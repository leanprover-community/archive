[
    {
        "content": "<p>At the moment we have one implementation for Finsupp, but i know that other ones are implemented outside mathlib with different required properties :</p>\n<ul>\n<li>i heard about one from <span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span>  that's computable, efficient, require Hashable and using HashMap</li>\n<li>i'm implementing one (also computable) that require LinearOrder and using TreeMap</li>\n<li>i saw one in CsLib</li>\n</ul>\n<p>So, to guide all these implementations and have some common lemmas for free, would it be interresting to have a class to bind them all ? like this ?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">FinsuppLike</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">FunLike</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Zero</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Zero</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">support</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">mem_supp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">support</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"n\">not_mem_supp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∉</span><span class=\"w\"> </span><span class=\"n\">support</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"n\">single</span><span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">F</span>\n<span class=\"w\">  </span><span class=\"bp\">...</span><span class=\"w\"> </span><span class=\"n\">other</span><span class=\"w\"> </span><span class=\"n\">common</span><span class=\"w\"> </span><span class=\"n\">operations</span>\n<span class=\"w\">  </span><span class=\"bp\">...</span><span class=\"w\"> </span><span class=\"n\">other</span><span class=\"w\"> </span><span class=\"n\">common</span><span class=\"w\"> </span><span class=\"n\">laws</span>\n</code></pre></div>",
        "id": 554996996,
        "sender_full_name": "Alfredo Moreira-Rosa",
        "timestamp": 1762896135
    },
    {
        "content": "<p>My first thought upon reading was: making a class for these surely defies the purpose of having multiple implementations, namely to have different performance specs?</p>\n<p>For the purpose of proving things, sure, this would work, but if you care about performance you need to consider the performance of the underlying implementations, and choose the one that best suits your purpose. In that case, figuring out which function is implemented in which way for which instance seems like more of a nuisance than anything... (compared to just plainly specifying the function you want)</p>\n<p>For proving stuff it could be beneficial, maybe as a way to turn operations in other implementations into a \"canonical\" choice of implementation which is suited for proving things about?</p>",
        "id": 554999575,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1762897726
    },
    {
        "content": "<p>I don't understand your thoughts about performance. A class would not impose any performance requirements.<br>\nExample, in my implementation, the real support is using TreeMap, but i defined an exposed support that is using Finset for the mathematical properties. The TreeMap is hidden from the user, the only thing that is exposed is that you need to provide a LinearOrder on <code>α</code>. But is not exposed at the class level.</p>\n<p>Can you expand a lithle more about your concerns about performance?</p>",
        "id": 555000094,
        "sender_full_name": "Alfredo Moreira-Rosa",
        "timestamp": 1762898018
    },
    {
        "content": "<p>as for the specific design, i suspect that rather than using <code>FunLike F α M</code>, we'd want to use something like <code>GetElem</code> (or just inline the whole operation) (particularly since (afaik) <code>HashMap</code>s don't implement <code>FunLike</code>?)</p>",
        "id": 555000288,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1762898120
    },
    {
        "content": "<p>The <code>F</code> here is not the <code>HashMap</code>, it's your <code>Finsupp</code> impl. And for sure your <code>Finsupp</code> impl should implement <code>FunLike</code></p>",
        "id": 555000438,
        "sender_full_name": "Alfredo Moreira-Rosa",
        "timestamp": 1762898224
    },
    {
        "content": "<p>I give you a MVW of my implementation as an example :</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">OrdFinsupp</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Zero</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">_</span><span class=\"n\">support</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">ExtTreeMap</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">M</span>\n<span class=\"w\">  </span><span class=\"bp\">_</span><span class=\"n\">ne_zero</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">support</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">support</span><span class=\"bp\">.</span><span class=\"n\">get?</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n\n<span class=\"kn\">infixr</span><span class=\"o\">:</span><span class=\"mi\">25</span><span class=\"w\"> </span><span class=\"s2\">\" ↦₀ \"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">OrdFinsupp</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">↦₀</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">._</span><span class=\"n\">support</span><span class=\"bp\">.</span><span class=\"n\">get?</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">m</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\">   </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FunLike</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">↦₀</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">apply</span>\n<span class=\"w\">  </span><span class=\"n\">coe_injective'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 555000772,
        "sender_full_name": "Alfredo Moreira-Rosa",
        "timestamp": 1762898423
    },
    {
        "content": "<p>You would then just have to link your implementation like this :</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FinsuppLike</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">↦₀</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">....</span>\n</code></pre></div>",
        "id": 555001065,
        "sender_full_name": "Alfredo Moreira-Rosa",
        "timestamp": 1762898597
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"942100\">Alfredo Moreira-Rosa</span> <a href=\"#narrow/channel/287929-mathlib4/topic/class.20for.20Finsupp.20like.20structures/near/555000438\">said</a>:</p>\n<blockquote>\n<p>The <code>F</code> here is not the <code>HashMap</code>, it's your <code>Finsupp</code> impl. And for sure your <code>Finsupp</code> impl should implement <code>FunLike</code></p>\n</blockquote>\n<p>for programming purposes, i'd say <code>HashMap</code> is very much like <code>Finsupp</code>, i.e. a way of storing some amount of data of some type indexed by some other type. There is an effective equivalence between <code>HashMap A B</code> (or <code>ExtHashMap A B</code> if you want to be pedantic) and <code>Finsupp A (WithZero B)</code>.</p>\n<p>As for my previous point, the issue i see is with <em>ergonomics</em>. If you want to write a performant program, it very possible that you need to use a certain implementation, where things like \"getting the value at the smallest index\" are efficient rather than \"reading out all values of the structure\" or \"reading out a single value of the structure\". It's easy for an abstraction like this to miss these kinds of highly specialized functions, which then are built up out of the basic operations which <em>are</em> stored in the class, at the cost of possible performance. However, <em>because of the abstraction</em>, it's not at all obvious that your implementation is not as performant as it could be, which seems like a tally against using the class to me.</p>\n<p>(a specific case i was considering is explained in detail in <a href=\"https://www.youtube.com/watch?v=6JxvKfSV9Ns\">this excellent video</a> on fibonacci heaps, which in my opinion are finsupp-like)</p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"6JxvKfSV9Ns\" href=\"https://www.youtube.com/watch?v=6JxvKfSV9Ns\"><img src=\"https://uploads.zulipusercontent.net/3120a6f270de877fad7b7da23b2ccf382e471214/68747470733a2f2f692e7974696d672e636f6d2f76692f364a78764b665356394e732f6d7164656661756c742e6a7067\"></a></div>",
        "id": 555003673,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1762900350
    },
    {
        "content": "<p>I still don't understand your point. I'm pretty sure exposing only math properties on <code>FinsuppLike</code> the way i did don't improse anything on the underlying implementation.<br>\nIt's pretty much the same as <code>CommGroup</code> don't impose anything on your <code>Nat</code> implementation. <br>\nThis is just saying, that a Finsupp should have a support and how it behaves when an element is in (is is not in) the support.<br>\nAnyway, thank you for the feedback.</p>",
        "id": 555006359,
        "sender_full_name": "Alfredo Moreira-Rosa",
        "timestamp": 1762902243
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"942100\">Alfredo Moreira-Rosa</span> <a href=\"#narrow/channel/287929-mathlib4/topic/class.20for.20Finsupp.20like.20structures/near/555006359\">said</a>:</p>\n<blockquote>\n<p>This is just saying, that a Finsupp should have a support and how it behaves when an element is in (is is not in) the support.</p>\n</blockquote>\n<p>But <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=DFinsupp#doc\">docs#DFinsupp</a> doesn't have a support in the way you describe (you can get one out when the domain has decidable equality and the codomain has decidable nezero)</p>",
        "id": 555020316,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1762913567
    },
    {
        "content": "<p>Thanks Aaron, I did not dive into <code>DFinsupp</code>.<br>\nBut my question still remains. Could we define a class to bind all implementations? That's the core of my question.<br>\nI think it would solve some difficulties we have to change these implementations, and allow more experimenting on them.<br>\nBut maybe that's not desirable.</p>",
        "id": 555065634,
        "sender_full_name": "Alfredo Moreira-Rosa",
        "timestamp": 1762938766
    },
    {
        "content": "<hr>\n<p>I just checked <code>DFinsupp</code> on my toy class and it don't pose any issue (you don't need to leak DecidableEq into the class):<br>\nhere my impl working just as with <code>Finsupp</code> and <code>DFinsupp</code> :</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- my impl</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">instFinsuppLikeOrdFinsupp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FinsuppLike</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">↦₀</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">support</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">OrdFinsupp</span><span class=\"bp\">.</span><span class=\"n\">support</span>\n<span class=\"w\">  </span><span class=\"n\">single</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">OrdFinsupp</span><span class=\"bp\">.</span><span class=\"n\">single</span>\n<span class=\"w\">  </span><span class=\"n\">mem_support</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">OrdFinsupp</span><span class=\"bp\">.</span><span class=\"n\">mem_support_iff</span>\n<span class=\"w\">  </span><span class=\"n\">zero_support</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">OrdFinsupp</span><span class=\"bp\">.</span><span class=\"n\">support_zero</span>\n\n<span class=\"c1\">-- Finsupp impl</span>\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">instFinsuppLikeFinsupp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FinsuppLike</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→₀</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">support</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Finsupp</span><span class=\"bp\">.</span><span class=\"n\">support</span>\n<span class=\"w\">  </span><span class=\"n\">single</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Finsupp</span><span class=\"bp\">.</span><span class=\"n\">single</span>\n<span class=\"w\">  </span><span class=\"n\">mem_support</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Finsupp</span><span class=\"bp\">.</span><span class=\"n\">mem_support_iff</span>\n<span class=\"w\">  </span><span class=\"n\">zero_support</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Finsupp</span><span class=\"bp\">.</span><span class=\"n\">support_zero</span>\n\n<span class=\"c1\">-- DFinsupp</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">instFinsuppLikeDFinsupp</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">FinsuppLike</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">DFinsupp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">support</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">DFinsupp</span><span class=\"bp\">.</span><span class=\"n\">support</span>\n<span class=\"w\">  </span><span class=\"n\">single</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">DFinsupp</span><span class=\"bp\">.</span><span class=\"n\">single</span>\n<span class=\"w\">  </span><span class=\"n\">mem_support</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">DFinsupp</span><span class=\"bp\">.</span><span class=\"n\">mem_support_iff</span>\n<span class=\"w\">  </span><span class=\"n\">zero_support</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">DFinsupp</span><span class=\"bp\">.</span><span class=\"n\">support_zero</span>\n</code></pre></div>\n<p>using the following class :</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">FinsuppLike</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">FunLike</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Zero</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Zero</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">support</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">M</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">single</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">F</span>\n<span class=\"w\">  </span><span class=\"n\">mem_support</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">support</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"n\">zero_support</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">support</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">∅</span>\n</code></pre></div>\n<p>And with those you can prove already a lot of the basic lemmas that could be shared with different implementations.</p>",
        "id": 555098741,
        "sender_full_name": "Alfredo Moreira-Rosa",
        "timestamp": 1762948423
    },
    {
        "content": "<p>Why are you trying to make an efficient <em>type</em>, rather than efficient <em>operations</em>?</p>",
        "id": 555099821,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1762948786
    },
    {
        "content": "<p>What do you have in mind ? Using efficient data structure gives efficient operations. So maybe i don't understand the question. Can you elaborate ?</p>",
        "id": 555100226,
        "sender_full_name": "Alfredo Moreira-Rosa",
        "timestamp": 1762948896
    },
    {
        "content": "<p>An inefficient representation forces inefficient operations, but I don't think an efficient representation will make you write efficient operations automagically. In this case, <code>DFinsupp</code> is an okay representation, and you can write rather efficient operations on it. I am not yet convinced you need a new, more efficient, representation.</p>",
        "id": 555101111,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1762949168
    },
    {
        "content": "<p>Can you make the above code a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>? I think you're still in trouble, because you'll conclude things like \"<code>DFinsupp</code> is only finsupp-like when the domain and codomain satisfy certain conditions\".</p>",
        "id": 555101349,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1762949236
    },
    {
        "content": "<p>Yes, my toy exemple was not made to adapt to <code>DFinsupp</code>. But rather to ask if having a class is something that is desirable or not.</p>\n<p>Don't focus too much on why i'm doing my own impl. I suspect Kim impl is much better than mine but i did not want to require Hashable, and LinearOrder seemed like a good tradeoff for me.</p>",
        "id": 555102333,
        "sender_full_name": "Alfredo Moreira-Rosa",
        "timestamp": 1762949522
    },
    {
        "content": "<p>So to clarify, i don't want to merge my impl on Mathlib, just asking if we want to have a class for this in Mathlib.<br>\nIf so i'm willing to work on it and discuss it here</p>",
        "id": 555102835,
        "sender_full_name": "Alfredo Moreira-Rosa",
        "timestamp": 1762949658
    },
    {
        "content": "<p>I think the point here is that the difficult bit is not choosing the right <em>implementation</em> for Finsupp given its API, but choosing an <em>API</em> that permits a performant implementation. By choosing the API in your typeclass you've already done this hard step, and you may as well just pick an efficient implementation of it and write <code>DFinsupp.toMyFinsupp</code> etc</p>",
        "id": 555105322,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1762950419
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>  is this enough of a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> ?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">section</span>\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">FinsuppLike</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">FunLike</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Zero</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Zero</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">support</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">M</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">single</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">F</span>\n<span class=\"w\">  </span><span class=\"n\">mem_support</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">support</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"n\">zero_support</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">support</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">∅</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">FinsuppLike</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Zero</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Zero</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">FunLike</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">FinsuppLike</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">DFunLike</span><span class=\"bp\">.</span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">h</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">ne_iff</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">FinsuppLike</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">DFunLike</span><span class=\"bp\">.</span><span class=\"n\">ne_iff</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">not_mem_support</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FinsuppLike</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∉</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">.</span><span class=\"n\">support</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">FinsuppLike</span><span class=\"bp\">.</span><span class=\"n\">mem_support</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">not_ne_iff</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">zero_apply</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">FinsuppLike</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">FinsuppLike</span><span class=\"bp\">.</span><span class=\"n\">not_mem_support</span><span class=\"bp\">.</span><span class=\"n\">mp</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">FinsuppLike</span><span class=\"bp\">.</span><span class=\"n\">zero_support</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">notMem_empty</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">h</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">FinsuppLike</span>\n</code></pre></div>",
        "id": 555105332,
        "sender_full_name": "Alfredo Moreira-Rosa",
        "timestamp": 1762950421
    },
    {
        "content": "<p>I meant one including your <code>instance instFinsuppLikeDFinsupp</code></p>",
        "id": 555105891,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1762950576
    },
    {
        "content": "<p>wasn't my code above enough, repeating it here :</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">DFinsupp</span><span class=\"bp\">.</span><span class=\"n\">Defs</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">FinsuppLike</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">FunLike</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Zero</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Zero</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">support</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">M</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">single</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">F</span>\n<span class=\"w\">  </span><span class=\"n\">mem_support</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">support</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"n\">zero_support</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">support</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">∅</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Zero</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">instFinsuppLikeDFinsupp</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">FinsuppLike</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">DFinsupp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">support</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">DFinsupp</span><span class=\"bp\">.</span><span class=\"n\">support</span>\n<span class=\"w\">  </span><span class=\"n\">single</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">DFinsupp</span><span class=\"bp\">.</span><span class=\"n\">single</span>\n<span class=\"w\">  </span><span class=\"n\">mem_support</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">DFinsupp</span><span class=\"bp\">.</span><span class=\"n\">mem_support_iff</span>\n<span class=\"w\">  </span><span class=\"n\">zero_support</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">DFinsupp</span><span class=\"bp\">.</span><span class=\"n\">support_zero</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 555106274,
        "sender_full_name": "Alfredo Moreira-Rosa",
        "timestamp": 1762950683
    },
    {
        "content": "<p><code>DecidableEq</code> is only needed for the <code>instance</code>, not the <code>FinsuppLike</code> declaration</p>",
        "id": 555107363,
        "sender_full_name": "Alfredo Moreira-Rosa",
        "timestamp": 1762951011
    },
    {
        "content": "<p>Edited <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> to separate <code>FinSuppLike</code> and <code>instance</code> requirements</p>",
        "id": 555108254,
        "sender_full_name": "Alfredo Moreira-Rosa",
        "timestamp": 1762951305
    },
    {
        "content": "<p>Right, so for your specification, <code>DFinsupp (fun _ : Nat =&gt; M')</code> for an arbirary type with zero <code>M'</code> is not Finsupp-like</p>",
        "id": 555110146,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1762951806
    },
    {
        "content": "<p>And I can't use <code>FinsuppLike.single</code> in that case, even though <code>DFinsupp.single</code> would work</p>",
        "id": 555110275,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1762951839
    },
    {
        "content": "<p>In this case, since only the impl is impacted, just changing it to makes it work for <code>M'</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Zero</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Decidable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)]</span>\n</code></pre></div>\n<p>For <code>single</code> issue, do you think it can be fixed ? any idea ? not worth it ?</p>",
        "id": 555113931,
        "sender_full_name": "Alfredo Moreira-Rosa",
        "timestamp": 1762952863
    },
    {
        "content": "<p>One fix would be to split <code>FinsuppLike</code> into a separate class for <code>single</code> and <code>support</code></p>",
        "id": 555124888,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1762955807
    }
]