[
    {
        "content": "<p>I'm looking for metaprogramming help on a macro which is intended to slightly extend the capabilities of <code>obtain</code>, letting it deal with equalities in products like <code>(x, 3) = (1, 3)</code> as if they were \"and\"-statements like <code>x = 1 ∧ 3 = 3</code>.  Here's what I have currently:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Prod.Basic</span>\n\n<span class=\"n\">macro_rules</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">obtain</span> <span class=\"bp\">$</span><span class=\"n\">pat</span><span class=\"bp\">?</span> <span class=\"bp\">$</span><span class=\"o\">[</span> <span class=\"o\">:</span>  <span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"o\">]</span><span class=\"bp\">?</span> <span class=\"o\">:=</span> <span class=\"bp\">$</span><span class=\"n\">val</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Prod.mk.inj_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span> <span class=\"bp\">;</span> <span class=\"n\">obtain</span> <span class=\"bp\">$</span><span class=\"n\">pat</span><span class=\"bp\">?</span> <span class=\"bp\">$</span><span class=\"o\">[</span> <span class=\"o\">:</span>  <span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"o\">]</span><span class=\"bp\">?</span> <span class=\"o\">:=</span> <span class=\"bp\">$</span><span class=\"n\">val</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>It works on a simple example like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">h1</span><span class=\"o\">,</span> <span class=\"n\">h2</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h</span>\n</code></pre></div>\n<p>producing the goal state</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>x : ℕ\nh1 : x = 1\nh2 : 3 = 3\n⊢ False\n</code></pre></div>",
        "id": 350206586,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1681586072
    },
    {
        "content": "<p>But the <code>rw ... at *</code> is obviously too heavy-handed. Here's an example of why:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"mi\">4</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">)):</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">obtain</span> <span class=\"n\">h1</span> <span class=\"bp\">|</span> <span class=\"n\">h2</span> <span class=\"o\">:=</span> <span class=\"n\">h</span>\n</code></pre></div>\n<p>The current version of the macro produces the goal state</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>x y z w : ℕ\nh' : 3 = z ∧ 4 = w\nh1 : x = 1 ∧ 3 = 3\n⊢ False\n\nx y z w : ℕ\nh' : 3 = z ∧ 4 = w\nh2 : y = 2\n⊢ False\n</code></pre></div>\n<p>whereas I'd like it to produce the goal state</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>x y z w : ℕ\nh' : (3, 4) = (z, w)\nh1 : (x, 3) = (1, 3)\n⊢ False\n\nx y z w : ℕ\nh' : (3, 4) = (z, w)\nh2 : y = 2\n⊢ False\n</code></pre></div>",
        "id": 350206678,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1681586162
    },
    {
        "content": "<p>Could I get some help adjusting my macro?  Effectively I want it to perform</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">replace</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">Iff.mp</span> <span class=\"n\">Prod.mk.inj_iff</span> <span class=\"n\">h</span>\n<span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">h1</span><span class=\"o\">,</span> <span class=\"n\">h2</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h</span>\n</code></pre></div>\n<p>if the <code>$val</code> in the macro is a named hypothesis <code>h</code>, and </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">Iff.mp</span> <span class=\"n\">Prod.mk.inj_iff</span> <span class=\"bp\">$</span><span class=\"n\">val</span>\n<span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">h1</span><span class=\"o\">,</span> <span class=\"n\">h2</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h</span>\n</code></pre></div>\n<p>if the <code>$val</code> in the macro is some compound term.</p>",
        "id": 350207019,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1681586364
    },
    {
        "content": "<p>Right now for simple-enough hypotheses (where the induced equalities are either between variables or between things that are defeq), it \"works\"</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">h1</span><span class=\"o\">,</span> <span class=\"n\">h2</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h</span>\n<span class=\"c\">/-</span><span class=\"cm\"> y: ℕ</span>\n<span class=\"cm\">   h': 1 = y</span>\n<span class=\"cm\">   ⊢ False -/</span>\n</code></pre></div>\n<p>though that <code>obtain</code> is equivalent to doing <code>obtain ⟨⟩ := h</code>, since these rcases patterns ignore any unused variables. Here we're asking <code>obtain</code> to do cases on <code>h</code>.</p>",
        "id": 350208675,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681587472
    },
    {
        "content": "<p>I wonder if it would be possible to extend rcases patterns to have another type of pattern specifically for equalities. Like maybe you could do <code>obtain rfl h1 h2 := h</code>, where <code>rfl</code> takes some number of arguments to name hypotheses for each component in the constructor injectivity lemma.</p>",
        "id": 350208803,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681587534
    },
    {
        "content": "<p>For your other example, it might look like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"mi\">4</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">)):</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">obtain</span> <span class=\"n\">rfl</span> <span class=\"n\">h1</span> <span class=\"n\">_</span> <span class=\"bp\">|</span> <span class=\"n\">h2</span> <span class=\"o\">:=</span> <span class=\"n\">h</span>\n<span class=\"c\">/-</span><span class=\"cm\"> Goal 1</span>\n<span class=\"cm\">   x y z w: ℕ</span>\n<span class=\"cm\">   h': (3, 4) = (z, w)</span>\n<span class=\"cm\">   h1: x = 1</span>\n<span class=\"cm\">   ⊢ False</span>\n\n<span class=\"cm\">   Goal 2</span>\n<span class=\"cm\">   x y z w: ℕ</span>\n<span class=\"cm\">   h': (3, 4) = (z, w)</span>\n<span class=\"cm\">   h2: y = 2</span>\n<span class=\"cm\">   ⊢ False -/</span>\n</code></pre></div>\n<p>(underscore in that <code>rfl</code> since we don't care about <code>3 = 3</code>)</p>",
        "id": 350209004,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681587678
    },
    {
        "content": "<p>I'm actually less interested in a principled approach with flexible syntax than in a hack that would work in this precise example, allowing me to pretend that <code>(x, 3) = (1, 3)</code> means <code>x = 1 \\and 3 = 3</code> <em>by definition</em> -- this is for teaching :)</p>",
        "id": 350209401,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1681587995
    },
    {
        "content": "<p>I get that -- I just don't have any good ideas myself for getting a hack to work that won't have unexpected consequences</p>",
        "id": 350209551,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681588093
    },
    {
        "content": "<p>but maybe to answer your immediate question, <code> `(tactic| obtain $pat? $[ :  $ty]? := $val:ident)</code> should let you match on the case you were asking about</p>",
        "id": 350209653,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681588182
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> I haven't tested it (and I didn't adapt it to your <code>Iff.mp ...</code> formulation), but maybe this will help?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">macro_rules</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">obtain</span> <span class=\"bp\">$</span><span class=\"n\">pat</span><span class=\"bp\">?</span> <span class=\"bp\">$</span><span class=\"o\">[</span> <span class=\"o\">:</span>  <span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"o\">]</span><span class=\"bp\">?</span> <span class=\"o\">:=</span> <span class=\"bp\">$</span><span class=\"n\">val</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"k\">if</span> <span class=\"n\">Syntax.isIdent</span> <span class=\"n\">val</span> <span class=\"k\">then</span>\n    <span class=\"k\">let</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">val.raw.getId</span>\n    <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Prod.mk.inj_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">mkIdent</span> <span class=\"n\">h</span><span class=\"o\">):</span><span class=\"n\">ident</span> <span class=\"bp\">;</span> <span class=\"n\">obtain</span> <span class=\"bp\">$</span><span class=\"n\">pat</span><span class=\"bp\">?</span> <span class=\"bp\">$</span><span class=\"o\">[</span> <span class=\"o\">:</span>  <span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"o\">]</span><span class=\"bp\">?</span> <span class=\"o\">:=</span> <span class=\"bp\">$</span><span class=\"n\">val</span><span class=\"o\">)</span>\n  <span class=\"k\">else</span>\n    <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"bp\">$</span><span class=\"n\">val</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Prod.mk.inj_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span> <span class=\"bp\">;</span> <span class=\"n\">obtain</span> <span class=\"bp\">$</span><span class=\"n\">pat</span><span class=\"bp\">?</span> <span class=\"bp\">$</span><span class=\"o\">[</span> <span class=\"o\">:</span>  <span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"o\">]</span><span class=\"bp\">?</span> <span class=\"o\">:=</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 350210185,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681588566
    },
    {
        "content": "<p>(There's probably a more elegant way to handle checking whether <code>val</code> is an identifier and getting its name, or better, an <code>Ident</code>.)</p>",
        "id": 350210235,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681588619
    }
]