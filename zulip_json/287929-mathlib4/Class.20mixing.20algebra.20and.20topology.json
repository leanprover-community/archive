[
    {
        "content": "<p>Hello, when I was working on isomorphism of topological groups, I was suggested not to mix class involving both algebra and topology, but then turn out that there are still things like this in mathlib, such as <code>ContinuousSemiLinearEquivClass</code>and <code>ContinuousLinearEquivClass</code>, I don't know if there are other things like this, should these be deprecated and reconstructed?</p>",
        "id": 482745545,
        "sender_full_name": "Nailin Guan",
        "timestamp": 1731741348
    },
    {
        "content": "<p>I was once suggested to add instance to these but I don't think working on a thing that should be reconstructed soon is very reasonable. Is anybody already working on it or about  to work on it?</p>",
        "id": 482745630,
        "sender_full_name": "Nailin Guan",
        "timestamp": 1731741406
    },
    {
        "content": "<p>Your PR (<a href=\"https://github.com/leanprover-community/mathlib4/pull/18689\">#18689</a> for everyone else) is exactly the thing that <em>allows</em> us in the future to remove <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ContinuousSemilinearEquivClass#doc\">docs#ContinuousSemilinearEquivClass</a> if we choose. Indeed, in order to separate the algebra and topology in that class you need both the algebra piece (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SemilinearEquivClass#doc\">docs#SemilinearEquivClass</a>) and the topology piece (your <code>HomeomorphClass</code>).</p>\n<p>However, the decision to remove that combined class should not be part of your current PR (just for separation of concerns). This is why I asked you to add the instance. Until we do decide to remove that class, we should have the relevant API, and introducing one instance does not create a lot of work, neither at the time of writing nor of removal.</p>",
        "id": 482775521,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1731768053
    },
    {
        "content": "<p>To answer your question, nobody is working on it because <code>HomeomorphClass</code> doesn't exist yet.</p>",
        "id": 482775579,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1731768100
    },
    {
        "content": "<p>I met problem after this: without these classes, the coersion to it may be a mess, for example <code>ContinuousMulEquiv</code> to <code>ContinuousMonoidHom</code>, the composition and inverse of it may be difficult or need a lot of lemma, is there any way to resolve this?</p>",
        "id": 492942227,
        "sender_full_name": "Nailin Guan",
        "timestamp": 1736512860
    },
    {
        "content": "<p>This was initially for dealing with category with morphisms <code>ContinuousMonoidHom</code>, but it turned out having some difficulty.</p>",
        "id": 492943294,
        "sender_full_name": "Nailin Guan",
        "timestamp": 1736513256
    },
    {
        "content": "<p>I'm not sure I understand the problem. Can you be more specific about the issues you are encountering? There are certainly well-known issues regarding composition of <code>FunLike</code> morphisms (i.e., you just can't without coercing), and inverses with <code>EquivLike</code>.</p>",
        "id": 492975435,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1736523659
    },
    {
        "content": "<p>I mean in a category with morphisms <code>ContinuousMonoidHom</code>,  going from <code>ContinuousMulEquiv A B</code> to <code>Category.Iso A B</code> is having some problem, as I don't want to unfold or ext when proving <code>hom_inv_id</code> and <code>inv_hom_id</code></p>",
        "id": 493060117,
        "sender_full_name": "Nailin Guan",
        "timestamp": 1736567131
    },
    {
        "content": "<p>So you're having problems with concrete categories? I'm still not clear what your issue is. Can you provide a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> highlighting your problem please?</p>",
        "id": 493061984,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1736569116
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Topology</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">ContinuousMonoidHom</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Topology</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"n\">ProfiniteGrp</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">ContinuousMulEquiv</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/--The coercion from `ContinuousMulEquiv` to `ContinuousMonoidHom` induced by `toMonoidHom`-/</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">toContinuousMonoidHom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"bp\">≃ₜ*</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ContinuousMonoidHom</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n\n<span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">toMonoidHom</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"n\">continuous_toFun</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">continuous_toFun</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">toContinuousMonoidHom_toMonoidHom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"bp\">≃ₜ*</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">toContinuousMonoidHom</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">toMonoidHom</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">toContinuousMonoidHom_toContinuousMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"bp\">≃ₜ*</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">toContinuousMonoidHom</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">toContinuousMap</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ProfiniteGrp</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">≃ₜ*</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">≅</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">toContinuousMonoidHom</span>\n<span class=\"w\">  </span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"bp\">.</span><span class=\"n\">toContinuousMonoidHom</span>\n<span class=\"w\">  </span><span class=\"n\">hom_inv_id</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">inv_hom_id</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">ContinuousMulEquiv</span>\n</code></pre></div>",
        "id": 493069199,
        "sender_full_name": "Nailin Guan",
        "timestamp": 1736576449
    },
    {
        "content": "<p>I can't prove the two sorry easily without using <code>ext</code> and <code>show</code> only using the lemmas above.</p>",
        "id": 493070886,
        "sender_full_name": "Nailin Guan",
        "timestamp": 1736577910
    },
    {
        "content": "<p>There are several issues with what you have:</p>\n<ol>\n<li>You shouldn't be defining a coercion from the equiv to the hom. Instead you should define a coercion <code>toContinuousMonoidHom</code> assuming the two relevant hom <em>classes</em>.</li>\n<li>Then, unless we're missing instances for <code>ContinuousMulEquiv</code>, you will simply be able to coerce directly.</li>\n<li>You're using <code>ProfiniteGrp</code>, which is a <em>category</em>. You shouldn't be using type-level equivalences, as those act on the coercion to type of a <code>ProfiniteGrp</code>. Instead you should be using morphisms in the relevant category.</li>\n</ol>",
        "id": 493121383,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1736623358
    },
    {
        "content": "<p>For <code>1</code>, it's very resonable, thanks! For <code>2</code>, I think when design, the classes are enough to pick up these. For <code>3</code>, may I ask for a look at the end of my PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/16992\">#16992</a>, I am only wanting to make it a bit shorter by introduce the aux <code>ContinuousMulEquiv</code>, any suggestions about it? Thank you.</p>",
        "id": 493141689,
        "sender_full_name": "Nailin Guan",
        "timestamp": 1736643756
    },
    {
        "content": "<p>I think Kevin and I are saying the same thing. You should work at the category-theoretic level, not at the type level, and if you want, deduce the type level result from the categorical one.</p>\n<p>As far as your problem on <a href=\"https://github.com/leanprover-community/mathlib4/pull/16992\">#16992</a>, it seems to me like you want to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Functor.ReflectsIsomorphisms#doc\">docs#CategoryTheory.Functor.ReflectsIsomorphisms</a> to say that you've got this morphism in <code>ProfiniteGrp</code>, which, as a function, is a bijection (i.e., the image under the forgetful functor is an isomorphism in <code>Type</code>), and therefore the morphisms is an isomorphism of <code>ProfiniteGrp</code>. You should never need to explicitly prove the continuity of the inverse with this approach (nor indeed even construct the inverse).</p>",
        "id": 493149401,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1736651730
    },
    {
        "content": "<p>I added <code>toContinuousMonoidHom</code>, I think I resolved all the problems for now, thanks.</p>",
        "id": 494130671,
        "sender_full_name": "Nailin Guan",
        "timestamp": 1737029779
    }
]