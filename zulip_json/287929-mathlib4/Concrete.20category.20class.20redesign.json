[
    {
        "content": "<p>I have been running some experiments in redesigning the <code>ConcreteCategory</code> class so we don't have a mismatch between <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ConcreteCategory.instFunLike#doc\">docs#ConcreteCategory.instFunLike</a> based on the forgetful functor and the FunLike instance for the morphisms of a particular category, e.g. <code>RingHom.instFunLike</code>. Essentially, what I would like to do is to split off having a faithful forgetful functor <code>forget C : C --&gt; Type</code> from being a category where the homomorphisms are concretely implemented by <code>FunLike</code>s. (<a href=\"#narrow/channel/287929-mathlib4/topic/Fixing.20the.20.60erw.60.20hell.20around.20concrete.20categories/near/486318166\">Previous mention here.</a>)</p>\n<p>I started attempting this in the <a href=\"https://github.com/leanprover-community/mathlib4/tree/redesign-ConcreteCategory\">branch#redesign-ConcreteCategory</a>. The basic idea is to rename <code>ConcreteCategory</code> to <code>HasForget</code> and to introduce a new <code>ConcreteCategory</code> class parametrized by three things:</p>\n<ul>\n<li><code>FC : C -&gt; C -&gt; Type*</code> maps the categorical type of <code>Hom</code>s, for example <code>RingCat.Hom</code> to the concrete type of maps, for example <code>RingHom</code>,</li>\n<li><code>CC : C -&gt; Type*</code> maps objects of <code>C</code> to the concrete carriers,</li>\n<li>and an instance <code>‚àÄ X Y, FunLike (FC X Y) (CC X) (CC Y)</code>.<br>\nThen we'd have fields asserting the coercion from <code>Hom</code>s to functions, via <code>FC</code>, preserves the identity and composition.</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span><span class=\"w\"> </span><span class=\"n\">ConcreteCategory</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">FC</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">CC</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">FunLike</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">FC</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">CC</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">CC</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">FC</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">ofHom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">FC</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hom_ofHom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FC</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ofHom</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">aesop_cat</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">ofHom_hom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">ofHom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">aesop_cat</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hom_id_apply</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CC</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">ùüô</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">aesop_cat</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hom_comp_apply</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CC</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">),</span>\n<span class=\"w\">    </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">aesop_cat</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Previously I tried doing this slightly differently, parametrizing <code>ConcreteCategory</code> over instances of <code>CoeSort C (Type w)</code> and <code>CoeFun (X ‚ü∂ Y) (X -&gt; Y)</code>. This did not work as well, since those coercions will be unfolded to e.g. <code>Bundled.…ë</code> if we work with e.g. <code>RingCat</code>, but if the instances are free variables they can't be unfolded and we see <code>CoeSort.coe</code>. Having the carrier as a free variable will fix this (at the expense of making the discrimination tree less keyed).</p>\n<p>Note that <code>ConcreteCategory</code> and <code>HasForget</code> as defined here are logically equivalent: the difference lies in their elaboration properties.</p>\n<p>Everything seems to go somewhat smoothly, albeit tediously, until we need to put this <code>ConcreteCategory</code> structure on <code>Type</code>: giving a <code>CC</code> and <code>FC</code> are no problem, but there is no <code>FunLike</code> instance on plain functions! We want the coercion of <code>f : X -&gt; Y</code> to <code>X -&gt; Y</code> to be <code>f</code> itself, not <code>FunLike.toFun f</code>. So probably in this setup it doesn't make sense to talk about <code>Type</code> as a concrete category. Since we have no such problem with <code>HasForget</code>, that's still logically okay: we can prove things for <code>HasForget</code> and then manually transfer them to <code>Type</code> like we currently have to do for each concrete category.</p>\n<p>Where it gets a bit more tricky is when we want to work with presheaves that can be valued in <code>Type</code> or in other concrete categories, but the natural way to phrase properties involves the full <code>ConcreteCategory</code> structure with its coercions. For example <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Presheaf.IsLocallyInjective#doc\">docs#CategoryTheory.Presheaf.IsLocallyInjective</a> is defined to be about <code>(forget D).obj (F‚ÇÅ.obj X)</code>, which would become <code>CC (F‚ÇÅ.obj X)</code> in the refactored version. But the concrete category <code>D</code> here is commonly also <code>Type</code>, so with this design we'll need to keep the <code>HasForget</code> version and set up aliases to use lemmas seamlessly for both <code>Type</code> and general <code>ConcreteCategory</code>.</p>",
        "id": 489288721,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1734368143
    },
    {
        "content": "<p>I think this is definitely a path worth pursuing, although I would like to make sure I'm not missing something that would make it possible to incorporate <code>Type</code> with the other concrete categories.</p>\n<p>Thoughts?</p>",
        "id": 489288954,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1734368198
    },
    {
        "content": "<p>Tagging <span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> <span class=\"user-mention\" data-user-id=\"459699\">@Jo√´l Riou</span> <span class=\"user-mention\" data-user-id=\"648495\">@Christian Merten</span> who have authored a lot of concrete categories recently. <span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span> might also be interested?</p>",
        "id": 489289134,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1734368243
    },
    {
        "content": "<blockquote>\n<p>Previously I tried doing this slightly differently, parametrizing¬†<code>ConcreteCategory</code>¬†over instances of¬†<code>CoeSort C (Type w)</code>¬†and¬†<code>CoeFun (X ‚ü∂ Y) (X -&gt; Y)</code>. This did not work as well, since those coercions will be unfolded to e.g.¬†<code>Bundled.…ë</code>¬†if we work with e.g.¬†<code>RingCat</code>, but if the instances are free variables they can't be unfolded and we see¬†<code>CoeSort.coe</code>. Having the carrier as a free variable will fix this (at the expense of making the discrimination tree less keyed).</p>\n</blockquote>\n<p>A naive thought: what about keeping the <code>CC</code> argument and replacing the <code>FunLike</code> by <code>CoeFun (X ‚ü∂ Y) (CC X -&gt; CC Y)</code>?</p>",
        "id": 489290199,
        "sender_full_name": "Christian Merten",
        "timestamp": 1734368531
    },
    {
        "content": "<p>i suspect that then you get the same issue? from my understanding, <code>FunLike</code> is basically <code>CoeFun</code> with the added condition that the coercion is injective...</p>",
        "id": 489291528,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1734368872
    },
    {
        "content": "<blockquote>\n<p>probably in this setup it doesn't make sense to talk about <code>Type</code> as a concrete category.</p>\n</blockquote>\n<p>I think it would be very problematic if <code>Type</code> was no longer a concrete category.</p>",
        "id": 489293241,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1734369288
    },
    {
        "content": "<p>No, <code>CoeFun.coe</code> is inlined as I <a href=\"#narrow/channel/287929-mathlib4/topic/Fixing.20the.20.60erw.60.20hell.20around.20concrete.20categories/near/482999391\">learned recently</a>. My point is that a <code>CoeFun (X -&gt; Y) (fun _ =&gt; X -&gt; Y)</code> should not have the issue that Anne describes here:</p>\n<blockquote>\n<p>but there is no¬†<code>FunLike</code>¬†instance on plain functions! We want the coercion of¬†<code>f : X -&gt; Y</code>¬†to¬†<code>X -&gt; Y</code>¬†to be¬†<code>f</code>¬†itself, not¬†<code>FunLike.toFun f</code></p>\n</blockquote>\n<p>Making <code>Type</code> a <code>ConcreteCategory</code> again. And with <code>CC</code>instead of <code>CoeSort</code> there will be no <code>CoeSort.coe</code>.</p>",
        "id": 489309433,
        "sender_full_name": "Christian Merten",
        "timestamp": 1734372864
    },
    {
        "content": "<p>Of course in the general setup, the <code>CoeFun</code> can't be unfolded so it will behave like <code>FunLike</code>.</p>",
        "id": 489309905,
        "sender_full_name": "Christian Merten",
        "timestamp": 1734372997
    },
    {
        "content": "<p>Alternatively one could keep both <code>CC</code> and <code>FC</code> and just replace <code>FunLike (FC X Y) (CC X) (CC Y)</code> by <code>CoeFun (FC X Y) (fun _ =&gt; CC X -&gt; CC Y)</code>.</p>",
        "id": 489310297,
        "sender_full_name": "Christian Merten",
        "timestamp": 1734373108
    },
    {
        "content": "<p>Are there any <code>simp</code> lemmas about concrete categories? If you use coercions that expand at elaboration time, then <code>simp</code> lemmas will no longer match.</p>",
        "id": 489357730,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1734388127
    },
    {
        "content": "<p>Yes there are and I think it is even worse, they don't even apply with <code>rw</code>. So indeed, my suggestion does not work. <code>CoeFun</code> does not seem to be the right tool for this type of abstraction.</p>",
        "id": 489359574,
        "sender_full_name": "Christian Merten",
        "timestamp": 1734388783
    },
    {
        "content": "<p><code>CoeFun</code> unfolds too.</p>",
        "id": 489359694,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1734388819
    },
    {
        "content": "<p>That's why I say it does not seem to be the right tool here. Am I misunderstanding you?</p>",
        "id": 489359846,
        "sender_full_name": "Christian Merten",
        "timestamp": 1734388887
    },
    {
        "content": "<p>Sorry, I've missed \"not\" in your message.</p>",
        "id": 489359894,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1734388908
    },
    {
        "content": "<p><span aria-label=\"man facepalming\" class=\"emoji emoji-1f926-200d-2642\" role=\"img\" title=\"man facepalming\">:man_facepalming:</span></p>",
        "id": 489359918,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1734388915
    },
    {
        "content": "<p>If we make morphisms in <code>Type u</code> one field structures, which we might want to do anyways, it would fit Anne's redesigned concrete categories again by setting <code>FC X Y = Hom X Y</code> and defining <code>FunLike (Hom X Y) X Y</code>.</p>",
        "id": 489361398,
        "sender_full_name": "Christian Merten",
        "timestamp": 1734389486
    },
    {
        "content": "<p>I can check how much pain we cause by changing the <code>Type</code> category to use the <code>Hom</code> structures. I suppose an alternative is to make <code>X -&gt; Y</code> a local <code>FunLike</code> instance in the way that we currently have a local <code>ConcreteCategory.instFunLike</code> to open.</p>",
        "id": 489444107,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1734428910
    },
    {
        "content": "<p>Answer to the first question: a lot of pain, and it doesn't help to try and combine this with the <code>ConcreteCategory</code> class. I'll try the no-op <code>FunLike</code> now.</p>",
        "id": 489477977,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1734439923
    },
    {
        "content": "<p>This also runs into difficulties, unfortunately: to apply results about <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Functor.id#doc\">docs#CategoryTheory.Functor.id</a> to <code>forget Type</code> we want these two to be <code>with_reducible rfl</code>, and if we want to define the forgetful functor using a <code>ConcreteCategory</code> instance, then we only get a <code>with_reducible_and_instances rfl</code>.</p>",
        "id": 489487868,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1734442860
    },
    {
        "content": "<p>Unless of course we use forgetful inheritance between <code>HasForget</code> and <code>ConcreteCategory</code>...</p>",
        "id": 489487963,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1734442885
    },
    {
        "content": "<p>Nope, not going to work either, because that would break the defeq <code>(forget C).obj X = carrier X</code>, meaning we can't even state that <code>(forget C).map f = hom f</code> unless we insert a bunch of casts...</p>",
        "id": 489490184,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1734443543
    },
    {
        "content": "<p>I have been playing around with a few options, seeing if maybe we can get the reducible defeq between <code>ConcreteCategory.hasForget.forget</code>, <code>HasForget.types.forget</code> and <code>Functor.id Type</code> to work by brute force anyway.</p>\n<p>Option 1: make <code>ConcreteCategory.hom</code> and <code>DFunLike.coe</code> reducible:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.CategoryTheory.EpiMono</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.CategoryTheory.Functor.FullyFaithful</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.Data.Set.Operations</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.Tactic.PPWithUniv</span>\n\n<span class=\"kd\">set_option</span><span class=\"w\"> </span><span class=\"n\">autoImplicit</span><span class=\"w\"> </span><span class=\"n\">false</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span>\n\n<span class=\"kd\">universe</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"n\">w'</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">v'</span><span class=\"w\"> </span><span class=\"n\">v''</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">u'</span><span class=\"w\"> </span><span class=\"n\">u''</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> The `@[to_additive]` attribute is just a hint that expressions involving this instance can</span>\n<span class=\"cm\">  still be additivized. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">to_additive</span><span class=\"w\"> </span><span class=\"n\">existing</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory.types</span><span class=\"kd\">]</span>\n<span class=\"kd\">instance</span><span class=\"w\"> </span><span class=\"n\">types</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LargeCategory</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">Hom</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"w\">  </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">id</span>\n<span class=\"w\">  </span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">‚àò</span><span class=\"w\"> </span><span class=\"n\">f</span>\n\n<span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">types_hom</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n\n<span class=\"c1\">-- Porting note (https://github.com/leanprover-community/mathlib4/issues/10688): this lemma was not here in Lean 3. Lean 3 `ext` would solve this goal</span>\n<span class=\"c1\">-- because of its \"if all else fails, apply all `ext` lemmas\" policy,</span>\n<span class=\"c1\">-- which apparently we want to move away from.</span>\n<span class=\"kd\">@[</span><span class=\"n\">ext</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">types_ext</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">funext</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"sd\">/-- Class for categories `C` with a fixed faithful functor `forget : C ‚•§ Type`.</span>\n\n<span class=\"sd\">This forgetful functor should not be used to cast objects or morphisms to</span>\n<span class=\"sd\">types or functions respectively: see `ConcreteCategory` for that.</span>\n\n<span class=\"sd\">Note that `HasForget` potentially depends on three independent universe levels,</span>\n<span class=\"sd\">* the universe level `w` appearing in `forget : C ‚•§ Type w`</span>\n<span class=\"sd\">* the universe level `v` of the morphisms (i.e. we have a `Category.{v} C`)</span>\n<span class=\"sd\">* the universe level `u` of the objects (i.e `C : Type u`)</span>\n<span class=\"sd\">They are specified that order, to avoid unnecessary universe annotations.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">class</span><span class=\"w\"> </span><span class=\"n\">HasForget</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- We have a functor to Type -/</span>\n<span class=\"w\">  </span><span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"n\">forget</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚•§</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">w</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- That functor is faithful -/</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">forget_faithful</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">forget.Faithful</span><span class=\"o\">]</span>\n\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">inline</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">reducible</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">HasForget.forget</span>\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"kd\">instance</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">HasForget.forget_faithful</span>\n\n<span class=\"sd\">/-- The forgetful functor from a concrete category to `Type u`. -/</span>\n<span class=\"n\">abbrev</span><span class=\"w\"> </span><span class=\"n\">forget</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">HasForget</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚•§</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">HasForget.forget</span>\n\n<span class=\"c1\">-- this is reducible because we want `forget (Type u)` to unfold to `ùü≠ _`</span>\n<span class=\"kd\">@[</span><span class=\"n\">instance</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"n\">abbrev</span><span class=\"w\"> </span><span class=\"n\">HasForget.types</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HasForget</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">forget</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">ùü≠</span><span class=\"w\"> </span><span class=\"n\">_</span>\n\n<span class=\"kd\">class</span><span class=\"w\"> </span><span class=\"n\">ConcreteCategory</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">FC</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">CC</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">FunLike</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">FC</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">CC</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">CC</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">FC</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">ofHom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">FC</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hom_ofHom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FC</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ofHom</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">aesop_cat</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">ofHom_hom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">ofHom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">aesop_cat</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">id_apply</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CC</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">ùüô</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">aesop_cat</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">comp_apply</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CC</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">),</span>\n<span class=\"w\">    </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">aesop_cat</span><span class=\"o\">)</span>\n\n<span class=\"kn\">export</span><span class=\"w\"> </span><span class=\"n\">ConcreteCategory</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">id_apply</span><span class=\"w\"> </span><span class=\"n\">comp_apply</span><span class=\"o\">)</span>\n\n<span class=\"kn\">section</span>\n\n<span class=\"kd\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">CC</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">}</span>\n<span class=\"kd\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">FunLike</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">CC</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">CC</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)]</span>\n<span class=\"kd\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ConcreteCategory</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">CC</span><span class=\"o\">]</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">ConcreteCategory</span>\n\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">id_apply</span><span class=\"w\"> </span><span class=\"n\">comp_apply</span>\n\n<span class=\"sd\">/-- We can apply morphisms of concrete categories by first casting them down</span>\n<span class=\"sd\">to the base functions.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CoeFun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"n\">CC</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">CC</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"n\">f</span>\n\n<span class=\"kd\">lemma</span><span class=\"w\"> </span><span class=\"n\">hom_injective</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Function.Injective</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Function.LeftInverse.injective</span><span class=\"w\"> </span><span class=\"n\">ofHom_hom</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">ext</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kd\">lemma</span><span class=\"w\"> </span><span class=\"n\">hom_ext</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">hom_injective</span><span class=\"w\"> </span><span class=\"n\">h</span>\n\n<span class=\"n\">abbrev</span><span class=\"w\"> </span><span class=\"n\">toHasForget</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HasForget</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">forget.obj</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">CC</span>\n<span class=\"w\">  </span><span class=\"n\">forget.map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">‚áë</span><span class=\"o\">(</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">forget_faithful.map_injective</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hom_injective</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">DFunLike.coe_injective</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span>\n\n<span class=\"kd\">end</span><span class=\"w\"> </span><span class=\"n\">ConcreteCategory</span>\n\n<span class=\"kn\">section</span>\n\n<span class=\"kd\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- Build a coercion to functions out of `HasForget`.</span>\n\n<span class=\"sd\">The intended usecase is to provide a `FunLike` instance in `HasForget.toConcreteCategory`.</span>\n<span class=\"sd\">See that definition for the considerations in making this an instance.</span>\n<span class=\"sd\">-/</span>\n<span class=\"n\">abbrev</span><span class=\"w\"> </span><span class=\"n\">HasForget.toFunLike</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">HasForget</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">FunLike</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">forget</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">forget</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">forget</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span>\n<span class=\"w\">  </span><span class=\"n\">coe_injective'</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Functor.Faithful.map_injective</span><span class=\"w\"> </span><span class=\"n\">h</span>\n\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"kn\">local</span><span class=\"w\"> </span><span class=\"kd\">instance</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">HasForget.toFunLike</span>\n<span class=\"sd\">/-- Build a concrete category out of `HasForget`.</span>\n\n<span class=\"sd\">The intended usecase is to prove theorems referencing only `(forget C)`</span>\n<span class=\"sd\">and not `(forget C).obj X` nor `(forget C).map f`: those should be written</span>\n<span class=\"sd\">as `CC X` and `ConcreteCategory.hom f` respectively.</span>\n<span class=\"sd\">-/</span>\n<span class=\"n\">abbrev</span><span class=\"w\"> </span><span class=\"n\">HasForget.toConcreteCategory</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">HasForget</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">ConcreteCategory</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">¬∑</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"bp\">¬∑</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"w\">  </span><span class=\"n\">ofHom</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"w\">  </span><span class=\"n\">id_apply</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">congr_fun</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">forget</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map_id</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">comp_apply</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">congr_fun</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">forget</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map_comp</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">)</span>\n\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"kn\">local</span><span class=\"w\"> </span><span class=\"kd\">instance</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">HasForget.toConcreteCategory</span>\n\n<span class=\"sd\">/-- Check that the new `ConcreteCategory` has the same forgetful functor as we started with. -/</span>\n<span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HasForget</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">@</span><span class=\"n\">forget</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">HasForget.toConcreteCategory</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toHasForget</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">forget</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">with_reducible_and_instances</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"sd\">/-- In particular, this should work for the category of types. -/</span>\n<span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">@</span><span class=\"n\">forget</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">HasForget.toConcreteCategory</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toHasForget</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">forget</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">HasForget.types</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">with_reducible_and_instances</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"c1\">-- Fails at `with_reducible`</span>\n\n<span class=\"sd\">/-- In addition, `forget Type` should be the identity functor. -/</span>\n<span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">@</span><span class=\"n\">forget</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">HasForget.toConcreteCategory</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toHasForget</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Functor.id</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">with_reducible_and_instances</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"c1\">-- Fails at `with_reducible`</span>\n\n<span class=\"kd\">set_option</span><span class=\"w\"> </span><span class=\"n\">allowUnsafeReducibility</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">reducible</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">ConcreteCategory.hom</span><span class=\"w\"> </span><span class=\"n\">DFunLike.coe</span>\n\n<span class=\"sd\">/-- In particular, this should work for the category of types. -/</span>\n<span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">@</span><span class=\"n\">forget</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">HasForget.toConcreteCategory</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toHasForget</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">forget</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">HasForget.types</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">with_reducible</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"sd\">/-- In addition, `forget Type` should be the identity functor. -/</span>\n<span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">@</span><span class=\"n\">forget</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">HasForget.toConcreteCategory</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toHasForget</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Functor.id</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">with_reducible</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 489733736,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1734520599
    },
    {
        "content": "<p>Option 2 is to make a one-field structure <code>Types.Hom</code> that wraps plain functions, and then try to put a <code>ConcreteCategory</code> instance on that. But the outcome is even worse:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.CategoryTheory.EpiMono</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.CategoryTheory.Functor.FullyFaithful</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.Data.Set.Operations</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.Tactic.PPWithUniv</span>\n\n<span class=\"kd\">set_option</span><span class=\"w\"> </span><span class=\"n\">autoImplicit</span><span class=\"w\"> </span><span class=\"n\">false</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span>\n\n<span class=\"kd\">universe</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"n\">w'</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">v'</span><span class=\"w\"> </span><span class=\"n\">v''</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">u'</span><span class=\"w\"> </span><span class=\"n\">u''</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">ext</span><span class=\"kd\">]</span>\n<span class=\"kd\">structure</span><span class=\"w\"> </span><span class=\"n\">Types.Hom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">where</span><span class=\"w\"> </span><span class=\"kn\">private</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">::</span>\n<span class=\"w\">  </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Y</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> The `@[to_additive]` attribute is just a hint that expressions involving this instance can</span>\n<span class=\"cm\">  still be additivized. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">to_additive</span><span class=\"w\"> </span><span class=\"n\">existing</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory.types</span><span class=\"kd\">]</span>\n<span class=\"kd\">instance</span><span class=\"w\"> </span><span class=\"n\">types</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LargeCategory</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">Hom</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Types.Hom</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"w\">  </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">‚ü®</span><span class=\"n\">id</span><span class=\"o\">‚ü©</span>\n<span class=\"w\">  </span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">‚ü®</span><span class=\"n\">g.hom</span><span class=\"w\"> </span><span class=\"bp\">‚àò</span><span class=\"w\"> </span><span class=\"n\">f.hom</span><span class=\"o\">‚ü©</span>\n\n<span class=\"n\">abbrev</span><span class=\"w\"> </span><span class=\"n\">types.ofHom</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">‚ü®</span><span class=\"n\">f</span><span class=\"o\">‚ü©</span>\n\n<span class=\"c1\">-- Porting note (https://github.com/leanprover-community/mathlib4/issues/10688): this lemma was not here in Lean 3. Lean 3 `ext` would solve this goal</span>\n<span class=\"c1\">-- because of its \"if all else fails, apply all `ext` lemmas\" policy,</span>\n<span class=\"c1\">-- which apparently we want to move away from.</span>\n<span class=\"kd\">@[</span><span class=\"n\">ext</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">types_ext</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f.hom</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g.hom</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Types.Hom.ext</span>\n<span class=\"w\">  </span><span class=\"n\">funext</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"sd\">/-- Class for categories `C` with a fixed faithful functor `forget : C ‚•§ Type`.</span>\n\n<span class=\"sd\">This forgetful functor should not be used to cast objects or morphisms to</span>\n<span class=\"sd\">types or functions respectively: see `ConcreteCategory` for that.</span>\n\n<span class=\"sd\">Note that `HasForget` potentially depends on three independent universe levels,</span>\n<span class=\"sd\">* the universe level `w` appearing in `forget : C ‚•§ Type w`</span>\n<span class=\"sd\">* the universe level `v` of the morphisms (i.e. we have a `Category.{v} C`)</span>\n<span class=\"sd\">* the universe level `u` of the objects (i.e `C : Type u`)</span>\n<span class=\"sd\">They are specified that order, to avoid unnecessary universe annotations.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">class</span><span class=\"w\"> </span><span class=\"n\">HasForget</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- We have a functor to Type -/</span>\n<span class=\"w\">  </span><span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"n\">forget</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚•§</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">w</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- That functor is faithful -/</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">forget_faithful</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">forget.Faithful</span><span class=\"o\">]</span>\n\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">inline</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">reducible</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">HasForget.forget</span>\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"kd\">instance</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">HasForget.forget_faithful</span>\n\n<span class=\"sd\">/-- The forgetful functor from a concrete category to `Type u`. -/</span>\n<span class=\"n\">abbrev</span><span class=\"w\"> </span><span class=\"n\">forget</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">HasForget</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚•§</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">HasForget.forget</span>\n\n<span class=\"c1\">-- this is reducible because we want `forget (Type u)` to unfold to `ùü≠ _`</span>\n<span class=\"kd\">@[</span><span class=\"n\">instance</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"n\">abbrev</span><span class=\"w\"> </span><span class=\"n\">HasForget.types</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HasForget</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">forget</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">ùü≠</span><span class=\"w\"> </span><span class=\"n\">_</span>\n\n<span class=\"kd\">class</span><span class=\"w\"> </span><span class=\"n\">ConcreteCategory</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">FC</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">CC</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">FunLike</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">FC</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">CC</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">CC</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">FC</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">ofHom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">FC</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hom_ofHom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FC</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ofHom</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">aesop_cat</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">ofHom_hom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">ofHom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">aesop_cat</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">id_apply</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CC</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">ùüô</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">aesop_cat</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">comp_apply</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CC</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">),</span>\n<span class=\"w\">    </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">aesop_cat</span><span class=\"o\">)</span>\n\n<span class=\"kn\">export</span><span class=\"w\"> </span><span class=\"n\">ConcreteCategory</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">id_apply</span><span class=\"w\"> </span><span class=\"n\">comp_apply</span><span class=\"o\">)</span>\n\n<span class=\"kn\">section</span>\n\n<span class=\"kd\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">CC</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">}</span>\n<span class=\"kd\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">FunLike</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">CC</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">CC</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)]</span>\n<span class=\"kd\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ConcreteCategory</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">CC</span><span class=\"o\">]</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">ConcreteCategory</span>\n\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">id_apply</span><span class=\"w\"> </span><span class=\"n\">comp_apply</span>\n\n<span class=\"sd\">/-- We can apply morphisms of concrete categories by first casting them down</span>\n<span class=\"sd\">to the base functions.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CoeFun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"n\">CC</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">CC</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"n\">f</span>\n\n<span class=\"kd\">lemma</span><span class=\"w\"> </span><span class=\"n\">hom_injective</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Function.Injective</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Function.LeftInverse.injective</span><span class=\"w\"> </span><span class=\"n\">ofHom_hom</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">ext</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kd\">lemma</span><span class=\"w\"> </span><span class=\"n\">hom_ext</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">hom_injective</span><span class=\"w\"> </span><span class=\"n\">h</span>\n\n<span class=\"kd\">lemma</span><span class=\"w\"> </span><span class=\"n\">coe_ext_iff</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">‚Üî</span><span class=\"w\"> </span><span class=\"bp\">‚áë</span><span class=\"o\">(</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">‚áë</span><span class=\"o\">(</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">ConcreteCategory.hom_ext_iff.trans</span><span class=\"w\"> </span><span class=\"n\">DFunLike.coe_injective.eq_iff.symm</span>\n\n<span class=\"kd\">instance</span><span class=\"w\"> </span><span class=\"n\">types.instFunLike</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FunLike</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Types.Hom</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f.hom</span>\n<span class=\"w\">  </span><span class=\"n\">coe_injective'</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Types.Hom.ext</span><span class=\"w\"> </span><span class=\"n\">h</span>\n\n<span class=\"sd\">/-- The category of types as a concrete category. -/</span>\n<span class=\"kd\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ConcreteCategory</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">Types.Hom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"w\">  </span><span class=\"n\">ofHom</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kd\">lemma</span><span class=\"w\"> </span><span class=\"n\">hom_types_ofHom</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">types.ofHom</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">types.ofHom</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"n\">abbrev</span><span class=\"w\"> </span><span class=\"n\">toHasForget</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HasForget</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">forget.obj</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">CC</span>\n<span class=\"w\">  </span><span class=\"n\">forget.map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">types.ofHom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">forget_faithful.map_injective</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hom_injective</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"n\">using</span><span class=\"w\"> </span><span class=\"n\">congr_arg</span><span class=\"w\"> </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"n\">h</span>\n\n<span class=\"kd\">end</span><span class=\"w\"> </span><span class=\"n\">ConcreteCategory</span>\n\n<span class=\"kn\">section</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">ConcreteCategory</span>\n\n<span class=\"kd\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- Build a coercion to functions out of `HasForget`.</span>\n\n<span class=\"sd\">The intended usecase is to provide a `FunLike` instance in `HasForget.toConcreteCategory`.</span>\n<span class=\"sd\">See that definition for the considerations in making this an instance.</span>\n<span class=\"sd\">-/</span>\n<span class=\"n\">abbrev</span><span class=\"w\"> </span><span class=\"n\">HasForget.toFunLike</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">HasForget</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">FunLike</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">forget</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">forget</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">forget</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"w\">  </span><span class=\"n\">coe_injective'</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">forget_faithful.map_injective</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hom_ext</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">DFunLike.coe_injective</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">))</span>\n\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"kn\">local</span><span class=\"w\"> </span><span class=\"kd\">instance</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">HasForget.toFunLike</span>\n<span class=\"sd\">/-- Build a concrete category out of `HasForget`.</span>\n\n<span class=\"sd\">The intended usecase is to prove theorems referencing only `(forget C)`</span>\n<span class=\"sd\">and not `(forget C).obj X` nor `(forget C).map f`: those should be written</span>\n<span class=\"sd\">as `CC X` and `ConcreteCategory.hom f` respectively.</span>\n<span class=\"sd\">-/</span>\n<span class=\"n\">abbrev</span><span class=\"w\"> </span><span class=\"n\">HasForget.toConcreteCategory</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">HasForget</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">ConcreteCategory</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">¬∑</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"bp\">¬∑</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"w\">  </span><span class=\"n\">ofHom</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"w\">  </span><span class=\"n\">id_apply</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">DFunLike.congr_fun</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">forget</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map_id</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">comp_apply</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">DFunLike.congr_fun</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">forget</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map_comp</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">)</span>\n\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"kn\">local</span><span class=\"w\"> </span><span class=\"kd\">instance</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">HasForget.toConcreteCategory</span>\n\n<span class=\"sd\">/-- Check that the new `ConcreteCategory` has the same forgetful functor as we started with. -/</span>\n<span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HasForget</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">@</span><span class=\"n\">forget</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">HasForget.toConcreteCategory</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toHasForget</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">forget</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">with_reducible_and_instances</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"sd\">/-- In particular, this should work for the category of types. -/</span>\n<span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">@</span><span class=\"n\">forget</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">HasForget.toConcreteCategory</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toHasForget</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">forget</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">HasForget.types</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">with_reducible_and_instances</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"c1\">-- Fails at `with_reducible`</span>\n\n<span class=\"sd\">/-- In addition, `forget Type` should be the identity functor. -/</span>\n<span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">@</span><span class=\"n\">forget</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">HasForget.toConcreteCategory</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toHasForget</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Functor.id</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">with_reducible_and_instances</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"c1\">-- Fails at `with_reducible`</span>\n\n<span class=\"kd\">set_option</span><span class=\"w\"> </span><span class=\"n\">allowUnsafeReducibility</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">reducible</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">Quiver.Hom</span>\n\n<span class=\"c1\">-- But making `Quiver.Hom` reducible blows up everything, in particular instance synth.</span>\n<span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FunLike</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">forget</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">forget</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">fail_if_success</span><span class=\"w\"> </span><span class=\"n\">infer_instance</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">types.instFunLike</span>\n\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 489755380,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1734527728
    },
    {
        "content": "<p>Option 3 is to try replacing <code>HasForget.toConcreteCategory</code> with an instance specialized for <code>Type</code>. This has essentially the same issues as option 1 but additionally breaks the equality between <code>forget</code> and <code>Functor.id</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.CategoryTheory.EpiMono</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.CategoryTheory.Functor.FullyFaithful</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.Data.Set.Operations</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.Tactic.PPWithUniv</span>\n\n<span class=\"kd\">set_option</span><span class=\"w\"> </span><span class=\"n\">autoImplicit</span><span class=\"w\"> </span><span class=\"n\">false</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span>\n\n<span class=\"kd\">universe</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"n\">w'</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">v'</span><span class=\"w\"> </span><span class=\"n\">v''</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">u'</span><span class=\"w\"> </span><span class=\"n\">u''</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> The `@[to_additive]` attribute is just a hint that expressions involving this instance can</span>\n<span class=\"cm\">  still be additivized. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">to_additive</span><span class=\"w\"> </span><span class=\"n\">existing</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory.types</span><span class=\"kd\">]</span>\n<span class=\"kd\">instance</span><span class=\"w\"> </span><span class=\"n\">types</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LargeCategory</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">Hom</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"w\">  </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">id</span>\n<span class=\"w\">  </span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">‚àò</span><span class=\"w\"> </span><span class=\"n\">f</span>\n\n<span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">types_hom</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n\n<span class=\"c1\">-- Porting note (https://github.com/leanprover-community/mathlib4/issues/10688): this lemma was not here in Lean 3. Lean 3 `ext` would solve this goal</span>\n<span class=\"c1\">-- because of its \"if all else fails, apply all `ext` lemmas\" policy,</span>\n<span class=\"c1\">-- which apparently we want to move away from.</span>\n<span class=\"kd\">@[</span><span class=\"n\">ext</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">types_ext</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">funext</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"sd\">/-- Class for categories `C` with a fixed faithful functor `forget : C ‚•§ Type`.</span>\n\n<span class=\"sd\">This forgetful functor should not be used to cast objects or morphisms to</span>\n<span class=\"sd\">types or functions respectively: see `ConcreteCategory` for that.</span>\n\n<span class=\"sd\">Note that `HasForget` potentially depends on three independent universe levels,</span>\n<span class=\"sd\">* the universe level `w` appearing in `forget : C ‚•§ Type w`</span>\n<span class=\"sd\">* the universe level `v` of the morphisms (i.e. we have a `Category.{v} C`)</span>\n<span class=\"sd\">* the universe level `u` of the objects (i.e `C : Type u`)</span>\n<span class=\"sd\">They are specified that order, to avoid unnecessary universe annotations.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">class</span><span class=\"w\"> </span><span class=\"n\">HasForget</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- We have a functor to Type -/</span>\n<span class=\"w\">  </span><span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"n\">forget</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚•§</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">w</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- That functor is faithful -/</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">forget_faithful</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">forget.Faithful</span><span class=\"o\">]</span>\n\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">inline</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">reducible</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">HasForget.forget</span>\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"kd\">instance</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">HasForget.forget_faithful</span>\n\n<span class=\"sd\">/-- The forgetful functor from a concrete category to `Type u`. -/</span>\n<span class=\"n\">abbrev</span><span class=\"w\"> </span><span class=\"n\">forget</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">HasForget</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚•§</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">HasForget.forget</span>\n\n<span class=\"c1\">-- this is reducible because we want `forget (Type u)` to unfold to `ùü≠ _`</span>\n<span class=\"kd\">@[</span><span class=\"n\">instance</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"n\">abbrev</span><span class=\"w\"> </span><span class=\"n\">HasForget.types</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HasForget</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">forget</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">ùü≠</span><span class=\"w\"> </span><span class=\"n\">_</span>\n\n<span class=\"kd\">class</span><span class=\"w\"> </span><span class=\"n\">ConcreteCategory</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">FC</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">CC</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">FunLike</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">FC</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">CC</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">CC</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">FC</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">ofHom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">FC</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hom_ofHom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FC</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ofHom</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">aesop_cat</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">ofHom_hom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">ofHom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">aesop_cat</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">id_apply</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CC</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">ùüô</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">aesop_cat</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">comp_apply</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CC</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">),</span>\n<span class=\"w\">    </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">aesop_cat</span><span class=\"o\">)</span>\n\n<span class=\"kn\">export</span><span class=\"w\"> </span><span class=\"n\">ConcreteCategory</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">id_apply</span><span class=\"w\"> </span><span class=\"n\">comp_apply</span><span class=\"o\">)</span>\n\n<span class=\"kn\">section</span>\n\n<span class=\"kd\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">CC</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">}</span>\n<span class=\"kd\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">FunLike</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">CC</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">CC</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)]</span>\n<span class=\"kd\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ConcreteCategory</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">CC</span><span class=\"o\">]</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">ConcreteCategory</span>\n\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">id_apply</span><span class=\"w\"> </span><span class=\"n\">comp_apply</span>\n\n<span class=\"sd\">/-- We can apply morphisms of concrete categories by first casting them down</span>\n<span class=\"sd\">to the base functions.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CoeFun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"n\">CC</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">CC</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"n\">f</span>\n\n<span class=\"kd\">lemma</span><span class=\"w\"> </span><span class=\"n\">hom_injective</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Function.Injective</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Function.LeftInverse.injective</span><span class=\"w\"> </span><span class=\"n\">ofHom_hom</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">ext</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kd\">lemma</span><span class=\"w\"> </span><span class=\"n\">hom_ext</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">hom_injective</span><span class=\"w\"> </span><span class=\"n\">h</span>\n\n<span class=\"n\">abbrev</span><span class=\"w\"> </span><span class=\"n\">toHasForget</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HasForget</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">forget.obj</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">CC</span>\n<span class=\"w\">  </span><span class=\"n\">forget.map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">‚áë</span><span class=\"o\">(</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">forget_faithful.map_injective</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hom_injective</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">DFunLike.coe_injective</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span>\n\n<span class=\"kd\">end</span><span class=\"w\"> </span><span class=\"n\">ConcreteCategory</span>\n\n<span class=\"kn\">section</span>\n\n<span class=\"kd\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- Put a do-nothing `FunLike` structure on plain functions.</span>\n\n<span class=\"sd\">The intended usecase is to provide a `FunLike` instance in `types.toConcreteCategory`.</span>\n<span class=\"sd\">See that definition for the considerations in making this an instance.</span>\n<span class=\"sd\">-/</span>\n<span class=\"n\">abbrev</span><span class=\"w\"> </span><span class=\"n\">types.instFunLike</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">FunLike</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"w\">  </span><span class=\"n\">coe_injective'</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span>\n\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"kn\">local</span><span class=\"w\"> </span><span class=\"kd\">instance</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">types.instFunLike</span>\n\n<span class=\"sd\">/-- A `ConcreteCategory` instance for the category of types.</span>\n\n<span class=\"sd\">This unfortunately causes defeq issues, since it puts a new `HasForget` instance on `Type`;</span>\n<span class=\"sd\">the `forget` functor should be reducibly defeq to that of `HasForget.types` but also both of these</span>\n<span class=\"sd\">should be reducibly defeq to the identity functor on `Type`; we have not figured out how to achieve</span>\n<span class=\"sd\">all conditions simultaneously.</span>\n<span class=\"sd\">-/</span>\n<span class=\"n\">abbrev</span><span class=\"w\"> </span><span class=\"n\">types.instConcreteCategory</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">ConcreteCategory</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">¬∑</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"bp\">¬∑</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"w\">  </span><span class=\"n\">ofHom</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"w\">  </span><span class=\"n\">id_apply</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"n\">comp_apply</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"kn\">local</span><span class=\"w\"> </span><span class=\"kd\">instance</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">types.instConcreteCategory</span>\n\n<span class=\"sd\">/-- The two ways to get a forgetful functor should be equal. -/</span>\n<span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">@</span><span class=\"n\">forget</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">types.instConcreteCategory.toHasForget</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">forget</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">HasForget.types</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"c1\">-- Even fails at `with_reducible_and_instances`.</span>\n\n<span class=\"sd\">/-- The concrete category should have the identity functor as the forgetful functor. -/</span>\n<span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">@</span><span class=\"n\">forget</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">types.instConcreteCategory.toHasForget</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Functor.id</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"c1\">-- Even fails at `with_reducible_and_instances`.</span>\n\n<span class=\"sd\">/-- The `HasForget` instance should have the identity functor as the forgetful functor. -/</span>\n<span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">forget</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">HasForget.types</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Functor.id</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">with_reducible</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"c1\">-- In addition to option 1, we also need `Functor.id` to be reducible.</span>\n<span class=\"kd\">set_option</span><span class=\"w\"> </span><span class=\"n\">allowUnsafeReducibility</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">reducible</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">DFunLike.coe</span><span class=\"w\"> </span><span class=\"n\">ConcreteCategory.hom</span><span class=\"w\"> </span><span class=\"n\">Functor.id</span>\n\n<span class=\"sd\">/-- The two ways to get a forgetful functor should be equal. -/</span>\n<span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">@</span><span class=\"n\">forget</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">types.instConcreteCategory.toHasForget</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">forget</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">HasForget.types</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">with_reducible</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"sd\">/-- The concrete category should have the identity functor as the forgetful functor. -/</span>\n<span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">@</span><span class=\"n\">forget</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">types.instConcreteCategory.toHasForget</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Functor.id</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">with_reducible</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"sd\">/-- The `HasForget` instance should have the identity functor as the forgetful functor. -/</span>\n<span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">forget</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">HasForget.types</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Functor.id</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">with_reducible</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 489758691,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1734528822
    },
    {
        "content": "<p>And finally my least favourite Option 4, we bundle <code>HasForget</code> into <code>ConcreteCategory</code> and get heterogeneous equalities everywhere.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.CategoryTheory.EpiMono</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.CategoryTheory.Functor.FullyFaithful</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.Data.Set.Operations</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.Tactic.PPWithUniv</span>\n\n<span class=\"kd\">set_option</span><span class=\"w\"> </span><span class=\"n\">autoImplicit</span><span class=\"w\"> </span><span class=\"n\">false</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span>\n\n<span class=\"kd\">universe</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"n\">w'</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">v'</span><span class=\"w\"> </span><span class=\"n\">v''</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">u'</span><span class=\"w\"> </span><span class=\"n\">u''</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> The `@[to_additive]` attribute is just a hint that expressions involving this instance can</span>\n<span class=\"cm\">  still be additivized. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">to_additive</span><span class=\"w\"> </span><span class=\"n\">existing</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory.types</span><span class=\"kd\">]</span>\n<span class=\"kd\">instance</span><span class=\"w\"> </span><span class=\"n\">types</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LargeCategory</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">Hom</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"w\">  </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">id</span>\n<span class=\"w\">  </span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">‚àò</span><span class=\"w\"> </span><span class=\"n\">f</span>\n\n<span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">types_hom</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n\n<span class=\"c1\">-- Porting note (https://github.com/leanprover-community/mathlib4/issues/10688): this lemma was not here in Lean 3. Lean 3 `ext` would solve this goal</span>\n<span class=\"c1\">-- because of its \"if all else fails, apply all `ext` lemmas\" policy,</span>\n<span class=\"c1\">-- which apparently we want to move away from.</span>\n<span class=\"kd\">@[</span><span class=\"n\">ext</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">types_ext</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">funext</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"sd\">/-- Class for categories `C` with a fixed faithful functor `forget : C ‚•§ Type`.</span>\n\n<span class=\"sd\">This forgetful functor should not be used to cast objects or morphisms to</span>\n<span class=\"sd\">types or functions respectively: see `ConcreteCategory` for that.</span>\n\n<span class=\"sd\">Note that `HasForget` potentially depends on three independent universe levels,</span>\n<span class=\"sd\">* the universe level `w` appearing in `forget : C ‚•§ Type w`</span>\n<span class=\"sd\">* the universe level `v` of the morphisms (i.e. we have a `Category.{v} C`)</span>\n<span class=\"sd\">* the universe level `u` of the objects (i.e `C : Type u`)</span>\n<span class=\"sd\">They are specified that order, to avoid unnecessary universe annotations.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">class</span><span class=\"w\"> </span><span class=\"n\">HasForget</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- We have a functor to Type -/</span>\n<span class=\"w\">  </span><span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"n\">forget</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚•§</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">w</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- That functor is faithful -/</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">forget_faithful</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">forget.Faithful</span><span class=\"o\">]</span>\n\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">inline</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">reducible</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">HasForget.forget</span>\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"kd\">instance</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">HasForget.forget_faithful</span>\n\n<span class=\"sd\">/-- The forgetful functor from a concrete category to `Type u`. -/</span>\n<span class=\"n\">abbrev</span><span class=\"w\"> </span><span class=\"n\">forget</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">HasForget</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚•§</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">HasForget.forget</span>\n\n<span class=\"c1\">-- this is reducible because we want `forget (Type u)` to unfold to `ùü≠ _`</span>\n<span class=\"kd\">@[</span><span class=\"n\">instance</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"n\">abbrev</span><span class=\"w\"> </span><span class=\"n\">HasForget.types</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HasForget</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">forget</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">ùü≠</span><span class=\"w\"> </span><span class=\"n\">_</span>\n\n<span class=\"kd\">class</span><span class=\"w\"> </span><span class=\"n\">ConcreteCategory</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">FC</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">CC</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">FunLike</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">FC</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">CC</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">CC</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">FC</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">ofHom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">FC</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hom_ofHom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FC</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ofHom</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">aesop_cat</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">ofHom_hom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">ofHom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">aesop_cat</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">id_apply</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CC</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">ùüô</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">aesop_cat</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">comp_apply</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CC</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">),</span>\n<span class=\"w\">    </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">aesop_cat</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">toHasForget</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HasForget</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- This could be an autoparam, but I don't want to bother with that.</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">forget_obj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">toHasForget.forget</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">CC</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">forget_map</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HEq</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">toHasForget.forget</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚áë</span><span class=\"o\">(</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 489759346,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1734529042
    },
    {
        "content": "<p>Those are all the options I could come up with. None of them look particularly appealing. Assuming there is no other option, I believe we should continue with what I had before yesterday. That is: manually enable <code>HasForget.toConcreteCategory</code> whenever we really need to treat <code>Type</code> as a concrete category (instead of a <code>HasForget</code>). Since the equalities still hold on the <code>with_reducible_and_instances</code> level, most tactics won't break, and the main breakage from adding this instance locally is that some instance searches will fail due to looking for the wrong <code>forget</code>.</p>",
        "id": 489760067,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1734529275
    },
    {
        "content": "<p>Can we enumerate precise goals for this project?</p>",
        "id": 489762275,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1734530039
    },
    {
        "content": "<p>The issue I want to solve is that the current <code>ConcreteCategory</code> setup has two incompatible ways to talk about elements of a concrete category and mapping them. Namely, in the general way we have <code>ConcreteCategory.hasCoeToSort</code> and <code>ConcreteCategory.instFunLike</code>, while for a specific category such as <code>CommRingCat</code> we have <code>CommRingCat.carrier</code> and <code>CommRingCat.Hom.hom</code>.</p>\n<p>For a very concrete example, how can we make the following compile?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.Algebra.Category.Ring.Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.CategoryTheory.Elementwise</span>\n\n<span class=\"kd\">lemma</span><span class=\"w\"> </span><span class=\"n\">CommRingCat.inv_hom_apply</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CommRingCat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">‚âÖ</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">e.inv</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e.hom</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CategoryTheory.Iso.hom_inv_id_apply</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 489764941,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1734530811
    },
    {
        "content": "<p>simprocs?</p>",
        "id": 489765139,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1734530878
    },
    {
        "content": "<p>That could work, but then <code>rw</code> wouldn't. Although <code>rw</code> might be made to work using unification hints...</p>",
        "id": 489765434,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1734530962
    },
    {
        "content": "<p>Do we have precedent for <code>simp only</code> being ok while <code>rw</code> being not ok elsewhere?</p>",
        "id": 489765716,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1734531046
    },
    {
        "content": "<p>If we can't figure out a good principled solution, we could also write some meta program generating the specialized lemmas for <code>RingCat</code>, <code>ModuleCat</code>, etc.</p>",
        "id": 489765868,
        "sender_full_name": "Christian Merten",
        "timestamp": 1734531099
    },
    {
        "content": "<p>(Sorry, mixed up <code>hom_inv_id</code> and <code>inv_hom_id</code> while copying files. Now the example above fails for the right reason.)</p>",
        "id": 489765894,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1734531106
    },
    {
        "content": "<p>Another example, that I haven't been able to minimize, is that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=TopCat.Presheaf.restrictOpenCommRingCat#doc\">docs#TopCat.Presheaf.restrictOpenCommRingCat</a> requires a type hint <code>(C := CommRingCat)</code> in its definition, since unification can't figure this out from the problem <code>(forget ?C).obj X =?= CommRingCat.carrier X</code>. (Again something that we might solve using unification hints.)</p>",
        "id": 489766695,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1734531331
    },
    {
        "content": "<p>Unification hints seems to be able to solve the last example! <a href=\"https://github.com/leanprover-community/mathlib4/pull/20075\">#20075</a></p>",
        "id": 489975954,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1734618508
    },
    {
        "content": "<p>Here‚Äôs an update on concrete categories. I am now confident that we can redesign the implementation so that the defeq issues with <code>simp</code> failing, and <code>rw</code>s needing to be <code>erw</code>s, can be drastically reduced. The <a href=\"https://github.com/leanprover-community/mathlib4/tree/redesign-ConcreteCategory\">branch#redesign-ConcreteCategory</a> has seen quite a few experiments and I‚Äôve settled on something we can implement.</p>\n<p>My expertise in the end lies much more in the elaboration side of things than the categorical side of things. I tried to be as thorough as possible before committing to this. Still I probably have overlooked some difficulties. Feedback is always welcome!</p>\n<h2>The issues this redesign is trying to solve</h2>\n<p>Let's try and sum up what I want to do here. Concrete categories have the issue that we have several different ways to spell the same notion. Let <code>R S : CommRingCat</code> and <code>f : R ‚ü∂ S</code>. Then we can write <code>DFunLike.coe f.hom : R -&gt; S</code> using the FunLike machinery (and this will give us access to <code>RingHomClass</code> with <code>map_mul</code>, etc.), or we can write <code>(forget CommRingCat).map f : R ‚Üí S</code> and plug into the categorical mechanisms. These are definitionally equal, but not reducibly so. The same holds for converting objects to types: <code>Bundled.…ë R</code> versus <code>(forget CommRingCat).obj R</code>. Having non-reducibly defeq different ways to write the same thing means we end up with lots of <code>erw</code> in the library. And often if Lean sees <code>DFunLike.coe f =?= (forget ?).map ?</code> it can‚Äôt figure out which category we‚Äôre supposed to be working in.</p>\n<p>We can‚Äôt fix this by changing the way we define the coercion from concrete categories to types: <code>CoeFun</code> and <code>CoeSort</code> instances can be inlined, but not if those instances are free variables. For example if we write <code>variables [Category C] [ConcreteCategory C] (X : C)</code>, then the cast <code>X : Type</code> will not get unfolded.</p>\n<p>What we can do instead is unbundle the carrier and <code>FunLike</code> from the concrete category, and that‚Äôs what the refactor does.</p>\n<h2>Declaring concrete categories</h2>\n<p>The new <code>ConcreteCategory</code> class will look like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span><span class=\"w\"> </span><span class=\"n\">ConcreteCategory</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">FC</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">CC</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">FunLike</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">FC</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">CC</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">CC</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- Convert a morphism of `C` to a bundled function. -/</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">FC</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- Convert a bundled function to a morphism of `C`. -/</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">ofHom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">FC</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hom_ofHom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FC</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ofHom</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">aesop_cat</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">ofHom_hom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">ofHom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">aesop_cat</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">id_apply</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CC</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">ùüô</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">aesop_cat</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">comp_apply</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CC</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">),</span>\n<span class=\"w\">    </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">aesop_cat</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>This looks rather intimidating, but on the other hand, you should not need to interact with this complication in practical uses.</p>\n<p>Declaring a <code>ConcreteCategory</code> instance needs changes, but nothing as complicated as the above. E.g. the minimal change for <code>CommRingCat</code> is to go from</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ConcreteCategory</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">CommRingCat</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">forget</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">R</span>\n<span class=\"w\">      </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">f.hom</span><span class=\"w\"> </span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"n\">forget_faithful</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">‚ü®</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"n\">using</span><span class=\"w\"> </span><span class=\"n\">congrFun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">‚ü©</span>\n</code></pre></div>\n<p>to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ConcreteCategory</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">CommRingCat</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CommRingCat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">‚Üí+*</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Hom.hom</span>\n<span class=\"w\">  </span><span class=\"n\">ofHom</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ofHom</span>\n</code></pre></div>\n<p>As you can see, we now explicitly mention the type of bundled functions in <code>ConcreteCategory</code>. The carrier type can be unified from the FunLike instance. This should be enough to upgrade everything with minimal breakage.</p>\n<p>To really make use of the generalisation brought by concrete categories, we need one step extra: make <code>ConcreteCategory.hom</code> and <code>ConcreteCategory.ofHom</code> the primary ways of converting between the bundled functions and the category morphisms. For <code>CommRingCat</code>, this means that <code>Hom.hom</code> and <code>ofHom</code> are declared as aliases for the <code>ConcreteCategory</code> declarations:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"sd\">/-- The type of morphisms in `CommRingCat`. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">ext</span><span class=\"kd\">]</span>\n<span class=\"kd\">structure</span><span class=\"w\"> </span><span class=\"n\">Hom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CommRingCat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"kn\">private</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">::</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- The underlying ring hom. The preferred spelling is `f.hom`. -/</span>\n<span class=\"w\">  </span><span class=\"n\">hom'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">‚Üí+*</span><span class=\"w\"> </span><span class=\"n\">S</span>\n\n<span class=\"kd\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">CommRingCat</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">Hom</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Hom</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">S</span>\n<span class=\"w\">  </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">‚ü®</span><span class=\"n\">RingHom.id</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">‚ü©</span>\n<span class=\"w\">  </span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">‚ü®</span><span class=\"n\">g.hom'.comp</span><span class=\"w\"> </span><span class=\"n\">f.hom'</span><span class=\"o\">‚ü©</span>\n\n<span class=\"kd\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ConcreteCategory</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">CommRingCat</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">‚Üí+*</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Hom.hom'</span>\n<span class=\"w\">  </span><span class=\"n\">ofHom</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">‚ü®</span><span class=\"n\">f</span><span class=\"o\">‚ü©</span>\n\n<span class=\"sd\">/-- The underlying ring hom. -/</span>\n<span class=\"n\">abbrev</span><span class=\"w\"> </span><span class=\"n\">Hom.hom</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CommRingCat</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Hom</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">ConcreteCategory.hom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">CommRingCat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">f</span>\n\n<span class=\"sd\">/-- Typecheck a `RingHom` as a morphism in `CommRingCat`. -/</span>\n<span class=\"n\">abbrev</span><span class=\"w\"> </span><span class=\"n\">ofHom</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">‚Üí+*</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">ConcreteCategory.ofHom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">CommRingCat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">f</span>\n</code></pre></div>\n<p>Now all the elementwise lemmas will apply automatically:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span><span class=\"w\"> </span><span class=\"n\">inv_hom_apply</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CommRingCat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">‚âÖ</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">e.inv</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e.hom</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n\n<span class=\"kd\">lemma</span><span class=\"w\"> </span><span class=\"n\">hom_inv_apply</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CommRingCat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">‚âÖ</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">e.hom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e.inv</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n</code></pre></div>\n<h2>Parametrizing over concrete categories</h2>\n<p>Taking a <code>ConcreteCategory</code> as a parameter is a bit more verbose now. You get <code>variables</code> lines like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">FC</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">CC</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">}</span>\n<span class=\"kd\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">FunLike</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">FC</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">CC</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">CC</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)]</span>\n<span class=\"kd\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ConcreteCategory</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">FC</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>I tried looking for a way for <code>variables?</code> or similar metaprograms to generate this automatically, but it seems this is going to be a bit too complicated to make happen soon.</p>\n<p>Once you have gotten through the <code>variables</code> lines, working with concrete categories should be a lot nicer. The carrier type of an object <code>X</code> is written <code>ToType X</code>, and the bundled function underlying a morphism <code>f</code> is called <code>hom f</code> (and we have a <code>CoeFun</code> instance so that <code>f x</code> gets turned into <code>DFunLike.coe (hom f) x</code> automatically). In exchange for those more complicated <code>variable</code> lines, you don‚Äôt need to add <code>ConcreteCategory.instFunLike</code> and <code>ConcreteCategory.hasCoeToSort</code> as local instances. And of course you don‚Äôt need to worry about casting back and forth across <code>(forget _).map = DFunLike.coe _</code>. You can still write <code>forget C</code> for the forgetful functor.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- The equivalence `ToType (‚àè·∂ú F) ‚âÉ ‚àÄ j, ToType F j` if `F : J ‚Üí C` is a family of objects</span>\n<span class=\"sd\">in a concrete category `C`. -/</span>\n<span class=\"kd\">noncomputable</span><span class=\"w\"> </span><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">productEquiv</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ToType</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">‚àè·∂ú</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚âÉ</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ToType</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">((</span><span class=\"n\">PreservesProduct.iso</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">forget</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚â™‚â´</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Types.productIso</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">ToType</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">))))</span><span class=\"bp\">.</span><span class=\"n\">toEquiv</span>\n</code></pre></div>\n<h2>Forgetful functors</h2>\n<p>In order to reduce the impact of the change (and so we won‚Äôt have to make one PR fixing about a thousand files all at once), I want to keep around the current definition of <code>ConcreteCategory</code>. This will be renamed <code>HasForget</code>, to match the already existing <code>HasForget‚ÇÇ</code>. Then we can move over each <code>ConcreteCategory</code> instance one by one, and finally we can start replacing usage of <code>HasForget</code> in lemmas with <code>ConcreteCategory</code>. In the long term, we might still want to keep the <code>HasForget</code> class for cases that really do not fit the concrete category redesign. Such as <code>Type</code> (see below!)</p>\n<p>While <code>HasForget</code> is around, there should be a new design rule: a result should be parametrized over <code>HasForget</code> if it only refers to <code>forget</code> itself, and use <code>ConcreteCategory</code> if it refers to <code>(forget _).map</code> (which should therefore be replaced with function coercion, using <code>hom</code>) or <code>(forget _).obj</code> (which should be replaced with <code>ToType</code>).</p>\n<h2>Type as concrete category</h2>\n<p>One issue is with the category of types: the objects and morphisms of <code>Type</code> are in fact already types and functions! So here we have to add a <code>FunLike</code> instance on functions themselves. This seems to have no structural issues, but right now a lot breaks locally. Namely: <code>forget Type</code> is assumed to be reducibly defeq to the identity map, and with the redesign of <code>ConcreteCategory</code>, this assumption needs to be fixed everywhere. We‚Äôll have to keep the <code>FunLike</code> and <code>ConcreteCategory</code> instances on <code>Type</code> as local instances for now and fix this gradually.</p>\n<p>In the meantime, while the identification <code>forget Type = id</code> remains true, we can work with <code>Type</code> as a <code>ConcreteCategory</code> by adding the instance locally. The errors caused by missing local instances are harder to understand compared to those by making <code>forget Type = id</code> non-reducible, so making <code>Type</code> a concrete category everywhere should be a longer term goal for the project.</p>\n<h2>BundledHom</h2>\n<p>The <code>BundledHom</code> class resembles the new <code>ConcreteCategory</code> quite closely. The main difference is that <code>BundledHom</code> is only for types bundled with a single typeclass argument, and <code>ConcreteCategory</code> uses <code>FunLike</code>, so it does not care so much about typeclasses. I had some trouble integrating the two. Since they are quite similar to decide how to transfer gracefully between the two. In the end the identification between the two costs quite a lot of headaches. So for now we can keep them living in their own separate worlds. Perhaps we can get away with removing <code>BundledHom</code> entirely later on.</p>\n<h2>Elementwise</h2>\n<p>I have a version of the <code>@[elementwise]</code> attribute that works with the new concrete category design. It works on all examples I encountered so far, but I might need some metaprogramming assistance to make it more robust.</p>\n<h2>Overall plan</h2>\n<p>This is how I see the refactor progressing:</p>\n<ul>\n<li>Make a PR renaming the existing <code>ConcreteCategory</code> to <code>HasForget</code>.</li>\n<li>Make a PR adding the new <code>ConcreteCategory</code> class.</li>\n<li>Implement <code>@[elementwise]</code> for the new <code>ConcreteCategory</code>.</li>\n<li>Upgrade <code>HasForget</code> instances to <code>ConcreteCategory</code>. Can be done alongside the <code>Hom</code> structure refactor.*</li>\n<li>Upgrade <code>HasForget</code> uses to <code>ConcreteCategory</code>.*</li>\n<li>Clean up <code>forget Type = id</code> issues.*</li>\n<li>Bugfixing and cleanup downstream.*</li>\n</ul>\n<p>After the first few steps, the remainder marked with * can be done in parallel.</p>",
        "id": 493903980,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1736940587
    },
    {
        "content": "<p>I am confident that this redesign can be made to work, and that this can be made to work without requiring so much effort that it's not worth it. But it can surely be optimized. So I would be very happy if you could check out <a href=\"https://github.com/leanprover-community/mathlib4/tree/redesign-ConcreteCategory\">branch#redesign-ConcreteCategory</a> and play around with it, see what I missed! :)</p>",
        "id": 493904363,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1736940708
    },
    {
        "content": "<p>I think this is very well considered. Thanks for the hard work <span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span> ! </p>\n<p>I don‚Äôt remember off the top of my head but does bare <code>Type</code> have a category instance?</p>",
        "id": 493921339,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1736946059
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306577\">Matthew Ballard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Concrete.20category.20class.20redesign/near/493921339\">said</a>:</p>\n<blockquote>\n<p>I don‚Äôt remember off the top of my head but does bare <code>Type</code> have a category instance?</p>\n</blockquote>\n<p>It does: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.types#doc\">docs#CategoryTheory.types</a> (with plain functions as the morphisms.)</p>",
        "id": 493921560,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1736946119
    },
    {
        "content": "<p>I would argue one shouldn‚Äôt do that to begin with</p>",
        "id": 493921653,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1736946140
    },
    {
        "content": "<p>I did try a few alternatives. There should be no technical issue with hiding types and functions behind one-field structures, only refactoring a good chunk of the library which assumes them to be reducibly equal to the plain things.</p>",
        "id": 493922136,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1736946269
    },
    {
        "content": "<p>IRL, I don‚Äôt think <code>Category</code> when I see <code>Type</code>. I have to think ‚ÄúType as a category‚Äù.  So I don‚Äôt think we should ask Lean to do so either</p>",
        "id": 493922545,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1736946398
    },
    {
        "content": "<p>Does it really matter what the <em>objects</em> of the category of types are? I would think only the <em>morphisms</em> are relevant for defeq purposes</p>",
        "id": 493933956,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1736949732
    },
    {
        "content": "<p>We obviously need the category of sets (whether on <code>Type u</code>, or with a different name, like <code>Sets.{u}</code>). I think that a good test case about design decisions is the bunch of results we have about limits in common concrete categories (e.g. the fact that the forget functor to types commute with all limits).</p>",
        "id": 493942400,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1736951999
    },
    {
        "content": "<p>I just finished going through and getting every <code>Limits</code> and <code>Colimits</code> file for concrete categories building. Some fixes were needed, but everything was very local. Lots of confusion between <code>MonoidHom X Y</code> and <code>X --&gt; Y</code>, so we should probably do the <code>Hom</code> structure change for <code>MonCat</code>, <code>Grp</code>, etc. simultaneously with adding the new <code>ConcreteCategory</code> instance. Also a few proofs that used to be complicated and can be replaced with <code>simp</code> or <code>aesop</code>. Only <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ModuleCat.restrictScalars#doc\">docs#ModuleCat.restrictScalars</a> is still very fragile and caused actual trouble.</p>",
        "id": 494161923,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1737038260
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"238446\">Anne Baanen</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Concrete.20category.20class.20redesign/near/494161923\">said</a>:</p>\n<blockquote>\n<p>Also a few proofs that used to be complicated and can be replaced with <code>simp</code> or <code>aesop</code>.</p>\n</blockquote>\n<p><span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span></p>",
        "id": 494249009,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1737068522
    },
    {
        "content": "<p>I think it's time to get the first few PRs out!</p>\n<ul>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/20809\">#20809</a> is the preparation PR renaming <code>HasForget</code> to <code>ConcreteCategory</code></li>\n</ul>",
        "id": 494359118,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1737119920
    },
    {
        "content": "<p>Will merge soon unless there are objections.</p>",
        "id": 494359963,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1737120202
    },
    {
        "content": "<ul>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/20810\">#20810</a> defines the new <code>ConcreteCategory</code> class</li>\n</ul>",
        "id": 494363283,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1737121235
    },
    {
        "content": "<ul>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/20811\">#20811</a> adapts <code>elementwise</code> to generate the right form of lemmas when <code>ConcreteCategory</code> is in scope</li>\n</ul>\n<p>This is only the first bit of adaptation we need for <code>elementwise</code>: later on when the amount of <code>ConcreteCategory</code> instances justifies it, it should add a <code>ConcreteCategory</code> instance to the context when none is found. (It currently adds a <code>HasForget</code> instance.)</p>",
        "id": 494363832,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1737121423
    },
    {
        "content": "<p>And <a href=\"https://github.com/leanprover-community/mathlib4/pull/20815\">#20815</a> gives us a nontrivial <code>ConcreteCategory</code> instance!</p>\n<p>I am having trouble with a timeout in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AlgebraicGeometry.SpecMapRestrictBasicOpenIso#doc\">docs#AlgebraicGeometry.SpecMapRestrictBasicOpenIso</a>: the <code>show</code> statements are much slower than before. I could get rid of one, but don't know how to start with the other.</p>",
        "id": 494409514,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1737135937
    },
    {
        "content": "<p><code>rw [RingHom.algebraMap_toAlgebra, RingHom.algebraMap_toAlgebra]</code> gets rid of the <code>show</code>, but the timeout still happens.</p>",
        "id": 494418638,
        "sender_full_name": "Christian Merten",
        "timestamp": 1737139357
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span>  I'm obviously late to the party, but let me ask what is a potentially very stupid question. <code>ConcreteCategory</code> now takes the type of bundled morphisms as an argument. Why does this same consideration not apply to the isomorphisms in the category? Should that type also be passed along with some fields dictating how they behave?</p>\n<p>Obviously, this would mean that working with generic concrete categories gets even more verbose. I'd be happy to understand a reason why I'm and idiot and it's obviously not necessary.</p>",
        "id": 494435608,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1737146249
    },
    {
        "content": "<p>It's a good question! I never really thought about it until you asked, in fact, since it didn't really come up. The reason we can get away with not considering <code>Iso</code>s is that to apply an <code>Iso</code>, let's say <code>e</code>, we write <code>e.hom</code> or <code>e.inv</code> to first convert it to a morphism: it doesn't have its own <code>FunLike</code> instance, unlike the morphisms themselves.</p>",
        "id": 494436504,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1737146634
    },
    {
        "content": "<p>I can see a place for something that could wrap all the <code>Iso.toFooEquiv</code>/<code>FooEquiv.toIso</code> conversion, which might be an upgraded <code>ConcreteCategory</code> class along the lines you're thinking of.</p>",
        "id": 494436764,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1737146746
    },
    {
        "content": "<p>If you want to allow custom <code>Iso</code>s, you need to include <code>Iso</code>s into the signature of a <code>Category</code> instead of defining them as a pair of inverse <code>Hom</code>s.</p>",
        "id": 494663976,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1737310152
    },
    {
        "content": "<p>Agreed. But I also think we should not do that.</p>",
        "id": 494785457,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1737372586
    },
    {
        "content": "<p>I don't use Mathlib category theory, so I have no opinion on whether we should do that.</p>",
        "id": 495190349,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1737516347
    },
    {
        "content": "<p>I have now made PRs for <code>RingCat</code>, <code>AlgebraCat</code> and <code>ModuleCat</code>:</p>",
        "id": 496108120,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1737980217
    },
    {
        "content": "<ul>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/20815\">#20815</a> implements a new <code>ConcreteCategory</code> instance for rings. A few fixes, typically old workarounds that got in the way. One timeout fixed by rewriting the proof.</li>\n</ul>",
        "id": 496108411,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1737980319
    },
    {
        "content": "<ul>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/21121\">#21121</a> implements <code>ConcreteCategory</code> for <code>AlgebraCat</code>. No fixes at all needed, everything just works!</li>\n</ul>",
        "id": 496108475,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1737980345
    },
    {
        "content": "<ul>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/21125\">#21125</a> implements <code>ConcreteCategory</code> for <code>ModuleCat</code>. It seems that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ModuleCat.restrictScalars#doc\">docs#ModuleCat.restrictScalars</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PresheafOfModules#doc\">docs#PresheafOfModules</a> do not like changes to the elaboration/defeq, so I had to come up with ugly workarounds. Anyone have ideas how to make a more principled fix?</li>\n</ul>",
        "id": 496108759,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1737980444
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/21192\">#21192</a> refactors categories of groups: redo the objects as a custom <code>structure</code>, add a <code>Hom</code> structure, implement <code>ConcreteCategory</code> and rework the <code>@[simp]</code> set. (Still needs to be linted and benchmarked.)</p>",
        "id": 496402584,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1738090064
    },
    {
        "content": "<p>Next up should be <code>Mon</code> (already got halfway before I realized that it would be easier to do <code>Grp</code> first, due to parent projections) and <code>SemiGrp</code>, then I want to try looking at some topological categories.</p>",
        "id": 496403012,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1738090201
    },
    {
        "content": "<p>Fixed all the regressions in the <code>MonCat</code> refactor: <a href=\"https://github.com/leanprover-community/mathlib4/pull/21222\">#21222</a> should be ready to review!</p>",
        "id": 496789543,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1738247153
    },
    {
        "content": "<p>Got topological spaces compiling just before the weekend: <a href=\"https://github.com/leanprover-community/mathlib4/pull/21302\">#21302</a>. After a bit of struggle in the basic files, there were lots of places where it was very easy to find cleanup opportunities: 34 porting notes and 11 <code>erw</code>s deleted. <span aria-label=\"octopus\" class=\"emoji emoji-1f419\" role=\"img\" title=\"octopus\">:octopus:</span></p>",
        "id": 497060724,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1738346719
    },
    {
        "content": "<p>That's what we were hoping for!!</p>",
        "id": 497136393,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1738391498
    },
    {
        "content": "<p>Quick refactor of <code>MagmaCat</code> and <code>Semigrp</code> while waiting for the <code>TopCat</code> benchmark results to come in: <a href=\"https://github.com/leanprover-community/mathlib4/pull/21368\">#21368</a></p>",
        "id": 497404044,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1738581548
    },
    {
        "content": "<p>I'm happy with the topological spaces PR: <a href=\"https://github.com/leanprover-community/mathlib4/pull/21302\">#21302</a></p>",
        "id": 497424961,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1738586906
    },
    {
        "content": "<p>Categories of orders: <a href=\"https://github.com/leanprover-community/mathlib4/pull/21409\">#21409</a></p>",
        "id": 497625267,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1738663601
    },
    {
        "content": "<p>Depends on the previous one: a minimal cleanup of <code>CompleteLattice</code>, <a href=\"https://github.com/leanprover-community/mathlib4/pull/21410\">#21410</a></p>",
        "id": 497637344,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1738667049
    },
    {
        "content": "<p>I think I am done with all the <code>HasForget</code> instances we have in the library! Lots of little PRs ready for review: <a href=\"https://github.com/leanprover-community/mathlib4/pulls?q=is%3Aopen+is%3Apr+author%3AVierkantor+label%3At-category-theory\">https://github.com/leanprover-community/mathlib4/pulls?q=is%3Aopen+is%3Apr+author%3AVierkantor+label%3At-category-theory</a></p>",
        "id": 497956114,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1738779620
    },
    {
        "content": "<p>I‚Äôve been using mathlib with the new design and it is a lot smoother compared to what we had before. It‚Äôs great!<br>\nA feature request is that my infoview is now filled with <code>ConcreteCategory.hom</code> that made it less readable than before. Is there a good way to use some pretty printer magic to hide this?</p>",
        "id": 497958429,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1738780435
    },
    {
        "content": "<p>Does it make sense to make it a <code>coe</code>?</p>",
        "id": 497958647,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1738780506
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"238446\">Anne Baanen</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Concrete.20category.20class.20redesign/near/497956114\">said</a>:</p>\n<blockquote>\n<p>I think I am done with all the <code>HasForget</code> instances we have in the library! Lots of little PRs ready for review: <a href=\"https://github.com/leanprover-community/mathlib4/pulls?q=is%3Aopen+is%3Apr+author%3AVierkantor+label%3At-category-theory\">https://github.com/leanprover-community/mathlib4/pulls?q=is%3Aopen+is%3Apr+author%3AVierkantor+label%3At-category-theory</a></p>\n</blockquote>\n<p>I've sent the ones without merge conflicts or awaiting-author to bors.</p>",
        "id": 498005396,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1738799799
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Concrete.20category.20class.20redesign/near/497958429\">said</a>:</p>\n<blockquote>\n<p>I‚Äôve been using mathlib with the new design and it is a lot smoother compared to what we had before. It‚Äôs great!<br>\nA feature request is that my infoview is now filled with <code>ConcreteCategory.hom</code> that made it less readable than before. Is there a good way to use some pretty printer magic to hide this?</p>\n</blockquote>\n<p>I'm very glad to hear it's working for you! I was expecting that the transition period would be more suffering because we now have even more ways that things would be mismatched :)</p>\n<p>Making <code>.hom</code> a <code>@[coe]</code> sounds like a good idea, thanks for the suggestion!</p>",
        "id": 498083122,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1738836650
    },
    {
        "content": "<p>I finished upgrading <code>HasForget</code> to <code>ConcreteCategory</code> for sheaves: <a href=\"https://github.com/leanprover-community/mathlib4/pull/21575\">#21575</a>.</p>",
        "id": 498499991,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1739019467
    },
    {
        "content": "<p>For the order instances PR: <a href=\"https://github.com/leanprover-community/mathlib4/pull/21409\">#21409</a>, anything else I can do?</p>",
        "id": 498500061,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1739019508
    },
    {
        "content": "<p>What‚Äôs the preferred way to apply results about concrete category to <code>Type</code> now?</p>",
        "id": 499594874,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1739484805
    },
    {
        "content": "<p>Currently: if you get errors about a missing instance <code>ConcreteCategory (Type _) _</code>, then the magic line is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"kn\">local</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">Types</span><span class=\"bp\">.</span><span class=\"n\">instFunLike</span><span class=\"w\"> </span><span class=\"n\">Types</span><span class=\"bp\">.</span><span class=\"n\">instConcreteCategory</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 499699716,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1739529175
    },
    {
        "content": "<p>In the future I would like to promote these local instances to global instances but that took quite some fixes when I tested it before.</p>",
        "id": 499699968,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1739529238
    },
    {
        "content": "<p>In particular, you might run into missing instances on the functor <code>forget Type</code>: this was previously reducibly defeq to the identity functor, so properties of the identity functor would apply to <code>forget</code> for free. Enabling <code>Types.instConcreteCategory</code> turns that into a reducible-with-instances defeq, and then they can't be found as easily.</p>\n<p>The solution is to copy the <code>id</code> instance to <code>forget</code>, see e.g. <a href=\"https://github.com/leanprover-community/mathlib4/blob/46717807bb894147739482876600f738758b5628/Mathlib/CategoryTheory/Limits/ConcreteCategory/Basic.lean#L39\">the start of Limits.ConcreteCategory.Basic</a>.</p>",
        "id": 499701540,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1739529602
    },
    {
        "content": "<p>By the way, could I ask for a meta expert on <a href=\"https://github.com/leanprover-community/mathlib4/pull/21729\">#21729</a> to figure out if there isn't a better way to write <a href=\"https://github.com/leanprover-community/mathlib4/pull/21729/files#r1951138618\">this bit</a>?</p>",
        "id": 499705819,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1739530619
    }
]