[
    {
        "content": "<p>Should <code>AtomM</code> have a cache for the atoms? Currently <code>addAtom</code> gets the atom of an expression <code>e</code> by looking at an array <code>atoms : Array Expr</code>, then checks each element of this array in turn against <code>e</code> by <code>isDefEq</code>.</p>\n<p>Is the current <code>AtomM</code> behavior less expensive than it sounds? Would there be any benefit in doing a cheaper check in a <code>HashMap Expr Nat</code>, then falling back on iterating through the array if that fails? I imagine this might have been considered already, but thought I'd check.</p>",
        "id": 451639603,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1721081463
    },
    {
        "content": "<p>The HashMap behavior is what both LeanSAT and omega are doing for performance reasons + actually no fallback to isDefEq at all.</p>",
        "id": 451641257,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1721082274
    },
    {
        "content": "<p>Doesn't that mean that <code>a + b</code> can end up not matching <code>a + b</code> if the <code>HAdd</code> instance is different-but-defeq?</p>",
        "id": 451646807,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1721084880
    },
    {
        "content": "<p>This test-case passes, so it seems omega is doing something with defeq:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">my_add</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddSemigroup</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">⌊</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"bp\">⌋</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"bp\">⌊</span><span class=\"o\">(</span><span class=\"n\">my_add</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"bp\">⌋</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">my_add</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">omega</span>\n</code></pre></div>",
        "id": 451647510,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1721085172
    },
    {
        "content": "<p><code>omega</code> uses <code>Lean.Meta.Canonicalizer</code>. This is much more efficient than <code>AtomM</code>.</p>",
        "id": 451658429,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1721091567
    },
    {
        "content": "<p>Is <code>Canonicalizer</code> strictly better than <code>AtomM</code> all around, or do they have different use cases?</p>",
        "id": 451658655,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1721091697
    },
    {
        "content": "<p>(<a href=\"https://leanprover-community.github.io/mathlib4_docs/Lean/Meta/Canonicalizer.html\">https://leanprover-community.github.io/mathlib4_docs/Lean/Meta/Canonicalizer.html</a>)</p>",
        "id": 451658745,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1721091733
    },
    {
        "content": "<p>I think there's quite a difference in philosophy between the two, and so picking between them is more than just a performance choice</p>",
        "id": 451658790,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1721091776
    },
    {
        "content": "<p>I think the two things going for AtomM are:</p>\n<ul>\n<li>It \"sees through\" <code>abbrev</code>, which depending on your model of what <code>abbrev</code> is supposed to mean, could be a feature</li>\n<li>It can be used to unify metavariables; though perhaps CanonM could special case expressions with metavariables, assigning them all the same hash, for parity here.</li>\n</ul>",
        "id": 451659999,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1721092580
    },
    {
        "content": "<p>Hmm, it also seems that there are some expression reductions <code>omega</code>/<code>CanonM</code> doesn’t do, which <code>AtomM</code> would in the course of isDefEq, e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">⌊</span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"bp\">⌋</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"bp\">⌊</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"bp\">⌋</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">omega</span><span class=\"w\"> </span><span class=\"c1\">--error</span>\n</code></pre></div>",
        "id": 451660527,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1721092935
    },
    {
        "content": "<p>Though I wonder how “<code>CanonM</code> plus expression reductions” would compare to <code>AtomM</code>.</p>",
        "id": 451660794,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1721093126
    },
    {
        "content": "<p>AtomM is a linear scan exactly because it can't use the discrimination tree because it works up to unfolding semireducibles</p>",
        "id": 451675796,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1721101620
    },
    {
        "content": "<p>I've thought about having a hybrid version where if the reducibility setting is reducible then it uses a discrimination tree instead</p>",
        "id": 451675877,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1721101666
    },
    {
        "content": "<p>in practice I don't think it's a major issue, but it is quadratic in the size of the statement</p>",
        "id": 451675958,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1721101700
    },
    {
        "content": "<p>Note that ring/linarith actually used to be using something closer to the discrimination tree approach, this is the result of a feature request</p>",
        "id": 451676054,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1721101787
    }
]