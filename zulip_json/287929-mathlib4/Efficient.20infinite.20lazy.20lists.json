[
    {
        "content": "<p>Hi there! I am working on a new tactic that will be able to (verifiably) compute limits and asymptotics of real functions. Basically, I am implementing this paper: <a href=\"https://www21.in.tum.de/~eberlm/pdfs/real_asymp.pdf\">https://www21.in.tum.de/~eberlm/pdfs/real_asymp.pdf</a>. For this I need efficient infinite lazy lists, which allows to reason about them (e.g. not sealed under <code>partial</code>). Is there something suitable for this in Lean/Mathlib? I see <a href=\"https://github.com/leanprover-community/mathlib4/pull/7512\">#7512</a> making Stream' efficient, but it is a draft.</p>",
        "id": 457299879,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1723105321
    },
    {
        "content": "<p>This is great news! Thank you so much for working on this!</p>",
        "id": 457309047,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1723107565
    },
    {
        "content": "<p>Lean doesn't have coinductive types (except functions), so that rules out the obvious solution. I imagine your best bet would be to define an inefficient model of lazy lists in terms of functions, then override that with an efficient but <code>unsafe</code> implementation, using <code>@[implementedBy]</code> or <code>@[csimp]</code>. See <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MLList#doc\">docs#MLList</a> for an example, though the model used there is trivial and therefore not suitable for proofs.</p>\n<p>With that said, I would also investigate whether you can get around the lazy list requirement. In my experience, lazy lists may be elegant for certain applications, but they're never required. (At the end of the day, you only ever evaluate a finite prefix.)</p>",
        "id": 457314468,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1723109012
    },
    {
        "content": "<p>Not to bring in a sledgehammer here, but are the ideas of the <a href=\"https://www.contrib.andrew.cmu.edu/~avigad/Papers/qpf.pdf\">QPF paper</a> applicable to introduce coinductive types? Not sure how \"efficient\" they would be, nor am I sure if this still wouldn't be \"sealed\" in some other way.</p>",
        "id": 457381725,
        "sender_full_name": "Enrico Borba",
        "timestamp": 1723126871
    },
    {
        "content": "<p>I am intersted in this too. What is the status of the <a href=\"https://github.com/alexkeizer/QpfTypes\">QpfTypes</a> project? Are there plans to add support for conductive types to the compiler?</p>",
        "id": 457396205,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1723130734
    },
    {
        "content": "<p>Afaik nobody is actively working on coinductive types in any form.</p>",
        "id": 457414439,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1723134278
    },
    {
        "content": "<p>The FRO is very keen to have coinductive predicates (not types; this is a smaller and easier target, but still useful for many applications) in Lean, but it's not on anyone's immediate roadmap.</p>",
        "id": 459312941,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1723159289
    },
    {
        "content": "<p>Just for additional context there was some lean 4 work on QPF: <a href=\"https://lean-forward.github.io/pubs/keizer_msc_thesis.pdf\">https://lean-forward.github.io/pubs/keizer_msc_thesis.pdf</a></p>",
        "id": 459376201,
        "sender_full_name": "Enrico Borba",
        "timestamp": 1723182351
    }
]