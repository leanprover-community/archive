[
    {
        "content": "<p>I wanna try and prove Tutte's theorem. I've come to the following statement. Before I move in and try to prove it, does anyone see anything that's problematic or unidiomatic? The eventual goal is a PR to mathlib, so anything with that in mind is welcome specifically:)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Combinatorics.SimpleGraph.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Combinatorics.SimpleGraph.Matching</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Combinatorics.SimpleGraph.Connectivity</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Combinatorics.SimpleGraph.Subgraph</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Fintype.Powerset</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Card</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">SimpleGraph</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">DecidableRel</span> <span class=\"n\">G.Adj</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">ConnectedComponent</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Fintype</span> <span class=\"o\">(</span><span class=\"n\">u.supp</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ConnectedComponent.card</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">ConnectedComponent</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">Fintype.card</span> <span class=\"n\">u.supp</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">OddConnectedComponents</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">SimpleGraph.Subgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span>\n   <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">component</span> <span class=\"o\">:</span> <span class=\"n\">SimpleGraph.ConnectedComponent</span> <span class=\"n\">U.coe</span> <span class=\"bp\">//</span> <span class=\"n\">Odd</span> <span class=\"o\">(</span><span class=\"n\">component.card</span><span class=\"o\">)}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">Subgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Fintype</span> <span class=\"o\">(</span><span class=\"n\">OddConnectedComponents</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">numOddComponents</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">Subgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">Fintype.card</span> <span class=\"o\">(</span><span class=\"n\">OddConnectedComponents</span> <span class=\"n\">U</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">tutte</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">Subgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">,</span> <span class=\"n\">M.IsPerfectMatching</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">V</span><span class=\"o\">),</span>\n      <span class=\"n\">numOddComponents</span> <span class=\"o\">(</span><span class=\"n\">Subgraph.induce</span> <span class=\"o\">(</span><span class=\"n\">G.toSubgraph</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">le_rfl</span><span class=\"o\">))</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">u.ncard</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 392317337,
        "sender_full_name": "Pim Otte",
        "timestamp": 1695301422
    },
    {
        "content": "<p>Very cool you work on Tutte's theorem!</p>",
        "id": 392319967,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1695302378
    },
    {
        "content": "<p>Can you use <code>SimpleGraph.induce</code> in place of <code>Subgraph.induce (G.toSubgraph G (le_rfl)) </code>  ?</p>",
        "id": 392323444,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1695303426
    },
    {
        "content": "<p>Maybe its more work in the long run, but just checking you also considered that option</p>",
        "id": 392323693,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1695303495
    },
    {
        "content": "<p>I hadn't, I can't really oversee the consequences, but it does look more clean:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Combinatorics.SimpleGraph.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Combinatorics.SimpleGraph.Matching</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Combinatorics.SimpleGraph.Connectivity</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Combinatorics.SimpleGraph.Subgraph</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Fintype.Powerset</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Card</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">SimpleGraph</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">V</span><span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">cc</span> <span class=\"o\">:</span> <span class=\"n\">ConnectedComponent</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Fintype</span> <span class=\"o\">(</span><span class=\"n\">cc.supp</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ConnectedComponent.card</span> <span class=\"o\">(</span><span class=\"n\">cc</span> <span class=\"o\">:</span> <span class=\"n\">ConnectedComponent</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">Fintype.card</span> <span class=\"n\">cc.supp</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">OddConnectedComponents</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span>\n   <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">component</span> <span class=\"o\">:</span> <span class=\"n\">ConnectedComponent</span> <span class=\"n\">G</span> <span class=\"bp\">//</span> <span class=\"n\">Odd</span> <span class=\"o\">(</span><span class=\"n\">component.card</span><span class=\"o\">)}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Fintype</span> <span class=\"o\">(</span><span class=\"n\">OddConnectedComponents</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">numOddComponents</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">Fintype.card</span> <span class=\"o\">(</span><span class=\"n\">OddConnectedComponents</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">tutte</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">Subgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">,</span> <span class=\"n\">M.IsPerfectMatching</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">V</span><span class=\"o\">),</span>\n      <span class=\"n\">numOddComponents</span> <span class=\"o\">(</span><span class=\"n\">SimpleGraph.induce</span> <span class=\"n\">u</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">u.ncard</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 392325416,
        "sender_full_name": "Pim Otte",
        "timestamp": 1695304040
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"519269\">@Pim Otte</span> I think this might be how I'd set things up:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Combinatorics.SimpleGraph.Matching</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Combinatorics.SimpleGraph.Connectivity</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Card</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">SimpleGraph</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">}</span>\n\n<span class=\"sd\">/-- A connected component is *odd* if it has an add number of vertices</span>\n<span class=\"sd\">in its support. -/</span>\n<span class=\"c1\">-- Note: only connected components with finitely many vertices can be odd.</span>\n<span class=\"kd\">def</span> <span class=\"n\">ConnectedComponent.isOdd</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">G.ConnectedComponent</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Odd</span> <span class=\"o\">(</span><span class=\"n\">Nat.card</span> <span class=\"n\">c.supp</span><span class=\"o\">)</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">cardOddComponents</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Set.ncard</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">G.ConnectedComponent</span> <span class=\"bp\">|</span> <span class=\"n\">c.isOdd</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">tutte</span> <span class=\"o\">[</span><span class=\"n\">Finite</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">Subgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">,</span> <span class=\"n\">M.IsPerfectMatching</span><span class=\"o\">)</span> <span class=\"bp\">↔</span>\n      <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">V</span><span class=\"o\">),</span>\n        <span class=\"n\">cardOddComponents</span> <span class=\"o\">((</span><span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">G.Subgraph</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">deleteVerts</span> <span class=\"n\">u</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">coe</span> <span class=\"bp\">≤</span> <span class=\"n\">u.ncard</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 392332249,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1695306147
    },
    {
        "content": "<p>(I changed this to deleting vertices rather than inducing a subgraph, which is what I think is the statement of Tutte's theorem.)</p>",
        "id": 392332396,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1695306188
    },
    {
        "content": "<p>Here are some extra things that might be useful at some point.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">ConnectedComponent.isOdd_iff</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">G.ConnectedComponent</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">c.supp</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"n\">c.isOdd</span> <span class=\"bp\">↔</span> <span class=\"n\">Odd</span> <span class=\"o\">(</span><span class=\"n\">Fintype.card</span> <span class=\"n\">c.supp</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">isOdd</span><span class=\"o\">,</span> <span class=\"n\">Nat.card_eq_fintype_card</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- Follows from other instances:</span>\n<span class=\"c1\">--instance (u : ConnectedComponent G) : Fintype u.supp := inferInstance</span>\n\n<span class=\"sd\">/-- This is `Quot.recOn` specialized to connected components.</span>\n<span class=\"sd\">For convenience, it strengthens the assumptions in the hypothesis</span>\n<span class=\"sd\">to provide a path between the vertices. -/</span>\n<span class=\"kd\">@[elab_as_elim]</span>\n<span class=\"kd\">def</span> <span class=\"n\">ConnectedComponent.recOn</span>\n    <span class=\"o\">{</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"n\">G.ConnectedComponent</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">G.ConnectedComponent</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">G.connectedComponentMk</span> <span class=\"n\">v</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.Walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">p.IsPath</span><span class=\"o\">),</span>\n      <span class=\"n\">ConnectedComponent.sound</span> <span class=\"n\">p.reachable</span> <span class=\"bp\">▸</span> <span class=\"n\">f</span> <span class=\"n\">u</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">motive</span> <span class=\"n\">c</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Quot.recOn</span> <span class=\"n\">c</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">r</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">r.elim_path</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">p</span> <span class=\"n\">p.2</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableRel</span> <span class=\"n\">G.Adj</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">G.ConnectedComponent</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">c.supp</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">c.recOn</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">w</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">ConnectedComponent.mem_supp_iff</span><span class=\"o\">,</span> <span class=\"n\">ConnectedComponent.eq</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">infer_instance</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Subsingleton.elim</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 392332729,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1695306287
    },
    {
        "content": "<p>Awesome, thanks, I'll see if I can build on this:) (oops@the deleting instead of subgraph, that's kind of critical)</p>",
        "id": 392358075,
        "sender_full_name": "Pim Otte",
        "timestamp": 1695314213
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> I'm making some small steps, but I can't get the instance you mention should follow from others. Any pointers?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Combinatorics.SimpleGraph.Matching</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Combinatorics.SimpleGraph.Connectivity</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Card</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Finite</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">SimpleGraph</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- Follows from other instances?</span>\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">Finite</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">ConnectedComponent</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Fintype</span> <span class=\"n\">u.supp</span> <span class=\"o\">:=</span> <span class=\"n\">inferInstance</span>\n</code></pre></div>",
        "id": 397663260,
        "sender_full_name": "Pim Otte",
        "timestamp": 1697792247
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"519269\">@Pim Otte</span> Oops, I must have copy-pasted some things out of order. Here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Combinatorics.SimpleGraph.Matching</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Combinatorics.SimpleGraph.Connectivity</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Card</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Finite</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">SimpleGraph</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">}</span>\n\n<span class=\"sd\">/-- This is `Quot.recOn` specialized to connected components.</span>\n<span class=\"sd\">For convenience, it strengthens the assumptions in the hypothesis</span>\n<span class=\"sd\">to provide a path between the vertices. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">elab_as_elim</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">ConnectedComponent.recOn</span>\n    <span class=\"o\">{</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"n\">G.ConnectedComponent</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">G.ConnectedComponent</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">G.connectedComponentMk</span> <span class=\"n\">v</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.Walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">p.IsPath</span><span class=\"o\">),</span>\n      <span class=\"n\">ConnectedComponent.sound</span> <span class=\"n\">p.reachable</span> <span class=\"bp\">▸</span> <span class=\"n\">f</span> <span class=\"n\">u</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">motive</span> <span class=\"n\">c</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Quot.recOn</span> <span class=\"n\">c</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">r</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">r.elim_path</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">p</span> <span class=\"n\">p.2</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableRel</span> <span class=\"n\">G.Adj</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">G.ConnectedComponent</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">c.supp</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">c.recOn</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">w</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">ConnectedComponent.mem_supp_iff</span><span class=\"o\">,</span> <span class=\"n\">ConnectedComponent.eq</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">infer_instance</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Subsingleton.elim</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableRel</span> <span class=\"n\">G.Adj</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">ConnectedComponent</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Fintype</span> <span class=\"n\">u.supp</span> <span class=\"o\">:=</span> <span class=\"n\">inferInstance</span>\n</code></pre></div>",
        "id": 397737511,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1697816617
    },
    {
        "content": "<p>There's probably a better instance, but this one is fine if you're working with finite graphs mathematically and you're not actually interested <code>#eval</code>ing things like the cardinality of the support. It takes a bit of untangling to see what's going on, but the way that <code>u.supp</code> is a fintype here is that (1) it's a subset of the fintype <code>V</code> and (2) there's an algorithm for telling whether or not a given <code>v</code> is an element of <code>u.supp</code>, so one can enumerate the support by filtering <code>V</code> according to this algorithm. This algorithm isn't very efficient: it chooses a basepoint for <code>u</code> and enumerates all walks starting from <code>u</code> up to length <code>card V - 1</code> and sees if <code>v</code> is ever one of the endpoints.</p>",
        "id": 397738130,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1697816842
    },
    {
        "content": "<p>I've been working on this every once in a while, and it seems like a good time to ask for a little feedback and help. </p>\n<p>The current concrete problem I'm running into is that I don't know how to really connect <code>(Subgraph.coe (⊤ : Subgraph G))</code> with <code>G</code> to prove the <code>have heven : ...</code>. Rewriting the statements of the lemma's somehow got some Lean.Internal stuff to enter the context, which kind of made me think I might be barking up the wrong tree. I'm very open to pointers specifically about this or my general approach/structure/cleaner proofs etc.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Combinatorics.SimpleGraph.Matching</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Combinatorics.SimpleGraph.Connectivity</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Card</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Finite</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">SimpleGraph</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">}</span>\n\n<span class=\"sd\">/-- A connected component is *odd* if it has an add number of vertices</span>\n<span class=\"sd\">in its support. -/</span>\n<span class=\"c1\">-- Note: only connected components with finitely many vertices can be odd.</span>\n<span class=\"kd\">def</span> <span class=\"n\">ConnectedComponent.isOdd</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">G.ConnectedComponent</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Odd</span> <span class=\"o\">(</span><span class=\"n\">Nat.card</span> <span class=\"n\">c.supp</span><span class=\"o\">)</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">cardOddComponents</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Set.ncard</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">G.ConnectedComponent</span> <span class=\"bp\">|</span> <span class=\"n\">c.isOdd</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">ConnectedComponent.isOdd_iff</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">G.ConnectedComponent</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">c.supp</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"n\">c.isOdd</span> <span class=\"bp\">↔</span> <span class=\"n\">Odd</span> <span class=\"o\">(</span><span class=\"n\">Fintype.card</span> <span class=\"n\">c.supp</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">isOdd</span><span class=\"o\">,</span> <span class=\"n\">Nat.card_eq_fintype_card</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- This is `Quot.recOn` specialized to connected components.</span>\n<span class=\"sd\">For convenience, it strengthens the assumptions in the hypothesis</span>\n<span class=\"sd\">to provide a path between the vertices. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">elab_as_elim</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">ConnectedComponent.recOn</span>\n    <span class=\"o\">{</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"n\">G.ConnectedComponent</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">G.ConnectedComponent</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">G.connectedComponentMk</span> <span class=\"n\">v</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.Walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">p.IsPath</span><span class=\"o\">),</span>\n      <span class=\"n\">ConnectedComponent.sound</span> <span class=\"n\">p.reachable</span> <span class=\"bp\">▸</span> <span class=\"n\">f</span> <span class=\"n\">u</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">motive</span> <span class=\"n\">c</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Quot.recOn</span> <span class=\"n\">c</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">r</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">r.elim_path</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">p</span> <span class=\"n\">p.2</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableRel</span> <span class=\"n\">G.Adj</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">G.ConnectedComponent</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">c.supp</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">c.recOn</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">w</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">ConnectedComponent.mem_supp_iff</span><span class=\"o\">,</span> <span class=\"n\">ConnectedComponent.eq</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">infer_instance</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Subsingleton.elim</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">myInst2</span> <span class=\"o\">[</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">DecidableRel</span> <span class=\"n\">G.Adj</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">DecidableRel</span> <span class=\"o\">(</span><span class=\"n\">Subgraph.coe</span> <span class=\"o\">(</span><span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">Subgraph</span> <span class=\"n\">G</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">Adj</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n  <span class=\"n\">cases</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">isFalse</span> <span class=\"n\">nh</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span>\n    <span class=\"n\">exact</span> <span class=\"bp\">.</span><span class=\"n\">isFalse</span> <span class=\"o\">(</span><span class=\"kd\">by</span>\n      <span class=\"n\">intro</span> <span class=\"n\">w</span>\n      <span class=\"n\">exact</span> <span class=\"n\">nh</span> <span class=\"o\">(</span><span class=\"n\">Subgraph.coe_adj_sub</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">w</span><span class=\"o\">)</span>\n      <span class=\"o\">)</span>\n  <span class=\"o\">}</span>\n  <span class=\"bp\">|</span> <span class=\"n\">isTrue</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span>\n    <span class=\"n\">exact</span> <span class=\"bp\">.</span><span class=\"n\">isTrue</span> <span class=\"o\">(</span><span class=\"kd\">by</span>\n      <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"n\">Subgraph.coe_adj_sub</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n      <span class=\"n\">exact</span> <span class=\"n\">h</span>\n    <span class=\"o\">)</span>\n  <span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">myInst</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableRel</span> <span class=\"n\">G.Adj</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">ConnectedComponent</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Fintype</span> <span class=\"n\">u.supp</span> <span class=\"o\">:=</span> <span class=\"n\">inferInstance</span>\n\n\n<span class=\"kd\">lemma</span> <span class=\"n\">SimpleGraph.PerfectMatchingInducesMatchingOnComponent</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableRel</span> <span class=\"n\">G.Adj</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">Subgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hM</span> <span class=\"o\">:</span> <span class=\"n\">Subgraph.IsPerfectMatching</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ConnectedComponent</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Subgraph.IsMatching</span> <span class=\"o\">(</span><span class=\"n\">M.induce</span> <span class=\"n\">c.supp</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intro</span> <span class=\"n\">v</span> <span class=\"n\">hv</span>\n    <span class=\"k\">have</span> <span class=\"n\">vM</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">M.verts</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">apply</span> <span class=\"n\">hM.2</span>\n    <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">hM.1</span> <span class=\"n\">vM</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">hw</span> <span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h</span>\n    <span class=\"n\">use</span> <span class=\"n\">w</span>\n    <span class=\"n\">dsimp</span> <span class=\"n\">at</span> <span class=\"bp\">*</span>\n    <span class=\"n\">constructor</span>\n    <span class=\"bp\">·</span> <span class=\"n\">constructor</span>\n      <span class=\"bp\">·</span> <span class=\"n\">assumption</span>\n      <span class=\"bp\">·</span> <span class=\"n\">constructor</span>\n        <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">ConnectedComponent.mem_supp_iff</span><span class=\"o\">]</span>\n          <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">ConnectedComponent.mem_supp_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hv</span>\n          <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">hv</span><span class=\"o\">]</span>\n          <span class=\"n\">apply</span> <span class=\"n\">ConnectedComponent.connectedComponentMk_eq_of_adj</span>\n          <span class=\"n\">apply</span> <span class=\"n\">M.adj_sub</span>\n          <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Subgraph.adj_comm</span><span class=\"o\">]</span>\n          <span class=\"n\">exact</span> <span class=\"n\">hw.1</span>\n        <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">hw.1</span>\n    <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">y</span> <span class=\"n\">hy</span>\n      <span class=\"n\">apply</span> <span class=\"n\">hw.2</span>\n      <span class=\"n\">exact</span> <span class=\"n\">hy.2.2</span>\n    <span class=\"n\">done</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">SimpleGraph.PerfectMatchingConnectedComponentEven</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableRel</span> <span class=\"n\">G.Adj</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">Subgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hM</span> <span class=\"o\">:</span> <span class=\"n\">Subgraph.IsPerfectMatching</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ConnectedComponent</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Even</span> <span class=\"o\">(</span><span class=\"n\">Fintype.card</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">ConnectedComponent.supp</span> <span class=\"n\">c</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">classical</span>\n    <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Even</span> <span class=\"o\">(</span><span class=\"n\">M.induce</span> <span class=\"n\">c.supp</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">verts.toFinset.card</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">exact</span> <span class=\"n\">Subgraph.IsMatching.even_card</span> <span class=\"o\">(</span><span class=\"n\">SimpleGraph.PerfectMatchingInducesMatchingOnComponent</span> <span class=\"n\">M</span> <span class=\"n\">hM</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span> <span class=\"n\">k</span> <span class=\"o\">,</span> <span class=\"n\">hk</span> <span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h</span>\n    <span class=\"n\">use</span> <span class=\"n\">k</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">hk</span><span class=\"o\">,</span> <span class=\"n\">Subgraph.induce_verts</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">Fintype.card_ofFinset</span><span class=\"o\">]</span>\n    <span class=\"n\">congr</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">ConnectedComponent.mem_supp_iff</span><span class=\"o\">,</span> <span class=\"n\">Finset.mem_univ</span><span class=\"o\">,</span> <span class=\"n\">forall_true_left</span><span class=\"o\">]</span>\n    <span class=\"n\">exact</span> <span class=\"n\">Set.filter_mem_univ_eq_toFinset</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">connectedComponentMk</span> <span class=\"n\">G</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">c</span>\n\n    <span class=\"n\">done</span>\n<span class=\"kd\">def</span> <span class=\"n\">tutte</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableRel</span> <span class=\"n\">G.Adj</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">Subgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">,</span> <span class=\"n\">M.IsPerfectMatching</span><span class=\"o\">)</span> <span class=\"bp\">↔</span>\n      <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">V</span><span class=\"o\">),</span>\n        <span class=\"n\">cardOddComponents</span> <span class=\"o\">((</span><span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">G.Subgraph</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">deleteVerts</span> <span class=\"n\">u</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">coe</span> <span class=\"bp\">≤</span> <span class=\"n\">u.ncard</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"o\">{</span>\n    <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">hM</span><span class=\"o\">⟩</span> <span class=\"n\">u</span>\n    <span class=\"n\">exact</span> <span class=\"n\">Set.Finite.induction_on</span> <span class=\"n\">u.toFinite</span>\n      <span class=\"o\">(</span><span class=\"kd\">by</span>\n        <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">G.Subgraph</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">deleteVerts</span> <span class=\"bp\">∅</span> <span class=\"bp\">=</span> <span class=\"bp\">⊤</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n        <span class=\"k\">have</span> <span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">Set.ncard</span> <span class=\"n\">V</span> <span class=\"bp\">∅</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h2</span><span class=\"o\">,</span> <span class=\"n\">cardOddComponents</span><span class=\"o\">]</span>\n        <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Subgraph.verts_top</span><span class=\"o\">,</span> <span class=\"n\">nonpos_iff_eq_zero</span><span class=\"o\">]</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">h2</span><span class=\"o\">]</span>\n        <span class=\"k\">have</span> <span class=\"n\">h3</span> <span class=\"o\">:</span>  <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"bp\">|</span> <span class=\"bp\">@</span><span class=\"n\">ConnectedComponent.isOdd</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">Subgraph.coe</span> <span class=\"bp\">⊤</span><span class=\"o\">)</span> <span class=\"n\">c</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n          <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Set.ext_iff</span><span class=\"o\">]</span>\n          <span class=\"n\">intro</span> <span class=\"n\">c</span>\n          <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">@</span><span class=\"n\">ConnectedComponent.isOdd_iff</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">myInst</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">myInst2</span> <span class=\"o\">:</span> <span class=\"n\">DecidableRel</span> <span class=\"o\">(</span><span class=\"n\">Subgraph.coe</span> <span class=\"o\">(</span><span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">Subgraph</span> <span class=\"n\">G</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">Adj</span><span class=\"o\">)</span> <span class=\"n\">c</span><span class=\"o\">)]</span>\n          <span class=\"n\">intro</span> <span class=\"n\">hodd</span>\n          <span class=\"k\">have</span> <span class=\"n\">heven</span> <span class=\"o\">:</span> <span class=\"n\">Even</span> <span class=\"o\">(</span><span class=\"n\">Fintype.card</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">ConnectedComponent.supp</span> <span class=\"n\">c</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n            <span class=\"n\">apply</span> <span class=\"n\">SimpleGraph.PerfectMatchingConnectedComponentEven</span> <span class=\"n\">M</span> <span class=\"n\">hM</span> <span class=\"n\">c</span>\n          <span class=\"n\">exact</span> <span class=\"n\">Nat.odd_iff_not_even.mp</span> <span class=\"n\">hodd</span> <span class=\"n\">heven</span>\n\n          <span class=\"n\">done</span>\n        <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h3</span><span class=\"o\">]</span>\n      <span class=\"o\">)</span>\n        <span class=\"n\">_</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"o\">}</span>\n  <span class=\"o\">{</span>\n    <span class=\"n\">cases</span> <span class=\"n\">nonempty_fintype</span> <span class=\"n\">V</span>\n    <span class=\"n\">intro</span> <span class=\"n\">h</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 404132764,
        "sender_full_name": "Pim Otte",
        "timestamp": 1700934703
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"519269\">@Pim Otte</span> There's one tricky dependent type obstacle along the way, but you can get around it with <code>generalize</code> (to be able to simplify <code>deleteVerts</code> on the empty set) and <code>subst</code> (to apply the simplification. The rest is using some library lemmas for connected components over equivalences, as well as being comfortable with moving between different notions of cardinality (and using <code>classical</code>).</p>\n<p>Here's the first <code>by</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>      <span class=\"o\">(</span><span class=\"kd\">by</span>\n        <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">G.Subgraph</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">deleteVerts</span> <span class=\"bp\">∅</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">coe.ConnectedComponent</span> <span class=\"bp\">|</span> <span class=\"n\">c.isOdd</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span>\n        <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">cardOddComponents</span><span class=\"o\">,</span> <span class=\"n\">this</span><span class=\"o\">]</span>\n          <span class=\"n\">simp</span>\n        <span class=\"n\">generalize</span> <span class=\"n\">hH</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">G.Subgraph</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">deleteVerts</span> <span class=\"bp\">∅</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">H</span>\n        <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Subgraph.deleteVerts_empty</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hH</span>\n        <span class=\"n\">subst</span> <span class=\"n\">hH</span>\n        <span class=\"n\">ext</span> <span class=\"n\">c</span>\n        <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Subgraph.induce_verts</span><span class=\"o\">,</span> <span class=\"n\">Subgraph.verts_top</span><span class=\"o\">,</span> <span class=\"n\">Set.mem_setOf_eq</span><span class=\"o\">,</span>\n          <span class=\"n\">Set.mem_empty_iff_false</span><span class=\"o\">,</span> <span class=\"n\">iff_false</span><span class=\"o\">]</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">ConnectedComponent.isOdd</span><span class=\"o\">,</span> <span class=\"n\">Nat.odd_iff_not_even</span><span class=\"o\">,</span> <span class=\"n\">not_not</span><span class=\"o\">]</span>\n        <span class=\"n\">classical</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.card_eq_fintype_card</span><span class=\"o\">]</span>\n        <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">SimpleGraph.PerfectMatchingConnectedComponentEven</span> <span class=\"n\">M</span> <span class=\"n\">hM</span>\n                  <span class=\"o\">(</span><span class=\"n\">Iso.connectedComponentEquiv</span> <span class=\"n\">Subgraph.topEquiv</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n        <span class=\"n\">convert</span> <span class=\"n\">this</span> <span class=\"n\">using</span> <span class=\"mi\">1</span>\n        <span class=\"n\">apply</span> <span class=\"n\">Fintype.card_congr</span>\n        <span class=\"n\">exact</span> <span class=\"n\">ConnectedComponent.isoEquivSupp</span> <span class=\"n\">Subgraph.topEquiv</span> <span class=\"n\">c</span>\n      <span class=\"o\">)</span>\n</code></pre></div>",
        "id": 404137532,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1700937119
    },
    {
        "content": "<p><code>Subgraph.topEquiv</code> is the isomorphism between a graph as a subgraph of itself and the graph</p>",
        "id": 404137679,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1700937170
    },
    {
        "content": "<p>I'm now running into a curious problem, which I have isolated. The <code>#check</code> below outputs <code>Subgraph.induce M (Lean.Internal.coeM (ConnectedComponent.supp c)) : Subgraph G</code>. The <code>Lean.Internal.coeM</code> seems weird, the docs seem to say that it's only for internal use, but I don't think I'm doing anything out there. Any pointers?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Combinatorics.SimpleGraph.Matching</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Combinatorics.SimpleGraph.Connectivity</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">SimpleGraph</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableRel</span> <span class=\"n\">G.Adj</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">Subgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hM</span> <span class=\"o\">:</span> <span class=\"n\">Subgraph.IsPerfectMatching</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">V</span><span class=\"o\">)(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ConnectedComponent</span> <span class=\"o\">((</span><span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">G.Subgraph</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">deleteVerts</span> <span class=\"n\">u</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">coe</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">M.induce</span> <span class=\"n\">c.supp</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 404715961,
        "sender_full_name": "Pim Otte",
        "timestamp": 1701204757
    },
    {
        "content": "<p>This usually occurs when you have a coercion <code>coe : A -&gt; B</code>, and you treat an element of <code>Set A</code> as an element of <code>Set B</code>.</p>",
        "id": 404716322,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1701204921
    },
    {
        "content": "<p>Although I think this was fixed recently. I get <code>Subgraph.induce M (Subtype.val '' ConnectedComponent.supp c) : Subgraph G</code>.</p>",
        "id": 404716805,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1701205113
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/8413\">#8413</a></p>",
        "id": 404716879,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1701205149
    },
    {
        "content": "<p>Ah, yes, a mathlib update solved it, thanks!</p>",
        "id": 404717611,
        "sender_full_name": "Pim Otte",
        "timestamp": 1701205366
    },
    {
        "content": "<p>A lot of ungolfed code, but, the first direction is done:) (I ended up dropping the induction on u)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Combinatorics.SimpleGraph.Matching</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Combinatorics.SimpleGraph.Connectivity</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Card</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Finite</span>\n\n<span class=\"kn\">import</span> <span class=\"n\">LeanInfer</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">SimpleGraph</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">}</span>\n\n<span class=\"sd\">/-- A connected component is *odd* if it has an add number of vertices</span>\n<span class=\"sd\">in its support. -/</span>\n<span class=\"c1\">-- Note: only connected components with finitely many vertices can be odd.</span>\n<span class=\"kd\">def</span> <span class=\"n\">ConnectedComponent.isOdd</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">G.ConnectedComponent</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Odd</span> <span class=\"o\">(</span><span class=\"n\">Nat.card</span> <span class=\"n\">c.supp</span><span class=\"o\">)</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">cardOddComponents</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Set.ncard</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">G.ConnectedComponent</span> <span class=\"bp\">|</span> <span class=\"n\">c.isOdd</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">ConnectedComponent.isOdd_iff</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">G.ConnectedComponent</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">c.supp</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"n\">c.isOdd</span> <span class=\"bp\">↔</span> <span class=\"n\">Odd</span> <span class=\"o\">(</span><span class=\"n\">Fintype.card</span> <span class=\"n\">c.supp</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">isOdd</span><span class=\"o\">,</span> <span class=\"n\">Nat.card_eq_fintype_card</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- This is `Quot.recOn` specialized to connected components.</span>\n<span class=\"sd\">For convenience, it strengthens the assumptions in the hypothesis</span>\n<span class=\"sd\">to provide a path between the vertices. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">elab_as_elim</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">ConnectedComponent.recOn</span>\n    <span class=\"o\">{</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"n\">G.ConnectedComponent</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">G.ConnectedComponent</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">G.connectedComponentMk</span> <span class=\"n\">v</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.Walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">p.IsPath</span><span class=\"o\">),</span>\n      <span class=\"n\">ConnectedComponent.sound</span> <span class=\"n\">p.reachable</span> <span class=\"bp\">▸</span> <span class=\"n\">f</span> <span class=\"n\">u</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">motive</span> <span class=\"n\">c</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Quot.recOn</span> <span class=\"n\">c</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">r</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">r.elim_path</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">p</span> <span class=\"n\">p.2</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableRel</span> <span class=\"n\">G.Adj</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">G.ConnectedComponent</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">c.supp</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">c.recOn</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">w</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">ConnectedComponent.mem_supp_iff</span><span class=\"o\">,</span> <span class=\"n\">ConnectedComponent.eq</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">infer_instance</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Subsingleton.elim</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n\n\n\n<span class=\"kd\">lemma</span> <span class=\"n\">deleteVerts_verts_notmem_deleted</span> <span class=\"o\">[</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">DecidableRel</span> <span class=\"n\">G.Adj</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">G.Subgraph</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">deleteVerts</span> <span class=\"n\">u</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">verts</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a.val</span> <span class=\"bp\">∉</span> <span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"n\">a.prop.2</span>\n\n\n<span class=\"kd\">instance</span> <span class=\"n\">myInst3</span> <span class=\"o\">[</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">DecidableRel</span> <span class=\"n\">G.Adj</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">DecidableRel</span> <span class=\"o\">(((</span><span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">G.Subgraph</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">deleteVerts</span> <span class=\"n\">u</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">coe</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">Adj</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n  <span class=\"n\">cases</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">isFalse</span> <span class=\"n\">nh</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span>\n    <span class=\"n\">exact</span> <span class=\"bp\">.</span><span class=\"n\">isFalse</span> <span class=\"o\">(</span><span class=\"kd\">by</span>\n      <span class=\"n\">intro</span> <span class=\"n\">w</span>\n      <span class=\"n\">exact</span> <span class=\"n\">nh</span> <span class=\"o\">(</span><span class=\"n\">Subgraph.coe_adj_sub</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">w</span><span class=\"o\">)</span>\n      <span class=\"o\">)</span>\n  <span class=\"o\">}</span>\n  <span class=\"bp\">|</span> <span class=\"n\">isTrue</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span>\n    <span class=\"n\">exact</span> <span class=\"bp\">.</span><span class=\"n\">isTrue</span> <span class=\"o\">(</span><span class=\"kd\">by</span>\n      <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"n\">SimpleGraph.Subgraph.Adj.coe</span><span class=\"o\">)</span>\n      <span class=\"n\">apply</span> <span class=\"n\">Subgraph.deleteVerts_adj.mpr</span>\n      <span class=\"n\">constructor</span>\n      <span class=\"bp\">·</span> <span class=\"n\">trivial</span>\n      <span class=\"n\">constructor</span>\n      <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">deleteVerts_verts_notmem_deleted</span> <span class=\"n\">x</span>\n      <span class=\"n\">constructor</span>\n      <span class=\"bp\">·</span> <span class=\"n\">trivial</span>\n      <span class=\"n\">constructor</span>\n      <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">deleteVerts_verts_notmem_deleted</span> <span class=\"n\">y</span>\n      <span class=\"n\">exact</span> <span class=\"n\">h</span>\n      <span class=\"n\">done</span>\n\n    <span class=\"o\">)</span>\n  <span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">myInst2</span> <span class=\"o\">[</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">DecidableRel</span> <span class=\"n\">G.Adj</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">DecidableRel</span> <span class=\"o\">(</span><span class=\"n\">Subgraph.coe</span> <span class=\"o\">(</span><span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">Subgraph</span> <span class=\"n\">G</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">Adj</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n  <span class=\"n\">cases</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">isFalse</span> <span class=\"n\">nh</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span>\n    <span class=\"n\">exact</span> <span class=\"bp\">.</span><span class=\"n\">isFalse</span> <span class=\"o\">(</span><span class=\"kd\">by</span>\n      <span class=\"n\">intro</span> <span class=\"n\">w</span>\n      <span class=\"n\">exact</span> <span class=\"n\">nh</span> <span class=\"o\">(</span><span class=\"n\">Subgraph.coe_adj_sub</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">w</span><span class=\"o\">)</span>\n      <span class=\"o\">)</span>\n  <span class=\"o\">}</span>\n  <span class=\"bp\">|</span> <span class=\"n\">isTrue</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span>\n    <span class=\"n\">exact</span> <span class=\"bp\">.</span><span class=\"n\">isTrue</span> <span class=\"o\">(</span><span class=\"kd\">by</span>\n      <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"n\">Subgraph.coe_adj_sub</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n      <span class=\"n\">exact</span> <span class=\"n\">h</span>\n    <span class=\"o\">)</span>\n  <span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">myInst</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableRel</span> <span class=\"n\">G.Adj</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">ConnectedComponent</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Fintype</span> <span class=\"n\">u.supp</span> <span class=\"o\">:=</span> <span class=\"n\">inferInstance</span>\n\n\n<span class=\"kd\">lemma</span> <span class=\"n\">SimpleGraph.PerfectMatchingInducesMatchingOnComponent</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableRel</span> <span class=\"n\">G.Adj</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">Subgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hM</span> <span class=\"o\">:</span> <span class=\"n\">Subgraph.IsPerfectMatching</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ConnectedComponent</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Subgraph.IsMatching</span> <span class=\"o\">(</span><span class=\"n\">M.induce</span> <span class=\"n\">c.supp</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intro</span> <span class=\"n\">v</span> <span class=\"n\">hv</span>\n    <span class=\"k\">have</span> <span class=\"n\">vM</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">M.verts</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">apply</span> <span class=\"n\">hM.2</span>\n    <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">hM.1</span> <span class=\"n\">vM</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">hw</span> <span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h</span>\n    <span class=\"n\">use</span> <span class=\"n\">w</span>\n    <span class=\"n\">dsimp</span> <span class=\"n\">at</span> <span class=\"bp\">*</span>\n    <span class=\"n\">constructor</span>\n    <span class=\"bp\">·</span> <span class=\"n\">constructor</span>\n      <span class=\"bp\">·</span> <span class=\"n\">assumption</span>\n      <span class=\"bp\">·</span> <span class=\"n\">constructor</span>\n        <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">ConnectedComponent.mem_supp_iff</span><span class=\"o\">]</span>\n          <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">ConnectedComponent.mem_supp_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hv</span>\n          <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">hv</span><span class=\"o\">]</span>\n          <span class=\"n\">apply</span> <span class=\"n\">ConnectedComponent.connectedComponentMk_eq_of_adj</span>\n          <span class=\"n\">apply</span> <span class=\"n\">M.adj_sub</span>\n          <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Subgraph.adj_comm</span><span class=\"o\">]</span>\n          <span class=\"n\">exact</span> <span class=\"n\">hw.1</span>\n        <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">hw.1</span>\n    <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">y</span> <span class=\"n\">hy</span>\n      <span class=\"n\">apply</span> <span class=\"n\">hw.2</span>\n      <span class=\"n\">exact</span> <span class=\"n\">hy.2.2</span>\n    <span class=\"n\">done</span>\n\n\n<span class=\"kd\">lemma</span> <span class=\"n\">SimpleGraph.PerfectMatchingConnectedComponentEven</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableRel</span> <span class=\"n\">G.Adj</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">Subgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hM</span> <span class=\"o\">:</span> <span class=\"n\">Subgraph.IsPerfectMatching</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ConnectedComponent</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Even</span> <span class=\"o\">(</span><span class=\"n\">Fintype.card</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">ConnectedComponent.supp</span> <span class=\"n\">c</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">classical</span>\n    <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Even</span> <span class=\"o\">(</span><span class=\"n\">M.induce</span> <span class=\"n\">c.supp</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">verts.toFinset.card</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">exact</span> <span class=\"n\">Subgraph.IsMatching.even_card</span> <span class=\"o\">(</span><span class=\"n\">SimpleGraph.PerfectMatchingInducesMatchingOnComponent</span> <span class=\"n\">M</span> <span class=\"n\">hM</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span> <span class=\"n\">k</span> <span class=\"o\">,</span> <span class=\"n\">hk</span> <span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h</span>\n    <span class=\"n\">use</span> <span class=\"n\">k</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">hk</span><span class=\"o\">,</span> <span class=\"n\">Subgraph.induce_verts</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">Fintype.card_ofFinset</span><span class=\"o\">]</span>\n    <span class=\"n\">congr</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">ConnectedComponent.mem_supp_iff</span><span class=\"o\">,</span> <span class=\"n\">Finset.mem_univ</span><span class=\"o\">,</span> <span class=\"n\">forall_true_left</span><span class=\"o\">]</span>\n    <span class=\"n\">exact</span> <span class=\"n\">Set.filter_mem_univ_eq_toFinset</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">connectedComponentMk</span> <span class=\"n\">G</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">c</span>\n\n    <span class=\"n\">done</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">instance</span> <span class=\"n\">myInst5</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Fintype</span> <span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">exact</span> <span class=\"n\">Fintype.ofFinite</span> <span class=\"bp\">↑</span><span class=\"n\">u</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">instance</span> <span class=\"n\">myInst4</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableRel</span> <span class=\"n\">G.Adj</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">u</span><span class=\"o\">]:</span>\n    <span class=\"n\">Fintype</span> <span class=\"o\">((</span><span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">G.Subgraph</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">deleteVerts</span> <span class=\"n\">u</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">verts</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Subgraph.induce_verts</span><span class=\"o\">,</span> <span class=\"n\">Subgraph.verts_top</span><span class=\"o\">]</span>\n      <span class=\"n\">infer_instance</span>\n\n\n<span class=\"kd\">theorem</span> <span class=\"n\">mem_supp_of_adj</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">G.ConnectedComponent</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hv</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">C.supp</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hadj</span> <span class=\"o\">:</span> <span class=\"n\">G.Adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n       <span class=\"n\">w</span> <span class=\"bp\">∈</span> <span class=\"n\">C.supp</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">ConnectedComponent.mem_supp_iff</span><span class=\"o\">]</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"o\">(</span><span class=\"n\">ConnectedComponent.mem_supp_iff</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">hv</span><span class=\"o\">]</span>\n      <span class=\"n\">exact</span> <span class=\"n\">ConnectedComponent.connectedComponentMk_eq_of_adj</span> <span class=\"o\">(</span><span class=\"n\">adj_symm</span> <span class=\"n\">G</span> <span class=\"n\">hadj</span><span class=\"o\">)</span>\n\n\n<span class=\"kd\">theorem</span> <span class=\"n\">mem_supp_of_adj'</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableRel</span> <span class=\"n\">G.Adj</span><span class=\"o\">]</span>  <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ConnectedComponent</span> <span class=\"o\">((</span><span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">Subgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">deleteVerts</span> <span class=\"n\">u</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">coe</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hv</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">Subtype.val</span> <span class=\"bp\">''</span> <span class=\"n\">c.supp</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hw</span> <span class=\"o\">:</span> <span class=\"n\">w</span> <span class=\"bp\">∈</span> <span class=\"o\">((</span><span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">Subgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">deleteVerts</span>  <span class=\"n\">u</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">verts</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"n\">hadj</span> <span class=\"o\">:</span> <span class=\"n\">G.Adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n       <span class=\"n\">w</span> <span class=\"bp\">∈</span> <span class=\"n\">Subtype.val</span> <span class=\"bp\">''</span> <span class=\"n\">c.supp</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Set.mem_image</span><span class=\"o\">]</span>\n      <span class=\"n\">obtain</span> <span class=\"o\">⟨</span> <span class=\"n\">v'</span> <span class=\"o\">,</span> <span class=\"n\">hv'</span> <span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hv</span>\n      <span class=\"n\">use</span> <span class=\"o\">⟨</span> <span class=\"n\">w</span> <span class=\"o\">,</span> <span class=\"o\">⟨</span> <span class=\"kd\">by</span> <span class=\"n\">trivial</span> <span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">refine</span> <span class=\"n\">Set.not_mem_of_mem_diff</span> <span class=\"n\">hw</span> <span class=\"o\">⟩</span> <span class=\"o\">⟩</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">ConnectedComponent.mem_supp_iff</span><span class=\"o\">]</span>\n      <span class=\"n\">constructor</span>\n      <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"o\">(</span><span class=\"n\">ConnectedComponent.mem_supp_iff</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">hv'.1</span><span class=\"o\">]</span>\n        <span class=\"n\">apply</span> <span class=\"n\">ConnectedComponent.connectedComponentMk_eq_of_adj</span>\n        <span class=\"n\">apply</span> <span class=\"n\">SimpleGraph.Subgraph.Adj.coe</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Subgraph.deleteVerts_adj</span><span class=\"o\">]</span>\n        <span class=\"n\">constructor</span>\n        <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">trivial</span>\n        <span class=\"bp\">·</span> <span class=\"n\">constructor</span>\n          <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">Set.not_mem_of_mem_diff</span> <span class=\"n\">hw</span>\n          <span class=\"bp\">·</span> <span class=\"n\">constructor</span>\n            <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">trivial</span>\n            <span class=\"bp\">·</span> <span class=\"n\">constructor</span>\n              <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">deleteVerts_verts_notmem_deleted</span> <span class=\"n\">v'</span>\n              <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Subgraph.top_adj</span><span class=\"o\">]</span>\n                <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hv'.2</span><span class=\"o\">]</span>\n                <span class=\"n\">exact</span> <span class=\"n\">adj_symm</span> <span class=\"n\">G</span> <span class=\"n\">hadj</span>\n\n\n      <span class=\"bp\">·</span> <span class=\"n\">dsimp</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">OddComponentHasNodeMatchedOutside</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableRel</span> <span class=\"n\">G.Adj</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">Subgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hM</span> <span class=\"o\">:</span> <span class=\"n\">Subgraph.IsPerfectMatching</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ConnectedComponent</span> <span class=\"o\">((</span><span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">Subgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">deleteVerts</span> <span class=\"n\">u</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">coe</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">codd</span> <span class=\"o\">:</span> <span class=\"n\">c.isOdd</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">Set.Elem</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Set.Elem</span> <span class=\"o\">((</span><span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">G.Subgraph</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">deleteVerts</span> <span class=\"n\">u</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">verts</span><span class=\"o\">)</span> <span class=\"o\">,</span>  <span class=\"n\">M.Adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">∧</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">c.supp</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">ConnectedComponent.isOdd_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">codd</span>\n\n      <span class=\"n\">by_contra'</span> <span class=\"n\">h</span>\n\n\n      <span class=\"k\">have</span> <span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Subgraph.IsMatching</span> <span class=\"o\">(</span><span class=\"n\">M.induce</span> <span class=\"n\">c.supp</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n        <span class=\"n\">intro</span> <span class=\"n\">v</span> <span class=\"n\">hv</span>\n        <span class=\"n\">obtain</span> <span class=\"o\">⟨</span> <span class=\"n\">w</span> <span class=\"o\">,</span> <span class=\"n\">hw</span> <span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hM.1</span> <span class=\"o\">(</span><span class=\"n\">hM.2</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n        <span class=\"n\">obtain</span> <span class=\"o\">⟨</span> <span class=\"n\">v'</span> <span class=\"o\">,</span> <span class=\"n\">hv'</span> <span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hv</span>\n        <span class=\"n\">use</span> <span class=\"n\">w</span>\n        <span class=\"n\">dsimp</span> <span class=\"n\">at</span> <span class=\"bp\">*</span>\n        <span class=\"n\">constructor</span>\n        <span class=\"bp\">·</span> <span class=\"n\">constructor</span>\n          <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span> <span class=\"n\">v'</span> <span class=\"o\">,</span> <span class=\"n\">hv'</span> <span class=\"o\">⟩</span>\n          <span class=\"bp\">·</span> <span class=\"n\">constructor</span>\n            <span class=\"bp\">·</span> <span class=\"k\">have</span> <span class=\"n\">h''</span> <span class=\"o\">:</span> <span class=\"n\">w</span> <span class=\"bp\">∉</span> <span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n                <span class=\"n\">intro</span> <span class=\"n\">hw'</span>\n                <span class=\"n\">apply</span> <span class=\"n\">h</span> <span class=\"o\">⟨</span> <span class=\"n\">w</span> <span class=\"o\">,</span> <span class=\"n\">hw'</span> <span class=\"o\">⟩</span> <span class=\"n\">v'</span> <span class=\"n\">_</span>\n                <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">hv'.1</span>\n                <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hv'.2</span><span class=\"o\">]</span>\n                <span class=\"n\">exact</span> <span class=\"n\">hw.1</span>\n                <span class=\"n\">done</span>\n\n              <span class=\"n\">apply</span> <span class=\"n\">mem_supp_of_adj'</span> <span class=\"n\">c</span> <span class=\"n\">v'</span> <span class=\"n\">w</span> <span class=\"o\">⟨</span> <span class=\"n\">v'</span> <span class=\"o\">,</span> <span class=\"o\">⟨</span> <span class=\"n\">hv'.1</span> <span class=\"o\">,</span> <span class=\"n\">rfl</span> <span class=\"o\">⟩</span> <span class=\"o\">⟩</span> <span class=\"o\">⟨</span> <span class=\"kd\">by</span> <span class=\"n\">trivial</span> <span class=\"o\">,</span> <span class=\"n\">h''</span> <span class=\"o\">⟩</span>\n              <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hv'.2</span><span class=\"o\">]</span>\n              <span class=\"n\">exact</span> <span class=\"n\">Subgraph.adj_sub</span> <span class=\"n\">_</span> <span class=\"n\">hw.1</span>\n            <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">hw.1</span>\n        <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">y</span> <span class=\"n\">hy</span>\n          <span class=\"n\">apply</span> <span class=\"n\">hw.2</span>\n          <span class=\"n\">exact</span> <span class=\"n\">hy.2.2</span>\n        <span class=\"n\">done</span>\n\n      <span class=\"n\">apply</span> <span class=\"n\">Nat.odd_iff_not_even.mp</span> <span class=\"n\">codd</span>\n      <span class=\"k\">have</span> <span class=\"n\">h''</span> <span class=\"o\">:=</span> <span class=\"n\">Subgraph.IsMatching.even_card</span> <span class=\"n\">h'</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Subgraph.induce_verts</span><span class=\"o\">,</span> <span class=\"n\">Subgraph.verts_top</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h''</span>\n      <span class=\"n\">unfold</span> <span class=\"n\">Fintype.card</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.even_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h''</span> <span class=\"bp\">⊢</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">h''</span><span class=\"o\">]</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span> <span class=\"n\">Set.toFinset_image</span> <span class=\"o\">]</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Finset.card_image_of_injective</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">Subtype.val_injective</span><span class=\"o\">)]</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Subgraph.induce_verts</span><span class=\"o\">,</span> <span class=\"n\">Subgraph.verts_top</span><span class=\"o\">,</span> <span class=\"n\">Set.toFinset_card</span><span class=\"o\">]</span>\n      <span class=\"n\">rfl</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">tutte</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Inhabited</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableRel</span> <span class=\"n\">G.Adj</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">Subgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">,</span> <span class=\"n\">M.IsPerfectMatching</span><span class=\"o\">)</span> <span class=\"bp\">↔</span>\n      <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">V</span><span class=\"o\">),</span>\n        <span class=\"n\">cardOddComponents</span> <span class=\"o\">((</span><span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">G.Subgraph</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">deleteVerts</span> <span class=\"n\">u</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">coe</span> <span class=\"bp\">≤</span> <span class=\"n\">u.ncard</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"o\">{</span>\n    <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">hM</span><span class=\"o\">⟩</span> <span class=\"n\">u</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">cardOddComponents</span>\n    <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ConnectedComponent</span> <span class=\"o\">((</span><span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">Subgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">deleteVerts</span> <span class=\"n\">u</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">coe</span> <span class=\"bp\">|</span> <span class=\"n\">ConnectedComponent.isOdd</span> <span class=\"n\">c</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">u</span> <span class=\"o\">:=</span>\n      <span class=\"k\">fun</span> <span class=\"n\">c</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Exists.choose</span> <span class=\"o\">(</span><span class=\"n\">OddComponentHasNodeMatchedOutside</span> <span class=\"n\">M</span> <span class=\"n\">hM</span> <span class=\"n\">u</span> <span class=\"n\">c</span> <span class=\"n\">c.2</span><span class=\"o\">)</span>\n\n    <span class=\"k\">let</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">ConnectedComponent</span> <span class=\"o\">((</span><span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">Subgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">deleteVerts</span> <span class=\"n\">u</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">coe</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">c</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Odd</span> <span class=\"o\">(</span><span class=\"n\">Fintype.card</span> <span class=\"n\">c.supp</span><span class=\"o\">)</span> <span class=\"k\">then</span> <span class=\"n\">f</span> <span class=\"o\">⟨</span> <span class=\"n\">c</span> <span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"kd\">by</span>\n            <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">ConnectedComponent.isOdd_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n            <span class=\"n\">exact</span> <span class=\"n\">h</span>\n      <span class=\"o\">)</span> <span class=\"o\">⟩</span> <span class=\"k\">else</span> <span class=\"n\">default</span>\n\n    <span class=\"n\">exact</span> <span class=\"n\">Set.ncard_le_ncard_of_injOn</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"kd\">by</span>\n      <span class=\"n\">intro</span> <span class=\"n\">a</span> <span class=\"n\">ha</span>\n      <span class=\"n\">dsimp</span> <span class=\"n\">at</span> <span class=\"n\">ha</span>\n      <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">⟨</span> <span class=\"n\">a</span> <span class=\"o\">,</span> <span class=\"n\">ha</span> <span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">dite_eq_iff</span><span class=\"o\">]</span>\n        <span class=\"n\">left</span>\n        <span class=\"n\">use</span> <span class=\"o\">(</span><span class=\"n\">ConnectedComponent.isOdd_iff</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">ha</span>\n        <span class=\"n\">done</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n      <span class=\"n\">dsimp</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Set.mem_def</span><span class=\"o\">]</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">ConnectedComponent.mem_supp_iff</span><span class=\"o\">,</span> <span class=\"n\">Subtype.exists</span><span class=\"o\">,</span> <span class=\"n\">Set.mem_diff</span><span class=\"o\">,</span> <span class=\"n\">Set.mem_univ</span><span class=\"o\">,</span>\n        <span class=\"n\">true_and</span><span class=\"o\">,</span> <span class=\"n\">exists_and_left</span><span class=\"o\">]</span>\n      <span class=\"n\">apply</span> <span class=\"n\">Subtype.prop</span>\n      <span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span>\n        <span class=\"n\">intro</span> <span class=\"n\">x</span> <span class=\"n\">hx</span> <span class=\"n\">y</span> <span class=\"n\">hy</span> <span class=\"n\">hxy</span>\n        <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">⟨</span> <span class=\"n\">x</span> <span class=\"o\">,</span> <span class=\"n\">hx</span> <span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n          <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">dite_eq_iff</span><span class=\"o\">]</span>\n          <span class=\"n\">left</span>\n          <span class=\"n\">use</span> <span class=\"o\">(</span><span class=\"n\">ConnectedComponent.isOdd_iff</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">hx</span>\n          <span class=\"n\">done</span>\n        <span class=\"k\">have</span> <span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">⟨</span> <span class=\"n\">y</span> <span class=\"o\">,</span> <span class=\"n\">hy</span> <span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n          <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">dite_eq_iff</span><span class=\"o\">]</span>\n          <span class=\"n\">left</span>\n          <span class=\"n\">use</span> <span class=\"o\">(</span><span class=\"n\">ConnectedComponent.isOdd_iff</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">hy</span>\n          <span class=\"n\">done</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">h'</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hxy</span>\n\n        <span class=\"n\">dsimp</span> <span class=\"n\">at</span> <span class=\"n\">hxy</span>\n        <span class=\"n\">obtain</span> <span class=\"o\">⟨</span> <span class=\"n\">v</span> <span class=\"o\">,</span> <span class=\"n\">hv</span> <span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">OddComponentHasNodeMatchedOutside</span> <span class=\"n\">M</span> <span class=\"n\">hM</span> <span class=\"n\">u</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">choose_spec</span>\n        <span class=\"n\">obtain</span> <span class=\"o\">⟨</span> <span class=\"n\">v'</span> <span class=\"o\">,</span> <span class=\"n\">hv'</span> <span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">OddComponentHasNodeMatchedOutside</span> <span class=\"n\">M</span> <span class=\"n\">hM</span> <span class=\"n\">u</span> <span class=\"n\">y</span> <span class=\"n\">hy</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">choose_spec</span>\n\n\n        <span class=\"k\">have</span> <span class=\"o\">⟨</span> <span class=\"n\">w</span> <span class=\"o\">,</span> <span class=\"n\">hw</span> <span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">Subgraph.isPerfectMatching_iff</span> <span class=\"n\">M</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">hM</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">⟨</span> <span class=\"n\">x</span> <span class=\"o\">,</span> <span class=\"n\">hx</span> <span class=\"o\">⟩)</span>\n        <span class=\"k\">have</span> <span class=\"n\">h''</span> <span class=\"o\">:=</span> <span class=\"n\">hw.2</span> <span class=\"n\">_</span> <span class=\"n\">hv.1.symm</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hxy</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hw</span>\n        <span class=\"k\">have</span> <span class=\"n\">h'''</span> <span class=\"o\">:=</span> <span class=\"n\">hw.2</span> <span class=\"n\">_</span> <span class=\"n\">hv'.1.symm</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">h'''</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h''</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"o\">((</span><span class=\"n\">ConnectedComponent.mem_supp_iff</span> <span class=\"n\">x</span> <span class=\"n\">v</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">hv.2</span><span class=\"o\">)]</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"o\">((</span><span class=\"n\">ConnectedComponent.mem_supp_iff</span> <span class=\"n\">y</span> <span class=\"n\">v'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">hv'.2</span><span class=\"o\">)]</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Subtype.val_injective</span> <span class=\"n\">h''</span><span class=\"o\">]</span>\n      <span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Set.toFinite</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n  <span class=\"o\">}</span>\n  <span class=\"o\">{</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 405695262,
        "sender_full_name": "Pim Otte",
        "timestamp": 1701635385
    },
    {
        "content": "<p>I've been mapping out the other direction  The proof on <a href=\"https://en.wikipedia.org/wiki/Tutte_theorem#Proof\">wikipedia</a> seems fairly direct and suitable. Every proof does start with some reasoning why it's okay to take G as edge-maximal, and I was wondering how to approach that. I came up with the statement below:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"k\">have</span> <span class=\"n\">hEdgeMaximal</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"bp\">¬</span> <span class=\"n\">G.Adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">Subgraph</span> <span class=\"o\">((</span><span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">Subgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">deleteVerts</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">})</span><span class=\"bp\">.</span><span class=\"n\">coe</span><span class=\"o\">),</span> <span class=\"n\">M.IsPerfectMatching</span>\n      <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>This still needs a little shaving because I can't really assume G itself is edge maximal, but in any case I can think of two other approaches: 1. Adding the edge instead of removing the nodes. (This is what the paper proofs do, but I think this is equivalent and better supported. 2. Somehow using the lattice structure. This seems really elegant, but I have no idea if it's possible to set something up along the lines of \"an edge-maximal G that has no perfect matching\". </p>\n<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> Do you have some intuition on which of these approaches is most suitable/idiomatic?</p>",
        "id": 406155960,
        "sender_full_name": "Pim Otte",
        "timestamp": 1701809153
    },
    {
        "content": "<p>Deleting vertices sets you up for dependent type problems, so if you can formulate the argument in terms of edges easily enough, I think you'll run into fewer type theory issues. For adding an edge to a graph, you can take the sup with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.subgraphOfAdj#doc\">docs#SimpleGraph.subgraphOfAdj</a>, though you could also define the positive version of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.deleteEdges#doc\">docs#SimpleGraph.deleteEdges</a> that uses <code>Sym2.ToRel s</code> for the Adj relation. (Note that you might not want to talk about edges themselves at all if you can help it, since their undirected nature can make things combinatorially complicated.)</p>\n<p>I'm not sure it's correct, but a lattice version of edge maximality of <code>G</code> might be \"for all graphs <code>G' : SimpleGraph V</code> such that <code>G &lt; G'</code> then there exists <code>M : Subgraph G'</code> such that <code>M.IsPerfectMatching</code>\"</p>",
        "id": 406163199,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1701812024
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> I've made some progress, do you have any thoughts or pointers on the sorry's or the structure I've built?:)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Combinatorics.SimpleGraph.Matching</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Combinatorics.SimpleGraph.Connectivity</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Card</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Finite</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">SimpleGraph</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">}</span>\n\n<span class=\"sd\">/-- A connected component is *odd* if it has an add number of vertices</span>\n<span class=\"sd\">in its support. -/</span>\n<span class=\"c1\">-- Note: only connected components with finitely many vertices can be odd.</span>\n<span class=\"kd\">def</span> <span class=\"n\">ConnectedComponent.isOdd</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">G.ConnectedComponent</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Odd</span> <span class=\"o\">(</span><span class=\"n\">Nat.card</span> <span class=\"n\">c.supp</span><span class=\"o\">)</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">cardOddComponents</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Set.ncard</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">G.ConnectedComponent</span> <span class=\"bp\">|</span> <span class=\"n\">c.isOdd</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">ConnectedComponent.isOdd_iff</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">G.ConnectedComponent</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">c.supp</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"n\">c.isOdd</span> <span class=\"bp\">↔</span> <span class=\"n\">Odd</span> <span class=\"o\">(</span><span class=\"n\">Fintype.card</span> <span class=\"n\">c.supp</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">isOdd</span><span class=\"o\">,</span> <span class=\"n\">Nat.card_eq_fintype_card</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- This is `Quot.recOn` specialized to connected components.</span>\n<span class=\"sd\">For convenience, it strengthens the assumptions in the hypothesis</span>\n<span class=\"sd\">to provide a path between the vertices. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">elab_as_elim</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">ConnectedComponent.recOn</span>\n    <span class=\"o\">{</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"n\">G.ConnectedComponent</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">G.ConnectedComponent</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">G.connectedComponentMk</span> <span class=\"n\">v</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.Walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">p.IsPath</span><span class=\"o\">),</span>\n      <span class=\"n\">ConnectedComponent.sound</span> <span class=\"n\">p.reachable</span> <span class=\"bp\">▸</span> <span class=\"n\">f</span> <span class=\"n\">u</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">motive</span> <span class=\"n\">c</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Quot.recOn</span> <span class=\"n\">c</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">r</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">r.elim_path</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">p</span> <span class=\"n\">p.2</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableRel</span> <span class=\"n\">G.Adj</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">G.ConnectedComponent</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">c.supp</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">c.recOn</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">w</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">ConnectedComponent.mem_supp_iff</span><span class=\"o\">,</span> <span class=\"n\">ConnectedComponent.eq</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">infer_instance</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Subsingleton.elim</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n\n\n<span class=\"kd\">instance</span> <span class=\"n\">myInst</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableRel</span> <span class=\"n\">G.Adj</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">ConnectedComponent</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Fintype</span> <span class=\"n\">u.supp</span> <span class=\"o\">:=</span> <span class=\"n\">inferInstance</span>\n\n\n\n<span class=\"kd\">lemma</span> <span class=\"n\">oddComponentsIncrease</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Inhabited</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">V</span><span class=\"o\">]</span>  <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">≤</span>  <span class=\"n\">G'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Finite</span> <span class=\"n\">u</span><span class=\"o\">]:</span>\n    <span class=\"n\">cardOddComponents</span> <span class=\"o\">((</span><span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">Subgraph</span> <span class=\"n\">G'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">deleteVerts</span> <span class=\"n\">u</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">coe</span> <span class=\"bp\">≤</span> <span class=\"n\">cardOddComponents</span> <span class=\"o\">((</span><span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">Subgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">deleteVerts</span> <span class=\"n\">u</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"c1\">-- I left out [DecideableRel G.Adj] [Decidable G'.Adj] because it would be nice if this can be done without it</span>\n      <span class=\"c1\">-- it would need to proved for Gmax</span>\n\n      <span class=\"c1\">-- Seems doable but involved</span>\n      <span class=\"k\">let</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">ConnectedComponent</span> <span class=\"o\">((</span><span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">Subgraph</span> <span class=\"n\">G'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">deleteVerts</span> <span class=\"n\">u</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">coe</span> <span class=\"bp\">→</span> <span class=\"n\">ConnectedComponent</span> <span class=\"o\">((</span><span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">Subgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">deleteVerts</span> <span class=\"n\">u</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n      <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">Finite</span> <span class=\"o\">(</span><span class=\"n\">ConnectedComponent</span> <span class=\"o\">((</span><span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">Subgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">deleteVerts</span> <span class=\"n\">u</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">coe</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n      <span class=\"n\">exact</span> <span class=\"n\">Set.ncard_le_ncard_of_injOn</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"gr\">sorry</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"gr\">sorry</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">tutte</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Inhabited</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableRel</span> <span class=\"n\">G.Adj</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">Subgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">,</span> <span class=\"n\">M.IsPerfectMatching</span><span class=\"o\">)</span> <span class=\"bp\">↔</span>\n      <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">V</span><span class=\"o\">),</span>\n        <span class=\"n\">cardOddComponents</span> <span class=\"o\">((</span><span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">G.Subgraph</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">deleteVerts</span> <span class=\"n\">u</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">coe</span> <span class=\"bp\">≤</span> <span class=\"n\">u.ncard</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"o\">{</span>\n    <span class=\"c1\">-- actually solved, omitted for brevity</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"o\">}</span>\n  <span class=\"o\">{</span>\n    <span class=\"n\">contrapose</span><span class=\"bp\">!</span>\n    <span class=\"n\">intro</span> <span class=\"n\">h</span>\n\n    <span class=\"k\">have</span> <span class=\"o\">⟨</span> <span class=\"n\">Gmax</span> <span class=\"o\">,</span> <span class=\"n\">hGmax</span> <span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">),</span>\n      <span class=\"n\">G</span> <span class=\"bp\">≤</span> <span class=\"n\">G'</span> <span class=\"bp\">∧</span>\n      <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">Subgraph</span> <span class=\"n\">G'</span><span class=\"o\">),</span> <span class=\"bp\">¬</span> <span class=\"n\">M.IsPerfectMatching</span><span class=\"o\">)</span>  <span class=\"bp\">∧</span>\n      <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">G''</span> <span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">G'</span> <span class=\"bp\">&lt;</span> <span class=\"n\">G''</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">Subgraph</span> <span class=\"n\">G''</span><span class=\"o\">),</span> <span class=\"n\">M.IsPerfectMatching</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n        <span class=\"n\">by_contra'</span> <span class=\"n\">hc</span>\n        <span class=\"k\">have</span> <span class=\"o\">⟨</span> <span class=\"n\">H</span> <span class=\"o\">,</span> <span class=\"n\">hH</span> <span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hc</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">Eq.ge</span> <span class=\"n\">rfl</span><span class=\"o\">)</span> <span class=\"n\">h</span>\n        <span class=\"k\">have</span> <span class=\"o\">⟨</span> <span class=\"n\">H'</span> <span class=\"o\">,</span> <span class=\"n\">hH'</span> <span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hc</span> <span class=\"n\">H</span> <span class=\"o\">(</span><span class=\"n\">le_of_lt</span> <span class=\"n\">hH.1</span><span class=\"o\">)</span> <span class=\"n\">hH.2</span>\n        <span class=\"c1\">-- This sorry is kind of stumping me. I kind of want to make the argument</span>\n        <span class=\"c1\">-- that we can't have an infinite chain of strictly larger graphs.</span>\n        <span class=\"gr\">sorry</span>\n\n    <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">Set.ncard</span> <span class=\"n\">u</span> <span class=\"bp\">&lt;</span> <span class=\"n\">cardOddComponents</span> <span class=\"o\">((</span><span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">Subgraph</span> <span class=\"n\">Gmax</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">deleteVerts</span> <span class=\"n\">u</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">coe</span>\n    <span class=\"bp\">·</span> <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">hu</span> <span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">this</span>\n      <span class=\"n\">use</span> <span class=\"n\">u</span>\n      <span class=\"n\">exact</span> <span class=\"n\">lt_of_lt_of_le</span> <span class=\"n\">hu</span> <span class=\"o\">(</span><span class=\"kd\">by</span>\n        <span class=\"n\">exact</span> <span class=\"n\">oddComponentsIncrease</span> <span class=\"n\">G</span> <span class=\"n\">Gmax</span> <span class=\"n\">hGmax.1</span> <span class=\"n\">u</span>\n        <span class=\"o\">)</span>\n\n    <span class=\"k\">let</span> <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"bp\">|</span> <span class=\"n\">G.degree</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">Fintype.card</span> <span class=\"n\">V</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">}</span>\n\n    <span class=\"k\">let</span> <span class=\"n\">Gsplit</span> <span class=\"o\">:=</span> <span class=\"o\">((</span><span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">Subgraph</span> <span class=\"n\">Gmax</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">deleteVerts</span> <span class=\"n\">S</span><span class=\"o\">)</span>\n    <span class=\"k\">have</span> <span class=\"o\">⟨</span><span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">hKvw</span> <span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">ConnectedComponent</span> <span class=\"n\">Gsplit.coe</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span>  <span class=\"n\">Set.Elem</span> <span class=\"n\">Gsplit.verts</span><span class=\"o\">),</span>\n      <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">K.supp</span> <span class=\"bp\">∧</span> <span class=\"n\">w</span> <span class=\"bp\">∈</span> <span class=\"n\">K.supp</span> <span class=\"bp\">∧</span> <span class=\"n\">v</span> <span class=\"bp\">≠</span> <span class=\"n\">w</span> <span class=\"bp\">∧</span> <span class=\"bp\">¬</span> <span class=\"n\">Gmax.Adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n    <span class=\"gr\">sorry</span>\n  <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 408991467,
        "sender_full_name": "Pim Otte",
        "timestamp": 1703009709
    }
]