[
    {
        "content": "<p>I had hoped that I'd be able to brute-force this with <code>decide</code>, but it reaches the maximum recursion depth. Is there any hope to get this to work?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.Exponent</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.FieldTheory.Finite.Basic</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Monoid.ExponentExists.ofFintype</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Monoid.ExponentExists</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Monoid.ExponentExists</span><span class=\"o\">]</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">Fintype.card</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">Fintype.card_pos</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">g</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">orderOf_dvd_iff_pow_eq_one</span><span class=\"o\">]</span>\n  <span class=\"n\">exact</span> <span class=\"n\">orderOf_dvd_card</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Monoid.exponent</span> <span class=\"o\">(</span><span class=\"n\">Equiv.Perm</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">5</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"mi\">60</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">Monoid.ExponentExists.ofFintype</span> <span class=\"o\">(</span><span class=\"n\">Equiv.Perm</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">5</span><span class=\"o\">))</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Monoid.exponent</span><span class=\"o\">,</span> <span class=\"n\">dif_pos</span> <span class=\"n\">this</span><span class=\"o\">]</span>\n  <span class=\"n\">convert</span> <span class=\"o\">(</span><span class=\"n\">Nat.find_eq_iff</span> <span class=\"n\">this</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mpr</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Nat.zero_lt_succ</span><span class=\"o\">,</span> <span class=\"n\">true_and</span><span class=\"o\">,</span> <span class=\"n\">not_and</span><span class=\"o\">,</span> <span class=\"n\">not_forall</span><span class=\"o\">]</span>\n  <span class=\"n\">decide</span>\n</code></pre></div>\n<p>The goal does seem a little harsh at that point: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Equiv.Perm</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">5</span><span class=\"o\">)),</span> <span class=\"n\">g</span> <span class=\"bp\">^</span> <span class=\"mi\">60</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">60</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">¬</span><span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span>\n</code></pre></div>",
        "id": 403166584,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1700485813
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"n\">Nat.find</span> <span class=\"o\">(</span><span class=\"n\">Monoid.ExponentExists.ofFintype</span> <span class=\"o\">(</span><span class=\"n\">Equiv.Perm</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">5</span><span class=\"o\">)))</span>\n</code></pre></div>\n<p>is instant, but doesn't really count as a proof</p>",
        "id": 403166747,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1700485889
    },
    {
        "content": "<p>Alternatively, suggestions for a better proof are also helpful. This is an exercise from a class I took when I was younger and smarter, and I somehow doubt that \"brute force\" was the intended solution</p>",
        "id": 403167098,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1700486024
    },
    {
        "content": "<p>The math proof I would follow is the fact that if there is <code>g</code> such that <code>g^60 ≠ 1</code> then the order of <code>g</code> would be <code>120</code>, so the group would be cyclic.</p>",
        "id": 403168001,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1700486345
    },
    {
        "content": "<p>And to prove that anything smaller than <code>60</code> (wrt to division) cannot work one has to find elements of order <code>3</code>, <code>5</code> and <code>4</code>, but this is easy.</p>",
        "id": 403169085,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1700486719
    },
    {
        "content": "<p>I guess that the general result that the exponent is the lcm of <code>1,2,..., n</code> is doable.</p>",
        "id": 403169291,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1700486784
    },
    {
        "content": "<p>You can locally change the recursion depth</p>",
        "id": 403169294,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700486785
    },
    {
        "content": "<p>Yeah, that works up to four, but not for 5</p>",
        "id": 403169509,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1700486863
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/monoid.lcm_order_eq_exponent\">docs3#monoid.lcm_order_eq_exponent</a> should be a good start for the general result no?</p>",
        "id": 403169925,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1700486997
    },
    {
        "content": "<p>Do we have the fact that any permutation can be written as the product of disjoint cycles? This is the main point.</p>",
        "id": 403170671,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1700487223
    },
    {
        "content": "<p>In any case the specific case of <code>S_5</code> should really be easy: <code>60</code> divides the exponent because of Eric's theorem and the existence of elements of order <code>3</code>,<code>4</code> and <code>5</code>. Then, the exponent divides the order of the group (this is probably there, or it should be added), so there are only two possibilities. If <code>60</code> doesn't work then there is an element of order <code>120</code>.</p>",
        "id": 403172107,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1700487694
    },
    {
        "content": "<p>Can't find it, but it's easy:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">Monoid.exponent_dvd_card</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"n\">Monoid.exponent</span> <span class=\"n\">G</span> <span class=\"bp\">∣</span> <span class=\"n\">Fintype.card</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Monoid.exponent_dvd_of_forall_pow_eq_one</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">Fintype.card</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">&lt;|</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">orderOf_dvd_iff_pow_eq_one.mp</span> <span class=\"n\">orderOf_dvd_card</span>\n</code></pre></div>",
        "id": 403176593,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1700489083
    },
    {
        "content": "<p>We have a lot of stuff about permutations, the general case should really be doable.</p>",
        "id": 403176960,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1700489184
    },
    {
        "content": "<p>We have that any perm can be written as a product of disjoint cycles</p>",
        "id": 403177022,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1700489213
    },
    {
        "content": "<p>One sec</p>",
        "id": 403177032,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1700489215
    },
    {
        "content": "<p>everything is in <code>Mathlib.GroupTheory.Perm.Cycle.Type</code> and friends</p>",
        "id": 403177090,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1700489227
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Equiv.Perm.cycleFactorsFinset#doc\">docs#Equiv.Perm.cycleFactorsFinset</a></p>",
        "id": 403177407,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1700489327
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/GroupTheory/Perm/Cycle/Type.html#Equiv.Perm.lcm_cycleType\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/GroupTheory/Perm/Cycle/Type.html#Equiv.Perm.lcm_cycleType</a> is also presumably useful</p>",
        "id": 403177580,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1700489368
    },
    {
        "content": "<p>Yes, all the maths is there. But I don't see a simple way of defining a cycle.</p>",
        "id": 403180268,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1700490123
    },
    {
        "content": "<p>I mean, explictely.</p>",
        "id": 403180309,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1700490127
    },
    {
        "content": "<p>Ah, we have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fin.cycleRange#doc\">docs#Fin.cycleRange</a></p>",
        "id": 403183640,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1700491091
    },
    {
        "content": "<p>There's also the <code>c[(1 : Fin 4), 3, 2]</code> notation</p>",
        "id": 403185873,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1700491777
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/GroupTheory/Perm/Cycle/Concrete.html#Equiv.Perm.%C2%ABtermC[_,]%C2%BB\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/GroupTheory/Perm/Cycle/Concrete.html#Equiv.Perm.%C2%ABtermC[_,]%C2%BB</a></p>",
        "id": 403186005,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1700491812
    },
    {
        "content": "<p>Yes, but it seems really annoying to work with.</p>",
        "id": 403186084,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1700491837
    },
    {
        "content": "<p>I playing with your problem, and I am stuck at proving that</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">set</span> <span class=\"n\">σ</span> <span class=\"o\">:=</span> <span class=\"n\">Fin.cycleRange</span> <span class=\"o\">(</span><span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">5</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"n\">σdef</span>\n<span class=\"k\">have</span> <span class=\"n\">σsupp</span> <span class=\"o\">:</span> <span class=\"n\">Equiv.Perm.support</span> <span class=\"n\">σ</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n</code></pre></div>",
        "id": 403186209,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1700491871
    },
    {
        "content": "<p>in principle it is easy, but I am looking for a short proof</p>",
        "id": 403186295,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1700491896
    },
    {
        "content": "<p>Ah, <code>Fin 5</code> starts at <code>0</code> <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 403187784,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1700492320
    },
    {
        "content": "<p>Riccardo, can you share more about what's frustrating in the <code>c[...]</code> notation?</p>",
        "id": 403192677,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1700493739
    },
    {
        "content": "<p>Well, I forgot that <code>Fin 5</code> starts at <code>0</code>, so maybe that was the reason why <code>simp</code>/<code>exact?</code> and stuff like that didn't work. Anyway I wanted to prove that order of <code>c[0,1,2]</code> is <code>3</code>.</p>",
        "id": 403194518,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1700494263
    },
    {
        "content": "<p>And this is easy for <code>Fin.cycleRange (2 : Fin 5)</code></p>",
        "id": 403194610,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1700494291
    },
    {
        "content": "<p>Here's an example of proving on something concrete:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.Perm.Cycle.Concrete</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Equiv.Perm</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Equiv.Perm.cycleType</span> <span class=\"n\">c</span><span class=\"o\">[(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">5</span><span class=\"o\">),</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"mi\">3</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Equiv.Perm.cycleType</span><span class=\"o\">,</span>\n      <span class=\"n\">cycleFactorsFinset_eq_singleton_self_iff.mpr</span> <span class=\"o\">(</span><span class=\"n\">Cycle.isCycle_formPerm</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)]</span>\n  <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Finset.singleton_val</span><span class=\"o\">,</span> <span class=\"n\">Multiset.map_singleton</span><span class=\"o\">,</span> <span class=\"n\">Function.comp_apply</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Cycle.support_formPerm</span><span class=\"o\">]</span>\n  <span class=\"n\">all_goals</span> <span class=\"n\">decide</span>\n</code></pre></div>",
        "id": 403199895,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1700496049
    },
    {
        "content": "<p>I think <code>apply?</code> times out because of too many Equiv.Perm lemmas (?)</p>",
        "id": 403200531,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1700496217
    },
    {
        "content": "<p>I've done half of <span class=\"user-mention\" data-user-id=\"307953\">@Ruben Van de Velde</span> 's exercice</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.Exponent</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.FieldTheory.Finite.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.Perm.Cycle.Concrete</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Monoid.ExponentExists.ofFintype</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Monoid.ExponentExists</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Monoid.ExponentExists</span><span class=\"o\">]</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">Fintype.card</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">Fintype.card_pos</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">g</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">orderOf_dvd_iff_pow_eq_one</span><span class=\"o\">]</span>\n  <span class=\"n\">exact</span> <span class=\"n\">orderOf_dvd_card</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Monoid.exponent</span> <span class=\"o\">(</span><span class=\"n\">Equiv.Perm</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">5</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"mi\">60</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">set</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"n\">Monoid.exponent</span> <span class=\"o\">(</span><span class=\"n\">Equiv.Perm</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">5</span><span class=\"o\">))</span> <span class=\"k\">with</span> <span class=\"n\">he</span>\n  <span class=\"n\">apply</span> <span class=\"n\">dvd_antisymm</span>\n  <span class=\"bp\">·</span> <span class=\"gr\">sorry</span>\n  <span class=\"bp\">·</span> <span class=\"k\">suffices</span> <span class=\"o\">(((</span><span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">∣</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(((</span><span class=\"mi\">4</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">∣</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(((</span><span class=\"mi\">5</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">∣</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"kd\">by</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Int.coe_nat_dvd</span><span class=\"o\">,</span> <span class=\"k\">show</span> <span class=\"o\">((</span><span class=\"mi\">60</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">((</span><span class=\"mi\">12</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">((</span><span class=\"mi\">5</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"kd\">by</span> <span class=\"n\">norm_num</span><span class=\"o\">]</span>\n      <span class=\"n\">apply</span> <span class=\"n\">IsCoprime.mul_dvd</span>\n      <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.isCoprime_iff_coprime</span><span class=\"o\">]</span>\n        <span class=\"n\">norm_num</span>\n      <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"k\">show</span> <span class=\"o\">((</span><span class=\"mi\">12</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">((</span><span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">((</span><span class=\"mi\">4</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"kd\">by</span> <span class=\"n\">norm_num</span><span class=\"o\">]</span>\n        <span class=\"n\">apply</span> <span class=\"n\">IsCoprime.mul_dvd</span>\n        <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.isCoprime_iff_coprime</span><span class=\"o\">]</span>\n          <span class=\"n\">norm_num</span>\n        <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">this.1</span>\n        <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">this.2.1</span>\n      <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">this.2.2</span>\n    <span class=\"n\">constructor</span>\n    <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">he</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">Monoid.lcm_order_eq_exponent</span><span class=\"o\">]</span>\n      <span class=\"k\">let</span> <span class=\"n\">σ</span> <span class=\"o\">:=</span> <span class=\"n\">Fin.cycleRange</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">5</span><span class=\"o\">)</span>\n      <span class=\"k\">have</span> <span class=\"n\">σsupp</span> <span class=\"o\">:</span> <span class=\"n\">Equiv.Perm.support</span> <span class=\"n\">σ</span> <span class=\"bp\">=</span> <span class=\"n\">Finset.filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"mi\">2</span><span class=\"o\">)</span>\n          <span class=\"o\">(</span><span class=\"n\">Finset.univ</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">5</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n        <span class=\"n\">ext</span> <span class=\"n\">x</span>\n        <span class=\"n\">constructor</span>\n        <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">hx</span>\n          <span class=\"n\">by_cases</span> <span class=\"n\">Hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"mi\">2</span>\n          <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">hx</span>\n          <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Equiv.Perm.mem_support</span><span class=\"o\">,</span> <span class=\"n\">ne_eq</span><span class=\"o\">,</span> <span class=\"n\">Fin.cycleRange_of_gt</span> <span class=\"o\">(</span><span class=\"n\">not_le.1</span> <span class=\"n\">Hx</span><span class=\"o\">)]</span> <span class=\"n\">at</span> <span class=\"n\">hx</span>\n        <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">hx</span>\n          <span class=\"n\">by_cases</span> <span class=\"n\">Hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"mi\">2</span>\n          <span class=\"bp\">·</span> <span class=\"n\">by_cases</span> <span class=\"n\">Hx'</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span>\n            <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Hx'</span><span class=\"o\">]</span>\n              <span class=\"n\">decide</span>\n            <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Fin.cycleRange_of_le</span> <span class=\"n\">Hx</span><span class=\"o\">,</span> <span class=\"n\">Hx'</span><span class=\"o\">]</span>\n          <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Hx</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hx</span>\n      <span class=\"k\">have</span> <span class=\"n\">σcycl</span> <span class=\"o\">:</span> <span class=\"n\">Equiv.Perm.IsCycle</span> <span class=\"n\">σ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n        <span class=\"n\">apply</span> <span class=\"n\">Fin.isCycle_cycleRange</span>\n        <span class=\"n\">intro</span> <span class=\"n\">h</span>\n        <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">5</span><span class=\"o\">)</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span>\n        <span class=\"n\">exact</span> <span class=\"n\">this</span> <span class=\"n\">h</span>\n      <span class=\"k\">have</span> <span class=\"n\">hσ</span> <span class=\"o\">:</span> <span class=\"n\">orderOf</span> <span class=\"n\">σ</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Equiv.Perm.IsCycle.orderOf</span> <span class=\"n\">σcycl</span><span class=\"o\">,</span> <span class=\"n\">σsupp</span><span class=\"o\">]</span>\n        <span class=\"n\">decide</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Int.coe_nat_dvd</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">hσ</span><span class=\"o\">]</span>\n      <span class=\"n\">exact</span> <span class=\"n\">Finset.dvd_lcm</span> <span class=\"o\">(</span><span class=\"n\">Finset.mem_univ</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n    <span class=\"n\">constructor</span>\n    <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">he</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">Monoid.lcm_order_eq_exponent</span><span class=\"o\">]</span>\n      <span class=\"k\">let</span> <span class=\"n\">σ</span> <span class=\"o\">:=</span> <span class=\"n\">Fin.cycleRange</span> <span class=\"o\">(</span><span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">5</span><span class=\"o\">)</span>\n      <span class=\"k\">have</span> <span class=\"n\">σsupp</span> <span class=\"o\">:</span> <span class=\"n\">Equiv.Perm.support</span> <span class=\"n\">σ</span> <span class=\"bp\">=</span> <span class=\"n\">Finset.filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"mi\">3</span><span class=\"o\">)</span>\n          <span class=\"o\">(</span><span class=\"n\">Finset.univ</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">5</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n        <span class=\"n\">ext</span> <span class=\"n\">x</span>\n        <span class=\"n\">constructor</span>\n        <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">hx</span>\n          <span class=\"n\">by_cases</span> <span class=\"n\">Hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"mi\">3</span>\n          <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">hx</span>\n          <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Equiv.Perm.mem_support</span><span class=\"o\">,</span> <span class=\"n\">ne_eq</span><span class=\"o\">,</span> <span class=\"n\">Fin.cycleRange_of_gt</span> <span class=\"o\">(</span><span class=\"n\">not_le.1</span> <span class=\"n\">Hx</span><span class=\"o\">)]</span> <span class=\"n\">at</span> <span class=\"n\">hx</span>\n        <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">hx</span>\n          <span class=\"n\">by_cases</span> <span class=\"n\">Hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"mi\">3</span>\n          <span class=\"bp\">·</span> <span class=\"n\">by_cases</span> <span class=\"n\">Hx'</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span>\n            <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Hx'</span><span class=\"o\">]</span>\n              <span class=\"n\">decide</span>\n            <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Fin.cycleRange_of_le</span> <span class=\"n\">Hx</span><span class=\"o\">,</span> <span class=\"n\">Hx'</span><span class=\"o\">]</span>\n          <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Hx</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hx</span>\n      <span class=\"k\">have</span> <span class=\"n\">σcycl</span> <span class=\"o\">:</span> <span class=\"n\">Equiv.Perm.IsCycle</span> <span class=\"n\">σ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n        <span class=\"n\">apply</span> <span class=\"n\">Fin.isCycle_cycleRange</span>\n        <span class=\"n\">intro</span> <span class=\"n\">h</span>\n        <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">5</span><span class=\"o\">)</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span>\n        <span class=\"n\">exact</span> <span class=\"n\">this</span> <span class=\"n\">h</span>\n      <span class=\"k\">have</span> <span class=\"n\">hσ</span> <span class=\"o\">:</span> <span class=\"n\">orderOf</span> <span class=\"n\">σ</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Equiv.Perm.IsCycle.orderOf</span> <span class=\"n\">σcycl</span><span class=\"o\">,</span> <span class=\"n\">σsupp</span><span class=\"o\">]</span>\n        <span class=\"n\">decide</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Int.coe_nat_dvd</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">hσ</span><span class=\"o\">]</span>\n      <span class=\"n\">exact</span> <span class=\"n\">Finset.dvd_lcm</span> <span class=\"o\">(</span><span class=\"n\">Finset.mem_univ</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n    <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">he</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">Monoid.lcm_order_eq_exponent</span><span class=\"o\">]</span>\n      <span class=\"k\">let</span> <span class=\"n\">σ</span> <span class=\"o\">:=</span> <span class=\"n\">Fin.cycleRange</span> <span class=\"o\">(</span><span class=\"n\">Fin.last</span> <span class=\"mi\">4</span><span class=\"o\">)</span>\n      <span class=\"k\">have</span> <span class=\"n\">σsupp</span> <span class=\"o\">:</span> <span class=\"n\">Equiv.Perm.support</span> <span class=\"n\">σ</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">Finset.univ</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">5</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n      <span class=\"k\">have</span> <span class=\"n\">σcycl</span> <span class=\"o\">:</span> <span class=\"n\">Equiv.Perm.IsCycle</span> <span class=\"n\">σ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n        <span class=\"n\">apply</span> <span class=\"n\">Fin.isCycle_cycleRange</span>\n        <span class=\"n\">intro</span> <span class=\"n\">h</span>\n        <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">4</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">5</span><span class=\"o\">)</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span>\n        <span class=\"n\">exact</span> <span class=\"n\">this</span> <span class=\"n\">h</span>\n      <span class=\"k\">have</span> <span class=\"n\">hσ</span> <span class=\"o\">:</span> <span class=\"n\">orderOf</span> <span class=\"n\">σ</span> <span class=\"bp\">=</span> <span class=\"mi\">5</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Equiv.Perm.IsCycle.orderOf</span> <span class=\"n\">σcycl</span><span class=\"o\">,</span> <span class=\"n\">σsupp</span><span class=\"o\">]</span>\n        <span class=\"n\">decide</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Int.coe_nat_dvd</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">hσ</span><span class=\"o\">]</span>\n      <span class=\"n\">convert</span> <span class=\"n\">Finset.dvd_lcm</span> <span class=\"o\">(</span><span class=\"n\">Finset.mem_univ</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n      <span class=\"n\">infer_instance</span>\n <span class=\"bp\">```</span>\n</code></pre></div>",
        "id": 403201766,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1700496624
    },
    {
        "content": "<p>Extracting the fact that <code>Equiv.Perm.support (Fin.cycleRange ...)</code> is what it is supposed to be (and hence the order is done) would shorten the proof a lot.</p>",
        "id": 403201962,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1700496705
    },
    {
        "content": "<p>One example of that in a concrete context:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">[(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">5</span><span class=\"o\">),</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">])</span><span class=\"bp\">.</span><span class=\"n\">support</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span>\n</code></pre></div>",
        "id": 403202148,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1700496766
    },
    {
        "content": "<p>agreed that for the more abstract constructor, a factored out lemma makes sense</p>",
        "id": 403202238,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1700496796
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proving.20the.20value.20of.20exp.20.28S_5.29/near/403202148\">said</a>:</p>\n<blockquote>\n<p>One example of that in a concrete context:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">[(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">5</span><span class=\"o\">),</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">])</span><span class=\"bp\">.</span><span class=\"n\">support</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>If <code>decide</code> works here forget about my complain. It is the first thing I tried and it didn't work because my statement was false.</p>",
        "id": 403202319,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1700496830
    },
    {
        "content": "<p>Looks a bit simpler without the casts:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Monoid.exponent</span> <span class=\"o\">(</span><span class=\"n\">Equiv.Perm</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">5</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"mi\">60</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">set</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"n\">Monoid.exponent</span> <span class=\"o\">(</span><span class=\"n\">Equiv.Perm</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">5</span><span class=\"o\">))</span> <span class=\"k\">with</span> <span class=\"n\">he</span>\n  <span class=\"n\">apply</span> <span class=\"n\">dvd_antisymm</span>\n  <span class=\"bp\">·</span> <span class=\"gr\">sorry</span>\n  <span class=\"bp\">·</span> <span class=\"k\">suffices</span> <span class=\"o\">(</span><span class=\"mi\">3</span> <span class=\"bp\">∣</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"mi\">4</span> <span class=\"bp\">∣</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"mi\">5</span> <span class=\"bp\">∣</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"kd\">by</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"k\">show</span> <span class=\"mi\">60</span> <span class=\"bp\">=</span> <span class=\"mi\">12</span> <span class=\"bp\">*</span> <span class=\"mi\">5</span> <span class=\"kd\">by</span> <span class=\"n\">norm_num</span><span class=\"o\">]</span>\n      <span class=\"n\">apply</span> <span class=\"n\">Nat.Coprime.mul_dvd_of_dvd_of_dvd</span>\n      <span class=\"bp\">·</span> <span class=\"n\">norm_num</span>\n      <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"k\">show</span> <span class=\"mi\">12</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span> <span class=\"bp\">*</span> <span class=\"mi\">4</span> <span class=\"kd\">by</span> <span class=\"n\">norm_num</span><span class=\"o\">]</span>\n        <span class=\"n\">apply</span> <span class=\"n\">Nat.Coprime.mul_dvd_of_dvd_of_dvd</span>\n        <span class=\"bp\">·</span> <span class=\"n\">norm_num</span>\n        <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">this.1</span>\n        <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">this.2.1</span>\n      <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">this.2.2</span>\n    <span class=\"n\">constructor</span>\n    <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">he</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">Monoid.lcm_order_eq_exponent</span><span class=\"o\">]</span>\n      <span class=\"k\">let</span> <span class=\"n\">σ</span> <span class=\"o\">:=</span> <span class=\"n\">Fin.cycleRange</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">5</span><span class=\"o\">)</span>\n      <span class=\"k\">have</span> <span class=\"n\">σsupp</span> <span class=\"o\">:</span> <span class=\"n\">Equiv.Perm.support</span> <span class=\"n\">σ</span> <span class=\"bp\">=</span> <span class=\"n\">Finset.filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"mi\">2</span><span class=\"o\">)</span>\n          <span class=\"o\">(</span><span class=\"n\">Finset.univ</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">5</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n        <span class=\"n\">ext</span> <span class=\"n\">x</span>\n        <span class=\"n\">constructor</span>\n        <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">hx</span>\n          <span class=\"n\">by_cases</span> <span class=\"n\">Hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"mi\">2</span>\n          <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">hx</span>\n          <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Equiv.Perm.mem_support</span><span class=\"o\">,</span> <span class=\"n\">ne_eq</span><span class=\"o\">,</span> <span class=\"n\">Fin.cycleRange_of_gt</span> <span class=\"o\">(</span><span class=\"n\">not_le.1</span> <span class=\"n\">Hx</span><span class=\"o\">)]</span> <span class=\"n\">at</span> <span class=\"n\">hx</span>\n        <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">hx</span>\n          <span class=\"n\">by_cases</span> <span class=\"n\">Hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"mi\">2</span>\n          <span class=\"bp\">·</span> <span class=\"n\">by_cases</span> <span class=\"n\">Hx'</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span>\n            <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Hx'</span><span class=\"o\">]</span>\n              <span class=\"n\">decide</span>\n            <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Fin.cycleRange_of_le</span> <span class=\"n\">Hx</span><span class=\"o\">,</span> <span class=\"n\">Hx'</span><span class=\"o\">]</span>\n          <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Hx</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hx</span>\n      <span class=\"k\">have</span> <span class=\"n\">σcycl</span> <span class=\"o\">:</span> <span class=\"n\">Equiv.Perm.IsCycle</span> <span class=\"n\">σ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n        <span class=\"n\">apply</span> <span class=\"n\">Fin.isCycle_cycleRange</span>\n        <span class=\"n\">intro</span> <span class=\"n\">h</span>\n        <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">5</span><span class=\"o\">)</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span>\n        <span class=\"n\">exact</span> <span class=\"n\">this</span> <span class=\"n\">h</span>\n      <span class=\"k\">have</span> <span class=\"n\">hσ</span> <span class=\"o\">:</span> <span class=\"n\">orderOf</span> <span class=\"n\">σ</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Equiv.Perm.IsCycle.orderOf</span> <span class=\"n\">σcycl</span><span class=\"o\">,</span> <span class=\"n\">σsupp</span><span class=\"o\">]</span>\n        <span class=\"n\">decide</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">hσ</span><span class=\"o\">]</span>\n      <span class=\"n\">exact</span> <span class=\"n\">Finset.dvd_lcm</span> <span class=\"o\">(</span><span class=\"n\">Finset.mem_univ</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n    <span class=\"n\">constructor</span>\n    <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">he</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">Monoid.lcm_order_eq_exponent</span><span class=\"o\">]</span>\n      <span class=\"k\">let</span> <span class=\"n\">σ</span> <span class=\"o\">:=</span> <span class=\"n\">Fin.cycleRange</span> <span class=\"o\">(</span><span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">5</span><span class=\"o\">)</span>\n      <span class=\"k\">have</span> <span class=\"n\">σsupp</span> <span class=\"o\">:</span> <span class=\"n\">Equiv.Perm.support</span> <span class=\"n\">σ</span> <span class=\"bp\">=</span> <span class=\"n\">Finset.filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"mi\">3</span><span class=\"o\">)</span>\n          <span class=\"o\">(</span><span class=\"n\">Finset.univ</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">5</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n        <span class=\"n\">ext</span> <span class=\"n\">x</span>\n        <span class=\"n\">constructor</span>\n        <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">hx</span>\n          <span class=\"n\">by_cases</span> <span class=\"n\">Hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"mi\">3</span>\n          <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">hx</span>\n          <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Equiv.Perm.mem_support</span><span class=\"o\">,</span> <span class=\"n\">ne_eq</span><span class=\"o\">,</span> <span class=\"n\">Fin.cycleRange_of_gt</span> <span class=\"o\">(</span><span class=\"n\">not_le.1</span> <span class=\"n\">Hx</span><span class=\"o\">)]</span> <span class=\"n\">at</span> <span class=\"n\">hx</span>\n        <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">hx</span>\n          <span class=\"n\">by_cases</span> <span class=\"n\">Hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"mi\">3</span>\n          <span class=\"bp\">·</span> <span class=\"n\">by_cases</span> <span class=\"n\">Hx'</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span>\n            <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Hx'</span><span class=\"o\">]</span>\n              <span class=\"n\">decide</span>\n            <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Fin.cycleRange_of_le</span> <span class=\"n\">Hx</span><span class=\"o\">,</span> <span class=\"n\">Hx'</span><span class=\"o\">]</span>\n          <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Hx</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hx</span>\n      <span class=\"k\">have</span> <span class=\"n\">σcycl</span> <span class=\"o\">:</span> <span class=\"n\">Equiv.Perm.IsCycle</span> <span class=\"n\">σ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n        <span class=\"n\">apply</span> <span class=\"n\">Fin.isCycle_cycleRange</span>\n        <span class=\"n\">intro</span> <span class=\"n\">h</span>\n        <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">5</span><span class=\"o\">)</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span>\n        <span class=\"n\">exact</span> <span class=\"n\">this</span> <span class=\"n\">h</span>\n      <span class=\"k\">have</span> <span class=\"n\">hσ</span> <span class=\"o\">:</span> <span class=\"n\">orderOf</span> <span class=\"n\">σ</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Equiv.Perm.IsCycle.orderOf</span> <span class=\"n\">σcycl</span><span class=\"o\">,</span> <span class=\"n\">σsupp</span><span class=\"o\">]</span>\n        <span class=\"n\">decide</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">hσ</span><span class=\"o\">]</span>\n      <span class=\"n\">exact</span> <span class=\"n\">Finset.dvd_lcm</span> <span class=\"o\">(</span><span class=\"n\">Finset.mem_univ</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n    <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">he</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">Monoid.lcm_order_eq_exponent</span><span class=\"o\">]</span>\n      <span class=\"k\">let</span> <span class=\"n\">σ</span> <span class=\"o\">:=</span> <span class=\"n\">Fin.cycleRange</span> <span class=\"o\">(</span><span class=\"n\">Fin.last</span> <span class=\"mi\">4</span><span class=\"o\">)</span>\n      <span class=\"k\">have</span> <span class=\"n\">σsupp</span> <span class=\"o\">:</span> <span class=\"n\">Equiv.Perm.support</span> <span class=\"n\">σ</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">Finset.univ</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">5</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n      <span class=\"k\">have</span> <span class=\"n\">σcycl</span> <span class=\"o\">:</span> <span class=\"n\">Equiv.Perm.IsCycle</span> <span class=\"n\">σ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n        <span class=\"n\">apply</span> <span class=\"n\">Fin.isCycle_cycleRange</span>\n        <span class=\"n\">intro</span> <span class=\"n\">h</span>\n        <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">4</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">5</span><span class=\"o\">)</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span>\n        <span class=\"n\">exact</span> <span class=\"n\">this</span> <span class=\"n\">h</span>\n      <span class=\"k\">have</span> <span class=\"n\">hσ</span> <span class=\"o\">:</span> <span class=\"n\">orderOf</span> <span class=\"n\">σ</span> <span class=\"bp\">=</span> <span class=\"mi\">5</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Equiv.Perm.IsCycle.orderOf</span> <span class=\"n\">σcycl</span><span class=\"o\">,</span> <span class=\"n\">σsupp</span><span class=\"o\">]</span>\n        <span class=\"n\">decide</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">hσ</span><span class=\"o\">]</span>\n      <span class=\"n\">convert</span> <span class=\"n\">Finset.dvd_lcm</span> <span class=\"o\">(</span><span class=\"n\">Finset.mem_univ</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n      <span class=\"n\">infer_instance</span>\n</code></pre></div>\n<p>(though we should rename <code>Nat.Coprime.mul_dvd_of_dvd_of_dvd</code> to match <code>IsCoprime.mul.dvd</code>)</p>",
        "id": 403208498,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1700499047
    },
    {
        "content": "<p>I didn't try to keep it short :D Anyway this essentially proves that <code>lcm 1, 2,..., n</code> divides the exponent, and we should add this general result</p>",
        "id": 403208981,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1700499213
    }
]