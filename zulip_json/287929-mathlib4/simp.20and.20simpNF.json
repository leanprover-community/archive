[
    {
        "content": "<p>I have a question about simp normal forms and the mathlib simp set. I will just focus on an example, while trying to understand this.</p>\n<p>We have decided that <code>f (x + y) = f x + f y</code> should be a simp lemma, instead of <code>f x + f y = f (x + y)</code>. Intuitively, I am still very happy with this choice. But from a (CS) theoretical perspective this is not clear at all. Because we are introducing an extra copy of <code>f</code>, instead of removing one.<br>\nSo I think the reason we like our definition is because in practice we hope that <code>x</code> or <code>y</code> will be in the kernel of <code>f</code> and so we can simplify even further. And in practice it is just much more likely that <code>x</code> or <code>y</code> will be in the kernel than that some complicated expression like <code>x + y</code> is in the kernel.<br>\nBut that's a very vague and imprecise argument.</p>\n<p>So my question is: after 5 years of mathlib, and 5 decades of ITP more generally, do we have a good understanding of why <code>f (x + y) = f x + f y</code> is the \"correct\" simp direction?</p>",
        "id": 474615965,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1727968130
    },
    {
        "content": "<p>My internal reasoning is that it is likelier that you have a result about <code>f</code> applied to something \"atomic\", than to a sum of stuff.  The kernel is an example, but you might also have other values of <code>a</code> that <code>simp</code> can simplify.  <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 474616400,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1727968247
    },
    {
        "content": "<p>Another case like \"in the kernel\" is \"is a constructor\"; often <code>f (mk x) = g x</code>, where <code>g</code> is simpler, and you want to get there from <code>f (mk x + y + 0)</code></p>",
        "id": 474616410,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727968251
    },
    {
        "content": "<p>Yup, that's a nice one.<br>\nI wonder if we can somehow come up with an abstract principle.</p>",
        "id": 474617134,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1727968462
    },
    {
        "content": "<p>Perhaps a more naive reason is that the usual direction is sure to fire while for simplifying <code>f x + 0 + f y</code> one needs to shuffle things around, so proving an equality with <code>simp</code> is more likely to work the way it is?</p>",
        "id": 474617567,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1727968587
    },
    {
        "content": "<p>A similar argument: some types of induction turn <code>P z</code> into <code>P x -&gt; P y -&gt; P (x + y)</code>, and for those it's helpful if <code>simp</code> can separate the <code>x</code> and <code>y</code> in the goal</p>",
        "id": 474617831,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727968662
    },
    {
        "content": "<p>Johan, here is one fascinating counterexample. The continuous functional calculus for an element <code>a : A</code> in a C⋆-algebra is a monomorphism <code>cfc : C(spectrum ℂ a, ℂ) →⋆ₐ[ℂ] A</code>. And it satisfies a composition property <code>cfc (f ∘ g) = cfc f (cfc g)</code> (please ignore that this is not well-typed). In practice, I have found that, when working with <code>cfc</code>, we almost always rewrite with the usual lemmas (e.g., <code>map_mul</code>, <code>map_add</code>, etc.) <em>backwards</em>. The reason is essentially this: to show two expressions involving the <code>cfc</code> are equal, pull <code>cfc</code> all the way out (i.e., from the leaves of the expression to the head) of both, then argue that the functions are equal.</p>\n<p>Because of the way we implemented <code>cfc</code>, we don't technically use <code>map_mul</code> and friends, we have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=cfc_mul#doc\">docs#cfc_mul</a>, but I wrote <code>cfc_mul</code> in the same direction and only later realized that somehow it is the \"wrong\" direction.</p>",
        "id": 474618877,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1727968977
    },
    {
        "content": "<p>Interesting! Thanks for sharing</p>",
        "id": 474639044,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1727974407
    },
    {
        "content": "<p>If <code>f</code> is a cast between numeric types then humans want to freely go in both directions in proofs and this is why we have <code>norm_cast</code> and <code>push_cast</code>. So it's not clear that there can be an argument which unambiguously concludes that one way is more helpful than the other.</p>",
        "id": 474899782,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1728075391
    },
    {
        "content": "<p>In SciLean I have simp sets <code>add_push</code>, <code>add_pull</code>, <code>smul_push</code>, <code>smul_pull</code>, ... and command that takes a proof of <code>IsLinearMap k f</code> and generates all the relevant theorems for a concrete <code>f</code>.</p>\n<p>Lots of my proofs end with <code>simp [smul_push, add_push]</code>.</p>",
        "id": 474955894,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1728112929
    },
    {
        "content": "<p>My intuition is that <code>f</code> can be a very complicated function, and it can be very unclear what it does when applied to some large term. Splitting it up allows you to think about its behavior on each specific portion of the term.</p>",
        "id": 475416012,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1728341882
    }
]