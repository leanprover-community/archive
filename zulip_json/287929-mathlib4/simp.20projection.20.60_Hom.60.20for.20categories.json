[
    {
        "content": "<p>When defining a category (or a <code>Quiver</code>), often the <code>Hom</code> field is already defined as some other type <code>Foo.Hom X Y</code>. Tagging the definition of the category with <code>@[simps]</code> then adds a simp lemma of type:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"bp\">.</span><span class=\"n\">Hom</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span>\n</code></pre></div>\n<p>I think I don't quite understand how the fields of structures work, will <code>Quiver.Hom X Y</code> (i.e. <code>X ⟶ Y</code>) not be an abbrev for <code>Foo.Hom X Y</code> anyways? So is it a good idea to be adding this simp lemma (and does it matter)?</p>\n<p>What makes me confused is that it seems to me that if simp sees this type, and simplifies it to <code>Foo.Hom X Y</code>, then we are forgetting that the morphisms are actually a part of a category, so simp can no longer use various category-theory lemmas. It seems better that one should apply some sort of <code>ext</code> lemma to reduce to working with <code>Foo.Hom X Y</code> (or rather its projections) when one needs to use the actual underlying implementation of <code>Foo.Hom</code>.</p>\n<p>Another small annoyance with <code>@[simps]</code> for categories that is slightly related, is that the simp lemmas that get added (e.g. <code>comp_hom</code> lets say, if <code>Foo.Hom</code> has a projection <code>hom</code>) will have the form</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"bp\">.</span><span class=\"n\">Hom</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"bp\">.</span><span class=\"n\">Hom</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"bp\">.</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">hom</span>\n</code></pre></div>\n<p>but it would be more visually appealing if <code>(f : Foo.Hom X Y)</code> was <code>(f : X ⟶ Y)</code>.</p>",
        "id": 558799333,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1763802101
    },
    {
        "content": "<p>Usually, when morphisms are a structure <code>Hom</code>, we add a lemma <code>hom_ext</code> which is definitionally the same as <code>Hom.ext</code> but it takes inputs in <code>X ⟶ Y</code> instead of <code>Hom X Y</code>. Similarly, we have to restate <code>id_hom</code> and <code>comp_hom</code>.</p>",
        "id": 558800808,
        "sender_full_name": "Joël Riou",
        "timestamp": 1763803601
    },
    {
        "content": "<p>Do we have to restate <code>id_hom</code> and <code>comp_hom</code>? In some testing I did locally where <code>Hom</code> was a 1-field structure, the simp lemmas with <code>Foo.Hom X Y</code> as parameters still seems to apply when the morphisms had type <code>X ⟶ Y</code> (also without adding the <code>_Hom</code> simp lemma).</p>",
        "id": 558800961,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1763803742
    },
    {
        "content": "<p>So the restated versions were already provable by simp</p>",
        "id": 558800977,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1763803763
    },
    {
        "content": "<p>And having to restate them would be very annoying for bicategories, where if <code>Hom</code> and the 2-<code>Hom</code>s are structures, then you suddenly have to restate 12 lemmas or even more sometimes.</p>",
        "id": 558801410,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1763804134
    },
    {
        "content": "<p>Ah, if you do <code>@[simps id comp]</code>, it may work.</p>",
        "id": 558801670,
        "sender_full_name": "Joël Riou",
        "timestamp": 1763804361
    },
    {
        "content": "<p>In my tests it seems to work in both cases</p>",
        "id": 558802423,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1763804999
    },
    {
        "content": "<p>I think maybe my question was not very well stated, it is basically this:<br>\nShould the <code>_Hom</code> lemma generated by <code>@[simps]</code> be excluded most of the time (at least when <code>Hom</code> is a structure), in favor of a manually added <code>ext</code> lemma?</p>",
        "id": 558806125,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1763808898
    },
    {
        "content": "<p>In general, I do not think we should generate <code>_Hom</code> lemmas.</p>",
        "id": 558806175,
        "sender_full_name": "Joël Riou",
        "timestamp": 1763808966
    },
    {
        "content": "<p>Thanks! I wonder if it is a good idea to remove this simps projection somehow, whilst still allowing <code>simps</code> to still access the projections of <code>Hom</code>. So that one would not have to manually exclude <code>_Hom</code> everywhere, which is especially painful for bicategories where one has to list the other ~12 simp lemmas that should be included. I don't know if this is possible already, maybe some metaprogramming needs to be done for this.</p>",
        "id": 558806353,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1763809132
    },
    {
        "content": "<p>Yes, we could add a <code>initialize_simps_projections</code>.</p>",
        "id": 558807099,
        "sender_full_name": "Joël Riou",
        "timestamp": 1763809804
    },
    {
        "content": "<p>To remove the <code>_Hom</code> you mean? I'm worried that this will make the projections of <code>Hom</code> that we care about invisible to <code>simps</code>.</p>",
        "id": 558808448,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1763811279
    },
    {
        "content": "<p>I do not think there are many projection of <code>Hom</code> we need. It can be activated if we care. I only suggest changing the default behaviour.</p>",
        "id": 558809079,
        "sender_full_name": "Joël Riou",
        "timestamp": 1763811924
    },
    {
        "content": "<p>Thanks for the help, then I will try removing it in a branch to see what happens.</p>",
        "id": 558809233,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1763812124
    }
]