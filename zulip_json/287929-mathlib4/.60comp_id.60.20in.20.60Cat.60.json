[
    {
        "content": "<p>I've noticed the following \"issue\" when adding some API for <code>Cat</code>, see <a href=\"https://github.com/leanprover-community/mathlib4/blob/f79b385789c6b8bb0447bdd87676d7c9d996152c/Mathlib/CategoryTheory/Category/Cat.lean\">file</a>. For example the lemma <code>whiskerRight_left</code> is reduced by simp to something that follows from <code>Category.comp_id</code>, but simp is unable to close this final goal. So the following is a proof of the lemma (note that rfl also works, but thats beside my point here):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">whiskerRight_left</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Cat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">‚óÅ</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚ñ∑</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">‚óÅ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚ñ∑</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">erw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category.comp_id</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>The final <code>erw</code> can not be replaced by <code>rw</code>. I would want this to be solvable by <code>simp</code> already. Is this an issue, or am I asking for too much since this is equalities of functors, which is bad?</p>",
        "id": 444645832,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1718352963
    },
    {
        "content": "<p>Can you make a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> ? I don't know how to get the triangles working.</p>",
        "id": 444686997,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1718367147
    },
    {
        "content": "<p>I'd be curious to hear what you're working on! I was trying to apply this theorem recently to prove that a certain pasting composite of natural transformations equals another pasting composite but got blocked because I needed to rewrite along an equality of functors. </p>\n<p>(Btw, what is \"erw\"? That's a tactic I don't know.)</p>\n<p>In case you're curious, the thing I was trying to prove were the left inverse and right inverse fields of <code>Mates</code> in this draft pull request (without appealing to <code>ext</code>):</p>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/13840\">https://github.com/leanprover-community/mathlib4/pull/13840</a></p>\n<p>That definition doesn't depend on anything else in this file, if you want to take it out and play around with it.</p>",
        "id": 444773173,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1718393209
    },
    {
        "content": "<p><code>erw</code> is ‚Äúexpensive‚Äù <code>rw</code> it tries to unfold definitions more than <code>rw</code>. Generally you see it when either something has been unfolded that should not have been or people are trying abuse defeq transparency settings</p>",
        "id": 444774075,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1718393491
    },
    {
        "content": "<p>Check what <code>simp</code> is applying here and what the full goal state is before the <code>erw</code> Generally this is a code smell</p>",
        "id": 444774364,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1718393578
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246635\">Emily Riehl</span> <a href=\"#narrow/stream/287929-mathlib4/topic/.60comp_id.60.20in.20.60Cat.60/near/444773173\">said</a>:</p>\n<blockquote>\n<p>In case you're curious, the thing I was trying to prove were the left inverse and right inverse fields of <code>Mates</code> in this draft pull request (without appealing to <code>ext</code>):</p>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/13840\">https://github.com/leanprover-community/mathlib4/pull/13840</a></p>\n</blockquote>\n<p>In the context of bicategories, these compatibilities are the <code>sorry</code> in this draft PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/13539\">#13539</a><br>\n<a href=\"https://github.com/leanprover-community/mathlib4/pull/13539/files#diff-8ea08c49c175b8da759053d08c832a3eff7c7d378fb78322b43c06c73b261a26R80-R85\">https://github.com/leanprover-community/mathlib4/pull/13539/files#diff-8ea08c49c175b8da759053d08c832a3eff7c7d378fb78322b43c06c73b261a26R80-R85</a> and there we cannot use <code>ext</code>!</p>",
        "id": 444779073,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1718395366
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/.60comp_id.60.20in.20.60Cat.60/near/444686997\">said</a>:</p>\n<blockquote>\n<p>Can you make a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> ? I don't know how to get the triangles working.</p>\n</blockquote>\n<p>Yes, sorry about that! Here is one:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.CategoryTheory.Category.Cat</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"w\"> </span><span class=\"n\">Bicategory</span>\n\n<span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">whiskerRight_left</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Cat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">‚óÅ</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚ñ∑</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">‚óÅ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚ñ∑</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">erw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category.comp_id</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 444848610,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1718445777
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246635\">Emily Riehl</span> <a href=\"#narrow/stream/287929-mathlib4/topic/.60comp_id.60.20in.20.60Cat.60/near/444773173\">said</a>:</p>\n<blockquote>\n<p>I'd be curious to hear what you're working on! I was trying to apply this theorem recently to prove that a certain pasting composite of natural transformations equals another pasting composite but got blocked because I needed to rewrite along an equality of functors. </p>\n<p>(Btw, what is \"erw\"? That's a tactic I don't know.)</p>\n<p>In case you're curious, the thing I was trying to prove were the left inverse and right inverse fields of <code>Mates</code> in this draft pull request (without appealing to <code>ext</code>):</p>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/13840\">https://github.com/leanprover-community/mathlib4/pull/13840</a></p>\n<p>That definition doesn't depend on anything else in this file, if you want to take it out and play around with it.</p>\n</blockquote>\n<p>I'm working on formalizing fibered categories right now, and this came up when trying to define the fibered category associated to a pseudofunctor. I don't know much about bicategories though, I'm basically learning this stuff as I'm formalizing :)</p>\n<p>I didn't know anything about <code>Mates</code> before, this looks like a very useful result! I had a look at the other thread about it now, but how come you want to avoid <code>ext</code>? Just because the proof would be cleaner without it?</p>",
        "id": 444850993,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1718446968
    },
    {
        "content": "<p>It is certainly reasonable to avoid <code>ext</code> in a human proof. We should try to get the <code>by ext; simp</code> strategy to work as well as possible, but only the automation has to follow this route.</p>",
        "id": 444851399,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1718447316
    },
    {
        "content": "<p>The rewrite seems to fail for the following reason (and you don't need <code>pp.all</code> to see it fortunately, because the terms are huge!). After <code>simp</code> the goal is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">‚ä¢</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">‚óÅ</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚ñ∑</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"mi\">ùüô</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">‚óÅ</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚ñ∑</span><span class=\"w\"> </span><span class=\"n\">K</span>\n</code></pre></div>\n<p>which looks pretty innocuous enough, but if you hover over <code>F ‚óÅ Œ± ‚ñ∑ K</code> you'll see that it has type <code>F ‚â´ G ‚â´ K ‚ü∂ F ‚â´ H ‚â´ K</code>, so in fact the goal is in some sense not well-typed, because <code> F ‚â´ H ‚â´ K = F ‚â´ (H ‚â´ K)</code>, whereas the identity wants <code> (F ‚â´ H) ‚â´ K</code>. I'm not entirely sure how to fix this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">whiskerRight_left</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Cat</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">‚óÅ</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚ñ∑</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">‚óÅ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚ñ∑</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"n\">assoc</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- motive is not type correct :-/</span>\n</code></pre></div>\n<p>and <code>simp_rw</code> etc don't work either. </p>\n<p>Hmm, in fact I think the reason we're in this mess might be that the statement of the lemma itself is abusing defeq. The type of the LHS <code>(F ‚óÅ Œ±) ‚ñ∑ K</code> is <code>(F ‚â´ G) ‚â´ K ‚ü∂ (F ‚â´ H) ‚â´ K</code> and the type of the RHS is <code>F ‚â´ G ‚â´ K ‚ü∂ F ‚â´ H ‚â´ K</code>. So maybe the lemma is bad?</p>",
        "id": 444852547,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1718448370
    },
    {
        "content": "<p>Thanks for catching this! The point of adding this lemma was just to get bicategory notation working with the lemmas in <code>Whiskering.lean</code>. So this lemma already exists in mathlib as <code>CategoryTheory.whiskerRight_left</code>, but without the triangles as notation. Although now that I look it up I see that this lemma is actually used 0 times elsewhere in mathlib, so maybe it's not so good?</p>",
        "id": 444852997,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1718448698
    },
    {
        "content": "<p>So probably this lemma should be stated in terms of the associator, and I should add a dsimp lemma (somehow) saying that the associator is just eqToIso (now with correct domains and codomains!). Then I should be able to get more useful versions of these lemmas!</p>",
        "id": 444853133,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1718448805
    },
    {
        "content": "<p>Yeah hopefully! Thanks, I found this exercise pretty instructive. I would like to understand better when <code>rw</code> fails and <code>erw</code> works.</p>",
        "id": 444855480,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1718450991
    },
    {
        "content": "<p>What happens if you try to splice in the associator?</p>",
        "id": 444865691,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1718459908
    },
    {
        "content": "<p>I would hope that the bicategory simp lemmas will take care of the associator directly without a simp lemma saying that it‚Äôs <code>eqToIso</code></p>",
        "id": 444865752,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1718459965
    },
    {
        "content": "<p>Indeed it works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"w\"> </span><span class=\"n\">Bicategory</span>\n\n<span class=\"kd\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ùíû</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Bicategory</span><span class=\"w\"> </span><span class=\"n\">ùíû</span><span class=\"o\">]</span>\n<span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">whiskerRight_left</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ùíû</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">Œ±_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">‚óÅ</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚ñ∑</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">‚óÅ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚ñ∑</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 444866294,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1718460251
    },
    {
        "content": "<p>But if you use <code>Cat</code>, there is a lemma that throws it off track, but this works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"w\"> </span><span class=\"n\">Bicategory</span>\n\n<span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">whiskerRight_left</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Cat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">Œ±_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">‚óÅ</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚ñ∑</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">‚óÅ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚ñ∑</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">Strict.associator_eqToIso</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 444866404,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1718460329
    },
    {
        "content": "<p>To be honest, I think <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Bicategory.Strict.associator_eqToIso#doc\">docs#CategoryTheory.Bicategory.Strict.associator_eqToIso</a> should <em>not</em> be a simp lemma.</p>",
        "id": 444874080,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1718465608
    },
    {
        "content": "<p>(same goes for the <code>(left/right)Unitor</code> lemmas)</p>",
        "id": 444874205,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1718465660
    },
    {
        "content": "<p>On a related point does this lemma exist anywhere:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Naturality of Œ≤ implies naturality of whiskering.</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">WhiskeringNaturality</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)(</span><span class=\"n\">Œ≤</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">whiskerRight</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">whiskerLeft</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">whiskerLeft</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">whiskerRight</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span>\n<span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">ext</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">whiskerLeft</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 444977085,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1718545047
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246635\">Emily Riehl</span> <a href=\"#narrow/stream/287929-mathlib4/topic/.60comp_id.60.20in.20.60Cat.60/near/444977085\">said</a>:</p>\n<blockquote>\n<p>On a related point does this lemma exist anywhere:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Naturality of Œ≤ implies naturality of whiskering.</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">WhiskeringNaturality</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)(</span><span class=\"n\">Œ≤</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">whiskerRight</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">whiskerLeft</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">whiskerLeft</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">whiskerRight</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span>\n<span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">ext</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">whiskerLeft</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Is this <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Bicategory.whisker_exchange#doc\">docs#CategoryTheory.Bicategory.whisker_exchange</a> ?</p>",
        "id": 444977446,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1718545352
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/287929-mathlib4/topic/.60comp_id.60.20in.20.60Cat.60/near/444874080\">said</a>:</p>\n<blockquote>\n<p>To be honest, I think <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Bicategory.Strict.associator_eqToIso#doc\">docs#CategoryTheory.Bicategory.Strict.associator_eqToIso</a> should <em>not</em> be a simp lemma.</p>\n</blockquote>\n<p>This is a bit of an old thread, but I just found it and would like to comment that I also agree with this. I've created a PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/16251\">#16251</a>.</p>",
        "id": 465995920,
        "sender_full_name": "Yuma Mizuno",
        "timestamp": 1724933389
    },
    {
        "content": "<p>I agree with this also, but just a thought. Could it be sensible to add some API to strict bicategories which shows that associators etc \"behave like eqToHom\" without rewriting them to eqToHoms?</p>",
        "id": 466002925,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1724934919
    },
    {
        "content": "<p>I have not thought about it too much, so maybe its not possible to formulate lemmas like that. But it would be ideal if those lemmas would allow us to avoid re-adding these simp lemmas in <code>LocallyDiscrete</code>.</p>",
        "id": 466003238,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1724934984
    },
    {
        "content": "<p>Maybe we could have simp lemmas which show that the composition of the associater with an <code>eqToHom</code> becomes a single <code>eqToHom</code>. This would make it so that <code>simp</code> can rewrite them to <code>eqToHom</code>s when there are other <code>eqToHom</code>s present?</p>",
        "id": 466003928,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1724935162
    },
    {
        "content": "<p>Although I guess this would be painful to undo if one does not want these to apply in a specific situation</p>",
        "id": 466010669,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1724937090
    },
    {
        "content": "<p>I may not have enough experience with this sort of thing, but I wouldn't be surprised if in some (low level?) equations, expanding to <code>eqToHom</code> is a reasonable solution.</p>\n<p>In general, it is often a good idea to treat equations for natural transformations in `Cat' (before applying them to objects) as equations for a bicategory, like Adam's solution.</p>",
        "id": 466156173,
        "sender_full_name": "Yuma Mizuno",
        "timestamp": 1724991828
    }
]