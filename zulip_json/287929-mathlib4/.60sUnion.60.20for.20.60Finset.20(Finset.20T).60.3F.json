[
    {
        "content": "<p>Is there an easy way to do something like this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">my_sUnion</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">}</span><span class=\"w\">  </span><span class=\"c1\">-- failed to synthesize instance of type class Fintype T</span>\n</code></pre></div>",
        "id": 568346395,
        "sender_full_name": "Bbbbbbbbba",
        "timestamp": 1768530639
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">my_sUnion</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">biUnion</span><span class=\"w\"> </span><span class=\"n\">id</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">mem_my_sUnion</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">my_sUnion</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">my_sUnion</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 568346589,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1768530817
    },
    {
        "content": "<p>Might be useful to add this to mathlib I think?</p>",
        "id": 568346885,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768531088
    },
    {
        "content": "<p>I don't think that we need this as a separate definition.</p>",
        "id": 568348204,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1768532171
    },
    {
        "content": "<p>True, although I think it would be nice if this is mentioned in the documentation somehow in a searchable way.</p>",
        "id": 568348990,
        "sender_full_name": "Bbbbbbbbba",
        "timestamp": 1768532734
    },
    {
        "content": "<p>We do have both <code>Set.iUnion</code> and <code>Set.sUnion</code>.</p>",
        "id": 568349120,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768532827
    },
    {
        "content": "<p>Why is it even called <code>Finset.biUnion</code>? <del>Can't we just call it <code>Finset.iUnion</code>?</del></p>",
        "id": 568349321,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768532992
    },
    {
        "content": "<p>I think we might want all of that in mathlib:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">iUnion</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">sUnion_of_Finite</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">Finite</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">biUnion</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">β</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">bsUnion</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">α</span>\n</code></pre></div>",
        "id": 568350012,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768533602
    },
    {
        "content": "<p>Actually I am not even sure for my project I should use Finset instead of Set. I am doing a graph theory problem involving the parity of degrees of vertices, so I need finiteness somewhere, but most of my arguments do not depend on finiteness.</p>",
        "id": 568350310,
        "sender_full_name": "Bbbbbbbbba",
        "timestamp": 1768533866
    },
    {
        "content": "<p>bounded indexed union = biUnion</p>",
        "id": 568350588,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1768534110
    },
    {
        "content": "<p>AFAIR, it used to be called <code>bind</code> because it's the monadic bind operation (not exactly, because it needs decidable equality), then was renamed to <code>biUnion</code>, but I may be wrong.</p>",
        "id": 568350673,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1768534180
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.sUnion#doc\">docs#Set.sUnion</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.iUnion#doc\">docs#Set.iUnion</a> are both here for definitional equalities. IMHO, we should start using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=sSup#doc\">docs#sSup</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=iSup#doc\">docs#iSup</a> instead, but it's a big refactor I have no time to do, and it slightly raises the entrance bar (even higher unless we make it pretty print as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mo>⋃</mo><mi>i</mi></msub><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\bigcup_i s_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0497em;vertical-align:-0.2997em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">⋃</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.162em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2997em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>).</p>",
        "id": 568350846,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1768534313
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.biUnion#doc\">docs#Finset.biUnion</a> is here, because it's a computable operation on <code>Finset</code>s. If you don't care about computability, then you may want to use finite <code>Set</code>s instead.</p>",
        "id": 568350944,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1768534387
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"1010687\">Bbbbbbbbba</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60sUnion.60.20for.20.60Finset.20.28Finset.20T.29.60.3F/near/568350310\">said</a>:</p>\n<blockquote>\n<p>Actually I am not even sure for my project I should use Finset instead of Set. I am doing a graph theory problem involving the parity of degrees of vertices, so I need finiteness somewhere, but most of my arguments do not depend on finiteness.</p>\n</blockquote>\n<p>There was a bit of discussion about Finset vs Set in graph theory here <a href=\"#narrow/channel/113489-new-members/topic/Hello.20.26.20graph.20coloring.20exercises\">#new members &gt; Hello &amp; graph coloring exercises</a>.<br>\nMaybe you'll find it a bit relevent?</p>",
        "id": 568351163,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768534592
    },
    {
        "content": "<p>The easiest solution might be to assume <code>Fintype V</code> and use <code>Set V</code> only instead of <code>Finset V</code>. If you don't care about infinite graphs.</p>",
        "id": 568351627,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768534979
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60sUnion.60.20for.20.60Finset.20.28Finset.20T.29.60.3F/near/568350944\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.biUnion#doc\">docs#Finset.biUnion</a> is here, because it's a computable operation on <code>Finset</code>s. If you don't care about computability, then you may want to use finite <code>Set</code>s instead.</p>\n</blockquote>\n<p>I happen to care about sums of edge weights. Could that be easily handled with finite <code>Set</code>s?</p>",
        "id": 568548859,
        "sender_full_name": "Bbbbbbbbba",
        "timestamp": 1768614512
    },
    {
        "content": "<p>It depends on whether you care about computability of these sums. There are two possible scenarios I think. Either you want to be able to run your code to compute some sums on some particular input graphs, or you're working with concrete graph/sets in the first place (i.e. you don't just assume you have some finite set, but you're working with some particular finite set like {1, 5, 7}).</p>",
        "id": 568552656,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768618723
    },
    {
        "content": "<p>Actually neither, but I want to use the fact that, for example, if the total weight of <code>A ∪ B</code> is <code>w</code>, then the total weight of at least one of <code>A</code> and <code>B</code> is <code>≥ w / 2</code>.</p>",
        "id": 568552792,
        "sender_full_name": "Bbbbbbbbba",
        "timestamp": 1768618900
    },
    {
        "content": "<p>Also, I see <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Set/Card.html#Set.ncard_lt_ncard\">Set.ncard_lt_ncard</a>, but where is \"Set.ncard_le_ncard\" for not-necessarily-proper subsets?</p>",
        "id": 568553912,
        "sender_full_name": "Bbbbbbbbba",
        "timestamp": 1768620139
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"1010687\">Bbbbbbbbba</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60sUnion.60.20for.20.60Finset.20.28Finset.20T.29.60.3F/near/568553912\">said</a>:</p>\n<blockquote>\n<p>Also, I see <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Set/Card.html#Set.ncard_lt_ncard\">Set.ncard_lt_ncard</a>, but where is \"Set.ncard_le_ncard\" for not-necessarily-proper subsets?</p>\n</blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Set/Card.html#Set.ncard_le_ncard\">Set.ncard_le_ncard</a></p>\n<p>It takes some time to get to know mathlib naming conventions. <code>lt</code> is used instead of <code>&lt;</code> in identifiers. <code>le</code> is used instead of <code>≤</code>.</p>",
        "id": 568554261,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768620552
    },
    {
        "content": "<p>Wait, I just failed to find it on the webpage <span aria-label=\"rolling on the floor laughing\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rolling on the floor laughing\">:rolling_on_the_floor_laughing:</span> A bit too many lemmas with the substring \"ncard_le_ncard\"...</p>",
        "id": 568554420,
        "sender_full_name": "Bbbbbbbbba",
        "timestamp": 1768620703
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"1010687\">Bbbbbbbbba</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60sUnion.60.20for.20.60Finset.20.28Finset.20T.29.60.3F/near/568552792\">said</a>:</p>\n<blockquote>\n<p>Actually neither, but I want to use the fact that, for example, if the total weight of <code>A ∪ B</code> is <code>w</code>, then the total weight of at least one of <code>A</code> and <code>B</code> is <code>≥ w / 2</code>.</p>\n</blockquote>\n<p>I think that working with sums over Finset was easier than finite sums over Set at the past, but it was some time ago when I tinkered with this, so maybe that improved? Seems like at least for sums over union they have very similar lemmas:<br>\n<span class=\"user-mention\" data-user-id=\"644391\">@loogle</span> finsum, Union.union</p>",
        "id": 568554862,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768621087
    },
    {
        "content": "<p><span aria-label=\"search\" class=\"emoji emoji-1f50d\" role=\"img\" title=\"search\">:search:</span> <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/BigOperators/Finprod.html#finsum_mem_union\">finsum_mem_union</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/BigOperators/Finprod.html#finsum_mem_union_inter\">finsum_mem_union_inter</a>, and <a href=\"https://loogle.lean-lang.org/?q=finsum%2C%20Union.union\">3 more</a></p>",
        "id": 568554863,
        "sender_full_name": "loogle",
        "timestamp": 1768621090
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"644391\">@loogle</span> Finset.sum, Union.union</p>",
        "id": 568554875,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768621110
    },
    {
        "content": "<p><span aria-label=\"search\" class=\"emoji emoji-1f50d\" role=\"img\" title=\"search\">:search:</span> <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/BigOperators/Group/Finset/Basic.html#Finset.sum_union\">Finset.sum_union</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/BigOperators/Group/Finset/Basic.html#Finset.sum_union_eq_left\">Finset.sum_union_eq_left</a>, and <a href=\"https://loogle.lean-lang.org/?q=Finset.sum%2C%20Union.union\">6 more</a></p>",
        "id": 568554876,
        "sender_full_name": "loogle",
        "timestamp": 1768621111
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"644391\">@loogle</span>  finsum, nonneg</p>",
        "id": 568599286,
        "sender_full_name": "Bbbbbbbbba",
        "timestamp": 1768666700
    },
    {
        "content": "<p><span aria-label=\"exclamation\" class=\"emoji emoji-2757\" role=\"img\" title=\"exclamation\">:exclamation:</span> unknown identifier 'nonneg'<br>\nDid you mean <a href=\"https://loogle.lean-lang.org/?q=finsum%2C%20%22nonneg%22\"><code>finsum, \"nonneg\"</code></a>, <a href=\"https://loogle.lean-lang.org/?q=finsum%2C%20Int.NonNeg\"><code>finsum, Int.NonNeg</code></a>, or <a href=\"https://loogle.lean-lang.org/?q=finsum%2C%20nonneg\">something else</a>?</p>",
        "id": 568599290,
        "sender_full_name": "loogle",
        "timestamp": 1768666701
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"644391\">@loogle</span> finsum, \"nonneg\"</p>",
        "id": 568599309,
        "sender_full_name": "Bbbbbbbbba",
        "timestamp": 1768666727
    },
    {
        "content": "<p><span aria-label=\"search\" class=\"emoji emoji-1f50d\" role=\"img\" title=\"search\">:search:</span> <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/BigOperators/Finprod.html#finsum_nonneg\">finsum_nonneg</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Topology/PartitionOfUnity.html#PartitionOfUnity.sum_nonneg\">PartitionOfUnity.sum_nonneg</a>, and <a href=\"https://loogle.lean-lang.org/?q=finsum%2C%20%22nonneg%22\">1 more</a></p>",
        "id": 568599312,
        "sender_full_name": "loogle",
        "timestamp": 1768666728
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"644391\">@loogle</span> finprod, \"nonneg\"</p>",
        "id": 568599345,
        "sender_full_name": "Bbbbbbbbba",
        "timestamp": 1768666761
    },
    {
        "content": "<p><span aria-label=\"search\" class=\"emoji emoji-1f50d\" role=\"img\" title=\"search\">:search:</span> <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/BigOperators/Finprod.html#finprod_nonneg\">finprod_nonneg</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/BigOperators/Finprod.html#finprod_cond_nonneg\">finprod_cond_nonneg</a></p>",
        "id": 568599346,
        "sender_full_name": "loogle",
        "timestamp": 1768666762
    },
    {
        "content": "<p>Why not finsum_cond_nonneg?</p>",
        "id": 568599369,
        "sender_full_name": "Bbbbbbbbba",
        "timestamp": 1768666782
    },
    {
        "content": "<p>I would guess the answer is \"because we forgot\". You should definitely prove it and PR to mathlib.</p>",
        "id": 568599852,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768667230
    },
    {
        "content": "<p>Here's the proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">to_additive</span><span class=\"w\"> </span><span class=\"n\">finsum_cond_nonneg</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">one_le_finprod_cond'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommMonoid</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PartialOrder</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsOrderedMonoid</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"bp\">∏ᶠ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">one_le_finprod'</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">one_le_finprod'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 568600297,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768667676
    },
    {
        "content": "<p>I'm not sure mathlib wants that lemma</p>",
        "id": 568661036,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1768739953
    },
    {
        "content": "<p>I don't know either, but would you elaborate why <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/BigOperators/Finprod.html#finprod_cond_nonneg\">finprod_cond_nonneg</a> is useful but <code>finsum_cond_nonneg</code> isn't?</p>",
        "id": 568661110,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768740033
    },
    {
        "content": "<p>That's a fair argument, we should be consistent one way or the other</p>",
        "id": 568661161,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1768740098
    },
    {
        "content": "<p>I mean, these are more different than the name would suggest tbh. As you can see the multiplicative equivalent of <code>finsum_cond_nonneg</code> is <code>one_le_finprod_cond'</code>, which we also don't have in mathlib.<br>\nI do wonder why only <code>finprod_cond_nonneg</code> was added as a \"cond\" version?</p>",
        "id": 568661346,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768740336
    },
    {
        "content": "<p>My experience is that since I am always adding over finite <code>Set</code>s (which is implemented in a way that matches the \"cond\" version), only having non-cond lemmas is quite awkward.</p>",
        "id": 568661892,
        "sender_full_name": "Bbbbbbbbba",
        "timestamp": 1768740910
    },
    {
        "content": "<p>Hm, I could image someone might also want to sum over <code>Set</code> AND have some additional condition. Which would result in wanting to have lemmas like <code>finsum_cond_cond_nonneg</code>.</p>",
        "id": 568663047,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768742189
    },
    {
        "content": "<p>Or maybe just one lemma to combine two conditions?</p>",
        "id": 568663135,
        "sender_full_name": "Bbbbbbbbba",
        "timestamp": 1768742290
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"870257\">Jakub Nowak</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60sUnion.60.20for.20.60Finset.20.28Finset.20T.29.60.3F/near/568600297\">said</a>:</p>\n<blockquote>\n<p>Here's the proof:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">to_additive</span><span class=\"w\"> </span><span class=\"n\">finsum_cond_nonneg</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">one_le_finprod_cond'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommMonoid</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PartialOrder</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsOrderedMonoid</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"bp\">∏ᶠ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">one_le_finprod'</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">one_le_finprod'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Also I think you should have <code>p i</code> instead of <code>p x</code> here?</p>",
        "id": 568664928,
        "sender_full_name": "Bbbbbbbbba",
        "timestamp": 1768744266
    },
    {
        "content": "<p>Oops, you're right. (I've edited code from that post)</p>",
        "id": 568665225,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768744570
    },
    {
        "content": "<p>You should also allow f to be a function of the proof</p>",
        "id": 568705619,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1768783358
    },
    {
        "content": "<p>... And then consider the case where the \"proof\" lives in <code>Sort</code></p>",
        "id": 568705651,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1768783393
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60sUnion.60.20for.20.60Finset.20.28Finset.20T.29.60.3F/near/568705619\">said</a>:</p>\n<blockquote>\n<p>You should also allow f to be a function of the proof</p>\n</blockquote>\n<p>Oh, you're right. <code>findprod_cond_nonneg</code> also has that problem. :/</p>",
        "id": 568715005,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768793393
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"1010687\">@Bbbbbbbbba</span> It looks like you might have easier time using <code>Finset.sum</code> instead of <code>finsum</code>. Unless you want to work on improving <code>finsum</code> API.</p>",
        "id": 568715080,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768793465
    },
    {
        "content": "<p>Well in my use case I am just adding fixed edge weights, so I do not foresee it being a big problem (<code>finsum_nonneg fun e ↦ finsum_nonneg fun h ↦ ctx.weight_nonneg e</code> works for the cases I've needed so far). Using Sets seems to make my code cleaner in many other places so it seems like a worthwhile tradeoff.</p>",
        "id": 568718333,
        "sender_full_name": "Bbbbbbbbba",
        "timestamp": 1768796750
    },
    {
        "content": "<p>Yeah, it's a tradeoff. In case you'll find out you're missing some lemmas, you can always convert to Finset with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=finsum_mem_eq_finite_toFinset_sum#doc\">docs#finsum_mem_eq_finite_toFinset_sum</a>. And for converting back to Set <code>norm_cast</code> should work.</p>",
        "id": 568746046,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768811753
    }
]