[
    {
        "content": "<p>On Mathlib revision <code>381f27922fc7b639c2670d0039751dc603d5c55d</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Polynomial</span>\n\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">Mul</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⊥</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ideal</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]))</span><span class=\"w\"> </span><span class=\"c1\">-- times out (~20500 hb)</span>\n</code></pre></div>",
        "id": 564374449,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1766027821
    },
    {
        "content": "<p>Even before the recent PRs which have pushed it over the line, mathlib was having trouble finding this instance. On a version of mathlib from last week we have this monster trace</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>first part of trace</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>[Meta.synthInstance] [12744412.000000] ✅️ Mul (R[X] ⧸ ⊥) ▼\n    [whnf] [25.000000] Non-easy whnf: Mul (R[X] ⧸ ⊥)\n    [whnf] [25.000000] Non-easy whnf: Mul (R[X] ⧸ ⊥)\n    [] [306.000000] new goal Mul (R[X] ⧸ ⊥) ▼\n      [whnf] [25.000000] Non-easy whnf: Mul (R[X] ⧸ ⊥)\n      [instances] #[@Lean.Grind.Semiring.toMul, @Semigroup.toMul, @CommMagma.toMul, @MulOne.toMul, @MulZeroClass.toMul, @Distrib.toMul, @GradedMonoid.GradeZero.mul]\n    [] [576514.000000] ✅️ apply @GradedMonoid.GradeZero.mul to Mul (R[X] ⧸ ⊥) ▶\n    [] [3394.000000] ✅️ apply @DirectSum.GNonUnitalNonAssocSemiring.toGMul to GradedMonoid.GMul (HasQuotient.Quotient R[X]) ▶\n    [] [397231.000000] ✅️ apply @DirectSum.GSemiring.toGNonUnitalNonAssocSemiring to DirectSum.GNonUnitalNonAssocSemiring\n          (HasQuotient.Quotient R[X]) ▶\n    [] [4279.000000] ✅️ apply @DirectSum.GRing.toGSemiring to DirectSum.GSemiring (HasQuotient.Quotient R[X]) ▶\n    [] [10620.000000] ✅️ apply @DirectSum.GCommRing.toGRing to DirectSum.GRing (HasQuotient.Quotient R[X]) ▶\n    [] [4766.000000] ✅️ apply @DirectSum.GCommSemiring.toGSemiring to DirectSum.GSemiring (HasQuotient.Quotient R[X]) ▶\n    [] [4482.000000] ✅️ apply @DirectSum.GCommRing.toGCommSemiring to DirectSum.GCommSemiring (HasQuotient.Quotient R[X]) ▶\n    [] [2477238.000000] ✅️ apply @Submodule.Quotient.addCommGroup to (i : Submodule R[X] R[X]) → AddCommGroup (R[X] ⧸ i) ▶\n    [isDefEq] [87430.000000] ✅️ ?m.31 =?= Submodule.Quotient.addCommGroup ▶\n    [resume] [308.000000] propagating (p : Submodule R[X] R[X]) →\n          AddCommGroup\n            (R[X] ⧸\n              p) to subgoal (i : Submodule R[X] R[X]) →\n          AddCommGroup (R[X] ⧸ i) of DirectSum.GCommSemiring (HasQuotient.Quotient R[X]) ▶\n    [] [3984.000000] ✅️ apply @GradedMonoid.GMonoid.toGMul to GradedMonoid.GMul (HasQuotient.Quotient R[X]) ▶\n    [] [3310.000000] ✅️ apply @DirectSum.GSemiring.toGMonoid to GradedMonoid.GMonoid (HasQuotient.Quotient R[X]) ▶\n    [] [2669.000000] ✅️ apply @ESeminormedAddCommMonoid.toAddCommMonoid to (i : Submodule R[X] R[X]) → AddCommMonoid (R[X] ⧸ i) ▶\n    [] [135646.000000] ✅️ apply @topologicalRingQuotientTopology to (i : Submodule R[X] R[X]) → TopologicalSpace (R[X] ⧸ i) ▶\n    [] [1206.000000] ✅️ apply @UpgradedStandardBorel.toTopologicalSpace to TopologicalSpace R[X] ▶\n    [] [1296.000000] ✅️ apply @UniformSpace.toTopologicalSpace to TopologicalSpace R[X] ▶\n    [] [1744.000000] ✅️ apply @Valued.toUniformSpace to UniformSpace R[X] ▶\n    [] [4651.000000] ✅️ apply @IsValuativeTopology.instValuedValueGroupWithZeroOfIsUniformAddGroup to Valued R[X]\n          (ValuativeRel.ValueGroupWithZero R[X]) ▶\n    [] [1532.000000] ✅️ apply @PseudoMetricSpace.toUniformSpace to UniformSpace R[X] ▶\n    [] [1428.000000] ✅️ apply @TopologicalSpace.UpgradedIsCompletelyPseudoMetrizableSpace.toPseudoMetricSpace to PseudoMetricSpace\n          R[X] ▶\n    [] [1445.000000] ✅️ apply @SeminormedRing.toPseudoMetricSpace to PseudoMetricSpace R[X] ▶\n    [] [1450.000000] ✅️ apply @SeminormedCommRing.toSeminormedRing to SeminormedRing R[X] ▶\n    [] [1469.000000] ✅️ apply @NormedCommRing.toSeminormedCommRing to SeminormedCommRing R[X] ▶\n    [] [1455.000000] ✅️ apply @CommCStarAlgebra.toNormedCommRing to NormedCommRing R[X] ▶\n    [] [1481.000000] ✅️ apply @NormedField.toNormedCommRing to NormedCommRing R[X] ▶\n    [] [1466.000000] ✅️ apply @DenselyNormedField.toNormedField to NormedField R[X] ▶\n    [] [1626.000000] ✅️ apply @RCLike.toDenselyNormedField to DenselyNormedField R[X] ▶\n    [] [1458.000000] ✅️ apply @NontriviallyNormedField.toNormedField to NormedField R[X] ▶\n    [] [1291.000000] ✅️ apply @DenselyNormedField.toNontriviallyNormedField to NontriviallyNormedField R[X] ▶\n    [] [1456.000000] ✅️ apply @NormedRing.toSeminormedRing to SeminormedRing R[X] ▶\n    [] [1447.000000] ✅️ apply @CStarAlgebra.toNormedRing to NormedRing R[X] ▶\n    [] [1426.000000] ✅️ apply @CommCStarAlgebra.toCStarAlgebra to CStarAlgebra R[X] ▶\n    [] [1254.000000] ✅️ apply @NormedCommRing.toNormedRing to NormedRing R[X] ▶\n    [] [1433.000000] ✅️ apply @NormedDivisionRing.toNormedRing to NormedRing R[X] ▶\n    [] [1274.000000] ✅️ apply @NormedField.toNormedDivisionRing to NormedDivisionRing R[X] ▶\n    [] [1482.000000] ✅️ apply @NonUnitalSeminormedRing.toPseudoMetricSpace to PseudoMetricSpace R[X] ▶\n    [] [1456.000000] ✅️ apply @NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing to NonUnitalSeminormedRing R[X] ▶\n    [] [1291.000000] ✅️ apply @SeminormedCommRing.toNonUnitalSeminormedCommRing to NonUnitalSeminormedCommRing R[X] ▶\n    [] [1469.000000] ✅️ apply @NonUnitalNormedCommRing.toNonUnitalSeminormedCommRing to NonUnitalSeminormedCommRing R[X] ▶\n    [] [1444.000000] ✅️ apply @NonUnitalCommCStarAlgebra.toNonUnitalNormedCommRing to NonUnitalNormedCommRing R[X] ▶\n    [] [1452.000000] ✅️ apply CommCStarAlgebra.toNonUnitalCommCStarAlgebra to NonUnitalCommCStarAlgebra R[X] ▶\n    [] [1261.000000] ✅️ apply @NormedCommRing.toNonUnitalNormedCommRing to NonUnitalNormedCommRing R[X] ▶\n    [] [1481.000000] ✅️ apply @NonUnitalNormedRing.toNonUnitalSeminormedRing to NonUnitalSeminormedRing R[X] ▶\n    [] [1463.000000] ✅️ apply @NonUnitalCStarAlgebra.toNonUnitalNormedRing to NonUnitalNormedRing R[X] ▶\n    [] [1267.000000] ✅️ apply @NonUnitalCommCStarAlgebra.toNonUnitalCStarAlgebra to NonUnitalCStarAlgebra R[X] ▶\n    [] [1282.000000] ✅️ apply CStarAlgebra.toNonUnitalCStarAlgebra to NonUnitalCStarAlgebra R[X] ▶\n    [] [1255.000000] ✅️ apply @NonUnitalNormedCommRing.toNonUnitalNormedRing to NonUnitalNormedRing R[X] ▶\n    [] 350 more entries... ▶\n</code></pre></div>\n</div></div>\n<p>(note \"350 more entries\" at the bottom).  Highlights from the beginning are:</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>    [] [306.000000] new goal Mul (R[X] ⧸ ⊥) ▼\n      [whnf] [25.000000] Non-easy whnf: Mul (R[X] ⧸ ⊥)\n      [instances] #[@Lean.Grind.Semiring.toMul, @Semigroup.toMul, @CommMagma.toMul, @MulOne.toMul, @MulZeroClass.toMul, @Distrib.toMul, @GradedMonoid.GradeZero.mul]\n</code></pre></div>\n<p>i.e. \"we're going to try and find <code>Mul</code> on a thing, and there are a ton of basic instances of this defined right at the start of mathlib such as <code>Distrib.toMul</code>, and then there's the completely exotic <code>GradedMonoid.GradeZero.mul</code> defined right at the end, and so we'll try this one first because that's the algorithm\". So the next step is</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>    [] [576514.000000] ✅️ apply @GradedMonoid.GradeZero.mul to Mul (R[X] ⧸ ⊥) ▶\n</code></pre></div>\n<p>and now suddenly we're looking for a grading to get our mul <del>(and note that this is happening in every file which imports <code>GradedMonoid.GradeZero.mul</code> and in every project or file which has a casual <code>import Mathlib</code> somewhere, every time someone asks for a multiplication)</del> (I take that back -- there is an extra coincidence here). </p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>[] [292.000000] new goal GradedMonoid.GMul (HasQuotient.Quotient R[X]) ▼\n        [whnf] [25.000000] Non-easy whnf: GradedMonoid.GMul (HasQuotient.Quotient R[X])\n        [instances] #[@GradedMonoid.GMonoid.toGMul, @DirectSum.GNonUnitalNonAssocSemiring.toGMul]\n</code></pre></div>\n<p>So now we're about to start looking for a graded ring structure on...wait...what? <code>HasQuotient.Quotient R[X]</code>?</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>    [] [4482.000000] ✅️ apply @DirectSum.GCommRing.toGCommSemiring to DirectSum.GCommSemiring (HasQuotient.Quotient R[X]) ▼\n      [whnf] [25.000000] Non-easy whnf: DirectSum.GCommSemiring (HasQuotient.Quotient R[X])\n</code></pre></div>\n<p>and there it ultimately goes: to find a multiplication on the quotient we're going to look for a graded ring structure on <code>HasQuotient.Quotient R[X]</code>, because <code>HasQuotient.Quotient R[X]</code> is indeed a function from the type <code>Ideal R[X]</code> to <code>Type </code> (sending <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">I</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo stretchy=\"false\">[</mo><mi>X</mi><mo stretchy=\"false\">]</mo><mi mathvariant=\"normal\">/</mi><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">R[X]/I</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">]</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span>) and indeed these quotients do have additive group structures, so perhaps this is a graded ring. And indeed it's not hard to find additive group structures on the quotient. So what's left to do before we ultimately fail to find this graded ring structure?</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>    [] [3984.000000] ✅️ apply @GradedMonoid.GMonoid.toGMul to GradedMonoid.GMul (HasQuotient.Quotient R[X]) ▼\n</code></pre></div>\n<p>Aah yes, a graded structure on a collection of additive groups indexed by a type which has addition (and indeed you can add ideals) needs a <code>GMul</code>, so now having started looking for <code>Mul</code> on <code>R[X]/I</code> we're now looking for <code>GMul</code> on the function sending an ideal <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">I</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo stretchy=\"false\">[</mo><mi>X</mi><mo stretchy=\"false\">]</mo><mi mathvariant=\"normal\">/</mi><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">R[X]/I</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">]</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span>, i.e. a map <code>R[X]/I-&gt;R[X]/J-&gt;R[X]/(I+J)</code>. OK so it will suffice to find a <code>GMonoid</code> structure on this function. Now, how do we find GMonoid structures? Well we certainly need additive monoid structures on each factor, so how do we find an additive monoid structure on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo stretchy=\"false\">[</mo><mi>X</mi><mo stretchy=\"false\">]</mo><mi mathvariant=\"normal\">/</mi><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">R[X]/I</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">]</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span>?</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>      [] [314.000000] new goal (i : Submodule R[X] R[X]) → AddCommMonoid (R[X] ⧸ i) ▼\n        [whnf] [25.000000] Non-easy whnf: AddCommMonoid (R[X] ⧸ i)\n        [instances] #[@AddCancelCommMonoid.toAddCommMonoid, @AddCommMonoid.ofIsAddCommutative, @SubtractionCommMonoid.toAddCommMonoid, @AddCommGroup.toAddCommMonoid, @AddCommMonoidWithOne.toAddCommMonoid, @NonUnitalNonAssocSemiring.toAddCommMonoid, @LinearOrderedAddCommMonoidWithTop.toAddCommMonoid, @ESeminormedAddCommMonoid.toAddCommMonoid]\n</code></pre></div>\n<p>Well there are a lot of choices, but we've imported everything and the last example of how to make an additive monoid is we can get one from an <code>ESeminormedAddCommMonoid</code>. Fabulous! Let's now start looking for norms on <code>R[X]/I</code>. Well, norms are something to do with topology so maybe we should be looking for a topology?</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>    [] [135646.000000] ✅️ apply @topologicalRingQuotientTopology to (i : Submodule R[X] R[X]) → TopologicalSpace (R[X] ⧸ i) ▶\n    [] [1206.000000] ✅️ apply @UpgradedStandardBorel.toTopologicalSpace to TopologicalSpace R[X] ▶\n</code></pre></div>\n<p>etc etc.</p>",
        "id": 564417997,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1766051300
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"mi\">900</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">GradedMonoid</span><span class=\"bp\">.</span><span class=\"n\">GradeZero</span><span class=\"bp\">.</span><span class=\"n\">mul</span>\n</code></pre></div>\n<p>divides the time taken to find this instance by a factor of three (and in particular fixes the timeout on this week's mathlib)</p>",
        "id": 564420043,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1766051971
    },
    {
        "content": "<p>aargh lol looking at the new trace:</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>    [] [305.000000] new goal Mul (R[X] ⧸ ⊥) ▶\n    [] [1500.000000] ✅️ apply @Distrib.toMul to Mul (R[X] ⧸ ⊥) ▶\n    [] [1706.000000] ✅️ apply @NonUnitalNonAssocSemiring.toDistrib to Distrib (R[X] ⧸ ⊥) ▶\n    [] [576477.000000] ✅️ apply @DirectSum.GradeZero.nonUnitalNonAssocSemiring to NonUnitalNonAssocSemiring (R[X] ⧸ ⊥) ▶\n    [] [4152.000000] ❌️ apply @FirstOrder.Language.instDecidableEqRelations to DecidableEq (Submodule R[X] R[X]) ▶\n    [] [4000.000000] ❌️ apply @FirstOrder.Language.instDecidableEqFunctions to DecidableEq (Submodule R[X] R[X]) ▶\n    [] [3885.000000] ✅️ apply @LinearOrder.toDecidableEq to DecidableEq (Submodule R[X] R[X]) ▶\n    [] [151392.000000] ✅️ apply ValuationRing.instLinearOrderIdealOfDecidableLE to LinearOrder (Submodule R[X] R[X]) ▶\n    [] [5008.000000] ✅️ apply @ValuationRing.toPreValuationRing to PreValuationRing R[X] ▶\n    [] [3056.000000] ✅️ apply of_isDiscreteValuationRing to ValuationRing R[X] ▶\n</code></pre></div>\n<p>and off we go again with randomness</p>",
        "id": 564420457,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1766052107
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"mi\">900</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">GradedMonoid</span><span class=\"bp\">.</span><span class=\"n\">GradeZero</span><span class=\"bp\">.</span><span class=\"n\">mul</span><span class=\"w\"> </span><span class=\"n\">DirectSum</span><span class=\"bp\">.</span><span class=\"n\">GradeZero</span><span class=\"bp\">.</span><span class=\"n\">nonUnitalNonAssocSemiring</span>\n</code></pre></div>\n<p>makes it 10x faster</p>",
        "id": 564420791,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1766052206
    },
    {
        "content": "<p>I think we've got graded rings wrong somehow (or perhaps just their prios)</p>",
        "id": 564420858,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1766052229
    },
    {
        "content": "<p>aargh dammit</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>    [] [307.000000] new goal Mul (R[X] ⧸ ⊥) ▶\n    [] [1504.000000] ✅️ apply @Distrib.toMul to Mul (R[X] ⧸ ⊥) ▶\n    [] [1706.000000] ✅️ apply @NonUnitalNonAssocSemiring.toDistrib to Distrib (R[X] ⧸ ⊥) ▶\n    [] [1649.000000] ✅️ apply @NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring to NonUnitalNonAssocSemiring\n          (R[X] ⧸ ⊥) ▶\n    [] [1647.000000] ✅️ apply @NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring to NonUnitalNonAssocCommSemiring\n          (R[X] ⧸ ⊥) ▶\n    [] [1669.000000] ✅️ apply @NonUnitalCommRing.toNonUnitalNonAssocCommRing to NonUnitalNonAssocCommRing (R[X] ⧸ ⊥) ▶\n    [] [1661.000000] ✅️ apply @NonUnitalNormedCommRing.toNonUnitalCommRing to NonUnitalCommRing (R[X] ⧸ ⊥) ▶\n    [] [1644.000000] ✅️ apply @NonUnitalCommCStarAlgebra.toNonUnitalNormedCommRing to NonUnitalNormedCommRing (R[X] ⧸ ⊥) ▶\n    [] [1637.000000] ✅️ apply CommCStarAlgebra.toNonUnitalCommCStarAlgebra to NonUnitalCommCStarAlgebra (R[X] ⧸ ⊥) ▶\n    [] [1917.000000] ✅️ apply @NormedCommRing.toNonUnitalNormedCommRing to NonUnitalNormedCommRing (R[X] ⧸ ⊥) ▶\n</code></pre></div>\n<p>why is typeclass inference so <em>stupid</em>? Don't look for a norm! Clearly this question has nothing to do with norms! Don't look for a grading! Don't look for a topology! This is boring old ring theory!</p>",
        "id": 564421206,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1766052348
    },
    {
        "content": "<p>Actually I am wrong about the severity of the issue. The funny coincidence which is happening here is this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">@</span><span class=\"n\">GradedMonoid</span><span class=\"bp\">.</span><span class=\"n\">GradeZero</span><span class=\"bp\">.</span><span class=\"n\">mul</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AddZeroClass</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">GradedMonoid</span><span class=\"bp\">.</span><span class=\"n\">GMul</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Mul</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>i.e. \"if I can find a <code>GMul</code> on a function <code>A : ι → Type</code> where <code>ι</code> has a zero and an addition, then I can find a <code>Mul</code> on <code>A 0</code>. So is <code>(R[X] ⧸ (⊥ : Ideal R[X]))</code> of the form <code>A 0</code>? Oh, coincidentally, it is! Because <code>0 = ⊥</code> and <code>ι = Ideal (R[X])</code> has an addition, so this works great if <code>A = HasQuotient.Quotient R[X] = I ↦ R[X]⧸I</code>. So it's this weird coincidence which is causing the problems here; usually this <code>GradedMonoid.GradeZero.mul</code> would presumably be quick to fail.</p>",
        "id": 564422390,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1766052720
    },
    {
        "content": "<p>I think making the graded instances globally a lower priority might be nice to try.<br>\nA more severe option would be scoping them, but that might be annoying.</p>",
        "id": 564437918,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1766058004
    },
    {
        "content": "<p>Some other things I noticed when looking when looking at live.lean-lang (Mathlib commit <code>dfccc70</code>):</p>\n<ul>\n<li>It spends a very long time trying to apply both <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ideal.Quotient.normedCommRing#doc\">docs#Ideal.Quotient.normedCommRing</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ideal.Quotient.semiNormedCommRing#doc\">docs#Ideal.Quotient.semiNormedCommRing</a> . Unfortunately it spends the same amount of time for both of them, probably doing essentially the same steps (but not the same enough so that the cache applies) (roughly 1.2M heartbeats with <code>attribute [-instance] GradedMonoid.GradeZero.mul DirectSum.GradeZero.nonUnitalNonAssocSemiring DirectSum.GradeZero.nonUnitalNonAssocRing</code>)</li>\n<li>It spends a lot of time unifying, before checking that there is actually a <code>NormedCommRing</code> instance on <code>R[X]</code>. Since elaboration is so complex, this is probably not something we can change.</li>\n<li>It spends a very long amount of time on both unifying <code>HasQuotient.quotient _ _ =?= HasQuotient.quotient _ _</code> and then on <code>HasQuotient.quotient' _ _ =?= HasQuotient.quotient' _ _</code>:</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">          </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mf\">1283186.000000</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">❌️</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"bp\">⊥</span><span class=\"w\"> </span><span class=\"bp\">=?=</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">23</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">25</span><span class=\"w\"> </span><span class=\"bp\">▼</span>\n<span class=\"w\">            </span><span class=\"o\">[</span><span class=\"n\">delta</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mf\">434066.000000</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">❌️</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"bp\">⊥</span><span class=\"w\"> </span><span class=\"bp\">=?=</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">23</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">25</span><span class=\"w\"> </span><span class=\"bp\">▶</span>\n<span class=\"w\">            </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mf\">848764.000000</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">❌️</span><span class=\"w\"> </span><span class=\"n\">HasQuotient</span><span class=\"bp\">.</span><span class=\"n\">quotient'</span><span class=\"w\"> </span><span class=\"bp\">⊥</span><span class=\"w\"> </span><span class=\"bp\">=?=</span><span class=\"w\"> </span><span class=\"n\">HasQuotient</span><span class=\"bp\">.</span><span class=\"n\">quotient'</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">25</span><span class=\"w\"> </span><span class=\"bp\">▼</span>\n</code></pre></div>\n<p>I'm wondering if there is secretly a very high cost to the following very innocently-looking abbreviation that just changes the explicitness of an argument:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">HasQuotient</span><span class=\"bp\">.</span><span class=\"n\">Quotient</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">HasQuotient</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">HasQuotient</span><span class=\"bp\">.</span><span class=\"n\">quotient'</span><span class=\"w\"> </span><span class=\"n\">b</span>\n</code></pre></div>\n<p>Note: it spends roughly the same number of heartbeats trying to unify arguments, so it seems it's actually doing a lot of work twice because of the existence of this abbrev:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">              </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mf\">433700.000000</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">❌️</span><span class=\"w\"> </span><span class=\"bp\">⊥</span><span class=\"w\"> </span><span class=\"bp\">=?=</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">25</span><span class=\"w\"> </span><span class=\"bp\">▼</span>\n<span class=\"o\">[</span><span class=\"bp\">...</span><span class=\"o\">]</span>\n<span class=\"w\">              </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mf\">422278.000000</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">❌️</span><span class=\"w\"> </span><span class=\"bp\">⊥</span><span class=\"w\"> </span><span class=\"bp\">=?=</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">25</span><span class=\"w\"> </span><span class=\"bp\">▶</span>\n</code></pre></div>\n<ul>\n<li>When unifying these quotient instances, it spends <em>a lot</em> of time unfolding everything it can from the instance <code>Polynomial.semiring</code>. Adding <code>attribute [local irreducible] Polynomial.semiring</code> improves the heartbeat count by a lot. We should make more instances on <code>Polynomial</code> (and other types) irreducible.<br>\nThe only thing we have to ensure is that the different instances of <code>Polynomial</code> do unify (e.g. <code>Polynomial.instAdd</code> maybe should be irreducible, but <code>Polynomial.semiring</code> should use the same (irreducible) addition as <code>Polynomial.instAdd</code>. This might require some reworking of the instances.</li>\n</ul>",
        "id": 564440738,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1766058961
    },
    {
        "content": "<p>Attempt to fix the <code>HasQuotient.quotient'</code> issue: <a href=\"https://github.com/leanprover-community/mathlib4/pull/33037\">#33037</a></p>",
        "id": 564454905,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1766063312
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  tried some ablations</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">count_heartbeats</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">Mul</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⊥</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ideal</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"c1\">-- 2951 hb</span>\n\n<span class=\"bp\">#</span><span class=\"n\">count_heartbeats</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">Mul</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- 2982 hb</span>\n\n<span class=\"bp\">#</span><span class=\"n\">count_heartbeats</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">Mul</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- 335 hb</span>\n</code></pre></div>\n<p>Looks like it's some sort of multiplicative blow up due to the combination of the two issues described</p>",
        "id": 564594927,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1766104761
    },
    {
        "content": "<p>Yeah the issue is that you're looking for a multiplication on something which is easily checked to be of the form <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">F(0)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mclose\">)</span></span></span></span> so the first thing it tries to find is a heterogeneous multiplication <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo stretchy=\"false\">)</mo><mo>×</mo><mi>F</mi><mo stretchy=\"false\">(</mo><mi>b</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mi>F</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">F(a)\\times F(b)\\to F(a+b)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span></span></span></span> and this takes a long time to fail.</p>",
        "id": 564643253,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1766133493
    },
    {
        "content": "<p>Oh but actually then the second one surprises me. Did you look at the trace? I'm unlikely to be near lean for the next two days</p>",
        "id": 564643450,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1766133555
    },
    {
        "content": "<p>We really really need some standalone (i.e. Mathlib free!) demonstrations of these issues. We would love to fix these issues, but need the test cases. I have been trying with the new <a href=\"https://github.com/kim-em/lean-minimizer\">https://github.com/kim-em/lean-minimizer</a>, but so far the interesting examples take too long (~days) to successfully minimize.</p>",
        "id": 566634638,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1767740689
    },
    {
        "content": "<p>The above issues of slow unification are fixed in my PR <a href=\"https://github.com/leanprover/lean4/pull/8883\">lean#8883</a>, and the corresponding issue <a href=\"https://github.com/leanprover/lean4/pull/10414\">lean#10414</a> shows a small standalone example of the problem of exponentially slow unification.</p>\n<p>If I need to do anything about the PR such as improve the documentation, let me know.</p>",
        "id": 566689574,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1767777315
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Typeclass.20Synthesis.20Regression/near/566634638\">said</a>:</p>\n<blockquote>\n<p>We really really need some standalone (i.e. Mathlib free!) demonstrations of these issues.</p>\n</blockquote>\n<p>Is it feasible for someone who knows little about the internal workings of Lean to minimise something like this? Or are you saying we need better tooling?</p>",
        "id": 566836103,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1767825640
    },
    {
        "content": "<p>It's definitely possibly to do minimizations only understanding Mathlib, not Lean. It's just very very tedious, on the order of day's work for examples like this. <code>lean-minimizer</code> linked above is even slower, but essentially automatic. I would <em>love</em> to have people try out <code>lean-minimizer</code> (there is also the <a href=\"https://github.com/kim-em/mathlib-minimizer\">https://github.com/kim-em/mathlib-minimizer</a> repo, which just provides the convenience of a project importing both lean-minimizer and mathlib) on realistic examples, and let me know:</p>\n<ul>\n<li>additional minimizations it should be performing</li>\n<li>ideas for speeding it up.</li>\n</ul>",
        "id": 566842846,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1767828817
    },
    {
        "content": "<p>I've minimised things like this manually before. It's quite tedious but definitely possible. You just have to copy out huge chunks of the algebra hierarchy. I have some skeleton files which would probably help.</p>",
        "id": 566885308,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1767859476
    }
]