[
    {
        "content": "<p>Hi everyone.</p>\n<p>While learning I've always stated my structures, theorems and definitions in such a way that I assign to every \"free\" variable the type ´´Type´, but when looking at the documentation in Mathlib I see that the usual way to do it is to assign to every new variable a type <code>Type u_i</code>. </p>\n<p>What is the reason for doing that?</p>",
        "id": 468752852,
        "sender_full_name": "Esteban Martínez Vañó",
        "timestamp": 1725878902
    },
    {
        "content": "<p>It's simply more general (it lets you treat the surreals as a field, for instance), and there's not much reason not to do that</p>",
        "id": 468754115,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1725879297
    },
    {
        "content": "<p>In Mathlib there's <code>Type*</code> which means \"a type in an arbitrary universe\", you can usually just write it in place of <code>Type</code></p>",
        "id": 468754244,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1725879337
    },
    {
        "content": "<p>If you're interested in \"big\" objects such as the class of ordinals or the category of sets then you need to use higher universes to express these, so mathlib tries to make everything universe-polymorphic as you've spotted. In my undergraduate lean course, which gives examples of how to use lean to do basic stuff in ring theory, analysis, calculus etc I just use <code>Type</code>, I don't even introduce universes in the course, and it works fine, but I don't do any category theory or set theory in that course. As Daniel says, the reason they're there is that there's no reason not for them to be there.</p>\n<p>Yesterday I noticed a higher universe in some pretty basic code I was writing when I was using Type not Type* (I often develop using Type and then just add the *s at the end when PRing, because occasionally being maximally polymorphic can cause confusing errors). Even though I was using Type := Type 0, I saw some intermediate universe u=1. I chased it down to a use of <code>Finite G</code>. In set theory <code>Finite</code> would be defined as a first order predicate on all sets and thus it's expressible without universes. In Mathlib it's defined as a function from Type to Prop and as such it lives in a higher universe because it's a function but (using set-theoretic language) its domain is not a set, it's a class.</p>",
        "id": 468756260,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1725879894
    },
    {
        "content": "<p>I see. I think I get it. But then, in practice, you don't write ´Type u_i´ for all the varaibles, just ´Type*´ and that makes them belong to the universe they need to be in?</p>",
        "id": 468759949,
        "sender_full_name": "Esteban Martínez Vañó",
        "timestamp": 1725880806
    },
    {
        "content": "<p>Yes, <code>(X : Type*)</code> just means \"create a new universe variable u_37 and make X live in that universe\".</p>",
        "id": 468763241,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1725881630
    },
    {
        "content": "<p>I see.</p>\n<p>But then, what is the problem in <a href=\"https://live.lean-lang.org/#codez=JYWwDg9gTgLgBAWQIYwBYBtgCMB0AVCSdCAcwE8cBJAOwGcYlqBjAU1pwCUWl0AoX6hGYRwAVwZZ0LOLRZMYwIf0ItqcAMot4AMWDoYLKHAJFSZOAGF0SWrWBMecbaOYKlvWTAD6hN2szUBlA4LqKyACYAakhQwEiSbHAAZjyyHlo+YH5wAUE4duC0AHIQFkL0UKLy0MmpLPy8APQAtACEcADEXXAAIsBQclos4TJatHCMI9RacOEsScDUwH7jzY38Lb3zi8uKahBJcAAUgtPgMGQAlLP9cgYjnnBrvEzWtr238sOa8Ec9AFzGMhgFgAKmuLAAHgZqOFxgAFAbQOZGHoAGjgNFQ8WWw16GMotD6Ay+Ix6xySLlmswA5HBAGWE1MAJkS0y78ahIEBsMBIVgfEn3H4bZpbFKifRwFhSLmBOCLCbUczhT73UbwZ5zQ6apDimB0v6AvDAsHXADaxLu3xmPQAunB/gBeOAAASxOPuOG1ut6cBgEDdWFx4X4mpuAuGdIA3gCgSDQQBfODmlVW+C244jcI0wE9a6AwDARBSc5cMSMWYdAOREtLg5ftTr9hItpM9KcztP4qjJraFTRFPW2S2yBzg03V6wqVRgogGcCKMyOAA1DcbwXAAO6oQz1OC9Zdx3g703K8PhH457vWm0HkczHNwQBJhHAF8LLBBDEw9r6IKNpEgb/AbAmZIXHkT9nl4RZ6EYPlIwXe1YzBRNATKFhnDUI453gBdriOSk1HGRl2HJR9sPXTcBmvHcmDfOtZy0HBR34FAYFiLBxGkU1qJYO1MIYrReGY1j2KTSCGGYbi6JgFsTx7ZoRTKOgWMnGokhqUdxhIYAADdVCA49LQea0FRGP88NAoQZDvEjeFDXiQAAayjJcEITOBoz3RDjlQc8ZOtHDaCsp880kp8614SNr3JR1emvfTSR+WjUGvUdaNoXh434OSQswEBllmAddiUUMABlQDy2CPNc00TAgYhNIcdB1B5PkFztI5xkBTCguOSF4NIwFEUIMKd0AACI4AAVTgQAIIjgQBWDcAXZ24EhDFCyOcJAACCeCiJLOAxrWracFzUtNpZEZH3GEYZvGhoGhadoug6OBipYEAQEA54sosbEoF5IJgAALxQT9hywFhFhIEchBerIyF4aU3shs4Ya8TV9Q6jQZn6mQ4EAAyI4EAUCI4EAFMI4ELMgMXMGaOqdLBYZ3KA1yTQAEwkR6GLi8YAkiSLxpi8NnydZ84yBR+Yrxu3t7u6GgoPE1Z1l4LK8E3NU4GHaZgBIVAsAgadUAgCA4VVw4/0gRZ4F6o5kS3EZabgQBwomuYBxj/OLVU8fhnVNAowFoK9ROg6RERYK3gh+dRRCwZ6kl+ODKuCoOQ+OBLSI3Ldrz9YqAFFaMjKRaLwiaGQpKlIiL0vADCiCbLgyncM7wHOJWigvJsZXCS7LuBK8mqsABrC8ryJq+vKQvAGJJ0Fo2nKLlQIoG/a6dx3KFfpyFhR/mCeF9XrwWMYam4CnxeZ5Y+e4FLgB1CapFLyIpHP6fl/kGQI88HefroM+76vlhImH7xOe5iPQQ3g87RUPovM2c9C6/yPtRRSlRqhQGngMEEKBp47kgd+JKR8l6QhXklCCikA78gMj8HAok5way1jrKAesDZR3gBVFyiZqqEFqqQewPAmq8mkK1HqfVgpNkFDMSMk0AA+hcZoLSWomVOFFa4QATlAFEtFnThywBcEEOAwBImUYYJOmMcJKJRDgMOEcGHdTbmoSaDoAB8ki5qLUhGyHcXpG5OkABfkLhtIYm8VpLwXIQCAEvyWKrZJ50wgbPb8IxtyLzCNIDx4QcAAEY4CAEoiSUKSMRm0MAEl6swcAACZMmFJCbA8oSlEHTwAO0TDAGAdA5gclQC8LQF+GQpDRxqXUhpTTAi5LaVgV+sRNYwA9l7UAPs/ZEPEpJchilKGa21rrfW4QLFMKNHGFhNU6qcMas1XhbVeqAlIu1QEoi4ASMmlIpxiYSLBS6rHB0147KOWOEI1M8z6CLOoSs+h8xzbXDSjuTKIolbSB0QbScRswwGTVOMJ2ekwmPDXMsVAvplaJwGNYbImpFh4lNoEVFaReCe29r7QhMs+RZy+TAQa4RoWRkAI3AcBABNwPBTZnlTRZzgEyu03Ls6srtICHlRwWUAHW2XXDkbE0BToC5HCQBiLA1xW4KqQDSZVNJVVARZBquAVYsA1gPtq/g/tZnGMMLS+ljKWXssqiwy1Rg+VJidWy4VcA3VirgJK1l0ryKxIztnaKNLRI2vkOnCAxV67RVzvAJuVJRBFysXALSRck0sjTb3VNxrRBDx3CPMeE8wERIwVEuAohp5wInIguAAAeAA3PYqA49h5r13h/Et09MEVpzYzcULA01aSkGuKtFSEF+iQUfWpj94Ajw7eMUQKTU3LrXMugdWll3DpYGu5J3TZ3bwXRWopK7ilruKRuk927z1/w5lzLwQCIAgOkF2o+Pak1aWnt7M1My+QfNPPRMNc8GVPz+HAYNLkzT/oSumZMvl4CZw9dB+c5JJWZ39WnBRbropOutcBycsV5g6nce8i8Uk3F6nxCQ+K9EKN0nQ6Ek84Tu3lo/cghwshxjIfI62OkS7UmbtSaitAcAPFJGSRicTUgymLygBxxI3HpIGT41ek9wn0VicKZJwp0np7xIpBJ5IhSXGLwPQAQVhPMk+xwLNJJ7VJlgy6kg6cc8knCtmrNQIcye5zUgilslJRMwo0yqXSF4kBqFT8NkrkTNGcDHKYteSitR4RaYcKoAg9x8D/k7xoYfN1TqmNhpzIcvqRTEWQNpmyzIdknJuQ8MkrwFQahMIvjM1+Uw9VHC0AOXKcYeBilHAABI6loOEaAXNHZc0lDpKA5g4GzZIKoeAKV5RwWxM7CtSwACOohpA5Tys8NAwcBggF9IUu93NRxeG8btteB3GGx2YUmHZHCGrcJasK68A2Pu8OJrtY46NHk4V6uYE5O0jilVyvAcYvUqxQ7yuMK4+XepOjBzTUtcBq2VMnd02g0A5vdJ7dgnBDMkwwEKb9y7V4cFwE2JQQ4cFEXALgCNsI42W1JAxMdtQx2ZxQidubXGcA+mhTaUwdFaAUDJBqIwcw6slk0LoYbSakwz7oKPsOXqavzADB63cbSUpzDHfMCAMI8BQY3FoAAKwgGbHAcBz7SAWFAegMgJCYFoOivKqkjDNZvFQ5ZtDVnAtpzuNXPOZ5wCW9MH6E9ni09pl4OBu9IbeGxGEDXcJJmuqQP0YlElpfAK8Bn0PR8wBhFQDzFgEMi9PpL6NjXcmbCJGL6X9caLRPLUlNtmTR9m+cZ7x3kTHiBaQmmNtgWbfRt98XtiHSaeG9hHgmNa5blxEOOkZCeMGIxqlxmhcq501HEi536Tfh4OMS9Suuks+zGw/HygZNcaPNUCGxvq/uEGvXHewmPAF/1Ab+ZeOC2e4Af+Z8n+wB/ejMpogSkB1O4BABQB3+cAZOsBL08BACdo0ukQkBKBA+iQSBhs6mom40mqE0NIgy40GIZBzWV+iwZBs+/e8m4wuBgBxBneHikQ5B3BgykQGI3BdBIuiw3BTBc+SAC+0U0+y+ZBZ8dItBIIagghihS0DBdIZAIhNI+BMByoNudugQl2HM/SLSLA22fMQsGILMc4GIpw/MIsSQNI2B8AaATs+BLBGKiKJBHi/0GI/0ahohKB+m/0KB8+L6FBt+3BnchcGSpcr6D+koeCT8zSrS7S/8xhFBVBchfBKBSA9SjSHhUBi8NgbS5wewGumwTu+UCw0wQEKUEAs2GK0gjwRwW+1wkqLRi0yOa0YStsdscAhKMABe1wts1u5u/R9g9k4MCoko0oy2KBUex2x8hgsg5k+wxsio/ReefuhwCuvyweBs4wWuxkIuqB3IBuOk+RRwG49g6KPAa4SAZAhRpmkIgu4wtsAARNIbQO8dcAnjglIPAFAOchvmvlvomJKofpvp0XcqFAmuhB4tQRNEYUEnAGiFwQIciTqpzHAN5OfkcMckFFfsfpNDEY0WoFYMUXsjgBLvrLIDiTMXSZCBrgCdjIVlhLRBVtCn8GRrSj8kHsrhYs4qRvBryWDIrn8msgCiLtcFOjghUdIKERitLi4eMClAtoYEtm8U+pLt+NrrCCcaDA4PpppDpGoHLgHuKfsSMJNFrhiGuLEmHg4LzkgPZNIEcIiQAJrXBq7YnukYhenGpHDnyACBBBiOfIAEEEO0ketAQZoZjukZx+IZt+EZxwtseKg4wMhwixo4JmYeauSZXcGI+O640gEAGieevO2IMOsZYZCZN+gE9x/SSSTgNQTSzsHIdUOscsGuiptAD28ECOMOS0BqT0ZUQ56OB8mO5S8CyksptOtSoBYASYg5NO8RPaz+eB8RFadJRwCJNBkBQSGIXiSwWkviJ5eSwSuZYePal8I898W5i5SYvs4B958Rv+XsTh28r5D+j5XsGIUAq5D+aByo3MkA4wJw9e7e58y60FySJ60FxSCF/mdoWUNJEAdJToMZIZtZV5tOip0UFJtgVJaFsgrSIITAxwXxjuMFKS8FdFhS/m8xPSlxgyr8R6XgX5KS1wKpTFuRvSSxLSrFHSAKKBC575K5TFPaH+7BTxcSO5x5PiW22kF5h5om/BEBMlQSuFOCN5X5TFv5z50u35Ye75hlc6a8xltOBl/5gFYewFnMXgYFlFkFo21FqSsF9F1FDFxmtleFEhL6TohFdgDU1JdCpF+uFFEF6erlsFblnlSFxmvFeR5g7UqRb8e8cAHFd5/mBRSV/FyRQl3gIyqAYytOB64+phKV6KsOJxfZY5lwQAA\">this code</a> that works perfectly fine when I substitute every <code>Type*</code> by <code>Type</code>?</p>",
        "id": 468780109,
        "sender_full_name": "Esteban Martínez Vañó",
        "timestamp": 1725885059
    },
    {
        "content": "<p>the issue is that <code>s</code> is in the wrong universe. you can fix this by either adapting the construction you're using, or make <code>Net</code> have only one universe parameter (i.e. saying that <code>X</code> lives in the same universe as <code>Net.D</code>)</p>",
        "id": 468783310,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1725885639
    },
    {
        "content": "<p>as a third alternative, you can restrict your statement to <code>∀ (s : Net.{u_1,u_1} X)</code></p>",
        "id": 468785883,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1725886134
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\"> Definition of net -/</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Net</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">D</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">directedSet</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DirectedSet</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">net</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">X</span>\n</code></pre></div>\n<p>This is probably a bad definition in the sense that there are universes mentioned in the data of the definition which aren't mentioned in the statement. In situations like this I would do <code>universe u</code> and <code>(X : Type u)</code> and then <code>D : Type u</code> as well. For example the truth of some statements about nets might depend on the universe type chosen for D, and you don't really want that (you won't see the universe in the statement of the theorem, in fact you'll probably get an error that Lean can't figure out which universe you're talking about).</p>",
        "id": 468789041,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1725886635
    },
    {
        "content": "<p>Understood. Thanks!</p>\n<p>So, for example, when stating that a sequence is a net, which I've done like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Every linear order is a directed set</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">LinearOrder</span><span class=\"bp\">.</span><span class=\"n\">instDirectedSet</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearOrder</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Inhabited</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DirectedSet</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">directed</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"n\">e</span>\n<span class=\"w\">    </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"n\">e</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">And</span><span class=\"bp\">.</span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">le_max_left</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">le_max_right</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- ℕ (with its usual order relation) is a directed set and so every sequence is a net</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simps</span><span class=\"kd\">]</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">Net</span><span class=\"bp\">.</span><span class=\"n\">instSequences</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Net</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Net</span><span class=\"bp\">.</span><span class=\"n\">mk'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">inferInstance</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">s</span>\n</code></pre></div>\n<p>I must state that <code>X</code> has type <code>Type</code>, and not use <code>Type*</code>, because ℕ has type <code>Type</code>, isn't it?</p>",
        "id": 468792371,
        "sender_full_name": "Esteban Martínez Vañó",
        "timestamp": 1725887155
    },
    {
        "content": "<p>no. the issue is that <code>Net</code> depends on two universe parameters, while only one gets mentioned when you use it as a type.</p>",
        "id": 468793117,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1725887302
    },
    {
        "content": "<p>Sorry, I mean after changing the definition of <code>Net</code> as you and Kevin mentioned by making it depending on only one universe</p>",
        "id": 468793433,
        "sender_full_name": "Esteban Martínez Vañó",
        "timestamp": 1725887372
    },
    {
        "content": "<p><del>after that, you likely shouldn't need to change <code>X</code> to be <code>Type</code>.</del> <br>\nindeed.</p>",
        "id": 468793735,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1725887434
    },
    {
        "content": "<p>You can be explicit with universes too. I'm not necessarily recommending this here, but just so you know, this is possible:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Net</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">directedSet</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DirectedSet</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">net</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">X</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">Net</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"c1\">-- The second `0` is inferred from `Nat`, so you can do this for short:</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">Net</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n</code></pre></div>\n<p>Notice I put <code>v</code> first in <code>Net</code>'s universe level list to make the second <code>#check</code> possible to write.</p>",
        "id": 468872639,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1725903926
    }
]