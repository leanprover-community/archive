[
    {
        "content": "<p>On the face of it, the question in the title may sound stupid, but let me explain why I think it's not. Whether or not it's stupid, I'd like to know the answer.</p>\n<p>By bicategory stuff, I'm thinking in particular about this cleverly designed <code>CategoryTheory.bicategoricalComp</code> and <code>CategoryTheory.bicategoricalIsoComp</code> operations defined <a href=\"https://github.com/leanprover-community/mathlib4/blob/7deb334c5f5104f4edad1a6396dd02a8cddefb86/Mathlib/Tactic/CategoryTheory/BicategoricalComp.lean#L50-L54\">here</a> that <span class=\"user-mention\" data-user-id=\"438192\">@Yuma Mizuno</span> defined for 2-cells or invertible 2-cells:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">bicategoricalComp</span><span class=\"o\">{</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Bicategory</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span>\n<span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">âŸ¶</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BicategoricalCoherence</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">Î·</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">âŸ¶</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Î¸</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">âŸ¶</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">âŸ¶</span><span class=\"w\"> </span><span class=\"n\">i</span>\n</code></pre></div>\n<p>It applies in a setting where you have a pair of 2-cells Î· and Î¸ that are morally composable but not actually composable, since the codomain g of Î· is related to the domain h of Î¸ by a bicategorical coherence (something built out of associators and unitors) but these are not actually equal.</p>\n<p>Note you can apply this in the context of any bicategory and we have <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/Category/Cat.html#CategoryTheory.Cat.bicategory\">CategoryTheory.Cat.bicategory</a> giving a bicategory instance on Cat, so surely we can apply this to categories, functors, and natural transformations?</p>\n<p>I was thinking of this question when <span class=\"user-mention\" data-user-id=\"318709\">@Sophie Morel</span> showed us some of the formalizations she's done such as the definition of <a href=\"https://github.com/smorel394/Appendix/blob/3c02ebdcad32e4c2239b82251b6fec168e567e71/Appendix/Basic.lean#L433-L520\">DerivedFunctor_comp</a>. The annoying part of the proof is in constructing an explicit natural isomorphism (an invertible 2-cell in Cat) and I'm wondering if <code>bicategoricalIsoComp</code> can be used to avoid some of the named coherences?</p>\n<p>My guess is no not directly due to issues with </p>\n<p>(i) universes; technically the bicategory structure lives on <code>Cat.{v,u}</code> for fixed universes u and v<br>\n(ii) conflicting notation for functors and morphisms in Cat and natural transformations and 2-cells in Cat.</p>\n<p>We described this sort of issue <a href=\"https://arxiv.org/abs/2503.20704\">in a recent preprint</a>. </p>\n<p>If this can't be done now, could it conceivably be in the future? If it can, please teach me (and <span class=\"user-mention\" data-user-id=\"318709\">@Sophie Morel</span>) how to simplify proofs like this.</p>",
        "id": 523960218,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1749825734
    },
    {
        "content": "<p>Note that with categories and functors, all \"named coherences\" (i.e associators and unitors) are in fact <code>Iso.refl _</code>, so you <em>could</em> in fact just put <code>(Iso.refl : &lt;expected type&gt;)</code> everywhere, and itâ€™d \"just\" work, even worse, you could even skip them and for some compositions itâ€™d work... For this kind of things, this is a bit of a \"bug\", because Lean will actually accept <code>Functor.rightUnitor F</code> as an isomorphism <code>ğŸ­ _ â‹™ F â‰… F</code>! </p>\n<p>That being said, I had a go at simply copy-pasting the code in <code>BicategoricalCoherence</code>, replacing every instance of a 1-cell by a functor, and it \"just works\", you can play with it <a href=\"https://gist.github.com/robin-carlier/0dc4bf960b1ac4bf3bdc20ef6d0c03ad\">here</a>. At the end of the day, <span class=\"user-mention\" data-user-id=\"438192\">@Yuma Mizuno</span>'s  code for bicategorical (and monoidal) composition does not rely on any \"coherence\" tactics, but rather on a clever use of the type class system, letting lean infer that the two sides of the compositions \"are related by a coherence 2-cell\".<br>\nBut again, every single iso appearing here is <code>Iso.refl _</code>, and all <code>âŠ—â‰«</code> is doing in the link I gave is inserting some identities that are \"well-typed\" to help lean.</p>",
        "id": 523976912,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1749831761
    },
    {
        "content": "<p>By the way, the code for <code>âŠ—â‰«</code>, which was originally written for monoidal categories, should be credited to <span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span> , not me.</p>",
        "id": 523978238,
        "sender_full_name": "Yuma Mizuno",
        "timestamp": 1749832265
    },
    {
        "content": "<p>6 messages were moved from this topic to <a href=\"#narrow/channel/287929-mathlib4/topic/Functor.20identity.20.60.F0.9D.9F.AD.20_.20.E2.8B.99.20F.20.3D.20F.60.20is.20definitional.20equality\">#mathlib4 &gt; Functor identity &#96;ğŸ­ _ â‹™ F = F&#96; is definitional equality</a> by <span class=\"user-mention silent\" data-user-id=\"438192\">Yuma Mizuno</span>.</p>",
        "id": 523982241,
        "sender_full_name": "Notification Bot",
        "timestamp": 1749833889
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246635\">Emily Riehl</span> <a href=\"#narrow/channel/287929-mathlib4/topic/can.20bicategory.20infrastructure.20be.20applied.20to.20Cat.3F/near/523960218\">said</a>:</p>\n<blockquote>\n<p>On the face of it, the question in the title may sound stupid, but let me explain why I think it's not. Whether or not it's stupid, I'd like to know the answer.</p>\n</blockquote>\n<p>The tactic <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.to_app#doc\">docs#CategoryTheory.to_app</a> by <span class=\"user-mention\" data-user-id=\"132603\">@Calle SÃ¶nne</span> is a tool that applies bicategory infrastructure to <code>Cat</code>. It provides equalities in <code>Cat</code> after <code>app</code>lying natural transformations to objects.</p>",
        "id": 523982449,
        "sender_full_name": "Yuma Mizuno",
        "timestamp": 1749833970
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/blob/d227035ea8b46e1d28ee90e5198f2aa080611b6b/MathlibTest/CategoryTheory/ToApp.lean#L17\">example</a></p>",
        "id": 523983205,
        "sender_full_name": "Yuma Mizuno",
        "timestamp": 1749834215
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246635\">Emily Riehl</span> <a href=\"#narrow/channel/287929-mathlib4/topic/can.20bicategory.20infrastructure.20be.20applied.20to.20Cat.3F/near/523960218\">said</a>:</p>\n<blockquote>\n<p>(i) universes; technically the bicategory structure lives on <code>Cat.{v,u}</code> for fixed universes u and v<br>\n(ii) conflicting notation for functors and morphisms in Cat and natural transformations and 2-cells in Cat.</p>\n</blockquote>\n<p>There are two possible formulation for declaring <code>C</code> and <code>D</code> are categories:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v2</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>and</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Cat</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">})</span>\n</code></pre></div>\n<p>The <code>to_app</code> is for the latter setting, so doesn't address these points.</p>",
        "id": 523984039,
        "sender_full_name": "Yuma Mizuno",
        "timestamp": 1749834573
    },
    {
        "content": "<p>When we working on the latter (<code>Cat</code>) setting, we can use bicategory structure at any time. So the tool we would like to have is one generating the lemma or definition like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">leftUnitor</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">uâ‚</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">vâ‚</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">uâ‚‚</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">vâ‚‚</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">â¥¤</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">Â  Â  </span><span class=\"mi\">ğŸ­</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">â‹™</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">â‰…</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">Â  </span><span class=\"bp\">_</span>\n</code></pre></div>\n<p>from </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">leftUnitor</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Cat</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">âŸ¶</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">Â  Â  </span><span class=\"mi\">ğŸ™</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">â‰«</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">â‰…</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">Â  </span><span class=\"bp\">_</span>\n</code></pre></div>\n<p>I'm not sure we can have such a tool.</p>",
        "id": 524001527,
        "sender_full_name": "Yuma Mizuno",
        "timestamp": 1749842144
    },
    {
        "content": "<p>We saw a great demonstration of an autogeneralizing tool today during Tim Gowers's talk, but it was only generalizing variables. I don't know if it could theoretically generalize universe levels.<br>\nMore realistically, I'll have a look at the code Robin posted when I'm not in a crowded train.</p>",
        "id": 524002125,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1749842461
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"286014\">Robin Carlier</span> <a href=\"#narrow/channel/287929-mathlib4/topic/can.20bicategory.20infrastructure.20be.20applied.20to.20Cat.3F/near/523976912\">said</a>:</p>\n<blockquote>\n<p>That being said, I had a go at simply copy-pasting the code in <code>BicategoricalCoherence</code>, replacing every instance of a 1-cell by a functor, and it \"just works\", you can play with it <a href=\"https://gist.github.com/robin-carlier/0dc4bf960b1ac4bf3bdc20ef6d0c03ad\">here</a>.</p>\n</blockquote>\n<p>Is there a way make a tactic which, given a goal like <code>Fâ‚ â‹™ (Fâ‚‚ â‹™ Fâ‚ƒ) â‹™ Fâ‚„ â‹™ ğŸ­ _ â‰… Fâ‚ â‹™ ğŸ­ _ â‹™ Fâ‚‚ â‹™ Fâ‚ƒ â‹™ Fâ‚„</code> would produce the <code>dsimp</code>ed expansion of this <code>âŠ—ğŸ­</code>? (which is <code>isoWhiskerLeft Fâ‚ (Fâ‚‚.associator Fâ‚ƒ (Fâ‚„ â‹™ ğŸ­ Câ‚…)) â‰ªâ‰« (Iso.refl (Fâ‚ â‹™ Fâ‚‚ â‹™ Fâ‚ƒ â‹™ Fâ‚„ â‹™ ğŸ­ Câ‚…) â‰ªâ‰« isoWhiskerLeft Fâ‚ (isoWhiskerLeft Fâ‚‚ (isoWhiskerLeft Fâ‚ƒ Fâ‚„.rightUnitor))) â‰ªâ‰« isoWhiskerLeft Fâ‚ (Fâ‚‚ â‹™ Fâ‚ƒ â‹™ Fâ‚„).leftUnitor.symm</code>)<br>\nEven though there is an unnecessary <code>Iso.refl _</code> in this particular case, it seems that this is what would have been helpful for <span class=\"user-mention\" data-user-id=\"318709\">@Sophie Morel</span>.</p>\n<p>For reasons related to <a href=\"#narrow/channel/287929-mathlib4/topic/Functor.20identity.20.60.F0.9D.9F.AD.20_.20.E2.8B.99.20F.20.3D.20F.60.20is.20definitional.20equality/near/523980180\">#mathlib4 &gt; Functor identity &#96;ğŸ­ _ â‹™ F = F&#96; is definitional equality @ ğŸ’¬</a>, I do not think that a bare <code>âŠ—ğŸ­</code> should appear in polished code (and there is the general argument that we should not construct data using tactics), but using some related metacode as I suggest above could be helpful when constructing terms.</p>",
        "id": 524002315,
        "sender_full_name": "JoÃ«l Riou",
        "timestamp": 1749842580
    },
    {
        "content": "<p>I can look at feasability of something like this, but I have a few things on my plate already so donâ€™t expect it super soon.</p>\n<p>What I have in mind would be an elaborator: you write something like <code>âŠ—ğŸ­</code>,  but it elaborates as \"the right morphism in this context\", and so you can freely use it in constructions because at the end itâ€™s \"just a macro\" an the terms constructed are tactic-free. Then, <code>âŠ—â‰«</code> would be a macro for <code>â‰« âŠ—ğŸ­.hom â‰«</code>.</p>\n<p>This is bound to be \"more complicated\" than the typeclass inference method, because the way I can see it working would involve looking at the expected types of the LHS/RHS of the <code>âŠ—ğŸ­</code>, check theyâ€™re indeed \"the same up to coherences\" by matching at the <code>Expr</code> level, and then build inductively the morphism.</p>\n<p>Iâ€™ll admit that Iâ€™m still a beginner at metaprogramming, so not sure if I can come up with something nice, but I can try and that could be a fun project.</p>",
        "id": 524004690,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1749843801
    },
    {
        "content": "<p>Actually, I am not sure it is necessary to do this! If we use <code>âŠ—ğŸ­</code> to create an isomorphism and we want to prove for example that it is compatible with shifts, we may just do <code>dsimp</code> which will expand <code>âŠ—ğŸ­</code> as a combination of associators, unitors, compositions, whiskering, and then <code>infer_instance</code> should work...</p>",
        "id": 524006664,
        "sender_full_name": "JoÃ«l Riou",
        "timestamp": 1749844781
    },
    {
        "content": "<p>I think it would be useful to have metacode that generates more optimized expressions than the current ones, in the sense that they do not contain <code>Iso.refl</code>s.</p>",
        "id": 524009188,
        "sender_full_name": "Yuma Mizuno",
        "timestamp": 1749846121
    },
    {
        "content": "<p>At the same time, I personally think that coherence isomorphisms (associators, ...) are \"irrelevant\", and I'm therefore willing to generate them by a tactic.</p>",
        "id": 524009231,
        "sender_full_name": "Yuma Mizuno",
        "timestamp": 1749846144
    },
    {
        "content": "<p>I wrote the <code>assoc%</code> term elaborator, which inserts appropriate associators: <a href=\"https://github.com/leanprover-community/mathlib4/pull/26920\">#26920</a>. Manual inserting is not as easy as it might seem (as it can pass type checking even if it is not correct), so I believe <code>assoc%</code> is useful.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Associators</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span>\n\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">vâ‚</span><span class=\"w\"> </span><span class=\"n\">vâ‚‚</span><span class=\"w\"> </span><span class=\"n\">vâ‚ƒ</span><span class=\"w\"> </span><span class=\"n\">vâ‚„</span><span class=\"w\"> </span><span class=\"n\">vâ‚…</span><span class=\"w\"> </span><span class=\"n\">uâ‚</span><span class=\"w\"> </span><span class=\"n\">uâ‚‚</span><span class=\"w\"> </span><span class=\"n\">uâ‚ƒ</span><span class=\"w\"> </span><span class=\"n\">uâ‚„</span><span class=\"w\"> </span><span class=\"n\">uâ‚…</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">uâ‚</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">vâ‚</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">uâ‚‚</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">vâ‚‚</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">uâ‚ƒ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">vâ‚ƒ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">uâ‚„</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">vâ‚„</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">]</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">uâ‚…</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">vâ‚…</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">â¥¤</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">â¥¤</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">â¥¤</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"bp\">â¥¤</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Functor</span>\n\n<span class=\"kn\">local</span><span class=\"w\"> </span><span class=\"kn\">infixr</span><span class=\"o\">:</span><span class=\"mi\">81</span><span class=\"w\"> </span><span class=\"s2\">\" â— \"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">whiskerLeft</span>\n<span class=\"kn\">local</span><span class=\"w\"> </span><span class=\"kn\">infixl</span><span class=\"o\">:</span><span class=\"mi\">81</span><span class=\"w\"> </span><span class=\"s2\">\" â–· \"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">whiskerRight</span>\n<span class=\"kn\">local</span><span class=\"w\"> </span><span class=\"kn\">notation</span><span class=\"w\"> </span><span class=\"s2\">\"Î±_\"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">associator</span>\n<span class=\"kn\">local</span><span class=\"w\"> </span><span class=\"kn\">notation</span><span class=\"w\"> </span><span class=\"s2\">\"Î»_\"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">leftUnitor</span>\n<span class=\"kn\">local</span><span class=\"w\"> </span><span class=\"kn\">notation</span><span class=\"w\"> </span><span class=\"s2\">\"Ï_\"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">rightUnitor</span>\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">Try this: (Î±_ F G H).hom</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">â‹™</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">â‹™</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"bp\">âŸ¶</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">â‹™</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">â‹™</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">assoc</span><span class=\"bp\">%</span>\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">Try this: (Î±_ F G H).inv</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">â‹™</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">â‹™</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">âŸ¶</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">â‹™</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">â‹™</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">assoc</span><span class=\"bp\">%</span>\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">Try this: F â— (Î±_ G H I).hom â‰« (Î±_ F G (H â‹™ I)).inv</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">â‹™</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">â‹™</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">â‹™</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"bp\">âŸ¶</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">â‹™</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">â‹™</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"bp\">â‹™</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">assoc</span><span class=\"bp\">%</span>\n</code></pre></div>",
        "id": 527823872,
        "sender_full_name": "Yuma Mizuno",
        "timestamp": 1752046276
    },
    {
        "content": "<p>I would be grateful for feedback from anyone who is interested.</p>",
        "id": 527823893,
        "sender_full_name": "Yuma Mizuno",
        "timestamp": 1752046284
    }
]