[
    {
        "content": "<p>For <code>linter claims that LHS doesn't simplify, but it does</code>, it seems that the <code>simpNF</code> linter runs <code>simp</code> instead of <code>simp [*]</code>, which is why <code>simpNF</code> can't simplify the LHS. Should this be changed?</p>",
        "id": 514787769,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745839546
    },
    {
        "content": "<p>That sounds good to me</p>",
        "id": 514796379,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1745842007
    },
    {
        "content": "<p>Would a patch like this make sense?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">diff</span><span class=\"w\"> </span><span class=\"c1\">--git a/Batteries/Tactic/Lint/Simp.lean b/Batteries/Tactic/Lint/Simp.lean</span>\n<span class=\"n\">index</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"n\">e83431d</span><span class=\"bp\">..</span><span class=\"n\">ce585f5d</span><span class=\"w\"> </span><span class=\"mi\">100644</span>\n<span class=\"c1\">--- a/Batteries/Tactic/Lint/Simp.lean</span>\n<span class=\"bp\">+++</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">/</span><span class=\"n\">Batteries</span><span class=\"bp\">/</span><span class=\"n\">Tactic</span><span class=\"bp\">/</span><span class=\"n\">Lint</span><span class=\"bp\">/</span><span class=\"n\">Simp</span><span class=\"bp\">.</span><span class=\"n\">lean</span>\n<span class=\"bp\">@@</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"mi\">109</span><span class=\"o\">,</span><span class=\"mi\">12</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"mi\">109</span><span class=\"o\">,</span><span class=\"mi\">18</span><span class=\"w\"> </span><span class=\"bp\">@@</span><span class=\"w\"> </span><span class=\"n\">https</span><span class=\"o\">:</span><span class=\"bp\">//</span><span class=\"n\">leanprover</span><span class=\"bp\">-</span><span class=\"n\">community</span><span class=\"bp\">.</span><span class=\"n\">github</span><span class=\"bp\">.</span><span class=\"n\">io</span><span class=\"bp\">/</span><span class=\"n\">mathlib_docs</span><span class=\"bp\">/</span><span class=\"n\">notes</span><span class=\"bp\">.</span><span class=\"n\">html</span><span class=\"bp\">#</span><span class=\"n\">simp</span><span class=\"bp\">-</span><span class=\"n\">normal</span><span class=\"bp\">%</span><span class=\"mi\">20</span><span class=\"n\">for</span>\n<span class=\"w\">   </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">declName</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">     </span><span class=\"n\">unless</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">isSimpTheorem</span><span class=\"w\"> </span><span class=\"n\">declName</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"w\">     </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Simp</span><span class=\"bp\">.</span><span class=\"n\">Context</span><span class=\"bp\">.</span><span class=\"n\">mkDefault</span>\n<span class=\"bp\">-</span><span class=\"w\">    </span><span class=\"n\">checkAllSimpTheoremInfos</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getConstInfo</span><span class=\"w\"> </span><span class=\"n\">declName</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">lhs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rhs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">isConditional</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">..</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"bp\">+</span><span class=\"w\">    </span><span class=\"n\">checkAllSimpTheoremInfos</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getConstInfo</span><span class=\"w\"> </span><span class=\"n\">declName</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">type</span>\n<span class=\"bp\">+</span><span class=\"w\">      </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">lhs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rhs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">isConditional</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hyps</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">..</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"bp\">+</span><span class=\"w\">      </span><span class=\"c1\">-- add the local hypotheses to the simp context</span>\n<span class=\"bp\">+</span><span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">simpTheorems</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"bp\">.</span><span class=\"n\">simpTheorems</span>\n<span class=\"bp\">+</span><span class=\"w\">      </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">hyps</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"bp\">+</span><span class=\"w\">        </span><span class=\"n\">simpTheorems</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">simpTheorems</span><span class=\"bp\">.</span><span class=\"n\">addTheorem</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">fvar</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">fvarId!</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"bp\">+</span><span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">ctxHyps</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"bp\">.</span><span class=\"n\">setSimpTheorems</span><span class=\"w\"> </span><span class=\"n\">simpTheorems</span>\n<span class=\"w\">       </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">isRfl</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">isRflTheorem</span><span class=\"w\"> </span><span class=\"n\">declName</span>\n<span class=\"w\">       </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"o\">({</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">lhs'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">proof?</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">prf1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">..</span><span class=\"w\"> </span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">prf1Stats</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">←</span>\n<span class=\"w\">         </span><span class=\"n\">decorateError</span><span class=\"w\"> </span><span class=\"s2\">\"simplify fails on left-hand side:\"</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span>\n<span class=\"w\">           </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"bp\">!</span><span class=\"n\">isRfl</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"bp\">-</span><span class=\"w\">            </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">lhs</span><span class=\"w\"> </span><span class=\"n\">ctx</span>\n<span class=\"bp\">+</span><span class=\"w\">            </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">lhs</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"w\"> </span><span class=\"bp\">&lt;|&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">lhs</span><span class=\"w\"> </span><span class=\"n\">ctxHyps</span>\n<span class=\"w\">           </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">             </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">dsimp</span><span class=\"w\"> </span><span class=\"n\">lhs</span><span class=\"w\"> </span><span class=\"n\">ctx</span>\n<span class=\"w\">             </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Simp</span><span class=\"bp\">.</span><span class=\"n\">Result</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">true</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 514835392,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1745851940
    },
    {
        "content": "<p>3 messages were moved here from <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/channel/287929-mathlib4/topic/Technical.20Debt.20Counters/with/443678155\">#mathlib4 &gt; Technical Debt Counters</a> by <span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span>.</p>",
        "id": 514835468,
        "sender_full_name": "Notification Bot",
        "timestamp": 1745851963
    },
    {
        "content": "<p>Why wouldn't we just overwrite <code>ctx</code> with the extended context?</p>",
        "id": 514838552,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745852785
    },
    {
        "content": "<p>Maybe there is value in checking if something can be simped unconditionally?</p>",
        "id": 514839668,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1745853066
    },
    {
        "content": "<p>But maybe we actually don't care.</p>",
        "id": 514839733,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1745853082
    },
    {
        "content": "<p>You might want to add an <code>isProp</code> check (to the free variable type) before <code>simpTheorems.addTheorem</code>. <code>hyps</code> contains all of the free variables. (I think you'll get an error otherwise)</p>",
        "id": 514841042,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745853432
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/batteries/pull/1214\">https://github.com/leanprover-community/batteries/pull/1214</a> contains my attempt.</p>",
        "id": 514841738,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1745853617
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/channel/287929-mathlib4/topic/simpNF.20lint.20with.20hyps/near/514841042\">said</a>:</p>\n<blockquote>\n<p>You might want to add an <code>isProp</code> check (to the free variable type) before <code>simpTheorems.addTheorem</code>. <code>hyps</code> contains all of the free variables. (I think you'll get an error otherwise)</p>\n</blockquote>\n<p>Good idea. Pushed that to the PR.</p>",
        "id": 514842007,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1745853702
    },
    {
        "content": "<p>I'm removing 3 <code>@[simp]</code> attributes that are now flagged by the linter.</p>\n<p>I tested, and indeed, these lemmas do not fire on their own LHS, even with <code>simp [*]</code>.</p>\n<p><a href=\"https://github.com/leanprover-community/batteries/pull/1214/commits/8e47a2ac82ea7d0ccaaa2dbb5eaf1c516c491999\">https://github.com/leanprover-community/batteries/pull/1214/commits/8e47a2ac82ea7d0ccaaa2dbb5eaf1c516c491999</a></p>",
        "id": 514854779,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1745857058
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"479299\">@Jovan Gerbscheid</span> I've tested this out on mathlib, and we get 184 new linter warnings.<br>\nFor example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- The product of `f` over `insert a s` is the same as</span>\n<span class=\"sd\">the product over `s`, as long as `f a = 1`. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">to_additive</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">attr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"s2\">\"The sum of `f` over `insert a s` is the same as</span>\n<span class=\"s2\">the sum over `s`, as long as `f a = 0`.\"</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">prod_insert_one</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∏</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">insert</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">∏</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">prod_insert_of_eq_one_if_not_mem</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">h</span>\n\n<span class=\"c1\">-- Indeed, this lemma can be proven using `simp [*]` but not by `simp`.</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">prod_insert_one'</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∏</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">insert</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">∏</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 514862929,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1745859626
    },
    {
        "content": "<p>So, I guess a general question for people to chime in on: do we want lemmas like <code>prod_insert_one</code> in our simp set, if <code>simp [*]</code> can already prove them...</p>",
        "id": 514863080,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1745859675
    },
    {
        "content": "<p>Isn't this lemma overshadowed by <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.prod_insert_of_eq_one_if_not_mem#doc\">docs#Finset.prod_insert_of_eq_one_if_not_mem</a> ? I seems like it should clearly not have a @[simp] tag.</p>",
        "id": 514867283,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745860972
    },
    {
        "content": "<p>Indeed, that is exactly what the linter now reports:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">././././</span><span class=\"n\">Mathlib</span><span class=\"bp\">/</span><span class=\"n\">Algebra</span><span class=\"bp\">/</span><span class=\"n\">BigOperators</span><span class=\"bp\">/</span><span class=\"n\">Group</span><span class=\"bp\">/</span><span class=\"n\">Finset</span><span class=\"bp\">/</span><span class=\"n\">Basic</span><span class=\"bp\">.</span><span class=\"n\">lean</span><span class=\"o\">:</span><span class=\"mi\">51</span><span class=\"o\">:</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">error</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">prod_insert_one</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">can</span><span class=\"w\"> </span><span class=\"n\">prove</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">implies_true</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">prod_insert_of_eq_one_if_not_mem</span><span class=\"o\">]</span>\n<span class=\"n\">One</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">lemmas</span><span class=\"w\"> </span><span class=\"n\">above</span><span class=\"w\"> </span><span class=\"n\">could</span><span class=\"w\"> </span><span class=\"n\">be</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">duplicate</span><span class=\"bp\">.</span>\n<span class=\"n\">If</span><span class=\"w\"> </span><span class=\"n\">that's</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">try</span><span class=\"w\"> </span><span class=\"n\">reordering</span><span class=\"w\"> </span><span class=\"n\">lemmas</span><span class=\"w\"> </span><span class=\"n\">or</span><span class=\"w\"> </span><span class=\"n\">adding</span><span class=\"w\"> </span><span class=\"kd\">@[</span><span class=\"n\">priority</span><span class=\"kd\">]</span><span class=\"bp\">.</span>\n</code></pre></div>",
        "id": 514957105,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1745903671
    },
    {
        "content": "<p>For the record, here is the full linter output: <a href=\"https://github.com/leanprover-community/mathlib4/actions/runs/14712661498/job/41288687885#step:25:21\">https://github.com/leanprover-community/mathlib4/actions/runs/14712661498/job/41288687885#step:25:21</a></p>",
        "id": 514960990,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1745904487
    },
    {
        "content": "<p>I think many of the new warnings are valid warnings, however it mistakenly chokes on <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Equiv.Perm.support_subtype_perm#doc\">docs#Equiv.Perm.support_subtype_perm</a>, because it has a hypothesis <code>h : ∀ (x : α), x ∈ s ↔ f x ∈ s)</code>. And then <code>simp [h]</code> loops forever.</p>",
        "id": 515033258,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745925272
    },
    {
        "content": "<p>I think <code>simp</code> should have an option that determines whether local simp theorems that are equalities (or iff) are turned into rewriting simp theorem, or just theorems that simplify a statement into true. Then we can use it in <code>simpNF</code> to avoid these kinds of looping rewrites with hypotheses that weren't meant for rewriting.</p>",
        "id": 515045459,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745928747
    },
    {
        "content": "<p>I've pushed a whole bunch of fixes to <a href=\"https://github.com/leanprover-community/mathlib4/tree/batteries-pr-testing-1214\">branch#batteries-pr-testing-1214</a></p>",
        "id": 515054535,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1745931140
    },
    {
        "content": "<p>Many of those can be backported to master indep of this linter change.</p>",
        "id": 515054636,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1745931161
    },
    {
        "content": "<p>It seems that any \"higher order\" simp theorem gets flagged by the new linter, e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">monovaryOn_inv_left₀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MonovaryOn</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">⁻¹</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">AntivaryOn</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">s</span>\n</code></pre></div>\n<p>which has a hypothesis that has a hypothesis. It seems like this simp lemma should be able to apply to itself, but the problem is that <code>contextual</code> is set to false by default. This means that when simplifying <code>0 &lt; f i</code>, the discharger doesn't have access to the <code>i ∈ s</code> hypothesis that is needed to apply <code>hf</code>. It does get solved by <code>simp +contextual [*]</code>.</p>",
        "id": 515063653,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745933275
    },
    {
        "content": "<p>So... should the linter also try <code>+contextual</code>?<br>\nOr should we just not have such higher order simp lemmas in the default set?</p>",
        "id": 515064229,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1745933402
    },
    {
        "content": "<p>We could put the <code>@[simp]</code> tag on a simpler version of the theorem without the <code>i ∈ s</code> hypothesis. On the other hand, the extra hypothesis doesn't do any harm, and is beneficial if we have <code>+contextual</code>.</p>",
        "id": 515065112,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745933624
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/channel/287929-mathlib4/topic/simpNF.20lint.20with.20hyps/near/515064229\">said</a>:</p>\n<blockquote>\n<p>So... should the linter also try <code>+contextual</code>?</p>\n</blockquote>\n<p>I think that would be a reasonable workaround.</p>",
        "id": 515067342,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745934162
    },
    {
        "content": "<p>Interestingly, if we have a \"higher higher order\" simp theorem (having a hypothesis in a hypothesis in a hypothesis), then the linter will complain due to <code>maxDischargeDepth := 2</code> :)</p>",
        "id": 515067577,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745934228
    },
    {
        "content": "<p>Clearly we should draw a line somewhere. <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 515067798,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1745934277
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"479299\">@Jovan Gerbscheid</span> btw, please feel free to push to the batteries PR if you have some ideas</p>",
        "id": 515082522,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1745937591
    },
    {
        "content": "<p>I don't have write access for batteries. But the change I wanted to make is replacing</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Simp</span><span class=\"bp\">.</span><span class=\"n\">Context</span><span class=\"bp\">.</span><span class=\"n\">mkDefault</span>\n</code></pre></div>\n<p>with</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Simp</span><span class=\"bp\">.</span><span class=\"n\">mkContext</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">config</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">contextual</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"o\">})</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">simpTheorems</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getSimpTheorems</span><span class=\"o\">)])</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">congrTheorems</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getSimpCongrTheorems</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 515115125,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745945634
    },
    {
        "content": "<p>Thanks, I pushed that change.</p>",
        "id": 515127540,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1745949384
    },
    {
        "content": "<p>It looks like there are some further linting failures on <a href=\"https://github.com/leanprover-community/mathlib4/tree/batteries-pr-testing-1214\">branch#batteries-pr-testing-1214</a>.</p>",
        "id": 515159899,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1745961674
    },
    {
        "content": "<p>Ping me when when you'd like this merged.</p>",
        "id": 515159917,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1745961683
    },
    {
        "content": "<p>The awkward thing about setting <code>contextual</code> to <code>true</code>, is that a lemma like <code>not_imp_self : ¬a → a ↔ a</code> now gets solved by <code>simpNF</code> (because it introduces <code>¬a</code> to its context, thus simplifying <code>a</code> to <code>False</code>).</p>\n<p>As a workaround, we could only set <code>contextual</code> to true if we detect that the lemma is higher order.</p>",
        "id": 515165163,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745964141
    },
    {
        "content": "<p>I made a pr where I only use <code>+contextual</code> in <code>simpNF</code> when it might need it: <a href=\"https://github.com/leanprover-community/batteries/pull/1220\">https://github.com/leanprover-community/batteries/pull/1220</a></p>\n<p>But it seems the automatically generated mathlib branch isn't compatible.</p>",
        "id": 515683096,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1746181501
    },
    {
        "content": "<p>Thanks, that's a lot more sophisticated (-;</p>",
        "id": 515723585,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1746195116
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/channel/287929-mathlib4/topic/simpNF.20lint.20with.20hyps/near/515683096\">said</a>:</p>\n<blockquote>\n<p>But it seems the automatically generated mathlib branch isn't compatible.</p>\n</blockquote>\n<p>I fear that it is caught in limbo between the 4.19 and 4.20-rc{1,2} releases.</p>",
        "id": 515725927,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1746195717
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"479299\">@Jovan Gerbscheid</span> I pushed an update to <a href=\"https://github.com/leanprover-community/mathlib4/tree/batteries-pr-testing-1220\">branch#batteries-pr-testing-1220</a> that moves to v4.20-rc2</p>",
        "id": 515847823,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1746248438
    },
    {
        "content": "<p><del>Only 10 linter errors!</del> <a href=\"https://github.com/leanprover-community/mathlib4/actions/runs/14807683945\">https://github.com/leanprover-community/mathlib4/actions/runs/14807683945</a></p>",
        "id": 515852461,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1746251138
    },
    {
        "content": "<p>I got confused by Github. It's actually 165 errors <span aria-label=\"expressionless\" class=\"emoji emoji-1f611\" role=\"img\" title=\"expressionless\">:expressionless:</span></p>",
        "id": 515852664,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1746251270
    },
    {
        "content": "<p>There are still quite a few of the form</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Mathlib</span><span class=\"bp\">/</span><span class=\"n\">Topology</span><span class=\"bp\">/</span><span class=\"n\">VectorBundle</span><span class=\"bp\">/</span><span class=\"n\">Constructions</span><span class=\"bp\">.</span><span class=\"n\">lean</span><span class=\"o\">:</span><span class=\"mi\">83</span><span class=\"o\">:</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">error</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Trivialization</span><span class=\"bp\">.</span><span class=\"n\">coordChangeL_prod</span>\n<span class=\"n\">Left</span><span class=\"bp\">-</span><span class=\"n\">hand</span><span class=\"w\"> </span><span class=\"n\">side</span><span class=\"w\"> </span><span class=\"n\">does</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">simplify</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">when</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">on</span><span class=\"w\"> </span><span class=\"n\">itself</span><span class=\"bp\">.</span>\n</code></pre></div>",
        "id": 515852782,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1746251339
    },
    {
        "content": "<p>In that lemma, it looks like the hypothesis is not in <code>simp</code> normal form. So we should either remove the <code>@[simp]</code> tag, or change the hypothesis to be in normal form.</p>",
        "id": 516260478,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1746466526
    },
    {
        "content": "<p>Aah, good catch. Maybe the linter should now warn about that possibility?</p>",
        "id": 516265605,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1746468368
    },
    {
        "content": "<p>Good idea, I made a change so that the linter now tells you explicitly when a hypothesis is not in <code>simp</code> normal form.</p>",
        "id": 516310638,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1746485240
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"479299\">@Jovan Gerbscheid</span> What do you think of a case like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">support_subtype_perm</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Perm</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">subtypePerm</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Perm</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">support</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">({</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">ext</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Subtype</span><span class=\"bp\">.</span><span class=\"n\">ext_iff</span><span class=\"o\">]</span>\n</code></pre></div>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/blob/95eff173b853f2ce190e3c085d7bdcf349be71f6/Mathlib/GroupTheory/Perm/Support.lean#L655\">https://github.com/leanprover-community/mathlib4/blob/95eff173b853f2ce190e3c085d7bdcf349be71f6/Mathlib/GroupTheory/Perm/Support.lean#L655</a></p>\n<p>Here <code>h</code> is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span>\n</code></pre></div>\n<p>This causes a loop when feeding <code>h</code> to <code>simp</code>.<br>\n(Arguably <code>subtypePerm</code> should not take <code>h</code> in that form, but swap the two sides.)</p>\n<p>But more importantly: I think that in this case the linter should not run <code>simp [h]</code> but should run just <code>simp</code>, because it will still apply the lemma, with <code>h</code> determined by unification.</p>",
        "id": 517741799,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1747115315
    },
    {
        "content": "<p>Ideally, we could run <code>simp [h]</code> in a way where the lemma added to the simp context is saying that for any <code>x</code>, <code>(x ∈ s ↔ f x ∈ s) = True</code>, instead of interpreting it as rewrite lemma. This would avoid the blowup in rewriting, but would still allow the linter to work in general. But this would require a change in core.</p>\n<p>Even better would be if <code>simp</code> could detect when lemmas cause a blowup, and then swap the direction of the rewrite automatically. This would be useful in e.g. <code>aesop</code> which makes calls to <code>simp_all</code>.</p>",
        "id": 517742571,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1747115740
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"479299\">@Jovan Gerbscheid</span> But do you think we could instead detect that <code>h</code> can be determined by unification?</p>",
        "id": 517753204,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1747120214
    },
    {
        "content": "<p>Or should the linter just try <code>simp</code> before attempting <code>simp [h]</code>?</p>",
        "id": 517753239,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1747120227
    },
    {
        "content": "<p>(Aside: <a href=\"https://github.com/leanprover-community/mathlib4/pull/24833\">#24833</a> fixes the order of the argument to <code>subtypePerm</code>.)</p>",
        "id": 517753871,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1747120495
    },
    {
        "content": "<p>The lemma that initiated this discussion, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearMap.linearProjOfIsCompl_of_proj#doc\">docs#LinearMap.linearProjOfIsCompl_of_proj</a>, has a type where it looks like the hypothesis may be possible to infer from unification, but it actually can't . So if we were to try that approach, then this one would need to keep its nolint simpNF tag.</p>",
        "id": 517766351,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1747124393
    },
    {
        "content": "<p>When you say \"try that approach\", which of the two that I mentioned are you referring to?</p>",
        "id": 517774070,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1747126680
    },
    {
        "content": "<p>I meant to use <code>simp</code> instead of <code>simp [h]</code> for hypotheses <code>h</code> that appear on the LHS</p>",
        "id": 517774240,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1747126730
    },
    {
        "content": "<p>Aha, but what about the second approach: where the linter tries <code>simp</code>, and if that fails, <code>simp [h]</code>.</p>",
        "id": 517774381,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1747126778
    },
    {
        "content": "<p>Yes, that would work in this case. But what about encouraging people to always write their equalities/iff in an order that works well with <code>simp</code>? Just like what you're doing in <a href=\"https://github.com/leanprover-community/mathlib4/pull/24833\">#24833</a>.</p>",
        "id": 517776223,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1747127294
    },
    {
        "content": "<p>Maybe that's good enough...</p>",
        "id": 517776840,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1747127467
    },
    {
        "content": "<p>I'm confused by</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Mathlib.CategoryTheory.Idempotents.Karoubi</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Idempotents</span><span class=\"bp\">.</span><span class=\"n\">Karoubi</span><span class=\"bp\">.</span><span class=\"n\">Hom</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"bp\">.</span><span class=\"n\">injEq</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\"> LINTER FAILED:</span>\n<span class=\"cm\">simplify fails on left-hand side:</span>\n<span class=\"cm\">tactic 'simp' failed, nested error:</span>\n<span class=\"cm\">maximum recursion depth has been reached</span>\n<span class=\"cm\">use `set_option maxRecDepth &lt;num&gt;` to increase limit</span>\n<span class=\"cm\">use `set_option diagnostics true` to get diagnostic information -/</span>\n</code></pre></div>\n<p>This is an autogenerated lemma... and I don't see where it ends up in the simp set...</p>",
        "id": 517830249,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1747142638
    },
    {
        "content": "<p>I think these are automatically put in the simp set</p>",
        "id": 517844488,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1747146050
    },
    {
        "content": "<p>Hmmmzz... so maybe we shouldn't do that?</p>",
        "id": 517848269,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1747146970
    },
    {
        "content": "<p>Or we swap the sides of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Idempotents.Karoubi.Hom.comm#doc\">docs#CategoryTheory.Idempotents.Karoubi.Hom.comm</a> :)</p>",
        "id": 517849170,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1747147193
    },
    {
        "content": "<p>Can you explain why that would help? Is that something the linter could detect and suggest?</p>",
        "id": 517849636,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1747147300
    },
    {
        "content": "<p>The problematic simp lemma has a hypothesis <code>comm : f = CategoryTheory.CategoryStruct.comp P.p (CategoryTheory.CategoryStruct.comp f Q.p)</code>, which causes the blowup, so that would be fixed. And similar to <a href=\"https://github.com/leanprover-community/mathlib4/pull/24833\">#24833</a>, it seems generally more useful to state an equality in the direction that can be used by <code>simp</code>.</p>",
        "id": 517850031,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1747147396
    },
    {
        "content": "<p>Thanks! <a href=\"https://github.com/leanprover-community/mathlib4/pull/24848\">#24848</a> should fix Karoubi.</p>",
        "id": 517856119,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1747148767
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/24851\">#24851</a> patches a bunch of proofs that can be <code>simp [*]</code>, and removes the <code>@[simp]</code> attribute from those lemmas.</p>",
        "id": 517865363,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1747151098
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/24926\">#24926</a> is another such batch</p>",
        "id": 518227146,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1747294588
    },
    {
        "content": "<p>Also, if there are further comment on <a href=\"https://github.com/leanprover-community/mathlib4/pull/24833\">#24833</a>, please let me know. It's also on the roadmap to this improved simpNF linter.</p>",
        "id": 518227318,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1747294632
    },
    {
        "content": "<p>I have a question from the peanut gallery: could un-marking lemmas as <code>simp</code> potentially break any proofs? Sure, replacing simp by simp [*] should \"always\" fix this work (perhaps unless local hypotheses are contradictory)... is there a saving grace I'm not yet aware of?</p>",
        "id": 518232031,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1747296018
    },
    {
        "content": "<p>I don't think it should break anything. If some proof X in the past<code>simp</code> used some conditional lemma <code>foo</code>, it would have had to fill in the hypothesis of <code>foo</code>. But if <code>foo</code> can be proved by <code>simp [*]</code>, using some lower level conditional lemmas, then those hypotheses should now also be provable by <code>simp</code> in the proof of X.</p>",
        "id": 518247380,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1747300260
    },
    {
        "content": "<p>There are 80 linter errors left on <a href=\"https://github.com/leanprover-community/mathlib4/tree/batteries-pr-testing-1220\">branch#batteries-pr-testing-1220</a><br>\nSee <a href=\"https://github.com/leanprover-community/mathlib4/actions/runs/15039232241/job/42266873368\">https://github.com/leanprover-community/mathlib4/actions/runs/15039232241/job/42266873368</a></p>",
        "id": 518258151,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1747303206
    },
    {
        "content": "<p>It should break only long chains of conditional lemmas, as those might be pushed over the depth limit of simp</p>",
        "id": 518260927,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1747304072
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/24961\">#24961</a> is another batch</p>",
        "id": 518689870,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1747408711
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/25024\">#25024</a> puts a bunch of hypotheses in simp normal form (and other minor improvements to the simp set)</p>",
        "id": 519139024,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1747666750
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"479299\">@Jovan Gerbscheid</span> What do you think of</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">Adj</span><span class=\"bp\">.</span><span class=\"n\">right_mem</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Adj</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"bp\">.</span><span class=\"n\">left_mem</span>\n</code></pre></div>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/blob/d6c3a2d285e461d43a0bed7d7a2aa51fce4de3d9/Mathlib/Combinatorics/Graph/Basic.lean#L293\">https://github.com/leanprover-community/mathlib4/blob/d6c3a2d285e461d43a0bed7d7a2aa51fce4de3d9/Mathlib/Combinatorics/Graph/Basic.lean#L293</a><br>\nwhich errors with</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Error</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"n\">home</span><span class=\"bp\">/</span><span class=\"n\">lean</span><span class=\"bp\">/</span><span class=\"n\">actions</span><span class=\"bp\">-</span><span class=\"n\">runner</span><span class=\"bp\">/_</span><span class=\"n\">work</span><span class=\"bp\">/</span><span class=\"n\">mathlib4</span><span class=\"bp\">/</span><span class=\"n\">mathlib4</span><span class=\"bp\">/</span><span class=\"n\">Mathlib</span><span class=\"bp\">/</span><span class=\"n\">Combinatorics</span><span class=\"bp\">/</span><span class=\"n\">Graph</span><span class=\"bp\">/</span><span class=\"n\">Basic</span><span class=\"bp\">.</span><span class=\"n\">lean</span><span class=\"o\">:</span><span class=\"mi\">293</span><span class=\"o\">:</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">error</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">Graph</span><span class=\"bp\">.</span><span class=\"n\">Adj</span><span class=\"bp\">.</span><span class=\"n\">right_mem</span><span class=\"w\"> </span><span class=\"n\">Left</span><span class=\"bp\">-</span><span class=\"n\">hand</span><span class=\"w\"> </span><span class=\"n\">side</span><span class=\"w\"> </span><span class=\"n\">does</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">simplify</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">when</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">on</span><span class=\"w\"> </span><span class=\"n\">itself</span><span class=\"bp\">.</span>\n<span class=\"n\">This</span><span class=\"w\"> </span><span class=\"n\">usually</span><span class=\"w\"> </span><span class=\"n\">means</span><span class=\"w\"> </span><span class=\"n\">that</span><span class=\"w\"> </span><span class=\"n\">it</span><span class=\"w\"> </span><span class=\"n\">will</span><span class=\"w\"> </span><span class=\"n\">never</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"bp\">.</span>\n</code></pre></div>",
        "id": 519144571,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1747667869
    },
    {
        "content": "<p>Can we provide a more precise reason why this is a bad simp-lemma?</p>",
        "id": 519144798,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1747667914
    },
    {
        "content": "<p>Yes, because arguments <code>x</code> cannot be determined. I think I could make the linter warn explicitly about this kind of situation.</p>",
        "id": 519152026,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1747669512
    },
    {
        "content": "<p>Ooh, thanks for pointing it out! Yes, if you can automate that warning message, it would be really great.</p>",
        "id": 519168421,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1747673418
    },
    {
        "content": "<p>This could possibly even run as an online-linter, right? As soon as the <code>@[simp]</code> attribute is added, we can run those checks.</p>",
        "id": 519168541,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1747673448
    },
    {
        "content": "<p>Arguably, we can have a linter which checks if <code>simp only [my_lemma]</code> solves the lemma. This can run immediately. And then we also keep the linter that uses the global simp set. This runs at the end.</p>",
        "id": 519184296,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1747677556
    },
    {
        "content": "<p><code>simp only [my_lemma, my, hyps]</code>, but yes, I think we should have both those linters.</p>",
        "id": 519190937,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1747679353
    },
    {
        "content": "<p>If you make this a syntax linter, I'm happy to review the \"syntax\"-y aspects of it.</p>",
        "id": 519191251,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1747679430
    },
    {
        "content": "<p>The implementation will be the same as the current linter, just replacing the whole simp set by just the lemma. So not a syntax linter.</p>",
        "id": 519195889,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1747680708
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/channel/287929-mathlib4/topic/simpNF.20lint.20with.20hyps/near/519168421\">said</a>:</p>\n<blockquote>\n<p>Yes, if you can automate that warning message, it would be really great.</p>\n</blockquote>\n<p>I've pushed a change that should do this.</p>",
        "id": 519315499,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1747727584
    },
    {
        "content": "<p>I think adding the online simp linter can go in a later PR.</p>",
        "id": 519315583,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1747727615
    },
    {
        "content": "<p>Sorry, just coming back after many weeks of busy IRL work: tldr... What is the current status for <a href=\"https://github.com/leanprover-community/batteries/pull/1220\">batteries#1220</a>?</p>",
        "id": 522218350,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1748986252
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> has fixed a bunch of simp lemmas on the master branch of mathlib to satisfy the new linter. There are now 25 errors left to fix before we can merge <a href=\"https://github.com/leanprover-community/batteries/pull/1220\">batteries#1220</a>.</p>",
        "id": 522221727,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1748987808
    },
    {
        "content": "<p>Why is this a bad simp lemma?<br>\n<a href=\"https://github.com/leanprover-community/mathlib4/blob/401dce0e8e36a1011330773466b2c6c1b3683a29/Mathlib/NumberTheory/ArithmeticFunction.lean#L547\">https://github.com/leanprover-community/mathlib4/blob/401dce0e8e36a1011330773466b2c6c1b3683a29/Mathlib/NumberTheory/ArithmeticFunction.lean#L547</a></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">map_mul_of_coprime</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ArithmeticFunction</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">IsMultiplicative</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">Coprime</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">hf</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">-- Mathlib.NumberTheory.ArithmeticFunction</span>\n<span class=\"cm\">Error: /home/lean/actions-runner/_work/mathlib4/mathlib4/Mathlib/NumberTheory/ArithmeticFunction.lean:546:1:</span>\n<span class=\"cm\">error: @ArithmeticFunction.IsMultiplicative.map_mul_of_coprime Left-hand side does not simplify, when using the simp lemma on itself.</span>\n<span class=\"cm\">This usually means that it will never apply.</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 522264460,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1749012815
    },
    {
        "content": "<p>There are now 15 cases left: <a href=\"https://github.com/leanprover-community/mathlib4/actions/runs/15434053802/job/43436958608\">https://github.com/leanprover-community/mathlib4/actions/runs/15434053802/job/43436958608</a></p>\n<p>All of them are of the form</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Left</span><span class=\"bp\">-</span><span class=\"n\">hand</span><span class=\"w\"> </span><span class=\"n\">side</span><span class=\"w\"> </span><span class=\"n\">does</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">simplify</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">when</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">on</span><span class=\"w\"> </span><span class=\"n\">itself</span><span class=\"bp\">.</span>\n<span class=\"n\">This</span><span class=\"w\"> </span><span class=\"n\">usually</span><span class=\"w\"> </span><span class=\"n\">means</span><span class=\"w\"> </span><span class=\"n\">that</span><span class=\"w\"> </span><span class=\"n\">it</span><span class=\"w\"> </span><span class=\"n\">will</span><span class=\"w\"> </span><span class=\"n\">never</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"bp\">.</span>\n</code></pre></div>",
        "id": 522269973,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1749016220
    },
    {
        "content": "<p>Random comment: I've seen that error plenty of times before and it turns out that sometimes it's a lie, in the sense that the simp lemma seems to fire just fine. I've nolinted this warning away in the past</p>",
        "id": 522273322,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1749017853
    },
    {
        "content": "<p>I wonder whether we should just <code>nolint</code> these 15, and merge the improved linter.<br>\nThen we can investigate the existing 38 + 15 nolints after that.</p>",
        "id": 522275029,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1749018594
    },
    {
        "content": "<ul>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/25419\">#25419</a> chore(Topology): remove <code>@[simp]</code> when simp can prove</li>\n</ul>\n<p>Mathlib/Topology/FiberBundle/Trivialization.lean | 6 +++---<br>\n Mathlib/Topology/VectorBundle/Basic.lean         | 9 +++++----<br>\n Mathlib/Topology/VectorBundle/Constructions.lean | 2 +-<br>\n 3 files changed, 9 insertions(+), 8 deletions(-)</p>",
        "id": 522285282,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1749022273
    },
    {
        "content": "<ul>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/25420\">#25420</a> chore(Data/List/EditDistance): put fields in simp-normal form</li>\n</ul>\n<p>1 file changed, 13 insertions(+), 13 deletions(-)</p>",
        "id": 522286007,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1749022513
    },
    {
        "content": "<p>The problem is in <code>Coprime</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">Coprime</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">gcd</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">coprime</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Coprime</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Coprime</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"c1\">-- simp made no progress</span>\n</code></pre></div>",
        "id": 522296212,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1749025453
    },
    {
        "content": "<p>and it works when I replace <code>abbrev</code> with <code>def</code></p>",
        "id": 522299973,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749026550
    },
    {
        "content": "<p>For the remaining lemmas:</p>\n<ul>\n<li><code>closure_sdiff_eq_closure</code> causes a recursive blowup, because  the lemma applies to its own hypothesis</li>\n<li><code>Finset.prod_image</code>, <code>Finset.fold_image</code> and <code>List.toFinset_filterMap</code> have hypotheses that are too strong to be useful simp lemmas</li>\n<li><code>List.Vector.mapAccumr₂_unused_input_right</code> and friends have a hypothesis that <code>f</code> doesn't depend on one of its arguments. I think instead of</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">mapAccumr₂_unused_input_right</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Inhabited</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">γ</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">default</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>it should state</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">mapAccumr₂_unused_input_right</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">γ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">γ</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f'</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span>\n</code></pre></div>\n<p><code>simp</code> should be able to figure out the value of <code>f'</code> exactly in the case that <code>f</code> doesn't depend on its second argument. And then we can also use <code>f'</code> in the conclusion of the statement.</p>",
        "id": 522301922,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1749027110
    },
    {
        "content": "<p>For <code>Coprime</code>, I think we need to inline the definition of <code>Coprime</code>, so that the hypothesis becomes <code>m.gcd n = 1</code></p>",
        "id": 522302405,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1749027252
    },
    {
        "content": "<p>Out of the existing <code>nolint simpNF</code>, 19 are labelled with a comment like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- It seems the side condition `hf` is not applied by `simpNF`.</span>\n</code></pre></div>\n<p>These should hopefully all correctly pass the new <code>simpNF</code> linter. (the labels were added in <a href=\"https://github.com/leanprover-community/mathlib4/pull/23201\">#23201</a> by <span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span>)</p>",
        "id": 522305909,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1749028190
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"479299\">@Jovan Gerbscheid</span> Thanks for those investigations! I pushed a commit that fixes them.</p>",
        "id": 522342535,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1749039327
    },
    {
        "content": "<p>Actually, <code>fold_image </code> and <code>prod_image</code> could probably remain a <code>simp</code> lemma if they used <code>Set.injOn</code>, instead of writing out the injectivity</p>",
        "id": 522344202,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1749039751
    },
    {
        "content": "<p>Looks like we should do something like that, in order to keep the build working: <a href=\"https://github.com/leanprover-community/mathlib4/actions/runs/15442001546/job/43461831048#step:25:20\">https://github.com/leanprover-community/mathlib4/actions/runs/15442001546/job/43461831048#step:25:20</a></p>",
        "id": 522344889,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1749039941
    },
    {
        "content": "<p>I added a simp lemma for simplifying <code>Set.InjOn</code> that should hopefully fix the places where proofs broke.</p>",
        "id": 522361635,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1749044337
    },
    {
        "content": "<p>But some of the proofs that broke weren't using <code>simp</code> but eg <code>rw</code>. Those still need to be fixed by hand, right?</p>",
        "id": 522364051,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1749044906
    },
    {
        "content": "<p>I'm working on that now.</p>",
        "id": 522364074,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1749044910
    },
    {
        "content": "<p>The <code>simp</code> lemma that I added fixes the proof of <code>Units.mk0_prod</code>, without needing to pass <code>Set.InjOn</code> to <code>simp</code>. Feel free to remove it though.</p>",
        "id": 522368286,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1749045879
    },
    {
        "content": "<p>But in that case I think it's clearer to unsimp <code>prod_image</code>, and pass it manually to <code>simp</code> as well.</p>",
        "id": 522368933,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1749046026
    },
    {
        "content": "<p>I think your lemma is fine</p>",
        "id": 522369243,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1749046104
    },
    {
        "content": "<p>My local build is at ~ 6000/6700</p>",
        "id": 522369357,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1749046129
    },
    {
        "content": "<p>Local build is done. Running local lint now</p>",
        "id": 522370997,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1749046542
    },
    {
        "content": "<p>Linting passed locally!</p>",
        "id": 522377765,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1749048235
    },
    {
        "content": "<p>I'm trying to remove existing <code>nolint</code>s on <a href=\"https://github.com/leanprover-community/mathlib4/tree/jmc-nolint-simpnf\">branch#jmc-nolint-simpnf</a></p>",
        "id": 522378312,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1749048357
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span> <span class=\"user-mention\" data-user-id=\"119741\">@François G. Dorais</span> <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> </p>\n<blockquote>\n<p>feat: simpNF to check lemmas with conditions <a href=\"https://github.com/leanprover-community/batteries/pull/1220\">batteries#1220</a></p>\n</blockquote>\n<p>is now ready for review, and a testing branch of mathlib builds against this PR</p>",
        "id": 522380202,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1749048819
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Bash Session\"><pre><span></span><code><span class=\"gp\">$ </span>rg<span class=\"w\"> </span>-il<span class=\"w\"> </span><span class=\"s2\">\"nolint simpnf\"</span><span class=\"w\"> </span>Mathlib\n<span class=\"go\">Mathlib/Topology/Specialization.lean</span>\n<span class=\"go\">Mathlib/Data/NNRat/Defs.lean</span>\n<span class=\"go\">Mathlib/Data/WSeq/Relation.lean</span>\n<span class=\"go\">Mathlib/Data/Seq/Computation.lean</span>\n<span class=\"go\">Mathlib/Data/Seq/Seq.lean</span>\n<span class=\"go\">Mathlib/Computability/TMToPartrec.lean</span>\n<span class=\"go\">Mathlib/CategoryTheory/WithTerminal/Basic.lean</span>\n</code></pre></div>",
        "id": 522388623,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1749050891
    },
    {
        "content": "<p>The remaining ones all have to do with either LHS not being in simp normal form, or with auto-generated match lemmas that can be proven by simp.</p>",
        "id": 522398311,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1749053468
    },
    {
        "content": "<p>When working on <a href=\"https://github.com/leanprover-community/mathlib4/pull/25515\">#25515</a>, I discovered a small bug in the <code>simpNF</code> linter. I've make a fix at <a href=\"https://github.com/leanprover-community/batteries/pull/1266\">batteries#1266</a></p>",
        "id": 522895573,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1749302557
    },
    {
        "content": "<p>Jovan asks a good question here: <a href=\"https://github.com/leanprover-community/mathlib4/pull/25515#discussion_r2151910631\">https://github.com/leanprover-community/mathlib4/pull/25515#discussion_r2151910631</a><br>\nIn a situation where we have</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">reassoc</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">attr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">elementwise</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">attr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">)</span><span class=\"kd\">]</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">foo</span>\n</code></pre></div>\n<p>the lemma <code>foo</code> gets tagged with <code>simp</code> twice. This doesn't seem to be too problematic, because it is an idempotent effect. But is this idiomatic, or should this be done differently?</p>",
        "id": 524445655,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1750164637
    },
    {
        "content": "<p>What about a syntax <code>(attr only := simp)</code>, to only add the attribute to the generated declaration and not the original?</p>",
        "id": 525043151,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1750426281
    }
]