[
    {
        "content": "<p>Searching for <code>DecidableEq (Ideal</code> in mathlib gives 18 hits. When I'm working with e.g. finite sums, or more generally finsets or fintypes, I expect to see the occasional Decidable hypothesis, because finsets are constructive. But I would not expect to see decidable stuff showing up in MSc level commutative algebra. </p>\n<p>The reason this came to my attention was this instance</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableRel</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ideal</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Ideal</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LinearOrder</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Ideal</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">decidableEqOfDecidableLE</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Ideal</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">decidableLTOfDecidableLE</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Ideal</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">Lattice</span><span class=\"bp\">.</span><span class=\"n\">toLinearOrder</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Ideal</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>which came up in a  <a href=\"#narrow/channel/287929-mathlib4/topic/set_option.20maxSynthPendingDepth.202/near/501498630\">discussion</a> about typeclass inference going crazy on a high SynthPendingDepth setting. The reason it goes crazy is explained <a href=\"#narrow/channel/287929-mathlib4/topic/set_option.20maxSynthPendingDepth.202/near/501501301\">here</a>. Sebastien suggested changing the instance to be fully classical:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LinearOrder</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Ideal</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">classical</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Lattice</span><span class=\"bp\">.</span><span class=\"n\">toLinearOrder</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Ideal</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and this solves the problem. But it raises the question about whether ideals, like polynomials, should be a \"fully classical\" theory. Perhaps evidence that this is a good idea is the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Ideal</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- fails</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Ideal</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- fails</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Ideal</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- fails</span>\n</code></pre></div>\n<p>which indicates that up until now nobody attempted to write these instances. If we globally make = and &lt;= on ideals decidable with a classical instance then (a) we'll be able to remove these weird decidable hypotheses in commutative algebra files (which are confusing to mathematicians) and (b) we'll be able to fix the timeout which occurs in mathlib when synthpendingdepth is set to 50 without causing diamonds. Are there any arguments against this?</p>",
        "id": 501520066,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1740397570
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"644391\">@loogle</span> DecidableEq (Ideal _)</p>",
        "id": 501520845,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1740397784
    },
    {
        "content": "<p><span aria-label=\"search\" class=\"emoji emoji-1f50d\" role=\"img\" title=\"search\">:search:</span> <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/RingTheory/Ideal/Basic.html#Ideal.equivFinTwo\">Ideal.equivFinTwo</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/RingTheory/DedekindDomain/Ideal.html#count_le_of_ideal_ge\">count_le_of_ideal_ge</a>, and <a href=\"https://loogle.lean-lang.org/?q=DecidableEq%20%28Ideal%20_%29\">15 more</a></p>",
        "id": 501520852,
        "sender_full_name": "loogle",
        "timestamp": 1740397786
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"644391\">@loogle</span> |- DecidableEq (Ideal _)</p>",
        "id": 501520892,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1740397797
    },
    {
        "content": "<p><span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span> nothing found</p>",
        "id": 501520893,
        "sender_full_name": "loogle",
        "timestamp": 1740397797
    },
    {
        "content": "<p>So indeed, this argument is everywhere but it is instantiated never</p>",
        "id": 501520971,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1740397811
    },
    {
        "content": "<p>Your suggestion sounds good to me</p>",
        "id": 501521060,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1740397838
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/decidable.20equality.20on.20ideals/near/501520066\">said</a>:</p>\n<blockquote>\n<p>should be a \"fully classical\" theory</p>\n</blockquote>\n<p>I think this is the wrong way to think about this; <code>Real</code> isn't \"fully classical\", but we still create classical instances here and there. I think the more precise rule is \"if a <code>Decidable</code> instance is <em>never</em> constructed computably, then construct it classically to save everyone the trouble downstream\"</p>",
        "id": 501521450,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1740397938
    },
    {
        "content": "<p>Indeed you can only prove <code>DecidableEq (Ideal R)</code> constructively if <code>R</code> is trivial. Otherwise, every <code>p : Prop</code> determines an ideal in <code>R</code> containing <code>x : R</code> if <code>p</code> holds or <code>x = 0</code>. If you can tell whether this ideal is all of <code>R</code> then you can decide if <code>p</code> is false or not false. The best you can hope for constructively is decidable equality of finitely generated ideals.</p>",
        "id": 501555219,
        "sender_full_name": "David Wärn",
        "timestamp": 1740406608
    },
    {
        "content": "<p>I think if <code>R</code> is a <code>CommRing</code> not a field, then <code>DecidableEq (Ideal R)</code> has prerequisites that we should have <code>DecidableEq R</code>, the ideal in question should have <code>DecidablePred Membership.mem</code>, and <code>R</code> must satisfies very good conditions, for example, a computable Euclidean algorithm, or the ring of integers of a number field (even in this case the <code>DecidableEq</code> algorithm for ideals becomes very complicated, as in computational number theory).</p>",
        "id": 501563423,
        "sender_full_name": "Jz Pan",
        "timestamp": 1740408536
    },
    {
        "content": "<p>even then, i suspect it's higly likely that you need <code>Fintype R</code>, right?</p>",
        "id": 501564779,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1740408842
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/channel/287929-mathlib4/topic/decidable.20equality.20on.20ideals/near/501564779\">said</a>:</p>\n<blockquote>\n<p>even then, i suspect it's higly likely that you need <code>Fintype R</code>, right?</p>\n</blockquote>\n<p>Oh yes, even when the ideal has <code>DecidablePred Membership.mem</code>, the <code>DecidableEq (Ideal ℤ)</code> is not possible, because although you can check if <code>n</code> belongs to the ideal for each <code>n</code>, but you cannot check if there exists a non-zero <code>n</code> in the ideal in finite number of steps...</p>",
        "id": 501565766,
        "sender_full_name": "Jz Pan",
        "timestamp": 1740409068
    },
    {
        "content": "<p>i think a strict requirement is a countable number of ideals?</p>",
        "id": 501566303,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1740409187
    },
    {
        "content": "<p><del><code>DecidableEq R</code></del> + <code>Fintype R</code> + <code>DecidablePred (· ∈ I)</code> is the best I can come up with.</p>",
        "id": 501566822,
        "sender_full_name": "Jz Pan",
        "timestamp": 1740409291
    },
    {
        "content": "<p>it might be possible in a slightly better generality if all ideals are finitely generated, and computably so, i.e. you can compute a <code>g:Finset R</code> of generators, such that <del><code>I = Ideal.closure g</code></del> <code>I = Ideal.span g</code>.</p>",
        "id": 501567891,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1740409525
    },
    {
        "content": "<p>If <code>R</code> is a field and membership is decidable, aren't you then also able to test for equality of ideals?  The only interesting question is whether an ideal contains <code>1</code> or not.</p>",
        "id": 501567898,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1740409527
    },
    {
        "content": "<p><del>no? for integers, i imagine you'd need to check all primes in order to know what ideal you're looking at?</del> right, <em>field</em></p>",
        "id": 501568254,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1740409609
    },
    {
        "content": "<p>(i might need to dust off my algebra knowledge)</p>",
        "id": 501568512,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1740409660
    },
    {
        "content": "<p>I can define an ideal of <code>ℤ</code> whose <code>n ∈ I</code> is \"<code>0 ∈ I</code>; if <code>n</code> is not zero, find the smallest positive integer <code>i ≤ |n|</code> such that there exists a zero of Riemann zeta function in the critical strip whose real part is not <code>1/2</code>, if such <code>i</code> exists, then <code>n ∈ I</code> if and only if <code>n</code> is a multiple of <code>i</code>, otherwise <code>n</code> is not in <code>I</code>\". This is indeed <code>DecidablePred</code> (but very far from implemented in Lean). But to decide whether <code>I = 0</code> it's equivalent to prove or disprove Riemann hypothesis.</p>",
        "id": 501568974,
        "sender_full_name": "Jz Pan",
        "timestamp": 1740409744
    },
    {
        "content": "<p>indeed in the case of a field, every ideal is either <code>Ideal.span 0</code> or <code>Ideal.span {1}</code></p>",
        "id": 501568986,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1740409746
    },
    {
        "content": "<p>You might get a little improvement for rings that only have finitely many ideals and for which you know how to test what ideal is what.  For instance, a finite product of fields is probably ok, since you can test the \"<code>0-1</code> sequences\" for membership.</p>",
        "id": 501570170,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1740410004
    },
    {
        "content": "<p>so indeed the question is one of finding a finite set of generators for any ideal? since then, to decide <code>I = J</code>, it suffices to decide <code>gen(I) &lt;= J</code> and <code>gen(J) &lt;= I</code>. in the case of a product, you can decompose the ideal by deciding membership of <code>(a,0)</code> and <code>(0,b)</code> (since if <code>(a,b)</code> is in the ideal, so is <code>(1,0) *(a,b)</code> etc), decide the generators of those ideals, take the cartesian product of the sets of generators, (verify they are members of the ideal,) and do the above procedure (or even do the above procedure on the respective projections? that might be more efficient).</p>",
        "id": 501572610,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1740410595
    },
    {
        "content": "<blockquote>\n<p><code>DecidablePred (· ∈ I)</code></p>\n</blockquote>\n<p>But in the context of <code>DecidableEq (Ideal R)</code>, this requires that <em>all</em> ideals satisfy this, which amounts to requiring that all propositions are decidable via the ideal <code>if p then \\top else \\bot</code> for arbitrary <code>p</code>.</p>",
        "id": 501578053,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1740411953
    },
    {
        "content": "<p>you have that issue with any kind of <code>DecidableEq</code> on a non-trivial type</p>",
        "id": 501578905,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1740412170
    },
    {
        "content": "<p>if you're writing down <code>if p then foo else bar</code>, you are already either using <code>classical</code> or <code>Decidable p</code></p>",
        "id": 501579156,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1740412223
    },
    {
        "content": "<p>(it's how <code>if</code> works)</p>",
        "id": 501579228,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1740412244
    },
    {
        "content": "<p>Ok, let's say I write down <code>{x | p} ∪ {0}</code> as my carrier for an ideal then. I didn't use classical or decidable to define that, but you can't decide members, and so <code>∀ I : Ideal R, DecidablePred (· ∈ I)</code> is impossible to construct for nontrivial <code>R</code></p>",
        "id": 501579953,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1740412418
    },
    {
        "content": "<p>I think your claim here reduces to \"you have that issue with anything built upon <code>Set</code>\", which is of course precisely the issue!</p>",
        "id": 501580341,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1740412482
    },
    {
        "content": "<p>so then ideally, you'd want to somehow express \"every ideal is equal to one in which membership is decidable\", and \"you can decide equality for all &lt;ideal, decidable membership&gt; tuples\"</p>",
        "id": 501581318,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1740412655
    },
    {
        "content": "<blockquote>\n<p>every ideal is equal to one in which membership is decidable</p>\n</blockquote>\n<p>If you can't know which one, then you don't have an algorithm available. If you <em>can</em> tell which one, then you could have just implemented the instance in the first place.</p>",
        "id": 501581688,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1740412723
    },
    {
        "content": "<p>As a simple test, try proving <code>DecidableEq (Set Bool)</code></p>",
        "id": 501581797,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1740412747
    },
    {
        "content": "<p>i guess you don't get <code>DecidableEq</code> but you do get <code>DecidablePred (. \\in I) -&gt; DecidablePred (. \\in J) -&gt; Decidable (I = J)</code></p>",
        "id": 501581852,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1740412755
    },
    {
        "content": "<p><code>DecidableEq ((I : Ideal R) × DecidablePred (· ∈ I))</code> if <code>R</code> satisfies good condition, here I can't write subtype since <code>DecidablePred</code> contains data.</p>",
        "id": 501718568,
        "sender_full_name": "Jz Pan",
        "timestamp": 1740462962
    }
]