[
    {
        "content": "<p>The following two lemmas are registered as simp lemmas in mathlib:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">‚âÉ</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"n\">ùïú</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"bp\">.</span><span class=\"n\">toLinearEquiv</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">toLinearEquiv</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">ContinuousLinearEquiv</span><span class=\"bp\">.</span><span class=\"n\">symm_toLinearEquiv</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">‚âÉ‚Çó</span><span class=\"o\">[</span><span class=\"n\">ùïú</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">toEquiv</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"bp\">.</span><span class=\"n\">toEquiv</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">LinearEquiv</span><span class=\"bp\">.</span><span class=\"n\">coe_toEquiv_symm</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n</code></pre></div>\n<p>They dont' simplify in the same direction, which means that <code>e.toLinearEquiv.toEquiv.symm = e.symm.toLinearEquiv.toEquiv</code> is not provable by simp. Do we have a prefered canonical direction?</p>",
        "id": 522798450,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1749222753
    },
    {
        "content": "<p>(And a prefered naming scheme, also?)</p>",
        "id": 522798554,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1749222797
    },
    {
        "content": "<p><a href=\"#narrow/channel/113488-general/topic/simp.20normal.20form.20for.20.60e.2Eto_equiv.2Esymm.60/near/228641270\">#general &gt; simp normal form for &#96;e.to_equiv.symm&#96; @ üí¨</a></p>",
        "id": 522799334,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1749223096
    },
    {
        "content": "<p>(should we merge the threads?)</p>",
        "id": 522799449,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1749223136
    },
    {
        "content": "<p>Ah, it's true. I guess this is one of these things where we will never make a decision, then. I'll just change the direction of one of the lemmas above for local coherence, then. It's not as good as a global decision, but still better than the status quo.</p>",
        "id": 522818161,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1749229922
    },
    {
        "content": "<p>There is also the issue of naming with dot notation here. We have the next lemmas in the library, following each other:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">symm_toLinearEquiv</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M‚ÇÅ</span><span class=\"w\"> </span><span class=\"bp\">‚âÉ</span><span class=\"n\">SL</span><span class=\"o\">[</span><span class=\"n\">œÉ‚ÇÅ‚ÇÇ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">M‚ÇÇ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"bp\">.</span><span class=\"n\">toLinearEquiv</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">toLinearEquiv</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">ext</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">symm_toHomeomorph</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M‚ÇÅ</span><span class=\"w\"> </span><span class=\"bp\">‚âÉ</span><span class=\"n\">SL</span><span class=\"o\">[</span><span class=\"n\">œÉ‚ÇÅ‚ÇÇ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">M‚ÇÇ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">toHomeomorph</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"bp\">.</span><span class=\"n\">toHomeomorph</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>They use a normal form in reverse directions, but they are named similarly!</p>",
        "id": 522819423,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1749230446
    },
    {
        "content": "<p>While the vote was split, it was also barely voted upon, so a global decision feels possible</p>",
        "id": 522834976,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1749237476
    },
    {
        "content": "<p>This feels similar to the problem we had with casts until we got <code>norm_cast</code> and <code>push_cast</code>.  But at least with casts we are consistent with directions!</p>",
        "id": 522875028,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1749275200
    },
    {
        "content": "<p>ok, let me summarize the discussion and then open a poll.</p>",
        "id": 522879475,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1749281154
    },
    {
        "content": "<p>Given <code>e</code> a continuous linear equiv, there are two ways to consider the inverse as a linear equiv: <code>e.symm.toLinearEquiv</code> and <code>e.toLinearEquiv.symm</code> (similarly for <code>trans</code>, and similarly for many equiv classes in the library, the above is just a representative example).</p>\n<p>We should choose a simp normal form, pushing symm either to the left, as in <code>e.symm.toLinearEquiv</code>, or to the right as in <code>e.toLinearEquiv.symm</code>. There are arguments in favor of one or the other, so there is no obvious better form, but still for coherence and predictability we should make a choice, as otherwise various simp lemmas will fight against each other.</p>\n<p>A few remarks:</p>\n<p>(a) For <code>refl</code>, we should push it to the right: the normal form of <code>ContinuousLinearEquiv.refl.toLinearEquiv</code> should obviously be <code>LinearEquiv.refl</code></p>\n<p>(b) For function applications, we should push it to the left: if <code>x</code> is a point, then <code>e.toLinearEquiv.symm x</code> should be simplified to <code>e.symm x</code>.</p>\n<p>(c) For an analogy, consider <code>f</code> an equiv between <code>E</code> and <code>F</code>, and the coercion to functions. Then (with made up dot notation) <code>f.symm.coe</code> makes sense, but <code>f.coe.symm</code> does not make sense, so in this case the only possible thing is to push symm to the left.</p>\n<p>(d) For another analogy, let <code>c</code> be an additive group morphism, and let <code>neg</code> be negation. Then we simplify <code>c (- x)</code> to <code>- c x</code>, i.e., we change <code>x.neg.c</code> to <code>x.c.neg</code>, i.e., we push <code>neg</code> to the right. As <code>neg</code> is a clear analogue of <code>symm</code>, this is in favor of pushing to the right.</p>",
        "id": 522879961,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1749281925
    },
    {
        "content": "<p>Initially, I was really convinced by (d), but thinking more of it the reason we push addition and negation to the right is usually so that we can try to simplify the remaining expression with <code>abel</code> or friends, which is not really relevant in an equiv-like context. So, I don't have a strong opinion. Maybe I'd err somewhat on the side of pushing to the left.</p>",
        "id": 522880015,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1749282016
    },
    {
        "content": "<p>/poll Should the simp normal form be <code>e.symm.toLinearEquiv</code> or <code>e.toLinearEquiv.symm</code>?<br>\n<code>e.symm.toLinearEquiv</code><br>\n<code>e.toLinearEquiv.symm</code><br>\nI don't care, but we should make a coherent choice<br>\nI don't care, and I don't even think we should make a coherent choice</p>",
        "id": 522880092,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1749282153
    },
    {
        "content": "<p>Comments on other examples in the library where one direction is more convenient than the other are most welcome. As well as other arguments, information I don't have about how things are handled in the category theory folders, and so on!</p>",
        "id": 522880715,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1749283221
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">S√©bastien Gou√´zel</span> <a href=\"#narrow/channel/287929-mathlib4/topic/simp.20normal.20form.20for.20symm.20and.20coercions/near/522879961\">said</a>:</p>\n<blockquote>\n<p>(b) For function applications, we should push it to the left: if <code>x</code> is a point, then <code>e.toLinearEquiv.symm x</code> should be simplified to <code>e.symm x</code>.</p>\n</blockquote>\n<p><code>e.toLinearEquiv.symm x = e.symm x</code> is a projection lemma for <code>toLinearEquiv</code>. Therefore point (b) doesn't matter, as if we are pushing the <code>symm</code> right-wards then we should simply add that projection lemma</p>",
        "id": 522884220,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1749288190
    },
    {
        "content": "<p>Sure, (b) is not incompatible with pushing to the left, we just need to add the correct simp lemma. I think there is no global obstruction to picking either left or right, we will just need to adjust the simpset.</p>",
        "id": 522884355,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1749288396
    },
    {
        "content": "<p>(If we push to the left, we just need to add the simp lemma <code>e.toLinearEquiv x = e x</code>, while if we push to the right we need to add both <code>e.toLinearEquiv x = e x</code> and <code>e.toLinearEquiv.symm x = e.symm x</code>, so pushing to the right is slightly more expensive than pushing to the left in this respect. This is why I am saying that (b) is in favor of pushing to the left.)</p>",
        "id": 522884510,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1749288601
    },
    {
        "content": "<p>If the goal is coherence and predictability, and if <code>toLinearEquiv</code> is a coercion, then shouldn't we use the convention for coercions? i.e. <code>toLinearEquiv</code> going inward and <code>symm</code> going outward.</p>",
        "id": 522886426,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1749291116
    },
    {
        "content": "<p>Is there really a convention for coercions?</p>",
        "id": 522887924,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1749293243
    },
    {
        "content": "<p>Doesn't e.g. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Int.cast_add#doc\">docs#Int.cast_add</a> follow the general pattern?</p>",
        "id": 522887997,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1749293341
    },
    {
        "content": "<p>For numerical casts, yes, definitely, because you want things to become elementary atoms to which operations are applied, to be able to use <code>abel</code> or friends. That's (d) in the above discussion. But it's not clear to me that it applies in general.</p>",
        "id": 522888167,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1749293567
    },
    {
        "content": "<p>Jovan's point is a strong argument for <code>toLinearEquiv</code> going inwards</p>",
        "id": 522888323,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1749293776
    },
    {
        "content": "<p>If we do decide to follow that logic, we should unsimp <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearEquiv.comp_coe#doc\">docs#LinearEquiv.comp_coe</a>, right?</p>",
        "id": 522888549,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1749294067
    },
    {
        "content": "<p>That lemma is the wrong way around!</p>",
        "id": 522888626,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1749294183
    },
    {
        "content": "<p>ok, if everyone agrees that this lemma is the wrong way around, this is another argument for pushing <code>symm</code> to the right.</p>",
        "id": 522890032,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1749295965
    },
    {
        "content": "<p>What should happen to <code>(f e).toLinearEquiv.symm.toAddEquiv</code>? Often there's a <code>simp</code> lemma of the form <code>(f e).symm = f e.symm</code>, which obviously can't apply unless the <code>symm</code> is pushed to the left</p>",
        "id": 522890347,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1749296374
    },
    {
        "content": "<p>Is the answer that we should write extra simp lemmas like <code>(f e).toLinearEquiv = fLinear e</code> (possibly introducing intermediate bundlings along the way?)</p>",
        "id": 522890383,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1749296414
    },
    {
        "content": "<p>If we decide we want to push symm to the right, yes, we should add the corresponding simp lemmas for concrete <code>f</code>s. Do you have a specific example in mind?</p>",
        "id": 522890740,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1749296797
    },
    {
        "content": "<p>I'm thinking of things like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finsupp.domLCongr#doc\">docs#Finsupp.domLCongr</a></p>",
        "id": 522890833,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1749296890
    },
    {
        "content": "<p>Or we could have a simp lemma <code>(f e).toLinearEquiv = fLinear e.toLinearEquiv</code>, and then if <code>symm</code> is pushed to the right you just need the simp lemma <code>(fLinear e).symm = fLinear e.symm</code>.</p>",
        "id": 522890840,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1749296898
    },
    {
        "content": "<p>This is a little bit annoying for cases when the map is already the weakest interesting bundling, as the weaker bundlings have no reason to exist beside simp confluence; but pragmatically these <code>symm</code> chains probably never appear in those cases anyway</p>",
        "id": 522890945,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1749297047
    },
    {
        "content": "<p>If we push <code>symm</code> outwards, do we now have to write the lemmas <code>E.toSomeEquiv.symm.toSomeOtherMap = E.symm.toSomeOtherMap</code> for all coercion chains <code>E -&gt; SomeEquiv -&gt; SomeOtherMap</code>?</p>",
        "id": 522892793,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1749299230
    },
    {
        "content": "<p>That rewrite can just be done by a lemma saying <code>E.toSomeEquiv.symm = E.symm</code></p>",
        "id": 522892850,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1749299325
    },
    {
        "content": "<p>And we almost never want simp lemmas with LHS <code>E.toLinearEquiv</code> but we sometimes do have <code>E.symm = ?</code> lemmas. This is another reason why I prefer pushing <code>symm</code> inwards.</p>",
        "id": 522892884,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1749299374
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/channel/287929-mathlib4/topic/simp.20normal.20form.20for.20symm.20and.20coercions/near/522892850\">said</a>:</p>\n<blockquote>\n<p>That rewrite can just be done by a lemma saying <code>E.toSomeEquiv.symm = E.symm</code></p>\n</blockquote>\n<p>Yes. So my point is that we should make this lemma simp.</p>",
        "id": 522892911,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1749299403
    },
    {
        "content": "<p>Are they not already tagged with simp?</p>",
        "id": 522892952,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1749299461
    },
    {
        "content": "<p>I thought the point some people are making in thread is to turn that simp lemma around.</p>",
        "id": 522893009,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1749299529
    },
    {
        "content": "<p>Sorry I got confused by how you wrote the lemma. The discussion is about lemmas of the form <code>E.toSomeEquiv.symm = E.symm.toSomeEquiv</code></p>",
        "id": 522893102,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1749299666
    },
    {
        "content": "<p>Is that not what you said? I thought you just forgot to add <code>toSomeEquiv</code> at the end. Your statement as is doesn't typecheck.</p>",
        "id": 522893307,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1749299906
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/channel/287929-mathlib4/topic/simp.20normal.20form.20for.20symm.20and.20coercions/near/522892793\">said</a>:</p>\n<blockquote>\n<p>If we push <code>symm</code> outwards, do we now have to write the lemmas <code>E.toSomeEquiv.symm.toSomeOtherMap = E.symm.toSomeOtherMap</code> for all coercion chains <code>E -&gt; SomeEquiv -&gt; SomeOtherMap</code>?</p>\n</blockquote>\n<p>I'm not sure I understand the question. It's about the case where you have a map to something else which is not an equiv, right? Like ContinuousLinearEquiv, LinearEquiv, ContinuousLinearMap, LinearMap? That's yet another normal form question: for <code>e : ContinuousLinearEquiv</code>, we have <code>e.toLinearEquiv.toLinearMap = e.toContinuousLinearMap.toLinearMap</code>, and we should choose a normal form between the two of them.</p>\n<p>But I don't see how <code>symm</code> plays with this. Is your point that <code>e.toLinearEquiv.symm.toLinearMap</code> is bad, and that you prefer <code>e.symm.toContinuousLinearMap.toLinearMap</code>?</p>",
        "id": 522895555,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1749302533
    },
    {
        "content": "<p>I think the simp normal form should be <code>LinearMapClass.toLinearMap e.symm</code>.</p>",
        "id": 522896136,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1749303234
    },
    {
        "content": "<p>That's usually a pretty bad simp-normal form, as for some <code> e : ContinuousLinearEquiv</code>, that hides the <code>.toLinearEquiv.toLinearMap</code> part of the chain each of which has separate lemmas about it</p>",
        "id": 522896358,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1749303526
    },
    {
        "content": "<p>Eg we often have <code>fContEquiv.toLinearEquiv = fEquiv</code>, and <code>fEquiv.toLinearMap = fMap</code> as lemmas but not <code>LinearMapClass.toLinearMap fContEquiv = fMap</code>, as having to write a lemma for every pair of connected nodes in the graph is much most costly than doing so for every edge.</p>",
        "id": 522896437,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1749303616
    },
    {
        "content": "<p>My experience is you almost never want <code>fContEquiv.toLinearEquiv = fEquiv</code> or <code>fEquiv.toLinearMap = fMap</code> or <code>LinearMapClass.toLinearMap fContEquiv = fMap</code> to be simp lemmas because you are losing information.</p>",
        "id": 522896590,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1749303809
    },
    {
        "content": "<p>... but you are also accessing a lot more existing lemmas</p>",
        "id": 522896708,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1749303943
    },
    {
        "content": "<p>Aren't you just missing lemmas for <code>fContEquiv</code>?<br>\nBut anyways my argument was based on these things were not simp lemmas or weren't even lemmas at all but if there are already a bunch of such lemmas in the simp set and people rely on them, then <code>symm</code> probably should go outward instead.</p>",
        "id": 522896874,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1749304128
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/channel/287929-mathlib4/topic/simp.20normal.20form.20for.20symm.20and.20coercions/near/522896590\">said</a>:</p>\n<blockquote>\n<p>to be simp lemmas because you are losing information.</p>\n</blockquote>\n<p>What information are you losing?</p>",
        "id": 522898002,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1749305378
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>, given what you explained, would you say that the simp lemma <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearEquiv.coe_toAddEquiv#doc\">docs#LinearEquiv.coe_toAddEquiv</a>, i.e.,</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">coe_toAddEquiv</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">toAddEquiv</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>is not a good simp lemma? On the right, there is an implicit application of <code>AddEquivClass.toAddEquiv</code>.</p>",
        "id": 522898600,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1749306081
    },
    {
        "content": "<p><del>I think that <code>AddEquivClass.toAddEquiv</code> should not be simp-normal form; so the lemma as is currently does no harm, but I think other lemmas we don't yet have should make <code>simpNF</code> complain about it.</del></p>",
        "id": 522898675,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1749306158
    },
    {
        "content": "<p>Yes, I think that is a bad simp lemma, and should go in the other direction</p>",
        "id": 522898713,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1749306190
    },
    {
        "content": "<p>But I think there are many like it</p>",
        "id": 522898717,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1749306198
    },
    {
        "content": "<p>ok, then this normal form story is definitely a mess. For <code>e : LinearEquiv</code>, should the normal form of <code>e.toAddEquiv</code> be <code>e.toAddEquiv</code> or the coercion from <code>AddEquivClass</code>? Eric says <code>e.toAddEquiv</code>, the library currently says the coercion. I won't start another poll!</p>",
        "id": 522899473,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1749307038
    },
    {
        "content": "<p>My opinion is that there should be no generic coercion at all from just <code>AddEquivClass</code></p>",
        "id": 522899499,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1749307073
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/287929-mathlib4/topic/simp.20normal.20form.20for.20symm.20and.20coercions/near/522898002\">said</a>:</p>\n<blockquote>\n<p>What information are you losing?</p>\n</blockquote>\n<p>For example <code>(Algebra.TensorProduct.comm R A B).toLinearMap (x * y)</code> should simp to <code>Algebra.TensorProduct.comm R A B x * Algebra.TensorProduct.comm R A B y</code> but if you add <code>(Algebra.TensorProduct.comm R A B).toLinearMap = TensorProduct.comm R A B</code> simp will now forget it is actually an algebra map and simp that to <code>TensorProduct.comm R A B (x * y)</code> (or you will have non-confluent simps)</p>",
        "id": 522899539,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1749307109
    },
    {
        "content": "<p>I think here you can just tell it to apply <code>f.toLinearMap x = f x</code> first?</p>",
        "id": 522899786,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1749307347
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 522900694,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1749308372
    },
    {
        "content": "<p>How would you achieve that? Is there a priority setting on simp lemmas?</p>",
        "id": 522900731,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1749308409
    },
    {
        "content": "<p>Yes, as well as pre and post settings</p>",
        "id": 522901153,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1749308834
    },
    {
        "content": "<p>In your example though the answer is to write the <code>comm_mul</code> lemmas, as it applies more generally for non-unital rings</p>",
        "id": 522901214,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1749308897
    },
    {
        "content": "<p>Given the discussion, and the fact that most people don't really care about the direction, I chose to push <code>symm</code> to the right to follow the usual convention for coercions. PR at <a href=\"https://github.com/leanprover-community/mathlib4/pull/25604\">#25604</a>. If people think it's a move in the right direction, I will do another PR to kill the coercion from EquivLike classes to Equivs, which messes up the normal form at several places. </p>\n<p>A note on the naming: the goal is, for each equiv class, to have simp lemmas of the form</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">lemma</span><span class=\"w\"> </span><span class=\"n\">coe_toEquiv</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">‚âÉ+</span><span class=\"n\">c</span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚áë</span><span class=\"n\">e.toEquiv</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">lemma</span><span class=\"w\"> </span><span class=\"n\">coe_symm_toEquiv</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">‚âÉ+</span><span class=\"n\">c</span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚áë</span><span class=\"n\">e.toEquiv.symm</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">e.symm</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">lemma</span><span class=\"w\"> </span><span class=\"n\">toEquiv_symm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">‚âÉ+</span><span class=\"n\">c</span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">e.symm.toEquiv</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">e.toEquiv.symm</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">lemma</span><span class=\"w\"> </span><span class=\"n\">toEquiv_trans</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e‚ÇÅ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">‚âÉ+</span><span class=\"n\">c</span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e‚ÇÇ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"bp\">‚âÉ+</span><span class=\"n\">c</span><span class=\"o\">[</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">e‚ÇÅ.trans</span><span class=\"w\"> </span><span class=\"n\">e‚ÇÇ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toEquiv</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">e‚ÇÅ.toEquiv.trans</span><span class=\"w\"> </span><span class=\"n\">e‚ÇÇ.toEquiv</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>Note how the naming I have used does not follow the dot notation order, but rather the logical order. I don't know if we have a clear convention for that, so please complain if you think I should use the opposite order (especially if you are <span class=\"user-mention\" data-user-id=\"387244\">@Ya√´l Dillies</span> or <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>, who I would trust most on these issues :-)</p>",
        "id": 522995926,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1749410721
    },
    {
        "content": "<p>Can you also explain what the target is for the lemmas about:</p>\n<ul>\n<li>concrete equivalences with various bundling (eg <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=WithLp.linearEquiv#doc\">docs#WithLp.linearEquiv</a>)</li>\n<li>Functorial equivalences</li>\n</ul>",
        "id": 522996041,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1749410825
    },
    {
        "content": "<p>Oops, I forgot the deprecations, so not ready for review.</p>",
        "id": 522996352,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1749411225
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">S√©bastien Gou√´zel</span> <a href=\"#narrow/channel/287929-mathlib4/topic/simp.20normal.20form.20for.20symm.20and.20coercions/near/522995926\">said</a>:</p>\n<blockquote>\n<p>I will do another PR to kill the coercion from EquivLike classes to Equivs</p>\n</blockquote>\n<p>Just warning you that it's difficult <span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span> <a href=\"https://github.com/leanprover-community/mathlib4/pull/21031\">#21031</a></p>",
        "id": 522996439,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1749411357
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">S√©bastien Gou√´zel</span> <a href=\"#narrow/channel/287929-mathlib4/topic/simp.20normal.20form.20for.20symm.20and.20coercions/near/522995926\">said</a>:</p>\n<blockquote>\n<p>Note how the naming I have used does not follow the dot notation order, but rather the logical order.</p>\n</blockquote>\n<p>All in favor <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 522996457,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1749411376
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/287929-mathlib4/topic/simp.20normal.20form.20for.20symm.20and.20coercions/near/522996041\">said</a>:</p>\n<blockquote>\n<p>Can you also explain what the target is for the lemmas about:</p>\n<ul>\n<li>concrete equivalences with various bundling (eg <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=WithLp.linearEquiv#doc\">docs#WithLp.linearEquiv</a>)</li>\n<li>Functorial equivalences</li>\n</ul>\n</blockquote>\n<p>I am not planning to change anything about these, and I don't know what the targets would be. The goal here is just one tiny improvement to our rules about normal forms (push symm outside) -- and I agree there is plenty of room for improvement elsewhere!</p>",
        "id": 522999527,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1749415488
    },
    {
        "content": "<p>Are we also killing the coercion from funlike classes to homs?</p>",
        "id": 523001866,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1749418444
    },
    {
        "content": "<p>Yes, that's what <span class=\"user-mention\" data-user-id=\"387244\">@Ya√´l Dillies</span> is doing in <a href=\"https://github.com/leanprover-community/mathlib4/pull/21031\">#21031</a>.</p>\n<p>By the way, <a href=\"https://github.com/leanprover-community/mathlib4/pull/25604\">#25604</a> is ready.</p>",
        "id": 523038032,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1749454109
    },
    {
        "content": "<p>can anyone find the thread where it was discussed whether <code>e.toRingEquiv.symm</code> or <code>e.symm.toRingEquiv</code> was the simpNF?</p>",
        "id": 543196208,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759702360
    },
    {
        "content": "<p>I want to see what the arguments for both sides are</p>",
        "id": 543196221,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759702374
    },
    {
        "content": "<p><a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/channel/287929-mathlib4/topic/simp.20normal.20form.20for.20symm.20and.20coercions/with/523038032\">#mathlib4 &gt; simp normal form for symm and coercions</a></p>",
        "id": 543313260,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1759756935
    },
    {
        "content": "<p>I am very confused while reading this thread</p>",
        "id": 543315191,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759757324
    },
    {
        "content": "<p>maybe I should ask chatgpt to summarise this thread</p>",
        "id": 543315431,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759757384
    },
    {
        "content": "<p>ChatGPT output:<br>\n==============</p>\n<h2><span aria-label=\"justice\" class=\"emoji emoji-2696\" role=\"img\" title=\"justice\">:justice:</span> Arguments for pushing <code>symm</code> <strong>to the left</strong></h2>\n<p>(i.e. canonical form <code>e.symm.toLinearEquiv</code>)<br>\n<strong>1. Analogy with function application</strong><br>\nIf <code>x</code> is a point, <code>e.toLinearEquiv.symm x</code> should simplify to <code>e.symm x</code>.<br>\nThis is more natural when <code>symm</code> is ‚Äúoutside‚Äù.<br>\n(Though Ya√´l Dillies noted this can be handled separately by projection lemmas.)<br>\n<strong>2. Fewer projection lemmas needed</strong><br>\nIf <code>symm</code> is on the left, you only need<br>\n<code>@[simp] lemma e.toLinearEquiv x = e x</code>,<br>\nwhereas pushing <code>symm</code> right requires both that and<br>\n<code>@[simp] lemma e.toLinearEquiv.symm x = e.symm x</code>.<br>\nSo ‚Äúleft‚Äù is slightly cheaper to maintain.<br>\n<strong>3. Conceptual clarity</strong><br>\nThis makes <code>symm</code> a property of the equivalence object itself, not of the linear map.<br>\nIt mirrors how we think of <code>e.symm</code> as a new equivalence rather than the inverse of a map.<br>\n<strong>4. Better alignment with lemmas like <code>(f e).symm = f e.symm</code></strong><br>\nIf <code>symm</code> is always outer, these standard functorial lemmas can apply directly.<br>\n<strong>Supporters / comments:</strong></p>\n<ul>\n<li>\n<p>Andrew Yang preferred this form because simp lemmas often have LHS <code>e.symm = ...</code>, not <code>e.toSomething.symm = ...</code>.</p>\n</li>\n<li>\n<p>Pushing <code>symm</code> inward (right) would require extra simp lemmas for every coercion chain.</p>\n</li>\n</ul>\n<hr>\n<h2><span aria-label=\"gear\" class=\"emoji emoji-2699\" role=\"img\" title=\"gear\">:gear:</span> Arguments for pushing <code>symm</code> <strong>to the right</strong></h2>\n<p>(i.e. canonical form <code>e.toLinearEquiv.symm</code>)<br>\n<strong>1. Coercion convention consistency</strong><br>\nJovan Gerbscheid and Ya√´l Dillies argued that since <code>toLinearEquiv</code> acts as a coercion, it should behave like numeric or algebraic coercions, where operations (like <code>symm</code>, <code>neg</code>, <code>+</code>) are pushed <em>outward</em>.<br>\nThis matches <code>norm_cast</code>/<code>push_cast</code> conventions.<br>\n<strong>2. Analogy with negation and arithmetic</strong><br>\nS√©bastien‚Äôs point (d):<br>\nfor morphisms <code>c</code>, <code>c (-x)</code> simplifies to <code>- c x</code>, i.e. <code>x.neg.c ‚Üí x.c.neg</code>.<br>\nBy analogy, we should push <code>symm</code> outward/rightward.<br>\n<strong>3. Simpler normal forms for chained coercions</strong><br>\nIf <code>e : ContinuousLinearEquiv</code>, we have chains like<br>\n<code>e.toLinearEquiv.toLinearMap = e.toContinuousLinearMap.toLinearMap</code>.<br>\nPushing <code>symm</code> right gives a uniform ‚Äúoutermost operation‚Äù approach.<br>\n<strong>4. Convention for coercions in mathlib</strong><br>\nS√©bastien concluded that, for predictability, we should ‚Äúfollow the usual convention for coercions‚Äù ‚Äî meaning push <code>symm</code> <em>outwards</em> (right).<br>\n<strong>Supporters / comments:</strong></p>\n<ul>\n<li>\n<p>Jovan and Ya√´l noted that numeric coercions already behave this way.</p>\n</li>\n<li>\n<p>Eric Wieser agreed that if coercions are treated uniformly, this is consistent.</p>\n</li>\n<li>\n<p>S√©bastien later implemented this choice in PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/25604\">#25604</a>.</p>\n</li>\n</ul>",
        "id": 543317010,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759757732
    },
    {
        "content": "<hr>\n<p>so I'm currently in the \"left\" camp just because I want <code>e.toLinearMap.symm x = e.symm x</code> to be more easily provable.</p>\n<p>I don't think the analogies from the \"right\" camp make a lot of sense, because when you do something like f(-x) = -f(x), the role of f (which is \"toLinearMap\") is actually transporting from less structure to more structure, e.g. from int to ring, you never go from ring to int.</p>\n<p>but the coercions here (i.e. toLinearMap) goes from more structure to less structure, so I don't think analogy applies.</p>",
        "id": 543317733,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759757903
    },
    {
        "content": "<p>I don't think \"convention\" is a good argument and I'm surprised people went with the right when the left has an actual argument (which is the function application above)</p>",
        "id": 543318928,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759758175
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/287929-mathlib4/topic/simp.20normal.20form.20for.20symm.20and.20coercions/near/543317733\">said</a>:</p>\n<blockquote>\n<p>so I'm currently in the \"left\" camp just because I want <code>e.toLinearMap.symm x = e.symm x</code> to be more easily provable.</p>\n</blockquote>\n<p>With the current approach, this is registered as a simp lemma, so definitely easily provable!</p>\n<p>Both approaches have pros and cons. The main point was to make one choice, to have a coherent mathlib.</p>",
        "id": 543330940,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1759760846
    }
]