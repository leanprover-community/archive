[
    {
        "content": "<p>Here's a style guideline question that arose in <a href=\"https://github.com/leanprover-community/mathlib4/pull/30508\">#30508</a>: should there be an exception to the \"hypotheses left of colon\" rule for pattern matching? More concretely, several changes in the PR are of the following kind, changing</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">listSum_le</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddLeftMono</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">abv</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">abv</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">abv</span><span class=\"bp\">.</span><span class=\"n\">add_le</span><span class=\"w\"> </span><span class=\"bp\">..</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">add_le_add_left</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">abv</span><span class=\"w\"> </span><span class=\"n\">head</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>by</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">listSum_le</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddLeftMono</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">abv</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">abv</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sum</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">grw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">map_cons</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">sum_cons</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">sum_cons</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">abv</span><span class=\"bp\">.</span><span class=\"n\">add_le</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">listSum_le</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>which includes a golf (that I like), but also moves hypotheses \"right of the colon\" by introducing a \\forall quantifier in the theorem type. On the other hand, that introduction enables golfing the proof by a line, because pattern matching becomes available.</p>\n<p>I'd like to have a general vibe check: should this be an exception to the style guide, or do we consider saving one line not desirable?</p>",
        "id": 545454034,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1760654275
    },
    {
        "content": "<p>(I personally don't feel strongly, but feel we should not knowingly violate our style guide.)</p>",
        "id": 545454062,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1760654293
    },
    {
        "content": "<p>I think the former is still preferable because it might get golfed into an induction &lt;;&gt; grind call</p>",
        "id": 545455339,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1760655142
    },
    {
        "content": "<p>I didn't like this change because it gives you a <code>match</code> and it messes up the equations</p>",
        "id": 545456197,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1760655770
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Style.3A.20hypothesis.20left.20of.20colon.20vs.20pattern.20matching/near/545455339\">said</a>:</p>\n<blockquote>\n<p>I think the former is still preferable because it might get golfed into an induction &lt;;&gt; grind call</p>\n</blockquote>\n<p>Concretely, you could write:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Semiring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Semiring</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PartialOrder</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">abv</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AbsoluteValue</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">AbsoluteValue</span><span class=\"bp\">.</span><span class=\"n\">listSum_le'</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddLeftMono</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">abv</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">abv</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">map_zero</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">le_refl</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">listSum_le</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 545459641,
        "sender_full_name": "Chris Henson",
        "timestamp": 1760658122
    },
    {
        "content": "<p>My concern is that disallowing this would completely forbid pattern-matching in proofs, which seems unreasonable</p>",
        "id": 545492058,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1760682319
    },
    {
        "content": "<p>I don't disagree that there may be further golfs available in specific cases</p>",
        "id": 545492664,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1760682633
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Style.3A.20hypothesis.20left.20of.20colon.20vs.20pattern.20matching/near/545492058\">said</a>:</p>\n<blockquote>\n<p>My concern is that disallowing this would completely forbid pattern-matching in proofs, which seems unreasonable</p>\n</blockquote>\n<p>I'm not saying you can't <code>match</code> I'm saying I don't like when you unname the hypotheses as a result of putting the <code>match</code> in that spot</p>",
        "id": 545532148,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1760695909
    },
    {
        "content": "<p>and of course by you I mean everyone</p>",
        "id": 545532204,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1760695928
    },
    {
        "content": "<p>What do you mean by \"unname\"? There is no hypothesis anymore, you directly call the lemma recursively (and so it is \"named\" like the lemma).</p>",
        "id": 545533785,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1760696503
    },
    {
        "content": "<p>it means the name of the hypothesis gets erased</p>",
        "id": 545535245,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1760696974
    },
    {
        "content": "<p>I don't understand what you are talking about. Can you show an example?</p>",
        "id": 545538382,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1760698106
    },
    {
        "content": "<p>Here like this</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">k1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hn</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero_lt_of_ne_zero</span><span class=\"w\"> </span><span class=\"n\">hn</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">k1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hn</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ_ne_zero</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">k2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hn</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero_lt_of_ne_zero</span><span class=\"w\"> </span><span class=\"n\">hn</span>\n\n<span class=\"c1\">-- uhoh</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">k2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hn</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ_ne_zero</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 545542780,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1760699553
    },
    {
        "content": "<ol>\n<li>This is not what Michael and I are talking about. There is no <code>hn</code>-like hypothesis in any of the code snippets above, except yours.</li>\n<li>This is easily fixable without getting rid of the pattern-matching:</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">k1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hn</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero_lt_of_ne_zero</span><span class=\"w\"> </span><span class=\"n\">hn</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">k1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hn</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ_ne_zero</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">k2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hn</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hn</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero_lt_of_ne_zero</span><span class=\"w\"> </span><span class=\"n\">hn</span>\n\n<span class=\"c1\">-- works</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">k2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hn</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ_ne_zero</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 545543284,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1760699715
    },
    {
        "content": "<ol>\n<li>Ok it doesn't apply to this case specifically but this is a minor annoyance I have come across</li>\n<li>but unfortunately no one writes like that (or at least, not that I've seen anywhere) and I think <del>it sets off an unused variable linter</del> (after I tested, it doesn't seem to be?)</li>\n</ol>",
        "id": 545544535,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1760700107
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Style.3A.20hypothesis.20left.20of.20colon.20vs.20pattern.20matching/near/545544535\">said</a>:</p>\n<blockquote>\n<p>unfortunately no one writes like that</p>\n</blockquote>\n<p><em>That</em> you can complain about. But we shouldn't ban pattern-matching because people sometimes misuse it!</p>",
        "id": 545545189,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1760700358
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"687698\">Chris Henson</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Style.3A.20hypothesis.20left.20of.20colon.20vs.20pattern.20matching/near/545459641\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Style.3A.20hypothesis.20left.20of.20colon.20vs.20pattern.20matching/near/545455339\">said</a>:</p>\n<blockquote>\n<p>I think the former is still preferable because it might get golfed into an induction &lt;;&gt; grind call</p>\n</blockquote>\n<p>Concretely, you could write:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Semiring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Semiring</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PartialOrder</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">abv</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AbsoluteValue</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">AbsoluteValue</span><span class=\"bp\">.</span><span class=\"n\">listSum_le'</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddLeftMono</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">abv</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">abv</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">map_zero</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">le_refl</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">listSum_le</span><span class=\"o\">]</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Your suggestion got me confused for a very long time: It is not valid, because you renamed <code>listSum_le</code> to <code>listSum_le'</code> in the statement but not in the proof. Therefore all that grind does is apply the existing lemma from mathlib!</p>",
        "id": 545553406,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1760703073
    },
    {
        "content": "<p>In fact, none of the proofs in <a href=\"https://github.com/leanprover-community/mathlib4/pull/30508\">#30508</a> that Michael is concerned about can be proved with <code>induction ... &lt;;&gt; grind [...]</code>. This is expected, since grind doesn't know about generalised rewriting, and this is a PR about <code>grw</code> and <code>gcongr</code>.</p>",
        "id": 545553577,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1760703133
    },
    {
        "content": "<p>I left a comment at the PR which is now <a href=\"https://github.com/leanprover-community/mathlib4/pull/30632\">#30632</a>. Although your matching style might be nice in some situations, I think there is also value in keeping the proof (and statement) style consistent throughout mathlib, and sticking to the <code>induction</code> tactic.</p>",
        "id": 545837502,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1760887603
    },
    {
        "content": "<p>In fact, a lot of proofs <em>already</em> use pattern-matching. This is the default in all <code>List</code> files for example. I therefore do not buy this consistency argument.</p>",
        "id": 545837870,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1760887972
    },
    {
        "content": "<p>Maybe, but I'd say that matching on lists feels a bit different from matching on natural numbers.</p>",
        "id": 545841397,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1760891630
    },
    {
        "content": "<p>My reading is that your stance, <span class=\"user-mention\" data-user-id=\"479299\">@Jovan Gerbscheid</span>, is \"matching on lists is fine, but use induction for natural numbers, please\"? Is that a correct reading? <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> What do you think here?</p>",
        "id": 545842089,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1760892413
    },
    {
        "content": "<p>I don't really have a horse in this race; I'm sympathetic to a consistency argument --- but am not sure if matching on natural numbers is used more commonly than induction. (For lists, it might well be, in which case I'm happy to go with it!)</p>",
        "id": 545842129,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1760892459
    },
    {
        "content": "<p>Yes. If you are proving a list lemma where the list is the main object of study, and if it is very obvious that the proof should go by induction, then I think that is comparatively a better situation to do a proof using recursion and an implicit <code>match</code>.</p>\n<p>But for proofs with natural numbers, I think it is cleaner to have an explicit <code>induction</code> tactic. This comes with the added benefits that the proof is more flexible (you can add a tactic before <code>induction</code>, you can do <code>induction n &lt;;&gt; grind</code>) and that the theorem headers look consistent.</p>",
        "id": 545987615,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1760968910
    },
    {
        "content": "<p>There is also the case to be made that more proofs can use <code>fun_induction</code></p>",
        "id": 545988162,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1760969017
    }
]