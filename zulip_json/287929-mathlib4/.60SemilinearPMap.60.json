[
    {
        "content": "<p>I want to generalize unbounded linear operators <code>LinearPMap</code> to antilinear operators, with applications to the Tomita-Takesaki modular theory for von Neumann algebras. It seems to me that the most natural thing is to generalize <code>LinearPMap</code> to semilinear maps, and change <code>LinearPMap</code> to an <code>abbrev</code>. However, <code>LinearPMap</code> is imported in several files and the refactor would not be small. Also the natural namespace would be <code>SemilinearPMap</code> but this would be inconsistent with <code>LinearMap</code> namespace. Is this a good idea? <span class=\"user-mention\" data-user-id=\"412682\">@Moritz Doll</span> <span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span> <span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> </p>\n<p>Besides, I noticed that LinearAlgebra/LinearPMap.lean takes explicit universes. Can I switch to <code>Type*</code>?</p>\n<p>My tentative definitions are</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- A `SemilinearPMap σ E F` or `E →ₛₗ.[σ] F` is a semilinear map from a submodule of `E` to</span>\n<span class=\"sd\">`F`. -/</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">SemilinearPMap</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">→+*</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">domain</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">E</span>\n<span class=\"w\">  </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">domain</span><span class=\"w\"> </span><span class=\"bp\">→ₛₗ</span><span class=\"o\">[</span><span class=\"n\">σ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">F</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">inherit_doc</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">notation</span><span class=\"o\">:</span><span class=\"mi\">25</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"s2\">\" →ₛₗ.[\"</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"o\">:</span><span class=\"mi\">25</span><span class=\"w\"> </span><span class=\"s2\">\"] \"</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">:</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">SemilinearPMap</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"n\">F</span>\n\n<span class=\"sd\">/-- A `LinearPMap R E F` or `E →ₛₗ.[σ] F` is a linear map from a submodule of `E` to `F`. -/</span>\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">LinearPMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">SemilinearPMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">RingHom</span><span class=\"bp\">.</span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"n\">F</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">inherit_doc</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">notation</span><span class=\"o\">:</span><span class=\"mi\">25</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"s2\">\" →ₗ.[\"</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">:</span><span class=\"mi\">25</span><span class=\"w\"> </span><span class=\"s2\">\"] \"</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">:</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">LinearPMap</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"n\">F</span>\n</code></pre></div>",
        "id": 575944128,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1772088678
    },
    {
        "content": "<p>Why not just generalize <code>LinearPMap</code> in place to the semilinear setting? That's how <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearMap#doc\">docs#LinearMap</a> is done.</p>",
        "id": 575944348,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1772088792
    },
    {
        "content": "<p>And yes, this refactor is absolutely a thing that should happen</p>",
        "id": 575944458,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1772088842
    },
    {
        "content": "<p>In <a href=\"https://github.com/leanprover-community/mathlib4/pull/20663\">#20663</a> I created a PFunLike typeclass and mimicked the homomorphism hierarchy for partial homs, but I didn’t get it into mathlib. See this discussion: <a href=\"#narrow/channel/287929-mathlib4/topic/ContinuousLinearPMap/with/490216152\">https://leanprover.zulipchat.com/#narrow/channel/287929-mathlib4/topic/ContinuousLinearPMap/with/490216152</a></p>",
        "id": 575947713,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1772090282
    },
    {
        "content": "<p>I see, then for the moment I'll go with the following</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- A `SemilinearPMap σ E F` or `E →ₛₗ.[σ] F` is a semilinear map from a submodule of `E` to</span>\n<span class=\"sd\">`F`. -/</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">LinearPMap</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">→+*</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">domain</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">E</span>\n<span class=\"w\">  </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">domain</span><span class=\"w\"> </span><span class=\"bp\">→ₛₗ</span><span class=\"o\">[</span><span class=\"n\">σ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">F</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">inherit_doc</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">notation</span><span class=\"o\">:</span><span class=\"mi\">25</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"s2\">\" →ₛₗ.[\"</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"o\">:</span><span class=\"mi\">25</span><span class=\"w\"> </span><span class=\"s2\">\"] \"</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">:</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">LinearPMap</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"n\">F</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">inherit_doc</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">notation</span><span class=\"o\">:</span><span class=\"mi\">25</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"s2\">\" →ₗ.[\"</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">:</span><span class=\"mi\">25</span><span class=\"w\"> </span><span class=\"s2\">\"] \"</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">:</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">LinearPMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">RingHom</span><span class=\"bp\">.</span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"n\">F</span>\n</code></pre></div>",
        "id": 575965956,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1772096211
    },
    {
        "content": "<p>To define <code>graph</code> with <code>[Module R E] [Module S F] {σ : R →+* S} (f : E →ₛₗ.[σ] F)</code>, I should define a new <code>[Module R (E × F)]</code> instance using <code>σ</code>, right?</p>",
        "id": 575989512,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1772102436
    },
    {
        "content": "<p>or introduce a type synonym?</p>",
        "id": 575994838,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1772103972
    },
    {
        "content": "<p>This is why I never semilinearized the closed graph theorem...</p>",
        "id": 576036077,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1772115719
    },
    {
        "content": "<p>mmm, but this refactor should happen, right? I will try to go with a <del>type synonym</del> structure</p>",
        "id": 576045228,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1772117785
    },
    {
        "content": "<p>Is it better to have a <code>Module (R x S) (E x F)</code> instance? Probably that creates diamonds too.</p>",
        "id": 576058093,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1772120834
    },
    {
        "content": "<p>What's going to be the instance using <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>σ</mi></mrow><annotation encoding=\"application/x-tex\">\\sigma</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span></span></span></span>? Can we have some typeclass assumptions instead?</p>",
        "id": 576058514,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1772120944
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60SemilinearPMap.60/near/576058093\">said</a>:</p>\n<blockquote>\n<p>Is it better to have a <code>Module (R x S) (E x F)</code> instance? Probably that creates diamonds too.</p>\n</blockquote>\n<p>really? don't we want the graph of an antilinear operator to be a (twisted) <code>ℂ</code>-linear space, instead of <code>ℂ x ℂ</code>-linear?</p>",
        "id": 576060552,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1772121437
    },
    {
        "content": "<p>by partially mimiking <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SemidirectProduct#doc\">docs#SemidirectProduct</a> I'm trying something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">linter</span><span class=\"bp\">.</span><span class=\"n\">unusedVariables</span><span class=\"w\"> </span><span class=\"n\">false</span>\n<span class=\"kd\">@[</span><span class=\"n\">ext</span><span class=\"kd\">]</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">twistedProductModule</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">→+*</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ms</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">left</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">E</span>\n<span class=\"w\">  </span><span class=\"n\">right</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">→+*</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">mr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ms</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">twistedProductModule</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"n\">mr</span><span class=\"w\"> </span><span class=\"n\">ms</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">twistedProductModule</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">left</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">left</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">right</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">right</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>although this way we would have to redeclare <code>AddCommGroup</code> instance in full</p>",
        "id": 576061277,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1772121604
    },
    {
        "content": "<p>Where do you use <code>σ</code> and how?</p>",
        "id": 576147321,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1772151247
    },
    {
        "content": "<p>You can get <code>AddCommGroup</code> from equivalence to the product type.</p>",
        "id": 576147345,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1772151263
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60SemilinearPMap.60/near/576147345\">said</a>:</p>\n<blockquote>\n<p>You can get <code>AddCommGroup</code> from equivalence to the product type.</p>\n</blockquote>\n<p>could you tell me how it works?</p>",
        "id": 576208197,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1772182694
    },
    {
        "content": "<p>I will use it in <code>SMul</code> and <code>Module</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SMul</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">twistedProductModule</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"n\">mr</span><span class=\"w\"> </span><span class=\"n\">ms</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">smul</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">left</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">right</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 576208198,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1772182694
    },
    {
        "content": "<p>How does it look? <a href=\"https://github.com/leanprover-community/mathlib4/pull/35877\">#35877</a> <img alt=\":pr-open:\" class=\"emoji\" src=\"https://avatars.zulip.com/3121/emoji/images/6f19606a.png\" title=\"pr-open\"> <span aria-label=\"memo\" class=\"emoji emoji-1f4dd\" role=\"img\" title=\"memo\">:memo:</span></p>",
        "id": 576385842,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1772250076
    },
    {
        "content": "<p>I don't like that we have to name the module instances, in practice they won't have names. Surely mathlib already has the \"restrict scalars\" function which takes an S-module and a ring homomorphism R-&gt;S and returns an R-module, and now you're just taking the product of this with another R-module (and the product is already an R-module in mathlib) and arguing that we need a special construction for this? That sounds like a weak argument.</p>",
        "id": 576405656,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1772269204
    },
    {
        "content": "<p>BTW, one more way to deal with it is to put a type synonym on <code>R</code> instead of the product.</p>",
        "id": 576407621,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1772270834
    },
    {
        "content": "<p>Not sure which one is better.</p>",
        "id": 576407736,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1772270909
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  I'm not arguing that this is good. I was asking how to do it, didn't really get an answer so I tried.</p>\n<p>Do I understand correctly that you are suggesting to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RestrictScalars.module#doc\">docs#RestrictScalars.module</a> ? It seems that this assumes <code>Algebra R S</code> which is stronger than just <code>R →+* S</code>, is it correct?</p>\n<p><span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span> do you mean this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">→+*</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">withTwist</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">→+*</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">R</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SMul</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">withTwist</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">smul</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SMul</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">withTwist</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">smul</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">SMul</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">withTwist</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 576415291,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1772277791
    },
    {
        "content": "<p>Indeed it looks like <code>RestrictScalars</code> won't work for you. Am I right in thinking that <code>Algebra R S</code> is not possible in your situation? Then it seems like <code>withTwist</code> (which should be <code>WithTwist</code> because it's a type) would be the way to go, if we don't have it already. I think experts would have to weigh in about whether this should be a type synonym or a one-field structure. You should define the sigma-semilinear map from WithTwist R to R. It should all be done for semirings and addcommmonoids.</p>",
        "id": 576420576,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1772282189
    }
]