[
    {
        "content": "<p>Why is <code>Stream'</code> (<a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Stream/Defs.html\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Stream/Defs.html</a>) called <code>Stream'</code>?  I understand there is already a <code>Stream</code> type.  But wouldn't <code>Sequence</code> or <code>Seq</code> be a more appropriate and informative name?  <code>Stream'.Seq</code> can be called <code>Sequence.Stream</code> instead.  Isn't the intuitive idea that a \"stream\" is a finite or infinite list?</p>",
        "id": 541165155,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1758700703
    },
    {
        "content": "<p>I'd love to get rid of these primed names. And I agree that <code>Sequence</code> would be more understandable to the average Mathlib user.</p>",
        "id": 541165326,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1758700762
    },
    {
        "content": "<p>Would agree with this. Primed names bad!</p>",
        "id": 541400910,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1758789577
    },
    {
        "content": "<p>I am not sure I love this definition of <code>Steam'</code> but it might be the simplest possible choice in the circumstances. IIRC the !proper\" definition of this sort of type uses coinduction which Lean does not (?) support well?</p>",
        "id": 541401151,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1758789646
    },
    {
        "content": "<p>In my automata theory development (<a class=\"stream-topic\" data-stream-id=\"113486\" href=\"/#narrow/channel/113486-announce/topic/Automata.20theory.20in.20Lean4/with/541344239\">#announce &gt; Automata theory in Lean4</a> ), I use types of the form <code>‚Ñï ‚Üí X</code> to model infinite words/sequences.  I would like to use <code>Strem'</code>, but am really put off by its awful name.  I'm not sure coinduction is strictly needed, because the automata theory papers I've read just directly index into infinite (or finite) words in their definitions and proofs.  This is not to say coinduction cannot be useful, but I think we should first have some evidence of its usefulness.</p>",
        "id": 541500490,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1758817543
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hern√°ndez</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Why.20is.20Stream'.20called.20Stream'.3F/near/541165326\">said</a>:</p>\n<blockquote>\n<p>I'd love to get rid of these primed names. And I agree that <code>Sequence</code> would be more understandable to the average Mathlib user.</p>\n</blockquote>\n<p>But we also have <code>Stream'.Seq</code> for possibly finite sequences :)</p>",
        "id": 541545153,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1758834641
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110637\">Ching-Tsun Chou</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Why.20is.20Stream'.20called.20Stream'.3F/near/541500490\">said</a>:</p>\n<blockquote>\n<p>In my automata theory development (<a class=\"stream-topic\" data-stream-id=\"113486\" href=\"/#narrow/channel/113486-announce/topic/Automata.20theory.20in.20Lean4/with/541344239\">#announce &gt; Automata theory in Lean4</a> ), I use types of the form <code>‚Ñï ‚Üí X</code> to model infinite words/sequences.  I would like to use <code>Strem'</code>, but am really put off by its awful name.  I'm not sure coinduction is strictly needed, because the automata theory papers I've read just directly index into infinite (or finite) words in their definitions and proofs.  This is not to say coinduction cannot be useful, but I think we should first have some evidence of its usefulness.</p>\n</blockquote>\n<p>Coinduction for <code>Stream'.Seq</code> was very useful in my tactic <a href=\"#narrow/channel/113486-announce/topic/New.20tactic.3A.20.60compute_asymptotics.60/near/538636093\">#announce &gt; New tactic: &#96;compute_asymptotics&#96; @ üí¨</a></p>",
        "id": 541545580,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1758834835
    },
    {
        "content": "<p>I suggest above that we rename <code>Stream'</code> to <code>Sequence</code> or <code>Seq</code> and <code>Stream'.Seq</code> to <code>Sequence.Stream</code>.  I assume the informal notion of a \"stream\" means a finite or infinite sequence.</p>",
        "id": 541545630,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1758834867
    },
    {
        "content": "<p>I feel the opposite way: \"stream\" is infinite, \"sequence\" is possibly finite</p>",
        "id": 541546192,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1758835181
    },
    {
        "content": "<p>I'm not sure that that agrees with <code>Stream</code> (without the prime):<br>\n<a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Data/Stream.html#Stream\">https://leanprover-community.github.io/mathlib4_docs/Init/Data/Stream.html#Stream</a><br>\nI wouldn't mind if we rename <code>Stream'</code> to (for example) <code>InfSeq</code>.  The current name <code>Stream'</code> is just confusing.</p>",
        "id": 541546983,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1758835623
    },
    {
        "content": "<p>As it now stands, we have:</p>\n<ul>\n<li>Finite sequences: <code>List</code></li>\n<li>Infinite sequences: <code>Stream'</code></li>\n<li>Finite or infinite sequences: <code>Stream'.Seq</code> and <code>Stream</code>.<br>\nIt just doesn't make sense.</li>\n</ul>",
        "id": 541547572,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1758835943
    },
    {
        "content": "<p>If anything should be called <code>Stream'</code>, it should be what is currently <code>Stream'.Seq</code>.</p>",
        "id": 541547749,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1758836038
    },
    {
        "content": "<p>I wouldn't call it <code>InfSeq</code>, since to me <code>Inf</code> means \"infimum\"</p>",
        "id": 541576384,
        "sender_full_name": "Niels Voss",
        "timestamp": 1758857110
    },
    {
        "content": "<p>Personally I prefer <code>Sequence</code> or  even <code>Seq</code>.    My suggestion of <code>InfSeq</code> was in response to Vasilii's comment.  Another option is <code>OmegaSeq</code> or <code>œâSeq</code>.</p>",
        "id": 541582455,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1758861678
    },
    {
        "content": "<p>Answering the question in the title, not the question \"how should it be called?\": it was called <code>stream</code> in Lean 3, but Lean 4 got something else called <code>Stream</code>, so we had to rename. Adding <code>'</code> was the easiest way to go forward with porting Mathlib to Lean 4.</p>",
        "id": 541669824,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1758893535
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110637\">Ching-Tsun Chou</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Why.20is.20Stream'.20called.20Stream'.3F/near/541582455\">said</a>:</p>\n<blockquote>\n<p>Personally I prefer <code>Sequence</code> or  even <code>Seq</code>.    My suggestion of <code>InfSeq</code> was in response to Vasilii's comment.  Another option is <code>OmegaSeq</code> or <code>œâSeq</code>.</p>\n</blockquote>\n<p>Seq is maybe confusing because of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Seq#doc\">docs#Seq</a></p>",
        "id": 541673175,
        "sender_full_name": "Chris Henson",
        "timestamp": 1758894606
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Why.20is.20Stream'.20called.20Stream'.3F/near/541669824\">said</a>:</p>\n<blockquote>\n<p>Answering the question in the title, not the question \"how should it be called?\": it was called <code>stream</code> in Lean 3, but Lean 4 got something else called <code>Stream</code>, so we had to rename. Adding <code>'</code> was the easiest way to go forward with porting Mathlib to Lean 4.</p>\n</blockquote>\n<p>That's really an unfortunate decision.  If <code>Stream'.Seq</code> had existed when <code>Stream</code> was <code>stream</code>, the new <code>Stream</code> should have been called <code>Sequence</code> to be consistent with <code>Stream'.Seq</code>.  Now we end up with a <code>Stream'</code> that's really not similar to <code>Stream</code> which in turn is more similar to <code>Stream'.Seq</code>.</p>",
        "id": 541750424,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1758923393
    },
    {
        "content": "<p>It was certainly a reasonable decision, if perhaps one with an undesirable outcome. Probably a PR to rename it (with deprecations) would be acceptable, if the new name is a significant improvement</p>",
        "id": 541752977,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1758925042
    },
    {
        "content": "<p><code>Stream'</code> was probably named after Coq's <code>Stream</code>: <a href=\"https://rocq-prover.org/doc/v8.10/stdlib/Coq.Lists.Streams.html\">https://rocq-prover.org/doc/v8.10/stdlib/Coq.Lists.Streams.html</a></p>",
        "id": 541799593,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1758973649
    },
    {
        "content": "<p>In <a href=\"https://people.inf.elte.hu/divip/AgdaTutorial/Revise.Coinduction.html\">Agda</a>, our <code>Stream'</code> is also called <code>Stream</code>, but our <code>Stream'.Seq</code> is called <code>Colist</code>. That was the word I had been searching for when trying to find this type. I only came across it later, after I had already made my own version. So yes, discoverability is probably not great.</p>",
        "id": 541810956,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1758983501
    },
    {
        "content": "<p>It doesn't seem like there are strong arguments in favor of the current name(s), so if someone would like to guide us to consensus on which new names we should go with, I agree that a PR would be welcome. In any case, improvements to docs to help discoverability (including mentioning alternative names / analogous types in other widely-used systems for basic definitions) are always welcome!</p>",
        "id": 541811579,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1758983995
    },
    {
        "content": "<p>I suggested above that <code>Stream'</code> and <code>Stream'.Seq</code> be renamed to <code>Sequence</code> and <code>Stream'</code>, respectively.  Another option for the latter is <code>Colist</code>, as Vasilii pointed out.</p>",
        "id": 541922204,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759097934
    },
    {
        "content": "<p>If people feel strongly that <code>Sequence</code> should encompass both finite and infinite sequences, then <code>Stream'</code> can renamed to <code>œâSequence</code>.</p>",
        "id": 541923165,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759099309
    },
    {
        "content": "<p>I usually see the coinductive type of infinite sequences referred to as a \"stream\" (Coq, Agda, Haskell, <a href=\"https://ncatlab.org/nlab/show/coinductive+type\">nlab</a>). Could you point me to a source where the term <code>œâSequence</code> is used?</p>",
        "id": 541923474,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1759099811
    },
    {
        "content": "<p>Your view is a programmer's view.  In normal mathematics, the current <code>Stream'</code> is just called sequences, infinite sequence, or œâ-sequences.</p>",
        "id": 541923920,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759100429
    },
    {
        "content": "<p>For example, the page attached below is taken from:<br>\nThomas, Wolfgang (1990). \"Automata on infinite objects\". In Van Leeuwen (ed.). Handbook of Theoretical Computer Science. Elsevier. pp. 133‚Äì164.<br>\n<a href=\"/user_uploads/3121/asZIQD4AgS_TRV7vFL6xlAZz/automata-on-infinite-words.pdf\">automata on infinite words.pdf</a></p>",
        "id": 541924169,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759100708
    },
    {
        "content": "<p>As you can see, even in some parts of theoretical computer science, people talk about \"words\", \"sequences\", or \"œâ-sequences\", and never use the word \"stream\".</p>",
        "id": 541924246,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759100816
    },
    {
        "content": "<p>Or œâ-words</p>",
        "id": 541924265,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1759100841
    },
    {
        "content": "<p>Renaming <code>Stream'</code> to <code>œâWords</code> would be fine with me.  But I suspect the term \"word\" is more limited to automata theory and related fields than the more generic term \"sequence\".</p>",
        "id": 541924346,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759100989
    },
    {
        "content": "<p>Is this type used in context of normal mathematics? I think most results about it treats this as a coinductive type. The only place where it's used outside <code>Data</code> is for continued fractions where it again represents a corecursive computation.</p>",
        "id": 541924408,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1759101061
    },
    {
        "content": "<p>My opinion is that we should treat <code>Stream'</code> as a coinductive type, and its definition as <code>‚Ñï ‚Üí Œ±</code> is just an implementation detail, since Lean doesn't support coinduction internally</p>",
        "id": 541924527,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1759101210
    },
    {
        "content": "<p>As it now stands, <code>Stream'</code> is not defined coinductively.  It is defined as sequences!<br>\n<a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Stream/Defs.html#Stream\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Stream/Defs.html#Stream</a>'</p>",
        "id": 541924611,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759101330
    },
    {
        "content": "<p>Yes, because there is no way to define things coinductively in Lean</p>",
        "id": 541924644,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1759101374
    },
    {
        "content": "<p>And I want to use it as sequences in my project on automata theory, where no one uses the term \"stream\".</p>",
        "id": 541924657,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759101398
    },
    {
        "content": "<p>What does it give to you compared to using <code>‚Ñï ‚Üí Œ±</code>?</p>",
        "id": 541924696,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1759101460
    },
    {
        "content": "<p>First, I don't want to reprove already proved theorems.  Second, <code>‚Ñï ‚Üí Œ±</code> does not let me use the dot-notation.</p>",
        "id": 541924756,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759101551
    },
    {
        "content": "<p>I think it's the right spelling when you need regular sequences and don't need coinduction, for example: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=TopologicalSpace.denseSeq#doc\">docs#TopologicalSpace.denseSeq</a></p>",
        "id": 541924777,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1759101580
    },
    {
        "content": "<p>I don't think how a data type is defined should be an issue at all.  What matters is the API of the data type.  I do want to use many of the existing APIs of <code>Stream'</code>, like <code>get</code>, <code>take</code>, <code>drop</code>, <code>append</code> etc.  I don't want to define a separate version of them and reprove the theorems.  That defeats the whole point of having mathlib.</p>",
        "id": 541924932,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759101785
    },
    {
        "content": "<p>In fact, I've redefined and reproved quite a few of them in terms of <code>‚Ñï ‚Üí Œ±</code>:<br>\n<a href=\"https://github.com/ctchou/AutomataTheory/blob/main/AutomataTheory/Sequences/Basic.lean\">https://github.com/ctchou/AutomataTheory/blob/main/AutomataTheory/Sequences/Basic.lean</a><br>\nI don't want to continue doing that.  I want to use a better-named <code>Stream'</code> and contribute to its API.</p>",
        "id": 541925204,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759102197
    },
    {
        "content": "<p>By the way, even leaving aside the issue of whether \"sequences' and \"œâ-sequences\" are reasonable names, the way that the term \"stream\" is used in Lean is just inconsistent: <code>Stream'</code> is always infinite, but <code>Stream</code> and <code>Stream'.Seq</code> can be either finite or infinite.  Why?  If we consistently use \"stream\" to refer to infinite sequences (as in Rocq), that would be OK with me.  But are we going to rename <code>Stream</code> (without the prime) to <code>Colist</code> or something else?</p>",
        "id": 541957107,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759129305
    },
    {
        "content": "<p>I've explained the source of this inconsistency above: <code>Stream'</code> and <code>Stream'.Seq</code> come from Lean 3 while <code>Stream</code> is a completely different concept introduced in Lean 4. You don't have to convince people that the current naming is bad (I guess, everyone involved agrees with this). You should convince people that the new names you propose are good.</p>",
        "id": 541978736,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1759136528
    },
    {
        "content": "<p>I have already stated my reasons above.  <code>Sequence</code> is a name any mathematician can understand and is literally what <code>Stream'</code> is currently defined to be.  <code>Stream'.Seq</code> can be renamed to <code>Stream'</code> for its resemblance to <code>Stream</code> (without the prime).</p>",
        "id": 542102151,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759167810
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> What do you think as the author of these files?</p>",
        "id": 542133149,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1759177467
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110637\">@Ching-Tsun Chou</span> Could you please summarize different proposals (pairs of new names for <code>Stream'</code> and <code>Stream'.Seq</code>) with main pros and cons?</p>",
        "id": 542161513,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1759191137
    },
    {
        "content": "<p>My proposal is literally just 2 message above your message.  I have stated it several times in this thread.</p>",
        "id": 542163213,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759192537
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 542163293,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759192587
    },
    {
        "content": "<p>Namely, I propose that (<code>Stream'</code>. <code>Stream'.Seq</code>) be renamed to (<code>Sequence</code>, <code>Stream'</code>).</p>",
        "id": 542163409,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759192683
    },
    {
        "content": "<p>There were other proposals in this topic. Some of them don't use <code>'</code> in the names. Could you please explain what's wrong with them?</p>",
        "id": 542163521,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1759192779
    },
    {
        "content": "<p>I'm not sure which proposal you are referring to.   Please quote the message.</p>",
        "id": 542163879,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759193025
    },
    {
        "content": "<p>Here I'm trying to quote most messages that mention other names. It looks like you've discarded most of them. It would be nice if you summarize why they're worse than having <code>Stream</code> and <code>Stream'</code> in the library.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110637\">Ching-Tsun Chou</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Why.20is.20Stream'.20called.20Stream'.3F/near/541582455\">said</a>:</p>\n<blockquote>\n<p>Personally I prefer <code>Sequence</code> or  even <code>Seq</code>.    My suggestion of <code>InfSeq</code> was in response to Vasilii's comment.  Another option is <code>OmegaSeq</code> or <code>œâSeq</code>.</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110637\">Ching-Tsun Chou</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Why.20is.20Stream'.20called.20Stream'.3F/near/541922204\">said</a>:</p>\n<blockquote>\n<p>I suggested above that <code>Stream'</code> and <code>Stream'.Seq</code> be renamed to <code>Sequence</code> and <code>Stream'</code>, respectively.  Another option for the latter is <code>Colist</code>, as Vasilii pointed out.</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110637\">Ching-Tsun Chou</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Why.20is.20Stream'.20called.20Stream'.3F/near/541923165\">said</a>:</p>\n<blockquote>\n<p>If people feel strongly that <code>Sequence</code> should encompass both finite and infinite sequences, then <code>Stream'</code> can renamed to <code>œâSequence</code>.</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110637\">Ching-Tsun Chou</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Why.20is.20Stream'.20called.20Stream'.3F/near/541924346\">said</a>:</p>\n<blockquote>\n<p>Renaming <code>Stream'</code> to <code>œâWords</code> would be fine with me.  But I suspect the term \"word\" is more limited to automata theory and related fields than the more generic term \"sequence\".</p>\n</blockquote>",
        "id": 542171563,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1759198752
    },
    {
        "content": "<p>Also, I would wait for Mario before starting a PR that actually renames definitions.</p>",
        "id": 542171617,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1759198800
    },
    {
        "content": "<p>My fundamental problem with the current naming scheme is that it does not make sense.  I copy the definition of <code>Stream'</code> below:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- A stream `Stream' Œ±` is an infinite sequence of elements of `Œ±`. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Stream'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Œ±</span>\n</code></pre></div>\n<p>Why is it called <code>Stream'</code>, not simply <code>Sequence</code> or <code>œâSequence</code> (as its own comment points out)?  How is it related to the <code>Stream</code> type without the prime?</p>\n<p>As to <code>Stream'.Seq</code>, I suggest it be renamed <code>Stream'</code> because it is the type of sequences which can be finite or infinite and hence resembles <code>Stream</code>, so the prime will actually make some sense.</p>",
        "id": 542181945,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759207026
    },
    {
        "content": "<p>Generally, we're trying to avoid primes in the names, especially in type names. As I wrote above, you don't need to convince people that the current names are bad (assuming that <code>Stream</code> isn't going anywhere). Their purpose was to go ahead with porting, and they served this purpose. OTOH, if we're renaming them, then it's better to make sure that we won't rename them again in a few months. So, you should explain what do you think about, e.g., pros and cons of <code>Sequence</code> + <code>Stream'</code> vs <code>Sequence</code> + <code>Colist</code>.</p>",
        "id": 542191640,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1759213455
    },
    {
        "content": "<p>OK, I propose that (<code>Stream'</code>,<code>Stream'.Seq</code>) be renamed to (<code>Sequence</code>, <code>Colist</code>).</p>",
        "id": 542325653,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759251449
    },
    {
        "content": "<p>I really like Sequence as a name for that (though I do think having it be a one-element structure rather than literally a function might be good.</p>",
        "id": 542520399,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1759331299
    },
    {
        "content": "<p>My opinion is that the definition should be named <code>Stream</code>, that's why it was called <code>stream</code> in the first place. Lean 4 introduced another thing called <code>Stream</code> which IMO has less claim to the name, and they are already working on something else that seems likely to replace it, so I'm not sure how worthwhile it is to try to avoid the word in the first place. AFAICT setting aside lean 4 core issues there is no reason why the names of <code>Stream</code> and <code>Seq</code> should be swapped.</p>",
        "id": 542534874,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759335087
    },
    {
        "content": "<p>I don't mind the name <code>Colist</code> as an alternative to <code>Seq</code>, but I think <code>Seq</code>/<code>Sequence</code> is a more common name. But <code>Colist</code> and <code>Sequence</code> should both be in the docstring for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Stream%27.Seq#doc\">docs#Stream'.Seq</a></p>",
        "id": 542535066,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759335146
    },
    {
        "content": "<p>And re: why is it not coinductive, it's about as coinductive as it can be. There is a commented out pretend <code>coinductive</code> declaration right next to the real declaration, and the entire API is coinductive-inspired. You won't find very many <code>corec</code> definitions in mathlib other than that one</p>",
        "id": 542535374,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759335237
    },
    {
        "content": "<p>Yes, it's likely that core will no longer need its <code>Stream</code> at some point, but if you want you can have the name even before then: <a href=\"https://github.com/leanprover/lean4/pull/10645\">lean4#10645</a></p>",
        "id": 542562713,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1759344811
    },
    {
        "content": "<p>First, I think dropping the prime from <code>Stream'</code> would already be a big improvement, especially if  the current <code>Stream</code> can be done away with and there is no confusion about whether \"streams\" refer to both finite and infinite sequences or only infinite sequences.</p>\n<p>Second, I do not understand why \"stream\" is an appropriate name for infinite sequences.  I searched the PDFs of quite a few mathematical textbooks on my drive.  Almost all of them talk about sequences (Cauchy sequences, for instance) and none of them even contains the word \"stream\".  In fact, the only exception I can find, Moschovakis's \"Notes on Set Theory\", defines \"streams\" to comprise both finite and infinite sequences, as you can see from the excerpt attached below:<br>\n<a href=\"/user_uploads/3121/Y4lO35ehlx2UnLbVx3eqRjmW/p84-of-notes-on-set-theory.pdf\">p84-of-notes-on-set-theory.pdf</a><br>\nSo, why is \"stream\" an appropriate name for plain, old infinite sequences?</p>\n<p>Third, even if infinite sequences can be viewed as a coinductive datatype, is there anything wrong with the naive view of thinking of them as plain, old infinite sequences?  Even <code>List</code>, which is defined inductively, also has APIs which basically view a list as a function on the domain <code>Fin n</code> (where <code>n</code> is the length of the list) , such as <code>ofFn</code> and the various flavors of <code>get</code>, and you can prove properties about <code>List</code> using them without ever thinking about induction at all.</p>",
        "id": 542624630,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759358249
    },
    {
        "content": "<p>There is a distinction one can make between a stream and an infinite sequence. An infinite sequence is a map <code>Nat -&gt; A</code> which is indexed i.e. <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>a</mi><mn>0</mn></msub><mo separator=\"true\">,</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><mo>‚Ä¶</mo></mrow><annotation encoding=\"application/x-tex\">a_0,a_1,\\dots</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">‚Ä¶</span></span></span></span>. You will often see these showing up in mathematics, e.g. taking the limit of a sequence in topology, or summing an infinite sequence. A stream is a coinductive data structure which you can pull elements from, it has a head and a tail. These come up in CS contexts, such as stream algorithms or state machines. It happens that these two types are isomorphic, but the APIs for them are not the same, and maybe one day <code>Stream</code> will get the data representation overhaul it's always yearned for when the compiler is ready for it, at which point they will have to be different types.</p>",
        "id": 542632981,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759363684
    },
    {
        "content": "<p>I'm not sure I understand this argument.  I have already given the example of <code>List</code>.  On the one hand, <code>List</code> is an inductive datatype.  On the other hand, a list can be viewed as a function with a <code>Fin</code> domain (in other words, it is a finite sequence).  Are you arguing that these two APIs should be on two different types, instead of sharing the same type <code>List</code>?  What's the advantage in doing that?</p>\n<p>In the past few days, I ported my automata theory project:<br>\n<a href=\"https://github.com/ctchou/AutomataTheory\">https://github.com/ctchou/AutomataTheory</a><br>\nfrom using <code>‚Ñï ‚Üí _</code> to represent infinite sequences to using <code>Stream' _</code>, because there is really no point in defining my own versions of <code>Stream'.appendStream'</code> and <code>Stream'.drop</code> (which I use a lot) and I want to use the dot-notation.  I was pleasantly surprised by how easy the porting was.  In my theory I never thought of infinite sequences as a coinductive datatype (after all, I was using <code>‚Ñï ‚Üí _</code>).  But the presumably \"coinductive style\" API of <code>Stream'</code> still works.  So, even if Lean acquires the capability to do proper coinductive definitions in the future, why do you want to have a separate type which you know is isomorphic to infinite sequences?</p>\n<p>For an analogy, consider the real numbers.  You can define them using Cauchy sequences or using Dedekind cuts (and perhaps other means).  Do you want to have two versions of the reals depending on how they are defined?</p>",
        "id": 542647537,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759375670
    },
    {
        "content": "<p>I agree. What's stopping us from just defining all the <code>Stream'</code> API for <code>‚Ñï ‚Üí Œ±</code>? We lose dot notation, sure, but then we don't have to bikeshed about names.</p>",
        "id": 542835550,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1759441701
    },
    {
        "content": "<p>That's what I was doing.  But after a while I realized that it was just silly to repeat stuffs that are already in the <code>Stream'</code> API and the dot-notation really helps to make expressions readable and beautiful.  I started this bike-shedding thread because I could not figure out why an exotic name \"stream\" was given to something that's called \"sequence\" in every mathematical text I've read.</p>",
        "id": 542841902,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759445543
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110637\">Ching-Tsun Chou</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Why.20is.20Stream'.20called.20Stream'.3F/near/542647537\">said</a>:</p>\n<blockquote>\n<p>I'm not sure I understand this argument. I have already given the example of <code>List</code>. On the one hand, <code>List</code> is an inductive datatype. On the other hand, a list can be viewed as a function with a <code>Fin</code> domain (in other words, it is a finite sequence). Are you arguing that these two APIs should be on two different types, instead of sharing the same type <code>List</code>? What's the advantage in doing that?</p>\n</blockquote>\n<p>It's basically the same reason <code>Array A</code> and <code>List A</code> exist as separate types even though they are isomorphic. If there is a difference in data representation then there has to be a separate type</p>",
        "id": 542918117,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759488397
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110637\">Ching-Tsun Chou</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Why.20is.20Stream'.20called.20Stream'.3F/near/542647537\">said</a>:</p>\n<blockquote>\n<p>For an analogy, consider the real numbers.  You can define them using Cauchy sequences or using Dedekind cuts (and perhaps other means).  Do you want to have two versions of the reals depending on how they are defined?</p>\n</blockquote>\n<p>If we had both versions, yes they would be separate types and we'd prove they are isomorphic</p>",
        "id": 542918666,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759488567
    },
    {
        "content": "<p>If you just want a Nat function, you should not be using <code>Stream'</code>. This is (minor) abuse of the type and things will probably be more complicated if/when it becomes properly coinductive.</p>",
        "id": 542919055,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759488703
    },
    {
        "content": "<p>the fact that Stream' is implemented as a nat function is an implementation detail</p>",
        "id": 542919142,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759488735
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>, I find what you wrote above very surprising.  The distinction between <code>Array</code> and <code>List</code> is meaningful only when Lean code is run as a computer program.  Here we are proving theorems involving infinite sequences, not writing or reasoning about computer programs.  Why should we care about the internal implementation of a datatype once the appropriate API has been defined and proved?</p>\n<p>As it happens, there is an alternative implementation of the reals , <code>Bourbaki‚Ñù</code>, in mathlib:<br>\n<a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Topology/UniformSpace/CompareReals.html\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Topology/UniformSpace/CompareReals.html</a><br>\nIf I now re-prove a bunch of analysis theorems in terms of <code>Bourbaki‚Ñù</code>rather than <code>‚Ñù</code>and submit a mathlib PR, will you approve that PR?</p>\n<p>Furthermore, to follow your own logic, since the internal implementation matters, you should have agreed with me in the first place that the current <code>Stream'</code> should be renamed <code>Sequence</code> (because it is literally implemented as sequences) and the name <code>Stream</code> should be used only after the appropriate coinductive implementation is in place.  Isn't that so?  (If in the future coinduction is used to define executable infinite list in Lean, then I would agree completely that it should be called <code>Stream</code>, but not before it is actually done.)</p>",
        "id": 542996325,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759513509
    },
    {
        "content": "<p>Yes, <code>Stream'</code> is intended to be a computational data type that can be used in programs</p>",
        "id": 542999776,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759514885
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110637\">Ching-Tsun Chou</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Why.20is.20Stream'.20called.20Stream'.3F/near/542996325\">said</a>:</p>\n<blockquote>\n<p>you should have agreed with me in the first place that the current <code>Stream'</code> should be renamed <code>Sequence</code> (because it is literally implemented as sequences) and the name <code>Stream</code> should be used only after the appropriate coinductive implementation is in place. Isn't that so?</p>\n</blockquote>\n<p>No, because API changes are more disruptive than internal implementation changes. Keep in mind that <code>stream</code> has been around with the same API since lean 3, and there have been <em>many many</em> implementation detail changes since then. Changing the API to track the internal changes would only make it that much harder to keep up with lean. Suffice it to say, <code>Stream'</code> is a coinductive API for a type which is awaiting compiler support. If you use it today you will face performance issues but those issues can at least be reported as a bug and tracked, whereas if we were to pretend that Stream was intended to be natural number functions all along then there would be no issue to track in the first place. (And there would also be a good chance that people would argue that there is no need for the <code>Sequence</code> type since it is just a wrapper around functions with no API changes so we would end up with nothing at all.)</p>",
        "id": 543000620,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759515235
    },
    {
        "content": "<p>Also, <code>Stream</code> is one in a family of definitions including <code>Stream'.Seq</code> and <code>Stream'.WSeq</code> which are also coinductive types but require more complicated simulations using subtypes of functions. These types are intended to work together and it would be awkward if one of them was missing.</p>",
        "id": 543000923,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759515337
    },
    {
        "content": "<p>Are you saying that I should define my own <code>Sequence</code> type to wrap <code>‚Ñï ‚Üí _</code> and duplicate all relevant theorems from <code>Stream'</code> on it?  I do want to use the dot-notation and follow the same naming convention as <code>List</code> and <code>Stream'</code>.</p>",
        "id": 543001288,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759515493
    },
    {
        "content": "<p>Yes, if you want. Obviously that would need to go through review if you want it in mathlib, I have already foreshadowed some critiques I can predict</p>",
        "id": 543001445,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759515559
    },
    {
        "content": "<p>You can use dot notation on functions BTW, you put them in the <code>Function.*</code> namespace</p>",
        "id": 543001561,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759515602
    },
    {
        "content": "<p>You could also put them in <code>Sequence.Function.*</code>; I think if you <code>open Sequence</code> then that will also work as dot notation for functions</p>",
        "id": 543001847,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759515688
    },
    {
        "content": "<p>But does it make sense to define API functions like <code>take</code>, <code>drop</code>, <code>extract</code>, <code>append</code> on general functions?</p>",
        "id": 543002127,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759515794
    },
    {
        "content": "<p>the latter approach avoids that issue since it's namespaced so it only works when you open the scope</p>",
        "id": 543002199,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759515824
    },
    {
        "content": "<p>but the reason I suggest that is because mathlib already uses sequences all over the place and the official spelling for sequences is to use unadorned function types</p>",
        "id": 543002281,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759515863
    },
    {
        "content": "<p>Still, a new namespace does not force the domain of a function to be N.</p>",
        "id": 543002374,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759515902
    },
    {
        "content": "<p>I know it's not a perfect solution, I think we both understand the pros and cons of the options here</p>",
        "id": 543002433,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759515929
    },
    {
        "content": "<p>if you can live without dot notation you can also just have reasonably named free functions</p>",
        "id": 543002529,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759515971
    },
    {
        "content": "<p>but if you insist on a new type then you will have to deal with conversion to and from functions for all the places where people use functions to mean sequences (or specialize a theorem about functions to sequences)</p>",
        "id": 543002696,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759516037
    },
    {
        "content": "<p>and it's not even the case that all sequences are indexed by <code>Nat</code>, some are <code>Int</code> or <code>Ordinal</code> or whatever</p>",
        "id": 543002775,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759516067
    },
    {
        "content": "<p>I'm not sure it can actually be interpreted as anything other than \"word mathematicians like to use for functions on a discrete domain\"</p>",
        "id": 543002830,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759516090
    },
    {
        "content": "<p>I was using naked <code>‚Ñï ‚Üí _</code> functions and I ended up not liking it.  In particular, I want to re-use names like <code>take</code>,¬†<code>drop</code>,¬†<code>extract</code>,¬†<code>append</code> and keep their approximate meanings.  (After all, infinite sequences have many similarities to finite ones.)</p>\n<p>One option is to call the new type <code>OmegaWord</code> or <code>œâWord</code> to avoid entanglement with the many meanings of \"sequence\" in normal math.</p>",
        "id": 543003703,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759516501
    },
    {
        "content": "<p>Seems fine to me. I will abstain from making an editorial decision on whether that should be in mathlib, but if it works for you and you can argue your case then great</p>",
        "id": 543003930,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759516611
    },
    {
        "content": "<p>...<code>append</code>?</p>",
        "id": 543004039,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759516656
    },
    {
        "content": "<p>what does it mean to append two infinite sequences</p>",
        "id": 543004060,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759516664
    },
    {
        "content": "<p>probably append a finite sequence at the front of an infinite one</p>",
        "id": 543004171,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1759516706
    },
    {
        "content": "<p>Sorry, I was being brief: <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Stream/Defs.html#Stream'.appendStream\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Stream/Defs.html#Stream'.appendStream</a>'</p>",
        "id": 543004285,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759516738
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 543032393,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1759527312
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Why.20is.20Stream'.20called.20Stream'.3F/near/542918117\">said</a>:</p>\n<blockquote>\n<p>It's basically the same reason <code>Array A</code> and <code>List A</code> exist as separate types even though they are isomorphic. If there is a difference in data representation then there has to be a separate type</p>\n</blockquote>\n<p>As I understand it, <code>Array</code> is internally backed by an array, while <code>List</code> is internally backed by a linked list. That is the only difference, and from a theorem proving perspective both types are exactly the same.</p>",
        "id": 543046589,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1759539798
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110637\">Ching-Tsun Chou</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Why.20is.20Stream'.20called.20Stream'.3F/near/542647537\">said</a>:</p>\n<blockquote>\n<p>For an analogy, consider the real numbers.  You can define them using Cauchy sequences or using Dedekind cuts (and perhaps other means).  Do you want to have two versions of the reals depending on how they are defined?</p>\n</blockquote>\n<p>Funny you mention this, since one of my PRs introduces the Dedekind completion to Mathlib! Of course, the only theorem I'm really interested in proving about <code>DedekindCut ‚Ñö</code> is that it's order-isomorphic to ‚Ñù. It seems like a complete waste of time to reintroduce all the API about arithmetic just to prove that the fields end up isomorphic.</p>",
        "id": 543046764,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1759539947
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110637\">Ching-Tsun Chou</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Why.20is.20Stream'.20called.20Stream'.3F/near/542325653\">schrieb</a>:</p>\n<blockquote>\n<p>OK, I propose that (<code>Stream'</code>,<code>Stream'.Seq</code>) be renamed to (<code>Sequence</code>, <code>Colist</code>).</p>\n</blockquote>\n<p>Now that the name <code>Stream</code> is free (that has now become <code>Std.Stream</code>) is there any consensus to renaming <code>Stream'.Seq</code> or even full <code>Stream'</code>?<br>\nPersonally i would really like to have <code>Stream'.Seq</code> contain the word <code>Colist</code>. For me a sequence is ingrained as an always-infinite object.</p>",
        "id": 570076435,
        "sender_full_name": "Moritz R",
        "timestamp": 1769429876
    },
    {
        "content": "<p>I think <code>Stream'</code> should definetely become <code>Stream</code>. And I personally agree that <code>Colist</code> is a better name for possibly infinite lists</p>",
        "id": 570094169,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1769434826
    },
    {
        "content": "<p>CSLib now has a substantial theory of infinite sequences:<br>\n<a href=\"https://github.com/leanprover/cslib/tree/main/Cslib/Foundations/Data/OmegaSequence\">https://github.com/leanprover/cslib/tree/main/Cslib/Foundations/Data/OmegaSequence</a></p>",
        "id": 570156511,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1769450273
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110637\">Ching-Tsun Chou</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Why.20is.20Stream'.20called.20Stream'.3F/near/570156511\">said</a>:</p>\n<blockquote>\n<p>CSLib now has a substantial theory of infinite sequences:<br>\n<a href=\"https://github.com/leanprover/cslib/tree/main/Cslib/Foundations/Data/OmegaSequence\">https://github.com/leanprover/cslib/tree/main/Cslib/Foundations/Data/OmegaSequence</a></p>\n</blockquote>\n<p>Yes, but to be clear it was built directly in analogy to Mathlib's <code>Steam'</code>. I still question that duplication.</p>",
        "id": 570157976,
        "sender_full_name": "Chris Henson",
        "timestamp": 1769450702
    },
    {
        "content": "<p>That would not have happened if mathlib had been more open to changing the name <code>Stream'</code> to something more meaningful and not insisted that <code>Stream'</code> is really meant to be a coinductively defined type and one should not use it like <code>‚Ñï ‚Üí Œ±</code>(which is what I wanted).  All these are in the earlier messages of this thread.</p>",
        "id": 570160189,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1769451459
    },
    {
        "content": "<p>Yes I understand your position, as I was here when the thread was written and the corresponding CSLib discussion. I did not mean to invite rehashing this, just to provide a minimal context for the code you linked.</p>\n<p>I think at minimum people agree that primed names are not ideal. I would support renaming <code>Stream'</code> to <code>Stream</code> (after the deprecation period) and <code>Stream'.Seq</code> to <code>Colist</code>. Given the intent of representing coinductive types, I think it best to avoid any intersection of naming with sequences.</p>",
        "id": 570166156,
        "sender_full_name": "Chris Henson",
        "timestamp": 1769453397
    },
    {
        "content": "<p>Is there any reason against implementing (for <code>Stream'.Seq</code>) a direct access to the value in the option, given a valid index <code>i &lt; Ns.length'</code>?<br>\nE.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">GetElem</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Stream'</span><span class=\"bp\">.</span><span class=\"n\">Seq</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">Ns</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">Ns</span><span class=\"bp\">.</span><span class=\"n\">length'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">getElem</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">Ns</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">hi</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Ns</span><span class=\"bp\">.</span><span class=\"n\">get?</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">lt_length'_iff_isSome</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">hi</span><span class=\"o\">)</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">SetSeq</span><span class=\"bp\">.</span><span class=\"n\">getElem_eq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Ns</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Stream'</span><span class=\"bp\">.</span><span class=\"n\">Seq</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hi</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">length'</span><span class=\"w\"> </span><span class=\"n\">Ns</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">getElem</span><span class=\"w\"> </span><span class=\"n\">Ns</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">hi</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Ns</span><span class=\"bp\">.</span><span class=\"n\">get?</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">lt_length'_iff_isSome</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">hi</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 570313480,
        "sender_full_name": "Moritz R",
        "timestamp": 1769518749
    },
    {
        "content": "<p>The following is working quite nicely for me:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">module</span>\n\n<span class=\"n\">public</span><span class=\"w\"> </span><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Seq</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">expose</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"n\">public</span><span class=\"w\"> </span><span class=\"kn\">section</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Stream'</span><span class=\"w\"> </span><span class=\"n\">Seq</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">lt_length'_iff_isSome</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Stream'</span><span class=\"bp\">.</span><span class=\"n\">Seq</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">length'</span><span class=\"w\"> </span><span class=\"bp\">‚Üî</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">get?</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">isSome</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Iff</span><span class=\"bp\">.</span><span class=\"n\">intro</span>\n<span class=\"w\">  </span><span class=\"bp\">¬∑</span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">hn</span>\n<span class=\"w\">   </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">lt_length'_iff</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">hn</span>\n<span class=\"w\">   </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Option</span><span class=\"bp\">.</span><span class=\"n\">isSome_iff_exists</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">¬∑</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">hn</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÉ</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">get?</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"n\">simp_all</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Option</span><span class=\"bp\">.</span><span class=\"n\">mem_def</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Option</span><span class=\"bp\">.</span><span class=\"n\">isSome_iff_exists</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">hn</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">lt_length'_iff</span><span class=\"o\">]</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">GetElem</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Stream'</span><span class=\"bp\">.</span><span class=\"n\">Seq</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">Ns</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">Ns</span><span class=\"bp\">.</span><span class=\"n\">length'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">getElem</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">Ns</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">hi</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Ns</span><span class=\"bp\">.</span><span class=\"n\">get?</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">lt_length'_iff_isSome</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">hi</span><span class=\"o\">)</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">SetSeq</span><span class=\"bp\">.</span><span class=\"n\">getElem_eq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Ns</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Stream'</span><span class=\"bp\">.</span><span class=\"n\">Seq</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hi</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">length'</span><span class=\"w\"> </span><span class=\"n\">Ns</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">getElem</span><span class=\"w\"> </span><span class=\"n\">Ns</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">hi</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Ns</span><span class=\"bp\">.</span><span class=\"n\">get?</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">lt_length'_iff_isSome</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">hi</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"kd\">]</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">last_idx_lt_length'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Ns</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Stream'</span><span class=\"bp\">.</span><span class=\"n\">Seq</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hTer</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ns</span><span class=\"bp\">.</span><span class=\"n\">Terminates</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬¨</span><span class=\"n\">Ns</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Ns</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"n\">hTer</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">Ns</span><span class=\"bp\">.</span><span class=\"n\">length'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ns</span><span class=\"bp\">.</span><span class=\"n\">length'</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Ns</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"n\">hTer</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">length'_of_terminates</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ns</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"n\">hTer</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">length_eq_zero</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">AddLECancellable</span><span class=\"bp\">.</span><span class=\"n\">tsub_lt_self</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n<span class=\"w\">  </span><span class=\"bp\">¬∑</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">ENat</span><span class=\"bp\">.</span><span class=\"n\">addLECancellable_coe</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"n\">Ns</span><span class=\"w\"> </span><span class=\"n\">hTer</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">¬∑</span><span class=\"w\"> </span><span class=\"n\">simp_all</span>\n<span class=\"w\">  </span><span class=\"bp\">¬∑</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">grind!</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"kd\">]</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">not_Terminates_imp_idx_lt_length'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Ns</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Stream'</span><span class=\"bp\">.</span><span class=\"n\">Seq</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hNTer</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬¨</span><span class=\"n\">Ns</span><span class=\"bp\">.</span><span class=\"n\">Terminates</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">Ns</span><span class=\"bp\">.</span><span class=\"n\">length'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">length'_of_not_terminates</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ENat</span><span class=\"bp\">.</span><span class=\"n\">coe_ne_top</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">‚Üê=</span><span class=\"w\"> </span><span class=\"n\">top_unique</span><span class=\"o\">]</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">use_smaller_idx</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Ns</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Stream'</span><span class=\"bp\">.</span><span class=\"n\">Seq</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">Ns</span><span class=\"bp\">.</span><span class=\"n\">length'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hb</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">Ns</span><span class=\"bp\">.</span><span class=\"n\">length'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"n\">ENat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"bp\">‚Üë</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp_all</span>\n<span class=\"w\">  </span><span class=\"n\">grind</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">not_eq_nil_imp_zero_lt_length'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Ns</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Stream'</span><span class=\"bp\">.</span><span class=\"n\">Seq</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hnil</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬¨</span><span class=\"n\">Ns</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">Ns</span><span class=\"bp\">.</span><span class=\"n\">length'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">length'_eq_zero_iff_nil</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">length'_ne_zero_iff_cons</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">length'_cons</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ENat</span><span class=\"bp\">.</span><span class=\"n\">add_one_pos</span><span class=\"o\">]</span>\n\n<span class=\"kn\">macro_rules</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">get_elem_tactic_extensible</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">first</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">last_idx_lt_length'</span><span class=\"w\"> </span><span class=\"bp\">‚Äπ_‚Ä∫</span><span class=\"w\"> </span><span class=\"bp\">‚Äπ_‚Ä∫</span><span class=\"w\"> </span><span class=\"bp\">‚Äπ_‚Ä∫</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">not_Terminates_imp_idx_lt_length'</span><span class=\"w\"> </span><span class=\"bp\">‚Äπ_‚Ä∫</span><span class=\"w\"> </span><span class=\"bp\">‚Äπ_‚Ä∫</span><span class=\"w\"> </span><span class=\"bp\">‚Äπ_‚Ä∫</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">use_smaller_idx</span><span class=\"w\"> </span><span class=\"bp\">‚Äπ_‚Ä∫</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">not_eq_nil_imp_zero_lt_length'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp_all</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">simp_all</span>\n<span class=\"w\">  </span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"kd\">]</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">Seq</span><span class=\"bp\">.</span><span class=\"n\">map_getElem_eq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Ns</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Stream'</span><span class=\"bp\">.</span><span class=\"n\">Seq</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hi</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">length'</span><span class=\"w\"> </span><span class=\"n\">Ns</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">Seq</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">Ns</span><span class=\"o\">)[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">Ns</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">SetSeq</span><span class=\"bp\">.</span><span class=\"n\">getElem_eq</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 570314047,
        "sender_full_name": "Moritz R",
        "timestamp": 1769518887
    },
    {
        "content": "<p>I want nicer index access for defining things such as </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"sd\">/-- The limit of a (possibly infinite) list of sets, is the set of `persistent elements`,</span>\n<span class=\"sd\">    i.e. those elements that at some point stay in the list forever.</span>\n<span class=\"sd\">    For a finite list this is just the last entry. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">limit</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Ns</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Seq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">hTer</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ns</span><span class=\"bp\">.</span><span class=\"n\">Terminates</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">h0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ns</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"bp\">‚àÖ</span>\n<span class=\"w\">    </span><span class=\"k\">else</span>\n<span class=\"w\">      </span><span class=\"c1\">-- Use the last set of the sequence.</span>\n<span class=\"w\">      </span><span class=\"n\">Ns</span><span class=\"o\">[</span><span class=\"n\">Ns</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"n\">hTer</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"k\">else</span>\n<span class=\"w\">    </span><span class=\"c1\">-- Infinite case: elements that are eventually in all sets.</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">œÜ</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">‚àÉ</span><span class=\"o\">(</span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">‚â•</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">œÜ</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">Ns</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 570314957,
        "sender_full_name": "Moritz R",
        "timestamp": 1769519096
    },
    {
        "content": "<p>There is also <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Stream%27.WSeq#doc\">docs#Stream'.WSeq</a>, for which I don't believe an alternative name has been proposed. It is probably desirable this still matches up with the current <code>Stream'.Seq</code>.</p>",
        "id": 570317591,
        "sender_full_name": "Chris Henson",
        "timestamp": 1769519765
    }
]