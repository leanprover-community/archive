[
    {
        "content": "<p>Hi everyone,</p>\n<p>I have been working on a formalization of <a href=\"https://en.wikipedia.org/wiki/Kraft%E2%80%93McMillan_inequality\">Kraft's Inequality</a> and related results from information theory, and I wanted to gauge interest in contributing this to Mathlib.</p>\n<p>What I have formalized:</p>\n<ul>\n<li>Kraft's Inequality: <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mo>∑</mo><mrow><mi>w</mi><mo>∈</mo><mi>S</mi></mrow></msub><msup><mi>D</mi><mrow><mo>−</mo><mi mathvariant=\"normal\">∣</mi><mi>w</mi><mi mathvariant=\"normal\">∣</mi></mrow></msup><mo>≤</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">\\sum_{w \\in S} D^{-|w|} \\le 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.2151em;vertical-align:-0.3271em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1786em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02691em;\">w</span><span class=\"mrel mtight\">∈</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05764em;\">S</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3271em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.888em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">∣</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord mtight\">∣</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> for prefix-free codes.</li>\n<li>Kraft-McMillan Inequality: The same bound for uniquely decodable codes (Kraft's Inequality is proved as a special case).</li>\n<li>The Converse: Given lengths <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>l</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">l_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> satisfying <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∑</mo><msup><mi>D</mi><mrow><mo>−</mo><msub><mi>l</mi><mi>i</mi></msub></mrow></msup><mo>≤</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">\\sum D^{-l_i} \\le 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0991em;vertical-align:-0.25em;\"></span><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∑</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3281em;\"><span style=\"top:-2.357em;margin-left:-0.0197em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>, there exists a prefix-free code with those lengths.</li>\n<li>Extensions:<ul>\n<li>The results are generalized to arbitrary finite alphabets (not just binary).</li>\n<li>The proofs handle both finite and infinite codes.</li>\n<li>As an example, I used it to prove <a href=\"https://en.wikipedia.org/wiki/Shannon%27s_source_coding_theorem\">Shannon's Source Coding theorem</a>.</li>\n</ul>\n</li>\n</ul>\n<p>Implementation Details:<br>\nThe project is currently structured as a standalone package.</p>\n<ul>\n<li>The forward direction (McMillan) uses an algebraic proof.</li>\n<li>The converse direction uses a \"cumulative sum\" / dyadic interval construction to assign codewords.</li>\n<li>I've tried to follow Mathlib naming conventions and style.</li>\n<li>I'm using v4.26</li>\n</ul>\n<p>As noted in my repo, I used AI assistants (Extensively) to help generate and iterate on the definitions and proofs. I have reviewed and structured the arguments, but I would appreciate feedback on whether the current style matches Mathlib's standards.</p>\n<p>Code: <a href=\"https://github.com/elazarg/kraft\">https://github.com/elazarg/kraft</a></p>\n<p>Is this something that would be a good fit for Mathlib? If so, I'd love advice on where in the hierarchy it belongs (perhaps <code>InformationTheory</code> or <code>Combinatorics</code>?) and how to break it down for a PR.</p>\n<p>Thanks!</p>",
        "id": 568043348,
        "sender_full_name": "Elazar Gershuni",
        "timestamp": 1768411858
    },
    {
        "content": "<p>I think this is InformationTheory and IMO would be a very welcome contribution.</p>",
        "id": 568154918,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1768468151
    },
    {
        "content": "<p>Interested in what definition you have chosen for codes (I have found it a little hard to decide in the past).</p>",
        "id": 568154972,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1768468167
    },
    {
        "content": "<p>I haven't yet looked at the code but I agree this theorem belongs in mathlib</p>",
        "id": 568191594,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1768478879
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Kraft's.20Inequality.20and.20Converse/near/568154972\">said</a>:</p>\n<blockquote>\n<p>Interested in what definition you have chosen for codes </p>\n</blockquote>\n<p>I used simply <code>Set (List α)</code>.  What alternatives have you considered?</p>",
        "id": 568230781,
        "sender_full_name": "Elazar Gershuni",
        "timestamp": 1768487886
    },
    {
        "content": "<p>Opened the first PR: KraftMcMillan for uniquely-decodable codes:<br>\n<a href=\"https://github.com/leanprover-community/mathlib4/pull/34108\">https://github.com/leanprover-community/mathlib4/pull/34108</a></p>",
        "id": 568670316,
        "sender_full_name": "Elazar Gershuni",
        "timestamp": 1768749295
    },
    {
        "content": "<p>I have generalized the KraftMcmillan theorem to this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">lengthGrowth</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">D_nat</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">filter</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">ℓ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">D_nat</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">s</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">tupleProduct</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">M</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\">     </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">tupleProduct</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">)</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">kraft_inequality_of_injective</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ℓ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">D_nat</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">D_pos</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">D_nat</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h_add</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ℓ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">ℓ</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">ℓ</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h_pos</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">ℓ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h_count</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">lengthGrowth</span><span class=\"w\"> </span><span class=\"n\">ℓ</span><span class=\"w\"> </span><span class=\"n\">D_nat</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h_inj</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">Injective</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">tupleProduct</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∑</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">D_nat</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ℓ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n</code></pre></div>\n<p>The proof is similar to the previous one, but it's no longer about uniquely decodable codes.</p>\n<p>Would that be useful? The \"standard\" theorem is an instantiation.</p>",
        "id": 568927398,
        "sender_full_name": "Elazar Gershuni",
        "timestamp": 1768872517
    },
    {
        "content": "<p>I think generalizing the statement is a good idea, it is more useful and generalizing can often lead to simpler proofs and statements.  Your tuple product seems like it could be defined</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">tupleProduct</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">foldl</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>The <code>h_add</code> hypothesis is very close to being a <code>MulHom</code> or <code>AddHom</code> but I'm not sure if there's a way to relate multiplication to addition without using Additive/Multiplicative or switching Monoid to AddMonoid.</p>",
        "id": 568964877,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1768897697
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"1015232\">Elazar Gershuni</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Kraft's.20Inequality.20and.20Converse/near/568230781\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Kraft's.20Inequality.20and.20Converse/near/568154972\">said</a>:</p>\n<blockquote>\n<p>Interested in what definition you have chosen for codes </p>\n</blockquote>\n<p>I used simply <code>Set (List α)</code>.  What alternatives have you considered?</p>\n</blockquote>\n<p>Well, one might consider codes of a fixed length, or linear codes, for which Fin n -&gt; α/Vector n α might be appropriate for the former and the latter, ah, probably wants LinearSpace or whatever it is.</p>\n<p>Equally, one might instead consider a code as the function X -&gt; FreeMonoid α (and bear in mind that FreeMonoid α is a synonym for List α): in this perspective, the code is the encoding map, rather than the <em>image</em> of the encoding map.</p>\n<p>For the particular case of linear codes one might consider a code represented by its generating matrix (which is nearly but not quite the same as the above), or indeed one might consider a code defined by the matrix to which it is a kernel.</p>\n<p>Also, one has the problem that a metric on (block) codes isn't necessarily singly defined - the Hamming metric is common but other options exist.</p>",
        "id": 569044751,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1768920065
    },
    {
        "content": "<p>oh: also Set (List α) allows for an infinite code, but one might reasonably impose the condition that it should be finite in which case you would probably use Finset, which corresponds to X above being a fintype. </p>\n<p>The Set representation leads to you being unable to consider non-singular codes.</p>\n<p>In addition you might well wish to attach a probability distribution to X which then induces a probability distribution on the codewords.</p>",
        "id": 569045456,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1768920212
    },
    {
        "content": "<p>Codes of fixed length aren't interesting in this case, since the statement becomes trivial (every code of fixed length is uniquely decodable).<br>\nThe Kraft-McMillan inequality is about variable-length codes.</p>\n<p>On the other hand, the Kraft–McMillan inequality is definitely interesting for (countably) infinite codes.<br>\nFor example, the famous information theorist Peter Elias studied universal codes for the natural numbers, and every so often new papers are published on the topic.</p>",
        "id": 569082865,
        "sender_full_name": "Yuval Filmus",
        "timestamp": 1768928663
    },
    {
        "content": "<p>\"Code\" has several meanings — the codes referred to in Kraft–McMillan are different from the ones considered in the theory of error-correcting codes, despite being called the same.<br>\nIn information theory, this is the difference between \"source coding\" and \"noisy channel coding\".</p>",
        "id": 569083320,
        "sender_full_name": "Yuval Filmus",
        "timestamp": 1768928783
    },
    {
        "content": "<p>Could we define Chaitin's constant once this is merged in?</p>",
        "id": 574188891,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1771279462
    },
    {
        "content": "<p>I suppose we could define it now, but this would allow us to show that the sum converges</p>",
        "id": 574188967,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1771279510
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"815159\">Yuval Filmus</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Kraft's.20Inequality.20and.20Converse/near/569083320\">said</a>:</p>\n<blockquote>\n<p>\"Code\" has several meanings — the codes referred to in Kraft–McMillan are different from the ones considered in the theory of error-correcting codes, despite being called the same.<br>\nIn information theory, this is the difference between \"source coding\" and \"noisy channel coding\".</p>\n</blockquote>\n<p>I think choosing good names for this stuff when it comes into Mathlib is going to be very important.</p>",
        "id": 574245050,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1771319739
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"380294\">Matt Diamond</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Kraft's.20Inequality.20and.20Converse/near/574188967\">said</a>:</p>\n<blockquote>\n<p>I suppose we could define it now, but this would allow us to show that the sum converges</p>\n</blockquote>\n<p>I think the current version is only for finite codes, though an infinite version should be easy to add.<br>\nAlso, I’m not sure prefix code are defined yet.</p>",
        "id": 574266488,
        "sender_full_name": "Yuval Filmus",
        "timestamp": 1771326773
    },
    {
        "content": "<p>I would love to hear tips about the next slice to PR, after <a href=\"https://github.com/leanprover-community/mathlib4/pull/34108\">34108</a> (Kraft-McMillan inequality) is merged.</p>",
        "id": 574343003,
        "sender_full_name": "Elazar Gershuni",
        "timestamp": 1771347983
    }
]