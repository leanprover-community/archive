[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span>  In Lean 3, if I type</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">topology.instances.real</span>\n<span class=\"kn\">import</span> <span class=\"n\">topology.algebra.order.compact</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hK</span><span class=\"o\">:</span> <span class=\"n\">is_compact</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">f</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">suggest</span><span class=\"o\">,</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>then among many stupid suggestions, I get the very relevant</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Try</span> <span class=\"n\">this</span><span class=\"o\">:</span> <span class=\"n\">refine</span> <span class=\"n\">hK.exists_forall_le</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n</code></pre></div>\n<p>(and by the way <code>suggest using hK</code> returns nothing, but I guess we don't want to fix this at this point). In Lean 4 if I type</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.Instances.Real</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.Algebra.Order.Compact</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.LibrarySearch</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hK</span><span class=\"o\">:</span> <span class=\"n\">IsCompact</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">f</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">library_search</span>\n</code></pre></div>\n<p>the best it comes up with is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">refine</span> <span class=\"n\">IsCompact.exists_forall_le</span> <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n</code></pre></div>\n<p>which fails to use assumption <code>hK</code>. Is this a known regression? Note that writing <code>library_search using hK</code> doesn't change anything.</p>",
        "id": 353375130,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1682611912
    },
    {
        "content": "<p>By the way, trying to continue the same proof (skipping the hopeless side condition), we get to </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.Instances.Real</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.Algebra.Order.Compact</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.LibrarySearch</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hK</span><span class=\"o\">:</span> <span class=\"n\">IsCompact</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">f</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine</span> <span class=\"n\">hK.exists_forall_le</span> <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n  <span class=\"gr\">sorry</span>\n  <span class=\"n\">library_search</span>\n</code></pre></div>\n<p>which very weirdly suggests <code>refine Continuous.continuousOn (False.elim ?_)</code> instead of <code>refine Continuous.continuousOn ?_</code>.</p>",
        "id": 353377168,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1682612201
    },
    {
        "content": "<p>Ah yes, this is a known issue. The <code>suggest</code> mode of <code>library_search</code> in<br>\nmathlib4 has never received much love. The key difference is that in<br>\nmathlib3 if we tried a lemma, it applied, but we could not close all<br>\nsubgoals using <code>solve_by_elim</code>, we would try again with <code>solve_by_elim</code><br>\nclosing whatever subset of the subgoals could be closed \"safely\" (ie<br>\nsubsingletons). In mathlib4 we have never implemented this second step.<br>\nThis is what would replace one of the <code>?_</code>s with <code>hK</code>.</p>\n<p>I agree we should fix this!</p>\n<p>We could even reorder the results automatically so that partial results<br>\nwhich used more of the local hypotheses (or have fewer unsolved subgoals,<br>\nor some combination), score higher.</p>",
        "id": 353514391,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1682633590
    },
    {
        "content": "<p>It would be nice to fix this especially for propaganda talks purposes. My standard talk example in Lean 3 is a proof where <code>suggest</code> is especially useful.</p>",
        "id": 353521814,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1682634946
    },
    {
        "content": "<p>Another <code>library_search</code> failure, posting in the same thread as Patrick's because it seems similar:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Quot</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.LibrarySearch</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Function.Surjective</span> <span class=\"o\">(</span><span class=\"n\">Quot.mk</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">library_search</span> <span class=\"c1\">-- fails</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Function.Surjective</span> <span class=\"o\">(</span><span class=\"n\">Quot.mk</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">surjective_quot_mk</span> <span class=\"n\">r</span> <span class=\"c1\">-- should find this</span>\n</code></pre></div>",
        "id": 354025788,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1682707255
    },
    {
        "content": "<p>It works in Lean 3:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.quot</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic.suggest</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">function.surjective</span> <span class=\"o\">(</span><span class=\"n\">quot.mk</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">library_search</span>\n<span class=\"c1\">-- finds `exact surjective_quot_mk r`</span>\n</code></pre></div>",
        "id": 354026566,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1682707398
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span>, <a href=\"https://github.com/leanprover-community/mathlib4/pull/3724\">!4#3724</a>.</p>",
        "id": 354205446,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1682748788
    },
    {
        "content": "<p>(The bug was using <code>forallMetaTelescopeReducing</code>, rather than just <code>forallMetaTelescope</code>, when indexing lemmas for the discrimination tree. This meant we were blasting through the <code>Function.Surjective</code> and seeing an <code>Exists</code> conclusion, and hence mis-indexing the lemma. This probably affected a great many results!)</p>",
        "id": 354205970,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1682748886
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span>, after <a href=\"https://github.com/leanprover-community/mathlib4/pull/3743\">!4#3743</a>, on your example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.Instances.Real</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.Algebra.Order.Compact</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.LibrarySearch</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hK</span><span class=\"o\">:</span> <span class=\"n\">IsCompact</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">f</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">library_search</span>\n</code></pre></div>\n<p>we have:</p>\n<ul>\n<li><code>refine IsCompact.exists_forall_le hK ?_ ?_</code> as one of the suggested solutions</li>\n<li>in fact, as the first solution (on the basis that it uses more local hypotheses than alternatives)</li>\n<li>none of the spurious results which use <code>False.elim ?_</code></li>\n<li>and better display of the result, with hints:</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">refine</span> <span class=\"n\">IsCompact.exists_forall_le</span> <span class=\"n\">hK</span> <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n<span class=\"c1\">-- Remaining subgoals:</span>\n<span class=\"c1\">-- ⊢ Set.Nonempty K</span>\n<span class=\"c1\">-- ⊢ ContinuousOn (fun x ↦ f x) K</span>\n</code></pre></div>",
        "id": 354770290,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1682901720
    },
    {
        "content": "<p>Amazing, thanks!</p>",
        "id": 354804556,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1682924400
    }
]