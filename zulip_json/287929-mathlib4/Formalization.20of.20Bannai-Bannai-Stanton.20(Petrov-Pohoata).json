[
    {
        "content": "<p>Hi everyone,</p>\n<p>I have formalized the Bannai-Bannai-Stanton theorem (bound on distance sets in $\\mathbb{R}^d$) following the proof by Petrov and Pohoata.</p>\n<p>My goal is to contribute this to Mathlib. However, as I am a new contributor, I would appreciate guidance on the workflow. The code is fully working and the main theorem is proved, but it is currently written as a single monolithic file.</p>\n<p>I am looking for advice on how to split the auxiliary results to fit Mathlib's hierarchy. Specifically, I have developed several lemmas that seem general enough to be upstreamed separately, including:</p>\n<ol>\n<li>Combinatorics: An explicit bijection between <code>restrictTotalDegree</code> polynomials and <code>Sym (Option (Fin d)) s</code> to count monomials (using <code>Sym.card_sym_eq_choose</code>).</li>\n<li>Linear Algebra: Bounds on the rank and inertia of matrices defined by polynomials (Polynomial Method / Croot-Lev-Pach lemmas).</li>\n</ol>\n<p>I am unsure if there are existing Mathlib abstractions I should use instead of my manual counting arguments, or where these new lemmas should ideally live.</p>\n<p>Here is the Gist with the full code:</p>\n<p><a href=\"https://gist.github.com/AntoineduFresne/184bb2f40f38d3592b80828f3a2ff525\">https://gist.github.com/AntoineduFresne/184bb2f40f38d3592b80828f3a2ff525</a></p>\n<p>Thanks for your help.</p>",
        "id": 566007051,
        "sender_full_name": "Antoine du Fresne von Hohenesche",
        "timestamp": 1767312575
    },
    {
        "content": "<p>Out of interest, did you use AI in your proof?</p>",
        "id": 566007357,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1767313139
    },
    {
        "content": "<p>I utilized Gemini Pro 3 as an assistant for this formalization. It helped me with tactic discovery and syntax. My workflow often involved writing the proof strategy in natural language and asking the AI to help translate it into Lean or suggest tactics. I want to highlight two specific contributions from the AI: It mostly helped to construct the bijection for the monomial counting argument (using <code>Option</code>). For the rank bound (Croot-Lev-Pach Lemma Part 1), I intended to follow Petrov's proof, but the AI suggested a different, shorter trick to bound the rank (see comments in the code). I am unsure if this is the standard CLP proof or a (small) novelty, but the mathematical insight for that specific step came from the model.</p>",
        "id": 566007669,
        "sender_full_name": "Antoine du Fresne von Hohenesche",
        "timestamp": 1767313698
    },
    {
        "content": "<p>I'm not in the area so I can't really comment on whether the result is in scope for mathlib, but I asked because your proof is extremely long and unidiomatic, which is the hallmark of an LLM-produced proof. I'm sure you don't want to hear this but one way of fixing this would be to actually learn how to write Lean yourself from one of the guides or online textbooks and then rewrite the proof in an idiomatic style. Right now LLMs are not capable of writing code which is anywhere near acceptable for mathlib.</p>",
        "id": 566007797,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1767313964
    },
    {
        "content": "<p>ok thanks for the information.</p>",
        "id": 566007875,
        "sender_full_name": "Antoine du Fresne von Hohenesche",
        "timestamp": 1767314052
    },
    {
        "content": "<p>To pick on one of many examples, I think that only an LLM could come up with</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">        </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Exists</span><span class=\"bp\">.</span><span class=\"n\">intro</span>\n<span class=\"w\">        </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Exists</span><span class=\"bp\">.</span><span class=\"n\">intro</span>\n<span class=\"w\">          </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Exists</span><span class=\"bp\">.</span><span class=\"n\">intro</span>\n<span class=\"w\">            </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">And</span><span class=\"bp\">.</span><span class=\"n\">intro</span>\n<span class=\"w\">              </span><span class=\"n\">on_goal</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Exists</span><span class=\"bp\">.</span><span class=\"n\">intro</span>\n<span class=\"w\">              </span><span class=\"n\">on_goal</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">              </span><span class=\"o\">}</span>\n<span class=\"w\">              </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">simp_all</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">not_false_eq_true</span><span class=\"o\">]</span>\n<span class=\"w\">              </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">simp_all</span><span class=\"w\"> </span><span class=\"n\">only</span>\n<span class=\"w\">          </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">hs</span>\n<span class=\"w\">            </span><span class=\"n\">simp_all</span><span class=\"w\"> </span><span class=\"n\">only</span>\n</code></pre></div>\n<p>There is basically nothing going on here and the LLM is writing meandering code.</p>",
        "id": 566008002,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1767314254
    },
    {
        "content": "<p>You are one of many people recently who have come here asking \"I have written an extremely long and unidiomatic proof using an LLM and would like to know how to get it into mathlib\" and I am not entirely sure how the community should go about explaining to such people that unfortunately there is still typically a huge amount of work to be done before their sloppy code is anywhere near acceptable for the library.</p>\n<p>The code quality review bar for mathlib is extremely high, for various reasons, and LLM-written code is very far from this bar right now.</p>",
        "id": 566008094,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1767314423
    },
    {
        "content": "<p>I completely understand. To be clear: I am not asking anyone to clean up this specific code for me. Since the file compiled, I was happy with the result, but I realize now that the code is sloppy and far too long for the library. You are right that the community needs to be clear with newcomers about this distinction, just as you were with me. I appreciate you taking the time to answer me directly.</p>",
        "id": 566008467,
        "sender_full_name": "Antoine du Fresne von Hohenesche",
        "timestamp": 1767315016
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"1010200\">@Antoine du Fresne von Hohenesche</span> </p>\n<p>You took the criticism like a champ. And while the proof is a bit messy, it’s <code>sorry</code>-free (which is already a real achievement). Now the fun begins: chipping away at the code line by line, sculpting it into a proof that can pass the scrutiny of the community.</p>\n<p>I am not much more than a novice myself, but have few suggestions, you might want to consider:</p>\n<h2>Check your <code>import</code>s.</h2>\n<p>You only need:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Analysis</span><span class=\"bp\">.</span><span class=\"n\">InnerProductSpace</span><span class=\"bp\">.</span><span class=\"n\">PiL2</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">LinearAlgebra</span><span class=\"bp\">.</span><span class=\"n\">Matrix</span><span class=\"bp\">.</span><span class=\"n\">Rank</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">LinearAlgebra</span><span class=\"bp\">.</span><span class=\"n\">Matrix</span><span class=\"bp\">.</span><span class=\"n\">BilinearForm</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">RingTheory</span><span class=\"bp\">.</span><span class=\"n\">MvPolynomial</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Sym</span><span class=\"bp\">.</span><span class=\"n\">Card</span>\n</code></pre></div>\n<h2>Explicit Variables in Definitions</h2>\n<p>In</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">distPoly</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">MvPolynomial</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∑</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">castLE</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">linarith</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">omega</span><span class=\"bp\">⟩</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"mi\">2</span>\n</code></pre></div>\n<p>you  might want to consider making <code>d</code> and <code>R</code> explicit, since they can not be inferred from other ones. </p>\n<p>If you define,</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">distPoly</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">MvPolynomial</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∑</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">castLE</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">linarith</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">omega</span><span class=\"bp\">⟩</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"mi\">2</span>\n</code></pre></div>\n<p>you can then write </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">degree_distPoly</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">distPoly</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">totalDegree</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>instead of </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">degree_distPoly</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">MvPolynomial</span><span class=\"bp\">.</span><span class=\"n\">totalDegree</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">distPoly</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MvPolynomial</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n</code></pre></div>\n<h2>Merge Lines</h2>\n<p>There places, where you do rewrites on one line and then again on next one. If the line length permits it, consider merging them into a single line.  The same goes for <code>obtain</code>. You can write:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">w</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">w_1</span><span class=\"o\">,</span><span class=\"n\">w_2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">left</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">w_3</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hr</span>\n</code></pre></div>\n<p>which is shorter than</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">w</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hr</span>\n<span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">w_1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">w_2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">left</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">right</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">w_3</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">right</span>\n<span class=\"n\">subst</span>\n</code></pre></div>\n<p><a href=\"https://gist.github.com/Citronhat/978b0232bc95c3fae4f072ea84039f14\">Here</a> is a version of your code with a few improvements. It cuts away just above 100 lines of code. It small step in the right direction, I think.</p>",
        "id": 566033465,
        "sender_full_name": "Peter Hansen",
        "timestamp": 1767343413
    },
    {
        "content": "<p>Yes, a sorry-free proof is a great achievement! We have an entire course at Imperial whose goal is to get people to sorry-free proofs and spend no time encouraging people to get stuff into mathlib -- it's all about the theorems. I didn't make these encouraging noises because I just answered the question because I'm a bit autistic. And turning a sloppy proof into a mathlib-ready one is probably a lot easier than writing a mathlib-ready one from scratch (unless it turns out that the entire approach is not mathlib-suitable, which I can't comment on because I'm not in the area). My general impression is that there are too many definitions but really you should be talking to experts in the area if you really want to tidy this up for possible inclusion into mathlib and are not content to just say \"yay I did it\". Note that I am not attempting to get FLT into mathlib, I am just attempting to say \"yay I did it\".</p>",
        "id": 566044270,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1767350826
    },
    {
        "content": "<p>Thank you Peter for the concrete help. I really appreciate you taking the time to review the code and especially for sharing the refactored version. I hadn't realized how bloated my imports were, and your point about merging the <code>obtain</code> lines is exactly the kind of idiomatic syntax I was missing (as Kevin noted, that block was definitely an artifact of me fighting the goal state step-by-step). I will update the gist.</p>\n<p>Thank you Kevin for the follow-up and the context regarding the \"sorry-free\" achievement. I genuinely value the honesty—it saves me from having unrealistic expectations.</p>\n<p>To provide a bit of background, this formalization is actually a 2-3 week project for a course I am taking at ETH Zürich. So, in the immediate term, reaching the \"sorry-free\" state to verify the theorem was the primary academic goal, and I am quite happy to just say (as you put it) \"yay I did it\" for the purpose of the grading.</p>\n<p>That said, I am still very interested in learning how to do this properly. I have another Lean project to do (again something combinatorial: Davenport-Schinzel Sequences).</p>\n<p>I do think my current file contains several results which could belong in Mathlib independently (e.g., bounding the rank of the sum of two matrices, the Croot-Lev-Pach lemma, or the linear independence of functions via the diagonal argument... maybe they are already there, but I didn't find them). For now, the code could be much shorter if some of these foundations were already in place. So maybe it is more reasonable to wait or participate in the formalization of these \"simpler\" lemmas first, rather than trying to upstream a theorem that requires all of them at once. It feels like I tried to forge a sword by brute force from scratch in the wild, instead of waiting for a proper furnace to make it.</p>\n<p>Thanks again to you both.</p>",
        "id": 566048091,
        "sender_full_name": "Antoine du Fresne von Hohenesche",
        "timestamp": 1767353609
    },
    {
        "content": "<p>Out of historical interest, Croot-Lev-Pach was already done in 2019: <a href=\"https://lean-forward.github.io/e-g/e-g.pdf\">https://lean-forward.github.io/e-g/e-g.pdf</a></p>",
        "id": 566051543,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1767355913
    },
    {
        "content": "<p>I'd suggest that an intermediary mechanism be created to link llm created \"proofs\" to editors for translation to mathlib. I'm a fan of the earth-fire-water abstract triplet where, in this case, llms are earth, fire is the editors that do the translation, and our source of truth, as close as we can get to it anyway, is mathlib. llms might produce slop but, in somewhat defense of them..they can produce a lot of slop? That triplet mechanism is rather generalizable, maybe it can find a place in Lean as well?</p>",
        "id": 566064702,
        "sender_full_name": "Matthew Coke",
        "timestamp": 1767364620
    }
]