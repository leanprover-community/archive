[
    {
        "content": "<p>Sorry to crosspost, but as it's been a week since the last time I asked: </p>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/compare/robertmaxton42/quiv-helper1\">This PR</a> (one of six 'helper' PRs for the PR constructing (co)limits in <code>Quiv</code>) doesn't pass CI because <code>simpNF</code> claims that <code>simp</code> can prove <code>limitSubobjectProduct_π</code> and its dual.  However, when I actually try it locally, <code>simp</code> doesn't work on its own. Is this a false positive, or am I misunderstanding what the linter is telling me here?</p>",
        "id": 513317871,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1745193513
    },
    {
        "content": "<p>Have you seen the full error message here: <a href=\"https://github.com/leanprover-community/mathlib4/actions/runs/14425381374/job/40453462576\">https://github.com/leanprover-community/mathlib4/actions/runs/14425381374/job/40453462576</a></p>",
        "id": 513318179,
        "sender_full_name": "Maja Kądziołka",
        "timestamp": 1745193749
    },
    {
        "content": "<p>also, does a <code>simp</code> with no modifiers make any progress on the left-hand side?</p>",
        "id": 513318198,
        "sender_full_name": "Maja Kądziołka",
        "timestamp": 1745193770
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"482773\">Maja Kądziołka</span> <a href=\"#narrow/channel/287929-mathlib4/topic/simpNF.20says.20simp.20can.20prove.20something.20it.20can't/near/513318179\">said</a>:</p>\n<blockquote>\n<p>Have you seen the full error message here: <a href=\"https://github.com/leanprover-community/mathlib4/actions/runs/14425381374/job/40453462576\">https://github.com/leanprover-community/mathlib4/actions/runs/14425381374/job/40453462576</a></p>\n</blockquote>\n<p>Yes, but it doesn't make much sense to me; I'm not even sure simp is using any of the <code>Fan.mk_</code> etc lemmas in this proof.</p>",
        "id": 513318774,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1745194217
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"482773\">Maja Kądziołka</span> <a href=\"#narrow/channel/287929-mathlib4/topic/simpNF.20says.20simp.20can.20prove.20something.20it.20can't/near/513318198\">said</a>:</p>\n<blockquote>\n<p>also, does a <code>simp</code> with no modifiers make any progress on the left-hand side?</p>\n</blockquote>\n<p>A <code>simp</code> with no modifiers makes no progress without unfolding <code>limitSubobjectProduct</code>.</p>",
        "id": 513318805,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1745194255
    },
    {
        "content": "<p><code>simp</code> can prove <code>limitSubobjectProduct_π</code> as claimed in the error message, but it needs to use <code>limitSubobjectProduct_eq_lift</code>, which is defined after it. That's why it didn't work when you tried to solve it with <code>simp</code>. So I think the simpNF linter is correctly complaining.</p>",
        "id": 513335143,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745206733
    },
    {
        "content": "<p>Er.... Well, yes. But the proof of <code>limitSubobjectProduct_eq_lift</code> itself makes use of <code>limitSubobjectProduct_π</code>; removing the <code>simp</code> from <code>limitSubobjectProduct_π</code> makes the former proof not go through.</p>",
        "id": 513335641,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1745207130
    },
    {
        "content": "<p>If you can't just pass the lemma directly to simp, you can use <code>@[local simp]</code> so that the simp tag is only used in this file</p>",
        "id": 513336182,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745207422
    },
    {
        "content": "<p>Mmm. I suppose I can do that, yeah. Seems a little backward but I guess it marginally reduces the number of simp lemmas</p>",
        "id": 513339074,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1745209286
    },
    {
        "content": "<p>I am also experiencing a problem where the simpNF linter is telling me a simp lemma can be proved by simp in <a href=\"https://github.com/leanprover-community/mathlib4/actions/runs/14631390517/job/41054189420?pr=24332\">this run</a>. But in my case, I can't use the simp call that the linter provides, because one of the lemmas being called is exactly the lemma that comes immediately after, that I am using this lemma to prove. What am I supposed to do about this?</p>",
        "id": 513993931,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1745459950
    },
    {
        "content": "<p>In that case, one of the lemmas should not be <code>@[simp]</code></p>",
        "id": 513994530,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745460294
    },
    {
        "content": "<p>It feels to me that both should be simp, In both cases the RHS is much more complicated. Which one shouldn't be simp?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">map_univ_comp_coe</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Multiset</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">((</span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">))))</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Multiset</span><span class=\"bp\">.</span><span class=\"n\">map_map</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Multiset</span><span class=\"bp\">.</span><span class=\"n\">map_univ_coe</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">map_univ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Multiset</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">((</span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp_rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">comp_apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)]</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">map_univ_comp_coe</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">f</span>\n</code></pre></div>",
        "id": 513995644,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1745460983
    },
    {
        "content": "<p>The lemma that the simpNF linter points out (the first one) should not be simp, since it is redundant.</p>\n<p>The fact that <code>Function.comp_apply</code> is actually applied here by <code>simp</code> seems very surprising, but it can be explained by the <code>congr</code> lemma <code>Multiset.map_congr</code></p>",
        "id": 513998012,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745462567
    }
]