[
    {
        "content": "<p>This is about a proposed more powerful version of the <code>variable</code> command.</p>\n<h1>Motivation</h1>\n<p>Often when developing some theory one first wants to prove something in a general case and then that stronger things hold in a \"special\" case. E.g., developing some module theory over a ring then proving extra results over a commutative ring, or proving some results about continuous functions on compact topological spaces, then \"specialising\" to compact uniform spaces to prove results about uniform continuity or something. (To be slightly more precise, B is a \"special case\" of A if hypothesis or structure B induces hypothesis or structure A in a canonical way that we have in mind.) I will illustrate with the example of <code>Ring</code> and <code>CommRing</code> for the rest of this message.</p>\n<p>Lean allows us to do this in the following form:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kn\">section</span><span class=\"w\"> </span><span class=\"n\">ForRings</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- Results true for general rings...</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">ForRings</span>\n\n<span class=\"kn\">section</span><span class=\"w\"> </span><span class=\"n\">ForCommRings</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- Results true for commutative rings...</span>\n<span class=\"c1\">-- We can use the results from the previous section, since there is an instance [CommRing R] -&gt; [Ring R]</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">ForCommRings</span>\n</code></pre></div>\n<p>However, this seems non-ideal in a few ways. Even though R will in fact be a ring throughout the whole file, we have to separate the variable declarations of <code>R</code> and <code>[Ring R]</code> and introduce a lot of sections and end commands. If we were also introducing an R-module M, we would have to duplicate at least the <code>[Module R M]</code> variable declaration as well (and more, if one particularly about the order of the variables). Moreover, I don't think this is how mathematicians naturally think - as in the language I used above, one thinks of \"specialising\" from <code>Ring</code> to <code>CommRing</code> temporarily, and certainly doesn't forget that M is an R-module and remember it after specialising.</p>\n<p>I think this is because the variable command can only add to the (end of the) context, forcing these workarounds when one wants to change the context in other ways. (<code>omit</code> doesn't remove variables from the context, only prevents them from being added to declarations - for example, I couldn't use <code>omit [Ring R]; variable [CommRing R]</code> because there's no way to tell Lean to replace the <code>Ring R</code> parameter to <code>Module R M</code> from the <code>[Ring R]</code> variable to the <code>Ring R</code> instance inferred from the <code>CommRing R</code> variable. <code>omit</code>/<code>include</code> is probably sufficient and works great if all structures and hypotheses are completely unbundled, but that's not the case in Mathlib.)</p>\n<h1>Proposal</h1>\n<p>I propose a new command to accomplish this (which could be called <code>variable</code> and shadow the default one if that's possible, or could have a new name like <code>modify_variables</code>, <code>replace_variables</code>, etc.) The syntax of the command would roughly be: specify sets of variables A to replace, B to introduce to replace A with, C to remove; and a way to produce terms of the types of A in terms of the remaining existing context plus the introduced variables of type B. Then the command would modify the current telescope of variables by removing A and C, introducing B, and replacing all references to the variables in A in subsequent variable types with the expressions for them in terms of B.</p>\n<p>For example, the above example would become (with a rough syntax for the new command, where you provide the \"conversion\" terms in tactic mode starting with one goal for each variable in A):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- Theorems for general rings...</span>\n\n<span class=\"kn\">section</span><span class=\"w\"> </span><span class=\"n\">ForCommRings</span>\n<span class=\"n\">replace_variables</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"n\">infer_instance</span>\n<span class=\"c1\">-- The [Ring R] in the type of the variable [Module R M] would now</span>\n<span class=\"c1\">-- have been automatically replaced with CommRing.toRing [CommRing R].</span>\n\n<span class=\"c1\">-- Theorems true for commutative rings...</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">ForCommRings</span>\n\n<span class=\"c1\">-- Old context restored - back to non-commutative rings</span>\n<span class=\"c1\">-- It should also be possible to use `replace_variables` with `in` for specialising hypotheses for a single conclusion.</span>\n</code></pre></div>\n<ol>\n<li>Is something resembling this capability already in Lean 4 or Mathlib?</li>\n<li>If not, would it be desirable?</li>\n</ol>\n<h1>P.S.</h1>\n<p>Some notes about the proposed behaviour:</p>\n<ul>\n<li>I am not sure whether in practice the functionality of removing variables will be necessary, but on the other hand it seems like it would be the easiest to implement anyway. I included it because I feel like there might be a case where some subset C of the old context <em>can't</em> be given in terms of B, but we don't need it and thus need it to be gone to do the replacement. I haven't thought of any examples of this yet, though.</li>\n<li>One subtlety in the implementation would be deciding where in the telescope of variables to insert B. I am not sure whether it would be desirable to allow the user to specify this or compute the \"best\" place to insert them. I think it should be straightforward, if not easy, to compute constraints on where each variable in B can be inserted, but it's not clear to me whether they should be inserted as late as possible or as early as possible, etc. Some user control might also be helpful for scenarios where the exact order of variables is important to give definitions made using them a nice interface.</li>\n</ul>",
        "id": 524893437,
        "sender_full_name": "Raghuram",
        "timestamp": 1750341796
    },
    {
        "content": "<p>Currently <code>variable</code> telescopes are stored completely syntactically (they are re-elaborated for every declaration).</p>\n<p>I think it wouldn't be hard for someone to make an elaborator for the syntax</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>that would replace the given binder with another. It would be a hack that looks at internals, but it's doable.</p>",
        "id": 524901661,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750344458
    },
    {
        "content": "<p>I see. I might try to implement a basic proof-of-concept then.</p>",
        "id": 524902301,
        "sender_full_name": "Raghuram",
        "timestamp": 1750344672
    },
    {
        "content": "<p>Another thing that's possible, which I haven't seen people do yet, is make macros for telescopes. E.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">macro</span><span class=\"w\"> </span><span class=\"s2\">\"variable_module \"</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">M</span><span class=\"o\">])</span>\n</code></pre></div>\n<p>and then you can do</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"n\">variable_module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span>\n</code></pre></div>\n<p>and later in another section do</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"n\">variable_module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span>\n</code></pre></div>\n<p>It's clunky, but it's a way to use telescopes as near-first-class objects.</p>",
        "id": 524902444,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750344729
    },
    {
        "content": "<p>In fact, it wouldn't be hard to make a <code>telescope</code> command that defines such parameterized macros.</p>",
        "id": 524902627,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750344792
    },
    {
        "content": "<p>In fact, it was recently learning about <code>variable?</code>, which achieves a similar effect (in a narrower context than arbitrary telescope macros), that got me thinking about this.</p>",
        "id": 524903452,
        "sender_full_name": "Raghuram",
        "timestamp": 1750345092
    },
    {
        "content": "<p>I almost mentioned <code>variable?</code>, but it didn't seem like what you were looking for.</p>",
        "id": 524904381,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750345390
    },
    {
        "content": "<p>Here's a telescope-construction creator. Example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">telescope</span><span class=\"w\"> </span><span class=\"s2\">\"mytele \"</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Repr</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>This makes it so that if you use the <code>mytele X</code> command, you get <code>[DecidableEq X] [Repr X]</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"s2\">\"telescope\"</span><span class=\"w\"> </span><span class=\"n\">str</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ppSpace</span><span class=\"w\"> </span><span class=\"n\">ident</span><span class=\"o\">)</span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"s2\">\" =&gt;\"</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ppSpace</span><span class=\"w\"> </span><span class=\"n\">colGt</span><span class=\"w\"> </span><span class=\"n\">bracketedBinder</span><span class=\"o\">)</span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span>\n\n<span class=\"sd\">/-- Wrap all occurrences of the given `ident` nodes in antiquotations -/</span>\n<span class=\"kn\">private</span><span class=\"w\"> </span><span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">antiquote</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">vars</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">Syntax</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">stx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Syntax</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Syntax</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">id</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">vars</span><span class=\"bp\">.</span><span class=\"n\">any</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">var</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">var</span><span class=\"bp\">.</span><span class=\"n\">getId</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"bp\">.</span><span class=\"n\">getId</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"n\">Syntax</span><span class=\"bp\">.</span><span class=\"n\">mkAntiquotNode</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">kind</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"ss\">`term</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">isPseudoKind</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"k\">else</span>\n<span class=\"w\">      </span><span class=\"n\">stx</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Syntax</span><span class=\"bp\">.</span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">args</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Syntax</span><span class=\"bp\">.</span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">args</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">antiquote</span><span class=\"w\"> </span><span class=\"n\">vars</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">stx</span>\n\n<span class=\"kn\">macro_rules</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">command</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">telescope</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">name</span><span class=\"o\">:</span><span class=\"n\">str</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">vars</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">binders</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">binders'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TSyntaxArray</span><span class=\"w\"> </span><span class=\"ss\">``Parser.Term.bracketedBinder</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">      </span><span class=\"n\">binders</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">binder</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">antiquote</span><span class=\"w\"> </span><span class=\"n\">vars</span><span class=\"w\"> </span><span class=\"n\">binder</span><span class=\"bp\">⟩</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">args</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TSyntaxArray</span><span class=\"w\"> </span><span class=\"ss\">``Parser.Command.macroArg</span><span class=\"w\"> </span><span class=\"bp\">←</span>\n<span class=\"w\">      </span><span class=\"n\">vars</span><span class=\"bp\">.</span><span class=\"n\">mapM</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">var</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">Parser</span><span class=\"bp\">.</span><span class=\"n\">Command</span><span class=\"bp\">.</span><span class=\"n\">macroArg</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">var</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kn\">macro</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">name</span><span class=\"o\">:</span><span class=\"n\">str</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">args</span><span class=\"o\">]</span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">command</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">binders'</span><span class=\"bp\">*</span><span class=\"o\">))</span>\n\n<span class=\"n\">telescope</span><span class=\"w\"> </span><span class=\"s2\">\"mytele \"</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Repr</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"n\">mytele</span><span class=\"w\"> </span><span class=\"n\">X</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">where</span>\n<span class=\"c1\">-- variable (X : Type) [DecidableEq✝ X] [Repr✝ X]</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"s2\">\"equal\"</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">toString</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">repr</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 524904959,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750345596
    },
    {
        "content": "<p>(This is a reiteration of something I tried in Lean 3 <a href=\"https://github.com/leanprover-community/mathlib3/pull/10254\">a few years ago</a>, but it's really nice this time being able to work with Syntax instead of strings!)</p>",
        "id": 524905410,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750345736
    },
    {
        "content": "<p>To confirm I'm reading the implementation correctly,</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">telescope</span><span class=\"w\"> </span><span class=\"s2\">\"my_tele \"</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Repr</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>expands to</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">macro</span><span class=\"w\"> </span><span class=\"s2\">\"my_tele \"</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">command</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">a</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Repr</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">a</span><span class=\"o\">])</span>\n</code></pre></div>\n<p>?</p>",
        "id": 524907746,
        "sender_full_name": "Raghuram",
        "timestamp": 1750346603
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/287929-mathlib4/topic/More.20general.20command.20to.20modify.20variables/near/524901661\">said</a>:</p>\n<blockquote>\n<p>Currently <code>variable</code> telescopes are stored completely syntactically (they are re-elaborated for every declaration).</p>\n</blockquote>\n<p>In that case, why does <code>variable {R M : Type*} [Module R M]</code> fail? Shouldn't it wait until a declaration before it elaborates the <code>Module R M</code> and fails to synthesise <code>Semiring R</code> etc.?</p>",
        "id": 524971273,
        "sender_full_name": "Raghuram",
        "timestamp": 1750388756
    },
    {
        "content": "<p>Is it because of this application of <code>Term.elabBinders</code> in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Elab.Command.elabVariable%3F#doc\">docs#Lean.Elab.Command.elabVariable?</a></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">    </span><span class=\"n\">runTermElabM</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">withSynthesize</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">withAutoBoundImplicit</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span>\n<span class=\"w\">      </span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">elabBinders</span><span class=\"w\"> </span><span class=\"n\">binders</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">        </span><span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 525115444,
        "sender_full_name": "Raghuram",
        "timestamp": 1750463391
    },
    {
        "content": "<p>Yes, <code>variable</code> also elaborates the binders to check that they elaborate, but then it throws the result away.</p>",
        "id": 525116476,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750464567
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/M5lqw1Bca3fYCMNxZp9UrNPH/ReplaceVariables.lean\">ReplaceVariables.lean</a><br>\nHere is a first pass at <code>replace_variables</code>. It's still rather buggy, but I would appreciate any feedback from using it or reading the implementation.</p>\n<p>The code inline:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">! # Util -/</span>\n<span class=\"kn\">section</span><span class=\"w\"> </span><span class=\"n\">Util</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"bp\">.</span><span class=\"n\">findFinIdxM?</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"kd\">@[</span><span class=\"n\">specialize</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"n\">find</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">        </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">⟩</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"k\">else</span>\n<span class=\"w\">        </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">sub_succ_lt_self</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">        </span><span class=\"n\">find</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"k\">else</span>\n<span class=\"w\">      </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"w\">  </span><span class=\"n\">termination_by</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">i</span>\n<span class=\"w\">  </span><span class=\"n\">find</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n\n<span class=\"c1\">-- Strangely, `open Lean.Parser.Term in` and `open Lean.Parser.Term (bracketedBinderF)` (within a section) work,</span>\n<span class=\"c1\">-- but `open Lean.Parser.Term (bracketedBinderF) in` doesn't.</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Parser</span><span class=\"bp\">.</span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bracketedBinder</span><span class=\"w\"> </span><span class=\"n\">bracketedBinderF</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- `Lean.Elab.Command.getBracketedBinderIds`, but for a more general kind of monad. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">getBracketedBinderIds</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MonadError</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Syntax</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">bracketedBinderF</span><span class=\"bp\">|</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">ids</span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">[:</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">ty?</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"n\">annot?</span><span class=\"o\">)</span><span class=\"bp\">?</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">ids</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">Syntax</span><span class=\"bp\">.</span><span class=\"n\">getId</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">bracketedBinderF</span><span class=\"bp\">|</span><span class=\"o\">{</span><span class=\"bp\">$</span><span class=\"n\">ids</span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">[:</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">ty?</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"o\">})</span><span class=\"w\">             </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">ids</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">Syntax</span><span class=\"bp\">.</span><span class=\"n\">getId</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">bracketedBinderF</span><span class=\"bp\">|</span><span class=\"o\">⦃</span><span class=\"bp\">$</span><span class=\"n\">ids</span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">$_</span><span class=\"o\">⦄)</span><span class=\"w\">                   </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">ids</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">Syntax</span><span class=\"bp\">.</span><span class=\"n\">getId</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">bracketedBinderF</span><span class=\"bp\">|</span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">$_</span><span class=\"o\">])</span><span class=\"w\">                     </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">id</span><span class=\"bp\">.</span><span class=\"n\">getId</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">bracketedBinderF</span><span class=\"bp\">|</span><span class=\"o\">[</span><span class=\"bp\">$_</span><span class=\"o\">])</span><span class=\"w\">                           </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">Name</span><span class=\"bp\">.</span><span class=\"n\">anonymous</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\">                                                  </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">throwUnsupportedSyntax</span>\n\n<span class=\"sd\">/-- Splits a `bracketedBinder` into a series of binders, one per variable introduced. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">splitBinder</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MonadQuotation</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MonadError</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">TSyntax</span><span class=\"w\"> </span><span class=\"ss\">``bracketedBinder</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">TSyntax</span><span class=\"w\"> </span><span class=\"ss\">``bracketedBinder</span><span class=\"o\">))</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">bracketedBinderF</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">ids</span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">[:</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">type?</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">  </span><span class=\"n\">ids</span><span class=\"bp\">.</span><span class=\"n\">mapM</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">bracketedBinderF</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">[:</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">type?</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"o\">))</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">bracketedBinderF</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">$</span><span class=\"n\">ids</span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">[:</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">type?</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">  </span><span class=\"n\">ids</span><span class=\"bp\">.</span><span class=\"n\">mapM</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">bracketedBinderF</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">$</span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">[:</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">type?</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"o\">})</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">bracketedBinderF</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">⦃</span><span class=\"bp\">$</span><span class=\"n\">ids</span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">[:</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">type?</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"o\">⦄)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">  </span><span class=\"n\">ids</span><span class=\"bp\">.</span><span class=\"n\">mapM</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">bracketedBinderF</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">⦃</span><span class=\"bp\">$</span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">[:</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">type?</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"o\">⦄)</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">bracketedBinderF</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">type</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">  </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">bracketedBinderF</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">type</span><span class=\"o\">])]</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">bracketedBinderF</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">type</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">  </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">bracketedBinderF</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">type</span><span class=\"o\">])]</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">throwUnsupportedSyntax</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">Util</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">! # Syntax -/</span>\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Parser</span><span class=\"bp\">.</span><span class=\"n\">Command</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Parser</span><span class=\"bp\">.</span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">instBinder</span><span class=\"w\"> </span><span class=\"n\">bracketedBinder</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"sd\">/-- A single clause for the `replace_variables` command. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">replaceVariablesItem</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">leading_parser</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">ident</span><span class=\"w\"> </span><span class=\"bp\">&lt;|&gt;</span><span class=\"w\"> </span><span class=\"n\">instBinder</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"n\">unicodeSymbol</span><span class=\"w\"> </span><span class=\"s2\">\" → \"</span><span class=\"w\"> </span><span class=\"s2\">\" -&gt; \"</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"n\">checkColGt</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"n\">many</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">bracketedBinder</span>\n\n<span class=\"sd\">/-- `replace_variables id₁ → b₁, …` replaces variable `id₁` with new ones `b₁`, and so on.</span>\n\n<span class=\"sd\">Each `id` specifies a currently declared variable, either by name using the syntax `name` or by type using the syntax `[type]`.</span>\n<span class=\"sd\">Each `b` is a list of new variable binders to replace the variable specified by `id` with. -/</span>\n<span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">replaceVariables</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"s2\">\"replace_variables \"</span><span class=\"w\"> </span><span class=\"n\">replaceVariablesItem</span><span class=\"o\">,</span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Parser</span><span class=\"bp\">.</span><span class=\"n\">Command</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">! # Elab -/</span>\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">Command</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Parser</span><span class=\"bp\">.</span><span class=\"n\">Command</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">replaceVariablesItem</span><span class=\"w\"> </span><span class=\"n\">replaceVariables</span><span class=\"o\">)</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Parser</span><span class=\"bp\">.</span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bracketedBinder</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- Parse a `replace_variables` clause into pattern and new binders. -/</span>\n<span class=\"c1\">-- Based on code in the implementation of `Lean.Elab.Command.elabOmit`.</span>\n<span class=\"kn\">private</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">parseReplaceVariablesItem</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TSyntax</span><span class=\"w\"> </span><span class=\"ss\">``replaceVariablesItem</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">    </span><span class=\"n\">TermElabM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Syntax</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Name</span><span class=\"w\"> </span><span class=\"bp\">⊕</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">TSyntax</span><span class=\"w\"> </span><span class=\"ss\">``bracketedBinder</span><span class=\"o\">))</span>\n<span class=\"c1\">-- TODO how to get `%$tk` on the correct node?</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">replaceVariablesItem</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">var</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"w\"> </span><span class=\"bp\">→%$</span><span class=\"n\">tk</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">binders</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">replaceVariablesItem</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">var</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">$_</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">→%$</span><span class=\"n\">tk</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">binders</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">tk</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"n\">var</span><span class=\"bp\">.</span><span class=\"n\">getId</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">binders</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">replaceVariablesItem</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">type</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">→%$</span><span class=\"n\">tk</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">binders</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">tk</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">withoutErrToSorry</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">elabTermAndSynthesize</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"o\">),</span>\n<span class=\"w\">          </span><span class=\"n\">binders</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">throwUnsupportedSyntax</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Meta</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">isDefEq</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"sd\">/-- Matches the variable `id` against `pattern`.</span>\n\n<span class=\"sd\">If `pattern` is a `Name`, it names a variable, so `id` must have the same name.</span>\n<span class=\"sd\">If `pattern` is an `Expr`, it specifies the type, so the type of `id` must unify with it. -/</span>\n<span class=\"c1\">-- Based on code in the implementation of `Lean.Elab.Command.elabOmit`.</span>\n<span class=\"kn\">private</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">variableMatch?</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FVarId</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Sum</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"n\">Bool</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"bp\">.</span><span class=\"n\">getDecl</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">userName</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"n\">name</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">decl</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"bp\">.</span><span class=\"n\">getDecl</span>\n<span class=\"w\">    </span><span class=\"c1\">-- Might as well allow `[type]` as syntax for matching any variable with of type `type`, rather than only instance-implicit ones.</span>\n<span class=\"w\">    </span><span class=\"c\">/-</span><span class=\"cm\"> if !decl.binderInfo.isInstImplicit then pure false else -/</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mctx</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getMCtx</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">isDefEq</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">decl</span><span class=\"bp\">.</span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"bp\">&lt;*</span><span class=\"w\"> </span><span class=\"n\">setMCtx</span><span class=\"w\"> </span><span class=\"n\">mctx</span>\n\n<span class=\"c1\">-- Heavily based on `elabOmit`, `replaceBinderAnnotation` and `elabVariable`.</span>\n<span class=\"kd\">@[</span><span class=\"n\">command_elab</span><span class=\"w\"> </span><span class=\"n\">replaceVariables</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">elabReplaceVariables</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CommandElab</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">replace_variables</span><span class=\"bp\">%$</span><span class=\"n\">tk</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">replacements</span><span class=\"o\">:</span><span class=\"n\">replaceVariablesItem</span><span class=\"o\">,</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"c1\">-- • Get some stuff from the scope that we'll need inside the `TermElabM`.</span>\n<span class=\"w\">  </span><span class=\"c1\">-- `binderData` is an array of the same length as the total number of variables,</span>\n<span class=\"w\">  </span><span class=\"c1\">-- consisting of the binders introducing each variable</span>\n<span class=\"w\">  </span><span class=\"c1\">-- (thus, each binder is repeated as many times as it introduces variables).</span>\n<span class=\"w\">  </span><span class=\"c1\">-- `oldVarUIds` is simply the current value of `scope.varUIds`.</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">binderData</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">oldVarUIds</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">scope</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getScope</span>\n<span class=\"w\">    </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">scope</span><span class=\"bp\">.</span><span class=\"n\">varDecls</span><span class=\"bp\">.</span><span class=\"n\">flatMapM</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">decl</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">liftTermElabM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">splitBinder</span><span class=\"w\"> </span><span class=\"n\">decl</span><span class=\"o\">),</span>\n<span class=\"w\">          </span><span class=\"n\">scope</span><span class=\"bp\">.</span><span class=\"n\">varUIds</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"c1\">-- • Elaborate current variables, as in `elabOmit`.</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">newVarDecls</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">newVarUIds</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">runTermElabM</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">oldVars</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">synthesizeSyntheticMVarsNoPostponing</span>\n<span class=\"w\">    </span><span class=\"n\">Core</span><span class=\"bp\">.</span><span class=\"n\">resetMessageLog</span>\n<span class=\"w\">    </span><span class=\"c\">/-</span><span class=\"cm\"> Lean.logInfo m!\"{oldVars.zip (binderData.zip oldVarUIds)}\" -/</span>\n\n<span class=\"w\">    </span><span class=\"c1\">-- • Parse the arguments to command (using the elaborated context).</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">replacements</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">replacements</span><span class=\"bp\">.</span><span class=\"n\">getElems</span><span class=\"bp\">.</span><span class=\"n\">mapM</span><span class=\"w\"> </span><span class=\"n\">parseReplaceVariablesItem</span>\n\n<span class=\"w\">    </span><span class=\"c1\">-- • Build new list of variable declarations (and `varUId`s for the sake of `Scope`).</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">newVarDecls</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">TSyntax</span><span class=\"w\"> </span><span class=\"ss\">``bracketedBinder</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[]</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">newVarUIds</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[]</span>\n<span class=\"w\">    </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">var</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">oldVars</span><span class=\"bp\">.</span><span class=\"n\">reverse</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">decl</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">binderData</span><span class=\"bp\">.</span><span class=\"n\">reverse</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">varUId</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">oldVarUIds</span><span class=\"bp\">.</span><span class=\"n\">reverse</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">fvar</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">var</span><span class=\"bp\">.</span><span class=\"n\">fvarId!</span>\n<span class=\"w\">      </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">idx</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">replacements</span><span class=\"bp\">.</span><span class=\"n\">findFinIdxM?</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">pattern</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">↦</span>\n<span class=\"w\">                          </span><span class=\"n\">variableMatch?</span><span class=\"w\"> </span><span class=\"n\">fvar</span><span class=\"w\"> </span><span class=\"n\">pattern</span>\n<span class=\"w\">      </span><span class=\"k\">then</span>\n<span class=\"w\">        </span><span class=\"c1\">-- Replace this variable with a list of binders `newBinders`.</span>\n<span class=\"w\">        </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">newBinders</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">replacements</span><span class=\"o\">[</span><span class=\"n\">idx</span><span class=\"o\">]</span>\n<span class=\"w\">        </span><span class=\"n\">replacements</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">replacements</span><span class=\"bp\">.</span><span class=\"n\">eraseIdx</span><span class=\"w\"> </span><span class=\"n\">idx</span>\n<span class=\"w\">        </span><span class=\"n\">newVarDecls</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">newVarDecls</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">newBinders</span>\n<span class=\"w\">        </span><span class=\"n\">newVarUIds</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">newVarUIds</span><span class=\"w\"> </span><span class=\"bp\">++</span>\n<span class=\"w\">          </span><span class=\"c1\">-- This is from `Lean.Elab.Command.replaceBinderAnnotations`.</span>\n<span class=\"w\">          </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">newBinders</span><span class=\"bp\">.</span><span class=\"n\">flatMapM</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">getBracketedBinderIds</span><span class=\"o\">)</span>\n<span class=\"w\">                        </span><span class=\"bp\">|&gt;.</span><span class=\"n\">mapM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">withFreshMacroScope</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">MonadQuotation</span><span class=\"bp\">.</span><span class=\"n\">addMacroScope</span><span class=\"o\">))</span>\n<span class=\"w\">      </span><span class=\"k\">else</span>\n<span class=\"w\">        </span><span class=\"c1\">-- Preserve this variable.</span>\n<span class=\"w\">        </span><span class=\"n\">newVarDecls</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">newVarDecls</span><span class=\"bp\">.</span><span class=\"n\">push</span><span class=\"w\"> </span><span class=\"n\">decl</span>\n<span class=\"w\">        </span><span class=\"n\">newVarUIds</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">newVarUIds</span><span class=\"bp\">.</span><span class=\"n\">push</span><span class=\"w\"> </span><span class=\"n\">varUId</span>\n<span class=\"w\">    </span><span class=\"c\">/-</span><span class=\"cm\"> Lean.logInfo m!\"Leftover replacements: {replacements.map (·.2.1)}\" -/</span>\n<span class=\"w\">    </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">tk</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">pattern</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">replacements</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"n\">throwErrorAt</span><span class=\"w\"> </span><span class=\"n\">tk</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">pattern</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">                      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"s2\">\"no variable found with name {name}\"</span>\n<span class=\"w\">                      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"s2\">\"no variable found with type unifying with {type}\"</span>\n<span class=\"w\">    </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">newVarDecls</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">newVarUIds</span><span class=\"o\">)</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- • Elaborate the new variable telescope to check that it is valid, as in `elabVariable`.</span>\n<span class=\"w\">  </span><span class=\"n\">liftTermElabM</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">withSynthesize</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">withAutoBoundImplicit</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span>\n<span class=\"w\">  </span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">elabBinders</span><span class=\"w\"> </span><span class=\"n\">newVarDecls</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">addAutoBoundImplicits</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">tk</span><span class=\"bp\">.</span><span class=\"n\">getTailPos?</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">canonicalOnly</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">))</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- • Finally, modify the scope.</span>\n<span class=\"w\">  </span><span class=\"n\">modifyScope</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">scope</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">scope</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"n\">varDecls</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">newVarDecls</span><span class=\"bp\">.</span><span class=\"n\">reverse</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">varUIds</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">newVarUIds</span><span class=\"bp\">.</span><span class=\"n\">reverse</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">includedVars</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">scope</span><span class=\"bp\">.</span><span class=\"n\">includedVars</span><span class=\"bp\">.</span><span class=\"n\">filter</span><span class=\"w\"> </span><span class=\"n\">newVarUIds</span><span class=\"bp\">.</span><span class=\"n\">contains</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">omittedVars</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">scope</span><span class=\"bp\">.</span><span class=\"n\">omittedVars</span><span class=\"bp\">.</span><span class=\"n\">filter</span><span class=\"w\"> </span><span class=\"n\">newVarUIds</span><span class=\"bp\">.</span><span class=\"n\">contains</span>\n<span class=\"w\">  </span><span class=\"o\">}</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">throwUnsupportedSyntax</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">Command</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">!</span>\n<span class=\"cm\">Known issues:</span>\n<span class=\"cm\">• If re-elaborating after modifying results in errors, they are shown on the original variable declaration.</span>\n<span class=\"cm\">• If `autoImplicit` is false while executing `replace_variables`, there are errors even for variables which were declared.</span>\n<span class=\"cm\">• Errors for variables not found are on the arrow.</span>\n<span class=\"cm\">• Unused variable linting is applied to the newly introduced binders for some reason.</span>\n<span class=\"cm\">Notes:</span>\n<span class=\"cm\">• It is possible to create accepted variable telescopes that are rejected when used in a declaration, if `autoImplicit` is true for `replace_variables` but not for the declaration.</span>\n<span class=\"cm\">  But this is true for `variable` as well.</span>\n<span class=\"cm\">• The elaboration check for `replace_variables` does not seem to consider previous variables in typeclass inference, the way that `variable` does.</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 525419082,
        "sender_full_name": "Raghuram",
        "timestamp": 1750720115
    },
    {
        "content": "<p>Also the rudimentary tests I've written so far:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">section</span><span class=\"w\"> </span><span class=\"n\">Test1</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Mul</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">SMul</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- variable {R M : Type _} [Add R] [Mul R] [Add M] [SMul R M]</span>\n<span class=\"bp\">#</span><span class=\"kn\">where</span>\n\n<span class=\"c1\">-- TODO stop it from linting that α is unused</span>\n<span class=\"n\">replace_variables</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span>\n<span class=\"c1\">-- variable (α : Type _) {M : Type _} [Add R] [Mul R] [Add M] [SMul R M]</span>\n<span class=\"bp\">#</span><span class=\"kn\">where</span>\n\n<span class=\"c1\">-- no variable found with type unifying with `Pow R`</span>\n<span class=\"n\">replace_variables</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Pow</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Mul</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- With autoImplicit false, would say \"unknown identifier 'N'\".</span>\n<span class=\"c1\">-- However, this causes errors on the first `variable` line.</span>\n<span class=\"c1\">-- set_option autoImplicit false in</span>\n<span class=\"n\">replace_variables</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Mul</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"kn\">where</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">Test1</span>\n\n<span class=\"kn\">section</span><span class=\"w\"> </span><span class=\"n\">TestInstances</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">R</span>\n\n<span class=\"c1\">-- `inst.toRing`</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">R</span>\n<span class=\"c1\">-- failed to synthesize `CommRing R`</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">R</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">CommModule</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">M</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"c1\">-- TODO fix: causes error at `Module R M`</span>\n<span class=\"n\">replace_variables</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">TestInstances</span>\n</code></pre></div>",
        "id": 525419386,
        "sender_full_name": "Raghuram",
        "timestamp": 1750720323
    }
]