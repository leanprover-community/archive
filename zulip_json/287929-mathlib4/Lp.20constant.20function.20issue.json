[
    {
        "content": "<p>Suppose we have</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MeasurableSpace</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Measure</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>For general <code>p</code>, we have constant functions in <code>Lp R p μ</code> provided we have <code>IsFiniteMeasure μ</code>. This requirement is unnecessary if <code>p= \\infty</code>. There are many situations where we are going to want essentially bounded constant functions where the measure isn't finite, and to have an associated <code>One</code> instance in this case. How to best handle this so that we don't later end up with colliding <code>One</code> instances when we have L\\infty over a finite measure space?</p>",
        "id": 537527356,
        "sender_full_name": "Jon Bannon",
        "timestamp": 1756921699
    },
    {
        "content": "<p>make the <code>One</code> instances defeq?</p>",
        "id": 537527555,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756921777
    },
    {
        "content": "<p>if you don't do anything weird this should just be automatic</p>",
        "id": 537527601,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756921794
    },
    {
        "content": "<p>I think they will be, but <span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span>  was wondering whether it would be better to generalize <code>Lp.const</code> to take either a finite measure or have <code>p := ∞</code> (solved with an autoParam so the user need never supply it)</p>",
        "id": 537527750,
        "sender_full_name": "Jon Bannon",
        "timestamp": 1756921850
    },
    {
        "content": "<p>like <code>(small : p = ⊤ ∨ IsFiniteMeasure μ := by first | exact Or.inl rfl | exact Or.inr inferInstance)</code>?</p>",
        "id": 537528077,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756921963
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Lp.20constant.20function.20issue/near/537527555\">said</a>:</p>\n<blockquote>\n<p>make the <code>One</code> instances defeq?</p>\n</blockquote>\n<p>This is safe, but you still end up having to repeat every lemma / downstream instance</p>",
        "id": 537531571,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1756923418
    },
    {
        "content": "<p>Another option would be to instroduce an <code>Lp.HasConst</code> typeclass, instantiated for both cases</p>",
        "id": 537531675,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1756923461
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Lp.20constant.20function.20issue/near/537531571\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Lp.20constant.20function.20issue/near/537527555\">said</a>:</p>\n<blockquote>\n<p>make the <code>One</code> instances defeq?</p>\n</blockquote>\n<p>This is safe, but you still end up having to repeat every lemma / downstream instance</p>\n</blockquote>\n<p>The thing I was worried about for this was actually performance. In particular, in the case when <code>p := ∞</code> and <code>μ.IsFiniteMeasure</code>, then there would be two <code>One</code> instances, and Lean may have to unfold a lot sometimes to see they are equal (e.g., if one of them is embedded in a <code>NormedCommRing</code> instance).</p>",
        "id": 537532749,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1756923947
    },
    {
        "content": "<p>I think that unfolding is not all that different to what it has to do anyway for two different paths from<code>NormedCommRing</code></p>",
        "id": 537563137,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1756938841
    }
]