[
    {
        "content": "<p>I would like to get more feedback on <a href=\"https://github.com/leanprover-community/mathlib4/pull/16421\">#16421</a> <code>QuotLike</code> API. This typeclass is primarily for use by type synonyms of <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Core.html#Quot.sound\">Quot</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Quotient#doc\">docs#Quotient</a>. Using <code>QuotLike</code> API for type synonyms of <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Core.html#Quot.sound\">Quot</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Quotient#doc\">docs#Quotient</a> will avoid defeq abuse caused by directly using <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Core.html#Quot.sound\">Quot</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Quotient#doc\">docs#Quotient</a> APIs.</p>\n<p>This PR also adds some typeclasses to support different ways to find the quotient map that should be used, which resolves the problem mentioned in <a href=\"https://github.com/leanprover-community/mathlib4/blob/9b16c5d7fb54a2f624ce50e9b4f9de1e2a26b963/Mathlib/Data/Quot.lean#L200-L204\">this porting note</a>.</p>\n<p>I expect most of the APIs in mathlib that use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Quotient#doc\">docs#Quotient</a> to migrate to <code>QuotLike</code> to avoid defeq abuse and duplication issues. It has been tested in <a href=\"https://github.com/leanprover-community/mathlib4/pull/16428\">#16428</a>, and works fine up to <code>LinearAlgebra.Quotient.Basic</code>.</p>",
        "id": 480257030,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1730588491
    },
    {
        "content": "<p>Can you please give some examples of existing issues that this would solve?</p>",
        "id": 480259211,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1730590715
    },
    {
        "content": "<p>To be honest, it’s not clear to me why we would want this change. The class <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SetLike#doc\">docs#SetLike</a> is useful because we frequently have bundled subobjects in the algebraic hierarchy. But that’s not the case for quotients.</p>",
        "id": 480259255,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1730590786
    },
    {
        "content": "<p>What sort of def-eq abuse? The def-eqs that exist for definitions such as <code>Quotient.lift</code> are very convenient ones, and are presumably the whole reason we treat <code>Quot.sound</code> as an axiom instead of just declaring the type of equivalence classes.</p>",
        "id": 480261827,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730593309
    },
    {
        "content": "<p>Maybe this isn't the best example. We recently cleared up some <code>Quotient</code> API usage in <a href=\"https://github.com/leanprover-community/mathlib4/pull/18205\">#18205</a>, replacing them with the API duplicated for <code>Cardinal</code>. Similarly, we may have to duplicate a lot of the <code>Quotient</code> API for every type synonym of <code>Quotient</code>.</p>",
        "id": 480263130,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1730594541
    },
    {
        "content": "<p>Using the <code>QuotLike</code> API doesn't break defeq. It just doesn't always produce <code>Quotient</code> in the proof, but instead the type you want. Then there's no need to copy the quotient API for various types.</p>",
        "id": 480263255,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1730594676
    },
    {
        "content": "<p>Well, in that case, the issue was that the preferred form of the quotient is <code>#x</code> rather than <code>[[x]]</code>. Something similar happens with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ordinal.inductionOn#doc\">docs#Ordinal.inductionOn</a>, which uses <code>type r</code> rather than <code>[[(a, r, wo)]]</code>.</p>",
        "id": 480263318,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730594749
    },
    {
        "content": "<p>Is that the issue being solved?</p>",
        "id": 480263386,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730594809
    },
    {
        "content": "<p>Currently after almost every quotient type is defined, the first thing to do is to define a constructor that is a synonym for <code>Quotient.mk</code>, and the second thing might be to define a simp lemma to turn <code>Quotient.mk</code> into the custom constructor. I hope <code>QuotLike</code> will make us not have to do that.</p>",
        "id": 480263747,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1730595212
    },
    {
        "content": "<p>In <a href=\"https://github.com/leanprover-community/mathlib4/pull/16428\">#16428</a> I made <code>#</code> another notation for <code>mkQ</code>, but I haven't tested it further.</p>",
        "id": 480263858,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1730595321
    },
    {
        "content": "<p>Oh, so the idea is every type can declare a <code>QuotLike</code> instance using whatever the preferred form of the constructor is? That seems very useful.</p>",
        "id": 480264189,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730595644
    },
    {
        "content": "<p>Out of curiosity, what are other examples of quotient types which use a default constructor other than <code>[[x]]</code>?</p>",
        "id": 480264216,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730595676
    },
    {
        "content": "<p>I guess there's also <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Surreal.mk#doc\">docs#Surreal.mk</a></p>",
        "id": 480264314,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730595742
    },
    {
        "content": "<p>Though yeah, I'm not sure if this <code>QuotLike</code> API can help much in cases where the constructor takes in different arguments than the quotient, such as this one or in the ordinal case.</p>",
        "id": 480264364,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730595809
    },
    {
        "content": "<p>Seems like you would need some tactic machinery instead</p>",
        "id": 480264428,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730595854
    },
    {
        "content": "<p>AUII, the proposal is to replace <code>Quotient.mk : X -&gt; Quotient someInternalSetoid</code> with <code>QuotLike.mk X -&gt; TheActualTypeName</code>, eliminating the custom mks entirely but also avoiding the abuse of defeq <em>of the types</em></p>",
        "id": 480267173,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1730598638
    },
    {
        "content": "<p>I think if we want to try something like this, then I would be inclined to try to mimic <code>SetLike</code>. We can identify <code>Setoid X</code> with the type of quotients of <code>X</code>, and define <code>QuotientLike T X</code> to say that <code>T</code> behaves like <code>Setoid X</code>. What the PR in this thread seems to miss is that in most situations of interest the quotient map is not just a plain function, but rather a morphism of some kind (a group hom, ring hom, continuous map, etc.), so one would <em>still</em> have to introduce an additional definition for the quotient map as a bundled morphism in most situations with the proposed approach. If we instead \"bundle\" quotients as I suggested here, and make a <code>QuotientLike</code> class, we could also introduce, for example, <code>MonoidQuotientClass</code> which would follow the analogy <code>SubmonoidClass : SetLike :: MonoidQuotientClass : QuotientLike</code>.</p>",
        "id": 480268392,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1730599818
    },
    {
        "content": "<p>Namely something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.Data.Setoid.Basic</span>\n\n<span class=\"kd\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CoeSort</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Setoid</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Quotient</span><span class=\"w\"> </span><span class=\"n\">s</span>\n\n<span class=\"kd\">class</span><span class=\"w\"> </span><span class=\"n\">QuotientLike</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Setoid</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">coe_injective</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Function.Injective</span><span class=\"w\"> </span><span class=\"n\">coe</span>\n\n<span class=\"kd\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">QuotientLike</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Setoid</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">s</span>\n<span class=\"w\">  </span><span class=\"n\">coe_injective</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span>\n\n<span class=\"kd\">instance</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">QuotientLike</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CoeTC</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Setoid</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">QuotientLike.coe</span><span class=\"w\"> </span><span class=\"n\">s</span>\n\n<span class=\"kd\">instance</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">QuotientLike</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CoeSort</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Setoid</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">QuotientLike.mk'</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">QuotientLike</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Quotient.mk</span><span class=\"w\"> </span><span class=\"n\">_</span>\n</code></pre></div>",
        "id": 480268893,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1730600339
    },
    {
        "content": "<p>I should clarify that I don't know whether this is a good idea, rather that it's analogous to <code>SetLike</code> which empirically seems to work quite well.</p>",
        "id": 480268982,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1730600432
    },
    {
        "content": "<p>This sounds like an orthogonal proposal. It cannot be used for two specific types. Maybe <code>QuotLike</code> isn't the appropriate name. It may suggest that this typeclass is similar to <code>FunLike</code> and <code>SetLike</code>, but it is not.</p>",
        "id": 509645403,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1743586133
    },
    {
        "content": "<p>It may be called something like <code>LawfulQuotient</code> or <code>QuotientType</code>?</p>",
        "id": 509646969,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1743586526
    },
    {
        "content": "<p>Also, <code>QuotientLike</code> typeclass in this proposal is not compatible with current API design. Both <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=QuotientGroup.mk%27#doc\">docs#QuotientGroup.mk'</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ideal.Quotient.mk#doc\">docs#Ideal.Quotient.mk</a> have an extra instance parameter.</p>",
        "id": 509648374,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1743586874
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"455791\">Yuyang Zhao</span> <a href=\"#narrow/channel/287929-mathlib4/topic/migrate.20to.20.60QuotLike.60.20API/near/509648374\">said</a>:</p>\n<blockquote>\n<p>Also, <code>QuotientLike</code> typeclass in this proposal is not compatible with current API design. Both <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=QuotientGroup.mk%27#doc\">docs#QuotientGroup.mk'</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ideal.Quotient.mk#doc\">docs#Ideal.Quotient.mk</a> have an extra instance parameter.</p>\n</blockquote>\n<p>Why does this matter? You could attach an extra instance parameter to the relevant <code>QuotientLike</code> class.</p>",
        "id": 509655127,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1743588992
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">QuotientLike</span><span class=\"bp\">.</span><span class=\"n\">mkMonoidHom</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">QuotientLike</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MonoidQuotientClass</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→*</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>We want this function iiuc. Then what should <code>S</code> be for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=QuotientGroup.mk%27#doc\">docs#QuotientGroup.mk'</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ideal.Quotient.mk#doc\">docs#Ideal.Quotient.mk</a> ?</p>",
        "id": 509660940,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1743590791
    },
    {
        "content": "<p>This one doesn't make any sense to me, since the only choice for <code>S</code> is <code>Type u</code> but that's obviously not what you want to say.</p>",
        "id": 509664017,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1743591710
    },
    {
        "content": "<p>In <span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span>'s example, <code>α → X</code> is actually <code>α → Quotient (QuotientLike.coe X)</code>.</p>",
        "id": 509664930,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1743591981
    },
    {
        "content": "<p><code>mkMonoidHom</code> just replaces the function in <code>mk'</code> with <code>MonoidHom</code>.</p>",
        "id": 509665917,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1743592269
    },
    {
        "content": "<p>Then I think <span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> is wrong, we should have <code>α → S</code> on the rhs and drop <code>X</code>.</p>",
        "id": 509666591,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1743592474
    },
    {
        "content": "<p>Actually, I could make this work...</p>",
        "id": 509666917,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1743592563
    },
    {
        "content": "<p>We would need to make some new types</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">QuotientGroup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">Setoid</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"n\">mul_left_sound'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">≈</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">≈</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">c</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">QuotientGroup</span><span class=\"bp\">.</span><span class=\"n\">Normal</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">QuotientGroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"n\">mul_sound'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≈</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">≈</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">≈</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">d</span>\n</code></pre></div>",
        "id": 509670845,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1743593686
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Con#doc\">docs#Con</a> is close to this</p>",
        "id": 509671594,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1743593897
    }
]