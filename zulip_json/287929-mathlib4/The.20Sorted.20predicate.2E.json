[
    {
        "content": "<p>I would like to propose re-defining the <code>List.Sorted</code> predicate. Currently, it is defined as a synonym of Pairwise, but not in any kind of specialised way - it is just another name for Pairwise. I think this is probably not the best way to do this, especially given it is currently a <code>def</code> and not an <code>abbrev</code>. It means there ends up being a lot of duplicated API without really much gain. <code>List.Sorted</code> is meant to be preferred in the case that r is a &lt; or ≤-like relation (transitive and antisymmetric or asymmetric)</p>\n<p>Given recent efforts to deprecated <code>List.Chain</code> and <code>List.Chain'</code> and introduce <code>List.IsChain</code> as a unified predicate (meaning the same as the latter), I think one possibility could be that <code>List.Sorted</code> is defined as <code>List.IsChain</code> in the case when the underlying relation is <code>IsTrans</code>, such that this is then equivalent to <code>List.Pairwise</code>. This has the advantage that the corresponding decidable instance to this could come from the decidability of <code>IsChain</code>, which is pretty much as efficient as you can get as a check for sortedness.</p>\n<p>Another option would be linking it to monotonicity of <code>List.get</code>.  We have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.sorted_lt_ofFn_iff#doc\">docs#List.sorted_lt_ofFn_iff</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.sorted_le_ofFn_iff#doc\">docs#List.sorted_le_ofFn_iff</a>, as well as docsList.Sorted.get_strictMono and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.Sorted.get_mono#doc\">docs#List.Sorted.get_mono</a>. What if these were actually the defining property of <code>List.Sorted</code>? That would make some sense to me. However it limits us to only considering &lt; or ≤ themselves - a lot less general (at least if we use the actual <code>Monotone</code> predicate).</p>\n<p>We could also consider separating <code>IsSorted</code> and <code>IsStrictlySorted</code>, i.e. \"the underlying relation is ≤-like\" and \"the underlying relation is &lt;-like\". As typeclasses I think this probably ought to correspond to<code>IsPreorder</code> and <code>IsStrictOrder</code> respectively, though if you wanted to base it on monotonicity of <code>List.get</code> you would probably just use <code>Preorder</code>. I think this has something to recommend it in some ways!</p>\n<p>I think maybe a poll would be appropriate once I've gathered some thoughts on this - my starting point is that the current definition of <code>List.Sorted</code> is not the most appropriate one we could choose, but I recognise a degree of bikeshedding might be needed to settle on an alternative (and that it is possible this was chosen in the past as a compromise for some other reason).</p>",
        "id": 541400462,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1758789454
    },
    {
        "content": "<p>Regarding monotonicity: <code>Pairwise</code> is basically already the predicate of monotonicity:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Pairwise</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">pairwise_iff_getElem</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">forall_iff</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">forall_comm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)]</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Refl</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Pairwise</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">pairwise_iff_getElem</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">forall_iff</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"bp\">‹</span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Refl</span><span class=\"w\"> </span><span class=\"bp\">_›</span>\n<span class=\"w\">  </span><span class=\"n\">grind</span>\n</code></pre></div>\n<p>And loogle seems to reveal that List.Pairwise is significantly more common than both of the others (List.Sorted occurs 107 times, List.IsChain 312 (admittedly, many of them are deprecations) and List.Pairwise 922 times). So it probably makes sense to take the one with the most API as the definition; but then the question is whether we even should distinguish Pairwise and Sorted</p>",
        "id": 541448875,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1758804395
    },
    {
        "content": "<p>Yes, I certainly can't currently see any reason why we do this.</p>",
        "id": 541449319,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1758804527
    },
    {
        "content": "<p>If it had a typeclass prereq and a different decidability instance I would do - as I say I think the fact that it is meant to only apply in a transitive context is key.</p>",
        "id": 541449480,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1758804577
    },
    {
        "content": "<p>Inherently Pairwise is O(n^2) to check and IsChain is O(n).</p>",
        "id": 541449580,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1758804607
    },
    {
        "content": "<p>An example of something which is defined as Pairwise but <em>does</em> make sense I think is <code>List.Nodup</code>, defined as <code>List.Pairwise fun (x1 x2 : α) =&gt; x1 ≠ x2</code>.</p>",
        "id": 541453016,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1758805473
    },
    {
        "content": "<p>If Sorted was <code>List.Pairwise fun (x1 x2 : α) =&gt; x1 ≤ x2</code> and we had a StrictlySorted with <code>List.Pairwise fun (x1 x2 : α) =&gt; x1 &lt; x2</code> that would feel reasonable. I think the reason I like the idea of using <code>IsChain</code> is that I feel a definition, the part of it that defines how you <em>construct</em> a term of a type, should be as minimal/weak as possible: but it being Pairwise is obviously the important result for proving a lot of stronger stuff (and that comes from the transitivity).</p>",
        "id": 541453541,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1758805621
    },
    {
        "content": "<p>I am not sure we ever use it <em>anywhere</em> without ≤ or &lt;.</p>",
        "id": 541453975,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1758805733
    },
    {
        "content": "<p>Incidentally the typeclass prereqs for <code>List.sorted_insertionSort</code> are <code>[IsTotal α r] [IsTrans α r]</code>, which is not a terrible choice I suppose for the required pre-reqs. Notably I am not sure the sorting-algorithm concept of sorting makes sense outside that?</p>",
        "id": 541455626,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1758806190
    },
    {
        "content": "<p>I recently tried proving some stuff about sorting, could the Sorted predicate be defined for arbitrary sequences instead of on list specifically? As a workaround i was defining my own Sorted predicate as <code>myContainer.toList.Sorted</code> but having something that would work for arbitrary sequences too would be nice.</p>",
        "id": 541472611,
        "sender_full_name": "Julia Scheaffer",
        "timestamp": 1758810418
    },
    {
        "content": "<p>When you say arbitrary sequences, what do you mean?</p>",
        "id": 541472705,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1758810443
    },
    {
        "content": "<p>i.e. is there a typeclass you're thinking of?</p>",
        "id": 541472785,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1758810462
    },
    {
        "content": "<p>Not at the moment</p>",
        "id": 541472891,
        "sender_full_name": "Julia Scheaffer",
        "timestamp": 1758810492
    },
    {
        "content": "<p>If it went based on the monotonicity definition, that would work well for arbitrary <code>ℕ → α</code></p>",
        "id": 541473000,
        "sender_full_name": "Julia Scheaffer",
        "timestamp": 1758810528
    },
    {
        "content": "<p>Or indeed <code>Fin n → α</code> which is different.</p>",
        "id": 541473109,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1758810554
    },
    {
        "content": "<p>Right, Fin n would be good for fixed size collections like vectors</p>",
        "id": 541473200,
        "sender_full_name": "Julia Scheaffer",
        "timestamp": 1758810582
    },
    {
        "content": "<p>We also have <code>Vector R n</code>, <code>Array R</code>, and my bête noire, <code>List.Vector R n</code>.</p>",
        "id": 541473334,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1758810618
    },
    {
        "content": "<p>I was having trouble dealing with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Vector#doc\">docs#Vector</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.Vector#doc\">docs#List.Vector</a> so i ended up making my own inductively defined Vector <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 541473378,
        "sender_full_name": "Julia Scheaffer",
        "timestamp": 1758810630
    },
    {
        "content": "<p>No! No!!</p>",
        "id": 541473405,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1758810639
    },
    {
        "content": "<p>and then proved equivalences to Vector and List.Vector</p>",
        "id": 541473453,
        "sender_full_name": "Julia Scheaffer",
        "timestamp": 1758810652
    },
    {
        "content": "<p>I mean fill your boots but I cannot dis-recommend that enough.</p>",
        "id": 541473463,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1758810654
    },
    {
        "content": "<p>Well, I am learning <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 541473608,
        "sender_full_name": "Julia Scheaffer",
        "timestamp": 1758810687
    },
    {
        "content": "<p>It's already terrible that we have <code>Vector</code> and <code>List.Vector</code>. I would like to have <code>Tuple</code> as a name for <code>Fin n → α</code> but that hasn't happened yet.</p>",
        "id": 541473734,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1758810721
    },
    {
        "content": "<p>(We do have Tuple.sort though.)</p>",
        "id": 541473795,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1758810741
    },
    {
        "content": "<p>Tuple.sort looks useful</p>",
        "id": 541474598,
        "sender_full_name": "Julia Scheaffer",
        "timestamp": 1758810949
    },
    {
        "content": "<p>I think it would be more useful if it wasn't so arcane, but I don't disagree.</p>",
        "id": 541474705,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1758810974
    },
    {
        "content": "<p>Having a definition of Sorted that could work for stuff like <code>Fin n -&gt; α</code> would be good too</p>",
        "id": 541475014,
        "sender_full_name": "Julia Scheaffer",
        "timestamp": 1758811048
    },
    {
        "content": "<p>I have also thought that it would be nice to have a predicate for <code>X is the sorted version of Y</code> - in lists this would be <code>List.Perm X Y /\\ List.Pairwise (X) &lt;=</code> or something like that.</p>",
        "id": 541475139,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1758811081
    },
    {
        "content": "<p>Like, there is a difference between \"this particular thing is sorted\", \"this particular thing is the sorted version of this other thing\", and \"this particular thing is calculated from this other thing using this function, which sorts it\".</p>",
        "id": 541475327,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1758811137
    },
    {
        "content": "<p>It doesn't matter in logical terms what sorting method you use, but in other contexts you will want to examine the algorithm.</p>",
        "id": 541475437,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1758811166
    },
    {
        "content": "<p>I would like also to get some content about sorting networks into Lean which I don't think we have. What was your context?</p>",
        "id": 541475513,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1758811184
    },
    {
        "content": "<p>Ooh, sorting networks are a good one. I was mainly trying to learn about how to prove stuff about functions that do complex stuff. I am attempting to design a language with a friend and one of the features I want is the ability to reason about function Implementations.</p>\n<p>I come from a computer science background, so I am very interested in cost analysis of programs, which as I understand is not something lean can do very well right now.</p>\n<p>Sorting algorithms are one of those things that are very simple to write and usually not too hard to reason about cost and correctness, so I was learning about how lean deals with them.</p>",
        "id": 541476540,
        "sender_full_name": "Julia Scheaffer",
        "timestamp": 1758811403
    },
    {
        "content": "<p>I could try and write some code to formalize sorting networks if they have not been done before in Lean/mathlib</p>",
        "id": 541476655,
        "sender_full_name": "Julia Scheaffer",
        "timestamp": 1758811432
    },
    {
        "content": "<p>I have done some work with permutation networks (it isn't in Mathlib though I would like for it to be at some point). Sorting networks I think we simply do not have and it would be great to have that in.</p>",
        "id": 541477224,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1758811564
    },
    {
        "content": "<p>It's outside the context of this thread but start a new one for that topic if you like and tag me in, as I'd be very interested.</p>",
        "id": 541477291,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1758811584
    },
    {
        "content": "<p>I'll let you know if and when i get the basics worked out <span aria-label=\"smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"smile\">:smile:</span> (I've got some reading to do)</p>",
        "id": 541477494,
        "sender_full_name": "Julia Scheaffer",
        "timestamp": 1758811632
    },
    {
        "content": "<p>Brill, let me know!</p>",
        "id": 541478114,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1758811790
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"953668\">Julia Scheaffer</span> <a href=\"#narrow/channel/287929-mathlib4/topic/The.20Sorted.20predicate.2E/near/541475014\">said</a>:</p>\n<blockquote>\n<p>Having a definition of Sorted that could work for stuff like <code>Fin n -&gt; α</code> would be good too</p>\n</blockquote>\n<p>Wouldn't this just be <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=StrictMono#doc\">docs#StrictMono</a> ?</p>",
        "id": 541550803,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1758837643
    },
    {
        "content": "<p>It would be <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Monotone#doc\">docs#Monotone</a>, adjacent elements can be equal in a sorted list</p>",
        "id": 541551000,
        "sender_full_name": "Julia Scheaffer",
        "timestamp": 1758837748
    },
    {
        "content": "<p>At least I am using <code>Monotone</code> in my sorting network code</p>",
        "id": 541551298,
        "sender_full_name": "Julia Scheaffer",
        "timestamp": 1758837920
    },
    {
        "content": "<p>I think Julia's intent there is something that works for everything, but yes it would be</p>",
        "id": 541559040,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1758843309
    },
    {
        "content": "<p>What does it mean that the list is 'sorted'? Currently in lean the list <code>l</code> is <code>Sorted</code> when <code>l[i] &lt; l[j]</code> for any <code>i &lt; j</code>, but in c++ for example, <a href=\"https://en.cppreference.com/w/cpp/algorithm/is_sorted.html\"><code>std::is_sorted</code></a> returns true if <code>l[i+1] &lt; l[i]</code> is false for every possible <code>i</code>, possibly weaker than <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Monotone#doc\">docs#Monotone</a> . If we change the definition of <code>Sorted</code>ness, then maybe we can weaken its definition in this style.</p>",
        "id": 541614041,
        "sender_full_name": "Jihoon Hyun",
        "timestamp": 1758875860
    },
    {
        "content": "<p>That is equivalent to IsChain with &lt;=.</p>",
        "id": 541614479,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1758876013
    },
    {
        "content": "<p>Which is in turn equivalent to Sorted &lt;=</p>",
        "id": 541614527,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1758876028
    },
    {
        "content": "<p>So, yes, for computing whether a list is sorted by a transitive relation you should use IsChain.</p>",
        "id": 541614651,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1758876071
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/channel/287929-mathlib4/topic/The.20Sorted.20predicate.2E/near/541614479\">말함</a>:</p>\n<blockquote>\n<p>That is equivalent to IsChain with &lt;=.</p>\n</blockquote>\n<p>Actually it's not, as <code>&lt;=</code> may not be defined; only <code>&lt;</code> is required, and equality might not be defined as in <code>Preorder</code> lacking  antisymmetry.</p>",
        "id": 541615075,
        "sender_full_name": "Jihoon Hyun",
        "timestamp": 1758876200
    },
    {
        "content": "<p>Well, <code>IsChain (¬· &gt; ·)</code> if you will</p>",
        "id": 541615733,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1758876426
    },
    {
        "content": "<p>Oh, you're right.</p>",
        "id": 541615822,
        "sender_full_name": "Jihoon Hyun",
        "timestamp": 1758876465
    },
    {
        "content": "<p>Sure I mean I am assuming it's a Preorder as otherwise it's kinda much of a muchness</p>",
        "id": 541616487,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1758876700
    },
    {
        "content": "<p>Update on this: <a href=\"https://github.com/leanprover-community/mathlib4/pull/30441\">#30441</a> I hope is close to a maintainer review and possibly merge.</p>",
        "id": 560657880,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1764269881
    },
    {
        "content": "<p>It's done :)</p>",
        "id": 562425126,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1765187502
    },
    {
        "content": "<p>I would now (relatedly) like to think about how we can best capture the predicate \"ys is a sorted version of xs\". But that can be for a seperate thread.</p>",
        "id": 562425362,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1765187584
    }
]