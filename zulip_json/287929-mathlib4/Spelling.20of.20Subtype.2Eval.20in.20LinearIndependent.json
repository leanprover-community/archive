[
    {
        "content": "<p>In <code>Mathlib.Data.LinearAlgebra.LinearIndependent</code>, many lemmas are hard to read in the infoview/docs because they use <code>Subtype.val</code> without the domain showing up. For example,  in this one, the hypothesis and conclusion look exactly the same. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">LinearIndependent.insert</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_3</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">DivisionRing</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">LinearIndependent</span> <span class=\"n\">K</span> <span class=\"k\">fun</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">↑</span><span class=\"n\">b</span><span class=\"o\">)</span>\n <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∉</span> <span class=\"n\">Submodule.span</span> <span class=\"n\">K</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">LinearIndependent</span> <span class=\"n\">K</span> <span class=\"k\">fun</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">↑</span><span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>It occurs to be that this could be solved using <code>Set.restrict</code>, so in the lemma above, we would have the (defeq) <br>\n<code>\nhs : LinearIndependent K (s.restrict id) \n</code><br>\nand the conclusion would be <br>\n<code>\nLinearIndependent K ((insert x s).restrict id)\n</code><br>\nThat way it is much clearer what the lemma is saying. A similar thing could be used for composing an arbitrary <code>f</code> with <code>Subtype.val</code> (which also happens in the API), using <br>\n<code>\nexample (f : α → β)  (s : Set α) : f ∘ ((↑) : s → α) = s.restrict f := rfl \n</code></p>\n<p>Would it make sense to do this? I was worried that for the identity case, there might be a problem with simp normal form, but it turns out there is no simp lemma for <code>s.restrict id = Subtype.val</code></p>",
        "id": 399676188,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1698825410
    },
    {
        "content": "<p>I think this is a sensible idea. How about the following: whenever the subtype is of the form \"set <code>s</code> coerced to a type\" then <code>s.restrict</code> is probably a better choice then <code>Subtype.val</code>. Of course for types such as <code>PNat</code> or <code>NNReal</code> that are defined <em>directly</em> as subtype, this option is not available.</p>\n<p>(Tangent: I don't really like the name <code>s.restrict</code>. I think <code>s.incl</code> or something like that might be better. Of course <code>Set.inclusion</code> already exists, and turns <code>s \\subset t</code> into a map between the two respective subtypes.)</p>",
        "id": 399677696,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1698826140
    },
    {
        "content": "<p>Yes, I've always thought <code>f.restrict s</code> would even be a better name that <code>s.restrict f</code></p>",
        "id": 399677779,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1698826191
    },
    {
        "content": "<p>Yes, that would make sense!</p>",
        "id": 399677895,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1698826233
    },
    {
        "content": "<p>Back in the day, we couldn't use dot-notation on functions. But now that we can, we should probably rename it to <code>Function.restrict</code>!</p>",
        "id": 399677934,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1698826261
    },
    {
        "content": "<p>And maybe make <code>s.incl</code> an abbreviation for <code>Subtype.val</code> and/or <code>Function.restrict id s</code>.</p>",
        "id": 399677993,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1698826300
    },
    {
        "content": "<p>To be clear, this is only a problem in the docs not the source: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearIndependent.insert#doc\">docs#LinearIndependent.insert</a></p>",
        "id": 399680620,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1698827644
    },
    {
        "content": "<p>I thought lean 4 was supposed to have \"fixed\" pretty printing so that things round-tripped and this ambiguity wouldn't be present?</p>",
        "id": 399680864,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1698827764
    },
    {
        "content": "<p>yeah that... didn't ship</p>",
        "id": 399681213,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1698827932
    },
    {
        "content": "<p>there is <code>pp.analyze</code> but it's not really maintained</p>",
        "id": 399681251,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1698827952
    },
    {
        "content": "<p>I assume <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.pp.analyze#doc\">docs#Lean.pp.analyze</a> won't lead me to any documentation... (Edit: it does!)</p>",
        "id": 399681422,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1698828044
    },
    {
        "content": "<p>It seems like there's a problem with dot notation, because <code>s.restrict f</code> is defined for dependent functions. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Basic</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">π</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Function.restrict</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">π</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">π</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">restrict_eq</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Function.restrict</span> <span class=\"n\">f</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">Subtype.val</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"c1\">-- works</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">restrict_eq'</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f.restrict</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">Subtype.val</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">fails:</span>\n<span class=\"cm\">application type mismatch</span>\n<span class=\"cm\">  @restrict ?m.472 f</span>\n<span class=\"cm\">argument</span>\n<span class=\"cm\">  f</span>\n<span class=\"cm\">has type</span>\n<span class=\"cm\">  α → β : Type (max u_1 u_2)</span>\n<span class=\"cm\">but is expected to have type</span>\n<span class=\"cm\">  ?m.472 → Type ?u.466 : Type (max ?u.465 (?u.466 + 1))</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>Is there a way around this?</p>",
        "id": 399685218,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1698829682
    },
    {
        "content": "<p>What about a symbol for restriction? </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Basic</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">π</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Function.restrict</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">π</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">π</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">infix</span><span class=\"o\">:</span><span class=\"mi\">99</span> <span class=\"s2\">\" ↾ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Function.restrict</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">restrict_eq</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">↾</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">Subtype.val</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 399703812,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1698836841
    },
    {
        "content": "<p>there is a minor annoyance there, unlike dot notation, it looks like you have to write <code>(f ↾ s) x</code> rather than <br>\n<code>f ↾ s x</code> for application, since there is no precedence for the infix that makes it work.</p>",
        "id": 399706889,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1698838303
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/8107\">#8107</a></p>",
        "id": 399827797,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1698885907
    },
    {
        "content": "<p>This dependent function problem is a known issue <a href=\"https://github.com/leanprover/lean4/pull/1629\">lean4#1629</a></p>",
        "id": 399828079,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1698886052
    },
    {
        "content": "<p>Instead of introducing a new definition or restating all our lemmas, should we just make the <code>ι</code> argument to <code>LinearIndependent</code> explicit?</p>",
        "id": 399915602,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1698925006
    },
    {
        "content": "<p>That feels like it would be more unwieldy in the general case of linear independence of actual indexed tuples, rather than sets. </p>\n<p>What is the problem with the solution in the PR? It is really just changing spellings rather than restating lemmas. This was a bit of work, but the PR does it. It also introduces a standard for something that was previously ad hoc (currently different spellings are used in different files, which causes annoyances when rewriting).</p>",
        "id": 399969422,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1698939516
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329425\">Peter Nelson</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Spelling.20of.20Subtype.2Eval.20in.20LinearIndependent/near/399969422\">said</a>:</p>\n<blockquote>\n<p>That feels like it would be more unwieldy in the general case of linear independence of actual indexed tuples, rather than sets. </p>\n</blockquote>\n<p>At worst the cost is a single <code>_</code> at each use, isn't it? That seems less bad than having to unfold <code>id</code> and <code>restrict</code> all the time</p>",
        "id": 399970380,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1698939801
    },
    {
        "content": "<p>Having to explicitly specify the ring (which mathematically is clear from context the majority of the time) is already a slight pain with <code>LinearIndependent</code> terms; this would just be yet another little thing. </p>\n<p>I don't know how frequently the unfolding for sets will actually need to happen, since so much of the <code>LinearIndependent</code> api deals directly with sets anyway. While making the changes for the PR, it seems that the simplifier (plus <code>restrict_eq</code>) could do what was needed easily in every case.</p>",
        "id": 399971786,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1698940222
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329425\">Peter Nelson</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Spelling.20of.20Subtype.2Eval.20in.20LinearIndependent/near/399971786\">said</a>:</p>\n<blockquote>\n<p>Having to explicitly specify the ring (which mathematically is clear from context the majority of the time) is already a slight pain with <code>LinearIndependent</code> terms; this would just be yet another little thing. </p>\n</blockquote>\n<p>This is not the same situation though; if you omit the ring and write a <code>_</code>, lean can never work it out. If you omit the index, lean can almost always work it out</p>",
        "id": 399973080,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1698940607
    },
    {
        "content": "<p>Yes, there is no way around the explicit ring. But it is still just a little annoyance that comes with every single use of <code>LinearIndependent</code>. The extra underscore would be another, and the need for it can be avoided by a spelling change. Having to sometimes use the simplifier to unfold things seems less bad.</p>",
        "id": 399973684,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1698940752
    },
    {
        "content": "<p>Here's an alternate approach:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.LinearIndependent</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Qq</span> <span class=\"n\">Lean</span> <span class=\"n\">PrettyPrinter.Delaborator</span> <span class=\"n\">SubExpr</span> <span class=\"k\">in</span>\n<span class=\"kd\">@[</span><span class=\"n\">delab</span> <span class=\"n\">app.LinearIndependent</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">delabLinearIndependent</span> <span class=\"o\">:</span> <span class=\"n\">Delab</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">getExpr</span>\n  <span class=\"c1\">-- it would be really nice to use `~q()` here</span>\n  <span class=\"n\">guard</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">e.isAppOfArity</span> <span class=\"bp\">``</span><span class=\"n\">LinearIndependent</span> <span class=\"mi\">7</span>\n  <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"bp\">←</span> <span class=\"n\">withNaryFn</span> <span class=\"n\">delabAppFn</span>\n  <span class=\"k\">let</span> <span class=\"n\">ι</span> <span class=\"bp\">←</span> <span class=\"n\">withNaryArg</span> <span class=\"mi\">0</span> <span class=\"n\">delab</span>\n  <span class=\"k\">let</span> <span class=\"n\">R</span> <span class=\"bp\">←</span> <span class=\"n\">withNaryArg</span> <span class=\"mi\">1</span> <span class=\"n\">delab</span>\n  <span class=\"k\">let</span> <span class=\"n\">v</span> <span class=\"bp\">←</span> <span class=\"n\">withNaryArg</span> <span class=\"mi\">3</span> <span class=\"n\">delab</span>\n  <span class=\"k\">let</span> <span class=\"n\">ιe</span> <span class=\"bp\">←</span> <span class=\"n\">Meta.whnf</span> <span class=\"o\">(</span><span class=\"n\">e.getArg</span><span class=\"bp\">!</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n  <span class=\"c1\">-- check that `ιe` is a subtype with set membership</span>\n  <span class=\"k\">let</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">lam</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">body</span> <span class=\"n\">_</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">ιe.getAppArgs</span> <span class=\"bp\">|</span> <span class=\"n\">failure</span>\n  <span class=\"n\">guard</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">body.isAppOf</span> <span class=\"bp\">``</span><span class=\"n\">Membership.mem</span>\n  <span class=\"k\">let</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">inst</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">bvar</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">body.getAppArgs</span> <span class=\"bp\">|</span> <span class=\"n\">failure</span>\n  <span class=\"n\">guard</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">inst.isAppOfArity</span> <span class=\"bp\">``</span><span class=\"n\">Set.instMembershipSet</span> <span class=\"mi\">1</span>\n  <span class=\"c1\">-- use the binder if we have it</span>\n  <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">$</span><span class=\"n\">body</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">v</span> <span class=\"k\">then</span>\n    <span class=\"k\">let</span> <span class=\"n\">v</span> <span class=\"bp\">←</span> <span class=\"n\">withNaryArg</span> <span class=\"mi\">3</span> <span class=\"o\">(</span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">ι</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">$</span><span class=\"n\">body</span><span class=\"o\">)</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">annotateCurPos</span><span class=\"o\">)</span>\n    <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">f</span> <span class=\"bp\">$</span><span class=\"n\">R</span> <span class=\"bp\">$</span><span class=\"n\">v</span><span class=\"o\">)</span>\n  <span class=\"k\">else</span>\n    <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">mkIdent</span> <span class=\"bp\">`</span><span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">$</span><span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"bp\">$</span><span class=\"n\">R</span> <span class=\"bp\">$</span><span class=\"n\">v</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- shows `LinearIndependent K fun b : ↑(insert x s) =&gt; ↑b`</span>\n<span class=\"k\">#check</span> <span class=\"n\">LinearIndependent.insert</span>\n<span class=\"c1\">-- unchanged</span>\n<span class=\"k\">#check</span> <span class=\"n\">LinearIndependent.fin_cons</span>\n</code></pre></div>",
        "id": 399976698,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1698941481
    },
    {
        "content": "<p>The nice thing about this solution is that it solves a pretty-printing-only problem with a pretty-printing-only solution</p>",
        "id": 399977196,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1698941627
    },
    {
        "content": "<p>what am I doing wrong? (added these lines at the end of the same code)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">V</span><span class=\"o\">}</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">LinearIndependent</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">Subtype.val</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">-- infoview shows</span>\n  <span class=\"c1\">-- hs : LinearIndependent✝ R Subtype.val</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 399977887,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1698941821
    },
    {
        "content": "<p>Ah, now you've hit upon something nasty; the difference between <code>Set.Elem</code> and <code>Subtype</code>! I'll attempt a fix</p>",
        "id": 399978142,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1698941895
    },
    {
        "content": "<p>oh, I see that it works if I write <code>fun (x : s) ↦ (x : V)</code> instead. But that kind of thing is quite hard to read when terms become complicated.</p>",
        "id": 399978169,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1698941904
    },
    {
        "content": "<p>I am actually still quite a fan of <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> 's <code>Set.incl</code>. It is much more readable for a mathematician than <code>Subtype.val</code>, and this is true even in contexts that have nothing to do with linear independence.</p>",
        "id": 399979571,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1698942361
    },
    {
        "content": "<p>Edited above</p>",
        "id": 399979761,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1698942418
    },
    {
        "content": "<p>The infoview now shows <code>hs: LinearIndependent✝ (ι✝ := { x // x ∈ s }) R Subtype.val</code>. <del>Maybe <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> can tell me how to make those tombstones go away</del> fixed using <code>mkIdent</code></p>",
        "id": 399980168,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1698942551
    },
    {
        "content": "<p>Is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">set_option</span> <span class=\"n\">hygiene</span> <span class=\"n\">false</span> <span class=\"k\">in</span>\n</code></pre></div>\n<p>Too radical?</p>",
        "id": 399980645,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1698942705
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Spelling.20of.20Subtype.2Eval.20in.20LinearIndependent/near/399980168\">said</a>:</p>\n<blockquote>\n<p>The infoview now shows <code>hs: LinearIndependent✝ (ι✝ := { x // x ∈ s }) R Subtype.val</code>. Maybe <span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> can tell me how to make those tombstones go away</p>\n</blockquote>\n<p>Ok, I see that this is workable. But there is still a lot of DTT cruft in there; it takes someone from the initiated to recognize that the <code>s</code> is the important thing in the above. </p>\n<p>There is a lot of stuff appearing in the infoview in the linear algebra API that is quite hard to read for this sort of reason - I've really dived into it for the first time in recent weeks, and it's been an adjustment getting past all the overhead. It would be good to see a solution that minimizes such things.</p>",
        "id": 399980751,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1698942734
    },
    {
        "content": "<blockquote>\n<p>Ok, I see that this is workable. But there is still a lot of DTT cruft in there; it takes someone from the initiated to recognize that the s is the important thing in the above.</p>\n</blockquote>\n<p>Yes, but this is a feature; you accidentally created the DTT cruft by passing <code>Subtype.val</code> in</p>",
        "id": 399981266,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1698942918
    },
    {
        "content": "<p>So what is the preferred way to do it?</p>",
        "id": 399981323,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1698942937
    },
    {
        "content": "<p>For that specific example you can set <code>ι</code> manually</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">LinearIndependent</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"o\">:=</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">Subtype.val</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">-- infoview shows</span>\n  <span class=\"c1\">-- hs : LinearIndependent (ι := ↑s) R Subtype.val</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 399981570,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1698942995
    },
    {
        "content": "<p>Or the solution you already found, which is what mathlib has been using:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">LinearIndependent</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">↦</span> <span class=\"n\">x.1</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">-- infoview shows</span>\n  <span class=\"c1\">-- hs : LinearIndependent R fun x : ↑s =&gt; ↑x</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 399981794,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1698943081
    },
    {
        "content": "<p>There is also <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.MVarId.renameInaccessibleFVars#doc\">docs#Lean.MVarId.renameInaccessibleFVars</a>, but I'm on mobile and I'm not sure that it is what you want.</p>",
        "id": 399982497,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1698943314
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span>, I think I solved the tombstones now, but thatnks!</p>",
        "id": 399983204,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1698943547
    },
    {
        "content": "<p>It's annoying that <code>{ x // x ∈ s }</code> and <code>s</code> are different things; we could solve this by deleting <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.Elem#doc\">docs#Set.Elem</a> from core, and adding a custom elaborator to use <code>↥s</code> as notation for <code>{ x // x ∈ s }</code></p>",
        "id": 399983391,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1698943613
    },
    {
        "content": "<p>Oh, it's not even in core!</p>",
        "id": 399983468,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1698943643
    },
    {
        "content": "<p>I wonder if there's anything interesting we could do with, for example, dot notation API by preserving <code>Set.Elem</code>.</p>\n<p>What is the concrete problem with there being this reducible <code>Set.Elem</code> wrapper? The docstring is indicating that <code>norm_cast</code> needs it.</p>",
        "id": 399996537,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1698948327
    },
    {
        "content": "<p>Mainly just that if we have Set.Elem, then the goal view should probably show the difference between when it's there and when it's not (otherwise <code>norm_num</code> will appear to fail randomly); and only one of those two spellings can be called <code>↥s</code>.</p>",
        "id": 399996781,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1698948428
    },
    {
        "content": "<p>I wonder if the norm_num comment is still true</p>",
        "id": 399996835,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1698948461
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Spelling.20of.20Subtype.2Eval.20in.20LinearIndependent/near/399981794\">said</a>:</p>\n<blockquote>\n<p>Or the solution you already found, which is what mathlib has been using:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">LinearIndependent</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">↦</span> <span class=\"n\">x.1</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">-- infoview shows</span>\n  <span class=\"c1\">-- hs : LinearIndependent R fun x : ↑s =&gt; ↑x</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I would even say the <code>fun</code> notation and coercions appearing in the infoview is not ideal if it can be avoided (which it can). </p>\n<p>What is there would still look cryptic to a curious mathematician.</p>",
        "id": 400005914,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1698952490
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Spelling.20of.20Subtype.2Eval.20in.20LinearIndependent/near/399996835\">said</a>:</p>\n<blockquote>\n<p>I wonder if the norm_num comment is still true</p>\n</blockquote>\n<p>I tested it, and it was; <code>norm_num</code> has a somewhat arbitrary list of functions that it is allowed to apply to (specifically, things that are explicitly tagged as coercions)</p>",
        "id": 402307906,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700074549
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>, would you be in favor of me PRing the delaborator above?</p>",
        "id": 402308015,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700074591
    },
    {
        "content": "<p>Can we still have <code>s.incl</code>?</p>",
        "id": 402308188,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1700074677
    },
    {
        "content": "<p>I worry slightly that having two ways to spell the same thing is setting ourselves up for more pain</p>",
        "id": 402309544,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700075120
    },
    {
        "content": "<p><code>abbrev</code> and <code>@[simp] theorem Set.incl_apply (s : Set α) (x : s) : Set.incl s x = x := rfl</code> make that less true, but might cause problems elsewhere</p>",
        "id": 402309596,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700075150
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> I'd suggest doing something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- If `e` is a coercion of a set to a type, return the set.</span>\n<span class=\"sd\">Succeeds either for `Set.Elem s` terms or `{x // x ∈ s}` subtype terms. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">Lean.Expr.coeTypeSet</span><span class=\"bp\">?</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">Expr</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">if</span> <span class=\"n\">e.isAppOfArity</span> <span class=\"bp\">``</span><span class=\"n\">Set.Elem</span> <span class=\"mi\">2</span> <span class=\"k\">then</span>\n    <span class=\"n\">return</span> <span class=\"n\">e.appArg</span><span class=\"bp\">!</span>\n  <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"n\">e.isAppOfArity</span> <span class=\"bp\">``</span><span class=\"n\">Subtype</span> <span class=\"mi\">2</span> <span class=\"k\">then</span>\n    <span class=\"k\">let</span> <span class=\"bp\">.</span><span class=\"n\">lam</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">body</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">e.appArg</span><span class=\"bp\">!</span> <span class=\"bp\">|</span> <span class=\"n\">failure</span>\n    <span class=\"n\">guard</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">body.isAppOfArity</span> <span class=\"bp\">``</span><span class=\"n\">Membership.mem</span> <span class=\"mi\">5</span>\n    <span class=\"k\">let</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">inst</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">bvar</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">body.getAppArgs</span> <span class=\"bp\">|</span> <span class=\"n\">failure</span>\n    <span class=\"n\">guard</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">inst.isAppOfArity</span> <span class=\"bp\">``</span><span class=\"n\">Set.instMembershipSet</span> <span class=\"mi\">1</span>\n    <span class=\"n\">return</span> <span class=\"n\">s</span>\n  <span class=\"k\">else</span>\n    <span class=\"n\">failure</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">PrettyPrinter.Delaborator</span> <span class=\"n\">SubExpr</span> <span class=\"k\">in</span>\n<span class=\"kd\">@[</span><span class=\"n\">delab</span> <span class=\"n\">app.LinearIndependent</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">delabLinearIndependent</span> <span class=\"o\">:</span> <span class=\"n\">Delab</span> <span class=\"o\">:=</span> <span class=\"n\">whenPPOption</span> <span class=\"n\">getPPNotation</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">getExpr</span>\n  <span class=\"n\">guard</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">e.isAppOfArity</span> <span class=\"bp\">``</span><span class=\"n\">LinearIndependent</span> <span class=\"mi\">7</span>\n  <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">e.getArg</span><span class=\"bp\">!</span> <span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">coeTypeSet</span><span class=\"bp\">?</span> <span class=\"bp\">|</span> <span class=\"n\">failure</span>\n  <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"bp\">←</span> <span class=\"n\">withNaryFn</span> <span class=\"n\">delabAppFn</span>\n  <span class=\"k\">let</span> <span class=\"n\">ι</span> <span class=\"bp\">←</span> <span class=\"n\">withNaryArg</span> <span class=\"mi\">0</span> <span class=\"n\">delab</span>\n  <span class=\"k\">let</span> <span class=\"n\">R</span> <span class=\"bp\">←</span> <span class=\"n\">withNaryArg</span> <span class=\"mi\">1</span> <span class=\"n\">delab</span>\n  <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">e.getArg</span><span class=\"bp\">!</span> <span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">isLambda</span> <span class=\"k\">then</span>\n    <span class=\"k\">let</span> <span class=\"n\">v</span> <span class=\"bp\">←</span> <span class=\"n\">withNaryArg</span> <span class=\"mi\">3</span> <span class=\"k\">do</span>\n      <span class=\"k\">let</span> <span class=\"n\">enableFunBinder</span> <span class=\"o\">(</span><span class=\"n\">subExpr</span> <span class=\"o\">:</span> <span class=\"n\">SubExpr</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n        <span class=\"k\">let</span> <span class=\"n\">expr</span> <span class=\"o\">:=</span> <span class=\"n\">subExpr.expr</span>\n        <span class=\"k\">let</span> <span class=\"n\">expr</span> <span class=\"o\">:=</span> <span class=\"n\">mkAppN</span> <span class=\"o\">(</span><span class=\"n\">expr.getAppFn.setOption</span> <span class=\"n\">pp.funBinderTypes.name</span> <span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"n\">expr.getAppArgs</span>\n        <span class=\"o\">{</span> <span class=\"n\">subExpr</span> <span class=\"k\">with</span> <span class=\"n\">expr</span> <span class=\"o\">}</span>\n      <span class=\"n\">withTheReader</span> <span class=\"n\">SubExpr</span> <span class=\"n\">enableFunBinder</span> <span class=\"n\">delab</span>\n    <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">f</span> <span class=\"bp\">$</span><span class=\"n\">R</span> <span class=\"bp\">$</span><span class=\"n\">v</span><span class=\"o\">)</span>\n  <span class=\"k\">else</span>\n    <span class=\"k\">let</span> <span class=\"n\">v</span> <span class=\"bp\">←</span> <span class=\"n\">withNaryArg</span> <span class=\"mi\">3</span> <span class=\"n\">delab</span>\n    <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">mkIdent</span> <span class=\"bp\">`</span><span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">$</span><span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"bp\">$</span><span class=\"n\">R</span> <span class=\"bp\">$</span><span class=\"n\">v</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- shows `LinearIndependent K fun (b : ↑(insert x s)) ↦ ↑b`</span>\n<span class=\"k\">#check</span> <span class=\"n\">LinearIndependent.insert</span>\n<span class=\"c1\">-- unchanged, shows `LinearIndependent K (Fin.cons x v)`</span>\n<span class=\"k\">#check</span> <span class=\"n\">LinearIndependent.fin_cons</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"c1\">-- shows `LinearIndependent ?m.20493 fun (x : ↑s) ↦ ↑x`</span>\n<span class=\"k\">#check</span> <span class=\"n\">LinearIndependent</span> <span class=\"n\">_</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"c1\">-- shows `LinearIndependent ?m.20842 fun (x : { x // x ∈ s }) ↦ ↑x`</span>\n<span class=\"k\">#check</span> <span class=\"n\">LinearIndependent</span> <span class=\"n\">_</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">})</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"c1\">-- shows `LinearIndependent (ι := { x // x ∈ s }) ?m.21215 Subtype.val`</span>\n<span class=\"k\">#check</span> <span class=\"n\">LinearIndependent</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">Subtype.val</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 402314475,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1700077110
    },
    {
        "content": "<p>(I'm just assuming it's a good idea to pretty print it this way. I only thought about how to organize the code.)</p>",
        "id": 402314799,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1700077233
    },
    {
        "content": "<p>Other than wanting to use <code>Qq</code> for <code>Lean.Expr.coeTypeSet?</code>, I agree that looks nicer!</p>",
        "id": 402314832,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700077252
    },
    {
        "content": "<p>My question for you was more \"is this type of thing a good excuse to use a custom delaborator?\". I guess it's all just a hack for <code>pp.analyze</code> not working well enough to be the default, but maybe that's fine</p>",
        "id": 402314981,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700077320
    },
    {
        "content": "<p>If we do whnf, I'd want it to be reducible transparency. I removed that and did matching by hand, hoping that the terms would be OK</p>",
        "id": 402314995,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1700077322
    },
    {
        "content": "<p>My understanding is that <code>pp.analyze</code> works by inserting these sorts of pp options into a term (though in a globally accessible table rather than into the term itself). We're kind of doing that here, but there's not a good way to say \"ok, I'm done, now delaborate from here\" since it'll just be indirectly calling itself again, so it's responsible for finishing up the delaboration itself. Maybe it could explicitly set a pp option on the term that turns itself off.</p>",
        "id": 402315419,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1700077505
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Spelling.20of.20Subtype.2Eval.20in.20LinearIndependent/near/402309544\">said</a>:</p>\n<blockquote>\n<p>I worry slightly that having two ways to spell the same thing is setting ourselves up for more pain</p>\n</blockquote>\n<p>Note that my PR uses <code>abbrev</code>. </p>\n<p>I think it's such a boon for readability to talk about 'the inclusion map from s' rather than using <code>fun</code> notation. Defining <code>incl</code> is in the same spirit as having <code>s.restrict</code> and <code>Set.inclusion</code>, which already happily exist in mathlib.</p>",
        "id": 402317353,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1700078259
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> This strategy, of making a custom analysis pass, does work.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- If `e` is a coercion of a set to a type, return the set.</span>\n<span class=\"sd\">Succeeds either for `Set.Elem s` terms or `{x // x ∈ s}` subtype terms. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">Lean.Expr.coeTypeSet</span><span class=\"bp\">?</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">Expr</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">if</span> <span class=\"n\">e.isAppOfArity</span> <span class=\"bp\">``</span><span class=\"n\">Set.Elem</span> <span class=\"mi\">2</span> <span class=\"k\">then</span>\n    <span class=\"n\">return</span> <span class=\"n\">e.appArg</span><span class=\"bp\">!</span>\n  <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"n\">e.isAppOfArity</span> <span class=\"bp\">``</span><span class=\"n\">Subtype</span> <span class=\"mi\">2</span> <span class=\"k\">then</span>\n    <span class=\"k\">let</span> <span class=\"bp\">.</span><span class=\"n\">lam</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">body</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">e.appArg</span><span class=\"bp\">!</span> <span class=\"bp\">|</span> <span class=\"n\">failure</span>\n    <span class=\"n\">guard</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">body.isAppOfArity</span> <span class=\"bp\">``</span><span class=\"n\">Membership.mem</span> <span class=\"mi\">5</span>\n    <span class=\"k\">let</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">inst</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">bvar</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">body.getAppArgs</span> <span class=\"bp\">|</span> <span class=\"n\">failure</span>\n    <span class=\"n\">guard</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">inst.isAppOfArity</span> <span class=\"bp\">``</span><span class=\"n\">Set.instMembershipSet</span> <span class=\"mi\">1</span>\n    <span class=\"n\">return</span> <span class=\"n\">s</span>\n  <span class=\"k\">else</span>\n    <span class=\"n\">failure</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Lean.PrettyPrinter.Delaborator.OptionsPerPos.setBool</span> <span class=\"o\">(</span><span class=\"n\">opts</span> <span class=\"o\">:</span> <span class=\"n\">OptionsPerPos</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">SubExpr.Pos</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">OptionsPerPos</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"n\">opts.findD</span> <span class=\"n\">p</span> <span class=\"o\">{}</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">setBool</span> <span class=\"n\">n</span> <span class=\"n\">v</span>\n  <span class=\"n\">opts.insert</span> <span class=\"n\">p</span> <span class=\"n\">e</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">PrettyPrinter.Delaborator</span> <span class=\"n\">SubExpr</span> <span class=\"k\">in</span>\n<span class=\"kd\">@[</span><span class=\"n\">delab</span> <span class=\"n\">app.LinearIndependent</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">delabLinearIndependent</span> <span class=\"o\">:</span> <span class=\"n\">Delab</span> <span class=\"o\">:=</span>\n  <span class=\"n\">whenPPOption</span> <span class=\"n\">getPPNotation</span> <span class=\"bp\">&lt;|</span>\n  <span class=\"n\">whenNotPPOption</span> <span class=\"n\">getPPAnalysisSkip</span> <span class=\"bp\">&lt;|</span>\n  <span class=\"n\">withOptionAtCurrPos</span> <span class=\"bp\">`</span><span class=\"n\">pp.analysis.skip</span> <span class=\"n\">true</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">getExpr</span>\n    <span class=\"n\">guard</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">e.isAppOfArity</span> <span class=\"bp\">``</span><span class=\"n\">LinearIndependent</span> <span class=\"mi\">7</span>\n    <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">e.getArg</span><span class=\"bp\">!</span> <span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">coeTypeSet</span><span class=\"bp\">?</span> <span class=\"bp\">|</span> <span class=\"n\">failure</span>\n    <span class=\"k\">let</span> <span class=\"n\">optionsPerPos</span> <span class=\"bp\">←</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">e.getArg</span><span class=\"bp\">!</span> <span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">isLambda</span> <span class=\"k\">then</span>\n      <span class=\"n\">withNaryArg</span> <span class=\"mi\">3</span> <span class=\"k\">do</span> <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">read</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">optionsPerPos.setBool</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getPos</span><span class=\"o\">)</span> <span class=\"n\">pp.funBinderTypes.name</span> <span class=\"n\">true</span>\n    <span class=\"k\">else</span>\n      <span class=\"n\">withNaryArg</span> <span class=\"mi\">0</span> <span class=\"k\">do</span> <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">read</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">optionsPerPos.setBool</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getPos</span><span class=\"o\">)</span> <span class=\"bp\">`</span><span class=\"n\">pp.analysis.namedArg</span> <span class=\"n\">true</span>\n    <span class=\"n\">withTheReader</span> <span class=\"n\">Context</span> <span class=\"o\">({</span><span class=\"bp\">·</span> <span class=\"k\">with</span> <span class=\"n\">optionsPerPos</span><span class=\"o\">})</span> <span class=\"n\">delab</span>\n</code></pre></div>",
        "id": 402319689,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1700079141
    },
    {
        "content": "<p>What is the status on the pp stuff here? I can see that the docs have changed, but they are still not readable : for example, the statement of the following lemma would need a mouseover to understand. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">LinearIndependent.insert</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_3</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">DivisionRing</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">LinearIndependent</span> <span class=\"n\">K</span> <span class=\"k\">fun</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">↑</span><span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∉</span> <span class=\"n\">Submodule.span</span> <span class=\"n\">K</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">LinearIndependent</span> <span class=\"n\">K</span> <span class=\"k\">fun</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">↑</span><span class=\"n\">b</span>\n</code></pre></div>",
        "id": 403820474,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1700757321
    },
    {
        "content": "<p>I think neither Kyle nor I have opened a PR with the above; so I'm surprised if the docs have changed!</p>",
        "id": 403824825,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700759298
    },
    {
        "content": "<p>Oops! I misremembered seeing the equally unhelpful <code>Subtype.val</code> there. That might have been in the pretty-printer.</p>",
        "id": 403824908,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1700759347
    },
    {
        "content": "<p>Here <span class=\"user-mention\" data-user-id=\"329425\">@Peter Nelson</span>: <a href=\"https://github.com/leanprover-community/mathlib4/pull/8602\">#8602</a></p>",
        "id": 403842932,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1700765878
    },
    {
        "content": "<p><code>insert</code> now reads:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">LinearIndependent.insert</span>\n    <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_3</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">DivisionRing</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n    <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">LinearIndependent</span> <span class=\"n\">K</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"bp\">↑</span><span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">↑</span><span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∉</span> <span class=\"n\">Submodule.span</span> <span class=\"n\">K</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">LinearIndependent</span> <span class=\"n\">K</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">x</span> <span class=\"n\">s</span><span class=\"o\">))</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">↑</span><span class=\"n\">b</span>\n</code></pre></div>\n<p>which I think is a big improvement</p>",
        "id": 403955833,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700827900
    },
    {
        "content": "<p>It's a bit unfortunate that <code>fun</code> looks like a regular variable name in the docs</p>",
        "id": 403955938,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700827930
    }
]