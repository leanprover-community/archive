[
    {
        "content": "<p>Hi, I am currently reading Mathematics in Lean. In Chapter 7, they introduce the <code>@[to_additive]</code> attribute and I am curious about its mechanism.</p>\n<p>Specifically, for this piece of code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">AddSemigroup₃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"sd\">/-- Addition is associative -/</span>\n<span class=\"w\">  </span><span class=\"n\">add_assoc₃</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">to_additive</span><span class=\"w\"> </span><span class=\"n\">AddSemigroup₃</span><span class=\"kd\">]</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Semigroup₃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">Mul</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"sd\">/-- Multiplication is associative -/</span>\n<span class=\"w\">  </span><span class=\"n\">mul_assoc₃</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Can someone explain what <code>to_additive</code> will do? Like, I don't think it will \"create\" <code>AddSemigroup₃</code> (because we already define that right above) and so maybe it will create a link? Does it do something else? Also, how does Lean/Mathlib know  <code>mul_assoc₃</code> is to be \"linked\" to <code>add_assoc₃</code> (does it?)</p>\n<p>Finally, for this part</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">whatsnew</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kd\">@[</span><span class=\"n\">to_additive</span><span class=\"kd\">]</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">left_inv_eq_right_inv'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid₃</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hba</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hac</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">one_mul</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">hba</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mul_assoc₃</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hac</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mul_one</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>How does it know to replace <code>inv</code> with <code>neg</code>? Is it hardcoded to find and replace all <code>inv</code>s with <code>neg</code>s?</p>\n<p>Many thanks.</p>",
        "id": 482495195,
        "sender_full_name": "The-Anh Vu-Le",
        "timestamp": 1731623823
    },
    {
        "content": "<p>Yes there's a big dictionary <code>inv</code>-&gt;<code>neg</code>, <code>mul</code>-&gt;<code>add</code> etc. It's in the code somewhere! Just right-click on to_additive, jump to the definition and poke around!</p>",
        "id": 482495375,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1731623928
    },
    {
        "content": "<p>Thanks! But I would also like to know what <code>@[to_additive AddSemigroup₃]</code> does and why we need to define <code>class AddSemigroup₃</code> before that (won't the same mechanism applicable to auto-generate an <code>AddSemigroup₃</code> definition)?</p>\n<p>Edit: I kinda see that maybe you want to add more things to  a class (<code>AddSemigroup₃</code>) so it's better to not rely on automation for class definition, but it works better for theorems.</p>",
        "id": 482496764,
        "sender_full_name": "The-Anh Vu-Le",
        "timestamp": 1731624591
    },
    {
        "content": "<p>At the time this attribute was written, lean didn't provide enough metaprogramming API to conveniently create structures in meta code. Do, for structures (incl. classes), <code>to_additive</code> just adds the names to its big dictionary. It would be nice to auto generate structures one day, but it's easy to work around, so nobody made this change yet.</p>",
        "id": 482497504,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1731625012
    },
    {
        "content": "<p>For definitions and lemmas, the attribute translates all names like <code>Inv.inv</code> to their additive counterparts, both in the type and in the definition or proof, then adds the resulting definition to the environment.</p>",
        "id": 482497691,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1731625112
    },
    {
        "content": "<p>One further question</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">AddSemigroup₃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"sd\">/-- Addition is associative -/</span>\n<span class=\"w\">  </span><span class=\"n\">add_assoc₃</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">to_additive</span><span class=\"w\"> </span><span class=\"n\">AddSemigroup₃</span><span class=\"kd\">]</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Semigroup₃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">Mul</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"sd\">/-- Multiplication is associative -/</span>\n<span class=\"w\">  </span><span class=\"n\">mul_assoc₃</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">AddMonoid₃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">AddSemigroup₃</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">AddZeroClass</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">to_additive</span><span class=\"w\"> </span><span class=\"n\">AddMonoid₃</span><span class=\"kd\">]</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Monoid₃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">Semigroup₃</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">MulOneClass</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">to_additive</span><span class=\"w\"> </span><span class=\"n\">existing</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">Monoid₃</span><span class=\"bp\">.</span><span class=\"n\">toMulOneClass</span>\n\n<span class=\"kn\">export</span><span class=\"w\"> </span><span class=\"n\">Semigroup₃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mul_assoc₃</span><span class=\"o\">)</span>\n<span class=\"kn\">export</span><span class=\"w\"> </span><span class=\"n\">AddSemigroup₃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">add_assoc₃</span><span class=\"o\">)</span>\n\n<span class=\"n\">whatsnew</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kd\">@[</span><span class=\"n\">to_additive</span><span class=\"kd\">]</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">left_inv_eq_right_inv'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid₃</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hba</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hac</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">one_mul</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">hba</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mul_assoc₃</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hac</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mul_one</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">]</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">left_neg_eq_right_neg'</span>\n</code></pre></div>\n<p>Let's say I change all <code>mul_assoc₃</code> to <code>m_assoc₃</code>. It will still successfully generate <code>left_neg_eq_right_neg'</code>. I find this very interesting, how did it get the proof/how did it relate <code>m_assoc₃</code> with <code>add_assoc₃</code>?</p>\n<p>Edit: seems like they do positional mapping as well.</p>",
        "id": 482498159,
        "sender_full_name": "The-Anh Vu-Le",
        "timestamp": 1731625347
    },
    {
        "content": "<p>Whenever <code>to_additive</code> deals with a <code>structure</code>, it records correspondence between its fields with same indexes.</p>",
        "id": 482502198,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1731627493
    },
    {
        "content": "<p>Correct (that happens <a href=\"https://github.com/leanprover-community/mathlib4/blob/daed990be85bb8fa9ad519b2c3249146f6ca11b7/Mathlib/Tactic/ToAdditive/Frontend.lean#L1102-L1104\">in these lines of code</a>)</p>",
        "id": 482502770,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1731627841
    }
]