[
    {
        "content": "<p>Lately I've been seeing (and participated in myself) a few efforts towards turning some semireducible type synonyms into one-element structures, to avoid defeq abuse and the like. </p>\n<p>The use case for this basically is when you have some type T and want to define a one-field structure, that field having the type T, in order to represent \"T, in a new context\" - you want to attach a different set of instances, normally. </p>\n<p>It occurs to me that when you make such a type you often then have a lot of boilerplate work that you need to do establishing the API for this pseudo-type synonym. In an ideal world this would always be the same API, or at least consistent between them.</p>\n<p>I'm no metaprogrammer, but surely something could be done in the vein of simps in order to auto-generate all the necessary API for these types. Perhaps this is even already possibly with tools like deriving, but that generates instances, rather than associated to/of functions or the like.</p>\n<p>What do people think? Is there any usefulness in creating an automated \"one-field structure API maker\"? What are the pitfalls and problems?</p>",
        "id": 528469309,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1752337323
    },
    {
        "content": "<p>Could you expand on what boilerplate you would expect to be generated?</p>",
        "id": 528483860,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1752353305
    },
    {
        "content": "<p>At minimum I guess the relevant maps to/from the wrapper to the original type, and the related Equiv.</p>",
        "id": 528490412,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1752363519
    },
    {
        "content": "<p>I'd also like to be able to say \"import this, this and this instances unchanged\", kind of thing.</p>",
        "id": 528490434,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1752363559
    },
    {
        "content": "<p>A common requirement is \"copy across all the additive structure, but let me define a new multiplication\"</p>",
        "id": 528518951,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1752400976
    },
    {
        "content": "<p>Right.</p>",
        "id": 528518966,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1752400995
    },
    {
        "content": "<p>And obviously that's case by case so you need to have a system for that.</p>",
        "id": 528518985,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1752401017
    },
    {
        "content": "<p>Having a \"transport this instance and everything under it\" approach would be close to what we need</p>",
        "id": 528519029,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1752401066
    },
    {
        "content": "<p>So transporting <code>AddCommGroup</code> also creates the required <code>[AddSemigroup X] : AddSemigroup (Wrapper X)</code> instance</p>",
        "id": 528519092,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1752401119
    },
    {
        "content": "<p>I noticed by the way, there's good machinery for using an Equiv to transport the algebra hierarchy but that doesn't seem to exist as much for the order hierarchy.</p>",
        "id": 528519161,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1752401185
    },
    {
        "content": "<p>You could also see this happening as part of typeclass search by having an <code>IsAddWrapper Wrapper</code> \"tag\" typeclass, though that probably runs into quantifier issues, and maybe has more of a runtime cost.</p>",
        "id": 528519225,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1752401262
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Coherent.20approach.20to.20one-field.20structures.2E/near/528519161\">said</a>:</p>\n<blockquote>\n<p>I noticed by the way, there's good machinery for using an Equiv to transport the algebra hierarchy but that doesn't seem to exist as much for the order hierarchy.</p>\n</blockquote>\n<p>I contend that this machinery is in fact not particularly good, and is merely extant</p>",
        "id": 528519302,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1752401342
    },
    {
        "content": "<p>The \"good\" machinery is the <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Function.Injective.group#doc\">docs#Function.Injective.group</a> family</p>",
        "id": 528519336,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1752401377
    },
    {
        "content": "<p>OK, that's fair. Yael is currently improving it a little by making it all not be in one file at least.</p>",
        "id": 528519338,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1752401377
    },
    {
        "content": "<p>Yes, I hope to find time to finish reviewing that PR on the next few days</p>",
        "id": 528519387,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1752401414
    },
    {
        "content": "<p>Still, I couldn't find a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Function.injective.completeSemilatticeInf#doc\">docs#Function.injective.completeSemilatticeInf</a>, for instance.</p>",
        "id": 528519412,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1752401440
    },
    {
        "content": "<p>Why care about <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CompleteSemilatticeInf#doc\">docs#CompleteSemilatticeInf</a> ?</p>",
        "id": 528519914,
        "sender_full_name": "YaÃ«l Dillies",
        "timestamp": 1752401956
    },
    {
        "content": "<p>Yes that's a fair question.</p>",
        "id": 528519924,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1752401968
    },
    {
        "content": "<p>I was in a weird case where I had two order-isomorphic structures and it was easy to prove one was a CompleteSemilatticeInf and one was a CompleteSemilatticeSup. And I wanted to say \"these are both complete lattices, and the \"hard\" instances arise by transporting over the easy ones from the other structure via the order isomorphism\".</p>",
        "id": 528520021,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1752402062
    },
    {
        "content": "<p>That feels like a pretty rare case:)</p>",
        "id": 528520027,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1752402072
    },
    {
        "content": "<p>I'm never sure if it's ever correct to use CompleteSemilatticeInf though.</p>",
        "id": 528520045,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1752402098
    },
    {
        "content": "<p>I would like to be able to transport a min or max using an order isomorphism though! And if that exists I couldn't find it.</p>",
        "id": 528520164,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1752402260
    }
]