[
    {
        "content": "<p>There are some (easily worked-around) issues with <code>ext</code> in <a href=\"https://github.com/leanprover-community/mathlib4/pull/3208\">!4#3208</a> (port <code>CategoryTheory.Limits.Presheaf</code>) and I thought I'd try and understand them rather than just pushing the PR through (which now compiles). Here's the first one:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- lean 3</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory.types</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">⟶</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"c1\">-- works</span>\n  <span class=\"gr\">sorry</span> <span class=\"c1\">-- `⊢ f x = g x`</span>\n<span class=\"kd\">end</span>\n\n<span class=\"k\">#print</span> <span class=\"n\">foo</span> <span class=\"c1\">-- it's `funext`</span>\n</code></pre></div>\n<p>In Lean 4 this currently fails:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- lean 4</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.CategoryTheory.Types</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">⟶</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">--ext x -- fails</span>\n  <span class=\"n\">funext</span> <span class=\"n\">x</span> <span class=\"c1\">-- works</span>\n</code></pre></div>\n<p>I don't really understand why it works in Lean 3 but not Lean 4. There seem to be no ext lemmas in <code>category_theory.types</code>. Does Lean 3 see through more stuff than Lean 4 somehow? My instinct was to make an ext lemma for <code>concrete_category</code> but actually this is not imported in the example. Should I just make an ext lemma for <code>Type u</code> and dump it in the imported file?</p>",
        "id": 351905867,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1682179319
    },
    {
        "content": "<p>Do you know if you can import <code>Mathlib.CategoryTheory.ConcreteCategory.Basic</code> into that file? It looks like there's a relevant ext lemma.</p>",
        "id": 351906761,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1682179699
    },
    {
        "content": "<p>Though perhaps it should have a specialized one for <code>Type</code> still, because this isn't great:</p>",
        "id": 351906862,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1682179769
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- lean 4</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.CategoryTheory.Types</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.CategoryTheory.ConcreteCategory.Basic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">⟶</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ext</span> <span class=\"n\">x</span> <span class=\"c1\">-- works</span>\n  <span class=\"c1\">-- ⊢ (CategoryTheory.forget Type).map f x = (CategoryTheory.forget Type).map g x</span>\n</code></pre></div>",
        "id": 351906900,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1682179794
    },
    {
        "content": "<p>There was a thread a while ago explaining the issue</p>",
        "id": 351906977,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1682179825
    },
    {
        "content": "<p>I’ll try to dig it up when I get home</p>",
        "id": 351906994,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1682179843
    },
    {
        "content": "<p>Something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- lean 4</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.CategoryTheory.Types</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.CategoryTheory.ConcreteCategory.Basic</span>\n\n<span class=\"kd\">@[ext 950]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">CategoryTheory.ConcreteCategory.type_hom_ext</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"n\">funext</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">⟶</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ext</span> <span class=\"n\">x</span> <span class=\"c1\">-- works</span>\n  <span class=\"c1\">-- ⊢ f x = g x</span>\n</code></pre></div>",
        "id": 351907425,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1682180034
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/287929-mathlib4/topic/ext.20issues/near/351906977\">said</a>:</p>\n<blockquote>\n<p>There was a thread a while ago explaining the issue</p>\n</blockquote>\n<p>I think it might be this one: <a href=\"#narrow/stream/287929-mathlib4/topic/ext.20debugging/near/348821912\">https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/ext.20debugging/near/348821912</a></p>",
        "id": 351907512,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1682180070
    },
    {
        "content": "<p>No there was one even before that (I think I initiated it)</p>",
        "id": 351907731,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1682180196
    },
    {
        "content": "<p>The second issue is that Lean 3 <code>ext</code> seems to unfold definitions if necessary, but Lean 4 doesn't. Here's an example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- lean 3</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">constant</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n\n<span class=\"kd\">@[ext]</span> <span class=\"kd\">lemma</span> <span class=\"n\">X.ext</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"c1\">--works fine</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">X</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"c1\">-- also works fine!</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>The analogous code in Lean 4 doesn't work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- lean 4</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"n\">opaque</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n\n<span class=\"kd\">@[ext]</span> <span class=\"kd\">lemma</span> <span class=\"n\">X.ext</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ext</span> <span class=\"c1\">--works fine</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">X</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ext</span> <span class=\"c1\">-- no applicable extensionality lemma found for `Y`</span>\n</code></pre></div>",
        "id": 351907959,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1682180304
    },
    {
        "content": "<p>In that thread I linked to, Gabriel mentioned that the Lean 3 <code>ext</code> tactic would try applying <em>all</em> ext lemmas as a last resort, which might be why the Lean 3 examples work here.</p>",
        "id": 351908187,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1682180406
    },
    {
        "content": "<p>This is kind of a big call. We have</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">extendAlongYoneda_obj</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"bp\">ᵒᵖ</span> <span class=\"bp\">⥤</span> <span class=\"kt\">Type</span> <span class=\"n\">u₁</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">extendAlongYoneda</span> <span class=\"n\">A</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">P</span> <span class=\"bp\">=</span> <span class=\"n\">colimit</span> <span class=\"o\">((</span><span class=\"n\">CategoryOfElements.π</span> <span class=\"n\">P</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">leftOp</span> <span class=\"bp\">⋙</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>and we have an <code>ext</code> lemma for colimits, so I could obviously make the corresponding <code>ext</code> lemma for <code>(extendAlongYoneda A).obj P</code> but it might be better to have Lean 4 <code>ext</code> doing the same thing as Lean 3.</p>",
        "id": 351908217,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1682180416
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/287929-mathlib4/topic/ext.20issues/near/351908187\">said</a>:</p>\n<blockquote>\n<p>In that thread I linked to, Gabriel mentioned that the Lean 3 <code>ext</code> tactic would try applying <em>all</em> ext lemmas as a last resort, which might be why the Lean 3 examples work here.</p>\n</blockquote>\n<p>Is there a reason that we don't want to do this in Lean 4? I mean, if we change the behaviour of the tactic then things are going to break, and are breaking.</p>",
        "id": 351908338,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1682180468
    },
    {
        "content": "<p>In fact this explains a lot!</p>",
        "id": 351908803,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1682180655
    },
    {
        "content": "<p>The old behavior seems really unpredictable to me. It depends on whatever random order the ext lemmas are defined in and what happens to unfold to what. There are probably things that are broken that are things that shouldn't have ever worked (though still some that arguably should).</p>\n<p>There should be some way to tell <code>ext</code> that it should unfold definitions while searching for <code>ext</code> lemmas... In any case, this breakage/change in behavior is making us fix \"bad exts\".</p>",
        "id": 351908978,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1682180735
    },
    {
        "content": "<p>Oh dear, the linked thread seems to indicate that making <code>ext</code> try all the ext lemmas as a last resort is not an option any more. So should I just add the \"missing\" <code>ext</code> lemmas?</p>",
        "id": 351909076,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1682180771
    },
    {
        "content": "<p>That to me seems like the right thing to do</p>",
        "id": 351909233,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1682180849
    },
    {
        "content": "<p>Maybe we could create an attribute to inherit ext lemmas from another definition, like maybe</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[exts]</span> <span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">X</span>\n</code></pre></div>",
        "id": 351909573,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1682180959
    },
    {
        "content": "<p>Anyway, I'm not sure what to call it, but this should definitely accompany <code>hom_ext</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[ext 950]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">CategoryTheory.ConcreteCategory.type_hom_ext</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"n\">funext</span> <span class=\"n\">h</span>\n</code></pre></div>\n<p>I don't know what <code>ext</code> priority it should be either. I just chose that number to be above the priority for <code>hom_ext</code>.</p>",
        "id": 351909858,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1682181065
    },
    {
        "content": "<p>Another option is to add <code>funext</code> to aesop_cat’s rule set (maybe scoped to concrete categories)</p>",
        "id": 351911907,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1682181882
    },
    {
        "content": "<p>Actually I think the right solution is to make Homs in the category of types (and also in all the categories arising from bundled, like <code>GroupCat</code> etc.) into a structure with a single field, similar to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.Sheaf.hom\">docs#category_theory.Sheaf.hom</a></p>",
        "id": 351912705,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1682182202
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/3593\">!4#3593</a> adds the ext lemma for <code>Type u</code>. This is part of what we need to unblock <a href=\"https://github.com/leanprover-community/mathlib4/pull/3208\">!4#3208</a> .</p>",
        "id": 351915164,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1682183234
    }
]