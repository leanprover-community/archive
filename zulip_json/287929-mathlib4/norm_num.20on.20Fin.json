[
    {
        "content": "<p>In mathlib3, we had norm_num and norm_fin, which did reductions of expressions like <code>(3 : Fin 3)</code> to <code>0</code>. So <code>norm_num</code> could solve <code>(3 : Fin 3) = 0</code>. I'm trying to extend mathlib4 norm_num to do the same. It seems a path would be to hardcode a branch in <code>mkOfNat</code>.:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">mkOfNat</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">_sα</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">AddMonoidWithOne</span> <span class=\"bp\">$</span><span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">lit</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">ℕ</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n    <span class=\"n\">MetaM</span> <span class=\"o\">((</span><span class=\"n\">a'</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"bp\">×</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">lit</span> <span class=\"bp\">=</span> <span class=\"bp\">$</span><span class=\"n\">a'</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">if</span> <span class=\"n\">α.isConstOf</span> <span class=\"bp\">``</span><span class=\"n\">Nat</span> <span class=\"k\">then</span>\n    <span class=\"k\">let</span> <span class=\"n\">a'</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">OfNat.ofNat</span> <span class=\"bp\">$</span><span class=\"n\">lit</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n    <span class=\"n\">pure</span> <span class=\"o\">⟨</span><span class=\"n\">a'</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"bp\">$</span><span class=\"n\">a'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)⟩</span>\n  <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"n\">α.isConstOf</span> <span class=\"bp\">``</span><span class=\"n\">Int</span> <span class=\"k\">then</span>\n    <span class=\"k\">let</span> <span class=\"n\">a'</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">OfNat.ofNat</span> <span class=\"bp\">$</span><span class=\"n\">lit</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span>\n    <span class=\"n\">pure</span> <span class=\"o\">⟨</span><span class=\"n\">a'</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"bp\">$</span><span class=\"n\">a'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)⟩</span>\n  <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"n\">α.isConstOf</span> <span class=\"bp\">``</span><span class=\"n\">Rat</span> <span class=\"k\">then</span>\n    <span class=\"k\">let</span> <span class=\"n\">a'</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">OfNat.ofNat</span> <span class=\"bp\">$</span><span class=\"n\">lit</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span>\n    <span class=\"n\">pure</span> <span class=\"o\">⟨</span><span class=\"n\">a'</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"bp\">$</span><span class=\"n\">a'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)⟩</span>\n  <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"n\">α.isAppOf</span> <span class=\"bp\">``</span><span class=\"n\">Fin</span> <span class=\"k\">then</span>\n    <span class=\"n\">trace</span><span class=\"o\">[</span><span class=\"n\">Tactic.norm_num</span><span class=\"o\">]</span> <span class=\"s2\">\"inside Fin α := {α}\"</span>\n    <span class=\"k\">let</span> <span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">`</span><span class=\"n\">Fin</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">ℕ</span><span class=\"o\">))</span> <span class=\"bp\">←</span> <span class=\"n\">whnfR</span> <span class=\"n\">α</span> <span class=\"bp\">|</span> <span class=\"n\">failure</span>\n    <span class=\"n\">trace</span><span class=\"o\">[</span><span class=\"n\">Tactic.norm_num</span><span class=\"o\">]</span> <span class=\"s2\">\"inside Fin qn := {n}\"</span>\n    <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">n.natLit</span><span class=\"bp\">?</span> <span class=\"bp\">|</span> <span class=\"n\">failure</span> <span class=\"c1\">-- fails here; need to `deriveNat n` possibly?</span>\n    <span class=\"n\">trace</span><span class=\"o\">[</span><span class=\"n\">Tactic.norm_num</span><span class=\"o\">]</span> <span class=\"s2\">\"inside Fin n := {n}\"</span>\n    <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">lit.natLit</span><span class=\"bp\">?</span> <span class=\"bp\">|</span> <span class=\"n\">failure</span>\n    <span class=\"n\">trace</span><span class=\"o\">[</span><span class=\"n\">Tactic.norm_num</span><span class=\"o\">]</span> <span class=\"s2\">\"inside Fin {x} {n}\"</span>\n    <span class=\"k\">match</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">%</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"o\">⟨</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Nat.cast_zero</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"bp\">$</span><span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)⟩</span>\n    <span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"o\">⟨</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Nat.cast_one</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"bp\">$</span><span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)⟩</span>\n    <span class=\"bp\">|</span> <span class=\"n\">k</span><span class=\"bp\">+</span><span class=\"mi\">2</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">let</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">mkRawNatLit</span> <span class=\"n\">k</span>\n      <span class=\"k\">let</span> <span class=\"n\">_x</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Nat.AtLeastTwo</span> <span class=\"bp\">$</span><span class=\"n\">lit</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n        <span class=\"o\">(</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">instNatAtLeastTwo</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"bp\">$</span><span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span>\n      <span class=\"k\">let</span> <span class=\"n\">a'</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">OfNat.ofNat</span> <span class=\"bp\">$</span><span class=\"n\">lit</span><span class=\"o\">)</span>\n      <span class=\"n\">pure</span> <span class=\"o\">⟨</span><span class=\"n\">a'</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"bp\">$</span><span class=\"n\">a'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)⟩</span>\n  <span class=\"k\">else</span>\n    <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">lit.natLit</span><span class=\"bp\">?</span> <span class=\"bp\">|</span> <span class=\"n\">failure</span>\n    <span class=\"k\">match</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"o\">⟨</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Nat.cast_zero</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"bp\">$</span><span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)⟩</span>\n    <span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"o\">⟨</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Nat.cast_one</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"bp\">$</span><span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)⟩</span>\n    <span class=\"bp\">|</span> <span class=\"n\">k</span><span class=\"bp\">+</span><span class=\"mi\">2</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">let</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">mkRawNatLit</span> <span class=\"n\">k</span>\n      <span class=\"k\">let</span> <span class=\"n\">_x</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Nat.AtLeastTwo</span> <span class=\"bp\">$</span><span class=\"n\">lit</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n        <span class=\"o\">(</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">instNatAtLeastTwo</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"bp\">$</span><span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span>\n      <span class=\"k\">let</span> <span class=\"n\">a'</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">OfNat.ofNat</span> <span class=\"bp\">$</span><span class=\"n\">lit</span><span class=\"o\">)</span>\n      <span class=\"n\">pure</span> <span class=\"o\">⟨</span><span class=\"n\">a'</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"bp\">$</span><span class=\"n\">a'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)⟩</span>\n</code></pre></div>",
        "id": 392856323,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1695579391
    },
    {
        "content": "<p>But the <code>n.natLit?</code> is failing, which makes sense, it's not really a literal at that point. Somehow I have to extract the nat value from the expression -- is this where <code>deriveNat</code> should come in?</p>",
        "id": 392856340,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1695579428
    },
    {
        "content": "<p>Or, separately, one could image writing a specific norm_num extension for <code>Fin</code>, but I would think it would be for catching <code>@OfNat.ofNat (Fin _) _ _</code>, which is already caught by the existing <code>@[norm_num OfNat.ofNat _] def evalOfNat</code>. How does norm_num currently handle overlapping extensions?</p>",
        "id": 392856436,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1695579511
    },
    {
        "content": "<p>The motivating example here to make neater is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.Perm.List</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.FinCases</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.NormNum</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">exercise36_hom3</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">3</span> <span class=\"bp\">→+</span> <span class=\"n\">Additive</span> <span class=\"o\">(</span><span class=\"n\">Equiv.Perm</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">3</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n  <span class=\"n\">AddMonoidHom.mk'</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">k</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">match</span> <span class=\"n\">k</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Additive.ofMul</span> <span class=\"o\">(</span><span class=\"n\">List.formPerm</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">])</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">2</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Additive.ofMul</span> <span class=\"o\">(</span><span class=\"n\">List.formPerm</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">])</span>\n  <span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span>\n    <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n    <span class=\"k\">have</span> <span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"o\">(⟨</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">norm_num</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n    <span class=\"k\">have</span> <span class=\"n\">h3</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">norm_num</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n    <span class=\"k\">have</span> <span class=\"n\">h4</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">4</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">norm_num</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n    <span class=\"n\">fin_cases</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;;&gt;</span>\n    <span class=\"n\">fin_cases</span> <span class=\"n\">b</span>\n    <span class=\"bp\">·</span> <span class=\"n\">simp</span>\n    <span class=\"bp\">·</span> <span class=\"n\">simp</span>\n    <span class=\"bp\">·</span> <span class=\"n\">simp</span>\n    <span class=\"bp\">·</span> <span class=\"n\">simp</span>\n    <span class=\"bp\">·</span> <span class=\"n\">norm_num</span>\n      <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">h2</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">ofMul_mul</span><span class=\"o\">]</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"n\">ofMul_mul</span><span class=\"o\">]</span>\n    <span class=\"bp\">·</span> <span class=\"n\">norm_num</span> <span class=\"o\">[</span><span class=\"n\">h2</span><span class=\"o\">]</span>\n      <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">ofMul_mul</span><span class=\"o\">]</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h3</span><span class=\"o\">,</span> <span class=\"n\">eq_comm</span><span class=\"o\">]</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"n\">ofMul_mul</span><span class=\"o\">]</span>\n    <span class=\"bp\">·</span> <span class=\"n\">simp</span>\n    <span class=\"bp\">·</span> <span class=\"n\">norm_num</span> <span class=\"o\">[</span><span class=\"n\">h2</span><span class=\"o\">]</span>\n      <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">h3</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">ofMul_mul</span><span class=\"o\">]</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">eq_comm</span><span class=\"o\">]</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"n\">ofMul_mul</span><span class=\"o\">]</span>\n    <span class=\"bp\">·</span> <span class=\"n\">norm_num</span> <span class=\"o\">[</span><span class=\"n\">h2</span><span class=\"o\">]</span>\n      <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">h4</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">ofMul_mul</span><span class=\"o\">]</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">eq_comm</span><span class=\"o\">]</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"n\">ofMul_mul</span><span class=\"o\">])</span>\n</code></pre></div>",
        "id": 392857859,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1695580863
    },
    {
        "content": "<p>Perhaps it is also a <code>fin_cases</code> concern, that it shouldn't break down a <code>Fin</code> into a <code>Fin.mk</code> expression.</p>",
        "id": 392857887,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1695580899
    },
    {
        "content": "<p>This should hopefully be handled by <a href=\"https://github.com/leanprover-community/mathlib4/pull/5376\">#5376</a></p>",
        "id": 392864784,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1695586619
    },
    {
        "content": "<p>See also <a href=\"#narrow/stream/287929-mathlib4/topic/Reducing.20mod.20n/near/387773271\">https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Reducing.20mod.20n/near/387773271</a> if you just want the case of numerals equal to the characteristic to be reduced</p>",
        "id": 392864878,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1695586732
    },
    {
        "content": "<p>In the meantime, if I wanted to match solely on <code>FIn</code> (instead of all char p rings), what would be the right syntax?</p>",
        "id": 392867094,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1695588743
    },
    {
        "content": "<p>What happened to this effort? So far, <code>norm_num</code> still does not simplify <code>8 * a</code> to zero, when <code>a : ZMod 8</code>...</p>",
        "id": 397557456,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1697740679
    },
    {
        "content": "<p>I think <a href=\"https://github.com/leanprover-community/mathlib4/pull/5376\">#5376</a> still needs some work, it looks like it basically works, but linting fails and it gets merge conflicts sometimes. Anne is busy writing their PhD thesis so it probably isnt their first priority right now. So maybe we shoud be a bit more proactive in fixing the (seemingly minor) issues with the branch for them. It does solve your problem so there is certainly benefit to merging it even if other improvements are planned</p>",
        "id": 397558221,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1697741013
    },
    {
        "content": "<p>I'm mostly done with my thesis now, but getting back into active work on mathlib is proving harder than expected. I'll do my best to get this PR in a good shape next week, and help is always deeply appreciated!</p>",
        "id": 397657421,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1697790426
    }
]