[
    {
        "content": "<p>Props to <span class=\"user-mention\" data-user-id=\"479299\">@Jovan Gerbscheid</span> who, in a one-line PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/21329\">#21329</a> , did this:</p>\n<div class=\"codehilite\" data-code-language=\"Diff\"><pre><span></span><code><span class=\"gi\">+ ~Mathlib.Algebra.Homology.BifunctorShift                        instructions   -39.2%</span>\n<span class=\"gi\">+ ~Mathlib.Algebra.Homology.HomotopyCategory.DegreewiseSplit      instructions   -52.2%</span>\n<span class=\"gi\">+ ~Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift      instructions   -25.1%</span>\n<span class=\"gi\">+ ~Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated      instructions   -32.1%</span>\n<span class=\"gi\">+ ~Mathlib.Algebra.Homology.HomotopyCategory.Shift                instructions   -26.4%</span>\n<span class=\"gi\">+ ~Mathlib.Algebra.Homology.HomotopyCategory.ShiftSequence        instructions   -45.0%</span>\n<span class=\"gi\">+ ~Mathlib.Algebra.Homology.HomotopyCategory.SingleFunctors       instructions   -41.4%</span>\n<span class=\"gi\">+ ~Mathlib.Algebra.Homology.HomotopyCategory.Triangulated         instructions   -30.7%</span>\n<span class=\"gi\">+ ~Mathlib.Algebra.Homology.TotalComplexShift                     instructions   -30.6%</span>\n<span class=\"gi\">+ ~Mathlib.CategoryTheory.Triangulated.Opposite.Pretriangulated   instructions   -26.3%</span>\n</code></pre></div>\n<p>The \"unfavourable discrimination tree key\" he mentions in the PR description is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">discr_tree_key</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">shiftFunctor_of_induced</span>\n<span class=\"c1\">-- @Eq (CategoryTheory.Functor _ _ _ _) (CategoryTheory.shiftFunctor _ _ _ _ _ _) _</span>\n</code></pre></div>\n<p>Thanks also to the person who wrote <code>#discr_tree_key</code> because it's the only tool I have to understand what people are talking about when they talk about discrimination trees.</p>\n<p>My question is: how many other simp lemmas are there out there with \"unfavourable discrimination tree key\" s and how much more of a speedup can we win by finding them and removing <code>@[simp]</code> from them?</p>",
        "id": 497258784,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1738502906
    },
    {
        "content": "<p>You want <code>#discr_tree_simp_key</code> for <code>simp</code> theorems. </p>\n<p>I‚Äôve thought about a broader search over the environment using the keys but what are the criteria to filter by?</p>",
        "id": 497259063,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1738503162
    },
    {
        "content": "<p>Two things that could be done:</p>\n<ul>\n<li>check for simp lemmas where the <code>#discr_tree_simp_key</code> has the form <code>foo _ _ _ _ _</code></li>\n<li>keep track of how much simp time is spent on failing, on a lemma-per-lemma basis.</li>\n</ul>",
        "id": 497259277,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1738503369
    },
    {
        "content": "<p>However the form <code>foo _ _ _ _</code> isn't the only bad form. I also stumbled upon <code>LinearMap.map_coe_ker</code>, which has the key<code>@DFunLike.coe _ _ _ _ _ _.1</code> (where the <code>.1</code> is a projection on a subtype). This is also too general.</p>\n<p>But that lemma is actually used so maybe scoping it would be a better middleground.</p>",
        "id": 497259464,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1738503538
    },
    {
        "content": "<p>How bad the first is overall depends a lot on <code>foo</code> and its ubiquity.</p>",
        "id": 497259621,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1738503704
    },
    {
        "content": "<p>Do we have a metric for this though?</p>",
        "id": 497259716,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1738503794
    },
    {
        "content": "<p>It's not too hard to go through the types of each declaration and determine which constants appear there. Then each constant has a count of how many declarations use it. So I guess we can use that for a metric.</p>",
        "id": 497259829,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1738503914
    },
    {
        "content": "<p>I‚Äôve done (or at least tried) the second. There‚Äôs a thread here with my results. My approach through an environment extension to store things didn‚Äôt comport with the ongoing parallelization work though</p>",
        "id": 497259843,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1738503942
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/stream/287929-mathlib4/topic/bad.20simp.20discrimination.20tree.20keys/near/497259829\">said</a>:</p>\n<blockquote>\n<p>It's not too hard to go through the types of each declaration and determine which constants appear there. Then each constant has a count of how many declarations use it. So I guess we can use that for a metric.</p>\n</blockquote>\n<p>I‚Äôd be interested to see this regardless</p>",
        "id": 497259921,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1738504013
    },
    {
        "content": "<p>If someone wants to hunt for things with bad keys <a href=\"https://speed.lean-lang.org/mathlib4/run-detail/1e05a0b3-1e66-45aa-b957-ebeb22dbcee2\">this</a> might be a good place to look.</p>",
        "id": 497266861,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1738510298
    },
    {
        "content": "<p>I made some code to check for keys of the form <code>foo _ _ _ _</code>, but it turns out there are way too many lemmas like this to check them one by one. However, what I did find out is that there are simp lemmas which have the form <code>(fun _ =&gt; _) = _</code>, and this is a very bad form of lemmas, because the discrimination tree key of a lambda expression is just &lt;other&gt;. Here's the quick code I used:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Meta</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Batteries</span><span class=\"w\"> </span><span class=\"n\">Tactic</span><span class=\"w\"> </span><span class=\"n\">Lint</span>\n\n<span class=\"kn\">private</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">mkKey</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">DiscrTree</span><span class=\"bp\">.</span><span class=\"n\">Key</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">withReducible</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">forallMetaTelescopeReducing</span><span class=\"w\"> </span><span class=\"n\">e</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">whnfR</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"n\">withSimpGlobalConfig</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">lhs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"bp\">.</span><span class=\"n\">eq?</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"n\">DiscrTree</span><span class=\"bp\">.</span><span class=\"n\">mkPath</span><span class=\"w\"> </span><span class=\"n\">lhs</span>\n<span class=\"w\">    </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">lhs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"bp\">.</span><span class=\"n\">iff?</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"n\">DiscrTree</span><span class=\"bp\">.</span><span class=\"n\">mkPath</span><span class=\"w\"> </span><span class=\"n\">lhs</span>\n<span class=\"w\">    </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">lhs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"bp\">.</span><span class=\"n\">ne?</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"n\">DiscrTree</span><span class=\"bp\">.</span><span class=\"n\">mkPath</span><span class=\"w\"> </span><span class=\"n\">lhs</span>\n<span class=\"w\">    </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"bp\">.</span><span class=\"n\">not?</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">eq?</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">lhs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">        </span><span class=\"n\">DiscrTree</span><span class=\"bp\">.</span><span class=\"n\">mkPath</span><span class=\"w\"> </span><span class=\"n\">lhs</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">DiscrTree</span><span class=\"bp\">.</span><span class=\"n\">mkPath</span><span class=\"w\"> </span><span class=\"n\">p</span>\n<span class=\"w\">    </span><span class=\"k\">else</span>\n<span class=\"w\">      </span><span class=\"n\">DiscrTree</span><span class=\"bp\">.</span><span class=\"n\">mkPath</span><span class=\"w\"> </span><span class=\"n\">type</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">isBadKeys</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">keys</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">DiscrTree</span><span class=\"bp\">.</span><span class=\"n\">Key</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">key</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">keys</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">:]</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"bp\">!</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"w\"> </span><span class=\"n\">matches</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">star</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">false</span>\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">true</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">env_linter</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">simpNF'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Lint</span><span class=\"bp\">.</span><span class=\"n\">Linter</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">noErrorsFound</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"NOTHING\"</span>\n<span class=\"w\">  </span><span class=\"n\">errorsFound</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"FOUND SOME!\"</span>\n<span class=\"w\">  </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">declName</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"n\">unless</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">isSimpTheorem</span><span class=\"w\"> </span><span class=\"n\">declName</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">getConstInfo</span><span class=\"w\"> </span><span class=\"n\">declName</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">type</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">keys</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">mkKey</span><span class=\"w\"> </span><span class=\"n\">e</span>\n<span class=\"w\">    </span><span class=\"n\">unless</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">isBadKeys</span><span class=\"w\"> </span><span class=\"n\">keys</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">none</span>\n\n<span class=\"w\">    </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"s2\">\"{e} might be a bad lemma. It has keys {keys}\"</span>\n\n<span class=\"bp\">#</span><span class=\"n\">lint</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"n\">simpNF'</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">all</span>\n</code></pre></div>",
        "id": 497559154,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1738629386
    },
    {
        "content": "<p>And here are the offending lemmas:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Init.Data.Array.Lemmas</span>\n<span class=\"n\">Array</span><span class=\"bp\">.</span><span class=\"n\">filterMap_eq_map</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\"> ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤),</span>\n<span class=\"cm\">  (fun as =&gt; Array.filterMap (some ‚àò f) as) = Array.map f -/</span>\n<span class=\"n\">Array</span><span class=\"bp\">.</span><span class=\"n\">filterMap_eq_filter</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\"> ‚àÄ {Œ± : Type u_1} (p : Œ± ‚Üí Bool),</span>\n<span class=\"cm\">  (fun as =&gt; Array.filterMap (Option.guard fun x =&gt; p x = true) as) = fun as =&gt;</span>\n<span class=\"cm\">    Array.filter p as -/</span>\n\n<span class=\"c1\">-- Mathlib.Analysis.Fourier.AddCircle</span>\n<span class=\"n\">coe_fourierBasis</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\"> ‚àÄ {T : ‚Ñù} [hT : Fact (0 &lt; T)],</span>\n<span class=\"cm\">  (fun i =&gt; fourierBasis.repr.symm (lp.single 2 i 1)) = fourierLp 2 -/</span>\n\n<span class=\"c1\">-- Mathlib.Analysis.Fourier.AddCircleMulti</span>\n<span class=\"n\">UnitAddTorus</span><span class=\"bp\">.</span><span class=\"n\">coe_mFourierBasis</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\"> ‚àÄ {d : Type u_1} [inst : Fintype d],</span>\n<span class=\"cm\">  (fun i =&gt; UnitAddTorus.mFourierBasis.repr.symm (lp.single 2 i 1)) =</span>\n<span class=\"cm\">    UnitAddTorus.mFourierLp 2 -/</span>\n\n<span class=\"c1\">-- Mathlib.Analysis.InnerProductSpace.l2Space</span>\n<span class=\"n\">HilbertBasis</span><span class=\"bp\">.</span><span class=\"n\">coe_mk</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\"> ‚àÄ {Œπ : Type u_1} {ùïú : Type u_2} [inst : RCLike ùïú] {E : Type u_3}</span>\n<span class=\"cm\">  [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ùïú E] [inst_3 : CompleteSpace E] {v : Œπ ‚Üí E}</span>\n<span class=\"cm\">  (hv : Orthonormal ùïú v) (hsp : ‚ä§ ‚â§ (Submodule.span ùïú (Set.range v)).topologicalClosure),</span>\n<span class=\"cm\">  (fun i =&gt; (HilbertBasis.mk hv hsp).repr.symm (lp.single 2 i 1)) = v -/</span>\n<span class=\"n\">HilbertBasis</span><span class=\"bp\">.</span><span class=\"n\">coe_mkOfOrthogonalEqBot</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\"> ‚àÄ {Œπ : Type u_1} {ùïú : Type u_2} [inst : RCLike ùïú] {E : Type u_3}</span>\n<span class=\"cm\">  [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ùïú E] [inst_3 : CompleteSpace E] {v : Œπ ‚Üí E}</span>\n<span class=\"cm\">  (hv : Orthonormal ùïú v) (hsp : (Submodule.span ùïú (Set.range v))·óÆ = ‚ä•),</span>\n<span class=\"cm\">  (fun i =&gt; (HilbertBasis.mkOfOrthogonalEqBot hv hsp).repr.symm (lp.single 2 i 1)) =</span>\n<span class=\"cm\">    v -/</span>\n<span class=\"n\">OrthonormalBasis</span><span class=\"bp\">.</span><span class=\"n\">coe_toHilbertBasis</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\"> ‚àÄ {Œπ : Type u_1} {ùïú : Type u_2} [inst : RCLike ùïú] {E : Type u_3}</span>\n<span class=\"cm\">  [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ùïú E] [inst_3 : CompleteSpace E] [inst_4 : Fintype Œπ]</span>\n<span class=\"cm\">  (b : OrthonormalBasis Œπ ùïú E),</span>\n<span class=\"cm\">  (fun i =&gt; b.toHilbertBasis.repr.symm (lp.single 2 i 1)) = ‚áëb -/</span>\n\n<span class=\"c1\">-- Mathlib.Combinatorics.HalesJewett</span>\n<span class=\"n\">Combinatorics</span><span class=\"bp\">.</span><span class=\"n\">Line</span><span class=\"bp\">.</span><span class=\"n\">map_apply</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\"> ‚àÄ {Œ± : Type u_5} {Œ±' : Type u_6} {Œπ : Type u_7} (f : Œ± ‚Üí Œ±')</span>\n<span class=\"cm\">  (l : Combinatorics.Line Œ± Œπ) (x : Œ±),</span>\n<span class=\"cm\">  (fun x i =&gt; ((Combinatorics.Line.map f l).idxFun i).getD x) (f x) =</span>\n<span class=\"cm\">    f ‚àò (fun x i =&gt; (l.idxFun i).getD x) x -/</span>\n<span class=\"n\">Combinatorics</span><span class=\"bp\">.</span><span class=\"n\">Line</span><span class=\"bp\">.</span><span class=\"n\">vertical_apply</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\"> ‚àÄ {Œ± : Type u_5} {Œπ : Type u_6} {Œπ' : Type u_7} (v : Œπ ‚Üí Œ±)</span>\n<span class=\"cm\">  (l : Combinatorics.Line Œ± Œπ') (x : Œ±),</span>\n<span class=\"cm\">  (fun x i =&gt; ((Combinatorics.Line.vertical v l).idxFun i).getD x) x =</span>\n<span class=\"cm\">    Sum.elim v ((fun x i =&gt; (l.idxFun i).getD x) x) -/</span>\n<span class=\"n\">Combinatorics</span><span class=\"bp\">.</span><span class=\"n\">Line</span><span class=\"bp\">.</span><span class=\"n\">horizontal_apply</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\"> ‚àÄ {Œ± : Type u_5} {Œπ : Type u_6} {Œπ' : Type u_7}</span>\n<span class=\"cm\">  (l : Combinatorics.Line Œ± Œπ) (v : Œπ' ‚Üí Œ±) (x : Œ±),</span>\n<span class=\"cm\">  (fun x i =&gt; ((l.horizontal v).idxFun i).getD x) x =</span>\n<span class=\"cm\">    Sum.elim ((fun x i =&gt; (l.idxFun i).getD x) x) v -/</span>\n<span class=\"n\">Combinatorics</span><span class=\"bp\">.</span><span class=\"n\">Line</span><span class=\"bp\">.</span><span class=\"n\">prod_apply</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\"> ‚àÄ {Œ± : Type u_5} {Œπ : Type u_6} {Œπ' : Type u_7} (l : Combinatorics.Line Œ± Œπ)</span>\n<span class=\"cm\">  (l' : Combinatorics.Line Œ± Œπ') (x : Œ±),</span>\n<span class=\"cm\">  (fun x i =&gt; ((l.prod l').idxFun i).getD x) x =</span>\n<span class=\"cm\">    Sum.elim ((fun x i =&gt; (l.idxFun i).getD x) x)</span>\n<span class=\"cm\">      ((fun x i =&gt; (l'.idxFun i).getD x) x) -/</span>\n<span class=\"n\">Combinatorics</span><span class=\"bp\">.</span><span class=\"n\">Line</span><span class=\"bp\">.</span><span class=\"n\">diagonal_apply</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\"> ‚àÄ {Œ± : Type u_5} {Œπ : Type u_6} [inst : Nonempty Œπ] (x : Œ±),</span>\n<span class=\"cm\">  (fun x i =&gt; ((Combinatorics.Line.diagonal Œ± Œπ).idxFun i).getD x) x = fun x_1 =&gt;</span>\n<span class=\"cm\">    x -/</span>\n\n<span class=\"c1\">-- Mathlib.Data.Fin.VecNotation</span>\n<span class=\"n\">Matrix</span><span class=\"bp\">.</span><span class=\"n\">empty_val'</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\"> ‚àÄ {Œ± : Type u} {n' : Type u_1} (j : n'),</span>\n<span class=\"cm\">  (fun i =&gt; ![] i j) = ![] -/</span>\n</code></pre></div>",
        "id": 497559259,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1738629475
    },
    {
        "content": "<p>There should definitely be a linter warning about simp lemmas with a lambda as the head symbol, because all of these simp lemmas are attempted every time when there is a lambda.</p>",
        "id": 497560123,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1738630018
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/channel/287929-mathlib4/topic/bad.20simp.20discrimination.20tree.20keys/near/497559259\">said</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Init.Data.Array.Lemmas</span>\n<span class=\"n\">Array</span><span class=\"bp\">.</span><span class=\"n\">filterMap_eq_map</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\"> ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤),</span>\n<span class=\"cm\">  (fun as =&gt; Array.filterMap (some ‚àò f) as) = Array.map f -/</span>\n<span class=\"n\">Array</span><span class=\"bp\">.</span><span class=\"n\">filterMap_eq_filter</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\"> ‚àÄ {Œ± : Type u_1} (p : Œ± ‚Üí Bool),</span>\n<span class=\"cm\">  (fun as =&gt; Array.filterMap (Option.guard fun x =&gt; p x = true) as) = fun as =&gt;</span>\n<span class=\"cm\">    Array.filter p as -/</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Fixed.</p>",
        "id": 497560154,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1738630060
    },
    {
        "content": "<p>This linter seems like a great idea. Could you PR it to Batteries?</p>",
        "id": 497560237,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1738630103
    },
    {
        "content": "<p>I'll clean up the rest of this report, it looks like most of them can just be dropped.</p>",
        "id": 497560471,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1738630311
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/channel/287929-mathlib4/topic/bad.20simp.20discrimination.20tree.20keys/near/497560237\">said</a>:</p>\n<blockquote>\n<p>This linter seems like a great idea. Could you PR it to Batteries?</p>\n</blockquote>\n<p><del>I've made a PR to lean (<a href=\"https://github.com/leanprover/lean4/pull/6936\">lean#6936</a>) that marks the relevant function as public, so that I can then use it in a linter in Batteries.</del> Nevermind, I can use the same machinery as <code>simpVarHead</code> and <code>simpNF</code></p>",
        "id": 497564402,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1738632733
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/21395\">#21395</a></p>",
        "id": 497579534,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1738642326
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/channel/287929-mathlib4/topic/bad.20simp.20discrimination.20tree.20keys/near/497559259\">said</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Mathlib.Combinatorics.HalesJewett</span>\n<span class=\"n\">Combinatorics</span><span class=\"bp\">.</span><span class=\"n\">Line</span><span class=\"bp\">.</span><span class=\"n\">map_apply</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\"> ‚àÄ {Œ± : Type u_5} {Œ±' : Type u_6} {Œπ : Type u_7} (f : Œ± ‚Üí Œ±')</span>\n<span class=\"cm\">  (l : Combinatorics.Line Œ± Œπ) (x : Œ±),</span>\n<span class=\"cm\">  (fun x i =&gt; ((Combinatorics.Line.map f l).idxFun i).getD x) (f x) =</span>\n<span class=\"cm\">    f ‚àò (fun x i =&gt; (l.idxFun i).getD x) x -/</span>\n<span class=\"n\">Combinatorics</span><span class=\"bp\">.</span><span class=\"n\">Line</span><span class=\"bp\">.</span><span class=\"n\">vertical_apply</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\"> ‚àÄ {Œ± : Type u_5} {Œπ : Type u_6} {Œπ' : Type u_7} (v : Œπ ‚Üí Œ±)</span>\n<span class=\"cm\">  (l : Combinatorics.Line Œ± Œπ') (x : Œ±),</span>\n<span class=\"cm\">  (fun x i =&gt; ((Combinatorics.Line.vertical v l).idxFun i).getD x) x =</span>\n<span class=\"cm\">    Sum.elim v ((fun x i =&gt; (l.idxFun i).getD x) x) -/</span>\n<span class=\"n\">Combinatorics</span><span class=\"bp\">.</span><span class=\"n\">Line</span><span class=\"bp\">.</span><span class=\"n\">horizontal_apply</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\"> ‚àÄ {Œ± : Type u_5} {Œπ : Type u_6} {Œπ' : Type u_7}</span>\n<span class=\"cm\">  (l : Combinatorics.Line Œ± Œπ) (v : Œπ' ‚Üí Œ±) (x : Œ±),</span>\n<span class=\"cm\">  (fun x i =&gt; ((l.horizontal v).idxFun i).getD x) x =</span>\n<span class=\"cm\">    Sum.elim ((fun x i =&gt; (l.idxFun i).getD x) x) v -/</span>\n<span class=\"n\">Combinatorics</span><span class=\"bp\">.</span><span class=\"n\">Line</span><span class=\"bp\">.</span><span class=\"n\">prod_apply</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\"> ‚àÄ {Œ± : Type u_5} {Œπ : Type u_6} {Œπ' : Type u_7} (l : Combinatorics.Line Œ± Œπ)</span>\n<span class=\"cm\">  (l' : Combinatorics.Line Œ± Œπ') (x : Œ±),</span>\n<span class=\"cm\">  (fun x i =&gt; ((l.prod l').idxFun i).getD x) x =</span>\n<span class=\"cm\">    Sum.elim ((fun x i =&gt; (l.idxFun i).getD x) x)</span>\n<span class=\"cm\">      ((fun x i =&gt; (l'.idxFun i).getD x) x) -/</span>\n<span class=\"n\">Combinatorics</span><span class=\"bp\">.</span><span class=\"n\">Line</span><span class=\"bp\">.</span><span class=\"n\">diagonal_apply</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\"> ‚àÄ {Œ± : Type u_5} {Œπ : Type u_6} [inst : Nonempty Œπ] (x : Œ±),</span>\n<span class=\"cm\">  (fun x i =&gt; ((Combinatorics.Line.diagonal Œ± Œπ).idxFun i).getD x) x = fun x_1 =&gt;</span>\n<span class=\"cm\">    x -/</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/21405\">#21405</a></p>",
        "id": 497599197,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1738654776
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/channel/287929-mathlib4/topic/bad.20simp.20discrimination.20tree.20keys/near/497559259\">said</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Mathlib.Analysis.Fourier.AddCircle</span>\n<span class=\"n\">coe_fourierBasis</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\"> ‚àÄ {T : ‚Ñù} [hT : Fact (0 &lt; T)],</span>\n<span class=\"cm\">  (fun i =&gt; fourierBasis.repr.symm (lp.single 2 i 1)) = fourierLp 2 -/</span>\n\n<span class=\"c1\">-- Mathlib.Analysis.Fourier.AddCircleMulti</span>\n<span class=\"n\">UnitAddTorus</span><span class=\"bp\">.</span><span class=\"n\">coe_mFourierBasis</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\"> ‚àÄ {d : Type u_1} [inst : Fintype d],</span>\n<span class=\"cm\">  (fun i =&gt; UnitAddTorus.mFourierBasis.repr.symm (lp.single 2 i 1)) =</span>\n<span class=\"cm\">    UnitAddTorus.mFourierLp 2 -/</span>\n\n<span class=\"c1\">-- Mathlib.Analysis.InnerProductSpace.l2Space</span>\n<span class=\"n\">HilbertBasis</span><span class=\"bp\">.</span><span class=\"n\">coe_mk</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\"> ‚àÄ {Œπ : Type u_1} {ùïú : Type u_2} [inst : RCLike ùïú] {E : Type u_3}</span>\n<span class=\"cm\">  [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ùïú E] [inst_3 : CompleteSpace E] {v : Œπ ‚Üí E}</span>\n<span class=\"cm\">  (hv : Orthonormal ùïú v) (hsp : ‚ä§ ‚â§ (Submodule.span ùïú (Set.range v)).topologicalClosure),</span>\n<span class=\"cm\">  (fun i =&gt; (HilbertBasis.mk hv hsp).repr.symm (lp.single 2 i 1)) = v -/</span>\n<span class=\"n\">HilbertBasis</span><span class=\"bp\">.</span><span class=\"n\">coe_mkOfOrthogonalEqBot</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\"> ‚àÄ {Œπ : Type u_1} {ùïú : Type u_2} [inst : RCLike ùïú] {E : Type u_3}</span>\n<span class=\"cm\">  [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ùïú E] [inst_3 : CompleteSpace E] {v : Œπ ‚Üí E}</span>\n<span class=\"cm\">  (hv : Orthonormal ùïú v) (hsp : (Submodule.span ùïú (Set.range v))·óÆ = ‚ä•),</span>\n<span class=\"cm\">  (fun i =&gt; (HilbertBasis.mkOfOrthogonalEqBot hv hsp).repr.symm (lp.single 2 i 1)) =</span>\n<span class=\"cm\">    v -/</span>\n<span class=\"n\">OrthonormalBasis</span><span class=\"bp\">.</span><span class=\"n\">coe_toHilbertBasis</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\"> ‚àÄ {Œπ : Type u_1} {ùïú : Type u_2} [inst : RCLike ùïú] {E : Type u_3}</span>\n<span class=\"cm\">  [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ùïú E] [inst_3 : CompleteSpace E] [inst_4 : Fintype Œπ]</span>\n<span class=\"cm\">  (b : OrthonormalBasis Œπ ùïú E),</span>\n<span class=\"cm\">  (fun i =&gt; b.toHilbertBasis.repr.symm (lp.single 2 i 1)) = ‚áëb -/</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Now also fixed in <a href=\"https://github.com/leanprover-community/mathlib4/pull/21405\">#21405</a></p>",
        "id": 497601060,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1738655678
    },
    {
        "content": "<blockquote>\n<p>but it turns out there are way too many lemmas like this to check them one by one. </p>\n</blockquote>\n<p>Yeah, this is was why I was getting a filtering heuristic. You can argue that anything of this shape is bad but the practical effect is negligible when <code>foo</code> is rarely used. </p>\n<p>You see that with the lambdas at the heads. Not a good idea in general but the practical effect is small compared to other situations.</p>",
        "id": 497890465,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1738761429
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/channel/287929-mathlib4/topic/bad.20simp.20discrimination.20tree.20keys/near/497564402\">said</a>:</p>\n<blockquote>\n<p>Nevermind, I can use the same machinery as <code>simpVarHead</code> and <code>simpNF</code></p>\n</blockquote>\n<p>If things weren't private in the <code>simp</code> processing, that would be optimal. You could reuse the same things that are actually used instead of cribbing them (and setting those to private because you cribbed them) like in the implementation of <code>#discr_tree_key</code>.</p>",
        "id": 497890882,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1738761558
    },
    {
        "content": "<p>Can <code>open private</code> be used to get the private defs? It's a hack, but it's better than copy-and-paste.</p>",
        "id": 497891953,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1738761890
    },
    {
        "content": "<p>Yes, I hadn't though of that before</p>",
        "id": 497892067,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1738761930
    },
    {
        "content": "<p>Where is that? I thought it was batteries</p>",
        "id": 497892075,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1738761935
    },
    {
        "content": "<p>Yes <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Elab.Command.elabOpenPrivate#doc\">docs#Lean.Elab.Command.elabOpenPrivate</a>. Maybe too implicit in what I said was that I was working in core. If you are importing batteries, then I think this is ok.</p>",
        "id": 497892802,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1738762167
    },
    {
        "content": "<p>Yes <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Elab.Command.elabOpenPrivate#doc\">docs#Lean.Elab.Command.elabOpenPrivate</a>. Maybe too implicit in what I said was that I was working in core. If you are importing batteries, then I think this is ok.</p>",
        "id": 497892811,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1738762171
    },
    {
        "content": "<p>I also tried linting for simp lemmas that simplify proofs (and hence don't usually apply). These seem to all originate from the <code>@[simps!]</code> tag. All of these failed the simpNF test when I tried fixing <a href=\"https://github.com/leanprover/lean4/pull/6960\">lean#6960</a>. Here are the offending lemmas:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Mathlib.AlgebraicGeometry.Cover.Open</span>\n<span class=\"n\">AlgebraicGeometry</span><span class=\"bp\">.</span><span class=\"n\">Scheme</span><span class=\"bp\">.</span><span class=\"n\">AffineOpenCover</span><span class=\"bp\">.</span><span class=\"n\">openCover_covers</span>\n\n<span class=\"c1\">-- Mathlib.AlgebraicTopology.SimplicialNerve</span>\n<span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">SimplicialThickening</span><span class=\"bp\">.</span><span class=\"n\">compFunctor_map_down_down</span>\n\n<span class=\"c1\">-- Mathlib.CategoryTheory.Comma.Basic</span>\n<span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Comma</span><span class=\"bp\">.</span><span class=\"n\">equivProd_inverse_obj_hom_down_down</span>\n<span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Comma</span><span class=\"bp\">.</span><span class=\"n\">toPUnitIdEquiv_unitIso_inv_app_right_down_down</span>\n<span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Comma</span><span class=\"bp\">.</span><span class=\"n\">toPUnitIdEquiv_inverse_map_right_down_down</span>\n<span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Comma</span><span class=\"bp\">.</span><span class=\"n\">toPUnitIdEquiv_inverse_obj_hom_down_down</span>\n<span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Comma</span><span class=\"bp\">.</span><span class=\"n\">toPUnitIdEquiv_unitIso_hom_app_right_down_down</span>\n<span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Comma</span><span class=\"bp\">.</span><span class=\"n\">toIdPUnitEquiv_inverse_map_left_down_down</span>\n<span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Comma</span><span class=\"bp\">.</span><span class=\"n\">toIdPUnitEquiv_unitIso_inv_app_left_down_down</span>\n<span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Comma</span><span class=\"bp\">.</span><span class=\"n\">toIdPUnitEquiv_unitIso_hom_app_left_down_down</span>\n<span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Comma</span><span class=\"bp\">.</span><span class=\"n\">toIdPUnitEquiv_inverse_obj_hom_down_down</span>\n\n<span class=\"c1\">-- Mathlib.CategoryTheory.Comma.Over</span>\n<span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Over</span><span class=\"bp\">.</span><span class=\"n\">postComp_inv_app_right_down_down</span>\n<span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Over</span><span class=\"bp\">.</span><span class=\"n\">postComp_hom_app_right_down_down</span>\n<span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Over</span><span class=\"bp\">.</span><span class=\"n\">postCongr_inv_app_right_down_down</span>\n<span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Over</span><span class=\"bp\">.</span><span class=\"n\">postCongr_hom_app_right_down_down</span>\n<span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Under</span><span class=\"bp\">.</span><span class=\"n\">postComp_hom_app_left_down_down</span>\n<span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Under</span><span class=\"bp\">.</span><span class=\"n\">postComp_inv_app_left_down_down</span>\n<span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Under</span><span class=\"bp\">.</span><span class=\"n\">postCongr_inv_app_left_down_down</span>\n<span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Under</span><span class=\"bp\">.</span><span class=\"n\">postCongr_hom_app_left_down_down</span>\n<span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">StructuredArrow</span><span class=\"bp\">.</span><span class=\"n\">ofStructuredArrowProjEquivalence</span><span class=\"bp\">.</span><span class=\"n\">functor_map_right_left_down_down</span>\n<span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">StructuredArrow</span><span class=\"bp\">.</span><span class=\"n\">ofStructuredArrowProjEquivalence</span><span class=\"bp\">.</span><span class=\"n\">functor_map_left_down_down</span>\n<span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">StructuredArrow</span><span class=\"bp\">.</span><span class=\"n\">ofStructuredArrowProjEquivalence</span><span class=\"bp\">.</span><span class=\"n\">inverse_map_left_down_down</span>\n<span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">StructuredArrow</span><span class=\"bp\">.</span><span class=\"n\">ofStructuredArrowProjEquivalence</span><span class=\"bp\">.</span><span class=\"n\">inverse_map_right_left_down_down</span>\n<span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">StructuredArrow</span><span class=\"bp\">.</span><span class=\"n\">ofDiagEquivalence</span><span class=\"bp\">.</span><span class=\"n\">functor_map_left_down_down</span>\n<span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">StructuredArrow</span><span class=\"bp\">.</span><span class=\"n\">ofDiagEquivalence</span><span class=\"bp\">.</span><span class=\"n\">functor_map_right_left_down_down</span>\n<span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">StructuredArrow</span><span class=\"bp\">.</span><span class=\"n\">ofDiagEquivalence</span><span class=\"bp\">.</span><span class=\"n\">inverse_map_left_down_down</span>\n<span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">StructuredArrow</span><span class=\"bp\">.</span><span class=\"n\">ofCommaSndEquivalenceInverse_map_left_down_down</span>\n<span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">CostructuredArrow</span><span class=\"bp\">.</span><span class=\"n\">ofCostructuredArrowProjEquivalence</span><span class=\"bp\">.</span><span class=\"n\">functor_map_right_down_down</span>\n<span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">CostructuredArrow</span><span class=\"bp\">.</span><span class=\"n\">ofCostructuredArrowProjEquivalence</span><span class=\"bp\">.</span><span class=\"n\">functor_map_left_right_down_down</span>\n<span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">CostructuredArrow</span><span class=\"bp\">.</span><span class=\"n\">ofCostructuredArrowProjEquivalence</span><span class=\"bp\">.</span><span class=\"n\">inverse_map_right_down_down</span>\n<span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">CostructuredArrow</span><span class=\"bp\">.</span><span class=\"n\">ofCostructuredArrowProjEquivalence</span><span class=\"bp\">.</span><span class=\"n\">inverse_map_left_right_down_down</span>\n<span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">CostructuredArrow</span><span class=\"bp\">.</span><span class=\"n\">ofDiagEquivalence</span><span class=\"bp\">.</span><span class=\"n\">functor_map_left_right_down_down</span>\n<span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">CostructuredArrow</span><span class=\"bp\">.</span><span class=\"n\">ofDiagEquivalence</span><span class=\"bp\">.</span><span class=\"n\">functor_map_right_down_down</span>\n<span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">CostructuredArrow</span><span class=\"bp\">.</span><span class=\"n\">ofDiagEquivalence</span><span class=\"bp\">.</span><span class=\"n\">inverse_map_right_down_down</span>\n<span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">CostructuredArrow</span><span class=\"bp\">.</span><span class=\"n\">ofCommaFstEquivalenceInverse_map_right_down_down</span>\n\n<span class=\"c1\">-- Mathlib.CategoryTheory.Comma.StructuredArrow.Basic</span>\n<span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">StructuredArrow</span><span class=\"bp\">.</span><span class=\"n\">preEquivalenceFunctor_map_left_down_down</span>\n<span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">StructuredArrow</span><span class=\"bp\">.</span><span class=\"n\">preEquivalenceInverse_map_left_down_down</span>\n<span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">StructuredArrow</span><span class=\"bp\">.</span><span class=\"n\">preEquivalenceInverse_map_right_left_down_down</span>\n<span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">StructuredArrow</span><span class=\"bp\">.</span><span class=\"n\">preEquivalenceInverse_obj_hom_left_down_down</span>\n<span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">CostructuredArrow</span><span class=\"bp\">.</span><span class=\"n\">preEquivalence</span><span class=\"bp\">.</span><span class=\"n\">functor_map_right_down_down</span>\n<span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">CostructuredArrow</span><span class=\"bp\">.</span><span class=\"n\">preEquivalence</span><span class=\"bp\">.</span><span class=\"n\">inverse_map_right_down_down</span>\n<span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">CostructuredArrow</span><span class=\"bp\">.</span><span class=\"n\">preEquivalence</span><span class=\"bp\">.</span><span class=\"n\">inverse_obj_hom_right_down_down</span>\n<span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">CostructuredArrow</span><span class=\"bp\">.</span><span class=\"n\">preEquivalence</span><span class=\"bp\">.</span><span class=\"n\">inverse_map_left_right_down_down</span>\n\n<span class=\"c1\">-- Mathlib.CategoryTheory.Comma.StructuredArrow.CommaMap</span>\n<span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">StructuredArrow</span><span class=\"bp\">.</span><span class=\"n\">commaMapEquivalenceUnitIso_inv_app_left_down_down</span>\n<span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">StructuredArrow</span><span class=\"bp\">.</span><span class=\"n\">commaMapEquivalenceUnitIso_hom_app_left_down_down</span>\n<span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">StructuredArrow</span><span class=\"bp\">.</span><span class=\"n\">commaMapEquivalenceCounitIso_hom_app_left_left_down_down</span>\n<span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">StructuredArrow</span><span class=\"bp\">.</span><span class=\"n\">commaMapEquivalenceCounitIso_inv_app_left_left_down_down</span>\n<span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">StructuredArrow</span><span class=\"bp\">.</span><span class=\"n\">commaMapEquivalenceCounitIso_hom_app_right_left_down_down</span>\n<span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">StructuredArrow</span><span class=\"bp\">.</span><span class=\"n\">commaMapEquivalenceCounitIso_inv_app_right_left_down_down</span>\n\n<span class=\"c1\">-- Mathlib.CategoryTheory.PUnit</span>\n<span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">star_map_down_down</span>\n<span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">punitExt_inv_app_down_down</span>\n<span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">punitExt_hom_app_down_down</span>\n\n<span class=\"c1\">-- Mathlib.Topology.Sheaves.MayerVietoris</span>\n<span class=\"n\">Opens</span><span class=\"bp\">.</span><span class=\"n\">mayerVietorisSquare_f‚ÇÅ‚ÇÇ_down_down</span>\n<span class=\"n\">Opens</span><span class=\"bp\">.</span><span class=\"n\">mayerVietorisSquare_f‚ÇÇ‚ÇÑ_down_down</span>\n<span class=\"n\">Opens</span><span class=\"bp\">.</span><span class=\"n\">mayerVietorisSquare_f‚ÇÉ‚ÇÑ_down_down</span>\n<span class=\"n\">Opens</span><span class=\"bp\">.</span><span class=\"n\">mayerVietorisSquare_f‚ÇÅ‚ÇÉ_down_down</span>\n</code></pre></div>",
        "id": 498341925,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1738935267
    },
    {
        "content": "<p>Is there an easy fix in <code>simps!</code>?</p>",
        "id": 498342822,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1738935549
    },
    {
        "content": "<p>The underlying issue is that the <code>PLift.down</code> field is universe polymorphic, so it can be a proposition or a type, so when <code>simps</code> checks if this is a proposition, it gets a negative result. So this can be fixed by either using a non-universe polymorphic version of <code>PLift</code>, or fixing <code>simps</code>. In <a href=\"https://github.com/leanprover-community/mathlib4/pull/21578\">#21578</a>, I've added another <code>isProof</code> check at the point in <code>simps</code> where the universe levels get instantiated. This solves the problem.</p>",
        "id": 498526859,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1739041401
    },
    {
        "content": "<p>Another bad simp lemma was added in core recently: <code>Std.ReflCmp.compare_self</code>, which has a metavariable as the head (so it is tried everywhere). I hope this one doesn't make it to the next release :)<br>\n<a href=\"https://github.com/leanprover/lean4/pull/7218\">lean4#7218</a></p>",
        "id": 501672423,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1740439482
    },
    {
        "content": "<p>Another bad simp lemma has appeared: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Option.elim_none_some#doc\">docs#Option.elim_none_some</a> applies on every lambda.</p>",
        "id": 505881050,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1742069172
    },
    {
        "content": "<p>That's because <code>Option.elim</code> should take its <code>Option</code> argument last</p>",
        "id": 505881266,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1742069366
    },
    {
        "content": "<p>Right, or it has to be stated as</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">‚àò</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>",
        "id": 505881501,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1742069532
    },
    {
        "content": "<p>There is <code>Option.elim'</code> which has the argument order you suggest. Did you want to remove the current <code>Option.elim</code> altogether?</p>",
        "id": 505887792,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1742074628
    },
    {
        "content": "<p>Oh and <code>Option.casesOn'</code> is a copy of <code>Option.elim</code>, and they have different simp lemmas. Surely that can't be a good state of affairs?</p>",
        "id": 505888231,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1742074996
    },
    {
        "content": "<p>Yes, <span class=\"user-mention\" data-user-id=\"387244\">@Ya√´l Dillies</span> suggests we remove <code>Option.elim</code> and replace it with <code>Option.elim'</code>, see discussions in <a href=\"https://github.com/leanprover-community/mathlib4/pull/15448\">#15448</a> and <a href=\"https://github.com/leanprover/lean4/pull/5096\">lean4#5096</a></p>",
        "id": 505894620,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1742080418
    },
    {
        "content": "<p>Nice, but that will not be solved soon, so what do we do with the lemma, unsimp it, change the definition to avoid the lambda, or change it to <code>Option.elim'</code>?</p>",
        "id": 505895721,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1742081376
    },
    {
        "content": "<p>I suggest that for now we leave 2 versions of the lemma:</p>\n<ul>\n<li>fully applied with <code>Option.elim</code></li>\n<li>partially applied with <code>Option.elim'</code>.</li>\n</ul>",
        "id": 505896465,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1742082027
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/22985\">#22985</a></p>",
        "id": 505972782,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1742142876
    }
]