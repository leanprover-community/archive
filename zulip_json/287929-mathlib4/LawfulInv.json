[
    {
        "content": "<p>In <a href=\"https://github.com/leanprover-community/mathlib4/pull/33441\">#33441</a> <span class=\"user-mention\" data-user-id=\"311453\">@Fr√©d√©ric Dupuis</span> is introducing a <code>LawfulInv</code> class for monoids with zero which satisfies <code>a‚Åª¬π</code> is the actual inverse when <code>a</code> is a unit, and <code>a‚Åª¬π = 0</code> for all nonunits. In this way it behaves like <code>Ring.inverse</code> and the <code>Inv</code> instance on matrices. The point is to add this class as a requirement for C‚ãÜ-algebras so that we can talk about <code>a‚Åª¬π</code> freely.</p>\n<p>One question is: would the community be okay if we just added an <code>Inv</code> field to <code>MonoidWithZero</code>? Overall, I think this would provide a nice usability boost to inverses in rings (there's a reason we've taken this approach with <code>Matrix</code> after all). However, it would have some perhaps surprising consequences, such that endowing <code>‚Ñï</code> and <code>‚Ñ§</code> with <code>‚Åª¬π</code>.</p>\n<p>I'll note that even making <code>LawfulInv</code> a requirement for <code>CStarAlgebra</code> would mean that <code>C(X, ‚ÑÇ)</code> would have an <code>Inv</code> instance for <code>X</code> a compact space, but not otherwise, unless we put one on explicitly. Optionally, we could scope the <code>CStarAlgebra</code> instance of that type to the <code>CStarAlgebra</code> namespace which would avoid this.</p>",
        "id": 569123171,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1768941441
    },
    {
        "content": "<p>My memory was that the only objection raised to this when we had a discussion about it a few years ago was \"what if we want the inverse of a noninvertible matrix to be a best approximation to an inverse\" but it looks like that we've decided not to do that. You raise the issue of inversion on Nat and Int and my take on this is that (a) your proposal gives the correct answer on those types and (b) in the past I've been surprised that Inv is <em>not</em> defined for Nat and Int. Is there anyone who is objecting to this idea? It sounds pretty natural to me given our current conventions.</p>",
        "id": 569123798,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1768941679
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/channel/287929-mathlib4/topic/LawfulInv/near/569123171\">said</a>:</p>\n<blockquote>\n<p>One question is: would the community be okay if we just added an <code>Inv</code> field to <code>MonoidWithZero</code>?</p>\n</blockquote>\n<p>What sort of conditions are you suggesting to put on the <code>Inv</code> in this case? I'm worried that it won't be satisfied by <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Prod.instInv#doc\">docs#Prod.instInv</a> for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Prod.instMonoidWithZero#doc\">docs#Prod.instMonoidWithZero</a>.</p>",
        "id": 569123898,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1768941714
    },
    {
        "content": "<p>oof, Aaron is correct, it is indeed not satisfied there. (Aaron, to explicitly answer your question: the same condition as <code>LawfulInv</code> mentioned in the post)</p>",
        "id": 569124191,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1768941805
    },
    {
        "content": "<p>That example would then just be an awful Inv rather than a lawful Inv.</p>",
        "id": 569124379,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1768941881
    },
    {
        "content": "<p>same for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Pi.instInv#doc\">docs#Pi.instInv</a>, unsurprisingly.</p>",
        "id": 569124511,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1768941937
    },
    {
        "content": "<p>Lawful Inv is like some kind of connectivity statement. One would not expect it to be always true.</p>",
        "id": 569124653,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1768941986
    },
    {
        "content": "<p>Looks like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi><mo>√ó</mo><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\R\\times\\R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7722em;vertical-align:-0.0833em;\"></span><span class=\"mord mathbb\">R</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">√ó</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span> will already have an unlawful Inv in mathlib</p>",
        "id": 569124762,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1768942033
    },
    {
        "content": "<p>Sure, but if we add an <code>Inv</code> with arbitrary behavior on <code>MonoidWithZero</code>, then we break extensionality.</p>",
        "id": 569124772,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1768942036
    },
    {
        "content": "<p>Yeah, maybe the lawful approach is the best one. How come you're not seeing this phenomenon in C^* algebras? Is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"double-struck\">C</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span> a C^* algebra? What Inv do you want it to have? One which is not the one it has right now?</p>",
        "id": 569125115,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1768942172
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"311453\">@Fr√©d√©ric Dupuis</span> this actually throws a wrench in your <code>LawfulInv</code> for <code>CStarAlgebra</code> plan anyway, because you wouldn't be able to provide the instance:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œπ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œπ</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">Œπ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">CStarAlgebra</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CStarAlgebra</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">Œ†</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 569125129,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1768942178
    },
    {
        "content": "<p>Kevin, we just want to provide a junk value of <code>0</code> for non-invertible elements, that's all.</p>",
        "id": 569125194,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1768942203
    },
    {
        "content": "<p>Right but surely we already have a definition of Inv on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"double-struck\">C</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span> and it doesn't satisfy this?</p>",
        "id": 569125380,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1768942295
    },
    {
        "content": "<p>Right, that was Aaron's point.</p>",
        "id": 569125427,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1768942311
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ring.inverse#doc\">docs#Ring.inverse</a></p>",
        "id": 569125516,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1768942346
    },
    {
        "content": "<p>This is already defined for monoids with zero and presumably the reason it's there as well as Inv is precisely Aaron's observation. So why not just use <code>inverse</code>?</p>",
        "id": 569125753,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1768942455
    },
    {
        "content": "<p>This is what I've just suggested on the PR.</p>",
        "id": 569125792,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1768942480
    },
    {
        "content": "<p>I think the reason he wanted to avoid <code>Ring.inverse</code> is that there is currently rather limited API for it, and obviously it doesn't currently have any notation. I suggested adding some scoped notation and expanding the API.</p>",
        "id": 569126238,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1768942646
    },
    {
        "content": "<p>Wasn't there some weird <code>1/</code> notation for it at some point? Or was that something else?</p>",
        "id": 569129572,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1768943902
    },
    {
        "content": "<p>That's for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Invertible#doc\">docs#Invertible</a> (which is data carrying).</p>",
        "id": 569129878,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1768944040
    },
    {
        "content": "<p>Indeed this is a problem! I wonder how far we could get with only the condition that the inverse behaves well on invertible elements, i.e. imposing no particular condition on noninvertible ones.</p>",
        "id": 569155344,
        "sender_full_name": "Fr√©d√©ric Dupuis",
        "timestamp": 1768958678
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/channel/287929-mathlib4/topic/LawfulInv/near/569126238\">said</a>:</p>\n<blockquote>\n<p>I think the reason he wanted to avoid <code>Ring.inverse</code> is that there is currently rather limited API for it, and obviously it doesn't currently have any notation. I suggested adding some scoped notation and expanding the API.</p>\n</blockquote>\n<p>A smaller disadvantage is that it's noncomputable. It's currently quite silly that we can't <code>#eval</code> matrix inverses</p>",
        "id": 569155713,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1768958943
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"311453\">Fr√©d√©ric Dupuis</span> <a href=\"#narrow/channel/287929-mathlib4/topic/LawfulInv/near/569155344\">said</a>:</p>\n<blockquote>\n<p>Indeed this is a problem! I wonder how far we could get with only the condition that the inverse behaves well on invertible elements, i.e. imposing no particular condition on noninvertible ones.</p>\n</blockquote>\n<p>That breaks extensionality.</p>",
        "id": 569168703,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1768968991
    },
    {
        "content": "<p>What do you mean? Suppose we go with</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">LawfulInv</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M‚ÇÄ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MonoidWithZero</span><span class=\"w\"> </span><span class=\"n\">M‚ÇÄ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Inv</span><span class=\"w\"> </span><span class=\"n\">M‚ÇÄ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">inv_unit</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M‚ÇÄ</span><span class=\"bp\">À£</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M‚ÇÄ</span><span class=\"o\">)</span><span class=\"bp\">‚Åª¬π</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"bp\">‚Åª¬π</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M‚ÇÄ</span><span class=\"bp\">À£</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>(i.e. removing the condition that the inverse of noninvertible elements is zero.) We would have fewer lemmas that apply generically to <code>LawfulInv</code>, but I'm not sure what would break.</p>",
        "id": 569170423,
        "sender_full_name": "Fr√©d√©ric Dupuis",
        "timestamp": 1768970303
    },
    {
        "content": "<p>Ah, you're not making <code>MonoidWithZero</code> extend <code>Inv</code>, which is what I was talking about. If you did that, then you would lose extensionality for <code>MonoidWithZero</code>.</p>",
        "id": 569171422,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1768971133
    },
    {
        "content": "<p>I still think what you want is to develop API for <code>Ring.inverse</code>.</p>",
        "id": 569171521,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1768971211
    },
    {
        "content": "<p>What's the problem with <code>LawfulInv</code>? It seems to me like a smart idea if we want to reduce theorem duplication.</p>",
        "id": 569176456,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1768974616
    },
    {
        "content": "<p>I think <a href=\"#narrow/channel/287929-mathlib4/topic/LawfulInv/near/569125129\">this message</a> about the motivating instance not working is the problem?</p>",
        "id": 569179144,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1768976510
    },
    {
        "content": "<p>Ah, I see.</p>",
        "id": 569183041,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1768978815
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/channel/287929-mathlib4/topic/LawfulInv/near/569171521\">said</a>:</p>\n<blockquote>\n<p>I still think what you want is to develop API for <code>Ring.inverse</code>.</p>\n</blockquote>\n<p>If we go down that route, do you have any suggestions for the notation? Maybe something like <code>x‚Åª¬π ≥</code>?</p>",
        "id": 569888283,
        "sender_full_name": "Fr√©d√©ric Dupuis",
        "timestamp": 1769274580
    },
    {
        "content": "<p>If that parses correctly, That's reasonable.</p>",
        "id": 569908498,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1769294766
    },
    {
        "content": "<p>Is the reason we cannot use <code>x‚Åª¬π</code> that this clashes with the field notation? Is there no way to overload?</p>",
        "id": 569909646,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1769296086
    },
    {
        "content": "<p>Yes, even if we could somehow overload the notation, it would be very confusing.</p>",
        "id": 569909982,
        "sender_full_name": "Fr√©d√©ric Dupuis",
        "timestamp": 1769296538
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/channel/287929-mathlib4/topic/LawfulInv/near/569125129\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"311453\">Fr√©d√©ric Dupuis</span> this actually throws a wrench in your <code>LawfulInv</code> for <code>CStarAlgebra</code> plan anyway, because you wouldn't be able to provide the instance:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œπ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œπ</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">Œπ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">CStarAlgebra</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CStarAlgebra</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">Œ†</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I don't quite follow the conclusion here; does this actually mean that LawfulInv is useless?  It seems like it might still be a nice way to replace <code>Ring.inverse</code>.</p>",
        "id": 569910531,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1769297358
    },
    {
        "content": "<p>(what the conclusion does seem to be is that <code>Ring.inverse</code> would be exactly as useful for <code>CStarAlgebra</code> as the proposed <code>LawfulInv</code> would be)</p>",
        "id": 569910558,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1769297384
    },
    {
        "content": "<p>The issue is that if we consider <code>A √ó B</code> where <code>A</code> and <code>B</code> are both C*-algebras with an inverse, the <code>Inv</code> that we get on <code>A √ó B</code> is different from <code>Ring.inverse</code>.</p>",
        "id": 569911150,
        "sender_full_name": "Fr√©d√©ric Dupuis",
        "timestamp": 1769298247
    },
    {
        "content": "<p>So either we just work with <code>Ring.inverse</code>, or else we change the definition of <code>LawfulInv</code> as above to leave the junk value on non-invertible elements unspecified.</p>",
        "id": 569911216,
        "sender_full_name": "Fr√©d√©ric Dupuis",
        "timestamp": 1769298327
    },
    {
        "content": "<p>Ah ok, it's that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Prod.instInv#doc\">docs#Prod.instInv</a> (which I assume is the inverse you want for C* algebras) doesn't satisfy LawfulInv in any reasonable setting</p>",
        "id": 569913735,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1769301815
    },
    {
        "content": "<p>I think it's the inverse they're stuck with rather than the one they were hoping to have!</p>",
        "id": 569913828,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1769301948
    },
    {
        "content": "<p>If we go with the <code>x‚Åª¬π ≥ </code> notation, here's what it looks like: <a href=\"https://github.com/leanprover-community/mathlib4/pull/34396\">#34396</a></p>",
        "id": 569926912,
        "sender_full_name": "Fr√©d√©ric Dupuis",
        "timestamp": 1769316587
    },
    {
        "content": "<p>We should add a note to the docstring about why <code>Ring.inverse</code> can't become axiomatized into the definition of <code>MonoidWithZero</code>.</p>",
        "id": 570000897,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1769394850
    },
    {
        "content": "<p>Also, should we scope that notation? I think it's exotic enough not to step on any toes if we leave it global, but scoping is definitely an option.</p>",
        "id": 570108390,
        "sender_full_name": "Fr√©d√©ric Dupuis",
        "timestamp": 1769438215
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/LawfulInv/near/569913828\">said</a>:</p>\n<blockquote>\n<p>I think it's the inverse they're stuck with rather than the one they were hoping to have!</p>\n</blockquote>\n<p>So to be clear, we have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Prod.instInv#doc\">docs#Prod.instInv</a> with <code>(x,0)‚Åª¬π = (x‚Åª¬π, 0)</code>, while <code>Ring.inverse (x,0) = 0</code>.@<strong>Fr√©d√©ric Dupuis</strong>, do you actually care which of these  junk values are used for C-star algebras? If you don't, perhaps we should pursue <code>LawfulInv</code> as a partial characterization, which means we can still keep it as an instance for <code>Prod</code></p>",
        "id": 570156691,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1769450330
    },
    {
        "content": "<p>I'm not sure how useful <code>LawfulInv</code> would be without the specification on nonunits, which would mean that it wouldn't apply to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Prod.instInv#doc\">docs#Prod.instInv</a> anyway. In any case, I believe its clear that it would be hard / impossible to add <code>Inv</code> (in any flavor) to the <code>extends</code> list for <code>CStarAlgebra</code>, and even if someone wanted to, I would push back pretty hard at this point.</p>",
        "id": 570178887,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1769457929
    },
    {
        "content": "<p>Why do we care how the inverse behaves on non-units?</p>",
        "id": 570187277,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1769460709
    },
    {
        "content": "<p>convenience</p>",
        "id": 570196285,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1769464830
    },
    {
        "content": "<p>I'm not declaring <code>LawfulInv</code> to be totally useless without the nonunits specification, but only that it has more limited value.</p>",
        "id": 570196523,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1769464923
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"311453\">Fr√©d√©ric Dupuis</span> <a href=\"#narrow/channel/287929-mathlib4/topic/LawfulInv/near/570108390\">said</a>:</p>\n<blockquote>\n<p>Also, should we scope that notation? I think it's exotic enough not to step on any toes if we leave it global, but scoping is definitely an option.</p>\n</blockquote>\n<p>In general I'm in favor of scoping anything that isn't both completely standard and very common. For perspective, we even scope <code>ùìù</code> and <code>ùìü</code> to <code>Topology</code> and <code>Filter</code>.</p>\n<p>Probably no one else wants <code>‚Åª¬π ≥</code> to mean anything, but I think we can be good stewards by scoping it. The biggest price we pay for now is that it still shows up as <code>Ring.inverse</code> in the docs, which is annoying. But that's really a docgen / Lean issue that needs sorting out.</p>",
        "id": 570196970,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1769465103
    }
]