[
    {
        "content": "<p>I just got tripped by this, so I was wondering if there was a reason why <code>CategoryTheory.uliftFunctor.{u,v}</code> is a functor <code>Type v тед Type (max v u)</code> while <code>Grp.uliftFunctor.{u,v}</code> is a functor <code>Grp.{u} тед Grp.{max u v}</code>?<br>\n(I want to prove that <code>Grp.uliftFunctor</code> and its variant for <code>CommGrp</code> preserve/reflect limits (depending on the size of the indexing category), and for this I want to go through the Yoneda functor, but I need the fact that Yoneda \"commutes\" with <code>uliftFunctor</code>, and that's when the difference in the order of <code>u</code> and <code>v</code> surprised me.)</p>",
        "id": 488879163,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1734107754
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.ULiftFunctor#doc\">docs#CategoryTheory.ULiftFunctor</a></p>",
        "id": 488890931,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1734111813
    },
    {
        "content": "<p>The one for <code>Grp</code> should be changed.</p>",
        "id": 488891109,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1734111859
    },
    {
        "content": "<p>It's really a practical thing. If <code>X : Type u</code> then it's nice to be able to write <code>ULift.{v} X</code> to get something in <code>Type (max v u)</code> instead of <code>ULift.{_, v} X</code>.</p>",
        "id": 488891292,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1734111918
    },
    {
        "content": "<p>So in the categorical case, we want to be able to write <code>uliftFunctor.{v} : Type u -&gt; Type (max v u)</code> instead of having to add three underscores in some confusing order.</p>",
        "id": 488891541,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1734111995
    },
    {
        "content": "<p>We put the universe levels of the morphisms in a category first for a similar reason. If <code>C : Type u</code> then it's nice to be able to write <code>Category.{v} C</code> to get a category structure whose morphisms are in universe <code>v</code>, instead of having to write <code>Category.{_, v} C</code></p>",
        "id": 488891732,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1734112063
    },
    {
        "content": "<p>I see, the convention for <code>Type</code> makes a lot of sense. (I'm nervous and tend to write the full <code>{v,u}</code> in both cases you mention, but I see that it is not actually necessary.)</p>",
        "id": 488892704,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1734112401
    },
    {
        "content": "<p>So you wouldn't object if I went and changed the convention for <code>Grp</code> then? (And <code>CommGrp</code> and I don't know what else. I suppose there are <code>uliftFunctor</code>s for the other common concrete categories.)</p>",
        "id": 488892875,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1734112457
    },
    {
        "content": "<p>(Or maybe not, I tried to find the <code>RingCat</code> and <code>CommRingCat</code> functors and didn't. Oh well.)</p>",
        "id": 488893217,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1734112581
    },
    {
        "content": "<p>Yes, I think that for all of the algebraic categories (<code>GrpCat</code>, <code>RingCat</code>, etc.) the universe order should be as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universe</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">u</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">FooCat.uliftFunctor</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FooCat</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"n\">func</span><span class=\"w\"> </span><span class=\"n\">FooCat</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>There are some categories where the type of objects itself can involve more than one universe (like <code>ModuleCat</code>) and in those cases the order may be a bit more subtle.</p>",
        "id": 488893429,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1734112664
    },
    {
        "content": "<p>When I have a minute, I'll PR the change for <code>Grp</code> and <code>CommGrp</code>, but i can't find <code>uliftFunctor</code>s for the other algebraic categories, and I'm not sure I want to start adding them.</p>",
        "id": 488893896,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1734112819
    },
    {
        "content": "<p>(I am much more interested in proving properties of the ones we do have, like the fact that they commute with (co)limits.)</p>",
        "id": 488894035,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1734112864
    },
    {
        "content": "<p>I found four <code>uliftFunctor</code>s, for types, groups, monoids and simplicial sets. The ones for types and simplicial sets follow the convention that <code>uliftFunctor.{u,v}</code> goes from universe <code>v</code> to universe <code>max v u</code>, the ones for group and monoid categories follow the convention that <code>uliftFunctor.{u,v}</code> goes from universe <code>u</code> to universe <code>max u v</code>. Just opened a PR to harmonize this so everybody follows the first convention.</p>",
        "id": 488988216,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1734177820
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"318709\">@Sophie Morel</span> Thanks! What is the PR number? (If you write <a href=\"https://github.com/leanprover-community/mathlib4/pull/98765\">#98765</a>, then zulip will turn it into a link.)</p>",
        "id": 488988337,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1734177920
    },
    {
        "content": "<p>And now I need to put out a few fires as this clashes with other mathlib files... It should not take too long, I hope.</p>",
        "id": 488988341,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1734177922
    },
    {
        "content": "<p>Ah yes, sorry forgot the number: <a href=\"https://github.com/leanprover-community/mathlib4/pull/19957\">#19957</a><br>\nLet me just make sure it builds first.</p>",
        "id": 488988406,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1734177970
    },
    {
        "content": "<p>CI gave you a <span aria-label=\"check\" class=\"emoji emoji-2705\" role=\"img\" title=\"check\">:check:</span> already</p>",
        "id": 488988426,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1734178003
    },
    {
        "content": "<p>It all looks good to me. So I'm happy to merge this.</p>",
        "id": 488988430,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1734178012
    },
    {
        "content": "<p>Yes, I just realized that I confused it with my current WIP which, of course, doesn't build. (I was very confused because the line where the mistake was supposed to be didn't exist in my branch of mathlib. <span aria-label=\"man facepalming\" class=\"emoji emoji-1f926-200d-2642\" role=\"img\" title=\"man facepalming\">:man_facepalming:</span> )</p>",
        "id": 488988614,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1734178165
    },
    {
        "content": "<p>Borsified</p>",
        "id": 488988791,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1734178267
    },
    {
        "content": "<p>Commutation with limits was easy: <a href=\"https://github.com/leanprover-community/mathlib4/pull/19968\">#19968</a><br>\n(Once you prove that the forgetful functor on the category of groups reflects limits: <a href=\"https://github.com/leanprover-community/mathlib4/pull/19965\">#19965</a> and <a href=\"https://github.com/leanprover-community/mathlib4/pull/19966\">#19966</a>. It actually creates them.)</p>\n<p>Colimits will probably take more effort, as usual with algebraic categories.</p>",
        "id": 489027983,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1734211818
    },
    {
        "content": "<ul>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/19965\">#19965</a> <img alt=\":bors:\" class=\"emoji\" src=\"https://avatars.zulip.com/3121/emoji/images/dce2c3bb.png\" title=\"bors\"></li>\n</ul>",
        "id": 489176424,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1734338337
    },
    {
        "content": "<ul>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/19966\">#19966</a></li>\n</ul>",
        "id": 489176444,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1734338344
    },
    {
        "content": "<ul>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/19968\">#19968</a></li>\n</ul>",
        "id": 489176462,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1734338349
    },
    {
        "content": "<p>(For the sake of the bot posting emojis on zulip messages.)</p>",
        "id": 489176506,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1734338363
    },
    {
        "content": "<p>That didn't work :)</p>",
        "id": 489176964,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1734338498
    }
]