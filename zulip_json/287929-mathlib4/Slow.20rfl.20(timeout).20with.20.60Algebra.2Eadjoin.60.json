[
    {
        "content": "<p>I think it's connected to an earlier <a href=\"#narrow/channel/287929-mathlib4/topic/kernel.20hangs.20on.20a.20proof/near/479499783\">slow rfl question</a>, but here even destructing the subtype doesn't work outright, I had to insert a <code>show</code> too.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">RingTheory</span><span class=\"bp\">.</span><span class=\"n\">Adjoin</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommSemiring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommSemiring</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommSemiring</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsScalarTower</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Algebra</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">quotPrecheck</span><span class=\"w\"> </span><span class=\"n\">false</span>\n<span class=\"kn\">local</span><span class=\"w\"> </span><span class=\"kn\">notation</span><span class=\"w\"> </span><span class=\"s2\">\"Rs\"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">adjoin</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">s</span>\n<span class=\"kn\">local</span><span class=\"w\"> </span><span class=\"kn\">notation</span><span class=\"w\"> </span><span class=\"s2\">\"As\"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">adjoin</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">restrictScalars</span><span class=\"w\"> </span><span class=\"n\">R</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">Rs</span><span class=\"w\"> </span><span class=\"n\">As</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">Subalgebra</span><span class=\"bp\">.</span><span class=\"n\">inclusion</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">adjoin_le</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">subset_adjoin</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toAlgebra</span>\n\n<span class=\"c1\">-- slow (timeout)</span>\n<span class=\"c1\">-- instance : IsScalarTower Rs As B := .of_algebraMap_eq fun _ ↦ rfl</span>\n<span class=\"c1\">-- instance : IsScalarTower Rs As B := .of_algebraMap_eq fun ⟨_, _⟩ ↦ rfl</span>\n<span class=\"c1\">-- instance : IsScalarTower Rs As B := .of_algebraMap_eq fun x ↦ show x.1 = x.1 from rfl</span>\n\n<span class=\"c1\">-- fast</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsScalarTower</span><span class=\"w\"> </span><span class=\"n\">Rs</span><span class=\"w\"> </span><span class=\"n\">As</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">of_algebraMap_eq</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_⟩</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">from</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 485429951,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1733010261
    },
    {
        "content": "<p>When you say \"slow\" do you actually mean \"slow\" or do you mean \"always times out\"? I've never got a \"slow\" one to terminate (which makes debugging much harder)</p>",
        "id": 485430123,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1733010469
    },
    {
        "content": "<p>Yeah, I edited to say \"timeout\"</p>",
        "id": 485430192,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1733010509
    },
    {
        "content": "<p>Definitely feels like kernel entering infinite loop</p>",
        "id": 485430213,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1733010553
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsScalarTower</span><span class=\"w\"> </span><span class=\"n\">Rs</span><span class=\"w\"> </span><span class=\"n\">As</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">of_algebraMap_eq</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rcases</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"n\">change</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"c1\">-- comment out one and you're still fine</span>\n<span class=\"w\">  </span><span class=\"n\">change</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"c1\">-- comment out both and you're dead</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 485430299,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1733010644
    },
    {
        "content": "<p>Good observation. Indeed both <code>show _ = x</code> and <code>show x = _</code> work.</p>",
        "id": 485430344,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1733010719
    },
    {
        "content": "<p>I'm not sure my observation helps. Here's what might be happening: maybe if both are commented out then <code>rfl</code> says \"OK so this is <code>algebraMap something something = algebraMap something something</code> so let's see if I can equate the somethings\" and now it might be in big trouble. But changing either of them to <code>a</code> makes it stop doing this.</p>",
        "id": 485430404,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1733010773
    },
    {
        "content": "<p>That can't quite explain why</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsScalarTower</span><span class=\"w\"> </span><span class=\"n\">Rs</span><span class=\"w\"> </span><span class=\"n\">As</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">of_algebraMap_eq</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"k\">from</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>doesn't work. So maybe the need of <code>show</code> is a new issue (due to Lean trying to equate the somethings), and the need to destruct the subtype is <a href=\"#narrow/channel/287929-mathlib4/topic/kernel.20hangs.20on.20a.20proof/near/479499783\">the old issue</a>? (A difference with the old issue is that there we're checking equality in a subtype, but here we're not.)</p>",
        "id": 485430644,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1733011035
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">↥</span><span class=\"n\">Rs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">Subalgebra</span><span class=\"bp\">.</span><span class=\"n\">restrictScalars</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">adjoin</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"c1\">-- fails quickly</span>\n</code></pre></div>\n<p>so I can't find evidence for my guess above.</p>",
        "id": 485430830,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1733011204
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">maxHeartbeats</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"c1\">-- slow (timeout)</span>\n<span class=\"c1\">-- instance : IsScalarTower Rs As B := .of_algebraMap_eq fun _ ↦ rfl</span>\n<span class=\"c1\">-- instance : IsScalarTower Rs As B := .of_algebraMap_eq fun ⟨_, _⟩ ↦ rfl</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsScalarTower</span><span class=\"w\"> </span><span class=\"n\">Rs</span><span class=\"w\"> </span><span class=\"n\">As</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">of_algebraMap_eq</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rcases</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"n\">congr</span>\n<span class=\"w\">  </span><span class=\"c1\">-- 15 goals (after a very long pause)</span>\n</code></pre></div>\n<p>I would imagine that <code>rfl</code> is going down this path before you tell it that it's just <code>a = a</code>. Examples of goals:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Rs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Subalgebra</span><span class=\"bp\">.</span><span class=\"n\">restrictScalars</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">adjoin</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">Rs</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Subalgebra</span><span class=\"bp\">.</span><span class=\"n\">restrictScalars</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">adjoin</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">HEq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">B</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">HEq</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"bp\">⋯</span>\n</code></pre></div>\n<p>In fact that's all the goals, the first one shows up 9 times and the second one shows up 4 times. The algorithm gets it wrong and never recovers.</p>",
        "id": 485431208,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1733011489
    },
    {
        "content": "<p><code>congr</code> might create <code>HEq</code> goals, but might <code>rfl</code>? <code>rfl</code> would first check the types are defeq, right?</p>",
        "id": 485431898,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1733012270
    },
    {
        "content": "<p>I'm afraid I have absolutely no idea what the <code>rfl</code> tactic does under the hood</p>",
        "id": 485432798,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1733013182
    },
    {
        "content": "<p>In my original post there's no use of the <code>rfl</code> tactic, only the <code>rfl</code> term. (Is <code>show</code> a tactic? Or just a hint to the kernel?)</p>",
        "id": 485432912,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1733013315
    },
    {
        "content": "<p>Oh I thought one should prefer the tactic to the term</p>",
        "id": 485434658,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1733015193
    },
    {
        "content": "<p>So I see the message \"(kernel) deterministic timeout\" on the <code>show</code>-less instances. A kernel timeout means that the elaborator already accepted your definition but the kernel is taking too long to check. The elaborator and the kernel both have an algorithm for checking definitional equalities, and the one in the elaborator has quite a few more features and options. For example, only the elaborator cares about reducibility settings, the kernel will just unfold everything.</p>\n<p>Unfortunately, the kernel does not do any tracing for equality checking, so unless you fire up a debugger with a breakpoint on <a href=\"https://github.com/leanprover/lean4/blob/master/src/kernel/type_checker.cpp#L1068\"><code>is_def_eq_core</code></a> we'll have to do with guessing.</p>",
        "id": 485581965,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1733132472
    },
    {
        "content": "<p>Thanks! What difference does <code>show</code> make? Does it break one equality into two or three equalities for the kernel to check?</p>",
        "id": 485583889,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1733133090
    },
    {
        "content": "<p>We can follow along what happens in the <em>elaborator</em> if we <code>set_option trace.Meta.isDefEq true</code>, and try to see if the kernel will do the same.</p>\n<p>What happens when we have a goal of</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">algebraMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">↥</span><span class=\"n\">Rs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">algebraMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">Subalgebra</span><span class=\"bp\">.</span><span class=\"n\">restrictScalars</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">adjoin</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"o\">((</span><span class=\"n\">algebraMap</span><span class=\"w\"> </span><span class=\"bp\">↥</span><span class=\"n\">Rs</span><span class=\"w\"> </span><span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">Subalgebra</span><span class=\"bp\">.</span><span class=\"n\">restrictScalars</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">adjoin</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>that gets solved by <code>rfl</code> (whether term or tactic) is that the elaborator will check that this term has the expected type. Which is basically just defeq checking</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">algebraMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">↥</span><span class=\"n\">Rs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">algebraMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">Subalgebra</span><span class=\"bp\">.</span><span class=\"n\">restrictScalars</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">adjoin</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"o\">((</span><span class=\"n\">algebraMap</span><span class=\"w\"> </span><span class=\"bp\">↥</span><span class=\"n\">Rs</span><span class=\"w\"> </span><span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">Subalgebra</span><span class=\"bp\">.</span><span class=\"n\">restrictScalars</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">adjoin</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"bp\">=?=</span>\n<span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">55479</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">55479</span>\n</code></pre></div>\n<p>Since <code>=</code> is an inductive type, the only solution is that the LHS equals the other LHS and the RHS equals the other RHS (this is done in the kernel by <code>is_def_eq_app</code>). Assigning <code>?m.55479</code> as <code>(algebraMap (↥Rs) B) x</code> solves the LHS, so the RHS now looks like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">((</span><span class=\"n\">algebraMap</span><span class=\"w\"> </span><span class=\"bp\">↥</span><span class=\"n\">Rs</span><span class=\"w\"> </span><span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">Subalgebra</span><span class=\"bp\">.</span><span class=\"n\">restrictScalars</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">adjoin</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">✝</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=?=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">algebraMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">↥</span><span class=\"n\">Rs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">✝</span>\n</code></pre></div>\n<p>What's interesting is that the elaborator now starts unfolding the function applications:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">(</span><span class=\"bp\">↑↑</span><span class=\"o\">(</span><span class=\"n\">algebraMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">↥</span><span class=\"n\">Rs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">✝</span>\n<span class=\"bp\">=?=</span>\n<span class=\"o\">(</span><span class=\"bp\">↑↑</span><span class=\"o\">(</span><span class=\"n\">algebraMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">Subalgebra</span><span class=\"bp\">.</span><span class=\"n\">restrictScalars</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">adjoin</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">toFun</span>\n<span class=\"w\">      </span><span class=\"o\">((</span><span class=\"n\">algebraMap</span><span class=\"w\"> </span><span class=\"bp\">↥</span><span class=\"n\">Rs</span><span class=\"w\"> </span><span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">Subalgebra</span><span class=\"bp\">.</span><span class=\"n\">restrictScalars</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">adjoin</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">✝</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>The kernel does its unfolding during defeq checks in <code>lazy_delta_reduction_step</code>, which gets called before trying to match up functions and arguments one by one. So this should still work the same between elaborator and kernel I think?</p>\n<p>With a bit of unfolding the elaborator gets to:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">algebraMap</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"o\">((</span><span class=\"n\">Subalgebra</span><span class=\"bp\">.</span><span class=\"n\">restrictScalars</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">adjoin</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">subtype</span>\n<span class=\"w\">        </span><span class=\"o\">((</span><span class=\"n\">algebraMap</span><span class=\"w\"> </span><span class=\"bp\">↥</span><span class=\"n\">Rs</span><span class=\"w\"> </span><span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">Subalgebra</span><span class=\"bp\">.</span><span class=\"n\">restrictScalars</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">adjoin</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">✝</span><span class=\"o\">))</span>\n<span class=\"bp\">=?=</span>\n<span class=\"o\">(</span><span class=\"n\">algebraMap</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Rs</span><span class=\"bp\">.</span><span class=\"n\">subtype</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">✝</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>which becomes</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">Subalgebra</span><span class=\"bp\">.</span><span class=\"n\">restrictScalars</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">adjoin</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">subtype</span>\n<span class=\"w\">      </span><span class=\"o\">((</span><span class=\"n\">algebraMap</span><span class=\"w\"> </span><span class=\"bp\">↥</span><span class=\"n\">Rs</span><span class=\"w\"> </span><span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">Subalgebra</span><span class=\"bp\">.</span><span class=\"n\">restrictScalars</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">adjoin</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">✝</span><span class=\"o\">)</span>\n<span class=\"bp\">=?=</span>\n<span class=\"n\">Rs</span><span class=\"bp\">.</span><span class=\"n\">subtype</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">✝</span>\n</code></pre></div>\n<p>and then</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">↑</span><span class=\"o\">((</span><span class=\"n\">algebraMap</span><span class=\"w\"> </span><span class=\"bp\">↥</span><span class=\"n\">Rs</span><span class=\"w\"> </span><span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">Subalgebra</span><span class=\"bp\">.</span><span class=\"n\">restrictScalars</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">adjoin</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">✝</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=?=</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">x</span><span class=\"bp\">✝</span>\n</code></pre></div>\n<p>Now here something interesting happens: the up arrow is a structure projection, and there the elaborator does decide to first try unifying the structures being projected:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">((</span><span class=\"n\">algebraMap</span><span class=\"w\"> </span><span class=\"bp\">↥</span><span class=\"n\">Rs</span><span class=\"w\"> </span><span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">Subalgebra</span><span class=\"bp\">.</span><span class=\"n\">restrictScalars</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">adjoin</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">✝</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">=?=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">✝.</span><span class=\"m\">1</span>\n</code></pre></div>\n<p>becomes</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">⟨↑</span><span class=\"n\">x</span><span class=\"bp\">✝</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">⋯⟩</span><span class=\"w\"> </span><span class=\"bp\">=?=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">✝</span>\n</code></pre></div>\n<p>and this actually <em>fails</em> on the check <code>{ x // x ∈ ↑(Subalgebra.restrictScalars R (adjoin A s)) } =?= ↥Rs</code>.</p>\n<p>So instead the elaborator unfolds the LHS one final time getting <code>↑x✝ =?= x✝.1</code> which finally succeeds.</p>",
        "id": 485588038,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1733134451
    },
    {
        "content": "<p>Although looking at the definition of <code>Rs</code>, I'm not sure why it is <em>not</em> equal to <code>(Subalgebra.restrictScalars R (adjoin A s))</code>...</p>",
        "id": 485588501,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1733134584
    },
    {
        "content": "<p>Ah nevermind, I was looking at the definition of <code>As</code> instead of <code>Rs</code>. It makes perfect sense again!</p>",
        "id": 485588845,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1733134693
    },
    {
        "content": "<p>There are some ways to get definitions kernel checked without the elaborator failing, so maybe we could try to see if the kernel also times out on <code>example : As = Rs := rfl</code>. But that's probably a project for another time.</p>",
        "id": 485589335,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1733134850
    },
    {
        "content": "<p>(Just a side note: the <code>rfl</code> tactic essentially tries <code>exact rfl</code> on equalities, and searches for a <code>@[refl]</code>-tagged proof for other relations. <code>rfl</code> and <code>by rfl</code> should not behave differently except if some weird goal order issues come up.)</p>",
        "id": 485589918,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1733135037
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Slow.20rfl.20.28timeout.29.20with.20.60Algebra.2Eadjoin.60/near/485432912\">said</a>:</p>\n<blockquote>\n<p>In my original post there's no use of the <code>rfl</code> tactic, only the <code>rfl</code> term. (Is <code>show</code> a tactic? Or just a hint to the kernel?)</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Slow.20rfl.20.28timeout.29.20with.20.60Algebra.2Eadjoin.60/near/485583889\">said</a>:</p>\n<blockquote>\n<p>Thanks! What difference does <code>show</code> make? Does it break one equality into two or three equalities for the kernel to check?</p>\n</blockquote>\n<p>Let's first try to explain the difference between <code>(rfl : x = x)</code> and <code>show x = x from rfl</code>. <code>(rfl : x = x)</code> is a hint to the elaborator to first typecheck that <code>rfl</code> has type <code>x = x</code>, and then to unify the hinted type with the goal type:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"bp\">=?=</span>\n<span class=\"o\">(</span><span class=\"n\">algebraMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">↥</span><span class=\"n\">Rs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">property</span><span class=\"bp\">✝⟩</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">algebraMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">Subalgebra</span><span class=\"bp\">.</span><span class=\"n\">restrictScalars</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">adjoin</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span>\n<span class=\"w\">        </span><span class=\"o\">((</span><span class=\"n\">algebraMap</span><span class=\"w\"> </span><span class=\"bp\">↥</span><span class=\"n\">Rs</span><span class=\"w\"> </span><span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">Subalgebra</span><span class=\"bp\">.</span><span class=\"n\">restrictScalars</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">adjoin</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">property</span><span class=\"bp\">✝⟩</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>So essentially this does the same as explicitly writing out <code>@rfl _ x</code>. The kernel will see that <code>@rfl _ x</code> and should therefore perform basically the same defeq check as above. And indeed,</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsScalarTower</span><span class=\"w\"> </span><span class=\"n\">Rs</span><span class=\"w\"> </span><span class=\"n\">As</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">of_algebraMap_eq</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_⟩</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsScalarTower</span><span class=\"w\"> </span><span class=\"n\">Rs</span><span class=\"w\"> </span><span class=\"n\">As</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">of_algebraMap_eq</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_⟩</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>\n<p>do not time out in the kernel!</p>\n<p>What <code>show x = x from rfl</code> does is defined in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Elab.Term.elabShow#doc\">docs#Lean.Elab.Term.elabShow</a>: it comes down to inserting a term <code>let this : x = x := rfl; this</code>. This whole term is passed to the kernel which will end up checking that <code>this : x = x</code> has the expected type and so we get essentially the same unification goal again.</p>\n<p>Crucially, <code>show</code> explicitly shows up in the term passed to the kernel, while the type ascription <code>(rfl : x = x)</code> just so happens to set up the implicit variables correctly. This is why <code>show</code> is sometimes more powerful than type ascription: it keeps the expected type around explicitly.</p>",
        "id": 485592797,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1733135850
    }
]