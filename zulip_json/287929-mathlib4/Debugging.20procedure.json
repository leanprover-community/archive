[
    {
        "content": "<p>As discussed last week, I found a really tricky lemma to port in the sphere eversion project. This is probably due to some not-so-nice instance, and I can prove the lemma. But I spend a lot of time on it and I still don't really understand the issue. My question is not really about this specific issue, it's about the debugging procedure. I'll paste the code below. This code works but it has two places that involve suffering. One is a <code>rw</code> that should be a <code>simp only</code>, and the other one is a <code>rw</code> that doesn't work but <code>erw</code> works (and of course <code>simp only</code> doesn't work). In Lean 3 the whole proof was a single <code>simp only</code> call. The question is: how do you debug this? In particular how can you get access to the part of the lemma that is not syntactically matching the goal, necessitating the <code>erw</code>?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c\">/-</span>\n<span class=\"cm\">Copyright (c) 2022 Heather Macbeth. All rights reserved.</span>\n<span class=\"cm\">Released under Apache 2.0 license as described in the file LICENSE.</span>\n<span class=\"cm\">Authors: Heather Macbeth</span>\n\n<span class=\"cm\">! This file was ported from Lean 3 source module to_mathlib.analysis.inner_product_space.cross_product</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.InnerProductSpace.Dual</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.InnerProductSpace.Orientation</span>\n\n\n<span class=\"kn\">section</span> <span class=\"n\">meta_utils</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">PrettyPrinter</span> <span class=\"n\">Delaborator</span> <span class=\"n\">SubExpr</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">withBetaReduced</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">Delab</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Delab</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">e'</span> <span class=\"bp\">←</span> <span class=\"n\">Core.betaReduce</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getExpr</span><span class=\"o\">)</span>\n  <span class=\"n\">withTheReader</span> <span class=\"n\">SubExpr</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">ctx</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span><span class=\"n\">ctx</span> <span class=\"k\">with</span> <span class=\"n\">expr</span> <span class=\"o\">:=</span> <span class=\"n\">e'</span><span class=\"o\">})</span> <span class=\"n\">d</span>\n\n<span class=\"sd\">/-- Fail if the arity is less than `n`, and collect arguments if the arity is more than `n`. -/</span>\n<span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">delabWithArity</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">Delab</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Delab</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getExpr</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">getAppNumArgs</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"k\">then</span>\n    <span class=\"n\">failure</span>\n  <span class=\"k\">else</span>\n    <span class=\"k\">let</span> <span class=\"n\">rec</span> <span class=\"n\">loop</span> <span class=\"o\">(</span><span class=\"n\">args</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Term</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Delab</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n      <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getExpr</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">getAppNumArgs</span> <span class=\"bp\">&gt;</span> <span class=\"n\">n</span> <span class=\"k\">then</span>\n        <span class=\"k\">let</span> <span class=\"n\">arg</span> <span class=\"bp\">←</span> <span class=\"n\">withAppArg</span> <span class=\"n\">delab</span>\n        <span class=\"n\">withAppFn</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">loop</span> <span class=\"o\">(</span><span class=\"n\">args.push</span> <span class=\"n\">arg</span><span class=\"o\">)</span>\n      <span class=\"k\">else</span>\n        <span class=\"k\">let</span> <span class=\"n\">s</span> <span class=\"bp\">←</span> <span class=\"n\">d</span>\n        <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">s</span> <span class=\"bp\">$</span><span class=\"n\">args</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n    <span class=\"n\">loop</span> <span class=\"bp\">#</span><span class=\"o\">[]</span>\n\n<span class=\"sd\">/-- Delaborator for a coercion function of arity `arity` such that</span>\n<span class=\"sd\">the coerced value is at argument index `coeArg`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">delabCoe</span> <span class=\"o\">(</span><span class=\"n\">arity</span> <span class=\"n\">coeArg</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Delab</span> <span class=\"o\">:=</span> <span class=\"n\">delabWithArity</span> <span class=\"n\">arity</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">arg</span> <span class=\"bp\">←</span> <span class=\"n\">withNaryArg</span> <span class=\"n\">coeArg</span> <span class=\"n\">delab</span>\n  <span class=\"k\">let</span> <span class=\"n\">ty</span> <span class=\"bp\">←</span> <span class=\"n\">withType</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">withBetaReduced</span> <span class=\"n\">delab</span>\n  <span class=\"bp\">`</span><span class=\"o\">((</span><span class=\"bp\">↑$</span><span class=\"n\">arg</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"o\">))</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">AnnotateFunLikecoe</span>\n<span class=\"sd\">/-- Display `FunLike.coe` with type ascriptions. -/</span>\n<span class=\"kd\">@[scoped delab app.FunLike.coe]</span>\n<span class=\"kd\">def</span> <span class=\"n\">delabFunLikeCoe</span> <span class=\"o\">:</span> <span class=\"n\">Delab</span> <span class=\"o\">:=</span> <span class=\"n\">delabCoe</span> <span class=\"mi\">5</span> <span class=\"mi\">4</span>\n<span class=\"kd\">end</span> <span class=\"n\">AnnotateFunLikecoe</span>\n<span class=\"kd\">end</span> <span class=\"n\">meta_utils</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">! # The cross-product on an oriented real inner product space of dimension three -/</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kn\">section</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">RealInnerProductSpace</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">FiniteDimensional</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">synthInstance.checkSynthOrder</span> <span class=\"n\">false</span>\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kn\">local</span> <span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">fact_finiteDimensional_of_finrank_eq_succ</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">synthInstance.checkSynthOrder</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">InnerProductSpace</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- The identification of a finite-dimensional inner product space with its algebraic dual. -/</span>\n<span class=\"kn\">private</span> <span class=\"kd\">def</span> <span class=\"n\">to_dual</span> <span class=\"o\">[</span><span class=\"n\">FiniteDimensional</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">≃ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">E</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">InnerProductSpace.toDual</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toLinearEquiv</span> <span class=\"bp\">≪≫ₗ</span> <span class=\"n\">LinearMap.toContinuousLinearMap.symm</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Orientation</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">E</span><span class=\"o\">}</span>\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">Fact</span> <span class=\"o\">(</span><span class=\"n\">finrank</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">ω</span> <span class=\"o\">:</span> <span class=\"n\">Orientation</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">3</span><span class=\"o\">))</span>\n\n<span class=\"sd\">/-- Linear map from `E` to `E →ₗ[ℝ] E` constructed from a 3-form `Ω` on `E` and an identification of</span>\n<span class=\"sd\">`E` with its dual.  Effectively, the Hodge star operation.  (Under appropriate hypotheses it turns</span>\n<span class=\"sd\">out that the image of this map is in `𝔰𝔬(E)`, the skew-symmetric operators, which can be identified</span>\n<span class=\"sd\">with `Λ²E`.) -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">crossProduct</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">E</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">E</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">let</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">AlternatingMap</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">≃ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span>\n    <span class=\"n\">AlternatingMap.constLinearEquivOfIsEmpty.symm</span>\n  <span class=\"k\">let</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">AlternatingMap</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">E</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span>\n    <span class=\"n\">LinearMap.llcomp</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span> <span class=\"o\">(</span><span class=\"n\">AlternatingMap</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">0</span><span class=\"o\">))</span> <span class=\"n\">ℝ</span> <span class=\"n\">z</span> <span class=\"bp\">∘ₗ</span> <span class=\"n\">AlternatingMap.curryLeftLinearMap</span>\n  <span class=\"k\">let</span> <span class=\"n\">y'</span> <span class=\"o\">:</span> <span class=\"n\">AlternatingMap</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">E</span> <span class=\"o\">:=</span>\n    <span class=\"o\">(</span><span class=\"n\">LinearMap.llcomp</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">AlternatingMap</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"n\">E</span> <span class=\"o\">(</span><span class=\"n\">to_dual</span> <span class=\"n\">E</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">)</span> <span class=\"n\">y</span>\n  <span class=\"k\">let</span> <span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">AlternatingMap</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">E</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">E</span> <span class=\"o\">:=</span>\n    <span class=\"n\">LinearMap.llcomp</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span> <span class=\"o\">(</span><span class=\"n\">AlternatingMap</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"n\">_</span> <span class=\"n\">y'</span> <span class=\"bp\">∘ₗ</span> <span class=\"n\">AlternatingMap.curryLeftLinearMap</span>\n  <span class=\"n\">exact</span> <span class=\"n\">u</span> <span class=\"bp\">∘ₗ</span> <span class=\"n\">AlternatingMap.curryLeftLinearMap</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"n\">ω.volumeForm</span>\n\n<span class=\"kn\">local</span> <span class=\"kd\">infixl</span><span class=\"o\">:</span><span class=\"mi\">100</span> <span class=\"s2\">\"×₃\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ω.crossProduct</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">crossProduct_apply_self</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">v</span><span class=\"bp\">×₃</span><span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">crossProduct</span><span class=\"o\">]</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">quotPrecheck</span> <span class=\"n\">false</span> <span class=\"k\">in</span>\n<span class=\"kd\">notation</span> <span class=\"s2\">\"𝒜\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">AlternatingMap</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">quotPrecheck</span> <span class=\"n\">false</span> <span class=\"k\">in</span>\n<span class=\"kd\">notation</span> <span class=\"s2\">\"𝒜'\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">AlternatingMap</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"mi\">0</span><span class=\"o\">))</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">pp_dot</span><span class=\"o\">]</span> <span class=\"n\">LinearEquiv.symm</span>\n<span class=\"kn\">open</span> <span class=\"n\">AnnotateFunLikecoe</span>\n\n<span class=\"c1\">-- Let's inspect `LinearMap.toContinuousLinearMap` and ways to build the `ContinuousSMul` instance</span>\n<span class=\"c1\">-- it requires. Feel free to skip to the theorem on first read.</span>\n\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">LinearMap.toContinuousLinearMap</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">NormedSpace.Dual</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">LinearMap.toContinuousLinearMap</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">NormedSpace.Dual</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">synth</span> <span class=\"n\">ContinuousSMul</span> <span class=\"n\">ℝ</span> <span class=\"n\">ℝ</span>\n<span class=\"k\">#check</span> <span class=\"n\">to_dual.proof_11</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">to_dual.proof_11</span> <span class=\"bp\">=</span> <span class=\"n\">ContinuousMul.to_continuousSMul</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">LinearMap.toContinuousLinearMap</span> <span class=\"n\">ℝ</span> <span class=\"n\">_</span> <span class=\"n\">E</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">ℝ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">to_dual.proof_11</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">w</span><span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"o\">((</span><span class=\"n\">LinearMap.toContinuousLinearMap</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">NormedSpace.Dual</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"n\">φ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"n\">w</span> <span class=\"bp\">=</span>\n    <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"n\">w</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rfl</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">bar</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">w</span><span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">FunLike.coe</span> <span class=\"o\">(</span><span class=\"n\">NormedSpace.Dual</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"n\">E</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"n\">ContinuousMapClass.toFunLike</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LinearMap.toContinuousLinearMap</span> <span class=\"n\">ℝ</span> <span class=\"n\">_</span> <span class=\"n\">E</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">ℝ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">to_dual.proof_11</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">φ</span><span class=\"o\">)</span> <span class=\"n\">w</span> <span class=\"bp\">=</span>\n    <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"n\">w</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rfl</span>\n\n<span class=\"c1\">--set_option pp.explicit true in</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">inner_crossProduct_apply</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">⟪</span><span class=\"n\">u</span><span class=\"bp\">×₃</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"bp\">⟫</span> <span class=\"bp\">=</span> <span class=\"n\">ω.volumeForm</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">crossProduct</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">to_dual</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">LinearEquiv.trans_symm</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">LinearEquiv.symm_symm</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">LinearIsometryEquiv.toLinearEquiv_symm</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">AlternatingMap.curryLeftLinearMap_apply</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">LinearMap.coe_comp</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Function.comp_apply</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">LinearMap.llcomp_apply</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">LinearEquiv.coe_coe</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">LinearEquiv.trans_apply</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">LinearIsometryEquiv.coe_toLinearEquiv</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">AlternatingMap.curryLeftLinearMap_apply</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">LinearMap.coe_comp</span><span class=\"o\">]</span>\n   <span class=\"c1\">-- simp only [InnerProductSpace.toDual_symm_apply] fails</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">InnerProductSpace.toDual_symm_apply</span><span class=\"o\">]</span>\n  <span class=\"n\">set</span> <span class=\"n\">F'</span> <span class=\"o\">:</span> <span class=\"bp\">𝒜'</span> <span class=\"bp\">→</span> <span class=\"n\">E</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">LinearMap.llcomp</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span> <span class=\"bp\">𝒜</span> <span class=\"n\">ℝ</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">AlternatingMap.constLinearEquivOfIsEmpty.symm</span> <span class=\"o\">:</span> <span class=\"bp\">𝒜</span> <span class=\"bp\">≃ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℝ</span><span class=\"o\">))</span> <span class=\"bp\">∘</span> <span class=\"n\">AlternatingMap.curryLeftLinearMap</span>\n  <span class=\"n\">set</span> <span class=\"n\">K</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">AlternatingMap.curryLeft</span> <span class=\"o\">((</span><span class=\"n\">AlternatingMap.curryLeft</span> <span class=\"o\">(</span><span class=\"n\">volumeForm</span> <span class=\"n\">ω</span><span class=\"o\">))</span> <span class=\"n\">u</span><span class=\"o\">))</span> <span class=\"n\">v</span>\n  <span class=\"c1\">-- rw [LinearMap.coe_toContinuousLinearMap' (F' K)] -- fails</span>\n  <span class=\"c1\">-- rw [bar (F' K) w] -- fails</span>\n  <span class=\"c1\">-- rw [foo (F' K) w] -- fails</span>\n  <span class=\"n\">erw</span> <span class=\"o\">[</span><span class=\"n\">bar</span> <span class=\"o\">(</span><span class=\"n\">F'</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"n\">w</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Function.comp_apply</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">LinearMap.llcomp_apply</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">LinearEquiv.coe_coe</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">AlternatingMap.constLinearEquivOfIsEmpty_symm_apply</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Matrix.zero_empty</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">AlternatingMap.curryLeftLinearMap_apply</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">AlternatingMap.curryLeft_apply_apply</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 389522361,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1694037490
    },
    {
        "content": "<p>Does making <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=NormedSpace.Dual#doc\">docs#NormedSpace.Dual</a> reducible (to match <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Module.Dual#doc\">docs#Module.Dual</a>) fix the first <code>simp only</code> failure?</p>",
        "id": 389525394,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694039106
    },
    {
        "content": "<p>The <code>(↑LinearMap.toContinuousLinearMap : (E →ₗ[ℝ] ℝ) → NormedSpace.Dual ℝ E)</code> in the goal view looks pretty fishy to me</p>",
        "id": 389525652,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694039260
    },
    {
        "content": "<p>That's not really the type of the def, so my guess is that lean is getting confused about the difference between <code>NormedSpace.Dual 𝕜 E</code> and <code>(E →L[𝕜] 𝕜)</code></p>",
        "id": 389525746,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694039304
    },
    {
        "content": "<p>Indeed, filling in a bunch of implicit variables gives the following error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">application</span> <span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"bp\">@</span><span class=\"n\">InnerProductSpace.toDual_symm_apply</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span> <span class=\"bp\">?</span><span class=\"n\">m.383599</span> <span class=\"bp\">?</span><span class=\"n\">m.383600</span> <span class=\"bp\">?</span><span class=\"n\">m.383601</span> <span class=\"bp\">?</span><span class=\"n\">m.383602</span> <span class=\"n\">w</span>\n    <span class=\"o\">(((</span><span class=\"bp\">↑</span><span class=\"o\">((</span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">LinearMap.llcomp</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span> <span class=\"bp\">𝒜</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">𝒜</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"bp\">𝒜</span><span class=\"o\">)</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">E</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">?</span><span class=\"n\">m.389716</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n            <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"bp\">𝒜</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">E</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">∘</span>\n        <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">AlternatingMap.curryLeftLinearMap</span> <span class=\"o\">:</span> <span class=\"bp\">𝒜'</span> <span class=\"bp\">→</span> <span class=\"n\">E</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"bp\">𝒜</span><span class=\"o\">))</span>\n      <span class=\"o\">((</span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">AlternatingMap.curryLeft</span>\n              <span class=\"o\">((</span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">AlternatingMap.curryLeft</span> <span class=\"o\">(</span><span class=\"n\">volumeForm</span> <span class=\"n\">ω</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">AlternatingMap</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">2</span><span class=\"o\">))</span> <span class=\"n\">u</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n          <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">AlternatingMap</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">1</span><span class=\"o\">))</span>\n        <span class=\"n\">v</span><span class=\"o\">))</span>\n<span class=\"n\">argument</span>\n  <span class=\"o\">((</span><span class=\"bp\">↑</span><span class=\"o\">((</span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">LinearMap.llcomp</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span> <span class=\"bp\">𝒜</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">𝒜</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"bp\">𝒜</span><span class=\"o\">)</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">E</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">?</span><span class=\"n\">m.389716</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"bp\">𝒜</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">E</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">∘</span>\n      <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">AlternatingMap.curryLeftLinearMap</span> <span class=\"o\">:</span> <span class=\"bp\">𝒜'</span> <span class=\"bp\">→</span> <span class=\"n\">E</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"bp\">𝒜</span><span class=\"o\">))</span>\n    <span class=\"o\">((</span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">AlternatingMap.curryLeft</span> <span class=\"o\">((</span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">AlternatingMap.curryLeft</span> <span class=\"o\">(</span><span class=\"n\">volumeForm</span> <span class=\"n\">ω</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">AlternatingMap</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">2</span><span class=\"o\">))</span> <span class=\"n\">u</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n        <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">AlternatingMap</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">1</span><span class=\"o\">))</span>\n      <span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">E</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℝ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">NormedSpace.Dual</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span>\n</code></pre></div>",
        "id": 389526084,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694039505
    },
    {
        "content": "<p>(I realize this doesn't directly answer your question, but perhaps we could write a tactic to detect this kind of type issue)</p>",
        "id": 389526089,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694039508
    },
    {
        "content": "<p><code>attribute [reducible] NormedSpace.Dual -- invalid attribute 'reducible', declaration is in an imported module</code> <span aria-label=\"cry\" class=\"emoji emoji-1f622\" role=\"img\" title=\"cry\">:cry:</span> </p>\n<p>So I have to mark it reducible at source and then recompile everything? :-( it's bed time!</p>",
        "id": 389526388,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694039678
    },
    {
        "content": "<p>Or better, change <code>def</code> to <code>abbrev</code></p>",
        "id": 389526643,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694039822
    },
    {
        "content": "<p>But yes, make the change and a PR, and let CI try it while you sleep!</p>",
        "id": 389526671,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694039839
    },
    {
        "content": "<p>Analysis/InnerProductSpace/Dual.lean stops compiling and I don't know my way around this part of the library at all.</p>",
        "id": 389526779,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694039886
    },
    {
        "content": "<p>You also need to delete all the instances we copied</p>",
        "id": 389526803,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694039908
    },
    {
        "content": "<p>I'm afraid I don't have time to embark on this :-(</p>",
        "id": 389526837,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694039930
    },
    {
        "content": "<p>Me neither</p>",
        "id": 389526873,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694039954
    },
    {
        "content": "<p>For the first, I think I would check for metadata in the expression with <code>pp.raw</code> (didn’t see it but the term is very large) and then <code>trace.Meta.isDefEq</code> and <code>trace.Meta.synthInstance</code> to see the difference in behavior between <code>simp</code> and <code>rw</code>. <a href=\"https://github.com/leanprover/lean4/pull/2461\">lean4#2461</a> seems to behave similarly. </p>\n<p>I don’t have a better way to inspect an expensive rewrite than printing a giant term. It would good to have something more efficient, especially for the horror that is some parts of current AG library</p>",
        "id": 389544634,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1694050774
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/6998\">#6998</a> fixes the expensive rewrite but not the simp vs rw issue</p>",
        "id": 389547783,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1694052387
    },
    {
        "content": "<p>By making <code>Dual</code> reducible</p>",
        "id": 389547806,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1694052409
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Debugging.20procedure/near/389526089\">said</a>:</p>\n<blockquote>\n<p>(I realize this doesn't directly answer your question, but perhaps we could write a tactic to detect this kind of type issue)</p>\n</blockquote>\n<p>On the contrary, this is exactly my question. I want a tools to debug those issues. As I wrote, I can work around this issue (the proof I posted does work), but I don want to regularly spend days on such issues.</p>",
        "id": 389668283,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1694095355
    },
    {
        "content": "<p>Sorry, what I meant was \"my previous message did not answer your question, but this parenthesized comment might\"</p>",
        "id": 389668647,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694095436
    },
    {
        "content": "<p>Are we any nearer to understanding why simp fails but rw works?</p>",
        "id": 389668954,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694095503
    },
    {
        "content": "<p>Presumably simp is using stricter reducibility settings than <code>rw</code></p>",
        "id": 389669110,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694095536
    },
    {
        "content": "<p>(and arguably, <code>rw</code> is in the wrong here and only <code>erw</code> should work)</p>",
        "id": 389669142,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694095542
    },
    {
        "content": "<p>Kevin, what was your algorithm to find the implicit variables you needed to fill?</p>",
        "id": 389669323,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1694095575
    },
    {
        "content": "<p>Kevin's error message doesn't look relevant to me. It says:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">E</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℝ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">NormedSpace.Dual</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span>\n</code></pre></div>\n<p>but my claim was that Lean was getting confused about <code>Dual</code> and <code>E →L[ℝ] ℝ</code> (with <code>L</code> not <code>ₗ</code>)</p>",
        "id": 389669685,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694095659
    },
    {
        "content": "<p>Which is to say, it sounds like Kevin filled the implicit variables incorrectly</p>",
        "id": 389669739,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694095670
    },
    {
        "content": "<p>oh maybe. My algorithm was to uncomment the <code>simp only</code> line, click on and hover over the <code>InnerProductSpace.toDual_symm_apply</code> on that line, and then observe that in the messages and in the pop-up I had enough information to start filling in implicit variables, and then I just started adding stuff like <code>simp only [InnerProductSpace.toDual_symm_apply (\\k := \\R)]</code> etc. It was just five minutes before I was turning the computer off though so I could have made some errors.</p>",
        "id": 389670835,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694095885
    },
    {
        "content": "<p>Eric, I answered some of your questions at <a href=\"https://github.com/leanprover-community/mathlib4/pull/6998\">#6998</a></p>",
        "id": 389671504,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1694096001
    },
    {
        "content": "<p>I'm on a 45 minute train journey and it's touch and go as to whether <code>lake exe cache get</code> will terminate before I arrive...</p>",
        "id": 389672917,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694096285
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306577\">Matthew Ballard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Debugging.20procedure/near/389544634\">said</a>:</p>\n<blockquote>\n<p>For the first, I think I would check for metadata in the expression with <code>pp.raw</code> (didn’t see it but the term is very large) and then <code>trace.Meta.isDefEq</code> and <code>trace.Meta.synthInstance</code> to see the difference in behavior between <code>simp</code> and <code>rw</code>. <a href=\"https://github.com/leanprover/lean4/pull/2461\">lean4#2461</a> seems to behave similarly. </p>\n<p>I don’t have a better way to inspect an expensive rewrite than printing a giant term. It would good to have something more efficient, especially for the horror that is some parts of current AG library</p>\n</blockquote>\n<p>Does anyone understand the output with <code>trace.Meta.isDefEq</code> in the failing <code>simp</code>? It's full of things like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">❌</span> <span class=\"kt\">Prop</span> <span class=\"bp\">=?=</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"bp\">→</span>\n      <span class=\"o\">[</span><span class=\"n\">inst</span> <span class=\"o\">:</span> <span class=\"n\">Semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"bp\">→</span>\n        <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"bp\">→</span>\n          <span class=\"o\">[</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">AddCommMonoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"bp\">→</span>\n            <span class=\"o\">[</span><span class=\"n\">inst_2</span> <span class=\"o\">:</span> <span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"bp\">→</span>\n              <span class=\"o\">{</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"bp\">→</span>\n                <span class=\"o\">[</span><span class=\"n\">inst_3</span> <span class=\"o\">:</span> <span class=\"n\">AddCommMonoid</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"bp\">→</span>\n                  <span class=\"o\">[</span><span class=\"n\">inst_4</span> <span class=\"o\">:</span> <span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"bp\">→</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">FunLike</span> <span class=\"o\">(</span><span class=\"n\">AlternatingMap</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">N</span>\n</code></pre></div>\n<p>There are dozens of variations on this unpromising theme, and then the trace ends with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">❌</span> <span class=\"bp\">?</span><span class=\"n\">a</span> <span class=\"bp\">=</span>\n      <span class=\"bp\">?</span><span class=\"n\">a</span> <span class=\"bp\">=?=</span> <span class=\"n\">inner</span>\n        <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">LinearIsometryEquiv.symm</span> <span class=\"o\">(</span><span class=\"n\">InnerProductSpace.toDual</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span><span class=\"o\">))</span>\n          <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">LinearMap.toContinuousLinearMap</span>\n            <span class=\"o\">((</span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">LinearMap.llcomp</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span> <span class=\"bp\">𝒜</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">↑</span><span class=\"n\">AlternatingMap.constLinearEquivOfIsEmpty.symm</span><span class=\"o\">)</span> <span class=\"bp\">∘</span>\n                <span class=\"bp\">↑</span><span class=\"n\">AlternatingMap.curryLeftLinearMap</span><span class=\"o\">)</span>\n              <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">AlternatingMap.curryLeft</span> <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">AlternatingMap.curryLeft</span> <span class=\"o\">(</span><span class=\"n\">Orientation.volumeForm</span> <span class=\"n\">ω</span><span class=\"o\">))</span> <span class=\"n\">u</span><span class=\"o\">))</span> <span class=\"n\">v</span><span class=\"o\">))))</span>\n        <span class=\"n\">w</span> <span class=\"bp\">=</span>\n      <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">Orientation.volumeForm</span> <span class=\"n\">ω</span><span class=\"o\">)</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 389674311,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1694096616
    },
    {
        "content": "<p>For comparison, the <code>rw</code> does the usual start with lots of failing <code>foo ?m.78876 =?= foo a</code> but then it goes straight to the relevant quest</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">inner</span>\n      <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">LinearIsometryEquiv.symm</span> <span class=\"o\">(</span><span class=\"n\">InnerProductSpace.toDual</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span><span class=\"o\">))</span>\n        <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">LinearMap.toContinuousLinearMap</span>\n          <span class=\"o\">((</span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">LinearMap.llcomp</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span> <span class=\"bp\">𝒜</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">↑</span><span class=\"n\">AlternatingMap.constLinearEquivOfIsEmpty.symm</span><span class=\"o\">)</span> <span class=\"bp\">∘</span>\n              <span class=\"bp\">↑</span><span class=\"n\">AlternatingMap.curryLeftLinearMap</span><span class=\"o\">)</span>\n            <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">AlternatingMap.curryLeft</span> <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">AlternatingMap.curryLeft</span> <span class=\"o\">(</span><span class=\"n\">Orientation.volumeForm</span> <span class=\"n\">ω</span><span class=\"o\">))</span> <span class=\"n\">u</span><span class=\"o\">))</span> <span class=\"n\">v</span><span class=\"o\">))))</span>\n      <span class=\"n\">w</span> <span class=\"bp\">=?=</span> <span class=\"n\">inner</span> <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">LinearIsometryEquiv.symm</span> <span class=\"o\">(</span><span class=\"n\">InnerProductSpace.toDual</span> <span class=\"bp\">?</span><span class=\"n\">m.412649</span> <span class=\"bp\">?</span><span class=\"n\">m.412650</span><span class=\"o\">))</span> <span class=\"bp\">?</span><span class=\"n\">m.412656</span><span class=\"o\">)</span> <span class=\"bp\">?</span><span class=\"n\">m.412655</span>\n</code></pre></div>",
        "id": 389674980,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1694096780
    },
    {
        "content": "<p>In particular <code>simp</code> does not go far enough to try to synthesize any instance at all.</p>",
        "id": 389675656,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1694096949
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Debugging.20procedure/near/389669110\">said</a>:</p>\n<blockquote>\n<p>Presumably simp is using stricter reducibility settings than <code>rw</code></p>\n</blockquote>\n<p>I thought these were the same defaults - they both only unfold things tagged with reducible. Am I wrong?</p>",
        "id": 389686090,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1694099359
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Debugging.20procedure/near/389674311\">said</a>:</p>\n<blockquote>\n<p>Does anyone understand the output with <code>trace.Meta.isDefEq</code> in the failing <code>simp</code>? </p>\n</blockquote>\n<p>I’ve seen this behavior where it wants to try to the unify the world with <code>Prop</code>most recently in <a href=\"https://github.com/leanprover-community/Lean4/pull/2461\">Lean4#2461</a> and the related discussion. </p>\n<p>I don’t understand it heuristically</p>",
        "id": 389686964,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1694099572
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306577\">Matthew Ballard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Debugging.20procedure/near/389686090\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Debugging.20procedure/near/389669110\">said</a>:</p>\n<blockquote>\n<p>Presumably simp is using stricter reducibility settings than <code>rw</code></p>\n</blockquote>\n<p>I thought these were the same defaults - they both only unfold things tagged with reducible. Am I wrong?</p>\n</blockquote>\n<p>I think unification is allowed to unfold further</p>",
        "id": 389687461,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694099696
    },
    {
        "content": "<p>Sorry, can you expand when you get a chance?</p>",
        "id": 389689576,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1694100240
    },
    {
        "content": "<p>Trying to investigate the second issue, I can type</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.InnerProductSpace.Dual</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.InnerProductSpace.Orientation</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">! # The cross-product on an oriented real inner product space of dimension three -/</span>\n\n\n<span class=\"kd\">noncomputable</span> <span class=\"kn\">section</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">RealInnerProductSpace</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">FiniteDimensional</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">synthInstance.checkSynthOrder</span> <span class=\"n\">false</span>\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kn\">local</span> <span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">fact_finiteDimensional_of_finrank_eq_succ</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">synthInstance.checkSynthOrder</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">InnerProductSpace</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- The identification of a finite-dimensional inner product space with its algebraic dual. -/</span>\n<span class=\"kn\">private</span> <span class=\"kd\">def</span> <span class=\"n\">to_dual</span> <span class=\"o\">[</span><span class=\"n\">FiniteDimensional</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">≃ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">E</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">InnerProductSpace.toDual</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toLinearEquiv</span> <span class=\"bp\">≪≫ₗ</span> <span class=\"n\">LinearMap.toContinuousLinearMap.symm</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Orientation</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">E</span><span class=\"o\">}</span>\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">Fact</span> <span class=\"o\">(</span><span class=\"n\">finrank</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">ω</span> <span class=\"o\">:</span> <span class=\"n\">Orientation</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">3</span><span class=\"o\">))</span>\n\n<span class=\"sd\">/-- Linear map from `E` to `E →ₗ[ℝ] E` constructed from a 3-form `Ω` on `E` and an identification of</span>\n<span class=\"sd\">`E` with its dual.  Effectively, the Hodge star operation.  (Under appropriate hypotheses it turns</span>\n<span class=\"sd\">out that the image of this map is in `𝔰𝔬(E)`, the skew-symmetric operators, which can be identified</span>\n<span class=\"sd\">with `Λ²E`.) -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">crossProduct</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">E</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">E</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">let</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">AlternatingMap</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">≃ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span>\n    <span class=\"n\">AlternatingMap.constLinearEquivOfIsEmpty.symm</span>\n  <span class=\"k\">let</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">AlternatingMap</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">E</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span>\n    <span class=\"n\">LinearMap.llcomp</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span> <span class=\"o\">(</span><span class=\"n\">AlternatingMap</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">0</span><span class=\"o\">))</span> <span class=\"n\">ℝ</span> <span class=\"n\">z</span> <span class=\"bp\">∘ₗ</span> <span class=\"n\">AlternatingMap.curryLeftLinearMap</span>\n  <span class=\"k\">let</span> <span class=\"n\">y'</span> <span class=\"o\">:</span> <span class=\"n\">AlternatingMap</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">E</span> <span class=\"o\">:=</span>\n    <span class=\"o\">(</span><span class=\"n\">LinearMap.llcomp</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">AlternatingMap</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"n\">E</span> <span class=\"o\">(</span><span class=\"n\">to_dual</span> <span class=\"n\">E</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">)</span> <span class=\"n\">y</span>\n  <span class=\"k\">let</span> <span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">AlternatingMap</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">E</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">E</span> <span class=\"o\">:=</span>\n    <span class=\"n\">LinearMap.llcomp</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span> <span class=\"o\">(</span><span class=\"n\">AlternatingMap</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"n\">_</span> <span class=\"n\">y'</span> <span class=\"bp\">∘ₗ</span> <span class=\"n\">AlternatingMap.curryLeftLinearMap</span>\n  <span class=\"n\">exact</span> <span class=\"n\">u</span> <span class=\"bp\">∘ₗ</span> <span class=\"n\">AlternatingMap.curryLeftLinearMap</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"n\">ω.volumeForm</span>\n\n<span class=\"kn\">local</span> <span class=\"kd\">infixl</span><span class=\"o\">:</span><span class=\"mi\">100</span> <span class=\"s2\">\"×₃\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ω.crossProduct</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">crossProduct_apply_self</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">v</span><span class=\"bp\">×₃</span><span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">crossProduct</span><span class=\"o\">]</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">quotPrecheck</span> <span class=\"n\">false</span> <span class=\"k\">in</span>\n<span class=\"kd\">notation</span> <span class=\"s2\">\"𝒜\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">AlternatingMap</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">quotPrecheck</span> <span class=\"n\">false</span> <span class=\"k\">in</span>\n<span class=\"kd\">notation</span> <span class=\"s2\">\"𝒜'\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">AlternatingMap</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"mi\">0</span><span class=\"o\">))</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">pp_dot</span><span class=\"o\">]</span> <span class=\"n\">LinearEquiv.symm</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">bar</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">w</span><span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">FunLike.coe</span> <span class=\"o\">(</span><span class=\"n\">NormedSpace.Dual</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"n\">E</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"n\">ContinuousMapClass.toFunLike</span>\n  <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LinearMap.toContinuousLinearMap</span> <span class=\"n\">ℝ</span> <span class=\"n\">_</span> <span class=\"n\">E</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">ℝ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">to_dual.proof_11</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">φ</span><span class=\"o\">)</span> <span class=\"n\">w</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"n\">w</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rfl</span>\n\n\n<span class=\"kd\">theorem</span> <span class=\"n\">inner_crossProduct_apply</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">⟪</span><span class=\"n\">u</span><span class=\"bp\">×₃</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"bp\">⟫</span> <span class=\"bp\">=</span> <span class=\"n\">ω.volumeForm</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">crossProduct</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">to_dual</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">LinearEquiv.trans_symm</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">LinearEquiv.symm_symm</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">LinearIsometryEquiv.toLinearEquiv_symm</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">AlternatingMap.curryLeftLinearMap_apply</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">LinearMap.coe_comp</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Function.comp_apply</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">LinearMap.llcomp_apply</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">LinearEquiv.coe_coe</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">LinearEquiv.trans_apply</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">LinearIsometryEquiv.coe_toLinearEquiv</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">AlternatingMap.curryLeftLinearMap_apply</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">LinearMap.coe_comp</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">InnerProductSpace.toDual_symm_apply</span><span class=\"o\">]</span>\n  <span class=\"n\">set</span> <span class=\"n\">F'</span> <span class=\"o\">:</span> <span class=\"bp\">𝒜'</span> <span class=\"bp\">→</span> <span class=\"n\">E</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">LinearMap.llcomp</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span> <span class=\"bp\">𝒜</span> <span class=\"n\">ℝ</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">AlternatingMap.constLinearEquivOfIsEmpty.symm</span> <span class=\"o\">:</span> <span class=\"bp\">𝒜</span> <span class=\"bp\">≃ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℝ</span><span class=\"o\">))</span> <span class=\"bp\">∘</span> <span class=\"n\">AlternatingMap.curryLeftLinearMap</span>\n  <span class=\"n\">set</span> <span class=\"n\">K</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">AlternatingMap.curryLeft</span> <span class=\"o\">((</span><span class=\"n\">AlternatingMap.curryLeft</span> <span class=\"o\">(</span><span class=\"n\">volumeForm</span> <span class=\"n\">ω</span><span class=\"o\">))</span> <span class=\"n\">u</span><span class=\"o\">))</span> <span class=\"n\">v</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">bar</span> <span class=\"o\">(</span><span class=\"n\">F'</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"n\">w</span>\n  <span class=\"n\">trans</span> <span class=\"n\">F'</span> <span class=\"n\">K</span> <span class=\"n\">w</span>\n  <span class=\"bp\">·</span> <span class=\"n\">beta_reduce</span> <span class=\"n\">at</span> <span class=\"n\">this</span> <span class=\"bp\">⊢</span>\n    <span class=\"c1\">-- rw [this] -- fails</span>\n    <span class=\"kd\">set_option</span> <span class=\"n\">trace.Meta.isDefEq</span> <span class=\"n\">true</span> <span class=\"k\">in</span> <span class=\"n\">exact</span> <span class=\"n\">this</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>But the <code>isDefEq</code> trace is showing nothing at all. I mean every line in the trace looks like a syntactic equality.</p>",
        "id": 389689807,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1694100300
    },
    {
        "content": "<p>Did you try it on <a href=\"https://github.com/leanprover-community/mathlib4/tree/mrb%2Fnormed_dual_reducible\">branch#mrb/normed_dual_reducible</a> to compare?</p>",
        "id": 389690456,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1694100447
    },
    {
        "content": "<p>No, I'm actively  avoiding doing this because I don't want to fix that proof, I want to understand how to debug the next 100 proofs that will fail in incomprehensible ways.</p>",
        "id": 389690887,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1694100532
    },
    {
        "content": "<p>I guess part of what I want a version of <code>convert</code> that works up to syntactic equality, reporting any mismatch that would block <code>rw</code>.</p>",
        "id": 389691369,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1694100617
    },
    {
        "content": "<p>I meant to compare the traces and see if the difference is insightful in some way. </p>\n<p>Is there a useful trace class for rewrite?</p>",
        "id": 389691840,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1694100728
    },
    {
        "content": "<p>I really only know print line debugging in general</p>",
        "id": 389692953,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1694100850
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> I think you can do that with <code>convert (config := {transparency := .reducible}) h</code>, at least, <code>#help tactic convert</code> seems to suggest something like this</p>",
        "id": 389693263,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1694100921
    },
    {
        "content": "<p>I'm not sure how helpful the error messages will be.</p>",
        "id": 389693407,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1694100944
    },
    {
        "content": "<p>Jireh, nice try but it closes the goal without reporting anything.</p>",
        "id": 389694213,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1694101175
    },
    {
        "content": "<p>Update: <code>set_option trace.Meta.isDefEq true in rw [this]</code> does report stuff about the failure. It starts with funny lines like </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">found</span> <span class=\"n\">messy</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ℝ</span> <span class=\"bp\">=?=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ℝ</span>\n</code></pre></div>\n<p>but then at some point it gets to </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[]</span> <span class=\"bp\">❌</span> <span class=\"n\">NormedSpace.Dual</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span> <span class=\"bp\">=?=</span> <span class=\"n\">E</span> <span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℝ</span> <span class=\"bp\">▼</span>\n        <span class=\"o\">[]</span> <span class=\"bp\">❌</span> <span class=\"n\">NormedSpace.Dual</span> <span class=\"bp\">=?=</span> <span class=\"bp\">@</span><span class=\"n\">ContinuousLinearMap</span>\n        <span class=\"o\">[</span><span class=\"n\">onFailure</span><span class=\"o\">]</span> <span class=\"bp\">❌</span> <span class=\"n\">NormedSpace.Dual</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span> <span class=\"bp\">=?=</span> <span class=\"n\">E</span> <span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℝ</span>\n        <span class=\"o\">[</span><span class=\"n\">onFailure</span><span class=\"o\">]</span> <span class=\"bp\">❌</span> <span class=\"n\">NormedSpace.Dual</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span> <span class=\"bp\">=?=</span> <span class=\"n\">E</span> <span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℝ</span>\n</code></pre></div>\n<p>which indeed seems to be useful.</p>",
        "id": 389717390,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1694107809
    },
    {
        "content": "<p>I'd be interested in learning what is messy about <code>fun a =&gt; ℝ =?= fun x =&gt; ℝ</code>.</p>",
        "id": 389717575,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1694107866
    },
    {
        "content": "<p>Is messy something about <code>mdata</code>? I think someone recently found a bug in <code>dsimp</code> about mdata.</p>",
        "id": 389721171,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1694109000
    },
    {
        "content": "<p>I'm just grasping at straws.</p>",
        "id": 389721307,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1694109035
    },
    {
        "content": "<p>Does grepping in core give any doc info?</p>",
        "id": 389721571,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1694109115
    },
    {
        "content": "<p>The message about messy DefEq comes from <a href=\"https://github.com/leanprover/lean4/blob/13ca443f058b0e33e44a9fdba347a53330463348/src/Lean/Meta/ExprDefEq.lean#L249-L250\">here</a>.</p>",
        "id": 389727071,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1694110599
    },
    {
        "content": "<p>So it's printed because <code>info.dependsOnHigherOrderOutParam || info.higherOrderOutParam</code>.</p>",
        "id": 389727184,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1694110637
    },
    {
        "content": "<p>Are the x and a the same time in that \"messy\" equality?</p>",
        "id": 389742257,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694115335
    },
    {
        "content": "<p>You mean the same type? Yes. This was also my first guess.</p>",
        "id": 389742446,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1694115385
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Debugging.20procedure/near/389671504\">said</a>:</p>\n<blockquote>\n<p>Eric, I answered some of your questions at <a href=\"https://github.com/leanprover-community/mathlib4/pull/6998\">#6998</a></p>\n</blockquote>\n<p>I'm back at Lean and had a look at this (and left some more comments); something very nasty seems to be happening with typeclass inference, where somehow things in an unrelated part of the expression affect whether an instance is found</p>",
        "id": 389757024,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694120169
    },
    {
        "content": "<p>Should we still merge or do you want to get to the bottom of this?</p>",
        "id": 389763701,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1694123122
    },
    {
        "content": "<p>I think we should add a TODO comment that references a new github issue, then merge</p>",
        "id": 389766844,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694124902
    },
    {
        "content": "<p>Ok, I delegated the PR.</p>",
        "id": 389792144,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1694138545
    },
    {
        "content": "<p>I've made a thread with a not-mathlib-free mwe at <a href=\"#narrow/stream/113488-general/topic/Typeclass.20search.20is.20affected.20by.20other.20subexpressions/near/389833387\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclass.20search.20is.20affected.20by.20other.20subexpressions/near/389833387</a></p>",
        "id": 389835655,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694162107
    },
    {
        "content": "<p>What is the status of <a href=\"https://github.com/leanprover-community/mathlib4/pull/6998\">#6998</a> <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> and <span class=\"user-mention\" data-user-id=\"306577\">@Matthew Ballard</span>? I lost track.</p>",
        "id": 390200737,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1694390351
    },
    {
        "content": "<p>It's waiting on the undergrad.yml fix, and also a tracking issue to be created for the <code>noncomputable</code> hack needed to keep down the <code>maxrss</code> performance metric.</p>",
        "id": 390261597,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694421610
    },
    {
        "content": "<p>Sorry. I’ve been out of commission for a bit. Back at it soon.</p>",
        "id": 390298828,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1694435035
    }
]