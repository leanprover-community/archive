[
    {
        "content": "<p>I recall having brought this up back in 2022 or so. But I'd like to bring it up again, because it keeps pestering me.</p>\n<p>Mathlib does not currently have a typeclass to express that the bottom element of a type and its zero element are equal. The closest thing we have is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CanonicallyOrderedAdd#doc\">docs#CanonicallyOrderedAdd</a>, which is a relatively minimal, somewhat common typeclass that implies it. Multiple order structures with the <code>⊥ = 0</code> property such as <code>ℕ</code>, <code>Ordinal</code>, or <code>Cardinal</code>, do satisfy the canonically ordered add typeclass.</p>\n<p>There are various convenience lemmas that are gated behind this typeclass. The basic examples would be <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=zero_le#doc\">docs#zero_le</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LT.lt.pos#doc\">docs#LT.lt.pos</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=eq_zero_or_pos#doc\">docs#eq_zero_or_pos</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=le_self_add#doc\">docs#le_self_add</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=le_add_self#doc\">docs#le_add_self</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=le_add_of_le_left#doc\">docs#le_add_of_le_left</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=le_add_of_le_right#doc\">docs#le_add_of_le_right</a>. There's also some more \"advanced\" examples, such as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.sum_eq_zero_iff#doc\">docs#List.sum_eq_zero_iff</a> or <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finsupp.Lex.wellFoundedLT#doc\">docs#Finsupp.Lex.wellFoundedLT</a>.</p>\n<p>However, working within the <a href=\"https://github.com/vihdzp/combinatorial-games\"><code>combinatorial-games</code></a> repository, there are various structures that satisfy <code>⊥ = 0</code> but not this predicate. The main one would be <code>NatOrdinal</code>. Although it's just a type alias for <code>Ordinal</code>, it has completely different (and quite interesting) arithmetic. In fact, it's a strictly ordered semiring with <code>⊥ = 0</code>, which means all the aforementioned convenience lemmas apply to it, even though they all have to be reproved, since it is not <code>CanonicallyOrderedAdd</code> (e.g. there's no <code>x</code> with <code>ω = 1 + x</code>).</p>\n<p>There's also <code>Nimber</code>, which is another mathematically interesting type alias of <code>Ordinal</code>. Its order is quite borked up with respect to its arithmetic, which means it only satisfies the direct consequences of <code>⊥ = 0</code>, though it's still a bit annoying having to reprove all of them. The same applies to <code>Nimber[X]</code>, which the repository endows with a lexicographic order structure, which is quite important for the simplest extension theorems.</p>\n<p>The problems I describe still apply to some extent to <code>Ordinal</code> itself. Since ordinal addition isn't commutative, it gets cut off (in a seemingly arbitrarily way) from about half of the <code>CanonicallyOrderedAdd</code> API. For instance, ordinals satisfy both <code>a ≤ a + b</code> and <code>a ≤ b + a</code>, but the latter (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=le_add_self#doc\">docs#le_add_self</a>) is proven assuming commutativity from the former.</p>\n<p>My proposal is to create the following typeclass:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">IsBotZero</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LE</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Zero</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">isBot_zero</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsBot</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>This would allow many of the theorems currently stated with <code>CanonicallyOrderedAdd</code> to be stated in terms of even weaker assumptions. Some combination of <code>IsBotZero</code> + <code>AddZeroClass</code> + <code>AddLeftMono</code> + <code>AddRightMono</code> should be sufficient for a large portion of these theorems, and would apply to my cases. We could then show (via a low-priority instance) that <code>CanonicallyOrderedAdd</code> + <code>AddZeroClass</code> → <code>IsBotZero</code>.</p>",
        "id": 536676851,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1756411874
    },
    {
        "content": "<p>The blocker last time I tried this was whether <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=bot_eq_zero#doc\">docs#bot_eq_zero</a> should be a simp lemma. The thing is, not all types with the <code>⊥ = 0</code> property prefer the <code>0</code> spelling, with a notable counterexample being ideals over a semiring (see <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ideal.zero_eq_bot#doc\">docs#Ideal.zero_eq_bot</a>). I think we can keep the current design, where the base lemma is not made <code>simp</code>, whereas the specialization <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=bot_eq_zero%27#doc\">docs#bot_eq_zero'</a> to linearly ordered monoids is.</p>",
        "id": 536677110,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1756412022
    },
    {
        "content": "<p>Probably don't assume <code>Bot</code></p>",
        "id": 536677137,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756412035
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/287929-mathlib4/topic/IsBotZeroClass/near/536676851\">said</a>:</p>\n<blockquote>\n<p>it only satisfies the direct consequences of <code>⊥ = 0</code></p>\n</blockquote>\n<p>What lemmas are we talking about?</p>",
        "id": 536677305,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1756412110
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/287929-mathlib4/topic/IsBotZeroClass/near/536677305\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/287929-mathlib4/topic/IsBotZeroClass/near/536676851\">said</a>:</p>\n<blockquote>\n<p>it only satisfies the direct consequences of <code>⊥ = 0</code></p>\n</blockquote>\n<p>What lemmas are we talking about?</p>\n</blockquote>\n<p><code>0 ≤ x</code>, <code>x &lt; y → 0 &lt; y</code>, <code>x = 0 ∨ 0 &lt; x</code>, those are the main three.</p>",
        "id": 536677453,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1756412164
    },
    {
        "content": "<p>Though I'd also like to call out <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finsupp.Lex.wellFoundedLT#doc\">docs#Finsupp.Lex.wellFoundedLT</a> which truly only needs <code>⊥ = 0</code> (as the primed version above it shows).</p>",
        "id": 536677585,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1756412226
    },
    {
        "content": "<p>Is this really that painful to have three extra lemmas <code>Nimber.zero_le</code>, <code>Nimber.pos_of_lt</code>, <code>Nimber.eq_zero_or_pos</code>?</p>",
        "id": 536677647,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1756412257
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/287929-mathlib4/topic/IsBotZeroClass/near/536677585\">said</a>:</p>\n<blockquote>\n<p>Though I'd also like to call out <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finsupp.Lex.wellFoundedLT#doc\">docs#Finsupp.Lex.wellFoundedLT</a> which truly only needs <code>⊥ = 0</code> (as the primed version above it shows).</p>\n</blockquote>\n<p>About this, you might be interested in the proposal Sky and I have had for a few years of decoupling <code>Finsupp</code> from <code>Zero</code>, since there are some use cases where we would instead want the support according to <code>1</code>, or the support according to <code>⊥</code></p>",
        "id": 536677805,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1756412326
    },
    {
        "content": "<p>Until recently it was difficult to actually implement this proposal, but now we have clearly-separated files for the \"data properties\" vs algebraic properties of <code>Finsupp</code></p>",
        "id": 536677936,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1756412389
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/287929-mathlib4/topic/IsBotZeroClass/near/536677647\">said</a>:</p>\n<blockquote>\n<p>Is this really that painful to have three extra lemmas <code>Nimber.zero_le</code>, <code>Nimber.pos_of_lt</code>, <code>Nimber.eq_zero_or_pos</code>?</p>\n</blockquote>\n<p>It's not, but it is a slight inconvenience piled up on the other larger inconveniences I mentioned. (Note also that we can't enable dot notation on <code>Nimber.pos_of_lt</code> in the same way as with <code>LT.lt.pos</code>).</p>",
        "id": 536678162,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1756412466
    },
    {
        "content": "<p>I'm not sure if this works, but can you do <code>Nimber.LT.lt.pos</code> and then when you <code>open Nimber</code> you can use it for dot notation?</p>",
        "id": 536678359,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1756412550
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/287929-mathlib4/topic/IsBotZeroClass/near/536677805\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/287929-mathlib4/topic/IsBotZeroClass/near/536677585\">said</a>:</p>\n<blockquote>\n<p>Though I'd also like to call out <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finsupp.Lex.wellFoundedLT#doc\">docs#Finsupp.Lex.wellFoundedLT</a> which truly only needs <code>⊥ = 0</code> (as the primed version above it shows).</p>\n</blockquote>\n<p>About this, you might be interested in the proposal Sky and I have had for a few years of decoupling <code>Finsupp</code> from <code>Zero</code>, since there are some use cases where we would instead want the support according to <code>1</code>, or the support according to <code>⊥</code></p>\n</blockquote>\n<p>I think said proposal is quite reasonable, but I do worry that in my particular case it might create two different ways to spell the same thing (finsupp with ⊥, finsupp with 0)</p>",
        "id": 536678451,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1756412595
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/channel/287929-mathlib4/topic/IsBotZeroClass/near/536678359\">said</a>:</p>\n<blockquote>\n<p>I'm not sure if this works, but can you do <code>Nimber.LT.lt.pos</code> and then when you <code>open Nimber</code> you can use it for dot notation?</p>\n</blockquote>\n<p>No, this doesn't work.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Nimber'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Ordinal</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Zero</span><span class=\"w\"> </span><span class=\"n\">Nimber'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">inferInstanceAs</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Zero</span><span class=\"w\"> </span><span class=\"n\">Ordinal</span><span class=\"o\">)</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LT</span><span class=\"w\"> </span><span class=\"n\">Nimber'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">inferInstanceAs</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">LT</span><span class=\"w\"> </span><span class=\"n\">Ordinal</span><span class=\"o\">)</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Nimber'</span><span class=\"bp\">.</span><span class=\"n\">LT</span><span class=\"bp\">.</span><span class=\"n\">lt</span><span class=\"bp\">.</span><span class=\"n\">pos</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nimber'</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">pos_of_gt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Ordinal</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">h</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Nimber'</span>\n\n<span class=\"w\"> </span><span class=\"c1\">-- failed to synthesize AddZeroClass Nimber'</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nimber'</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">pos</span>\n</code></pre></div>",
        "id": 536679170,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1756412983
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/287929-mathlib4/topic/IsBotZeroClass/near/536678451\">said</a>:</p>\n<blockquote>\n<p>I do worry that in my particular case it might create two different ways to spell the same thing (finsupp with ⊥, finsupp with 0)</p>\n</blockquote>\n<p>My idea is that they will be defeq, so you needn't worry</p>",
        "id": 536679671,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1756413179
    },
    {
        "content": "<p>Fair enough!</p>",
        "id": 536679739,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1756413211
    },
    {
        "content": "<p>I do still think that the <code>List.sum</code> theorems (e.g. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.le_sum_of_mem#doc\">docs#List.le_sum_of_mem</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.sum_eq_zero_iff#doc\">docs#List.sum_eq_zero_iff</a>) assuming commutativity are quite unfortunate. Working with the Cantor normal form I've had to use <code>List.sum</code> <em>precisely</em> because it allows for noncommutative sums. and the only reason these theorems assume commutativity is for the same reason <code>a ≤ b + a</code> does.</p>",
        "id": 536680429,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1756413565
    },
    {
        "content": "<p>maybe <code>CanonicallyOrderedAdd</code> should also have an <code>le_add_self</code> field</p>",
        "id": 536680658,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756413684
    },
    {
        "content": "<p>That seems like a reasonable middle-ground solution. Looking through the instances of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CanonicallyOrderedAdd#doc\">docs#CanonicallyOrderedAdd</a> it seems like <code>Ordinal</code> is the only one without commutative addition.</p>",
        "id": 536680941,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1756413838
    },
    {
        "content": "<p>On a tangentially related note... why do we have both <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=le_self_add#doc\">docs#le_self_add</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=self_le_add_right#doc\">docs#self_le_add_right</a> ?</p>",
        "id": 536681537,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1756414173
    },
    {
        "content": "<p>The only difference is the former has explicit arguments</p>",
        "id": 536682064,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1756414458
    },
    {
        "content": "<p>Notably, neither of these match <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.le_add_right#doc\">docs#Nat.le_add_right</a> or <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Multiset.le_add_right#doc\">docs#Multiset.le_add_right</a></p>",
        "id": 536686208,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1756416523
    },
    {
        "content": "<p>PR is ready! Surprised by how smoothly it went. <a href=\"https://github.com/leanprover-community/mathlib4/pull/29084\">#29084</a></p>",
        "id": 536700578,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1756427534
    }
]