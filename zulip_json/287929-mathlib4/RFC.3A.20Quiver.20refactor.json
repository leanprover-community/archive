[
    {
        "content": "<p>In her Lean Together talk, Sophie Morel was tripped up because she typed <code>[Quiver.{v} V]</code> and then got incomprehensible universe errors. Turns out that Mathlib is in fact full of <code>[Quiver.{v + 1} V]</code>, because in 99% of our applications of quivers we need to demand that the hom types really are types rather than <code>Prop</code>. My proposal in <a href=\"https://github.com/leanprover-community/mathlib4/pull/34228\">#34228</a> is that we follow category theory and let hom types be <code>Type v</code>-valued rather than <code>Sort v</code>-valued; this removes about 60 <code>+1</code>s from mathlib.</p>\n<p>However it breaks one thing: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Matrix.toQuiver#doc\">docs#Matrix.toQuiver</a> is a construction which takes a square matrix over an ordered ring and returns a Prop-valued quiver on the type which indexes the rows and columns which is true iff the corresponding matrix entry is positive. Already one can see that this is the \"wrong\" definition, because <code>Quiver</code> is a class but <code>Matrix.toQuiver</code> is a definition rather than an instance.</p>\n<p>My proposal is<br>\n(1) refactor Quiver so, like Category, the hom sets are Type-valued rather than Sort-valued<br>\n(2) change Matrix.toQuiver into Matrix.toDigraph.</p>\n<p><span class=\"user-mention\" data-user-id=\"779253\">@Matteo Cipollina</span> is there a reason that you ultimately chose quivers rather than digraphs in <a href=\"https://github.com/leanprover-community/mathlib4/pull/28728\">#28728</a> ?</p>\n<p>In <a href=\"https://github.com/leanprover-community/mathlib4/pull/34228\">#34228</a> I make a start on this refactor, just to see if I can get mathlib compiling. Right now I just use <code>PLift</code> to get the <code>Matrix.toQuiver</code> file compiling; Is this a satisfactory change or should I attempt the <code>Digraph</code> refactor? Right now I am a bit confused about why quivers are used here at all when digraphs seem more natural.</p>",
        "id": 569341904,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1769024913
    },
    {
        "content": "<p>The issue was indeed raised in the review, I've chosen Quiver because it had more available API that was suited to the reasoning about paths and connectedness, as needed for the Perron Frobenius theorem. <br>\nI'll have a closer look, see how to refactor this  where it is used (<a href=\"https://github.com/or4nge19/MCMC/tree/main/MCMC/PF/LinearAlgebra/Matrix/PerronFrobenius\">here</a>) along your PR and let you know asap</p>",
        "id": 569344795,
        "sender_full_name": "Matteo Cipollina",
        "timestamp": 1769025809
    },
    {
        "content": "<p>If you look at <a href=\"https://github.com/leanprover-community/mathlib4/pull/34228\">#34228</a> (which is now compiling) then you can see what I've done currently: we're still using quivers, but the hom sets are in <code>Type</code> not <code>Prop</code>, and I use <code>PLift.up</code> and <code>PLift.down</code> to move between them.</p>",
        "id": 569345549,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1769026055
    },
    {
        "content": "<p>It definitely looks the best solution, if we could avoid using Digraph it would be a smoother fix in my view. Thanks!</p>",
        "id": 569346179,
        "sender_full_name": "Matteo Cipollina",
        "timestamp": 1769026238
    },
    {
        "content": "<p>So what is wrong with Digraph? Looking at the repo you sent, you have this <code>@Quiver.Path</code> and <code>@Path</code> etc -- I suspect that here you're fighting the typeclass system, and presumably you won't have to do these <code>@</code>s if you use digraphs?</p>",
        "id": 569349692,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1769027451
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/lQQkb0Wsv7LH5UzIw61-Vgjz/Screenshot-2026-01-21-at-21.36.15.png\">Screenshot 2026-01-21 at 21.36.15.png</a><br>\nThe only thing wrong with Digraph was the lack of relevant API vs Quiver. It would have required providing  or porting from Quiver a lot of API</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/lQQkb0Wsv7LH5UzIw61-Vgjz/Screenshot-2026-01-21-at-21.36.15.png\" title=\"Screenshot 2026-01-21 at 21.36.15.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"352x535\" src=\"/user_uploads/thumbnail/3121/lQQkb0Wsv7LH5UzIw61-Vgjz/Screenshot-2026-01-21-at-21.36.15.png/840x560.webp\"></a></div>",
        "id": 569350916,
        "sender_full_name": "Matteo Cipollina",
        "timestamp": 1769027912
    },
    {
        "content": "<p>The standard procedure here would be to replace <code>def toQuiver (A : Matrix n n R) : Quiver n := ...</code> by the definition of a type synonym for <code>n</code> with <code>A</code> as a parameter and to set up a quiver structure on it.</p>",
        "id": 569352490,
        "sender_full_name": "Joël Riou",
        "timestamp": 1769028412
    },
    {
        "content": "<p>something like this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">module</span>\n\n<span class=\"n\">public</span><span class=\"w\"> </span><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Combinatorics</span><span class=\"bp\">.</span><span class=\"n\">Quiver</span><span class=\"bp\">.</span><span class=\"n\">ConnectedComponent</span>\n<span class=\"n\">public</span><span class=\"w\"> </span><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Combinatorics</span><span class=\"bp\">.</span><span class=\"n\">Quiver</span><span class=\"bp\">.</span><span class=\"n\">Path</span><span class=\"bp\">.</span><span class=\"n\">Vertices</span>\n<span class=\"n\">public</span><span class=\"w\"> </span><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Matrix</span><span class=\"bp\">.</span><span class=\"n\">Mul</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">expose</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"n\">public</span><span class=\"w\"> </span><span class=\"kn\">section</span>\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Matrix</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Quiver</span><span class=\"w\"> </span><span class=\"n\">Quiver</span><span class=\"bp\">.</span><span class=\"n\">Path</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearOrder</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> current definition</span>\n<span class=\"cm\">/-- The directed graph (quiver) associated with a matrix `A`,</span>\n<span class=\"cm\">with an edge `i ⟶ j` iff `0 &lt; A i j`. -/</span>\n<span class=\"cm\">def toQuiver (A : Matrix n n R) : Quiver n :=</span>\n<span class=\"cm\">  ⟨fun i j =&gt; 0 &lt; A i j⟩-/</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">MatrixQuiver</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Matrix</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Matrix</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Quiver</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MatrixQuiver</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">Hom</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span>\n\n<span class=\"sd\">/-- A matrix `A` is irreducible if it is entrywise nonnegative and</span>\n<span class=\"sd\">its quiver of positive entries (`toQuiver A`) is strongly connected. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">mk_iff</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">IsIrreducible</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Matrix</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">nonneg</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span>\n<span class=\"w\">  </span><span class=\"n\">connected</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">IsSStronglyConnected</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">inferInstanceAs</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Quiver</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MatrixQuiver</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)))</span>\n</code></pre></div>",
        "id": 569354439,
        "sender_full_name": "Matteo Cipollina",
        "timestamp": 1769029078
    },
    {
        "content": "<p>Yes, and at the end <code>IsSStronglyConnected (MatrixQuiver A)</code> should work.<br>\n(Note that after Kevin's refactor, you will have to lift<code>(0 &lt; A i j) : Prop</code> to <code>Type</code>.)</p>",
        "id": 569357632,
        "sender_full_name": "Joël Riou",
        "timestamp": 1769030135
    },
    {
        "content": "<p>That's assuming the refactor happens! This construction here seems to be an argument against it? But everywhere else in mathlib we are writing <code>Quiver.{v+1}</code>. If there were a refactor the other way -- someone came along and said \"I think Quiver homs should be Sort-valued, here's my PR, oh by the way I had to add 60 <code>+1</code>s\" then people would probably say \"I think that those 60 <code>+1</code>s are an indication that this is a bad idea\".</p>",
        "id": 569381768,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1769040138
    }
]