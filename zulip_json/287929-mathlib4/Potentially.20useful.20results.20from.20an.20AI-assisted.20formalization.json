[
    {
        "content": "<p>Hi everyone, while working on an experiment of mine, I ended up developing some general-purpose formalization that isn't specific to the experiment (<a href=\"https://github.com/marcellop71/EM\">repo here</a>, ~28,800 lines).</p>\n<p>I thought some of it might be of interest to the Mathlib community, so I put together a <a href=\"https://github.com/marcellop71/EM/blob/main/zulip_mathlib_candidates.md\">list of candidates</a> organized by topic.</p>\n<p>Areas include analytic number theory (large sieve, Van der Corput, Gauss sums, Parseval for finite groups), arithmetic functions, finite group theory, and various small lemmas.</p>\n<p>Worth noting: the Lean code was written by an agent swarm powered by Claude Opus 4.6, with my direction. I make no claims about Mathlib-readiness (conventions, style and organization of mathematical content), but if anything looks useful, I'd be happy to split things into small, focused PRs and adapt to the project's standards.</p>",
        "id": 576198206,
        "sender_full_name": "Marcello Paris",
        "timestamp": 1772178983
    },
    {
        "content": "<p>My first concern, looking at your \"list of candidates\", is that a large fraction of these results seem to duplicate (exactly or nearly) existing functionality in mathlib. E.g. we already have Cauchy-Schwartz, Mellin transforms, periodized Bernoulli functions, the Jacobi theta transformation law, etc.</p>",
        "id": 576205420,
        "sender_full_name": "David Loeffler",
        "timestamp": 1772181704
    },
    {
        "content": "<p>A second, and rather more serious, concern is that your repository doesn't seem to actually contain what you claim. Taking an example, you say \"you have formalized the Jacobi transformation law\". But the declaration in your file IKCh4.lean is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">JacobiThetaTransformation</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">    </span><span class=\"bp\">∑'</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">exp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">π</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">      </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">sqrt</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">∑'</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">exp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">π</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>That's not a theorem; it's a <em>statement</em> of a theorem, not its proof.  As a rule, Mathlib is not interested in collecting statements without proofs. Unless you can contribute proofs of these theorems, not just statements, there's nothing here that's mathlib-able.</p>\n<p>Most of the content of your files consists of <code>def</code>s like this; and sometimes you don't even have a proper statement, like this one (the next declaration after the above):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- Fejér kernel identity — IK (4.27). -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">FejerKernelIdentity</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">),</span>\n<span class=\"w\">    </span><span class=\"n\">True</span><span class=\"w\">  </span><span class=\"c1\">-- Poisson transform of Fejér pair</span>\n</code></pre></div>\n<p>I'm afraid that reading this codebase gives the strong impression that you are mechanically copy-pasting the output of an LLM without yourself really understanding what it <em>means</em> to formalize a theorem in Lean. Given that the mathlib code-review process has very strict standards and requires a lot of effort by highly qualified and distinctly overworked reviewers, I'm afraid it will take quite a bit of further work on your side before any of this can be seriously considered for a mathlib PR.</p>",
        "id": 576207649,
        "sender_full_name": "David Loeffler",
        "timestamp": 1772182495
    },
    {
        "content": "<p>Thank you for your feedback David. To give some context: my goal with this experiment is to understand how to design agent workflows that produce acceptable code and sound mathematical organization. The quality bar I'm measuring against is precisely Mathlib's -&gt; so when you point out that def X : Prop isn't a theorem, I am well aware of  that (but what I understand is not the point) : those are concrete failure modes I need to characterize and fix in the generation process.</p>\n<p>That said, I should have been much clearer about what the repo actually contains. Here's some stats I collected:</p>\n<p>981 proved theorems/lemmas<br>\n~190 def X : Prop — known results from Iwaniec-Kowalski stated without proof, not claimed as formalized: there are for the agents to continue their job<br>\n~50 def X : Prop — genuinely open hypotheses, used as antecedents in proved reduction chains (some of them proved false)</p>\n<p>The architecture is a reduction machine for a well-known conjectuure: its difficulty is one of the reasons that allowed the process to collect results. The def X : Prop declarations you flagged are the intentionally unproved nodes, either open conjectures or known results not yet in Mathlib that could be formalized in subsequent sessions.</p>\n<p>None of this changes your point that much of it may not be Mathlib-ready. But I wanted to correct the impression that the repo is mostly unproved statements, the bulk is proved reductions, and that's where any potentially reusable lemmas would live</p>",
        "id": 576224480,
        "sender_full_name": "Marcello Paris",
        "timestamp": 1772187638
    },
    {
        "content": "<p>The following is my personal opinion. I'm not speaking with my Mathlib maintainer hat on.</p>\n<p><span class=\"user-mention\" data-user-id=\"439429\">@Marcello Paris</span> It is too easy to generate code like this. It's not clear why people should spend time reviewing it. It's already been extremely generous of David that he looked at it in a fair amount of detail.</p>\n<p>Mathlib isn't interested in \"proved reductions\", unless this is about reducing an honest open conjecture to another honest open conjecture.<br>\nIf your formalize <code>P -&gt; Q</code> while there is a known proof of <code>P</code>, then this can happily live in a downstream repo, but not in Mathlib.</p>\n<p>AI's currently produce somewhat uncanny-valley like Lean code. But there is no point in risking Mathlib's carefully curated high quality status by mass-adopting AI-generated code that hasn't been battle-tested.</p>\n<p>AI's by construction produce code that <em>looks</em> like it is useful and polished.<br>\nSo it needs to go through extensive battle-testing to prove that it in fact is useful and polished.<br>\nI claim this should happen in \"production\" downstream of Mathlib.</p>",
        "id": 576230170,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1772189344
    },
    {
        "content": "<p>See also <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/channel/287929-mathlib4/topic/What.20to.20do.20with.20.22slop.22.20PRs/with/576217705\">#mathlib4 &gt; What to do with \"slop\" PRs</a></p>",
        "id": 576230227,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1772189361
    },
    {
        "content": "<p>Thank you both. To be clear: I'm not seeking to contribute to Mathlib, and I don't want to take up reviewer time. I posted this as a notification.</p>\n<p>A few thoughts on what's behind this, though:<br>\nIt's not that easy to get LLMs to generate this code: understanding how to direct agents toward an acceptable mixture of readable reasoning and more opaque but valid solutions, possibly with some mathematical organization.</p>\n<p>You mention \"battle-tested\" and \"carefully curated\": I find this genuinely interesting. If those criteria could be described more formally, it might eventually be possible to automate parts of quality assessment (kind of semantic diff against Mathlib, essentially). That would help downstream repos converge toward Mathlib standards before anyone asks for reviewer time.</p>\n<p>I understand your good point about battle-testing happening downstream. Whether a core-with-satellites model is the right long-term architecture is a separate question that could have different answers if taken from a mathematical or from a software engineering viewpoint.</p>\n<p>Anyway, the situation you're describing isn't specific to my repo. The volume of AI-generated code that's almost good enough is only going to increase. How formalization communities handle that is (I guess) an interesting open question.</p>",
        "id": 576270681,
        "sender_full_name": "Marcello Paris",
        "timestamp": 1772201497
    }
]