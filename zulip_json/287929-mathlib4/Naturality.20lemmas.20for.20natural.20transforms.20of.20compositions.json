[
    {
        "content": "<p>A pattern that occurs several times in the category theory library is that one has several functors, say <code>T : C‚ÇÅ ‚•§ C‚ÇÇ, L : C‚ÇÅ ‚•§ C‚ÇÉ, R : C‚ÇÇ ‚•§ C‚ÇÑ, B : C‚ÇÉ ‚•§ C‚ÇÑ</code>, and a natural transformation <code>Œ± : T ‚ãô R ‚Üí L ‚ãô B</code> (this is the litteral definition of a <code>TwoSquare</code>). Then within a proof, a <code>simp</code> call gets stuck on <code>R.map (T.map f) ‚â´ Œ±.app Y</code>, and can‚Äôt proceed further. Then what one usually does is a variation of the following pattern</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"bp\">.</span><span class=\"n\">naturality</span>\n<span class=\"w\">  </span><span class=\"n\">dsimp</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">this</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>to put this in a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>: the following example can‚Äôt be closed by a single <code>simp</code> call.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C‚ÇÅ</span><span class=\"w\"> </span><span class=\"n\">C‚ÇÇ</span><span class=\"w\"> </span><span class=\"n\">C‚ÇÉ</span><span class=\"w\"> </span><span class=\"n\">C‚ÇÑ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">C‚ÇÅ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">C‚ÇÇ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">C‚ÇÉ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">C‚ÇÑ</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C‚ÇÅ</span><span class=\"w\"> </span><span class=\"bp\">‚•§</span><span class=\"w\"> </span><span class=\"n\">C‚ÇÇ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C‚ÇÅ</span><span class=\"w\"> </span><span class=\"bp\">‚•§</span><span class=\"w\"> </span><span class=\"n\">C‚ÇÉ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C‚ÇÇ</span><span class=\"w\"> </span><span class=\"bp\">‚•§</span><span class=\"w\"> </span><span class=\"n\">C‚ÇÑ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C‚ÇÉ</span><span class=\"w\"> </span><span class=\"bp\">‚•§</span><span class=\"w\"> </span><span class=\"n\">C‚ÇÑ</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"bp\">‚ãô</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"bp\">‚ãô</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">‚¶É</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C‚ÇÅ</span><span class=\"o\">‚¶Ñ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">R</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"bp\">.</span><span class=\"n\">naturality</span>\n<span class=\"w\">  </span><span class=\"n\">dsimp</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">this</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Sure enough, other tactics, like <code>aesop</code> close this goal, and I‚Äôm sure <code>grind</code> will (and in this specific example, an <code>exact Œ±.naturality</code> also of course works), but when it shows up in more complex proofs not directly closed by these hammers, or if one wants to precisely rewrite, or use them in reverse direction, we‚Äôre out of luck and have to add a <code>have</code> anyway.</p>\n<p>This pattern occurs not only for two-squares, but for basically every natural transform that involves a composition of functors, or an identity functor. This is why e.g there are extra simp lemmas <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Adjunction.counit_naturality#doc\">docs#CategoryTheory.Adjunction.counit_naturality</a> that records the \"dsimped forms\" of naturality directly, I know I introduced some to get around some <code>erw</code>s.</p>\n<p>To ease automation, should we add some (<code>[reassoc]</code>and possibly <code>simp</code>) lemmas that restate the \"dsimped\" forms of general natural transformations of say, shape <code>T ‚ãô R ‚ü∂ L ‚ãô B</code>, <code> _ ‚ü∂ F ‚ãô G</code>, <code>G ‚ãô F ‚ü∂ _</code>, <code>F ‚ü∂ ùü≠ C‚ÇÇ</code> and <code>1 C‚ÇÅ ‚ü∂ _</code> and <code>_ ‚ü∂ ùü≠ C‚ÇÅ</code> (the last four might need extra overlap)?<br>\nThis is admittedly a rather \"bruteforce\" solution, but it seems to cover most of the use cases I could notice.</p>",
        "id": 522206299,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1748981072
    },
    {
        "content": "<p>It could make sense to have an option in <code>simp</code> for simplifying the lemmas that you pass to it. So then <code>simp [Œ±.naturality]</code> should be able to prove this goal.</p>",
        "id": 522231375,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1748992129
    },
    {
        "content": "<p>Also, please follow the <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> rules in the future to make it easier to run the minimal example</p>",
        "id": 522231887,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1748992406
    },
    {
        "content": "<p>I thought about a simproc, but then we wouldn't be able to use it in <code>rw</code>, right?<br>\nAlso, Sorry for the mwe, I forgot the imports and the universe variables... I'll update it.</p>",
        "id": 522232108,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1748992544
    },
    {
        "content": "<p>Actually, what about an elaborator? Something like <code>simp%</code>, and then if I write <code>simp% Œ±.naturality</code>, it elaborates to a proof of <code>‚àÄ ‚¶ÉX Y : C‚ÇÅ‚¶Ñ (f : X ‚ü∂ Y), R.map (T.map f) ‚â´ Œ±.app Y = Œ±.app X ‚â´ B.map (L.map f)</code></p>",
        "id": 522232444,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1748992731
    },
    {
        "content": "<p>That would work in <code>simp</code>, but is also useful in <code>rw</code>.</p>",
        "id": 522232628,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1748992828
    },
    {
        "content": "<p>I guess for maintainability reasons, the <code>dsimp%</code> version would be preferred, but that is enough for your example.</p>",
        "id": 522232720,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1748992877
    },
    {
        "content": "<p>It would be nice (and similar to the very nice <code>reassoc_of%</code> elaborator), but won't something as radical <code>simp%</code> be a \"hidden non-terminal simp\"?</p>",
        "id": 522232805,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1748992932
    },
    {
        "content": "<p>Yes exactly, that's what I meant with my last message. I think <code>simp%</code> and <code>dsimp%</code> would both be very nice, but <code>simp%</code> would count as a hidden non-terminal simp.</p>",
        "id": 522233099,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1748993099
    },
    {
        "content": "<p>Arguably, you'd want something a little more advanced than just a <code>dsimp%</code> in cases involving identities, since you might want to simplify identities using <code>Category.comp_id</code> or <code>Category.id_comp</code><br>\nMaybe a <code>cat_normalize%</code> that is a <code>simp only [..]</code> under the hood, where <code>[...]</code> is a curated category theory simp set?</p>",
        "id": 522233141,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1748993123
    },
    {
        "content": "<p>That sounds like a good idea</p>",
        "id": 522233288,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1748993203
    }
]