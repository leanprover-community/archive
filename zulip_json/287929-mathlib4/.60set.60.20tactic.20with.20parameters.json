[
    {
        "content": "<p>One nice feature of <code>have</code> and <code>let</code> is that they can now take parameters between the name and the colon:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">key</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">some_nice_property_of</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>How hard would it be to give <code>set</code> the same skills and powers?</p>",
        "id": 483451901,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1732098775
    },
    {
        "content": "<p>Yes, now that we have this feature in some places, I also want it everywhere :-)</p>\n<p>The place where I notice it most is the <code>{ foo := ... }</code> structure constructor notation, e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">≃</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">{</span>\n<span class=\"w\">    </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"c1\">-- unexpected token ':='; expected ':' or '}'</span>\n<span class=\"w\">    </span><span class=\"n\">invFun</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n<span class=\"w\">    </span><span class=\"n\">left_inv</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n<span class=\"w\">    </span><span class=\"n\">right_inv</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n<span class=\"w\">  </span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 483452638,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1732099039
    },
    {
        "content": "<p>Yup! That's another one!</p>",
        "id": 483452723,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1732099071
    },
    {
        "content": "<p>But it does work with <code>where</code>!</p>",
        "id": 483458145,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1732100820
    },
    {
        "content": "<p>But not with <code>where foo a := { ... }</code></p>",
        "id": 483458311,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1732100875
    },
    {
        "content": "<p><code>where</code> is good where <code>where</code> is valid</p>",
        "id": 483458547,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1732100951
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 483459156,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1732101143
    },
    {
        "content": "<p>There's an annoying ambiguity in the structure instance notation if we were to let the fields be more like the <code>where</code> clause. In particular if you want type ascriptions.</p>\n<p>This looks fine: <code>{ toFun x : Nat := _ }</code>, but what if you write</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n<span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>\n<p>The problem is that you can write <code>{ ... : S }</code> for <code>({ ... } : S)</code>.</p>\n<p>You could say \"only allow a type ascription on a field if a <code>:=</code> is present\" but then that needs a bit of lookahead. Maybe it's not so bad because in both cases it's looking for a term?</p>",
        "id": 483573573,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1732137698
    },
    {
        "content": "<p>I wouldn't phrase it quite like that, it's more like \"<code>:=</code> is always present\" except for the case of the name punning shorthand syntax (which already causes a conflict with set notation)</p>",
        "id": 483574502,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1732138094
    },
    {
        "content": "<p>At least the set notation is a different parser in the term category so we get disambiguation there, but for structure instance notation itself, I think it makes sense to talk about it like this with respect to this particular parser</p>",
        "id": 483574873,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1732138255
    },
    {
        "content": "<p>Maybe it would work to add <code>:</code> to the notFollowedBy list for <code>Lean.Parser.Term.structInstFieldAbbrev</code>?</p>",
        "id": 483575039,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1732138323
    },
    {
        "content": "<p>Does this actually cause backtracking? I think the parser will just handle this issue transparently, and there is no actual ambiguity here</p>",
        "id": 483575252,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1732138434
    },
    {
        "content": "<p>One problem is that if we're parsing <code>structInstFieldAbbrev &lt;|&gt; structInstField</code> starting from say <code>toFun x</code>, then the current definition will commit to <code>structInstFieldAbbrev</code> and say that <code>x</code> is unexpected.</p>\n<p>I think for parsing purposes we could allow <code>structInstFieldAbbrev</code> to take <code>ident</code> followed by any number of binders and then not followed by its current list plus <code>:</code>, all under <code>atomic</code>. That would keep it from committing to <code>structInstFieldAbbrev</code> if there is a trailing <code>:</code>, and then <code>structInstField</code> could allow this <code>:</code>, but then it requires <code>:=</code>.</p>\n<p>Actually, I guess the notFollowedBy list could also include binder rather than waiting until elaboration time to make the error.</p>",
        "id": 483597685,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1732150367
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60set.60.20tactic.20with.20parameters/near/483573573\">said</a>:</p>\n<blockquote>\n<p>The problem is that you can write <code>{ ... : S }</code> for <code>({ ... } : S)</code>.</p>\n</blockquote>\n<p>Is this actually desirable notation? I don't recall seeing it used anywhere, and it feels inconsistent with other ways to do type-ascriptions</p>",
        "id": 483634938,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1732175660
    },
    {
        "content": "<p>It certainly tripped me up when reading it the first time.</p>",
        "id": 483644411,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1732179453
    },
    {
        "content": "<p>In Lean 3 we had <code>{ S . ... }</code> which, although aobscure, at least had the advantage of not conflicting with any other notation</p>",
        "id": 483648581,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1732180844
    },
    {
        "content": "<p>note that the lean 3 notation was a bit different, <code>S</code> was just an identifier rather than the full type of the term</p>",
        "id": 483666242,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1732186466
    },
    {
        "content": "<p>I would be very happy to get rid of <code>{ ... : S }</code> if it means we can (more easily) have <code>{ toFun x := _ }</code>.</p>",
        "id": 483690019,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1732193972
    },
    {
        "content": "<p>The <code>{ ... : S }</code> notation turns out not to be a problem to get this to work. <a href=\"https://github.com/leanprover/lean4/pull/6165\">lean4#6165</a></p>\n<p>Example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">PosFun</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"w\">  </span><span class=\"n\">pos</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PosFun</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">    </span><span class=\"n\">pos</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 483803373,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1732229489
    },
    {
        "content": "<p>I wonder, would be make sense to allow <code>where</code> notation on the declarations in <code>where</code>? Are there any parsing ambiguities with this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">    </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">    </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n</code></pre></div>",
        "id": 483841293,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1732254447
    }
]