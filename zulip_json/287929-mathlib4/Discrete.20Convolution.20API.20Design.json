[
    {
        "content": "<p>This is a topic derived from my PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/33130\">#33130</a> where we formalized commutative unital Banach algebra structure of Cauchy product over l1 space. According to the feedback I got, there are two generalizations to be made to fit into Mathlib. </p>\n<ul>\n<li>Cauhcy product is specialized discrete convolution (finite support), but discrete convolution doesn't fit well in the existing <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Analysis/Convolution.html#MeasureTheory.convolution\">MeasureTheory.convolution</a> since a <code>[AddGroup]</code> structure is needed for operation <code>x ↦ ∫ f(t)g(x - t) ∂t</code> while the most common index ℕ is <code>[AddMonoid]</code>.</li>\n<li>For reasons above, Discrete convolution warrants its own API</li>\n</ul>\n<p>So there I go, I propose the following API design. </p>\n<h2>Basic setup</h2>\n<h3>Discrete Convolution</h3>\n<p>Given two functions <code>f, g : M → R</code> where <code>[Monoid M]</code> and <code>[Ring R]</code>, their convolution at a point <code>x</code> sums over all pairs <code>(a, b)</code> whose product equals <code>x</code> (<code>MulFiber</code>\\`AddFiber`):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">⋆</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)(</span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">∑</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"w\">            </span><span class=\"n\">a</span><span class=\"bp\">·</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>\n<h3>Typeclass Signature</h3>\n<table>\n<thead>\n<tr>\n<th>Variable</th>\n<th>Type</th>\n<th>Role</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>M</code></td>\n<td><code>[Monoid M]</code> or <code>[AddMonoid M]</code></td>\n<td>Index set; elements label \"positions\" (e.g., ℕ for polynomial degrees, G for group algebra basis)</td>\n</tr>\n<tr>\n<td><code>R</code></td>\n<td><code>[CommSemiring R]</code> or <code>[NormedCommRing R]</code></td>\n<td>Coefficient ring where function values live</td>\n</tr>\n<tr>\n<td><code>f</code>, <code>g</code></td>\n<td><code>M → R</code></td>\n<td>Input functions to convolve</td>\n</tr>\n<tr>\n<td><code>x</code></td>\n<td><code>M</code></td>\n<td>Point at which <code>(f ⋆ g)(x)</code> is evaluated</td>\n</tr>\n<tr>\n<td><code>a</code>, <code>b</code></td>\n<td><code>M</code></td>\n<td>Summation indices satisfying <code>a · b = x</code> (or <code>a + b = x</code> for additive)</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Generalized (bilinear) convolution:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Variable</th>\n<th>Type</th>\n<th>Role</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>S</code></td>\n<td><code>[CommSemiring S]</code></td>\n<td>Scalar ring for module structures</td>\n</tr>\n<tr>\n<td><code>E</code>, <code>E'</code>, <code>F</code></td>\n<td><code>[Module S E]</code>, etc.</td>\n<td>Codomains: <code>f : M → E</code>, <code>g : M → E'</code>, result in <code>F</code></td>\n</tr>\n<tr>\n<td><code>L</code></td>\n<td><code>E →ₗ[S] E' →ₗ[S] F</code></td>\n<td>Bilinear map combining values; e.g., <code>LinearMap.mul R R</code> for ring multiplication</td>\n</tr>\n</tbody>\n</table>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">###</span><span class=\"w\"> </span><span class=\"n\">Notations</span>\n\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Notation</span><span class=\"w\">     </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Index</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\">           </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Operation</span><span class=\"w\">                                       </span><span class=\"bp\">|</span>\n<span class=\"bp\">|</span><span class=\"c1\">--------------|----------------------|-------------------------------------------------|</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"ss\">`f</span><span class=\"w\"> </span><span class=\"bp\">⋆</span><span class=\"o\">[</span><span class=\"n\">L</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"bp\">`</span><span class=\"w\">   </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"ss\">`Monoid</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"bp\">`</span><span class=\"w\">           </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`∑'</span><span class=\"w\"> </span><span class=\"n\">ab</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">mulFiber</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">ab</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">ab</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"o\">)</span><span class=\"bp\">`</span><span class=\"w\">   </span><span class=\"bp\">|</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"ss\">`f</span><span class=\"w\"> </span><span class=\"bp\">⋆₊</span><span class=\"o\">[</span><span class=\"n\">L</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"bp\">`</span><span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"ss\">`AddMonoid</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"bp\">`</span><span class=\"w\">        </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`∑'</span><span class=\"w\"> </span><span class=\"n\">ab</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">addFiber</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">ab</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">ab</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"o\">)</span><span class=\"bp\">`</span><span class=\"w\">   </span><span class=\"bp\">|</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"ss\">`f</span><span class=\"w\"> </span><span class=\"bp\">⋆ₘ</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"bp\">`</span><span class=\"w\">     </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"ss\">`Monoid</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"bp\">`</span><span class=\"w\">           </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`∑'</span><span class=\"w\"> </span><span class=\"n\">ab</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">mulFiber</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">ab</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">ab</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"bp\">`</span><span class=\"w\">       </span><span class=\"bp\">|</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"ss\">`f</span><span class=\"w\"> </span><span class=\"bp\">⋆₊ₘ</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"bp\">`</span><span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"ss\">`AddMonoid</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"bp\">`</span><span class=\"w\">        </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`∑'</span><span class=\"w\"> </span><span class=\"n\">ab</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">addFiber</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">ab</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">ab</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"bp\">`</span><span class=\"w\">       </span><span class=\"bp\">|</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"ss\">`a</span><span class=\"w\"> </span><span class=\"bp\">⋆</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">`</span><span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"ss\">`HasAntidiagonal</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">`</span><span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`∑</span><span class=\"w\"> </span><span class=\"n\">kl</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">antidiagonal</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">kl</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">kl</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"bp\">`</span><span class=\"w\">        </span><span class=\"bp\">|</span>\n</code></pre></div>\n<h3>Examples (Semantic)</h3>\n<p><strong>Additive index <code>[AddMonoid ℕ]</code> (power series):</strong></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">⋆</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)(</span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">·</span><span class=\"n\">g</span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">·</span><span class=\"n\">g</span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"bp\">·</span><span class=\"n\">g</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"bp\">·</span><span class=\"n\">g</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>This is polynomial multiplication: if <code>f</code> and <code>g</code> represent coefficients, then <code>(f ⋆ g)(n)</code><br>\nis the n-th coefficient of the product.</p>\n<p><strong>Multiplicative index <code>[Group G]</code> (group algebras):</strong></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">⋆</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)(</span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">∑</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\">    </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"n\">over</span><span class=\"w\"> </span><span class=\"n\">all</span><span class=\"w\"> </span><span class=\"n\">pairs</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">·</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">            </span><span class=\"n\">a</span><span class=\"bp\">·</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>\n<h3>Cauchy Product as <code>[HasAntidiagonal]</code> type (Counterpart of <code>HasCompactSupport</code> in <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Analysis/Convolution.html#MeasureTheory.convolution\">MeasureTheory.convolution</a>)</h3>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">CauchyProduct</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddMonoid</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">HasAntidiagonal</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Semiring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- Cauchy product (convolution) via finite antidiagonal sum. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">∑</span><span class=\"w\"> </span><span class=\"n\">kl</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">antidiagonal</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">kl</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">kl</span><span class=\"bp\">.</span><span class=\"m\">2</span>\n\n<span class=\"c1\">-- code</span>\n\n<span class=\"sd\">/-- `addMulConvolution` equals `CauchyProduct.apply` for `HasAntidiagonal` types. -/</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">addMulConvolution_eq_cauchyProduct</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">⋆₊ₘ</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">CauchyProduct</span><span class=\"bp\">.</span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n</code></pre></div>\n<h2>Extendibility</h2>\n<p>As per <a href=\"https://github.com/leanprover-community/mathlib4/pull/30391#issuecomment-3694941192\">#30391</a>, this extends to weighted concatenation of languages via <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/FreeMonoid/Basic.html#FreeAddMonoid\">FreeAddMonoid</a>. </p>\n<h2>Current TODO</h2>\n<ul>\n<li>\n<p>Associativity for general bilinear maps (requires composition of bilinear maps);<br>\n  currently only proved for ℓ¹ ring multiplication in <code>LpOneBanachAlgebra.lean</code></p>\n</li>\n<li>\n<p>Bridge to <code>MeasureTheory.convolution</code>: prove <code>addMulConvolution f g =\n  MeasureTheory.convolution f g (.mul ℝ R) Measure.count</code> for <code>[AddGroup M]</code></p>\n</li>\n</ul>\n<h2>Concerns</h2>\n<ul>\n<li><strong>Notation collision</strong>: <code>⋆[L]</code> in discrete vs MeasureTheory (volume default)</li>\n<li>There are definitely more concerns. Haven't figured out how to put them down in words.</li>\n</ul>\n<p>I would love to hear your opinions on the current design. Where did I do well, where did I act silly, and what is the next step?</p>",
        "id": 565834311,
        "sender_full_name": "Fengyang Wang",
        "timestamp": 1767129209
    },
    {
        "content": "<p>Note that I have quite a bit about discrete convolution in APAP: <a href=\"https://yaeldillies.github.io/LeanAPAP/docs/LeanAPAP/Prereqs/Convolution/Discrete/Defs.html#conv\">https://yaeldillies.github.io/LeanAPAP/docs/LeanAPAP/Prereqs/Convolution/Discrete/Defs.html#conv</a></p>",
        "id": 565835647,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1767130296
    },
    {
        "content": "<p>I haven't pushed it to mathlib yet because I realised that in fact I wanted the compact convolution instead!</p>",
        "id": 565835680,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1767130329
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Discrete.20Convolution.20API.20Design/near/565835647\">said</a>:</p>\n<blockquote>\n<p>Note that I have quite a bit about discrete convolution in APAP: <a href=\"https://yaeldillies.github.io/LeanAPAP/docs/LeanAPAP/Prereqs/Convolution/Discrete/Defs.html#conv\">https://yaeldillies.github.io/LeanAPAP/docs/LeanAPAP/Prereqs/Convolution/Discrete/Defs.html#conv</a></p>\n</blockquote>\n<p>Thank you! A key difference of the two approaches, according to the feedback I got from code reviews, we would like a discrete conv API for <code>[Monoid M]</code> and <code>tsum</code>. Your implementation is definitely enlightening. I'd like to know how you would like me to note if I were to carry over some functionalities from your implementation of discrete convolution?</p>",
        "id": 565836294,
        "sender_full_name": "Fengyang Wang",
        "timestamp": 1767130852
    },
    {
        "content": "<p><code>tsum</code> is indeed the furthest you can go with the counting measure, but generality wasn't the only main concern in my case: I wanted something usable for the purpose of additive combinatorics, with as few unnecessary requirements (such as summability) as possible. What do you want to use the discrete convolution for?</p>",
        "id": 565836431,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1767130999
    },
    {
        "content": "<p>Mainly for establishing the Banach algebra structure of l1 space (initially weighted l1 norm) w.r.t. Cauchy product (dis. conv. w/ fin. supp.) in Mathlin (Analysis/Lp), but ended up needing to develop a whole API to make the maintainers happy. A notable use is this new implementation of a more general discrete conv. can be used in weighted concatenation of languages via List ~ free additive monoid.</p>",
        "id": 565836693,
        "sender_full_name": "Fengyang Wang",
        "timestamp": 1767131242
    }
]