[
    {
        "content": "<p>Minimal working example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span>\n</code></pre></div>\n<p>Hover over the 2 in the exponent in each line, and observe that the types are ℝ and ℂ respectively. The expected types are ℕ and ℕ. A practical example where this causes an issue is the following, taken from <em>Lean for the Curious Mathematician</em>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- This does not work.</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">w</span> <span class=\"bp\">=</span> <span class=\"n\">z</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">z</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">w</span> <span class=\"bp\">-</span> <span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">polyrith</span>  <span class=\"c1\">-- polyrith failed to retrieve a solution from Sage! ValueError: polynomial is not in the ideal</span>\n\n<span class=\"c1\">-- This works.</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">w</span> <span class=\"bp\">=</span> <span class=\"n\">z</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">z</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">w</span> <span class=\"bp\">-</span> <span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">norm_cast</span> <span class=\"n\">at</span> <span class=\"n\">h₁</span> <span class=\"n\">h₂</span>\n  <span class=\"n\">polyrith</span>  <span class=\"c1\">-- Try this: linear_combination w * h₁ + y * h₂</span>\n</code></pre></div>",
        "id": 392868555,
        "sender_full_name": "Yongyi Chen",
        "timestamp": 1695590249
    },
    {
        "content": "<p>This is a known issue: <a href=\"https://github.com/leanprover/lean4/pull/2220\">lean4#2220</a></p>\n<p>There is a mathlib override in the WIP branch <a href=\"https://github.com/leanprover-community/mathlib4/pull/6852\">mathlib4#6852</a>. If you import the Mathlib/binop2.lean file you'll get Real^Nat rather than Real^Real.</p>",
        "id": 392869122,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1695590658
    },
    {
        "content": "<p>There's also a <code>local macro_rules | `($x ^ $y) =&gt; `(HPow.hPow $x $y)</code> workaround you can see in current mathlib, but this completely turns off the coercion propagation features for <code>^</code> notation and can lead to unexpected results.</p>",
        "id": 392869229,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1695590800
    },
    {
        "content": "<p>OK, good to know!</p>",
        "id": 392875645,
        "sender_full_name": "Yongyi Chen",
        "timestamp": 1695598305
    }
]