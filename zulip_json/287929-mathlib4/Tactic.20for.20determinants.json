[
    {
        "content": "<p>While working on Cartan matrix theorems for exceptional Lie algebras (<a href=\"https://github.com/leanprover-community/mathlib4/pull/33115\">#33115</a>), we encountered a limitation with <code>decide</code> for computing determinants of larger matrices.<br>\nThe situation:</p>\n<ul>\n<li>\n<p><code>G₂.det = 1</code> (2×2): <code>decide</code> works </p>\n</li>\n<li>\n<p><code>F₄.det = 1</code> (4×4): <code>decide</code> works</p>\n</li>\n<li>\n<p><code>E₆.det = 3</code> (6×6): <code>decide</code> fails (max recursion depth)</p>\n</li>\n<li>\n<p><code>E₇.det = 2</code> (7×7): <code>decide</code> fails</p>\n</li>\n<li>\n<p><code>E₈.det = 1</code> (8×8): <code>decide</code> fails</p>\n</li>\n</ul>\n<p>These are integer matrices with small entries (only 0, ±1, ±2, ±3), so the computation is straightforward by hand. We've added these as <code>proof_wanted</code> for now.<br>\nIs there interest in developing a more efficient determinant tactic? Possible approaches:</p>\n<ul>\n<li>Cofactor expansion with better evaluation strategy </li>\n<li>LU decomposition for integer matrices</li>\n<li>Exploiting sparsity (Cartan matrices are tridiagonal-ish)</li>\n</ul>\n<p>The matrices are defined in <code>Mathlib.Algebra.Lie.CartanMatrix</code> if anyone wants to experiment. Happy to help test any proposed solutions.</p>",
        "id": 566213060,
        "sender_full_name": "Jonathan Reich",
        "timestamp": 1767522116
    },
    {
        "content": "<p>How far do <code>simp</code> and <code>norm_num</code> get? (Possibly specifying the \"determinant is a sum\" lemma)</p>",
        "id": 566216153,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1767525691
    },
    {
        "content": "<p>Thanks @Ruben Van de Velde. I tested a few approaches:<br>\n<strong><code>simp</code>/<code>norm_num</code></strong>: Haven't found the right lemma combination yet. Do you have a specific determinant expansion lemma in mind? <br>\n<strong><code>native_decide</code></strong> (discovered while testing):</p>\n<ul>\n<li>\n<p>E₆.det = 3 works</p>\n</li>\n<li>\n<p>E₇.det = 2 works</p>\n</li>\n<li>\n<p>E₈.det = 1 fails (too many IR definitions)   </p>\n</li>\n</ul>\n<p>The difference from what I can gather from <code>decide</code> is that <code>native_decide</code> compiles to native code, bypassing kernel recursion limits.</p>\n<p>So we can fill in E₆ and E₇ with <code>native_decide</code>. E₈ still needs something smarter - maybe the determinant expansion lemmas you mentioned?</p>",
        "id": 566216832,
        "sender_full_name": "Jonathan Reich",
        "timestamp": 1767526634
    },
    {
        "content": "<p>The <code>native_decide</code> tactic is not allowed in mathlib.</p>",
        "id": 566216958,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1767526772
    },
    {
        "content": "<p>Ah, good to know <code>native_decide</code> isn't allowed in mathlib. Thanks for the heads up.</p>\n<p>So we're still looking for a proper solution. <code>simp</code> alone doesn't get far. Do you have a specific lemma in mind for the determinant expansion? Something like repeatedly applying <code>Matrix.det_succ_column_zero</code> for cofactor expansion?</p>\n<p>For now the PR keeps these as <code>proof_wanted</code>. Happy to implement whatever approach is recommended.</p>",
        "id": 566217106,
        "sender_full_name": "Jonathan Reich",
        "timestamp": 1767526933
    },
    {
        "content": "<p>That was a fun nerd snipe :) it occurred to me that you could write the L and U matrices for say E₈ and have Lean verify that <code>L*U = E₈</code>. The time complexity for a general matrix <code>M</code> would be O(n^3) (bottleneck is verifying that LU = M), which is the same as finding the decomposition, but the code to do so can live outside Lean.</p>\n<p>So here's a <a href=\"https://gist.github.com/ldct/7e33691388de6795dd4db051d9315fd5\">proof</a> that  <code>E₆.det = 3, E₇.det = 2</code>.</p>\n<p>Unfortunately L and U are necessarily matrices over ℚ, the proof for <code>det_map_ℚ</code> is pretty horrible, and there's something strange going on with <code>prod_helper</code> that screws up the proof for E₈.</p>",
        "id": 566227065,
        "sender_full_name": "Li Xuanji",
        "timestamp": 1767538036
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308587\">Li Xuanji</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Tactic.20for.20determinants/near/566227065\">said</a>:</p>\n<blockquote>\n<p>The time complexity for a general matrix <code>M</code> would be O(n^3)</p>\n</blockquote>\n<p>Technically it's O(n^2.38) <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 566227942,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1767538838
    },
    {
        "content": "<p>Thanks @Li Xuanji - this is really elegant! The LU verification approach is exactly what's needed.</p>\n<p>For the E₈ <code>prod_helper</code> issue - have you tried just <code>exact Matrix.det_mul L₈ U₈</code>? Curious if it's a timeout or something more subtle with the 8×8 case? Anyway, I'm sure you tried this.</p>\n<p>Are you going to PR this directly to close out the <code>proof_wanted</code> items, or should we coordinate? Either way is good with me =)</p>",
        "id": 566228096,
        "sender_full_name": "Jonathan Reich",
        "timestamp": 1767538999
    },
    {
        "content": "<p>Feel free to take my code and do whatever you want, including opening a PR! I have no plans to do so</p>",
        "id": 566228188,
        "sender_full_name": "Li Xuanji",
        "timestamp": 1767539105
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308587\">Li Xuanji</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Tactic.20for.20determinants/near/566227065\">said</a>:</p>\n<blockquote>\n<p>the proof for <code>det_map_ℚ</code> is pretty horrible</p>\n</blockquote>\n<p>This golfs to</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">det_map_ℚ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Matrix</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Int</span><span class=\"bp\">.</span><span class=\"n\">castRingHom</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">det</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">det</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Int</span><span class=\"bp\">.</span><span class=\"n\">cast_det</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">symm</span>\n</code></pre></div>\n<p>(<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Int.cast_det#doc\">docs#Int.cast_det</a>)</p>",
        "id": 566228755,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1767539545
    },
    {
        "content": "<p>It's very impressive, and great work by <span class=\"user-mention\" data-user-id=\"308587\">@Li Xuanji</span> that we have proofs for the determinants. Thanks!</p>\n<p>However I'm not absolutely sure we want these in Mathlib (I might feel different if / when we need to know these results for an application). What we really want is a tactic.</p>",
        "id": 566240426,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1767551071
    },
    {
        "content": "<p>Incidentally if we were to go down the adhoc route of custom proofs for these matrices, it seems to me that <code>E₈</code> could be the easiest: because its determinant is 1, the inverse will be a matrix of integers so if we supply this data in the proof and calculate that the product of <code>E₈</code> with its inverse is 1 then using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Matrix.det_mul#doc\">docs#Matrix.det_mul</a> we immediately get that the determinant of <code>E₈</code> divides 1 in the integers, so we have it up to a sign.</p>",
        "id": 566240629,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1767551244
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/KkITfz4d5MM2ttwrLlbYTQCk/det_lu.lean\">det_lu.lean</a><br>\nI've spent a bit of time on this. </p>\n<p>The LU approach works almost perfectly. I have:</p>\n<ul>\n<li>\n<p><code>L₈</code> and <code>U₈</code> defined as the lower and upper triangular factors over ℚ</p>\n</li>\n<li>\n<p><code>E₈_lu : E₈Q = L₈ * U₈</code> — compiles fine</p>\n</li>\n<li>\n<p><code>L₈_det : L₈.det = 1</code> — proven via <code>det_of_lowerTriangular</code> + <code>norm_num</code></p>\n</li>\n<li>\n<p><code>U₈_det : U₈.det = 1</code> — proven via <code>det_of_upperTriangular</code> + <code>norm_num</code></p>\n</li>\n<li>\n<p><code>E₈_det_eq_one_or_neg_one</code> — proven using the integer inverse (which also compiles)</p>\n</li>\n</ul>\n<p>The problem is the final connection step. Any attempt to <em>use</em> <code>E₈_lu</code> in a subsequent proof causes a stack overflow in the kernel. I tried:</p>\n<ul>\n<li>\n<p><code>congrArg Matrix.det E₈_lu</code> then rewriting</p>\n</li>\n<li>\n<p>Direct <code>rw [E₈_lu]</code></p>\n</li>\n<li>\n<p><code>calc</code> chains</p>\n</li>\n<li>\n<p>Various <code>maxRecDepth</code> and <code>maxHeartbeats</code> settings (up to 50k/2M)</p>\n</li>\n</ul>\n<p>All hit stack overflow, not just recursion depth limits.</p>\n<p>I also tried the modular arithmetic route: compute <code>det(E₈)</code> in ZMod 3 (where 1 ≠ -1) using <code>decide</code>. This also fails with stack overflow / timeout as the 8! = 40,320 permutations in the Leibniz formula are too much even for a small finite field.</p>\n<p>The proof is verified in pieces. The kernel just can't verify the equality <code>E₈Q = L₈ * U₈</code> efficiently enough to use it in a subsequent theorem. This really does seem to need a dedicated determinant tactic that can exploit sparsity or use LU decomposition without requiring kernel verification of the full matrix product.</p>\n<p>For now I've left it as <code>proof_wanted</code> with the LU infrastructure in place for when such a tactic exists. If others have more thoughts on how to make progress on this,  please let me know.</p>",
        "id": 566275064,
        "sender_full_name": "Jonathan Reich",
        "timestamp": 1767587870
    },
    {
        "content": "<p>Yeah, I can see why having random LU factorizations in Mathlib might not be desired.</p>\n<p>Would Mathlib welcome a tactic to compute determinants of <code>Matrix (Fin n) (Fin n) ℚ</code> (0 &lt; n) which internally computes the LU factorization? I can forsee that users not understanding why it doesn't work for finite fields, or ℚ[i], or ℚ[√2]... I'm not totally sure what the most general type over which this would work is, it seems to be some kind of field with computable field operations and equality.</p>\n<blockquote>\n<p>Technically it's O(n^2.38) <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>\n</blockquote>\n<p>I meant that my proof that <code>L*U = E₆</code> is O(n^3) if generalized to larger matrices. It would be fun to write a different O(n^2.38) proof and see if it has an actual speedup for concrete matrices <span aria-label=\"smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"smile\">:smile:</span> </p>\n<blockquote>\n<p>Curious if it's a timeout or something more subtle with the 8×8 case?</p>\n</blockquote>\n<p>I get a <code>(kernel) deep recursion detected</code> even in term mode</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">prod_helper</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L₈</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">U₈</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">det</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">L₈</span><span class=\"bp\">.</span><span class=\"n\">det</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">U₈</span><span class=\"bp\">.</span><span class=\"n\">det</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Matrix</span><span class=\"bp\">.</span><span class=\"n\">det_mul</span><span class=\"w\"> </span><span class=\"n\">L₈</span><span class=\"w\"> </span><span class=\"n\">U₈</span>\n</code></pre></div>\n<p>I think the definition of <code>det</code> might be getting unfolded for concrete matrices.</p>",
        "id": 566275478,
        "sender_full_name": "Li Xuanji",
        "timestamp": 1767588237
    },
    {
        "content": "<p>The <code>(kernel) deep recursion detected</code> error is pretty bad. I've opened <a href=\"https://github.com/leanprover-community/mathlib4/pull/33590\">#33590</a> to address this.</p>\n<p>It is likely that deeper issues exist (e.g., perhaps some day somebody working with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MultilinearMap.alternatization#doc\">docs#MultilinearMap.alternatization</a> on a large concrete matrix might hit a similar issue) but making <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Matrix.det#doc\">docs#Matrix.det</a> into a <code>def</code> makes sense in its own right so I think we can probably merge this.</p>",
        "id": 566311598,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1767606452
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308587\">Li Xuanji</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Tactic.20for.20determinants/near/566275478\">said</a>:</p>\n<blockquote>\n<p>Would Mathlib welcome a tactic to compute determinants of <code>Matrix (Fin n) (Fin n) ℚ</code> (0 &lt; n) which internally computes the LU factorization? I can forsee that users not understanding why it doesn't work for finite fields, or ℚ[i], or ℚ[√2]... I'm not totally sure what the most general type over which this would work is, it seems to be some kind of field with computable field operations and equality.</p>\n</blockquote>\n<p>Yes we absolutely would love to have such a tactic. Regarding coefficients, I expect it should be similar to <code>norm_num</code>: general coefficients are fine as long as you don't expect it to do anything fancy for non-integral elements of your ring.</p>",
        "id": 566312548,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1767606746
    },
    {
        "content": "<p>Probably this shouldn't be a tactic but a simproc! See <a href=\"http://leanprover-community.github.io/blog\">the blog</a></p>",
        "id": 566313093,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1767606922
    },
    {
        "content": "<blockquote>\n<p>Regarding coefficients, I expect it should be similar to <code>norm_num</code>: general coefficients are fine as long as you don't expect it to do anything fancy for non-integral elements of your ring.</p>\n</blockquote>\n<p>The issue I am thinking of is with these two matrices</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Matrix</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">A'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Matrix</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">det</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">A'</span><span class=\"bp\">.</span><span class=\"n\">det</span>\n</code></pre></div>\n<p>I'm not really sure how to compute that A' is lower triangular since (for e.g.) <code>#eval A' 0 0</code> fails.</p>\n<p>In any case, I am very unlikely to have time to try to write a simproc, so anyone reading should feel free to give it a shot <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 566331791,
        "sender_full_name": "Li Xuanji",
        "timestamp": 1767612716
    },
    {
        "content": "<p>I'm not sure how strictly to interpret your use of the word \"compute\" but I'll just note in passing that it is trivial to \"prove\" that <code>A'</code> is lower triangular:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.Data.Real.Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.LinearAlgebra.Matrix.Block</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Matrix</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">A'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Matrix</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n\n<span class=\"c1\">-- `A'` is upper triangular</span>\n<span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A'.BlockTriangular</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"n\">hij</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">aesop</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">A'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Matrix.one_apply</span><span class=\"o\">])</span>\n\n<span class=\"c1\">-- `A'` is lower triangular (unsure of idiomatic spelling)</span>\n<span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A'</span><span class=\"bp\">ᵀ.</span><span class=\"n\">BlockTriangular</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"n\">hij</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">aesop</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">A'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Matrix.one_apply</span><span class=\"o\">])</span>\n</code></pre></div>",
        "id": 566336564,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1767614395
    },
    {
        "content": "<p>I have a proof of the determinant of a matrix corresponding to E8 in the sphere packing project, and a prototype implementation for much larger matrices elsewhere too. (In fact I also have a prototype for the same thing with real interval matrices, giving an interval output too)</p>",
        "id": 566381542,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1767627304
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"240862\">Oliver Nash</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Tactic.20for.20determinants/near/566311598\">said</a>:</p>\n<blockquote>\n<p>The <code>(kernel) deep recursion detected</code> error is pretty bad. I've opened <a href=\"https://github.com/leanprover-community/mathlib4/pull/33590\">#33590</a> to address this.</p>\n<p>It is likely that deeper issues exist (e.g., perhaps some day somebody working with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MultilinearMap.alternatization#doc\">docs#MultilinearMap.alternatization</a> on a large concrete matrix might hit a similar issue) but making <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Matrix.det#doc\">docs#Matrix.det</a> into a <code>def</code> makes sense in its own right so I think we can probably merge this.</p>\n</blockquote>\n<p>This exact issue was discussed on zulip a few months ago (and first noticed here <a href=\"#narrow/channel/287929-mathlib4/topic/kernel.20deep.20recursion.20detected/near/453282247\">https://leanprover.zulipchat.com/#narrow/channel/287929-mathlib4/topic/kernel.20deep.20recursion.20detected/near/453282247</a>): it's specific to large concrete real matrices, and making it a def does indeed fix this, but when I tried to do so last time it had other unfortunate consequences. Maybe those are gone now though?</p>",
        "id": 566382034,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1767627420
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> there seemed to be no negative consequences of making <code>Matrix.det</code> a <code>def</code>. It solves the issue here though not the root cause. I'll comment further in the other thread from ~18 months ago (active again less than three months ago) which I hadn't seen before.</p>",
        "id": 566403698,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1767633476
    },
    {
        "content": "<p>I know this is not a tactic either, but I couldn't help myself:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">E₈_det_aux</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Matrix</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">updateRow</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">det</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hij</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">det</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">det_updateRow_add</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">det_updateRow_smul</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">det_updateRow_eq_zero</span><span class=\"w\"> </span><span class=\"n\">hij</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">updateRow_eq_self</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">add_zero</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mul_zero</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mul_eq_mul_left_iff</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">or_false</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">h</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">E₈_det</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">E₈</span><span class=\"bp\">.</span><span class=\"n\">det</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">E₈_det_aux</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">:</span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">ℤ</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">E₈_det_aux</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">:</span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">ℤ</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">E₈_det_aux</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">:</span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">:</span><span class=\"n\">ℤ</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">E₈_det_aux</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">5</span><span class=\"o\">:</span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">ℤ</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">E₈_det_aux</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">4</span><span class=\"o\">:</span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">ℤ</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">E₈_det_aux</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">:</span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">ℤ</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">E₈_det_aux</span><span class=\"w\"> </span><span class=\"mi\">7</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">:</span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">ℤ</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Matrix</span><span class=\"bp\">.</span><span class=\"n\">det_of_upperTriangular</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"n\">kernel</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">BlockTriangular</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"n\">kernel</span>\n</code></pre></div>\n<p>Note that the intermediate goals are completely unreadable.</p>",
        "id": 567684593,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1768280147
    }
]