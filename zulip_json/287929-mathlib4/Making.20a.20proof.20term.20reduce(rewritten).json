[
    {
        "content": "<p>This is a rewritten version of a question I asked yesterday. I was asked by  @<strong>Adam Topaz </strong> to provide a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> . I have added it to the bottow.  I also decided to add some background information to why the question is relevant .<br>\n<strong>Background</strong><br>\nA while ago I  had some problems with the lean implementationof the core of a category. I asked here and got a nice answer from  @<strong>Kim Morrison </strong> and @<strong>Joel Riou</strong> to reimplement it similarly to how the opposite category is implemented by embedding the original category . I started by copying <code>Oppopsite.lean, </code> but didn't like that my code was 90% cut and paste. Also, it is a common pattern in functional languages to make a copy of a type under a new name, so I thought it would be a nice chance to learn some meta programming in Lean. </p>\n<p>I now have a first implementation. It does introduce a layer of abstraction to how the original <code>Opposite.lean</code> was implemented.  I recompiled Mathlib with my new version of <code>Opposite.lean</code> and it  got stuck in a proof in <code>Opposites.lean</code> where simp did not progress in my reimplemented version. I tracked the problem down to a change in the proof of one of the lemmas <code>op_unop</code>. The lemma is identical, of course, only the proof is changed from rfl to something using my new abstractions.  I simulate the issue in the question below by adding a structure with the  rfl, so that the proof is now just a selector from this structure (see below). It is difficult for me to make a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> that showes precisely why simp no longer makes a progress. The proof objects in Opposites.lean printed with pp.all are two pages long and I am not able to precisely pinpoint what the issue is. I understand from surfing around in that it sometimes happens that a proof that involves dependent types sometimes don't go throuh when a proof object it depends on is changed, even though it proves precisely the same theorem. In my illustration below that is the only change, so I assume that it pinpoints the problem. So,  if I could just make Lean reduce the proof term of my new proof  of  op_unop below, to the rfl it reduces to, the problem should be solved.</p>\n<p><strong>My original formulation of the problem</strong><br>\nI have problems with a proof term that does not simplify if a proof of a lemma is changed.<br>\nI have tried to add the hint reducible, but it makes no difference. Is there some other way to guarantee that a proof of a theorem is maxiamally reduced? Or some other solution?<br>\nHere is a condensed version of what goes wrong:<br>\nIn <code>Mathlib.Data.Opposite</code> if I change</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">op_unop</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"bp\">·µí·µñ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">unop</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>to </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">testC</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"bp\">·µí·µñ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">   </span><span class=\"n\">out</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">unop</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">reducible</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">testC1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"bp\">·µí·µñ</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">testC</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">out</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">}</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">op_unop</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"bp\">·µí·µñ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">unop</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">testC1</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">out</span>\n</code></pre></div>\n<p>then a  proof in Opposites.lean goes wrong because simp can no longer simplify an expression.<br>\nThe theorem that goes wrong is </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">unop</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"bp\">·µí·µñ</span><span class=\"w\"> </span><span class=\"bp\">‚âå</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"bp\">·µí·µñ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚âå</span><span class=\"w\"> </span><span class=\"n\">D</span>\n</code></pre></div>\n<p>where the last simp in the proof does not make any progress. <br>\nA simplified example of what goes wrong is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"bp\">·µí·µñ</span><span class=\"w\"> </span><span class=\"bp\">‚âå</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"bp\">·µí·µñ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">functor</span><span class=\"bp\">.</span><span class=\"n\">unop</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">NatIso</span><span class=\"bp\">.</span><span class=\"n\">unop</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">unitIso</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"bp\">.</span><span class=\"n\">hom</span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span>\n<span class=\"w\">  ¬†</span><span class=\"o\">(</span><span class=\"n\">NatIso</span><span class=\"bp\">.</span><span class=\"n\">unop</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">counitIso</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"bp\">.</span><span class=\"n\">hom</span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">functor</span><span class=\"bp\">.</span><span class=\"n\">unop</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">    </span><span class=\"mi\">ùüô</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">functor</span><span class=\"bp\">.</span><span class=\"n\">unop</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">   </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Quiver</span><span class=\"bp\">.</span><span class=\"n\">Hom</span><span class=\"bp\">.</span><span class=\"n\">op_inj</span>\n<span class=\"w\">   </span><span class=\"n\">dsimp</span>\n<span class=\"w\">   </span><span class=\"n\">simp</span>\n</code></pre></div>\n<p><strong>My attempt at <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> of the issue to reduce a proof term</strong></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">iseq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">testC</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">   </span><span class=\"n\">out</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">reducible</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">testC1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">testC</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">out</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">}</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">should_be_rfl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">testC1</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">out</span>\n\n<span class=\"w\"> </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">is_rfl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n\n<span class=\"c1\">-- I want the proof term of should_be_rfl to be identical to is_rfl</span>\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">should_be_rfl</span><span class=\"w\"> </span><span class=\"c1\">-- fun Œ± x ‚Ü¶ (testC1 Œ± x).out</span>\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">is_rfl</span><span class=\"w\"> </span><span class=\"c1\">-- fun Œ± x ‚Ü¶ rfl</span>\n</code></pre></div>",
        "id": 451182598,
        "sender_full_name": "Dan Synek",
        "timestamp": 1720882168
    },
    {
        "content": "<p>Can you provide a self-contained <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> please?</p>",
        "id": 451186876,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1720883793
    },
    {
        "content": "<p>Note that Lean treats <code>simp</code> lemmas proved by <code>rfl</code> a bit differently. E.g., the <code>dsimp</code> tactic can use them. This tactic just replaces the goal with the simplified version, without using any congruence lemmas.</p>",
        "id": 451222246,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1720901794
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span> So, if it turns out that I cannot reduce the proof term to rfl, do you have a pointer to how  I can prove the test lemma above? I tried using substitution, but got  a error message  ['rewrite' failed, motive is not type correct]</p>",
        "id": 451335931,
        "sender_full_name": "Dan Synek",
        "timestamp": 1720947329
    },
    {
        "content": "<p>I don't understand the question yet. The proof of <code>should_be_rfl</code> is indeed <code>rfl</code>. What am I missing?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">testC1</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">out</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 451340710,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1720951374
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  Yes, also <code>example(x :Œ±·µí·µñ ) : (@testC1 Œ± x).out = rfl := rfl</code> is provable in my original code above (you can try yourself by adding it to Opposite.lean), but still exchanging one for the other makes the proof of the <code>test</code> theorem go through in the refl case but not the other.</p>",
        "id": 451357500,
        "sender_full_name": "Dan Synek",
        "timestamp": 1720966097
    },
    {
        "content": "<p>Can you make an <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> with a lemma you can't prove?</p>",
        "id": 451358354,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1720967018
    },
    {
        "content": "<p>I guess the thing I don't understand here is the first premise. You said that if you turn</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">op_unop</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"bp\">·µí·µñ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">unop</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>to</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">testC</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"bp\">·µí·µñ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">   </span><span class=\"n\">out</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">unop</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>\n<p>then things go wrong. But <code>testC</code> is a completely unmotivated structure, and removing a simp lemma will of course make things go wrong. I think I'm just not on the right wavelength for this question yet.</p>",
        "id": 451358993,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1720967664
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span>  I did make the test lemma in the code above which is relatively short. To try it,  checkout a fresh copy of Mathlib, exchange the  <code>theorem op_unop (x : Œ±·µí·µñ) : op (unop x) = x := rfl</code> line in <code>Mathlib/Data/Opposite.lean</code> to </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">testC</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"bp\">·µí·µñ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">   </span><span class=\"n\">out</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">unop</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">reducible</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">testC1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"bp\">·µí·µñ</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">testC</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">out</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">}</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">op_unop</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"bp\">·µí·µñ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">unop</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">testC1</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">out</span>\n</code></pre></div>\n<p>recompile Mathlab and you will get an error on the proof of <code>`def unop (e : C·µí·µñ ‚âå D·µí·µñ) : C ‚âå D</code> in <code>Mathlib/CategoryTheory/Opposites.lean</code> I simplified that to the test definition above which you can insert at the same section as the theorem.</p>\n<p>I will try to make an isolated example that doesn't depend on Mathlib, but even getting this far has been difficult for a relative beginner as I am, so it might take time (and there is no guarantee I will succeed)</p>",
        "id": 451359029,
        "sender_full_name": "Dan Synek",
        "timestamp": 1720967732
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"698527\">Dan Synek</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Making.20a.20proof.20term.20reduce.28rewritten.29/near/451335931\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> So, if it turns out that I cannot reduce the proof term to rfl</p>\n</blockquote>\n<p>For <code>dsimp</code>, it isn't important if the proof term <em>reduces</em> to <code>rfl</code>. It's important if it's literally <code>rfl</code>.</p>",
        "id": 451359031,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1720967740
    },
    {
        "content": "<p>That's because Mathlib relies on <code>op_unop</code> being a <code>dsimp</code> lemma.</p>",
        "id": 451359095,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1720967790
    },
    {
        "content": "<p>Why do you want to modify <code>Opposites</code> in this way?</p>",
        "id": 451359116,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1720967822
    },
    {
        "content": "<p>Oh -- something which might be confusing you -- in this definition which is bothering you</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚•§</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"bp\">·µí·µñ</span><span class=\"w\"> </span><span class=\"bp\">‚•§</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"bp\">·µí·µñ</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">unop</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">unop</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">op</span>\n</code></pre></div>\n<p>there are two proofs which are hidden from you: the two axioms <code>map_id</code> and <code>map_comp</code> of a functor. They are being proved by <code>aesop_cat</code> (they are omitted completely in the code, and are hence being proved by a given default tactic, which for <code>Functor</code> is <code>aesop_cat</code>), and your change is changing the behaviour of <code>dsimp</code> and hence, presumably, of this more high-powered tactic.</p>",
        "id": 451359250,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1720967992
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> the testC structure is a simplification of the  class I introduced to abstract from the Opposite definition. I made it as simple as I could, so of course it looks unmotivated. The isue is quiet natural and I think it must occur often. You abstract from a specific implementation, but retain the theorems. Naively, you would expect that as long as you prove the same theorems, the proofs that depend on them would remain provable, but in this case that is not the case. .</p>",
        "id": 451359358,
        "sender_full_name": "Dan Synek",
        "timestamp": 1720968095
    },
    {
        "content": "<p>But you're not leaving the system in the same state that it was, you're just leaving it in a similar state :-)</p>",
        "id": 451359433,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1720968186
    },
    {
        "content": "<p>Currently, category theory relies on <code>unop_op</code> being a <code>rfl</code> lemma all over the place. With dependent type theory, changing <code>rfl</code>/non-<code>rfl</code> can be important, if the term appears in the <em>type</em> of something else.</p>",
        "id": 451359437,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1720968198
    },
    {
        "content": "<p>E.g., if you have <code>(f : Œ± ‚Üí Type*) (x : Œ±) (y : f x) (z : f (unop (op x)))</code>, then without <code>unop_op</code> being a <code>rfl</code> lemma, you can't even write <code>y = z</code>, you have to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=HEq#doc\">docs#HEq</a> instead.</p>",
        "id": 451361125,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1720968889
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span>  Why do you want to modify¬†<code>Opposites</code>¬†in this way?<br>\nSo what I actually did was to make a macro (I called newtype) that makes a structure like the one used in Opposite.lean but with new names for constructos and the type.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Opposite</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- The canonical map `Œ± ‚Üí Œ±·µí·µñ`. -/</span>\n<span class=\"w\">  </span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"bp\">::</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- The canonical map `Œ±·µí·µñ ‚Üí Œ±`. -/</span>\n<span class=\"w\">  </span><span class=\"n\">unop</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span>\n</code></pre></div>\n<p>I then make an abstract versions of the lemmas proved in Opposite.lean. I  reimplementf the original Opposite by applying my macro and instantiating the abstracted theorems. In this way the proof  that used to be ref in Opposite.lean are now the proofs of my abstract theorems instantiated to the Opposite I generated with my macro(and naively should be reducible to rfl). </p>\n<p>Of course I am not sure that this is a good project that should be pushed into the main branch, even though it was an interesting project for me. But it is worrying that there is a lack of referential transparency in substituting a proof to another proof of a lemma. Most of the time in mathematics, you wouldn't want a theorem to depend on a particular proof of the lemmas it uses. Also, my project is still doable, I just have to move all the theorems into the macro, so that they are reproved every time a new instantiation is done. I wantedt avoid this, since it is not much better than the cut and paste I started  with...</p>\n<p>When you write:<br>\nE.g., if you have¬†<code>(f : Œ± ‚Üí Type*) (x : Œ±) (y : f x) (z : f (unop (op x)))</code>, then without¬†<code>unop_op</code>¬†being a¬†<code>rfl</code>¬†lemma, you can't even write¬†<code>y = z</code>, you have to use¬†<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=HEq#doc\">docs#HEq</a>¬†instead.<br>\nIs this true, even if the proof object reduces to rfl. But equality in type theory is a difficult subject, so I guess I am missing something.</p>",
        "id": 451361780,
        "sender_full_name": "Dan Synek",
        "timestamp": 1720969546
    },
    {
        "content": "<p>If you want to autogenerate types like <code>Opposite</code>, then you should make sure that the lemmas like <code>unop_op</code> are proved by <code>rfl</code>, not something else. Otherwise <code>dsimp</code> won't use them.</p>",
        "id": 451365630,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1720973552
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span>    I can't say I understand exactly what is going on, but I will continue my project by generatig the proof in my macro to avoid the extra level of abstraction, which should solve the acute issues. You have been very helpful, so yet again the Lean community has been great! I will mark it as resolved, though I think it does point at a problem with the category theory implementation of Lean.</p>",
        "id": 451367768,
        "sender_full_name": "Dan Synek",
        "timestamp": 1720975861
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"698527\">Dan Synek</span> has marked this topic as resolved.</p>",
        "id": 451367779,
        "sender_full_name": "Notification Bot",
        "timestamp": 1720975870
    },
    {
        "content": "<p>Here's another explanation, since this is something that people working on the category theory library have found they need to understand:</p>\n<p>If a <code>@[simp]</code> theorem is literally proved with <code>rfl</code> or <code>Iff.rfl</code>, it is marked as being a \"<code>dsimp</code> theorem\". These mark that the LHS and RHS are defeq, meaning that the LHS can <em>always</em> be replaced with the RHS no matter the context. Using <code>rfl</code>/<code>Iff.rfl</code> is also a marker by the user that they want this behavior.</p>\n<p>Normally, <code>simp</code> can only rewrite in some contexts. Those contexts are constrained by the structure of congruence lemmas it generates. Dependent types prevent certain arguments from being rewritten by <code>simp</code> (for example, if there is an argument <code>A : Type</code> and an argument <code>x : A</code>, then usually only <code>x</code> will be rewritable by the general <code>simp</code> set). The non-rewritable arguments will be rewritten using the <code>dsimp</code> algorithm. All this complexity is due to the difference between definitional equality and propositional equality.</p>\n<p>This doesn't have anything to do with proof reduction. Usually Lean doesn't reduce proofs, and it even avoids reducing them if it can help it. Note that the proof of a <code>dsimp</code> theorem doesn't matter: you can always replace the proof with <code>rfl</code>/<code>Iff.rfl</code> and see if it succeeds, and if it does then proof irrelevance says that this new proof is defeq to the old one. In principle, <code>@[simp]</code> could try re-proving a theorem with <code>rfl</code>/<code>Iff.rfl</code> when it decides what counts as a dsimp theorem, but it's at least more predictable that it looks for literally one of these proofs.</p>",
        "id": 451370565,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1720978968
    },
    {
        "content": "<p>BTW, sometimes I wish we had an attribute for \"this is a generic lemma, but in practice it's usually a <code>rfl</code>, so let <code>dsimp</code> try to use it\".</p>",
        "id": 451371378,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1720979918
    },
    {
        "content": "<p>This would make it possible to add a generic <code>DFunLike.add_apply</code> lemma that uses a (not yet existing) <code>DFunLike.PointwiseAdd</code> typeclass but is usable for <code>dsimp</code> for specific types.</p>",
        "id": 451371483,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1720980018
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/287929-mathlib4/topic/.E2.9C.94.20Making.20a.20proof.20term.20reduce.28rewritten.29/near/451371378\">said</a>:</p>\n<blockquote>\n<p>BTW, sometimes I wish we had an attribute for \"this is a generic lemma, but in practice it's usually a <code>rfl</code>, so let <code>dsimp</code> try to use it\".</p>\n</blockquote>\n<p>Do I understand correctly that if I had a way of saying that \"try to use this lemma as if it was proved by rfl\" it would solve my problem since when applying the lemma it would actually be reduced to rfl.</p>",
        "id": 451435708,
        "sender_full_name": "Dan Synek",
        "timestamp": 1721030655
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> <br>\nI find this topic interestingand would like to understand it better.<br>\nCold you expand on this:<br>\n<code>you can always replace the proof with¬†</code>rfl<code>/</code>Iff.rfl<code>¬†and see if it succeeds, and if it does then proof irrelevance says that this new proof is defeq to the old one.</code><br>\nWhat does \"it\" refer to in your explanation. The theorem we are proving or the lemma we are using?</p>",
        "id": 451437669,
        "sender_full_name": "Dan Synek",
        "timestamp": 1721031194
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"698527\">Dan Synek</span> has marked this topic as unresolved.</p>",
        "id": 451439496,
        "sender_full_name": "Notification Bot",
        "timestamp": 1721031765
    },
    {
        "content": "<p>\"it succeeds\" -&gt; \"whether <code>rfl</code>/<code>Iff.rfl</code> can typecheck as a proof for the theorem\"</p>\n<p>In other words, when <code>@[simp]</code> processes a lemma, it could check for itself whether the LHS and RHS are defeq, and if so add it to the list of dsimp lemmas. Note that dsimp lemmas don't need proofs, since they're all lemmas whose LHS and RHS are defeq, so <code>rfl</code>/<code>Iff.rfl</code> may always be used to synthesize a proof as needed.</p>",
        "id": 451572918,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1721065995
    },
    {
        "content": "<p>That's supposing that at declaration time the LHS and RHS are defeq and you just didn't realize it yet.</p>",
        "id": 451573279,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1721066052
    },
    {
        "content": "<p>Yury's idea is interesting, where at dsimp application time, you can have it attempt to apply certain simp lemmas in addition to the dsimp lemmas, where the simp lemma only succeeds if the new term is defeq to the old one.</p>",
        "id": 451573592,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1721066110
    }
]