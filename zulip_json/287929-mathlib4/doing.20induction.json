[
    {
        "content": "<p>Imagine I want to prove a property of x : A, and I have a function f : A -&gt; B, where B is well ordered. Can I do it by induction, thanks to some ‘termination-by‘ stuff? But I can't understand what I need to fill in. (This is to prove 'euclDivd‘ in  <a href=\"https://github.com/leanprover-community/mathlib4/tree/ACL%2FCombNS\">branch#ACL/CombNS</a>)</p>",
        "id": 466315888,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1725039614
    },
    {
        "content": "<p>A mwe could be</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\"> </span><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Init</span><span class=\"bp\">.</span><span class=\"n\">WF</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">hasP</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">WellFounded</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>where, in the proof, I only apply <code>hasP</code> to elements <code>b : A</code> such that <code>r b a</code>.</p>",
        "id": 466317836,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1725040472
    },
    {
        "content": "<p>The mwe theorem is false (<code>P</code> could be <code>fun a =&gt; False</code>)...?</p>",
        "id": 466321281,
        "sender_full_name": "Bjørn Kjos-Hanssen",
        "timestamp": 1725041857
    },
    {
        "content": "<p>Have you seen <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/WF.html#WellFounded.induction\"><code>WellFounded.induction</code></a>?</p>\n<p>I guess in your mwe you meant <code>P</code> and <code>f</code> to not be part of the theorem and instead something you defined yourself?</p>",
        "id": 466322170,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1725042279
    },
    {
        "content": "<p>i'd guess you need a statement saying that <code>r</code> is wellfounded on the range of <code>f</code>, along with a statement like <code>wf_hyp : ∀ a, (∀ a', r (f a') (f a) → P a') → P a</code></p>",
        "id": 466322703,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1725042520
    },
    {
        "content": "<p>i think the first part is easily satisfied if <code>r</code> is a transitive relation?</p>",
        "id": 466322784,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1725042564
    },
    {
        "content": "<p>i'm not very sure though</p>",
        "id": 466322822,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1725042587
    },
    {
        "content": "<p>You can indeed use termination by.<br>\nSo just write the proof as usual, and put a sorry to get rid of the termination goal. Then focus on it separately when you are done</p>",
        "id": 466327458,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1725044609
    },
    {
        "content": "<p>You can also use <code>decreasing_by</code> to apply your <code>f</code></p>",
        "id": 466327594,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1725044669
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"728068\">Giacomo Stevanato</span> <a href=\"#narrow/stream/287929-mathlib4/topic/doing.20induction/near/466322170\">said</a>:</p>\n<blockquote>\n<p>Have you seen <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/WF.html#WellFounded.induction\"><code>WellFounded.induction</code></a>?</p>\n<p>I guess in your mwe you meant <code>P</code> and <code>f</code> to not be part of the theorem and instead something you defined yourself?</p>\n</blockquote>\n<p>In my not minimal example (see <a href=\"https://github.com/leanprover-community/mathlib4/tree/ACL%2FCombNS\">branch#ACL/CombNS</a>), <code>f</code>is a multivariate polynomial and <code>P</code> is a complicated property, so <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=WellFounded.induction#doc\">docs#WellFounded.induction</a> does not immediately apply. Of course, I could set up some induction procedure, but my point was to have it on the spot, just having a function applying itself recursively, while checking that the things I apply it to are always strictly smaller than my initial stuff.</p>",
        "id": 466501074,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1725097579
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130609\">Antoine Chambert-Loir</span> <a href=\"#narrow/stream/287929-mathlib4/topic/doing.20induction/near/466501074\">said</a>:</p>\n<blockquote>\n<p><code>f</code>is a multivariate polynomial and <code>P</code> is a complicated property, so <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=WellFounded.induction#doc\">docs#WellFounded.induction</a> does not immediately apply.</p>\n</blockquote>\n<p>I'm not sure why you think that is the case. From a quick glance it seems you should be able to apply it right after creating the instance of the well-founded relation.</p>",
        "id": 466531005,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1725109652
    },
    {
        "content": "<p>Sometimes <code>induction</code> lemmas don't like playing nice with <code>apply</code>, so you might want to use the <code>induction</code> or <code>refine</code> tactics with them instead.</p>",
        "id": 466531260,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725109714
    },
    {
        "content": "<p>This seems to work for me:</p>\n<div class=\"codehilite\" data-code-language=\"Diff\"><pre><span></span><code><span class=\"gh\">diff --git a/Mathlib/Combinatorics/Nullstellensatz.lean b/Mathlib/Combinatorics/Nullstellensatz.lean</span>\n<span class=\"gh\">index 5b39e4d..18410f3 100644</span>\n<span class=\"gd\">--- a/Mathlib/Combinatorics/Nullstellensatz.lean</span>\n<span class=\"gi\">+++ b/Mathlib/Combinatorics/Nullstellensatz.lean</span>\n<span class=\"gu\">@@ -624,9 +624,11 @@ theorem euclDivd (S : σ → Finset R) (Sne : ∀ i, (S i).Nonempty) (f : MvPoly</span>\n<span class=\"w\"> </span>      (∀ i, (h i * (S i).prod (fun (s : R) ↦ (X i - C s))).totalDegree ≤ f.totalDegree) ∧\n<span class=\"w\"> </span>      (∀ i, r.weightedTotalDegree (Finsupp.single i 1) &lt; (S i).card) := by\n<span class=\"w\"> </span>  letI : LinearOrder σ := WellOrderingRel.isWellOrder.linearOrder\n<span class=\"gd\">-  haveI wfr : WellFoundedRelation (MvPolynomial σ R) := {</span>\n<span class=\"gi\">+  let wfr : WellFoundedRelation (MvPolynomial σ R) := {</span>\n<span class=\"w\"> </span>    rel := Function.onFun (· &lt; ·) fun f ↦ f.lexHomDegree\n<span class=\"w\"> </span>    wf := WellFounded.onFun wellFounded_lt }\n<span class=\"gi\">+  apply wfr.wf.induction f</span>\n<span class=\"gi\">+  intro f h_ind</span>\n<span class=\"w\"> </span>  by_cases hD0 : f.lexHomDegree = ⊥\n<span class=\"w\"> </span>  · use fun _ ↦ 0, f\n<span class=\"w\"> </span>    rw [lexHomDegree_eq_bot_iff] at hD0\n<span class=\"gu\">@@ -663,7 +665,7 @@ theorem euclDivd (S : σ → Finset R) (Sne : ∀ i, (S i).Nonempty) (f : MvPoly</span>\n<span class=\"w\"> </span>      rw [lt_iff_le_and_ne, ← hd]\n<span class=\"w\"> </span>      exact ⟨le_lexHomDegree hc.2, fun h ↦ hc.1 (toLexHom.injective h)⟩\n<span class=\"w\"> </span>    · exact Ne.bot_lt' fun a ↦ hD0 a.symm\n<span class=\"gd\">-  obtain ⟨h', r', Hf', Hh', Hr'⟩ := euclDivd S Sne f' -- hf'D</span>\n<span class=\"gi\">+  obtain ⟨h', r', Hf', Hh', Hr'⟩ := h_ind f' hf'D</span>\n<span class=\"w\"> </span>  by_cases H : ∀ i, d i &lt; (S i).card\n<span class=\"w\"> </span>  · -- First case, the monomial `d` is small, we just add it to the remainder\n<span class=\"w\"> </span>    use h', r' + monomial d (f.coeff d)\n<span class=\"gu\">@@ -782,7 +784,7 @@ theorem euclDivd (S : σ → Finset R) (Sne : ∀ i, (S i).Nonempty) (f : MvPoly</span>\n<span class=\"w\"> </span>      left\n<span class=\"w\"> </span>      simp only [lexHomDegree_degree]\n<span class=\"w\"> </span>      exact hf''_degree\n<span class=\"gd\">-    obtain ⟨h'', r'', Hf'', Hh'', Hr''⟩ := euclDivd S Sne f'' -- hf''2</span>\n<span class=\"gi\">+    obtain ⟨h'', r'', Hf'', Hh'', Hr''⟩ := h_ind f'' hf''2</span>\n<span class=\"w\"> </span>    use h' + h'' + single i (monomial d' (f.coeff d)), r' + r''\n<span class=\"w\"> </span>    constructor\n<span class=\"w\"> </span>    · nth_rewrite 1 [hf, Hf', hf'', Hf'']\n</code></pre></div>",
        "id": 466531356,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1725109745
    },
    {
        "content": "<p>A similar thing worked for me as well (see commented out code just below), but I expected to be able to do it differently, by using directly the function on smaller arguments.</p>",
        "id": 466532191,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1725109932
    },
    {
        "content": "<p>FYI <code>WellFoundedRelation</code> is probably not what you want to be using. The purpose of that typeclass is to establish a default well-founded relation for the termination checker whenever you're working with a certain type. If you just want a well-founded predicate you can use <code>WellFounded</code>, and if you want a bundled version that works with typeclass inference you can use <code>IsWellFounded</code> or something stronger like <code>WellFoundedLT</code> or <code>IsWellOrder</code>.</p>",
        "id": 466532495,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725109997
    },
    {
        "content": "<p>I had used <code>IsWellFounded</code> but devised an additional induction theorem for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MvPolynomial#doc\">docs#MvPolynomial</a> for lexicographic order (see the commented out proof of <code>euclDivd</code> in the branch). My question (sorry if I didn't make myself clearer) came out of wondering whether this additional theorem was indeed necessary or if it is possible to prove a theorem directly along the lines of the current attempt. <br>\nMaybe the difficulty is that I use the function twice, for two different arguments <code>f'</code> and <code>f''</code>, each of them smaller than the initial one. Possibly, <code>terminating_by</code> doesn't understand what I need.</p>\n<p>By the way, the error message is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Not</span><span class=\"w\"> </span><span class=\"n\">considering</span><span class=\"w\"> </span><span class=\"n\">parameter</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">MvPolynomial</span><span class=\"bp\">.</span><span class=\"n\">euclDivd</span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">it</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">unchanged</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">recursive</span><span class=\"w\"> </span><span class=\"n\">calls</span>\n<span class=\"n\">Not</span><span class=\"w\"> </span><span class=\"n\">considering</span><span class=\"w\"> </span><span class=\"n\">parameter</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">MvPolynomial</span><span class=\"bp\">.</span><span class=\"n\">euclDivd</span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">it</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">unchanged</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">recursive</span><span class=\"w\"> </span><span class=\"n\">calls</span>\n<span class=\"n\">Not</span><span class=\"w\"> </span><span class=\"n\">considering</span><span class=\"w\"> </span><span class=\"n\">parameter</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">MvPolynomial</span><span class=\"bp\">.</span><span class=\"n\">euclDivd</span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">it</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">unchanged</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">recursive</span><span class=\"w\"> </span><span class=\"n\">calls</span>\n<span class=\"n\">Not</span><span class=\"w\"> </span><span class=\"n\">considering</span><span class=\"w\"> </span><span class=\"n\">parameter</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">MvPolynomial</span><span class=\"bp\">.</span><span class=\"n\">euclDivd</span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">it</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">unchanged</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">recursive</span><span class=\"w\"> </span><span class=\"n\">calls</span>\n<span class=\"n\">Not</span><span class=\"w\"> </span><span class=\"n\">considering</span><span class=\"w\"> </span><span class=\"n\">parameter</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">MvPolynomial</span><span class=\"bp\">.</span><span class=\"n\">euclDivd</span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">it</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">unchanged</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">recursive</span><span class=\"w\"> </span><span class=\"n\">calls</span>\n<span class=\"n\">Not</span><span class=\"w\"> </span><span class=\"n\">considering</span><span class=\"w\"> </span><span class=\"n\">parameter</span><span class=\"w\"> </span><span class=\"n\">Sne</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">MvPolynomial</span><span class=\"bp\">.</span><span class=\"n\">euclDivd</span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">it</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">unchanged</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">recursive</span><span class=\"w\"> </span><span class=\"n\">calls</span>\n<span class=\"n\">Cannot</span><span class=\"w\"> </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">parameter</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"bp\">→₀</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→₀</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">does</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">`.</span><span class=\"n\">brecOn</span><span class=\"bp\">`</span><span class=\"w\"> </span><span class=\"n\">recursor</span>\n\n\n<span class=\"n\">Could</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">find</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">decreasing</span><span class=\"w\"> </span><span class=\"n\">measure</span><span class=\"bp\">.</span>\n<span class=\"n\">The</span><span class=\"w\"> </span><span class=\"n\">arguments</span><span class=\"w\"> </span><span class=\"n\">relate</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">each</span><span class=\"w\"> </span><span class=\"n\">recursive</span><span class=\"w\"> </span><span class=\"n\">call</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"n\">follows</span><span class=\"o\">:</span>\n<span class=\"o\">(</span><span class=\"bp\">&lt;</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">relation</span><span class=\"w\"> </span><span class=\"n\">proved</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"n\">all</span><span class=\"w\"> </span><span class=\"n\">proofs</span><span class=\"w\"> </span><span class=\"n\">failed</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">no</span><span class=\"w\"> </span><span class=\"n\">proof</span><span class=\"w\"> </span><span class=\"n\">attempted</span><span class=\"o\">)</span>\n\n<span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">666</span><span class=\"o\">:</span><span class=\"mi\">36</span><span class=\"bp\">-</span><span class=\"mi\">53</span>\n<span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">785</span><span class=\"o\">:</span><span class=\"mi\">43</span><span class=\"bp\">-</span><span class=\"mi\">61</span>\n<span class=\"n\">Please</span><span class=\"w\"> </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"ss\">`termination_by</span><span class=\"bp\">`</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">specify</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">decreasing</span><span class=\"w\"> </span><span class=\"n\">measure</span><span class=\"bp\">.</span>\n</code></pre></div>\n<p>and the decreasing measures are proved in <code>hf'D : f'.lexHomDegree &lt; f.lexHomDegree</code> (just before line 666) and  <code>hf''2 : f''.lexHomDegree &lt; f.lexHomDegree</code> (just before line 785). In both cases, <code>MvPolynomial.lexHomDegree</code> is a function from <code>MvPolynomial α R</code> to a type synonym <code>LexHom (α →₀ N)</code> of monomials <code>α →₀ N</code> but endowed with a well ordering (see instance on line 199, <code>WellFoundedLT (LexHom (α →₀ N))</code>.</p>",
        "id": 466535538,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1725110704
    },
    {
        "content": "<p>I believe you need to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/Batteries/WF.html#WellFounded.wrap\"><code>WellFounded.wrap</code></a> to use an arbitrary <code>WellFounded</code> relation with <code>termination_by</code> (or add an <code>instance</code> for that <code>WellFoundedRelation</code> outside the theorem, but this should be cleaner):</p>\n<div class=\"codehilite\" data-code-language=\"Diff\"><pre><span></span><code><span class=\"gh\">diff --git a/Mathlib/Combinatorics/Nullstellensatz.lean b/Mathlib/Combinatorics/Nullstellensatz.lean</span>\n<span class=\"gh\">index 5b39e4d..eb0ef5b 100644</span>\n<span class=\"gd\">--- a/Mathlib/Combinatorics/Nullstellensatz.lean</span>\n<span class=\"gi\">+++ b/Mathlib/Combinatorics/Nullstellensatz.lean</span>\n<span class=\"gu\">@@ -618,15 +618,13 @@ lemma prod_totalDegree [Nontrivial R] {ι : Type*} (i : ι) (s : Finset R) :</span>\n<span class=\"w\"> </span>  rw [mem_support_iff, prod_leadCoeff]\n<span class=\"w\"> </span>  exact one_ne_zero\n\n<span class=\"gi\">+noncomputable instance : LinearOrder σ := WellOrderingRel.isWellOrder.linearOrder</span>\n<span class=\"gi\">+</span>\n<span class=\"w\"> </span>theorem euclDivd (S : σ → Finset R) (Sne : ∀ i, (S i).Nonempty) (f : MvPolynomial σ R) :\n<span class=\"w\"> </span>    ∃ (h : σ → MvPolynomial σ R) (r : MvPolynomial σ R),\n<span class=\"w\"> </span>      f = Finset.univ.sum (fun i =&gt; (h i) * (S i).prod (fun (s : R) ↦ (X i - C s))) + r ∧\n<span class=\"w\"> </span>      (∀ i, (h i * (S i).prod (fun (s : R) ↦ (X i - C s))).totalDegree ≤ f.totalDegree) ∧\n<span class=\"w\"> </span>      (∀ i, r.weightedTotalDegree (Finsupp.single i 1) &lt; (S i).card) := by\n<span class=\"gd\">-  letI : LinearOrder σ := WellOrderingRel.isWellOrder.linearOrder</span>\n<span class=\"gd\">-  haveI wfr : WellFoundedRelation (MvPolynomial σ R) := {</span>\n<span class=\"gd\">-    rel := Function.onFun (· &lt; ·) fun f ↦ f.lexHomDegree</span>\n<span class=\"gd\">-    wf := WellFounded.onFun wellFounded_lt }</span>\n<span class=\"w\"> </span>  by_cases hD0 : f.lexHomDegree = ⊥\n<span class=\"w\"> </span>  · use fun _ ↦ 0, f\n<span class=\"w\"> </span>    rw [lexHomDegree_eq_bot_iff] at hD0\n<span class=\"gu\">@@ -654,7 +652,7 @@ theorem euclDivd (S : σ → Finset R) (Sne : ∀ i, (S i).Nonempty) (f : MvPoly</span>\n<span class=\"w\"> </span>    split_ifs with h\n<span class=\"w\"> </span>    · simp [h]\n<span class=\"w\"> </span>    · simp [sub_zero, Ne.symm h]\n<span class=\"gd\">-  haveI hf'D : f'.lexHomDegree &lt; f.lexHomDegree := by</span>\n<span class=\"gi\">+  have : f'.lexHomDegree &lt; f.lexHomDegree := by</span>\n<span class=\"w\"> </span>    rw [hd]\n<span class=\"w\"> </span>    unfold lexHomDegree\n<span class=\"w\"> </span>    rw [Finset.sup_lt_iff]\n<span class=\"gu\">@@ -777,7 +775,7 @@ theorem euclDivd (S : σ → Finset R) (Sne : ∀ i, (S i).Nonempty) (f : MvPoly</span>\n<span class=\"w\"> </span>        apply lt_of_lt_of_le (b := (S i).card)\n<span class=\"w\"> </span>        simp only [bot_eq_zero', Finset.card_pos, Sne i]\n<span class=\"w\"> </span>        exact Nat.le_add_left (S i).card d'.degree\n<span class=\"gd\">-    haveI hf''2 : f''.lexHomDegree &lt; f.lexHomDegree := by</span>\n<span class=\"gi\">+    have : f''.lexHomDegree &lt; f.lexHomDegree := by</span>\n<span class=\"w\"> </span>      rw [LexHom.lt_iff]\n<span class=\"w\"> </span>      left\n<span class=\"w\"> </span>      simp only [lexHomDegree_degree]\n<span class=\"gu\">@@ -834,6 +832,8 @@ theorem euclDivd (S : σ → Finset R) (Sne : ∀ i, (S i).Nonempty) (f : MvPoly</span>\n<span class=\"w\"> </span>      apply lt_of_le_of_lt (weightedTotalDegree_add _)\n<span class=\"w\"> </span>      simp only [sup_lt_iff]\n<span class=\"w\"> </span>      exact ⟨Hr' i, Hr'' i⟩\n<span class=\"gi\">+termination_by LexHom.wellFoundedLT.wf.wrap f.lexHomDegree</span>\n<span class=\"gi\">+decreasing_by repeat assumption</span>\n\n<span class=\"w\"> </span>/- -- OLD VERSION\n<span class=\"w\"> </span>theorem euclDivd (S : σ → Finset R) (Sne : ∀ i, (S i).Nonempty)\n</code></pre></div>",
        "id": 466542249,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1725112285
    },
    {
        "content": "<p>Thanks a lot, that's exactly the kind of things I expected was possible.<br>\n(<code>repeat assumption</code> did not work, though, but I could insert the proofs at this place.)</p>",
        "id": 466545981,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1725113160
    }
]