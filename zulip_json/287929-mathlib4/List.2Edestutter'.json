[
    {
        "content": "<p>I'm looking at <span class=\"user-mention\" data-user-id=\"448405\">@Alex Meiburg</span> 's <a href=\"https://github.com/leanprover-community/mathlib4/pull/9082\">#9082</a> and I wonder why <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.destutter%27#doc\">docs#List.destutter'</a> works as a special case of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.destutter#doc\">docs#List.destutter</a> . I think that we'll get better lemmas if we drop <code>a</code> from the answer. What do you think?</p>",
        "id": 481530177,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1731217583
    },
    {
        "content": "<p>E.g., with the current definition we have</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">tail_destutter'_congr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">destutter'</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">destutter'</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n</code></pre></div>\n<p>and we'll be able to drop <code>tail</code> if we drop the head from the output of <code>List.destutter'</code>.</p>",
        "id": 481530300,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1731217696
    },
    {
        "content": "<p>AFAICT, this is an auxiliary definition which is only used to prove properties of <code>List.destutter</code>, so I assume that we can change its definition without worrying about backwards compatibility too much.</p>",
        "id": 481530364,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1731217777
    },
    {
        "content": "<p>Yeah, it was much easier to develop the theory with having <code>destutter'</code> around, much like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.Chain%27#doc\">docs#List.Chain'</a>. At least, that was my experience whilst writing it.</p>",
        "id": 481608188,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1731282342
    },
    {
        "content": "<p>Another question: since we don't hardcode <code>R = \\ne</code>, should we call it something like <code>List.greedyChain</code> instead of <code>destutter</code>?</p>",
        "id": 481620262,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1731292528
    },
    {
        "content": "<p>It can be used, e.g., to construct monotone chains too.</p>",
        "id": 481620274,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1731292550
    },
    {
        "content": "<p>Another question: should we rename <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.Chain%27#doc\">docs#List.Chain'</a> to <code>Chain</code> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.Chain#doc\">docs#List.Chain</a> to something else?</p>",
        "id": 481630939,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1731299990
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/channel/287929-mathlib4/topic/List.2Edestutter'/near/481630939\">said</a>:</p>\n<blockquote>\n<p>Another question: should we rename <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.Chain%27#doc\">docs#List.Chain'</a> to <code>Chain</code> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.Chain#doc\">docs#List.Chain</a> to something else?</p>\n</blockquote>\n<p>That would be great, I'm tired of having to fight the docPrime linter every time I write anything involving pairwise relations...</p>",
        "id": 481856093,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1731381714
    },
    {
        "content": "<p>Maybe <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.Chain#doc\">docs#List.Chain</a> can be <code>List.ChainWith</code>?</p>",
        "id": 481856273,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1731381802
    },
    {
        "content": "<p>In fact, I don't understand why we need it at all.</p>",
        "id": 481856319,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1731381828
    },
    {
        "content": "<p>We can define</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">IsChain</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">zipWith</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">tail</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">Forall</span>\n</code></pre></div>\n<p>or</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">IsChain</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">dropLast</span><span class=\"bp\">.</span><span class=\"n\">Forall₂</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">tail</span>\n</code></pre></div>",
        "id": 481856597,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1731381964
    },
    {
        "content": "<p>Then <code>List.Chain' R a l = List.IsChain R (a :: l)</code></p>",
        "id": 481856626,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1731381986
    },
    {
        "content": "<p>Well, <code>List.Chain R a l</code> is already the same as <code>List.Chain' R (a :: l)</code>, so its only value is being easier to prove things about</p>",
        "id": 481857250,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1731382326
    },
    {
        "content": "<p>The main difference in my experience is that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.chain_cons#doc\">docs#List.chain_cons</a> is nicer than <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.chain%27_cons#doc\">docs#List.chain'_cons</a> or <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.chain%27_cons%27#doc\">docs#List.chain'_cons'</a></p>",
        "id": 481857378,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1731382416
    },
    {
        "content": "<p>It will become <code>List.isChain_cons_cons</code>.</p>",
        "id": 481857469,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1731382452
    },
    {
        "content": "<p>(if we drop one of 2 predicates)</p>",
        "id": 481857487,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1731382465
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/channel/287929-mathlib4/topic/List.2Edestutter'/near/481856597\">said</a>:</p>\n<blockquote>\n<p>We can define</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">IsChain</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">zipWith</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">tail</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">Forall</span>\n</code></pre></div>\n<p>or</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">IsChain</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">dropLast</span><span class=\"bp\">.</span><span class=\"n\">Forall₂</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">tail</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>These re-definitions seem harder to reason about and possibly worse in terms of performance. What about something like this instead?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">IsChain</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">IsChain</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">singleton</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">IsChain</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons_cons</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">IsChain</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">IsChain</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 481858054,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1731382806
    },
    {
        "content": "<p>Actually nevermind, performance isn't really a factor here since this is a function into <code>Prop</code> and not into <code>Bool</code> or anything of the sort.</p>",
        "id": 481858864,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1731383302
    },
    {
        "content": "<p>Still, I feel an inductive definition is probably going to be the easiest to work with no matter what. We can prove equivalences to the <code>zipWith</code>, etc. definitions separately.</p>",
        "id": 481858956,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1731383378
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> / <span class=\"user-mention\" data-user-id=\"119741\">@François G. Dorais</span>, any opinions here? If we're going to change the definition of <code>Chain</code> I'd prefer to do to sooner rather than later.</p>",
        "id": 481859050,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1731383415
    },
    {
        "content": "<p>We can prove API lemmas starting with any definition. Since it's computationally irrelevant, I don't care much about which one we use.</p>",
        "id": 481861474,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1731384919
    },
    {
        "content": "<p>Possibly, an inductive one is better, because Lean won't try to unify it with something else.</p>",
        "id": 481861506,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1731384943
    },
    {
        "content": "<p>Just to be sure: the two alternatives are?</p>",
        "id": 481861852,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1731385209
    },
    {
        "content": "<p>I gave 2 similar definitions of <code>List.IsChain</code> in terms of <code>zipWith</code>, <span class=\"user-mention\" data-user-id=\"459227\">@Violeta Hernández</span> wrote a direct inductive definition. Also, there is a status quo (<code>Chain</code> and <code>Chain'</code>).</p>",
        "id": 481861920,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1731385271
    },
    {
        "content": "<p>I don't like status quo, because <code>List.Chain R a l</code> is just <code>List.Chain' R (a :: l)</code>.</p>",
        "id": 481861943,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1731385293
    },
    {
        "content": "<p>There seems to be two issues:</p>\n<ul>\n<li><code>List.Chain : α → List α → Prop</code> is begging for a nonempty list type as input.</li>\n<li><code>List.Chain': List α → Prop</code> is the right notion for a possibly empty list.</li>\n</ul>",
        "id": 481863621,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1731386495
    },
    {
        "content": "<p>There's also the less important but still relevant issue of having a primed name.</p>",
        "id": 481863719,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1731386562
    },
    {
        "content": "<p>As far as the definitions of <code>List.IsChain</code>, this is probably more efficient:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">IsChain</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">True</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">::</span><span class=\"n\">xs</span><span class=\"bp\">@</span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"bp\">::_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">IsChain</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">xs</span>\n</code></pre></div>\n<p>But Violeta's inductive definition is perhaps easier to reason with.</p>",
        "id": 481863910,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1731386729
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/287929-mathlib4/topic/List.2Edestutter'/near/481863719\">said</a>:</p>\n<blockquote>\n<p>There's also the less important but still relevant issue of having a primed name.</p>\n</blockquote>\n<p>Prime names are convenient in the short term but never good in the long term.</p>",
        "id": 481864029,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1731386801
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119741\">François G. Dorais</span> <a href=\"#narrow/stream/287929-mathlib4/topic/List.2Edestutter'/near/481863910\">said</a>:</p>\n<blockquote>\n<p>As far as the definitions of <code>List.IsChain</code>, this is probably more efficient:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">IsChain</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">True</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">::</span><span class=\"n\">xs</span><span class=\"bp\">@</span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"bp\">::_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">IsChain</span><span class=\"w\"> </span><span class=\"n\">xs</span>\n</code></pre></div>\n<p>But Violeta's inductive definition is perhaps easier to reason with.</p>\n</blockquote>\n<p>I think yours might be better actually, since it makes <code>List.IsChain.cons_cons</code> an iff trivially.</p>",
        "id": 481864087,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1731386860
    },
    {
        "content": "<p>But \"efficiency\" is not so relevant unless <code>R</code> is decidable.</p>",
        "id": 481864187,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1731386922
    },
    {
        "content": "<p>I think your recursive definition should also make it easier to prove decidability of <code>IsChain</code> (for decidable relations)</p>",
        "id": 481864332,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1731387029
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span> I support replacing <code>List.Chain</code> with the current <code>List.Chain'</code>.</p>",
        "id": 481864350,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1731387041
    },
    {
        "content": "<p>Pinging <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> since he recently added some <code>Chain</code> lemmas in one of my PRs for golfing purposes</p>",
        "id": 481864460,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1731387123
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"459227\">@Violeta Hernández</span> But your inductive definition comes with an inductive principle, which is nice to have.</p>",
        "id": 481864475,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1731387129
    },
    {
        "content": "<p>Note that this is actually tail recursive:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">isChain</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">::</span><span class=\"n\">xs</span><span class=\"bp\">@</span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"bp\">::_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">isChain</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">xs</span>\n</code></pre></div>",
        "id": 481866217,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1731388407
    },
    {
        "content": "<p>Is it? I mean, does Lean treat <code>&amp;&amp;</code> so that this definition becomes tail recursive?</p>",
        "id": 481866487,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1731388585
    },
    {
        "content": "<p>Yes, because <code>&amp;&amp;</code> is short circuiting, so if <code>r x y = false</code> then <code>isChain r xs</code> is not evaluated.</p>",
        "id": 481866563,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1731388646
    },
    {
        "content": "<p>BTW, can we somehow ask Lean whether it treats a given definition as tail recursive?</p>",
        "id": 481866659,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1731388693
    },
    {
        "content": "<p>I think Mario wrote some code for that but I just inspect the IR.</p>",
        "id": 481866728,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1731388753
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">compiler</span><span class=\"bp\">.</span><span class=\"n\">ir</span><span class=\"bp\">.</span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">isChain</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">True</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">::</span><span class=\"n\">xs</span><span class=\"bp\">@</span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"bp\">::_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">isChain</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">xs</span>\n</code></pre></div>\n<p>The key is at the end:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">      </span><span class=\"n\">Bool</span><span class=\"bp\">.</span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">        </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">x_11</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">u8</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">isChain</span><span class=\"bp\">._</span><span class=\"n\">rarg</span><span class=\"w\"> </span><span class=\"n\">x_1</span><span class=\"w\"> </span><span class=\"n\">x_4</span><span class=\"bp\">;</span>\n<span class=\"w\">        </span><span class=\"n\">ret</span><span class=\"w\"> </span><span class=\"n\">x_11</span>\n</code></pre></div>",
        "id": 481866917,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1731388885
    },
    {
        "content": "<p>Found it! <a href=\"#narrow/channel/348111-batteries/topic/tail.20recursion/near/404515501\">https://leanprover.zulipchat.com/#narrow/channel/348111-batteries/topic/tail.20recursion/near/404515501</a></p>",
        "id": 481871702,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1731391976
    },
    {
        "content": "<p>I find <code>List.Chain</code> useful as it is, I don't think it's just there to make the definition of <code>List.Chain'</code> any easier. Indeed when proving things about lists, I often find myself copying the Chain/Chain' pattern in order to make the proofs go more smoothly, having support to induct on a list without changing its first element is pretty useful! So I'm in favour of keeping it, since I use List.Chain quite a bit more than I use List.Chain'. But really if we keep the induction principles that Chain currently has, phrased in terms of Chain', then I'd be happy too.</p>",
        "id": 481896488,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1731402202
    },
    {
        "content": "<p>You can induct on <code>l</code> in <code>IsChain R (a :: l)</code>.</p>",
        "id": 481994212,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1731430449
    },
    {
        "content": "<p>I'll try to make some proof-of-concept PR tonight or tomorrow.</p>",
        "id": 481994301,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1731430480
    }
]