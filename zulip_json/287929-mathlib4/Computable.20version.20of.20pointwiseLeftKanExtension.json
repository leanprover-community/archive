[
    {
        "content": "<p>Currently, we have <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/Functor/KanExtension/Pointwise.html#CategoryTheory.Functor.pointwiseLeftKanExtension\">CategoryTheory.Functor.pointwiseLeftKanExtension</a> which noncomputably constructs a pointwise left Kan extension, given a similarly anti-computable <code>Prop</code> instance of <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/Functor/KanExtension/Pointwise.html#CategoryTheory.Functor.HasPointwiseLeftKanExtension\">HasPointwiseLeftKanExtension</a>.</p>\n<p>As a result, the constructed left extension would have worse definitional equality when it is used.</p>\n<p>I think there should be a version of this that takes the explicit colimits, and explicitly constructs the extension instead. Is this desirable?</p>",
        "id": 529695700,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753025575
    },
    {
        "content": "<p>update: I essentially copied the code to my situation and the same code just works</p>",
        "id": 529697369,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753027389
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span> <span class=\"user-mention\" data-user-id=\"286014\">@Robin Carlier</span> you might be interested in this</p>",
        "id": 535383482,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1755720794
    },
    {
        "content": "<p>more concretely now, I have <a href=\"https://github.com/kckennylau/EllipticCurve/blob/2c953f2315ad44521c190f97a4634425a75f6b29/EllipticCurve/Grassmannians/PresheafCostructured.lean#L150-L200\">this code in my personal repo</a>, which is a generalisation of <a href=\"https://github.com/leanprover-community/mathlib4/blob/4cb1b3ce077a6cae2d2e315ae981108826467d91/Mathlib/CategoryTheory/Functor/KanExtension/Pointwise.lean#L484-L538\">this code in mathlib</a> that takes in explicit colimit cocones and hence removes the \"noncomputable\" tag. should I PR this to mathlib?</p>\n<p>(And note that I essentially just copied the code, and everything works out)</p>",
        "id": 535383566,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1755720834
    },
    {
        "content": "<p>I do not think we need computable colimits.</p>",
        "id": 535390032,
        "sender_full_name": "Joël Riou",
        "timestamp": 1755724053
    },
    {
        "content": "<p>then we can't really control the left extension, we can only say what they're isomorphic to</p>",
        "id": 535390184,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1755724129
    },
    {
        "content": "<p>I would guess if we really need good object-level def-eqs, we can use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Functor.copyObj#doc\">docs#CategoryTheory.Functor.copyObj</a> to get a functor isomorphic to the original one, and being a pointwise left Kan extension is a property that is preserved by isomorphisms, so the new functor will have good defeqs and will remain a pointwise left Kan extension.</p>",
        "id": 535390533,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1755724323
    },
    {
        "content": "<p>There’s also the option and building the functor and extension first, and only then prove that it is a pointwise left Kan extension, most of the time, you already have the candidate functor and extension before the colimit cocones.</p>",
        "id": 535390954,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1755724574
    },
    {
        "content": "<p>well in my \"real\" use case it's a functor to types and you can see how the <code>Types.leftExtension</code> makes use of this computable version, and I don't really have the candidate functor except this explicit construction, which I would argue would be easier if it goes through the computable version in my repo</p>",
        "id": 535391180,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1755724718
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"286014\">Robin Carlier</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Computable.20version.20of.20pointwiseLeftKanExtension/near/535390533\">said</a>:</p>\n<blockquote>\n<p>being a pointwise left Kan extension is a property that is preserved by isomorphisms,</p>\n</blockquote>\n<p>ok, so you use copyObj to make the new functor, but how do you prove that they're isomorphic? you would need to go through an explicit colimit argument (so you still need the explicit colimit as argument). moreover, you don't get functoriality for free when you build your new functor (whereas the <em>pointwise</em> extension is, well, <em>pointwise</em>).</p>",
        "id": 535391462,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1755724899
    },
    {
        "content": "<p>when you're proving functoriality, you will be basically using the same code as the functoriality code in this noncomputable version, so you're duplicating code</p>",
        "id": 535391603,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1755724967
    },
    {
        "content": "<p>in some sense you don't actually \"need\" to control the colimit i guess, because for example we only care about P^2_S as a scheme over S, so we don't really think about it as a scheme over Spec Z</p>",
        "id": 535391893,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1755725140
    },
    {
        "content": "<p>I don’t understand what you mean when you say you don’t get functoriality. <code>F.copyObj e</code> is a functor. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Functor.isoCopyObj#doc\">docs#CategoryTheory.Functor.isoCopyObj</a> tells you that <code>F.copyObj e</code> is isomorphic to <code>F</code>. Now if you take <code>F</code> to be the pointwise left Kan extension with \"bad defeq\" and <code>e</code> be the family of <code>colimit.uniqueUpToIso</code> that your <code>isColimit</code> gives you, then you get a new functor, and a natural isomorphism, and what I’m saying is that if <code>α : F ⟶ L ⋙ G</code>  exhibhits <code>G</code> as a pointwise left Kan extension of <code>F</code> along <code>L</code> , and <code>e : G ≅ G'</code> is an isomorphism, then the canonical <code>F ⟶ L ⋙ G'</code>  induced by <code>e</code> exhibits <code>G'</code> as a pointwise Left kan extension: noncomputably, this is <code>isPointwiseLeftKanExtensionOfIsLeftKanExtension</code> with the corresponding fact about non-pointwise left Kan extensions (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Functor.LeftExtension#doc\">docs#CategoryTheory.Functor.LeftExtension</a>.isUniversalEquivOfIso₂): so as long as you have <em>any</em> family of isomorphism <del>between</del> from the objects of the arbitrary pointwise extension, you have a pointwise extension, with the desired objects.</p>",
        "id": 535393726,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1755726107
    },
    {
        "content": "<p>thanks for the explanation. it makes more sense now.</p>",
        "id": 535393876,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1755726194
    },
    {
        "content": "<p>Also, this is really a \"chosen/abstract colimit\" issue rather than a \"computable/noncomputable\" one: if <code>IsColimit</code> were a <code>Prop</code> and <code>IsColimit.desc</code>  were tagged noncomputable, these kind of issues would still be there! This is because at the end of the day <code>IsColimit</code> asserts something about a specific colimit cocone, with specific cocone point and maps, and any other one, however obtained, will be canonically (though possibly noncomputably, but that’s irrelevant 90% of the time) isomorphic but not equal to this one.</p>",
        "id": 535395955,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1755727345
    }
]