[
    {
        "content": "<p>I'd like to define continuous group cohomology in the following way. Assume <code>G</code> is a topological group and <code>œÄ</code> is a representation of <code>G</code> on an additive commutative topological group <code>M</code> (or more generally a topological <code>R</code>-module, where <code>R</code> is a commutative ring).</p>\n<p>I'll assume that for all <code>g : G</code>, the map <code>œÄ g : M ‚Üí M</code> is continuous, and for all <code>r : R</code> the map <code>M ‚Üí M</code> defined by <code>m ‚Ü¶ r ‚Ä¢ m</code> is continuous. Under these conditions, we can define a new representation <code>I œÄ</code> of <code>G</code> on the topological group <code>C(G,M)</code> of continuous maps (with the compact open topology), where the action of <code>G</code> is by conjugation. It's easy to check that the representation <code>I œÄ</code> satisfies the same weak continuity conditions as <code>œÄ</code>.</p>\n<p>If we let <code>œÄ ‚Üí·µ¢ œÄ'</code> denote the set of continuous intertwining operators from <code>œÄ</code> to another representation <code>œÄ'</code>, then there is an intertwining operator <code>const : œÄ ‚Üí·µ¢ C(G,M)</code> which takes <code>m : M</code> to the constant function with value <code>m</code>. Also, for any intertwining operator <code>œÜ : œÄ ‚Üí·µ¢ œÄ'</code>, there is a corresponding intertwining operator <code>map œÜ : I œÄ ‚Üí·µ¢ I œÄ'</code>, which takes a continuous map <code>f : G ‚Üí M</code> to the continuous map <code>g ‚Ü¶ œÜ(f g)</code>.</p>\n<p>We can use this notation to define a resolution of representation <code>œÄ</code> as the sequence<br>\n<code>0 ‚Üí œÄ ‚Üí·µ¢ I œÄ ‚Üí·µ¢ I (I œÄ) ‚Üí·µ¢ I (I (I œÄ)) ‚Üí·µ¢ ...</code>,<br>\nwhere the map <code>œÄ ‚Üí·µ¢ I œÄ</code> is <code>const</code> and the other maps are:<br>\n<code>d‚ÇÄ = const - map const</code>,<br>\n<code>d‚ÇÅ = const - map d‚ÇÄ</code><br>\n<code>d‚ÇÇ = const - map d‚ÇÅ</code>, etc.<br>\nThis kind of recursive definition avoids the the finite alternating sum of maps that appears in most definitions, and this seems to simplify the proofs. For example, it's trivial to prove from the definitions that this sequence is exact, and all of the maps are continuous.</p>\n<p>To obtain the continuous group cohomology, we take the invariants, and then take the cohomology of the resulting cochain complex. The definition is very general: it requires only a very weak continuity condition on the representation <code>œÄ</code>, and it avoids the assumption that <code>G</code> is locally compact.</p>",
        "id": 500005760,
        "sender_full_name": "Richard Hill",
        "timestamp": 1739707886
    },
    {
        "content": "<p>This I guess must specialise to group cohomology when G and M have the discrete topology but I've never seen this approach before. I suppose it doesn't matter at all that our current definition of group cohomology is different. One approach for continuous group cohomology which I've seen is \"do group cohomology for finite quotients and then take a filtered colimit\" but it wouldn't surprise me if your approach is easier to formalise. </p>\n<p>One question this raises is which of the 7 currently available versions of \"representation\" you want to use.</p>",
        "id": 500014256,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1739715401
    },
    {
        "content": "<p>For a <em>definition</em> of group cohomology, I would rather use a certain subcomplex of continuous cochains in the complex of inhomogeneous cochains defined in <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/RepresentationTheory/GroupCohomology/Basic.html\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/RepresentationTheory/GroupCohomology/Basic.html</a> (this is the definition in the stacks project <a href=\"https://stacks.math.columbia.edu/tag/0DVG\">https://stacks.math.columbia.edu/tag/0DVG</a>): this would ease comparison results in situations which appear in Galois cohomology (like the relation with the colimit of the cohomology of finite quotients mentionned by Kevin).<br>\nIf there are two nonequivalent definitions which require different assumptions on the group <code>G</code>, the module <code>M</code> and the <code>G</code>-action on <code>M</code> (and how it is bundled...), we should probably implement both...</p>",
        "id": 500014546,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1739715684
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">One</span><span class=\"w\"> </span><span class=\"n\">approach</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">continuous</span><span class=\"w\"> </span><span class=\"n\">group</span><span class=\"w\"> </span><span class=\"n\">cohomology</span><span class=\"w\"> </span><span class=\"n\">which</span><span class=\"w\"> </span><span class=\"n\">I've</span><span class=\"w\"> </span><span class=\"n\">seen</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"s2\">\"do group cohomology for finite quotients and then take a filtered colimit\"</span>\n</code></pre></div>\n<p>This only works if the group is profinite and the module is discrete.</p>",
        "id": 500021603,
        "sender_full_name": "Richard Hill",
        "timestamp": 1739721775
    },
    {
        "content": "<p>As you say, one can define \"continuous cohomology\" to mean the same as in <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/RepresentationTheory/GroupCohomology/Basic.html\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/RepresentationTheory/GroupCohomology/Basic.html</a>, but with all the maps continuous. However, there are a few limitations with this.</p>\n<ol>\n<li>if the action is not continuous in the stronger sense that <code>G \\times M \\to M</code> is continuous, then the coboundary map will not take continuous maps to continuous maps.</li>\n<li>The stronger continuity condition is not preserved by continuous induction unless the group <code>G</code> is locally compact.</li>\n<li>The only proof that I've seen that the spaces <code>C(G^n,M)</code> form a continuously injective resolution is to identify these spaces with <code>C(G,_)</code>, i.e. it reduces the problem to my approach (see page 3 of <a href=\"https://deepblue.lib.umich.edu/bitstream/handle/2027.42/46596/222_2005_Article_BF01389727.pdf;sequence=1\">https://deepblue.lib.umich.edu/bitstream/handle/2027.42/46596/222_2005_Article_BF01389727.pdf;sequence=1</a>). This reduction breaks down if <code>G</code> is not locally compact because the two spaces are not the same . There may be some way around this problem; I don't know.</li>\n</ol>",
        "id": 500023580,
        "sender_full_name": "Richard Hill",
        "timestamp": 1739723432
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">One</span><span class=\"w\"> </span><span class=\"n\">question</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"n\">raises</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">which</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"mi\">7</span><span class=\"w\"> </span><span class=\"n\">currently</span><span class=\"w\"> </span><span class=\"n\">available</span><span class=\"w\"> </span><span class=\"n\">versions</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"s2\">\"representation\"</span><span class=\"w\"> </span><span class=\"n\">you</span><span class=\"w\"> </span><span class=\"n\">want</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">use</span><span class=\"bp\">.</span>\n</code></pre></div>\n<p>I don't think this makes a lot of difference (and I don't think I know all seven definitions), but my code uses <code>Representation R G</code> and a type class to keep track of the continuity condition.</p>",
        "id": 500023804,
        "sender_full_name": "Richard Hill",
        "timestamp": 1739723630
    },
    {
        "content": "<ol>\n<li>This all looks great! I'm excited to see this.</li>\n<li>Here's a discussion about the (thirty-)seven definitions: <a class=\"message-link\" href=\"/#narrow/channel/116395-maths/topic/Representation.20Theory/near/498710886\">#maths &gt; Representation Theory @ üí¨</a></li>\n</ol>",
        "id": 500186194,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1739798747
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"424936\">@Richard Hill</span> It sounds like you have already formalized (almost) all of what you describe above. Is this project publicly available somewhere?</p>",
        "id": 500186480,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1739798815
    },
    {
        "content": "<p>Thanks for your comments. I'm not quite ready with my code, although it's quite close now. I started off working on the case where the coefficient ring <code>R</code> is the integers, and I completed a sorry-free version of this. However I guess people will want a version with a general <code>CommRing R</code>. I also have a few annoying places where lemmas do not work because of the Type synonyms which I'm using, so I'd like to tidy that up.</p>",
        "id": 500254035,
        "sender_full_name": "Richard Hill",
        "timestamp": 1739816712
    },
    {
        "content": "<p>Great! Looking forward to the final result!</p>",
        "id": 500298194,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1739840806
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span>  my current sketch is here : <a href=\"https://github.com/rmhi/cts_cohomology/blob/master/CtsCohomology/Basic.lean\">https://github.com/rmhi/cts_cohomology/blob/master/CtsCohomology/Basic.lean</a>.<br>\nMost of this file is API. The actual definition of the complex of homogeneous cochains is lines 342 to 419 (in the initial commit). At the moment, this is just a functor of the module, but it's not much more work to make it a functor of the group as well. Also, I haven't proved that the resolution is continuously injective, and this needs extra conditions on the representation.</p>",
        "id": 500700621,
        "sender_full_name": "Richard Hill",
        "timestamp": 1739984920
    },
    {
        "content": "<p>This sat on my backlog for a week. It's great that you have this. Do you plan on pushing (parts of) it to mathlib?</p>",
        "id": 501724476,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1740466017
    },
    {
        "content": "<p>There is <a href=\"https://github.com/leanprover-community/mathlib4/pull/21300\">#21300</a> for starters. But Richard has talked to me about these ideas and I am convinced that they're rather beautiful (he has formalized a bunch of stuff which isn't in PRs and it seems to work fine) but at the back of my mind I am worried that when Amelia said \"hey here's how I propose to do group cohomology Joel's response was \"actually you should do it a very different way\" and Amelia took Joel's advice; I am a bit confused about whether Richard's novel approach to the definitions will be something which Joel won't like.</p>",
        "id": 501735324,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1740470695
    },
    {
        "content": "<p>I am very much ok with Richard approach if the formalization includes a map from his complex to Amelia's, and that it is a quasi-isomorphism when the group and module are discrete.</p>",
        "id": 502075575,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1740583629
    },
    {
        "content": "<p>Otherwise, I agree that the construction is beautiful!</p>",
        "id": 502111263,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1740593118
    },
    {
        "content": "<p>many thanks for all of your comments. I'll start making a few PRs on this.</p>",
        "id": 502539919,
        "sender_full_name": "Richard Hill",
        "timestamp": 1740737183
    }
]