[
    {
        "content": "<p>One of the major pain points when working with C⋆-algebras in mathlib currently is the fact that <code>CStarAlgebra</code> doesn't extend <code>Inv</code>, so one can't write <code>a⁻¹</code>. Of course, not every element is invertible, but it would definitely make sense to have an inverse that behaves like <code>Ring.inverse</code>, i.e. <code>a⁻¹ = 0</code> for non-invertible elements.</p>\n<p>There are many options for making this happen. One option would be to make <code>MonoidWithZero</code> extend <code>Inv</code>, which would provide such an inverse for a large part of mathlib. I haven't tried to implement this, but it's probably the most seamless solution, especially if this issue is also felt in other parts of the library. There are some drawbacks, like the fact that types like <code>Nat</code> would end up with a useless inverse, and possibly performance problems related to typeclass search. </p>\n<p>Another option is to define the typeclass</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">LawfulInv</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M₀</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MonoidWithZero</span><span class=\"w\"> </span><span class=\"n\">M₀</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Inv</span><span class=\"w\"> </span><span class=\"n\">M₀</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">ringInverse_eq_inv</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M₀</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ring</span><span class=\"bp\">.</span><span class=\"n\">inverse</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">⁻¹</span>\n</code></pre></div>\n<p>and provide instances for actual C⋆-algebras, and then redefine <code>CStarAlgebra A</code> to extend <code>[Inv A] [LawfulInv A]</code>. I got partway through this approach in <a href=\"https://github.com/leanprover-community/mathlib4/pull/33441\">#33441</a>. Another even less invasive option is to scope the <code>LawfulInv</code> material to <code>CStarAlgebra</code>.</p>\n<p>Before going further with any of these approaches, I would be very interested in what people think about this. Any thoughts?</p>",
        "id": 566095376,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1767383487
    },
    {
        "content": "<p>Note we have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ring.inverse#doc\">docs#Ring.inverse</a> (already used to give your proposed definition of inverse on matrix rings).</p>",
        "id": 566096679,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1767384339
    },
    {
        "content": "<p>Yes, but using it is quite annoying: the obvious notation for it is already taken, and one still has to convert between this and the actual inverse for the concrete types that do have an inverse (like matrices). Maybe having notation for it would make it bearable (any suggestions?).</p>",
        "id": 566096859,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1767384468
    },
    {
        "content": "<p>There is the class <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Invertible#doc\">docs#Invertible</a> which comes with a notation (although different from <code>⁻¹</code>). Or do you want to define inverse for all elements?</p>",
        "id": 566109141,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1767395634
    },
    {
        "content": "<p>Yes, the whole point is to have a total function, for the same reason that we use a total function for the inverse on real numbers.</p>",
        "id": 566109294,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1767395814
    },
    {
        "content": "<p>ok, could you elaborate why you would like to define it as a total function in the context of C*-algebras?</p>",
        "id": 566110224,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1767397109
    },
    {
        "content": "<p>The same reason we have an <code>Inv</code> instance for matrix. Just convenience.</p>",
        "id": 566111634,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1767398528
    },
    {
        "content": "<p>I like this idea (and I think brought it up long ago), but it does have some downsides. The main ones that come to mind are that:</p>\n<ul>\n<li>Mathematicians are surely going to be unhappy that they have to provide a partial inverse in every monoid (as they presumably already are about <code>npow</code>). We can provide a noncomputable default (the current <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ring.inverse#doc\">docs#Ring.inverse</a>), but then...</li>\n<li>Computer scientists are going to be annoyed that by default their <code>Ring</code> instances are non-computable</li>\n<li>Even if mathlib avoids noncomputable defaults as much as possible, some ring instances might be unavoidably non-computable; for instance, inverses in a subring will probably now require decidability of membership in order to produce the restricted partial inverse</li>\n</ul>",
        "id": 566131146,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1767424936
    },
    {
        "content": "<p>Leaving <code>LawfulInv</code> as a mixin does avoid many of these issues, as then the noncomputability of the inverse doesn't poison the other arithmetic operations.</p>",
        "id": 566131292,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1767425163
    },
    {
        "content": "<p>I think if we go the <code>LawfulInv</code> route, we should drop <code>Ring.inverse</code> altogether (changing the definition of <code>LawfulInv</code> to characterize its properties) and require all existing mentions of <code>Ring.inverse</code> to take <code>[LawfulInv R]</code> assumptions.</p>",
        "id": 566131364,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1767425265
    },
    {
        "content": "<p>Then we could have <code>letI := Ring.lawfulInv R</code> in places which only need the inverse in proofs as opposed to statements</p>",
        "id": 566131415,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1767425318
    },
    {
        "content": "<p>The matrix inverse would then become <code>[LawfulInv R] : LawfulInv (Matrix n n R)</code>, and as a really nice bonus would become computable over the rationals</p>",
        "id": 566131451,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1767425363
    },
    {
        "content": "<p>Note that <code>ENNReal</code> wouldn't be a <code>LawfulInv</code> because there <code>0⁻¹ = ⊤</code> instead of <code>0⁻¹ = 0</code></p>",
        "id": 566131453,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1767425365
    },
    {
        "content": "<p>I think that's fine, the goal here is to banish <code>Ring.inverse</code> not to deal with the fact that <code>ENNReal</code> is not a semifield</p>",
        "id": 566131561,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1767425444
    },
    {
        "content": "<p>Yes, I like the idea of replacing <code>Ring.inverse</code> altogether.</p>",
        "id": 566154469,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1767451232
    }
]