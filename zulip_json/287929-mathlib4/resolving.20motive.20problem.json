[
    {
        "content": "<p>Greetings! I came across this \"motive is not type correct\" problem in the following code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Polynomial</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">finrank</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">AdjoinRoot</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">natDegree</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hp</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">AdjoinRoot</span>\n<span class=\"w\">  </span><span class=\"n\">convert_to</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">finrank</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⊥</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ideal</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]))</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">LinearEquiv</span><span class=\"bp\">.</span><span class=\"n\">finrank_eq</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Ideal</span><span class=\"bp\">.</span><span class=\"n\">span_singleton_eq_bot</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])))</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">convert_to</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">finrank</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">LinearEquiv</span><span class=\"bp\">.</span><span class=\"n\">finrank_eq</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">AlgEquiv</span><span class=\"bp\">.</span><span class=\"n\">quotientBot</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])</span><span class=\"bp\">.</span><span class=\"n\">toLinearEquiv</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">finrank_of_not_finite</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">Polynomial</span><span class=\"bp\">.</span><span class=\"n\">not_finite</span>\n</code></pre></div>\n<p>The error message is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">rewrite'</span><span class=\"w\"> </span><span class=\"n\">failed</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">correct</span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≃ₗ</span><span class=\"o\">[</span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"bp\">⊥</span>\n<span class=\"n\">Error</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">application</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">mismatch</span>\n<span class=\"w\">  </span><span class=\"bp\">@</span><span class=\"n\">CommRing</span><span class=\"bp\">.</span><span class=\"n\">toNonUnitalCommRing</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">instCommRing</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"n\">argument</span>\n<span class=\"w\">  </span><span class=\"n\">instCommRing</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">AdjoinRoot</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_2</span>\n<span class=\"n\">but</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">expected</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_2</span>\n</code></pre></div>\n<p>Seems like it didn't unfold <code>AdjoinRoot</code>? How can I resolve it? <code>simp_rw</code>, <code>erw</code> doesn't work here</p>",
        "id": 512727880,
        "sender_full_name": "Suzuka Yu",
        "timestamp": 1744860397
    },
    {
        "content": "<p>this seems to work (instead of <code>rw [this]</code>):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"o\">]</span>\n<span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">LinearEquiv</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n</code></pre></div>",
        "id": 512731646,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1744862625
    },
    {
        "content": "<p>I'm not sure why the rewrite works in one direction but not the other, but at least this should resolve it</p>",
        "id": 512731996,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1744862797
    },
    {
        "content": "<p>Ah, yes! Thanks! (I'm also curious whats happening behind the scene lol)</p>",
        "id": 512734084,
        "sender_full_name": "Suzuka Yu",
        "timestamp": 1744864008
    },
    {
        "content": "<p>The goal <code>⊢ (F[X] ⧸ Ideal.span {0}) ≃ₗ[F] F[X] ⧸ ⊥</code> contains an explicit <code>Ideal.span {0}</code> but it also contains at least one \"secret\" one. The goal is an isomorphism of F-algebras so buried away in the goal there must be some kind of data which expresses how <code>F[X] ⧸ Ideal.span {0}</code> is an F-algebra: remember that what Lean prints is not all of what is going on; a lot of information in the terms printed on the screen is suppressed by the pretty-printer (for example all implicit inputs to functions, all typeclass information etc). When you attempt to change the visible <code>Ideal.span {0}</code> to <code>⊥</code> Lean makes the change, and now when it tries to <em>make sense</em> of the resulting expression it says \"wait a minute, this is supposed to be the type of isomorphisms of F-algebras but the F-algebra on the left is <code>F[X] ⧸ ⊥</code> and the data showing that it's an F-algebra is data showing that <code>F[X] ⧸ Ideal.span {0}</code> is an F-algebra, so this expression doesn't even make sense as a type any more\". You hence get the error. By the way, you shouldn't be in tactic mode with your goal a Type, goals should always be Props in tactic mode.</p>\n<p>You might ask \"well why doesn't Lean just rewrite all of the <code>Ideal.span {0}</code>s, including the ones that the user can't see?\". This is a fair question but it turns out that this is super-complicated in Lean's type theory and the <code>rw</code> tactic cannot do it in this case. The problem is that even if two ideals <code>I</code> and <code>J</code> are equal, but if the proof of this equality is not <code>rfl</code> (and in your case it's not <code>rfl</code>, it's <code>Ideal.span_singleton_eq_bot</code>), then the relationship between the types <code>R/I</code> and <code>R/J</code> is complicated, and Lean would rather say that they are isomorphic than equal (equality of types is a poorly-behaved concept in Lean's type theory, most questions about it are undecidable). So what you really want to do here is to say \"I and J are equal, so R/I and R/J are isomorphic F-algebras, and I will apply this isomorphism to continue\" but this is well beyond the remit of the <code>rw</code> tactic, which only deals in equalities not isomorphisms. You can see the point where <code>rw</code> gives up in the error message; it is confused about two types which you have proved are equal but the proof isn't <code>rfl</code>, so it is now muddled about how to get a ring structure on one type from a ring structure on the other one. Such a transfer of ring structures shoudl be done via a bijection, not an equality of types.</p>",
        "id": 512869045,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1744907516
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"739620\">Suzuka Yu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/resolving.20motive.20problem/near/512727880\">said</a>:</p>\n<blockquote>\n<p>Greetings! I came across this \"motive is not type correct\" problem in the following code:</p>\n</blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Polynomial</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">finrank</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">AdjoinRoot</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">natDegree</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">hp</span>\n<span class=\"w\">  </span><span class=\"n\">change</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">finrank</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"bp\">⧸_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">Submodule</span><span class=\"bp\">.</span><span class=\"n\">quotEquivOfEq</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">Ideal</span><span class=\"bp\">.</span><span class=\"n\">span_singleton_eq_bot</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]))</span><span class=\"bp\">|&gt;.</span><span class=\"m\">2</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"bp\">|&gt;.</span><span class=\"n\">restrictScalars</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≪≫ₗ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">AlgEquiv</span><span class=\"bp\">.</span><span class=\"n\">quotientBot</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])</span><span class=\"bp\">.</span><span class=\"n\">toLinearEquiv</span>\n<span class=\"w\">  </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">this</span><span class=\"bp\">.</span><span class=\"n\">finrank_eq</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">finrank_of_not_finite</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">Polynomial</span><span class=\"bp\">.</span><span class=\"n\">not_finite</span>\n</code></pre></div>\n<p>this would avoid rewriting theorems about <code>Ideal.span {0}</code></p>",
        "id": 512886445,
        "sender_full_name": "Edison Xie",
        "timestamp": 1744913139
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/resolving.20motive.20problem/near/512869045\">said</a>:</p>\n<blockquote>\n<p>The problem is that even if two ideals <code>I</code> and <code>J</code> are equal, but if the proof of this equality is not <code>rfl</code> (and in your case it's not <code>rfl</code>, it's <code>Ideal.span_singleton_eq_bot</code>), then the relationship between the types <code>R/I</code> and <code>R/J</code> is complicated, and Lean would rather say that they are isomorphic than equal (equality of types is a poorly-behaved concept in Lean's type theory, most questions about it are undecidable). </p>\n</blockquote>\n<p>Really? I would've thought the you can just subst your way out</p>",
        "id": 512891066,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744914767
    },
    {
        "content": "<p>Unfortunately <code>subst</code> doesn't work here. What happens is that you have equal ideals <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">I</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>J</mi></mrow><annotation encoding=\"application/x-tex\">J</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.09618em;\">J</span></span></span></span>, and then you can deduce that the <em>types</em> <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mi mathvariant=\"normal\">/</mi><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">R/I</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mi mathvariant=\"normal\">/</mi><mi>J</mi></mrow><annotation encoding=\"application/x-tex\">R/J</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.09618em;\">J</span></span></span></span> are equal, however <code>subst</code> does not tell you that the <code>CommRing</code> instances match up.</p>",
        "id": 512897953,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1744917242
    },
    {
        "content": "<p>Also remember that <code>subst</code> only works if at least one of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">I</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span> or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>J</mi></mrow><annotation encoding=\"application/x-tex\">J</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.09618em;\">J</span></span></span></span> is a free variable. Kevin's <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">I</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>J</mi></mrow><annotation encoding=\"application/x-tex\">J</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.09618em;\">J</span></span></span></span> are definitely not free variables.</p>",
        "id": 512898205,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1744917322
    },
    {
        "content": "<p>You case just have two instances?? Also <code>Eq.rec</code> tells you the <code>CommRing</code> instances match up.</p>",
        "id": 512898265,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744917347
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/287929-mathlib4/topic/resolving.20motive.20problem/near/512898205\">said</a>:</p>\n<blockquote>\n<p>Also remember that <code>subst</code> only works if at least one of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">I</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span> or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>J</mi></mrow><annotation encoding=\"application/x-tex\">J</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.09618em;\">J</span></span></span></span> is a free variable. Kevin's <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">I</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>J</mi></mrow><annotation encoding=\"application/x-tex\">J</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.09618em;\">J</span></span></span></span> are definitely not free variables.</p>\n</blockquote>\n<p>I didn't mean the tactic <code>subst</code>, but rather the general idea of substituting an equality. Sorry if that wasn't clear.</p>",
        "id": 512898433,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744917400
    },
    {
        "content": "<p>Yes, so this general idea of substituting an equality incarnates itself here by \"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi><mo>=</mo><mi>J</mi></mrow><annotation encoding=\"application/x-tex\">I = J</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.09618em;\">J</span></span></span></span>, so <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mi mathvariant=\"normal\">/</mi><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">R/I</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mi mathvariant=\"normal\">/</mi><mi>J</mi></mrow><annotation encoding=\"application/x-tex\">R/J</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.09618em;\">J</span></span></span></span> are isomorphic rings\".</p>",
        "id": 512898589,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1744917477
    },
    {
        "content": "<p>This is definitely a rabbit hole, but you might want to learn a bit of homotopy type theory</p>",
        "id": 512898693,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1744917510
    },
    {
        "content": "<p>I was thinking \"<code>I = J</code>, so <code>R ⧸ I = R ⧸ J</code> and the two instances are <code>HEq</code>\"</p>",
        "id": 512898756,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744917540
    },
    {
        "content": "<p>But that works too</p>",
        "id": 512898808,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744917558
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/resolving.20motive.20problem/near/512898756\">said</a>:</p>\n<blockquote>\n<p>I was thinking \"<code>I = J</code>, so <code>R ⧸ I = R ⧸ J</code> and the two instances are <code>HEq</code>\"</p>\n</blockquote>\n<p>With that view, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RingEquiv#doc\">docs#RingEquiv</a> is a more general (and flexible!) version of your predicate \"<code>A = B</code> and the two instances are <code>HEq</code>\"</p>",
        "id": 512899071,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1744917652
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/resolving.20motive.20problem/near/512898433\">said</a>:</p>\n<blockquote>\n<p>the general idea of substituting an equality</p>\n</blockquote>\n<p>The general idea of substituting an equality is what <code>rw</code> does though, and it fails here.</p>\n<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> <code>rw</code> rewrites all occurrences simultaneously, even the \"secret\" ones. I'm not sure what you're talking about with equality of types confusing <code>rw</code>, since <code>rw</code> doesn't distinguish whether a term is a value or a type or a proposition or a universe or what-have-you. I think the problem is simply that the LHS of the rewrite lemma doesn't literally appear inside one of the instance arguments. If it did, then it could rewrite and typecheck. However, the terms are really large (if you set `pp.explicit), and I didn't have the patience to try to verify this.</p>\n<p>It's a fair caution that rewrites that involve equalities of types are best to be avoided (better to create an isomorphism and compose).</p>",
        "id": 512901839,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1744918720
    },
    {
        "content": "<p>The secret one is hidden inside <code>AdjoinRoot.instCommRing</code></p>",
        "id": 512901963,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744918770
    },
    {
        "content": "<p><code>rw</code> does not unfold this instance so does not get to rewrite it</p>",
        "id": 512902107,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744918822
    },
    {
        "content": "<p>Yep, that's the one. It takes a few unfoldings, but then rw can see it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">finrank</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">AdjoinRoot</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">natDegree</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hp</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">AdjoinRoot</span>\n<span class=\"w\">  </span><span class=\"n\">convert_to</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">finrank</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⊥</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ideal</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]))</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">LinearEquiv</span><span class=\"bp\">.</span><span class=\"n\">finrank_eq</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Ideal</span><span class=\"bp\">.</span><span class=\"n\">span_singleton_eq_bot</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])))</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">    </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">AdjoinRoot</span><span class=\"bp\">.</span><span class=\"n\">instCommRing</span><span class=\"w\"> </span><span class=\"n\">AdjoinRoot</span><span class=\"bp\">.</span><span class=\"n\">instAlgebra</span><span class=\"w\"> </span><span class=\"n\">AdjoinRoot</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"bp\">._</span><span class=\"n\">proof_1</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">convert_to</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">finrank</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">LinearEquiv</span><span class=\"bp\">.</span><span class=\"n\">finrank_eq</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">AlgEquiv</span><span class=\"bp\">.</span><span class=\"n\">quotientBot</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])</span><span class=\"bp\">.</span><span class=\"n\">toLinearEquiv</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">finrank_of_not_finite</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">Polynomial</span><span class=\"bp\">.</span><span class=\"n\">not_finite</span>\n</code></pre></div>",
        "id": 512902550,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1744918996
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> I think I misunderstood what you were saying in your post, sorry. When you said \"secret\" I thought you just meant implicit arguments, not that it might be buried deeper in an expression, or otherwise obscured.</p>",
        "id": 512903604,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1744919405
    },
    {
        "content": "<p>It's not exactly the same, but I think the rw failure here could be regarded as being similar to why this doesn't work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 512903847,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1744919523
    },
    {
        "content": "<p>Reiterating a point Kevin made, rewriting data like this is not the right approach (my <code>unfold</code> is just for illustration, it's not the solution!). It's better to work with isomorphisms.</p>\n<p>I couldn't find it easily, but there ought to be an isomorphism somewhere in mathlib for <code>R ⧸ I ≃+* R ⧸ J</code> given <code>I = J</code>.</p>",
        "id": 512904447,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1744919774
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ideal.quotEquivOfEq#doc\">docs#Ideal.quotEquivOfEq</a> ?</p>",
        "id": 512904729,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1744919895
    },
    {
        "content": "<p>(First hit on loogle)</p>",
        "id": 512904779,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1744919923
    },
    {
        "content": "<p>if only it were F-linear...</p>",
        "id": 512905273,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1744920126
    },
    {
        "content": "<p>Ok, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Submodule.quotEquivOfEq#doc\">docs#Submodule.quotEquivOfEq</a> was the answer.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Polynomial</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">finrank</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">AdjoinRoot</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">natDegree</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hp</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">AdjoinRoot</span>\n<span class=\"w\">  </span><span class=\"n\">convert_to</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">finrank</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⊥</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ideal</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]))</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">LinearEquiv</span><span class=\"bp\">.</span><span class=\"n\">finrank_eq</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Ideal</span><span class=\"bp\">.</span><span class=\"n\">span_singleton_eq_bot</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])))</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"bp\">.</span><span class=\"n\">quotEquivOfEq</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">this</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"bp\">.</span><span class=\"n\">restrictScalars</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">convert_to</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">finrank</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">LinearEquiv</span><span class=\"bp\">.</span><span class=\"n\">finrank_eq</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">AlgEquiv</span><span class=\"bp\">.</span><span class=\"n\">quotientBot</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])</span><span class=\"bp\">.</span><span class=\"n\">toLinearEquiv</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">finrank_of_not_finite</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">Polynomial</span><span class=\"bp\">.</span><span class=\"n\">not_finite</span>\n</code></pre></div>",
        "id": 512906029,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1744920425
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Submodule.quotEquivOfEqBot#doc\">docs#Submodule.quotEquivOfEqBot</a> is a hack :)</p>",
        "id": 512976453,
        "sender_full_name": "Edison Xie",
        "timestamp": 1744955450
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Polynomial</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">finrank</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">AdjoinRoot</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">natDegree</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">hp</span>\n<span class=\"w\">  </span><span class=\"n\">change</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">finrank</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"bp\">⧸_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"bp\">.</span><span class=\"n\">quotEquivOfEqBot</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Ideal</span><span class=\"bp\">.</span><span class=\"n\">span</span><span class=\"w\"> </span><span class=\"o\">{(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])})</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">Ideal</span><span class=\"bp\">.</span><span class=\"n\">span_singleton_eq_bot</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]))</span><span class=\"bp\">|&gt;.</span><span class=\"m\">2</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">)</span><span class=\"bp\">|&gt;.</span><span class=\"n\">restrictScalars</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">finrank_eq</span>\n<span class=\"w\">  </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">finrank_of_not_finite</span><span class=\"w\"> </span><span class=\"n\">Polynomial</span><span class=\"bp\">.</span><span class=\"n\">not_finite</span>\n</code></pre></div>",
        "id": 512976492,
        "sender_full_name": "Edison Xie",
        "timestamp": 1744955481
    }
]