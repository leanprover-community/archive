[
    {
        "content": "<p>Continuing from <a class=\"stream-topic\" data-stream-id=\"270676\" href=\"/#narrow/channel/270676-lean4/topic/Elab.20to.20generalize.20type.20classes.20for.20theorems/with/498862988\">#lean4 &gt; Elab to generalize type classes for theorems</a>  which discussed whether automated generalization was possible:</p>\n<blockquote>\n<p>others are maybe not very useful</p>\n</blockquote>\n<p>Some examples of this are thinks like generalizing <code>[Ring R] [AddCommGroup M] [Module R M]</code> to <code>[Ring R] [AddCommMonoid M] [Module R M]</code>, since every module over a ring is necessarily also an <code>AddCommGroup</code>, and the generalization is just a distraction.</p>",
        "id": 501288855,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1740247698
    },
    {
        "content": "<p>(The same is not true for <code>[Semiring R] [AddCommGroup M]</code>, which actually can be useful)</p>",
        "id": 501288872,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1740247727
    },
    {
        "content": "<p>One might start with the ones that are just dropping commutativity, for example</p>",
        "id": 501289435,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1740248169
    },
    {
        "content": "<p>Maybe the main annoyance will be that it's harder to use <code>variable</code></p>",
        "id": 501289480,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1740248209
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/270676-lean4/topic/Elab.20to.20generalize.20type.20classes.20for.20theorems/near/501288855\">said</a>:</p>\n<blockquote>\n<p>since every module over a ring is necessarily also an <code>AddCommGroup</code></p>\n</blockquote>\n<p>Are you saying that <code>M</code> is always actually an AddCommGroup, or am I misunderstanding? If that's the case, should Module actually require an AddCommGroup?</p>",
        "id": 501289652,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1740248356
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/channel/270676-lean4/topic/Elab.20to.20generalize.20type.20classes.20for.20theorems/near/501289480\">said</a>:</p>\n<blockquote>\n<p>Maybe the main annoyance will be that it's harder to use <code>variable</code></p>\n</blockquote>\n<p>That's one thing I have actually not gotten to yet. My current code only looks at type classes explicitly defined in the declaration, I do not yet look at those pulled in by <code>variable</code></p>",
        "id": 501289689,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1740248391
    },
    {
        "content": "<p>However, building mathlib there are actually only a few places where it has complaints about uses of <code>variable</code> being shadowed, so at least up until now it doesn't seem to make it too messy</p>",
        "id": 501289783,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1740248441
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"761203\">Vlad Tsyrklevich</span> <a href=\"#narrow/channel/270676-lean4/topic/Elab.20to.20generalize.20type.20classes.20for.20theorems/near/501289652\">said</a>:</p>\n<blockquote>\n<p>Are you saying that <code>M</code> is always actually an AddCommGroup, or am I misunderstanding? If that's the case, should Module actually require an AddCommGroup?</p>\n</blockquote>\n<p>I'm saying that the following are interesting:</p>\n<ul>\n<li><code>[Semiring R] [AddCommMonoid M] [Module R M]</code> (a \"semimodule\")</li>\n<li><code>[Semiring R] [AddCommGroup M] [Module R M]</code> (e.g a positive cone in a vector space)</li>\n<li><code>[Ring R] [AddCommGroup M] [Module R M]</code> (a \"module\")</li>\n</ul>\n<p>and this one is not:</p>\n<ul>\n<li><code>[Ring R] [AddCommMonoid M] [Module R M]</code> (equivalent to a \"module\" mathematically, but with data fields absent)</li>\n</ul>",
        "id": 501289843,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1740248510
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"761203\">Vlad Tsyrklevich</span> <a href=\"#narrow/channel/270676-lean4/topic/Elab.20to.20generalize.20type.20classes.20for.20theorems/near/501289652\">said</a>:</p>\n<blockquote>\n<p>Are you saying that <code>M</code> is always actually an AddCommGroup, or am I misunderstanding? If that's the case, should Module actually require an AddCommGroup?</p>\n</blockquote>\n<p>If R is a semiring and M is an AddCommMomoid then M can be an R-module. If R is a ring and M is an AddCommGroup then M can be an R-module and this is the set-up which is often used by mathematicians. The point is that if R is a ring (not a semiring) and M is an AddCommMonoid and if furthermore M is an R-module, then M is automatically an AddCommGroup, because negation on M can be defined by acting by -1 in the ring. So if you can't weaken the assumption on R from Ring to Semiring then weaking the hypothesis on M from group to monoid might just be causing problems rather than solving them, because they're still groups and it's now harder to see this because you're now going \"the wrong way\" in the typeclass inference graph.</p>",
        "id": 501289948,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1740248602
    },
    {
        "content": "<p>That makes sense. There could be some filters to try to match cases like this. If others see more cases that are not useful generalizations in that diff, that'd be helpful</p>",
        "id": 501291086,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1740249556
    },
    {
        "content": "<p>If the total diff is going to be O(600 lines) then I would be tempted to just PR anyway, and link to this thread in the first message of the PR, and get people to check manually for stuff like this. Note that the second change (<code>Mathlib/Algebra/Algebra/Basic.lean</code>) is a bad module change, but the next few look fine to me. Stuff like Field -&gt; DivisionRing, CommRing -&gt; Semiring and Semiring -&gt; MonoidWithZero look like great changes to me. It will be interesting to see what the results of benchmarking are.</p>",
        "id": 501291723,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1740250015
    },
    {
        "content": "<p>should part of this conversation move to <a class=\"stream\" data-stream-id=\"287929\" href=\"/#narrow/channel/287929-mathlib4\">#mathlib4</a> ? i imagine talking about specific suggestions by the tool will be more appropriate there, while talking about implementation of this kind of tool would (i think) still be appropriate <del>here</del> (edit: in <a class=\"stream\" data-stream-id=\"270676\" href=\"/#narrow/channel/270676-lean4\">#lean4</a>)?</p>",
        "id": 501293189,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1740251330
    },
    {
        "content": "<p>12 messages were moved here from <a class=\"stream-topic\" data-stream-id=\"270676\" href=\"/#narrow/channel/270676-lean4/topic/Elab.20to.20generalize.20type.20classes.20for.20theorems/with/498862988\">#lean4 &gt; Elab to generalize type classes for theorems</a> by <span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span>.</p>",
        "id": 501293636,
        "sender_full_name": "Notification Bot",
        "timestamp": 1740251713
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Elab.20to.20generalize.20type.20classes.20for.20theorems/near/501291723\">said</a>:</p>\n<blockquote>\n<p>If the total diff is going to be O(600 lines) then I would be tempted to just PR anyway, and link to this thread in the first message of the PR, and get people to check manually for stuff like this.</p>\n</blockquote>\n<p>The current diff is over a commit that's ~2 weeks old so it's got plenty of merge conflicts already, but I'll keep that in mind for when I prepare the changes to upstream. Ideally, I'd like my code to be in a more complete state before preparing any derivative changes, though I'll probably have some small changes to split off before then.</p>",
        "id": 501295741,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1740253528
    },
    {
        "content": "<p>I think you should make a PR anyway, even if it has conflicts</p>",
        "id": 501301926,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1740258816
    },
    {
        "content": "<p>Then people can start extracting parts they like into spin-off PRs. You can always force-push over the original PR when you re-run</p>",
        "id": 501301959,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1740258842
    },
    {
        "content": "<p>I got caught up in a refactor and have not yet gotten to this, but will soon.</p>",
        "id": 502047771,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1740576836
    },
    {
        "content": "<p>I had a question about how to structure this to eventually upstream to Mathlib. I originally wrote the code as a command elab because that's what matched what I learned in Metaprogamming in Lean. Later I realized it could be a linter and that I could then use @[nolint] since at least one theorem requires it, but then after porting the code to use Lean's Linter architecture I realized that @[nolint] is specific to Batteries' linter architecture, which only supports MetaM. So now I have no idea if this should even be a Linter since it seems like it adds nothing and has some costs. At this point either approach is fine for me. Feedback welcome.</p>",
        "id": 502048885,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1740577162
    },
    {
        "content": "<p>There are two types of linters; environment and syntax. Which one are you trying to explore, and why is MetaM an issue?</p>",
        "id": 502054508,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1740578611
    },
    {
        "content": "<p>Up until now I've worked on Syntax and I think that's the right way to go. That's what I meant with the MetaM comment since I thought that I would not be able to retrieve Syntax for declarations, but now I'm not sure if that's actually correct.</p>",
        "id": 502076426,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1740583856
    },
    {
        "content": "<p>Perhaps a related question: there is no equivalent for @[nolint] for linters in Mathlib (or perhaps just an extension of @[nolint] so both use the same attribute), instead a number of linters seem to use a number of scripts/nolints* files for the same purpose. Is there a principaled reason for this or is it just vestigial?</p>",
        "id": 502077206,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1740584082
    },
    {
        "content": "<p>The way to silence a syntax linter is to use <code>set_option linter.option false</code>.</p>",
        "id": 502077665,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1740584200
    },
    {
        "content": "<p>However, this normally is an indication that the exception is something that probably should not be linted in the first place, and it is ok to allow it.</p>",
        "id": 502077784,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1740584234
    },
    {
        "content": "<p>Aha, I had not seen this pattern before. So <code>set_option linter.xyz false in</code> seems to be kind of the idiomatic equivalent of <code>@[nolint]</code></p>",
        "id": 502077924,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1740584274
    },
    {
        "content": "<p>The <code>nolints</code> file are typically exceptions that should be resolved, in the sense that the linter is \"right\" in excepting them.  Usually they are accumulated debt from introducing a linter late: you cannot/do not want to fix all the exceptions, but you still want to avoid introducing more exceptions in future code.</p>",
        "id": 502078069,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1740584301
    },
    {
        "content": "<p>A good example of this is the <code>docPrime</code> linter: the idea is that every declaration that ends in <code>'</code> should have an explanation of why it exists with this name, rather than something more descriptive.</p>",
        "id": 502078254,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1740584349
    },
    {
        "content": "<p>However, when the linter was added, there were already over 4k exceptions.</p>",
        "id": 502078329,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1740584365
    },
    {
        "content": "<p>So, those exceptions were engulfed in a giant nolints file and new declarations were no longer allowed to end in <code>'</code>.</p>",
        "id": 502078412,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1740584391
    },
    {
        "content": "<p>If, for some reason, a future declaration was supposed to be allowed to end in <code>'</code> and not have a doc-string, then <code>set_option linter.docPrime false in</code> would be the \"correct\" solution, instead of increasing the nolints file.</p>",
        "id": 502078633,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1740584441
    },
    {
        "content": "<p>That all makes sense and helps motivate how I should proceed, thanks!</p>",
        "id": 502078719,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1740584461
    },
    {
        "content": "<p>I've put up <a href=\"https://github.com/leanprover-community/mathlib4/pull/22337\">#22337</a> for review. It's branched off of the current master. I only included a subset of the generalizations (~350 in total). In particular I avoided any rewrites that would increase lines past &gt;100 chars to avoid hitting linter warnings, and I also excluded all AddCommGroup -&gt; AddCommMonoid changes for now.</p>",
        "id": 502117371,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1740595021
    },
    {
        "content": "<p>Looks like there's some interesting errors - probably you should fix those in a separate PR</p>",
        "id": 502127381,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1740598117
    },
    {
        "content": "<p>Also: cool!</p>",
        "id": 502127395,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1740598122
    },
    {
        "content": "<p>I investigated the batch of 30 unusedArguments linter failures and wanted to ask for some feedback. I'd not run the environment linters during development so I hadn't seen that in some cases generalization makes some instances unnecessary. For quick background, the way my linter works is very naive, simply trying to replace text for explicitly specified type classes instances in a theorem's declaration with it's parent type classes. It is not yet aware of instances pulled in from <code>variable</code>s.</p>\n<p>In <a href=\"https://github.com/leanprover-community/mathlib4/pull/22337/commits/108b761a5eb7ac1e179ca6b2df2305463fe8d576\">20/30</a> linter failures, this was cases that we would expect, things like generalizing <code>[StarAddMonoid A]</code>-&gt;<code>[Star A]</code> meaning we no longer need <code>[AddMonoid A]</code>.<br>\nIn <a href=\"https://github.com/leanprover-community/mathlib4/pull/22337/commits/e0415e4b00219df136eea406a12abac855753599\">8/30 cases</a> something more pernicious was happening, a theorem would use e.g. <code>[Module R M]</code> in the scope of <code>variable {Module R M}</code> block, and my linter would try to replace it with something more general and it would succeed because the implicit instance was being pulled in from the variable block. I changed my linter to reject generalizations when it caused a new parameter to be added to the theorem's type.<br>\nThe <a href=\"https://github.com/leanprover-community/mathlib4/pull/22337/commits/892a47f7634516d5caa680df706fb34b1bf2a0eb\">final 2 cases</a> are what I'm less sure about, these are cases where by weakening the instance's type class, we caused it to be implicitly synthesized instead, e.g. for</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">finite_of_fg_torsion</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hM</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">IsTorsion</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">root_</span><span class=\"bp\">.</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n</code></pre></div>\n<p>deleting <code>[Module ℤ M]</code> just causes it to be implicitly synthesized using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AddCommGroup.toIntModule#doc\">docs#AddCommGroup.toIntModule</a>. This is not a generalization, but just replacing an explicit type class with an implicitly synthesized one. This seems like it may be undesirable, since it just makes the code less explicit. I'm not sure if it's also possible that the synthesized type class could also be different in a way that subtly changes the resulting statement of the theorem. I wanted to check if others agreed that I should teach my linter to avoid this case, before I try to figure out the best way to do so.</p>",
        "id": 502220158,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1740643960
    },
    {
        "content": "<p>[Module \\Z M] is a subsingleton (ie all instances are propositionally equal) but because that instance which you link to exists I think we must be discouraging users from creating another one, which makes me think that it's safe to delete. It might be a remnant of before <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AddCommGroup#doc\">docs#AddCommGroup</a> had an inbuilt action of <code>Int</code></p>",
        "id": 502221182,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1740644294
    },
    {
        "content": "<p>I think this actually un-generalises the theorem, in that it now no longer works if you already have a Module that doesn't come from AddCommGroup</p>",
        "id": 502222220,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1740644610
    },
    {
        "content": "<p>But a Z-module which is a monoid is mathematically an AddCommGroup. And the theorem already asks for an AddCommGroup?</p>",
        "id": 502222581,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1740644716
    },
    {
        "content": "<p>Given that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AddCommGroup.toIntModule#doc\">docs#AddCommGroup.toIntModule</a> exists it seems to me that the current set-up is as silly as a theorem asking for <code>[Group G] [Monoid G]</code></p>",
        "id": 502223073,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1740644867
    },
    {
        "content": "<p>We do have at least one ZSmul diamond in mathlib right now (see my unique open PR which Andrew Yang didn't think would fix the problem) but I can't imagine that we want a theorem which is specifically designed to work even if there are diamonds, I think we're supposed to fix the diamonds</p>",
        "id": 502225588,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1740645649
    },
    {
        "content": "<p>In case it's useful, the second example of this is a case of deleting <code>[Module R₀ P.Cotangent]</code> and instead using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Algebra.Extension.instModuleCotangent#doc\">docs#Algebra.Extension.instModuleCotangent</a>. Since it may be useful to delete some instances, perhaps I won't implement a change to filter them out yet, and instead I'll collect cases where this happens and see what people think when I have more examples, as this PR is only a subset of all generalizations found</p>",
        "id": 502245773,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1740651596
    },
    {
        "content": "<p>Aah now this one isn't a subsingleton so deleting it might in theory actually change the meaning of some theorems, and if this happens in practice then it will probably change them to what the user actually meant to write :-)</p>",
        "id": 502267102,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1740658100
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Elab.20to.20generalize.20type.20classes.20for.20theorems/near/502225588\">said</a>:</p>\n<blockquote>\n<p>but I can't imagine that we want a theorem which is specifically designed to work even if there are diamonds, I think we're supposed to fix the diamonds</p>\n</blockquote>\n<p>At once point this actually was something we wanted, but this was before we introduced <code>AddGroup.zsmul</code></p>",
        "id": 502274383,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1740660296
    },
    {
        "content": "<p>I have been finishing up some remaining edge case investigation in mathlib and just thought I'd share here. My linter currently tries to repeatedly replace a type class with a parent type class (note: only one at a time, if it has e.g. 3 parent type classes it won't try to replace it with 2/3). It will only report the most general type class, assuming generalization only follows a single parent in the tree. If there is a fork, it will report multiple \"most general\" type classes. This only occurs twice, once is because in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=HahnSeries.embDomain_one#doc\">docs#HahnSeries.embDomain_one</a> it wants to replace <code>NonAssocSemiring</code> with either <code>AddMonoidWithOne</code> or <code>MulZeroOneClass</code> (what it actually wants is <code>[Zero R] [One R]</code> but the linter isn't smart enough for that.)</p>\n<p>The other is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ordinal.type_eq_zero_of_empty#doc\">docs#Ordinal.type_eq_zero_of_empty</a> where <code>IsWellOrder</code> can be replaced by any of its parents, because <code>IsEmpty</code> means that it can be implicitly synthesized. My linter avoids reporting 'generalizations' if just deleting the entire class still causes the theorem to succeed to compile [1], and in this case because <code>r</code> does not have a type, it fails to synthesize <code>IsWellOrder</code> using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=instIsWellOrderOfIsEmpty#doc\">docs#instIsWellOrderOfIsEmpty</a> Adding a type to <code>r</code> silences the 'generalization'</p>\n<p>[1] There is already a linter that reports if a type class is unused, so deleting it just means that it causes an explicit type class to be made implicit via synthesis or being pulled in from a <code>variable</code> block, and this should IMO be up to the discretion of the author.</p>",
        "id": 503207719,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1741077233
    },
    {
        "content": "<p>I've been somewhat hesitant to start looking at generalizing type classes inherited from <code>variable</code> blocks as these changes will be painful to automatically apply, I will probably hold off any investigation until I get more feedback on the current changes to ensure the current results are providing value.</p>",
        "id": 503209135,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1741077721
    },
    {
        "content": "<p>Going to use this thread a bit for non-PR review chat.</p>",
        "id": 505934592,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1742113250
    },
    {
        "content": "<p>One thing I realized the other day is that many possible generalizations are not expressed by parent type classes in the hierarchy, e.g. Semifield is not a parent of Field, T2Space is not a parent of T1Space, etc. I ran a build with the following additional parent relationships injected:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>(Child, (Parents))</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"ss\">`Group</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"ss\">`DivisionMonoid</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"ss\">`CancelMonoid</span><span class=\"o\">]),</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"ss\">`AddGroup</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"ss\">`SubtractionMonoid</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"ss\">`AddCancelMonoid</span><span class=\"o\">]),</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"ss\">`CommGroup</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"ss\">`CancelCommMonoid</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"ss\">`DivisionCommMonoid</span><span class=\"o\">]),</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"ss\">`AddCommGroup</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"ss\">`AddCancelCommMonoid</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"ss\">`SubtractionCommMonoid</span><span class=\"o\">]),</span>\n\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"ss\">`CommSemiring</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"ss\">`NonUnitalCommSemiring</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"ss\">`CommMonoidWithZero</span><span class=\"o\">]),</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"ss\">`CommRing</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"ss\">`CommSemiring</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"ss\">`NonUnitalCommRing</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"ss\">`AddCommGroupWithOne</span><span class=\"o\">]),</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"ss\">`DivisionRing</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"ss\">`DivisionSemiring</span><span class=\"o\">]),</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"ss\">`Field</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"ss\">`Semifield</span><span class=\"o\">]),</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"ss\">`NonUnitalCommRing</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"ss\">`NonUnitalCommSemiring</span><span class=\"o\">]),</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"ss\">`Ring</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"ss\">`NonUnitalRing</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"ss\">`NonAssocRing</span><span class=\"o\">]),</span>\n\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"ss\">`NormedDivisionRing</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"ss\">`NormedRing</span><span class=\"o\">]),</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"ss\">`DenselyNormedField</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"ss\">`NontriviallyNormedField</span><span class=\"o\">]),</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"ss\">`NormedField</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"ss\">`NormedDivisionRing</span><span class=\"o\">]),</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"ss\">`NormedField</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"ss\">`NormedCommRing</span><span class=\"o\">]),</span>\n\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"ss\">`T1Space</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"ss\">`T0Space</span><span class=\"o\">]),</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"ss\">`T2Space</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"ss\">`T1Space</span><span class=\"o\">]),</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"ss\">`T25Space</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"ss\">`T2Space</span><span class=\"o\">]),</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"ss\">`T3Space</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"ss\">`T25Space</span><span class=\"o\">]),</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"ss\">`T35Space</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"ss\">`T3Space</span><span class=\"o\">]),</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"ss\">`T4Space</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"ss\">`T35Space</span><span class=\"o\">]),</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"ss\">`T5Space</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"ss\">`T4Space</span><span class=\"o\">]),</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"ss\">`T6Space</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"ss\">`T5Space</span><span class=\"o\">]),</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"ss\">`CompletelyRegularSpace</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"ss\">`RegularSpace</span><span class=\"o\">]),</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"ss\">`PerfectlyNormalSpace</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"ss\">`CompletelyNormalSpace</span><span class=\"o\">]),</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"ss\">`CompletelyNormalSpace</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"ss\">`NormalSpace</span><span class=\"o\">]),</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"ss\">`PathConnectedSpace</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"ss\">`ConnectedSpace</span><span class=\"o\">]),</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"ss\">`IrreducibleSpace</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"ss\">`ConnectedSpace</span><span class=\"o\">]),</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"ss\">`PreirreducibleSpace</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"ss\">`PreconnectedSpace</span><span class=\"o\">]),</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"ss\">`R1Space</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"ss\">`R0Space</span><span class=\"o\">]),</span>\n</code></pre></div>\n</div></div>\n<p>For T*Space most of the results were junk, e.g. 'generalizing' a theorem about a T2Space to a T0Space, because T0Space + IsTopologicalRing recovers the Hausdorff property. In this case it, would be useful to not offer a generalization if the 'generalized' definition still allows you to synthesize the original type class. This seems obvious now, and in fact perhaps this offers a different way of filtering away useless generalizations, instead of writing code that specifically looks for the case where I have <code>[Ring R] [AddCommMonoid M] [Module R M]</code>, maybe I just add an <code>instance [Ring R] [AddCommMonoid M] [Module R M] : AddCommGroup M</code> that's included only when the generalizer runs to make it clear AddCommGroup-&gt;AddCommMonoid does nothing.</p>",
        "id": 505934986,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1742113603
    },
    {
        "content": "<p>I think <code>instance [Ring R] [AddCommMonoid M] [Module R M] : AddCommGroup M</code> is a recipe for diamonds. I thought we had it already in some form? Edit: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Module.addCommMonoidToAddCommGroup#doc\">docs#Module.addCommMonoidToAddCommGroup</a> (not an instance)</p>",
        "id": 505935258,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1742113827
    },
    {
        "content": "<p>Yeah my idea was to only inject it when the generalizer is running, though maybe that's more trouble than it's worth</p>",
        "id": 505943221,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1742120536
    }
]