[
    {
        "content": "<p>I have never understood Lean 4 coercions. There are the myriad typeclasses (<code>Coe</code>, <code>CoeTC</code>, <code>CoeOut</code>, <code>CoeOTC</code>, <code>CoeHead</code>, <code>CoeHTC</code>, <code>CoeTail</code>, <code>CoeHTCT</code>, <code>CoeDep</code>, <code>CoeT</code>,  many of which are I think implementation details) as well as <code>CoeFun</code> and <code>CoeSort</code> (which I think I do understand) and then also the attribute <code>@[coe]</code> which I think is just for up-arrow notation. I just reviewed a PR on profinite groups and noticed this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ProfiniteGrp</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"c1\">-- an object in the category of profinite groups.</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- ↑P.toProfinite.toTop : Type</span>\n</code></pre></div>\n<p>Is that what we want to happen here? It looks a bit ridiculous to me, but I'm not sure that with the current set-up we can just make <code>↑P : Type</code> be a thing because</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CoeSort</span><span class=\"w\"> </span><span class=\"n\">ProfiniteGrp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">toProfinite</span>\n</code></pre></div>\n<p>really means <code>coe G := G.toProfinite.toTop.α</code> and in particular there doesn't seem to be a bare function which we can tag with <code>@[coe]</code>. Are we just doomed to have this silly-looking <code>↑P.toProfinite.toTop</code> in our goals?</p>",
        "id": 491896206,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1736014264
    },
    {
        "content": "<p>It's always possible to write a custom delaborator that prints that specific term as a coercion</p>",
        "id": 491898516,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1736016186
    },
    {
        "content": "<p><code>@[coe]</code> is nothing more than a mechanism to reuse an existing delaborator in the simple cases</p>",
        "id": 491898545,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1736016217
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Coercions/near/491898516\">said</a>:</p>\n<blockquote>\n<p>It's always possible to write a custom delaborator that prints that specific term as a coercion</p>\n</blockquote>\n<p>If this delaborator were written for the example above (profinite groups to Type) then it would merely be a syntactic change, thus tidying up printed output, whilst having no affect on mathlib?</p>",
        "id": 491898694,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1736016326
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Coercions/near/491898545\">said</a>:</p>\n<blockquote>\n<p><code>@[coe]</code> is nothing more than a mechanism to reuse an existing delaborator in the simple cases</p>\n</blockquote>\n<p>It's also the mechanism to configure the <code>norm_cast</code> tactics, which <span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> pointed out to me.</p>",
        "id": 491900249,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1736017586
    },
    {
        "content": "<p>If you want a bare function to tag with <code>@[coe]</code>, you can make one:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">coe</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ProfiniteGrp</span><span class=\"bp\">.</span><span class=\"n\">toType</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ProfiniteGrp</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">G</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CoeSort</span><span class=\"w\"> </span><span class=\"n\">ProfiniteGrp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ProfiniteGrp</span><span class=\"bp\">.</span><span class=\"n\">toType</span>\n</code></pre></div>\n<p>I think it's generally better to define coercions using an auxiliary function like this for this reason.</p>\n<p>Presumably you'd have a simp lemma to rewrite <code>↑P.toProfinite.toTop</code> to <code>↑P</code>.</p>",
        "id": 491900474,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1736017790
    },
    {
        "content": "<p>Agreed, I think auxiliary functions are likely the way to go here.</p>",
        "id": 491900951,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1736018178
    },
    {
        "content": "<p>You probably want an abbrev not a def, otherwise you have to copy over all the instances again</p>",
        "id": 491929957,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1736046368
    },
    {
        "content": "<p>Do we have a linter that all <code>Coe</code> instances are tagged with <code>@[coe]</code>? Should we?</p>",
        "id": 499864192,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739583515
    },
    {
        "content": "<p>I don't think we should, I think there are cases where you want automatic insertion but you'd prefer to always see the full name in the goal view</p>",
        "id": 499954093,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739656975
    },
    {
        "content": "<p>But I guess there could be a <code>@[no_coe_pp]</code> attribute, and a linter that ensures either that or <code>@[coe]</code> is present</p>",
        "id": 499954127,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739657002
    },
    {
        "content": "<p>I was thinking you would just use <code>@[nolint]</code> when you don't want to use <code>@[coe]</code></p>",
        "id": 499963569,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739666137
    }
]