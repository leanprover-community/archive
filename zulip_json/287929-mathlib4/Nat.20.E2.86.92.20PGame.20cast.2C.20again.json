[
    {
        "content": "<p>Thinking back to this instance. I don't know if we should even have it.</p>",
        "id": 469290453,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726034433
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SetTheory.PGame.instNatCast#doc\">docs#SetTheory.PGame.instNatCast</a></p>",
        "id": 469290486,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726034453
    },
    {
        "content": "<p>The issue is: this doesn't match the usual definition of natural numbers as games through the correspondence <code>n = {0, 1, ..., n - 1 | }</code></p>",
        "id": 469290591,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726034495
    },
    {
        "content": "<p>We have this definition but for greater generality as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ordinal.toPGame#doc\">docs#Ordinal.toPGame</a>. But that file imports both <code>PGame</code> and <code>Game</code>, so if we define the <code>NatCast</code> there, by that point, we will already have defined <code>NatCast</code> on <code>Game</code>.</p>",
        "id": 469290739,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726034558
    },
    {
        "content": "<p>I guess we could split the file in two. Make it strictly about <code>PGame</code>, then make the <code>Game</code> file import it, and move the results on <code>Game</code> to the end of it.</p>",
        "id": 469291004,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726034695
    },
    {
        "content": "<p>Yeah, I'm also realizing now that we will need this <code>NatCast</code> instance if we want to talk about small games or dyadic numbers.</p>",
        "id": 469291198,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726034764
    },
    {
        "content": "<p>There's another problem though. If we define <code>NatCast</code> like this, we don't have the equalities <code>↑0 = 0</code>, <code>↑1 = 1</code>, or <code>↑(n + 1) = ↑n + 1</code>. The last one is unavoidable, but the other two are certainly annoying.</p>",
        "id": 469291273,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726034816
    },
    {
        "content": "<p>So maybe the actual solution is to move <code>Ordinal.toPGame</code> to the <code>PGame</code> file? And define <code>0 = toPGame 0</code> and <code>1 = toPGame 1</code>.</p>",
        "id": 469291363,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726034870
    },
    {
        "content": "<p>Yeah, I know def-eqs are evil and especially when it comes to types, but it is pretty jarring to talk about <code>(0 : ℕ)</code> and <code>(1 : ℕ)</code> and not being able to just write <code>0</code> or <code>1</code></p>",
        "id": 469291807,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726035090
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Nat.20.E2.86.92.20PGame.20cast.2C.20again/near/469291273\">said</a>:</p>\n<blockquote>\n<p>The issue is: this doesn't match the usual definition of natural numbers as games through the correspondence <code>n = {0, 1, ..., n - 1 | }</code></p>\n</blockquote>\n<p>What goes wrong if you define it this way, and then define the <code>Zero</code>/<code>One</code> instances as <code>natCast 0</code>/<code>natCast 1</code>?</p>",
        "id": 469665131,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1726145639
    },
    {
        "content": "<p>There's nothing that really goes wrong, it's just that either we end up duplicating this definition later with <code>Ordinal.toPGame</code>, or we have to move <code>Ordinal.toPGame</code> much earlier</p>",
        "id": 469769489,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726171172
    },
    {
        "content": "<p>Well... There is something that might go wrong. The proofs we have of the arithmetical properties are pretty convoluted, and a lot of them simply case on a <code>PGame</code> to avoid having to use the <code>moveLeft</code> / <code>moveRight</code> API.</p>",
        "id": 469770530,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726171439
    },
    {
        "content": "<p>In particular, we got a bunch of proofs that currently use the fact that the left moves of <code>1</code> are indexed by <code>PUnit</code></p>",
        "id": 469770675,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726171466
    },
    {
        "content": "<p>If we did the redefinition in terms of <code>Ordinal.toPGame</code>, the new type of moves would be the much uglier <code>Ordinal.toType 1</code>.</p>",
        "id": 469770878,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726171528
    },
    {
        "content": "<p>This does have a <code>Unique</code>instance, but working with this is in fact somewhat less direct then just using <code>Unit</code></p>",
        "id": 469770983,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726171554
    },
    {
        "content": "<p>I'm also just a bit skeptical about defining ordinal games before even defining <code>0</code> or <code>1</code>, could we even prove what we want about them?</p>",
        "id": 469771220,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726171620
    },
    {
        "content": "<p>Unless we just made the definition but didn't develop the API for anything other than <code>0</code> or <code>1</code> till much later</p>",
        "id": 469771324,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726171645
    },
    {
        "content": "<p>There's an alternate solution I just came up with</p>",
        "id": 469774112,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726172624
    },
    {
        "content": "<p>We could define <code>n</code> as <code>{n - 1 | }</code> instead</p>",
        "id": 469774145,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726172639
    },
    {
        "content": "<p>It might even be nicer to work with. The only real reason the <code>{0, 1, ... | }</code> definition is considered canonical is because it generalizes to ordinals, but if we're explicitly talking about natural numbers then we don't really need that</p>",
        "id": 469774326,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726172701
    },
    {
        "content": "<p>why not define <code>Ordinal.toPGame</code> first and then use that to define <code>natCast</code>?</p>",
        "id": 469774729,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726172860
    },
    {
        "content": "<p>But actually, as long as the adding ones definition gives the correct answer I don't see any particular reason not to use it</p>",
        "id": 469774894,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726172915
    },
    {
        "content": "<p>I don't think the defeq of this definition is very important</p>",
        "id": 469774970,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726172947
    },
    {
        "content": "<p>It gives the correct <code>Game</code>, but not the \"correct\" <code>PGame</code></p>",
        "id": 469774986,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726172954
    },
    {
        "content": "<p>oh I see, for PGame these are all different</p>",
        "id": 469775077,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726172990
    },
    {
        "content": "<p>in that case, just make definitions for all of them</p>",
        "id": 469775093,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726172997
    },
    {
        "content": "<p><code>2 = (0 + 1) + 1 = {(0 + 1) + 0, (0 + 0) + 1 | } ≡r { 1, 1 | }</code> instead of the expected <code>{ 1 | }</code> or <code>{ 0, 1 | }</code></p>",
        "id": 469775159,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726173005
    },
    {
        "content": "<p>what is that <code>≡</code> there?</p>",
        "id": 469775242,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726173041
    },
    {
        "content": "<p>A relabelling</p>",
        "id": 469775276,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726173060
    },
    {
        "content": "<p>I thought relabellings couldn't change values?</p>",
        "id": 469775343,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726173086
    },
    {
        "content": "<p>Yeah, the value of the game is correct, it's just not assembled like one might expect</p>",
        "id": 469775402,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726173119
    },
    {
        "content": "<p>I'm not sure why we should care about this</p>",
        "id": 469775520,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726173157
    },
    {
        "content": "<p>looking at equality or relabelling of PGames seems like the wrong notion</p>",
        "id": 469775559,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726173176
    },
    {
        "content": "<p>Hm, I think we might have <code>n = { n - 1 | }</code> up to identity, actually</p>",
        "id": 469775653,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726173224
    },
    {
        "content": "<p>If so this might not really be an issue</p>",
        "id": 469775680,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726173236
    },
    {
        "content": "<p>what changed?</p>",
        "id": 469775796,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726173260
    },
    {
        "content": "<p>Up to identity, not relabellings</p>",
        "id": 469775826,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726173274
    },
    {
        "content": "<p>...there's a lot of equivalence relations on <code>PGame</code></p>",
        "id": 469775861,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726173292
    },
    {
        "content": "<p>you just gave a derivation which seems to state otherwise, so I'm asking how that is not the case</p>",
        "id": 469775957,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726173341
    },
    {
        "content": "<p>The identity relation deduplicates elements which are themselves identical, so that <code>{ x, x, ..., x | } ≡ { x | }</code></p>",
        "id": 469776068,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726173385
    },
    {
        "content": "<p>We don't currently have identity in Mathlib, but it's been discussed a lot and there's an open PR that introduces it</p>",
        "id": 469776127,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726173418
    },
    {
        "content": "<p>does that relation subsume relabelling?</p>",
        "id": 469776253,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726173476
    },
    {
        "content": "<p>Yeah, the idea is to remove relabellings after it's introduced</p>",
        "id": 469776330,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726173489
    },
    {
        "content": "<p>Relabellings are not really the correct notion to talk about games being the same</p>",
        "id": 469776383,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726173509
    },
    {
        "content": "<p>is that different from the equivalence relation used by <code>Game</code>?</p>",
        "id": 469776922,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726173741
    },
    {
        "content": "<p>Yes, the equivalence relation used by <code>Game</code> is just the antisymmetrization relation</p>",
        "id": 469776986,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726173779
    },
    {
        "content": "<p>Games with entirely different movesets can still work out to be equivalent (under the antisymmetrization relation)</p>",
        "id": 469777052,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726173798
    },
    {
        "content": "<p>oh so <code>{0, 1 | }</code> is not identity-related to <code>{1 | }</code></p>",
        "id": 469777283,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726173884
    },
    {
        "content": "<p>IMO the adding ones definition looks the most canonical to me</p>",
        "id": 469777396,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726173953
    },
    {
        "content": "<p>people have seen it in many other settings, it doesn't need explication</p>",
        "id": 469777508,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726173990
    },
    {
        "content": "<p>It feels a bit too needlessly complicated IMO. I tried making API for its left moves a while back but got stuck because the left moves of a natural <code>n</code> aren't equal to other naturals.</p>",
        "id": 469778302,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726174301
    },
    {
        "content": "<p>I get that strict equality should be avoided, but talking about e.g. the left moves of a left move is currently basically impossible in the current API otherwise</p>",
        "id": 469778380,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726174325
    },
    {
        "content": "<p><code>IGame</code> (games up to identity) would make this situation better, but it still would be nice to just have <code>moveLeft n = n - 1</code> as a characterizing equality, or something of the sort</p>",
        "id": 469778452,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726174355
    },
    {
        "content": "<p>Instead of having <code>n - 1</code> copies of games that are only identical to <code>n - 1</code> as left moves</p>",
        "id": 469778486,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726174371
    },
    {
        "content": "<p>Compare to <code>Ordinal.toPGame</code>, which does satisfy <code>∃ a &lt; o, (Ordinal.toPGame o).moveLeft i = Ordinal.toPGame a</code> as a strict equality</p>",
        "id": 469779215,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726174641
    },
    {
        "content": "<p>why do you need to talk about left moves directly? That seems very internal-detail</p>",
        "id": 469779411,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726174721
    },
    {
        "content": "<p>They're games! Talking about their moves is most of what we do</p>",
        "id": 469779454,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726174741
    },
    {
        "content": "<p>would it be possible to have an induction principle which allows manipulating them up to identity?</p>",
        "id": 469779481,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726174751
    },
    {
        "content": "<p>Hm, how would that look like?</p>",
        "id": 469779500,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726174764
    },
    {
        "content": "<p>you get to specify the type you want to be the left/right moves, and as long as these types are identity-related to what you want, then you get a value identity-related to the result</p>",
        "id": 469779650,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726174806
    },
    {
        "content": "<p>it's not really clear to me how you actually use this left move function though so it's hard to suggest something formal</p>",
        "id": 469779759,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726174841
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Nat.20.E2.86.92.20PGame.20cast.2C.20again/near/469779454\">said</a>:</p>\n<blockquote>\n<p>They're games! Talking about their moves is most of what we do</p>\n</blockquote>\n<p>Why is it not sufficient to just know that the left moves is some function with some domain? When making constructions you don't generally need to introspect more than that, and equality of types is evil(TM)</p>",
        "id": 469780006,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726174935
    },
    {
        "content": "<p>So basically, a mechanism to cast the indexing types of a <code>PGame</code> to other congruent types?</p>",
        "id": 469780033,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726174949
    },
    {
        "content": "<p>I agree we shouldn't be talking about the domain of the <code>moveLeft</code> function, but talking about its range is quite important.</p>",
        "id": 469780108,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726174991
    },
    {
        "content": "<p>bounds on its range maybe, the exact values I'm not so sure</p>",
        "id": 469780153,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726175014
    },
    {
        "content": "<p>Bounds on its range is certainly too weak, then we couldn't define stuff like birthdays</p>",
        "id": 469780302,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726175056
    },
    {
        "content": "<p>Those require some knowledge about the structure of games. Again, <code>IGame</code> is what we'd ideally be using, but for now we're stuck with <code>PGame</code></p>",
        "id": 469780358,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726175087
    },
    {
        "content": "<p>isn't the birthday just the height of the recursion?</p>",
        "id": 469780407,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726175106
    },
    {
        "content": "<p>Yeah, but different equivalent <code>Game</code>s can have very different heights</p>",
        "id": 469780609,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726175184
    },
    {
        "content": "<p>For instance <code>{ }</code>, or <code>{ -1 | 1 }</code>, or <code>{ -ω₁ | ω₁ }</code> all have very different heights but are equivalent to <code>0</code></p>",
        "id": 469780701,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726175210
    },
    {
        "content": "<p>Maybe the real solution to the original <code>NatCast</code> conundrum is to just wait until <code>IGame</code> drops, refactor all that needs to be, and then see how we proceed.</p>",
        "id": 469780796,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726175268
    },
    {
        "content": "<p>To clarify my point, structural equivalence of games is a mathematically useful notion. But both relabellings and strict equality are stronger than this, and thus not very mathematical.</p>",
        "id": 469781098,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726175403
    },
    {
        "content": "<p>(I don't really have time to be drawn back into this, but I'll throw out there that relabellings are not useful for thinking about the general theory, but very helpful to have on hand once you want to analyze a particular game --- which is very much a part of studying combinatorial games a la Conway!)</p>",
        "id": 469831205,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1726197497
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Nat.20.E2.86.92.20PGame.20cast.2C.20again/near/469831205\">said</a>:</p>\n<blockquote>\n<p>(I don't really have time to be drawn back into this, but I'll throw out there that relabellings are not useful for thinking about the general theory, but very helpful to have on hand once you want to analyze a particular game --- which is very much a part of studying combinatorial games a la Conway!)</p>\n</blockquote>\n<p>Wouldn't that be the purpose of <code>Identical</code>? (I was curious about deprecating Relabellings from a comment brought about in  <a href=\"https://github.com/leanprover-community/mathlib4/pull/20088\">#20088</a>.)Relabellings would only be useful if <code>x ≡r y</code> was equivalent to / implied <code>x = y</code>, but I would be astonished if that was the case. Otherwise, <code>Identical</code> is the more useful definition when trying to analyze a particular game, as it doesn't preserve the type-theoretic notions that this formalization has, as <span class=\"user-mention\" data-user-id=\"459227\">@Violeta Hernández</span> mentioned.</p>",
        "id": 490833001,
        "sender_full_name": "Tristan Figueroa-Reid",
        "timestamp": 1735186786
    },
    {
        "content": "<p>I can see Relabellings as a tool only for faster proofs for identicalness in specific cases.</p>",
        "id": 490833067,
        "sender_full_name": "Tristan Figueroa-Reid",
        "timestamp": 1735186813
    },
    {
        "content": "<p>I agree with you. And really, the functionality given by relabellings can be imitated by the identical relation. We should be able to create a constructor for identicalness given two equivalences mapping games to identical games.</p>",
        "id": 490897013,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1735232483
    }
]