[
    {
        "content": "<p>In <a href=\"https://github.com/leanprover-community/mathlib4/pull/18510\">#18510</a> we're getting the definition of Grothendieck categories. A Grothendieck category is an abelian category that satisfies Grothendieck's axiom AB5 and has a generator. Here is the definition from the PR:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">An abelian category `C` is called a Grothendieck category provided that it has `AB5` and a</span>\n<span class=\"sd\">separator (see `HasSeparator`).</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">class</span><span class=\"w\"> </span><span class=\"n\">GrothendieckCategory</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Abelian</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">HasFilteredColimits</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AB5</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">HasSeparator</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"n\">where</span>\n</code></pre></div>\n<p>I'll admit that I am completely clueless about design tradeoffs in typeclass hierarchies. My first instinct for the definition might have been something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span>\n<span class=\"kd\">class</span><span class=\"w\"> </span><span class=\"n\">GrothendieckCategory</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Abelian</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kd\">extends</span><span class=\"w\"> </span><span class=\"n\">HasFilteredColimits</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">AB5</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">HasSeparator</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"n\">where</span>\n</code></pre></div>\n<p>except that this doesn't work because <code>AB5 C</code> is actually data (because <code>PreservesLimit</code> is data), but arguably it shouldn't be and <code>AB5</code> should wrap the <code>PreservesLimit</code> in a <code>Nonempty</code>. Of course another option could be to put some of the typeclasses as structure fields of <code>GrothendieckCategory</code>.</p>\n<p>I'm sure there are some heuristics that mathlib's hierarchy experts have developed that help decide how best to define a typeclass that is logically the conjunction of several other typeclasses and nothing else. Is there a good place to learn about this? Does anyone have advice?</p>\n<p>cc <span class=\"user-mention\" data-user-id=\"221653\">@Paul Reichert</span></p>",
        "id": 481753810,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1731340286
    },
    {
        "content": "<p>I also think everything apart from <code>Abelian C</code>should be a field of <code>GrothendieckCategory</code> (whether by <code>extends</code> or by introducing explicit fields; I do not care very much about this detail).<br>\nAs for now, I think it is ok if this is not a <code>Prop</code>. The reason is that eventually, I believe that in general <code>PreservesLimit</code> should be made a <code>Prop</code>: I do not think we have any construction which rely on the data in these instances. Then, when we do this refactor, Lean will complain that a class that can be reduced to a <code>Prop</code> is not declared as a <code>Prop</code>, and the fix will be easy.</p>",
        "id": 483020548,
        "sender_full_name": "JoÃ«l Riou",
        "timestamp": 1731936035
    }
]