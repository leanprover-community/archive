[
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"286014\">Robin Carlier</span> <a href=\"#narrow/channel/287929-mathlib4/topic/can.20bicategory.20infrastructure.20be.20applied.20to.20Cat.3F/near/523976912\">said</a>:</p>\n<blockquote>\n<p>Note that with categories and functors, all \"named coherences\" (i.e associators and unitors) are in fact <code>Iso.refl _</code>, so you <code>could</code> in fact just put <code>(Iso.refl : &lt;expected type&gt;)</code> everywhere, and it‚Äôd \"just\" work, even worse, you could even skip them and for some compositions it‚Äôd work... For this kind of things, this is a bit of a \"bug\", because Lean will actually accept <code>Functor.rightUnitor F</code> as an isomorphism <code>ùü≠ _ ‚ãô F ‚âÖ F</code>!</p>\n</blockquote>\n<p>Side remark: this was not the case for Lean 3, but we now have more definitionally equalities.</p>",
        "id": 523978659,
        "sender_full_name": "Yuma Mizuno",
        "timestamp": 1749832432
    },
    {
        "content": "<p>Oh I don‚Äôt remember this fact about lean 3, that‚Äôs interesting. I have sometimes wondered if things wouldn‚Äôt in fact be <em>better</em> if functor composition was not defeq-associative and defeq-unitary (but still prop-eq associative and prop-eq unitary).</p>",
        "id": 523979044,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1749832600
    },
    {
        "content": "<p>Actually, it is very easy to write \"type incorrect\" expressions, some of them may be found in e.g., <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Adjunction#doc\">docs#CategoryTheory.Adjunction</a> file.</p>",
        "id": 523979440,
        "sender_full_name": "Yuma Mizuno",
        "timestamp": 1749832780
    },
    {
        "content": "<p>Yes, I remember <a href=\"https://github.com/leanprover-community/mathlib4/pull/23698\">fixing one in whiskering</a> as well, and that what made me think that It‚Äôd be better if lean was throwing an error in cases like this, which it would if things were not defeq.</p>",
        "id": 523980165,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1749833050
    },
    {
        "content": "<p>I just would like to say that replacing <code>Functor.associator _ _ _</code>, etc, by <code>Iso.refl _</code> would be problematic. When we want to show certain properties of natural isomorphisms, for example show that an isomorphism is compatible with shifts (which are recorded in instances <code>Functor.CommShift</code>: this applies in particular for triangulated functors), the source and the target of an associator are not equipped with definitionally equal instances of <code>Functor.CommShift</code>(but they are compatible, see <a href=\"https://github.com/leanprover-community/mathlib4/blob/7deb334c5f5104f4edad1a6396dd02a8cddefb86/Mathlib/CategoryTheory/Shift/CommShift.lean#L343-L347\">https://github.com/leanprover-community/mathlib4/blob/7deb334c5f5104f4edad1a6396dd02a8cddefb86/Mathlib/CategoryTheory/Shift/CommShift.lean#L343-L347</a> ). In <a href=\"https://github.com/leanprover-community/mathlib4/pull/20490\">#20490</a>, with <span class=\"user-mention\" data-user-id=\"318709\">@Sophie Morel</span>, we changed the definition of the composition of adjunctions by adding explicit associators, and this way we got better automation (for things like adjunctions between triangulated categories, see <a href=\"https://github.com/leanprover-community/mathlib4/pull/20337\">#20337</a>).</p>",
        "id": 523980180,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1749833057
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"459699\">@Jo√´l Riou</span> , I agree with you, which is why I said \"even worse\" in my message, and said it‚Äôs \"a bug\".<br>\nI don‚Äôt advocate for this and I‚Äôve also had cases of very slow elaboration or bad automation when trying to power through by defeq abuse.<br>\n(Though, I wonder how much we can get away with <code>Iso.refl _</code> if we provide the right type hints? Is it really different to write <code>Functor.associator _ _ _</code> and <code>(Iso.refl _ : (_ ‚ãô _) ‚ãô _ ‚âÖ _ ‚ãô _ ‚ãô _)</code>?)  (Edit: your example about <code>CommShift</code> shows that we probably can‚Äô t do that everywhere, at the very least).</p>\n<p>But I‚Äôm also worried that the fact that this is a possibility makes it much harder to write a suitable \"Categorical composition\": when writing <code>‚äó‚â´</code>, there‚Äôs always the possibility that the LHS or RHS unifies with the \"wrong\" thing due to that defeq, right?</p>",
        "id": 523981162,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1749833456
    },
    {
        "content": "<p>6 messages were moved here from <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/channel/287929-mathlib4/topic/can.20bicategory.20infrastructure.20be.20applied.20to.20Cat.3F/with/523960218\">#mathlib4 &gt; can bicategory infrastructure be applied to Cat?</a> by <span class=\"user-mention silent\" data-user-id=\"438192\">Yuma Mizuno</span>.</p>",
        "id": 523982233,
        "sender_full_name": "Notification Bot",
        "timestamp": 1749833889
    },
    {
        "content": "<p>I tried to be very careful about not abusing defeq in the project that Emily mentioned, but it was not always easy for the reason that Robin was talking about: sometimes I would put a <code>unitor</code> or <code>associator</code> in the wrong direction, and it would still be accepted! In the end I had to make a lot of variable explicit, which helped with speed issues too. But it was painful, and the biggest problem is that it makes the code more painful to fix if I make a change somewhere upstream.</p>",
        "id": 523994139,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1749838728
    },
    {
        "content": "<p>Can we set a transparency setting somewhere so that Lean cannot see these defeqs?</p>",
        "id": 524001991,
        "sender_full_name": "Yuma Mizuno",
        "timestamp": 1749842392
    },
    {
        "content": "<p>I don't know what a transparency setting is, but I would love a way to force Lean to be more annoying. (Just on this particular point though.)</p>",
        "id": 524002242,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1749842530
    },
    {
        "content": "<p>Here the transparency setting means putting <code>irreducible</code> at some definitions, but this is just a naive idea.</p>",
        "id": 524002532,
        "sender_full_name": "Yuma Mizuno",
        "timestamp": 1749842699
    },
    {
        "content": "<p>Thanks for the explanation!</p>",
        "id": 524002716,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1749842804
    },
    {
        "content": "<p>I tried blindly slapping an <code>irreducible</code> on <code>Functor.comp</code>, it doesn‚Äôt work super well, and we have to put an  <code>unseal Functor.comp in</code> each time we want to define a natural transformation to/from a composition of functors.</p>",
        "id": 524003236,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1749843065
    },
    {
        "content": "<p>Putting <code>irreducible</code> only to <code>comp.map</code> is enough to hide the undesired defeqs, which is a much milder setting than putting <code>irreducible</code> to the entire <code>Functor.comp</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">irreducible</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">compMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚•§</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"bp\">‚•§</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">   </span><span class=\"n\">G.obj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F.obj</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">G.obj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F.obj</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">G.map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F.map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simps</span><span class=\"w\"> </span><span class=\"n\">obj</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚•§</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"bp\">‚•§</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚•§</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">G.obj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F.obj</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">compMap</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">f</span>\n</code></pre></div>",
        "id": 526531520,
        "sender_full_name": "Yuma Mizuno",
        "timestamp": 1751350569
    },
    {
        "content": "<p>By applying this change to downstream files, Lean found that the statement of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.isoWhiskerRight_left#doc\">docs#CategoryTheory.isoWhiskerRight_left</a>, which is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">    </span><span class=\"n\">isoWhiskerRight</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">isoWhiskerLeft</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">    </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">associator</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">‚â™‚â´</span><span class=\"w\"> </span><span class=\"n\">isoWhiskerLeft</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">isoWhiskerRight</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚â™‚â´</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">associator</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>is type incorrect. The correct statement is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">    </span><span class=\"n\">isoWhiskerRight</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">isoWhiskerLeft</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">    </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">associator</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">‚â™‚â´</span><span class=\"w\"> </span><span class=\"n\">isoWhiskerLeft</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">isoWhiskerRight</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚â™‚â´</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">associator</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n</code></pre></div>",
        "id": 526686817,
        "sender_full_name": "Yuma Mizuno",
        "timestamp": 1751405893
    },
    {
        "content": "<p>WIP branch for this experiment: <a href=\"https://github.com/leanprover-community/mathlib4/pull/26601\">#26601</a>. Anyone interested is welcome to ask about write access permissions.</p>",
        "id": 526686919,
        "sender_full_name": "Yuma Mizuno",
        "timestamp": 1751405965
    },
    {
        "content": "<p>Nice! It's very easy to make this kind of mistake, I had a <code>Functor.leftUnitor</code> instead of <code>Functor.rightUnitor</code> in some of my code and it was typechecking, I only noticed when I was trying to prove further properties. (Not because of an error in Lean, but because I wrote things out on paper and saw that the identity functor was on the wrong side.)</p>",
        "id": 526726494,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1751436876
    },
    {
        "content": "<p>Looking at the error message for your branch, I notice a lot of errors in <code>Mathlib/CategoryTheory/ObjectProperty/FullSubcategory.lean</code>, which reminds me that I had some beef with the way full subcategories are implemented in mathlib and was toying with the idea of suggesting a refactor.</p>",
        "id": 526726708,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1751436998
    },
    {
        "content": "<p>Whoops, <code>isoWhiskerRight_left</code> is my doing...</p>",
        "id": 526739917,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1751442653
    },
    {
        "content": "<p>(Regarding full subcategories, there is <a href=\"https://github.com/leanprover-community/mathlib4/pull/26446\">#26446</a> in the brewing, which I‚Äôm hyped for)</p>",
        "id": 526744137,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1751444019
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"286014\">Robin Carlier</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Functor.20identity.20.60.F0.9D.9F.AD.20_.20.E2.8B.99.20F.20.3D.20F.60.20is.20definitional.20equality/near/526744137\">said</a>:</p>\n<blockquote>\n<p>(Regarding full subcategories, there is <a href=\"https://github.com/leanprover-community/mathlib4/pull/26446\">#26446</a> in the brewing, which I‚Äôm hyped for)</p>\n</blockquote>\n<p>Yes, that's exactly what I wanted to do!</p>",
        "id": 526772196,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1751453190
    },
    {
        "content": "<p>Okay, now I need to leave reviews so that it gets merged.</p>",
        "id": 526773724,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1751453704
    },
    {
        "content": "<p>It‚Äôs still tagged \"WIP\" though.</p>",
        "id": 526779664,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1751455704
    },
    {
        "content": "<p>I continued to further downstream files.</p>\n<p>One thing I found is that to prove </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">equivalence‚ÇÇCounitIso</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">eB</span><span class=\"bp\">.</span><span class=\"n\">functor</span><span class=\"w\"> </span><span class=\"bp\">‚ãô</span><span class=\"w\"> </span><span class=\"n\">e'</span><span class=\"bp\">.</span><span class=\"n\">inverse</span><span class=\"w\"> </span><span class=\"bp\">‚ãô</span><span class=\"w\"> </span><span class=\"n\">eA</span><span class=\"bp\">.</span><span class=\"n\">inverse</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚ãô</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">‚ãô</span><span class=\"w\"> </span><span class=\"n\">eB</span><span class=\"bp\">.</span><span class=\"n\">inverse</span><span class=\"w\"> </span><span class=\"bp\">‚âÖ</span><span class=\"w\"> </span><span class=\"mi\">ùü≠</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>where <code>e</code>, <code>eA</code>, and <code>eB</code> are equivalences, in the AlgebraicTopology\\DoldKan\\Compatibility.lean file, we now have to give an isomorphism of the form</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">‚ãô</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">‚ãô</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚ãô</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"bp\">‚ãô</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">‚âÖ</span>\n<span class=\"w\">  </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">‚ãô</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">‚ãô</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚ãô</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚ãô</span><span class=\"w\"> </span><span class=\"n\">E</span>\n</code></pre></div>\n<p>at the first step of the proof. Of course we can write it, but I feel I now really want to the machinery what we have in the bicategory library (constructing this by a tactic or an instance resolution).</p>",
        "id": 526807195,
        "sender_full_name": "Yuma Mizuno",
        "timestamp": 1751464402
    },
    {
        "content": "<p>I wonder how much it is possible to have machinery not only for functors and natural transformations but also for other \"unbundled bicategory-like\" (\"meta-bicategories\"?) structures? In a recent series of PR I play with \"categorical transforms of cospans\", in <a href=\"https://github.com/leanprover-community/mathlib4/pull/26447\">#26447</a> I show that whatever this gadget is, it behaves like a bicategory (the reason it‚Äôs not one is, as usual, universes...), but I don‚Äôt have any tooling so the proof that when constructing equivalences, the right triangle identity is implied by the left triangle identity <a href=\"https://github.com/robin-carlier/mathlib4/blob/14e2bd4c25a61584bc07895a8876fa9822fb8601/Mathlib/CategoryTheory/Limits/Shapes/Pullback/Categorical/CatCospanTransform.lean#L694-L734\">ends up looking like this</a> while it‚Äôs in fact <a href=\"https://github.com/leanprover-community/mathlib4/blob/eeb88358d567f59a9b073788fd89f5bab5db153c/Mathlib/CategoryTheory/Bicategory/Adjunction/Basic.lean#L64-L76\">exactly the one in the Bicategory setting</a></p>",
        "id": 526810212,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1751465185
    },
    {
        "content": "<p>(note that in the situation above, at least <code>aesop_cat</code> finds that the meta-bicategory is strict so replaces \"by bicategory\" but you still have to painfully write the coherence 2-cells by yourself...)</p>",
        "id": 526810728,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1751465318
    },
    {
        "content": "<p>(Though, I can golf this particular proof to a non-calc one  so the point don‚Äôt really apply in this case, but I think there might be other situations where this would be nice).</p>",
        "id": 526817833,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1751467125
    },
    {
        "content": "<p>It would be nice to have machinery that can be applied to any \"bicategory-like\" situations, not only <code>Category</code>/<code>Functor</code>/<code>NatTrans</code>.</p>",
        "id": 526833713,
        "sender_full_name": "Yuma Mizuno",
        "timestamp": 1751471533
    },
    {
        "content": "<p>Would it work to annotate associators like morphisms and write a tactic that try to apply them to goals? (It seems to be a non-Prop simp?)</p>",
        "id": 526834322,
        "sender_full_name": "Yuma Mizuno",
        "timestamp": 1751471728
    },
    {
        "content": "<p>I made several fixes on this direction, but there are too many files to be touched, and I'm not sure I can continue to work on this right now.</p>\n<p>As a tentative achievement, I made a PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/26701\">#26701</a>, which fixed some associator directions and inserted associators and unitros in several files.</p>",
        "id": 527059148,
        "sender_full_name": "Yuma Mizuno",
        "timestamp": 1751569657
    }
]