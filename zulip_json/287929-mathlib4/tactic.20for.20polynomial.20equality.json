[
    {
        "content": "<p>It's currently quite annoying to prove equality of polynomials using <code>ring</code>, because <code>ring</code> isn't aware that <code>Polynomial.C</code> is a homomorphism:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">Polynomial</span><span class=\"bp\">.</span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">ring</span>\n<span class=\"w\">  </span><span class=\"c\">/-</span>\n<span class=\"cm\">  a : ℚ</span>\n<span class=\"cm\">  ⊢ Polynomial.C a * Polynomial.X * 2 + Polynomial.C a ^ 2 + Polynomial.X ^ 2 =</span>\n<span class=\"cm\">    Polynomial.X * Polynomial.C (a * 2) + Polynomial.X ^ 2 + Polynomial.C (a ^ 2)</span>\n<span class=\"cm\">  -/</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I have a prototype tactic for proving equations of this form, granted that the exponents are explicit natural numbers.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">Polynomial</span><span class=\"bp\">.</span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">poly</span>\n<span class=\"w\">  </span><span class=\"c\">/-</span>\n<span class=\"cm\">  a : ℚ</span>\n<span class=\"cm\">  ⊢ a + a = 2 * a</span>\n<span class=\"cm\">  a : ℚ</span>\n<span class=\"cm\">  ⊢ a * a = a ^ 2</span>\n<span class=\"cm\">  -/</span>\n</code></pre></div>\n<p>It works quite like <code>ring</code> in that it puts both polynomials into a normal form, except this tactic can then equate the coefficients in the base ring and produce side goals for the user. </p>\n<p>Is there interest for a tactic like this in mathlib? This is my first serious metaprogramming project. It's quite close to being usable, but cleaning up the code would take some time.</p>",
        "id": 501861702,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1740503448
    },
    {
        "content": "<p>Why not teach the tactic that C is a ring homomorphism and have it work for all commutative rings?</p>",
        "id": 501885110,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1740508895
    },
    {
        "content": "<p>It is quite ironic that <code>ring</code> uses (its own version of) polynomials under the hood, but is then actually not so good at proving equalities between <code>Polynomial</code>s <span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span></p>",
        "id": 501962679,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1740545994
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/tactic.20for.20polynomial.20equality/near/501885110\">said</a>:</p>\n<blockquote>\n<p>Why not teach the tactic that C is a ring homomorphism and have it work for all commutative rings?</p>\n</blockquote>\n<p>The reason I chose polynomials is that there is a very clear normal form - group the coefficients by <code>.X^n</code> and move all of them into a single <code>.C</code>. In a more general setting it's not obvious to me (a) what to group by and (b) how to normalise the coefficients.</p>",
        "id": 502013379,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1740566383
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/channel/287929-mathlib4/topic/tactic.20for.20polynomial.20equality/near/501962679\">said</a>:</p>\n<blockquote>\n<p>It is quite ironic that <code>ring</code> uses (its own version of) polynomials under the hood, but is then actually not so good at proving equalities between <code>Polynomial</code>s <span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span></p>\n</blockquote>\n<p>I'll point out <code>ring</code> uses <em>rational</em> polynomials with explicit constants under the hood, so dealing with coefficients in an arbitrary ring is not so obvious!</p>",
        "id": 502013943,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1740566526
    },
    {
        "content": "<p>If we were using <code>a • X ^ n</code> (like quite literally every other algebra) instead of <code>C a * X ^ n</code>, we could simply use <code>module</code> and <code>module_nf</code></p>",
        "id": 502016139,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1740567110
    },
    {
        "content": "<p>I guess you could create a tactic that does the following:</p>\n<ul>\n<li>Turn <code>C a *</code> into <code>a •</code></li>\n<li>Run <code>module</code> or <code>module_nf</code> accordingly</li>\n<li>In the normal form version, turn back <code>a •</code> into <code>C a *</code></li>\n</ul>",
        "id": 502016603,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1740567233
    },
    {
        "content": "<p>But I would much rather we drop the <code>Polynomial</code>/<code>MvPolynomial</code> particularism of using <code>C a</code> instead of <code>•</code> and <code>algebraMap</code></p>",
        "id": 502016868,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1740567298
    },
    {
        "content": "<p>I'm not familiar with <code>module</code>, but it doesn't seem to play very nice with polynomials:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">b</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">a</span><span class=\"bp\">*</span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">a</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Polynomial</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">match_scalars</span>\n<span class=\"w\">  </span><span class=\"c\">/-</span>\n<span class=\"cm\">  a b : ℚ</span>\n<span class=\"cm\">  ⊢ 1 = 0</span>\n<span class=\"cm\">  a b : ℚ</span>\n<span class=\"cm\">  ⊢ 0 = b ^ 2 * 1</span>\n<span class=\"cm\">  a b : ℚ</span>\n<span class=\"cm\">  ⊢ 0 = 2 * a * b * 1</span>\n<span class=\"cm\">  a b : ℚ</span>\n<span class=\"cm\">  ⊢ 0 = a ^ 2 * 1</span>\n<span class=\"cm\">  -/</span>\n<span class=\"w\">  </span><span class=\"n\">repeat</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 502021558,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1740568742
    },
    {
        "content": "<p>It doesn't play very nice with multiplication I think. If you replace all the <code>*</code> by <code>•</code> (by hand), it should work.</p>",
        "id": 502022217,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1740568936
    },
    {
        "content": "<p>Not quite...</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Polynomial</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Polynomial</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Polynomial</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">b</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">a</span><span class=\"bp\">*</span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">a</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Polynomial</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">match_scalars</span>\n<span class=\"w\">  </span><span class=\"c\">/-</span>\n<span class=\"cm\">  a b : ℚ</span>\n<span class=\"cm\">  ⊢ (b • 1 + a • X) * (↑b * 1) = ↑b ^ 2 * 1</span>\n<span class=\"cm\">  a b : ℚ</span>\n<span class=\"cm\">  ⊢ (b • 1 + a • X) * (↑a * 1) = ↑2 * ↑a * ↑b * 1</span>\n<span class=\"cm\">  a b : ℚ</span>\n<span class=\"cm\">  ⊢ 0 = ↑a ^ 2 * 1</span>\n<span class=\"cm\">  -/</span>\n<span class=\"w\">  </span><span class=\"n\">repeat</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 502022756,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1740569097
    },
    {
        "content": "<p>Well, you mix various module structure, the first <code>•</code> is external multiplication by <code>R</code> on <code>R[X]</code>, but the third one is just multiplication in <code>R[X]</code></p>",
        "id": 502023837,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1740569438
    },
    {
        "content": "<p>Right, but if we want a tactic that can solve polynomial equations we surely want it to handle multiplication in<code>R[X]</code>!</p>",
        "id": 502024135,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1740569537
    },
    {
        "content": "<p>Yes of course. I am just saying that the tactic should do something before calling <code>module</code>.</p>",
        "id": 502024628,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1740569710
    },
    {
        "content": "<p>I think that you should probably first normalize to get as close as possible to each individual summand being of the form <code>constant * X ^ n</code> and then replace the <code>*</code>.</p>",
        "id": 502024662,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1740569726
    },
    {
        "content": "<p>As in</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Polynomial</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Polynomial</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">b</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">a</span><span class=\"bp\">*</span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">a</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Polynomial</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">smul_eq_mul</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">add_mul</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mul_add</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mul_add</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">smul_mul_smul_comm</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">smul_mul_smul_comm</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">smul_mul_smul_comm</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">smul_mul_smul_comm</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">pow_two</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">one_mul</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mul_one</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">one_pow</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">module</span>\n</code></pre></div>",
        "id": 502024969,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1740569812
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/channel/287929-mathlib4/topic/tactic.20for.20polynomial.20equality/near/502024662\">said</a>:</p>\n<blockquote>\n<p>I think that you should probably first normalize to get as close as possible to each individual summand being of the form <code>constant * X ^ n</code> and then replace the <code>*</code>.</p>\n</blockquote>\n<p>To be clear, this is essentially what my prototype tactic does. Perhaps I'm duplicating work by matching the coefficients manually rather than calling <code>module</code> or <code>match_scalars</code></p>",
        "id": 502025302,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1740569932
    },
    {
        "content": "<p>If you can piggy-back on the existing <code>module</code> tactic, then your add-on only needs to take care of \"expanding and merging powers\", which means simpler and more robust implementation.</p>",
        "id": 502025539,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1740570014
    },
    {
        "content": "<p>It sounds like you want to write an <code>algebra</code> tactic that replaces <code>algebraMap a * b</code> and <code>b * algebraMap a</code> with <code>a • b</code>, <code>algebraMap a</code> with <code>a • 1</code>, then run <code>module</code></p>",
        "id": 502026487,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1740570338
    },
    {
        "content": "<p>I disagree - the example above is written entirely in terms of <code>•</code> and <code>module</code> fails to solve it as it doesn't handle multiplication in the algebra itself.</p>",
        "id": 502027490,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1740570628
    },
    {
        "content": "<p>Isn't that quite precisely what I said?</p>",
        "id": 502027768,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1740570723
    },
    {
        "content": "<p>My point is that your tactic shouldn't be <code>Polynomial</code>-specific</p>",
        "id": 502027821,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1740570740
    },
    {
        "content": "<p>The tactic should also be aware of distributing multiplications over additions.</p>",
        "id": 502028608,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1740570991
    },
    {
        "content": "<p>and normalizing terms on the RHS of an <code>smul</code>: <code>match_scalars</code> views <code>X*X</code> and <code>X^2</code> as different things</p>",
        "id": 502028780,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1740571053
    },
    {
        "content": "<p>If you end up outsourcing coefficient matching to <code>match_scalars</code>, it would be nice if you could also get <code>match_scalars</code> to label each goal with the name of the coefficient being matched.</p>",
        "id": 502086123,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1740586222
    },
    {
        "content": "<p>So, the goal's list when applying it to a polynomial would tell you from which degree each side goals comes.</p>",
        "id": 502086328,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1740586274
    },
    {
        "content": "<p>Thinking about ringhoms in terms of <code>smul</code> has carified things for me: </p>\n<p>The reason <code>module</code> breaks for an <code>R</code>-algebra <code>A</code> is that it is completely oblivious to multiplication: . <code>a • (x*y)</code> won't match <code>a • (y*x)</code>. To make it work we'd have to (a) distribute out all of the multiplications in <code>A</code> and (b) for every \"product of atoms\" we reorder the product into a canonical ordering (e.g. <code>x*y*x</code> =&gt; <code>x^2*y</code>). </p>\n<p>Now I <em>could</em> write a tactic that first uses <code>simp</code> to distribute out all the products and exponents, then goes through the resulting expression, normalising all of the subterms of type <code>A</code> that are products of atoms. I worry that this approach is brittle. It also comes with an inherent performance penalty: <code>(a+b)^8</code> gets expanded into 256 terms by <code>simp</code></p>\n<p>Another option is to essentially extend <code>module</code>/<code>ring</code> and parse the entire expression into a normal form. That would be a sum of <code>r_i • a_i</code> where each <code>a_i</code> is a normalised product of atoms. At that point there isn't much reason to call out to <code>module</code> - we already have the coefficients in a neat list. If we keep the <code>r_i</code> in ring normal form, this would also solve the exponential blowup problem mentioned before, but that would be a fair bit of work. </p>\n<p>I'm not sure yet which way is best, but the second option seems more fruitful.</p>",
        "id": 502107773,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1740592084
    }
]