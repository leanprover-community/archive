[
    {
        "content": "<p>The following looks like a bug to me, where Lean finds an instance it shouldn't find:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NontriviallyNormedField</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedSpace</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">my_copy</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">E</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">my_copy</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">inferInstanceAs</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">my_copy</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">inferInstanceAs</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">my_copy</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">inferInstanceAs</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">synthInstance</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">Norm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"n\">ùïú</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">my_copy</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- works, while it shouldn't</span>\n</code></pre></div>\n<p>To have a norm on a space of linear maps, you should have a norm on both sides. But there is no norm on <code>my_copy E</code>, it is a type synonym on which I've <em>not</em> registered the norm. The trace shows failure but success, it's very weird.</p>\n<p>Does anyone understand what is going on here?</p>",
        "id": 525980562,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1750971854
    },
    {
        "content": "<p>(It's not a theoretical question, this is blocking me on my work on Riemannian metrics)</p>",
        "id": 525980672,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1750971910
    },
    {
        "content": "<p>Unsurprisingly this still reproduces with <code>import Mathlib.Analysis.NormedSpace.OperatorNorm.Basic</code></p>",
        "id": 525981397,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1750972294
    },
    {
        "content": "<p>It is using the instance for <code>E</code> (but why?)</p>",
        "id": 525981477,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1750972341
    },
    {
        "content": "<p>If you comment out the <code>AddCommGroup</code> and the <code>TopologicalSpace</code> instances, then the <code>Module</code> instance fails because it cannot synthesize <code>AddCommMonoid (my_copy E)</code>. But if you uncomment only the <code>TopologicalSpace</code> instance, then it works. Looking at the synthesized value, it seems to infer a <code>NormedAddCommGroup</code> structure on <code>my_copy E</code>, but it is not able to synthesize <code>NormedAddCommGroup E</code>.</p>",
        "id": 525984066,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1750973846
    },
    {
        "content": "<p>It's even more funny when synthetizing <code>Norm (my_copy E ‚ÜíL[ùïú] my_copy E)</code>, which also works. In the synthInstance trace, one sees that Lean fails to solve all the subgoals of <code>ContinuousLinearMap.hasOpNorm</code>, with only red crosses, but still it comes back with a green tick saying it has solved the problem!<br>\n<a href=\"/user_uploads/3121/PPaOzSWVYTKb8eHflxOZmW7j/crazyTrace.png\">crazyTrace.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/PPaOzSWVYTKb8eHflxOZmW7j/crazyTrace.png\" title=\"crazyTrace.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"832x355\" src=\"/user_uploads/thumbnail/3121/PPaOzSWVYTKb8eHflxOZmW7j/crazyTrace.png/840x560.webp\"></a></div>",
        "id": 526046039,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1751016739
    },
    {
        "content": "<p>It is probably caching a <code>NormedAddCommGroup</code> instance on <code>my_copy E</code> when it unifies some other non-normed instance using a projection and notices that it unfolds to <code>E</code>.</p>",
        "id": 526050191,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1751018352
    },
    {
        "content": "<p>We get a line </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">@</span><span class=\"n\">SeminormedAddCommGroup</span><span class=\"bp\">.</span><span class=\"n\">toAddCommGroup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">my_copy</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">‚úù¬π</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">my_copy</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>from </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\"> </span><span class=\"bp\">‚úÖÔ∏è</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"n\">ùïú</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">my_copy</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">=?=</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">4956</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"n\">SL</span><span class=\"o\">[</span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">4964</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">4957</span>\n</code></pre></div>\n<p>where <code>[inst‚úù¬π : SeminormedAddCommGroup E]</code> (changed slightly from example above)</p>",
        "id": 526056015,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1751020527
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">@</span><span class=\"n\">ContinuousLinearMap</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">Field</span><span class=\"bp\">.</span><span class=\"n\">toSemifield</span><span class=\"bp\">.</span><span class=\"n\">toDivisionSemiring</span><span class=\"bp\">.</span><span class=\"n\">toSemiring</span><span class=\"w\"> </span><span class=\"n\">Field</span><span class=\"bp\">.</span><span class=\"n\">toSemifield</span><span class=\"bp\">.</span><span class=\"n\">toDivisionSemiring</span><span class=\"bp\">.</span><span class=\"n\">toSemiring</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">RingHom</span><span class=\"bp\">.</span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">E</span>\n<span class=\"w\">  </span><span class=\"n\">PseudoMetricSpace</span><span class=\"bp\">.</span><span class=\"n\">toUniformSpace</span><span class=\"bp\">.</span><span class=\"n\">toTopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">‚úù¬π.</span><span class=\"n\">toAddCommMonoid</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">my_copy</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">PseudoMetricSpace</span><span class=\"bp\">.</span><span class=\"n\">toUniformSpace</span><span class=\"bp\">.</span><span class=\"n\">toTopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">‚úù¬π.</span><span class=\"n\">toAddCommMonoid</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">‚úù.</span><span class=\"n\">toModule</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">‚úù.</span><span class=\"n\">toModule</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_2</span>\n</code></pre></div>\n<p>is what applying <code>ContinuousLinearMap.hasOpNorm</code> says we have to unify with where we get a <code>PseudoMetricSpace (my_copy E)</code> from the projection from <code>SeminormedAddCommGroup E</code>.</p>",
        "id": 526057573,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1751021134
    },
    {
        "content": "<p>Thanks for investigating! Does this mean that unifying some projections is done at the wrong reducibility level?</p>",
        "id": 526069776,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1751025997
    },
    {
        "content": "<p>Certainly we end up in a unification problem at semi-reducible transparency. You can see this in the trace. I am not sure the exact entry point yet</p>",
        "id": 526070189,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1751026134
    },
    {
        "content": "<p>Note: if you make <code>my_copy</code> <code>irreducible</code> and unseal it in the instances we fail correctly</p>",
        "id": 526072292,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1751026867
    },
    {
        "content": "<p>Not an option in my use case, unfortunately.</p>",
        "id": 526072759,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1751027051
    },
    {
        "content": "<p>Reported at <a href=\"https://github.com/leanprover/lean4/pull/9077\">lean4#9077</a></p>",
        "id": 526268661,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1751202335
    },
    {
        "content": "<p>isn't this the reason we switched from defs to wrapper structures for <code>Opposite</code> and friends?</p>",
        "id": 526286585,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1751221795
    },
    {
        "content": "<p>I thought that it was because things randomly got unfolded due to incomplete API and/or accidental defeq abuse, not this: I've never seen anything like this before. It would probably be good to minimise :-/</p>",
        "id": 526287196,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1751222413
    },
    {
        "content": "<p>no I distinctly remember lean unfolding things more aggressively than it used to in defeq problems and instance search</p>",
        "id": 526288899,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1751224365
    },
    {
        "content": "<p>there were some cases that we just couldn't work around</p>",
        "id": 526288909,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1751224382
    },
    {
        "content": "<p>it wasn't about users unfolding and getting themselves confused, lean was doing it without us asking it to</p>",
        "id": 526288939,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1751224412
    },
    {
        "content": "<p>Lean's unification has the following feature: when unifying two applications of the same head constant (in this case <code>ContinuousLinearMap</code>), then in the (instance) implicit arguments it sets the reducibility to <code>default</code> (in this case in the argument of type <code>TopologicalSpace (my_copy E)</code>). It does this using the funtion <code>withInferTypeConfig</code>. Arguably, when checking the type of the assignment of an instance metavariable, the reducibility should be at most <code>instances</code>, and not <code>default</code>.</p>",
        "id": 526300747,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1751239129
    },
    {
        "content": "<p>Interesting (and surprising to me) comment of <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> on the issue:</p>\n<blockquote>\n<p>I believe this amounts to a misuse of <code>def</code> which is hard/unlikely to be addressed across the entire elaborator. Because of its context-dependent reducibility, the main difference of <code>def</code> to <code>abbrev</code> is performance-related, it should not be used to create semantically distinct types. Actually irreducible declarations like <code>structure</code> should be the preferred way for doing so.</p>\n</blockquote>\n<p>I read this as a \"won't fix\", if I understand correctly.</p>",
        "id": 529889141,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1753103848
    },
    {
        "content": "<p>So type synonyms literally don't work any more and this won't be fixed?</p>",
        "id": 529931341,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1753117668
    },
    {
        "content": "<p>Posted this also on GitHub, but I'm not sure where is the preferred place for conversation about it (since this is in the Mathlib4 stream, but the GitHub issue is on the Lean4 repo):</p>\n<p>Aside from the fact that this is ubiquitous throughout Mathlib, I really don't understand the idea that this is misuse of <code>def</code>. If it were the case that default transparency is the correct setting for instance synthesis, then it should <em>always</em> work. But, unsurprisingly, this doesn't:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">where</span>\n\n<span class=\"kd\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"n\">where</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">Unit'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Unit</span>\n\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"n\">Unit'</span><span class=\"w\"> </span><span class=\"c1\">-- fails</span>\n</code></pre></div>\n<p>That's because we have a different transparency setting for instance synthesis. As it currently stands, evidenced by this bug report, it's completely unpredictable whether unification will cause Lean to find an instance on a defeq type (not an <code>abbrev</code>) or not. That unpredictability seems like a problem to me.</p>\n<p>If this really is supposed to be a misuse of <code>def</code>, then it argues that we should <em>only</em> ever write <code>abbrev Œ± := Œ≤</code> or <code>irreducible_def Œ± := Œ≤</code> or <code>structure Œ± where toBeta : Œ≤</code>, and <em>never</em> <code>def Œ± := Œ≤</code>, when <code>Œ≤</code> is a type.</p>",
        "id": 530429584,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1753303317
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Bug.20in.20instance.20synthesis.3F/near/526300747\">said</a>:</p>\n<blockquote>\n<p>Lean's unification has the following feature: when unifying two applications of the same head constant (in this case <code>ContinuousLinearMap</code>), then in the (instance) implicit arguments it sets the reducibility to <code>default</code> (in this case in the argument of type <code>TopologicalSpace (my_copy E)</code>). It does this using the funtion <code>withInferTypeConfig</code>. Arguably, when checking the type of the assignment of an instance metavariable, the reducibility should be at most <code>instances</code>, and not <code>default</code>.</p>\n</blockquote>\n<p>Why is this? What happens if you change this? </p>\n<p>I confess to thinking of <code>def</code> as a mild semantic boundary.</p>",
        "id": 530430559,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1753303770
    },
    {
        "content": "<p>Even with the assumed status quo, I think  <code>def Œ± := Œ≤</code> trips up enough new users that it should come with a linter warning that you have to silence with <code>@[type_synonym]</code> or something.</p>",
        "id": 530430632,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1753303795
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306577\">Matthew Ballard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Bug.20in.20instance.20synthesis.3F/near/530430559\">said</a>:</p>\n<blockquote>\n<p>Why is this? What happens if you change this?</p>\n</blockquote>\n<p>I haven't tried it yet, but I would assume lots of things would fail if we were to change this. In particular, the change would be that when unifying in the <code>instances</code> transparency, and entering an instance implicit argument, we don't change the transparency level.</p>",
        "id": 530439169,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1753307360
    }
]