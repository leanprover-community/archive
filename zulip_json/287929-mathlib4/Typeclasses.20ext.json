[
    {
        "content": "<p>Currently <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Monoid.ext#doc\">docs#Monoid.ext</a> has this assumption:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">h_mul</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">letI</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">m₁</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">HMul</span><span class=\"bp\">.</span><span class=\"n\">hMul</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">letI</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">m₂</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">HMul</span><span class=\"bp\">.</span><span class=\"n\">hMul</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>It took me a while to realize that <code>letI</code> shifts respective instances to the top of the context, thereby determining which multiplication is referred by which <code>(HMul.hMul : M → M → M)</code> term.</p>\n<p>Note that with assumption</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">h_mul</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">letI</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">m₁</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">HMul</span><span class=\"bp\">.</span><span class=\"n\">hMul</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">HMul</span><span class=\"bp\">.</span><span class=\"n\">hMul</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>it would still work but with assumption</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">h_mul</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">HMul</span><span class=\"bp\">.</span><span class=\"n\">hMul</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">letI</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">m₂</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">HMul</span><span class=\"bp\">.</span><span class=\"n\">hMul</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>it wouldn't work.</p>\n<p>I find the behaviour quite cryptic. In contrast, assumption</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">h_mul</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m₁</span><span class=\"bp\">.</span><span class=\"n\">mul</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">m₂</span><span class=\"bp\">.</span><span class=\"n\">mul</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>would make it work as well and would be much clearer, but the resulting theorem would be less useful.</p>\n<p>Is there any better option how to implement these <code>ext</code> theorems for typeclasses?</p>",
        "id": 574363242,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1771354229
    },
    {
        "content": "<p>I was just thinking about that yesterday. In the topology part of the library, there's the notation <code>IsOpen[t]</code> which means to use the specific TopologicalSpace instance <code>t</code> to define the open set. (Unfortunately, it delaborates into just <code>IsOpen</code>, so this is \"invisible\" in the info view / loogle ... but alas.)</p>\n<p>I was wondering if it would be worth defining <code>*[m]</code> and <code>+[a]</code> notations to specify a particular <code>Add</code> or <code>Mul</code> instance. It would have to be a bit funnier though, because often you don't have an <code>HMul</code> or even a <code>Mul</code> instance, but rather a <code>Monoid</code> or <code>Ring</code> instance, and I would want to be able to do <code>[it : Ring R] .... ... : x *[it] y = 0</code>, where it's understood that <code>it</code> should be used to get the Mul instance.</p>",
        "id": 574364633,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1771354677
    }
]