[
    {
        "content": "<p>Currently mathlib has the definition <a href=\"https://github.com/leanprover-community/mathlib4/blob/926fb9ebeaeac0d42f11a6cd7f087b93a36a3a86/Mathlib/LinearAlgebra/SesquilinearForm.lean#L192\">LinearMap.IsSymm</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommSemiring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">→+*</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">→ₛₗ</span><span class=\"o\">[</span><span class=\"n\">I</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">}</span>\n\n<span class=\"sd\">/-- The proposition that a sesquilinear form is symmetric -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">IsSymm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">→ₛₗ</span><span class=\"o\">[</span><span class=\"n\">I</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>\n<p>It's not clear to me how to generalise this to sesquilinear maps in mathlib. In the spirit of the current definition, I have opened the PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/18406\">#18406</a> which uses:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"n\">M₁</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommSemiring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M₁</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">→+*</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">J</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">→+</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M₁</span><span class=\"w\"> </span><span class=\"bp\">→ₛₗ</span><span class=\"o\">[</span><span class=\"n\">I</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">M₁</span><span class=\"w\"> </span><span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">}</span>\n\n<span class=\"sd\">/-- The proposition that a sesquilinear form is conjugate symmetric -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">IsConjSymm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M₁</span><span class=\"w\"> </span><span class=\"bp\">→ₛₗ</span><span class=\"o\">[</span><span class=\"n\">I</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">M₁</span><span class=\"w\"> </span><span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">J</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">→+</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">J</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>\n<p>but this seems rather strange since it doesn't include the hypothesis:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">J</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">J</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>In particular, <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> <a href=\"https://github.com/leanprover-community/mathlib4/pull/18406#discussion_r1821662467\">says</a>:</p>\n<blockquote>\n<p>I worry this is more generality than we really care about, and maybe we just want to allow <code>I = J = star</code>. Rather than changing anything here, it's probably best to discuss on Zulip.</p>\n</blockquote>\n<p>An example of a conjugate symmetric (or Hermitian) sesquilinear map is the inner product on a Hilbert C*-module.</p>\n<p>Thanks,</p>\n<p>Christopher</p>",
        "id": 479597568,
        "sender_full_name": "Christopher Hoskin",
        "timestamp": 1730255875
    },
    {
        "content": "<p>Were there any further thoughts on this please? I'm bashing my head against not having a Map version of <a href=\"https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/LinearAlgebra/QuadraticForm/TensorProduct.lean#L120\">https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/LinearAlgebra/QuadraticForm/TensorProduct.lean#L120</a></p>",
        "id": 486766104,
        "sender_full_name": "Christopher Hoskin",
        "timestamp": 1733661051
    },
    {
        "content": "<p>I've been a little short of time recently; would you prefer I spend what I can find on this one or on the quadratic basis stuff first?</p>",
        "id": 486795243,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1733685095
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Linear.2EIsSymm.20for.20sesquilinear.20maps/near/486795243\">said</a>:</p>\n<blockquote>\n<p>I've been a little short of time recently; would you prefer I spend what I can find on this one or on the quadratic basis stuff first?</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> thanks - I appreciate doing this must be a huge time sink for you. My thinking on the quadratic basis stuff is still coming together, and may possibly end up depending on this. Also this is more widely applicable and perhaps also a simpler problem, so perhaps best to focus on this first?</p>",
        "id": 486795801,
        "sender_full_name": "Christopher Hoskin",
        "timestamp": 1733685595
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> , <span class=\"user-mention\" data-user-id=\"311453\">@Frédéric Dupuis</span> , and <span class=\"user-mention\" data-user-id=\"373192\">@Christopher Hoskin</span> (also <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> because you asked me to look at this; and <span class=\"user-mention\" data-user-id=\"130609\">@Antoine Chambert-Loir</span> because you developed the API for equivariant maps): I'm not super keen on either <a href=\"https://github.com/leanprover-community/mathlib4/pull/19809\">#19809</a> or <a href=\"https://github.com/leanprover-community/mathlib4/pull/18406\">#18406</a>. I don't like the former because it loses generality and requires us to add the <code>starRingOfComm</code> instance locally in many places. I don't like the latter because probably we only ever want <code>I = J</code> in practice. In fact, the stated use case is for <code>I = J = star</code> (which is why <a href=\"https://github.com/leanprover-community/mathlib4/pull/19809\">#19809</a> was proposed), and the only reason we can't do it with the existing set up is that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearMap#doc\">docs#LinearMap</a> requires a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RingHom#doc\">docs#RingHom</a>, but <code>star</code> only satisfies that in the commutative case.</p>\n<p>So, here's a question: Do we really need that for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearMap%3F#doc\">docs#LinearMap?</a> Can we get away with anything weaker? Does it cause performance issues?</p>",
        "id": 490346086,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1734830350
    },
    {
        "content": "<p>I think at the time I suggested we should take a raw function, because I didn't like declaring <code>starRingHom</code> the canonical spelling; but I think the compromise was to reconsider that later</p>",
        "id": 490347232,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1734831596
    },
    {
        "content": "<p>Arguably the <code>RingHom</code> restriction is still fine for the noncommutative case, because you can write:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">starLinearMap</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Semiring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">StarRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">→ₛₗ</span><span class=\"o\">[(</span><span class=\"n\">starRingEquiv</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">toRingHom</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">__</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">starAddEquiv</span>\n<span class=\"w\">  </span><span class=\"n\">map_smul'</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 490347444,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1734831819
    },
    {
        "content": "<p>(though generalizing this runs into issues with the definition of <code>StarModule</code> in the noncommutative case, which have threads elsewhere we should revive rather than repeating)</p>",
        "id": 490347497,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1734831854
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Linear.2EIsSymm.20for.20sesquilinear.20maps/near/490346086\">said</a>:</p>\n<blockquote>\n<p>In fact, the stated use case is for <code>I = J = star</code></p>\n</blockquote>\n<p>Sorry, bad example now I think about it a bit more.</p>\n<p>In fact what I was trying to achieve was to make a version of <code>QuadraticForm.associated_tmul</code> which works for quadratic maps (see the <a href=\"https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/LinearAlgebra/QuadraticForm/TensorProduct.lean#L107\">TODO</a>). In that case the range of the map may be in a different module to the ring and therefore <code>I</code> and <code>J</code> are not the same thing.</p>\n<p>Christopher</p>",
        "id": 490367101,
        "sender_full_name": "Christopher Hoskin",
        "timestamp": 1734852474
    },
    {
        "content": "<p>As a third suggestion, how about we leave <code>LinearMap.IsSymm</code> as it is (for now at least) and do something like <a href=\"https://github.com/leanprover-community/mathlib4/pull/20177\">#20177</a> instead?</p>",
        "id": 490375721,
        "sender_full_name": "Christopher Hoskin",
        "timestamp": 1734861353
    },
    {
        "content": "<p>Although this isn't a complete solution, as we also need <code>LinearMap.IsSymm.tmul</code> to work for maps, not just forms.</p>",
        "id": 490420835,
        "sender_full_name": "Christopher Hoskin",
        "timestamp": 1734903706
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"373192\">Christopher Hoskin</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Linear.2EIsSymm.20for.20sesquilinear.20maps/near/490420835\">said</a>:</p>\n<blockquote>\n<p>Although this isn't a complete solution, as we also need <code>LinearMap.IsSymm.tmul</code> to work for maps, not just forms</p>\n</blockquote>\n<p>I've now updated <a href=\"https://github.com/leanprover-community/mathlib4/pull/20177\">#20177</a> to establish <code>QuadraticMap.associated_tmul</code> and derive <code>QuadraticForm.associated_tmul</code> from it resolving the TODO. I'm not sure this approach is entirely satisfactory either <span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> .</p>",
        "id": 490650234,
        "sender_full_name": "Christopher Hoskin",
        "timestamp": 1735030604
    }
]