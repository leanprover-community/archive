[
    {
        "content": "<p>I want to define an idempotent semigroup and now see two options:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">IdemSemigroup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">Semigroup</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">IdempotentOp</span><span class=\"w\"> </span><span class=\"n\">toMul</span><span class=\"bp\">.</span><span class=\"n\">mul</span>\n</code></pre></div>\n<p>versus spelling it out</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">IdemSemigroup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">Semigroup</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">   </span><span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"n\">idempotent</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\">  </span><span class=\"bp\">\\</span><span class=\"k\">forall</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>\n<p>I noticed that for a commutative semigroup (or rather Magma) it was spelled out, but don't know which is generally preferable/better style?</p>",
        "id": 474275627,
        "sender_full_name": "Pieter Cuijpers",
        "timestamp": 1727870321
    },
    {
        "content": "<p>It's better spelled out because:</p>\n<ol>\n<li>It lets you name the field. In particular, if you wanted to eg reason about rings whose addition and multiplication are idempotent, then you couldn't do <code>extends Ring, Std.IdempotentOp (· * ·), Std.IdempotentOp (· + ·)</code> because that would result in a duplicated field name.</li>\n<li>It lets your users not worry about what <code>Std.IdempotentOp toMul.mul</code> means</li>\n</ol>",
        "id": 474276842,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1727870577
    },
    {
        "content": "<p><code>protected idempotent : Std.IdempotentOp (· * ·)</code> woula also be a possible compromise</p>",
        "id": 474278105,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727870789
    },
    {
        "content": "<p>But realistically you should just add <code>instance [IdemSemigroup G] : Std.IdempotentOp (· * ·)</code>, and everything else is probably user-hostile</p>",
        "id": 474278236,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727870814
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Two.20ways.20of.20defining.20an.20idempotent.20semigroup/near/474278236\">said</a>:</p>\n<blockquote>\n<p>But realistically you should just add <code>instance [IdemSemigroup G] : Std.IdempotentOp (· * ·)</code>, and everything else is probably user-hostile</p>\n</blockquote>\n<p>And is this also what is generally done in Mathlib? <br>\nI mean, as soon as you realize an operator <code>op</code> has a property, would you always instantiate it as a <code>Std.Property op</code> if available? I cannot find this for CommMagma for example, but maybe I'm not looking in the right place.</p>",
        "id": 474287544,
        "sender_full_name": "Pieter Cuijpers",
        "timestamp": 1727873434
    },
    {
        "content": "<p>We rarely use the <code>Std.Property</code> typeclasses in mathlib</p>",
        "id": 474287728,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1727873496
    },
    {
        "content": "<p>I think a PR to add such missing instances would be accepted though</p>",
        "id": 474292661,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727874379
    },
    {
        "content": "<p>But it would be for convenience with interacting with Lean core, not so much for the benefit of mathlib</p>",
        "id": 474292834,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727874402
    },
    {
        "content": "<p>I would think Std.Property definitions are there to standardize the kind of names we give to properties, and that consistently referring back to them would make searching / automating proofs easier ultimately. But perhaps that is not what happens in practice? How are these definitions used?</p>",
        "id": 474294182,
        "sender_full_name": "Pieter Cuijpers",
        "timestamp": 1727874703
    },
    {
        "content": "<p>The <code>Std</code> in their name doesn't mean \"standardize\" but refers to Std, the core Lean library</p>",
        "id": 474295065,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1727874955
    }
]