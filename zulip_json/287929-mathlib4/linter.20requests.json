[
    {
        "content": "<p>Perhaps a separate topic to record these is useful? </p>\n<p>I have one: a linter that warns you if you are building data using tactics.</p>",
        "id": 463994608,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1724232354
    },
    {
        "content": "<p>Oh, this could leverage a lot of the <code>have</code> vs <code>let</code> linter.</p>",
        "id": 464012131,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1724237200
    },
    {
        "content": "<p>Maybe this is not possible or already exists, but I would love to have a linter that checks for pointless parentheses (i.e. pairs of parentheses that can be deleted with no ill effect).</p>",
        "id": 464013619,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1724237685
    },
    {
        "content": "<p>Linters can do <em>a lot</em> of things and this is certainly in scope!</p>",
        "id": 464014235,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1724237838
    },
    {
        "content": "<p>There is a \"pedantic\" linter in the works that checks how closely your code matches the output of pretty-printing it.  I suspect that unnecessary parenthesie are there too, but there is a lot.  (<a href=\"https://github.com/leanprover-community/mathlib4/pull/15535\">#15535</a>)</p>",
        "id": 464014540,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1724237906
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/15941\">#15941</a> looks at some of its warnings on mathlib: help fixing these (if appropriate) or merging some of the fixes is welcome.</p>",
        "id": 464041616,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1724244066
    },
    {
        "content": "<p>Would it be possible to have a linter for putting hypotheses in <code>variable</code>? From what I understand doing so is not ideal</p>",
        "id": 464520104,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724379022
    },
    {
        "content": "<p>It would, but I have argued it <em>is</em> ideal in some situations</p>",
        "id": 464556708,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1724393714
    },
    {
        "content": "<p>Here's another idea: a linter for using <code>Type</code> instead of <code>Type*</code></p>",
        "id": 465427054,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724760500
    },
    {
        "content": "<p>One a linter when using <code>Type _</code> instead of <code>Type*</code>. (This was discussed before; in a calm moment, I'll edit in the link.)</p>",
        "id": 465458223,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1724766261
    },
    {
        "content": "<p>Just for completeness sake: \"a linter that flags unwanted unicode\".</p>\n<p>I have no idea how to implement it technically (been reading the metaprogramming book but not sure how to parse individual characters) and also there would need to be some discussion about what \"unwanted\" should be. (My suggestion would be \"everything that's not on a whitelist, which can grow over time\").</p>\n<p>Previously discussed <a href=\"#narrow/stream/287929-mathlib4/topic/Whitelist.20for.20Unicode.3F/near/448721083\">here</a></p>",
        "id": 465582179,
        "sender_full_name": "Adomas Baliuka",
        "timestamp": 1724798925
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"638715\">Adomas Baliuka</span> <a href=\"#narrow/stream/287929-mathlib4/topic/linter.20requests/near/465582179\">said</a>:</p>\n<blockquote>\n<p>Just for completeness sake: \"a linter that flags unwanted unicode\".</p>\n<p>I have no idea how to implement it technically (been reading the metaprogramming book but not sure how to parse individual characters) and also there would need to be some discussion about what \"unwanted\" should be. (My suggestion would be \"everything that's not on a whitelist, which can grow over time\").</p>\n<p>Previously discussed <a href=\"#narrow/stream/287929-mathlib4/topic/Whitelist.20for.20Unicode.3F/near/448721083\">here</a></p>\n</blockquote>\n<p>In terms of infrastructure, you could certainly piggy-back on the text-based linters in <code>Mathlib.Tactic.Linter.TextBased</code> (or try to use a syntax linter... but that might be harder/you may have to distinguish more cases). The former are text-based, so have no understanding of Lean syntax (in particular, the linter would also complain about using unicode symbols in comments etc., which might actually be fine).</p>\n<p>Or is your question more about the \"splitting the string into unicode codepoints\"?</p>",
        "id": 465689967,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1724834709
    },
    {
        "content": "<p>(Though, searching for \"is this a substring\" <em>hopefully</em> would side-step this question.)</p>",
        "id": 465690244,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1724834762
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 465720683,
        "sender_full_name": "Adomas Baliuka",
        "timestamp": 1724840116
    },
    {
        "content": "<p>Looks like a reasonable start. Perhaps the following is obvious to you (in that case, please proceed), otherwise:</p>\n<ul>\n<li>you need to define a <code>newUnicode</code> variant of the styleError</li>\n<li>you should add your linter to <code>allLinters</code></li>\n<li>Right now, your check is not quite what we want, as it would also complain about the letter <code>a</code>, the number <code>0</code> or some common symbols. But the idea works.</li>\n</ul>",
        "id": 465721513,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1724840315
    },
    {
        "content": "<p>(Edit: I see you deleted your post now. It contained a start towards linting against the above.)</p>",
        "id": 465721579,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1724840333
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"634338\">@Michael Rothgang</span> Thanks! I deleted because I didn't want to hijack this thread and, as you said, had to do some more modifications that cannot be usefully shortened into what could be posted here. I think I will just make a PR and see what happens.</p>",
        "id": 465722254,
        "sender_full_name": "Adomas Baliuka",
        "timestamp": 1724840477
    },
    {
        "content": "<p>How about: linter for theorem and instance names that are too long!</p>",
        "id": 467072145,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725322933
    },
    {
        "content": "<p>We've got a bunch of bad autogenerated instance names like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=NumberField.instIsLocalizedModuleIntNonZeroDivisorsSubtypeMemSubmoduleRingOfIntegersCoeToSubmoduleValFractionalIdealRestrictScalarsSubtype#doc\">docs#NumberField.instIsLocalizedModuleIntNonZeroDivisorsSubtypeMemSubmoduleRingOfIntegersCoeToSubmoduleValFractionalIdealRestrictScalarsSubtype</a>, which are so long you can't even call them explicitly without triggering the long line linter</p>",
        "id": 467072378,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725323053
    },
    {
        "content": "<p>And they clutter search results on the docs</p>",
        "id": 467072422,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725323087
    },
    {
        "content": "<p>Violeta, you have no idea what instance names we had when you were away <span aria-label=\"face with hand over mouth\" class=\"emoji emoji-1f92d\" role=\"img\" title=\"face with hand over mouth\">:face_with_hand_over_mouth:</span></p>",
        "id": 467128376,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1725343728
    },
    {
        "content": "<p>I still come across the old instance names while searching for lemmas on <a href=\"http://moogle.ai\">moogle.ai</a>, some of those can fill my whole screen!</p>",
        "id": 467129607,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1725344002
    },
    {
        "content": "<p>Would collapsing subsequent calls of <code>subst</code> be a good linter? (Are there any linters that look at adjacent tactic calls at all, like collapsing <code>rw/rwa ...</code> and <code>assertion</code> to <code>rwa</code>?)</p>",
        "id": 497344961,
        "sender_full_name": "Tristan Figueroa-Reid",
        "timestamp": 1738566289
    },
    {
        "content": "<p>A brief check suggests that there are about 15 files containing consecutive <code>subst</code>s.</p>",
        "id": 497380927,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1738576094
    },
    {
        "content": "<p>In terms of actual implementation of the linter, I do not think that there are already linters that check consecutive tactics \"syntactically\".  There are some linters that track metavariables, looking for two tactics modifying a given goal in sequence (possibly with some different intervening tactics in-between).  If you decide to do the metavariable-tracking, then the linter will be quite a bit more involved.</p>",
        "id": 497380961,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1738576101
    },
    {
        "content": "<p>Here are a couple of examples of some straightforward and not-so-straightforward lints:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hb</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">ha</span>\n<span class=\"w\">  </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">hb</span>\n<span class=\"w\">  </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">hc</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hb</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">hb</span>\n<span class=\"w\">  </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">hc</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hb</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">ha</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">id</span>\n<span class=\"w\">  </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">hb</span><span class=\"w\"> </span><span class=\"n\">hc</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hb</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">ha</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">right</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">trivial</span>\n<span class=\"w\">  </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">hb</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 497381009,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1738576112
    },
    {
        "content": "<p>Some of the <code>subst</code>s above are \"syntactically\" consecutive, others are \"semantically\" consecutive.</p>",
        "id": 497381048,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1738576118
    },
    {
        "content": "<p>There are some ongoing discussions about general linter performances, but the idea of collapsing consecutive <code>subst</code>s seems reasonable.  Still, unless this is intended mostly as a learning exercise, try to gather some support, since every new linter means adding more potential warnings and there is a fine balance between being useful and being annoying!</p>",
        "id": 497381073,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1738576123
    },
    {
        "content": "<p>There are a few linters that maybe should not be running constantly, but rather every once in a while in an automated process and I think that this linter would be one of them: it is rare to have consecutive <code>subst</code>s, so having the linter constantly running may be a little wasteful, but it is also good to clean up code, even if \"after the fact\".</p>",
        "id": 497381095,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1738576127
    },
    {
        "content": "<p>This kind of periodic clean up is not automated, but I have been thinking about it for some time and would like to see it implemented.</p>",
        "id": 497381102,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1738576128
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"767695\">Tristan Figueroa-Reid</span> <a href=\"#narrow/channel/287929-mathlib4/topic/linter.20requests/near/497344961\">said</a>:</p>\n<blockquote>\n<p>Would collapsing subsequent calls of <code>subst</code> be a good linter? (Are there any linters that look at adjacent tactic calls at all, like collapsing <code>rw/rwa ...</code> and <code>assertion</code> to <code>rwa</code>?)</p>\n</blockquote>\n<p>I have added this to the <a href=\"https://github.com/leanprover-community/mathlib4/issues/7217\">wishlist</a>, along with some of the earlier suggestions <span class=\"user-mention\" data-user-id=\"459227\">@Violeta Hernández</span> and <span class=\"user-mention\" data-user-id=\"306577\">@Matthew Ballard</span>  made, hope that's all right.</p>",
        "id": 497502127,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1738606117
    },
    {
        "content": "<p>My wish for today: write a \"low-level performance optimisation tactic linter\", which tries to replace one tactic with a \"faster\" one if that is possible. Let's use the replacement \"continuity -&gt; fun_prop\" as an example. This cannot always be done, but if it can, fun_prop is usually faster (sometimes by a lot). This linter would tell you \"this continuity call can be replaced by fun_prop\" could be useful.</p>\n<p>More specifically, I'm thinking of a syntax linter which does the following, for every pair <code>(slower_tactic, faster_tactic)</code>.</p>\n<ul>\n<li>look for occurrences of the <code>slower_tactic</code> tactic<ul>\n<li>careful: do ignore default parameters</li>\n<li>occurrences inside proofs (of theorems, instances or definitions) should be fine</li>\n</ul>\n</li>\n<li>try to replace this by the <code>faster_tactic</code> tactic</li>\n<li>elaborate the result: if there are no errors, print a message about the replacement. Otherwise, do nothing.</li>\n</ul>\n<p>As a start, the pair <code>(continuity, fun_prop)</code> and <code>(measurability, fun_prop)</code> could be a start.</p>",
        "id": 504596190,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1741616288
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> In case you're bored and want to write a performance-enhancing linter instead :-)</p>",
        "id": 504596273,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1741616306
    },
    {
        "content": "<p>My experience with figuring out what is faster using linters is that it is hard to avoid \"caching\": linters will usually re-elaborate some syntax that has already been elaborated and, in the process, will have access to cached computations.  This makes speed tests performed by linters somewhat unreliable.</p>",
        "id": 504602297,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1741617486
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"634338\">Michael Rothgang</span> <a href=\"#narrow/channel/287929-mathlib4/topic/linter.20requests/near/504596190\">said</a>:</p>\n<blockquote>\n<p>As a start, the pair <code>(continuity, fun_prop)</code> and <code>(measurability, fun_prop)</code> could be a start.</p>\n</blockquote>\n<p>Seems like something <a href=\"https://github.com/dwrensha/tryAtEachStep\">tryAtEachStep</a> could be helpful with.</p>",
        "id": 504619860,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1741620997
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/channel/287929-mathlib4/topic/linter.20requests/near/504602297\">said</a>:</p>\n<blockquote>\n<p>My experience with figuring out what is faster using linters is that it is hard to avoid \"caching\": linters will usually re-elaborate some syntax that has already been elaborated and, in the process, will have access to cached computations.  This makes speed tests performed by linters somewhat unreliable.</p>\n</blockquote>\n<p>Good point! In the case of fun_prop and continuity, in my experience the former is ~always a lot faster, so I don't need any speed comparisons. Telling me which ones can be replaced should suffice. :-)</p>",
        "id": 504646949,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1741627425
    },
    {
        "content": "<p>A pair I've encountered a few times is <code>(aesop, simp_all)</code>.</p>",
        "id": 506689727,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1742380408
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"634338\">Michael Rothgang</span> <a href=\"#narrow/channel/287929-mathlib4/topic/linter.20requests/near/504596190\">said</a>:</p>\n<blockquote>\n<p>More specifically, I'm thinking of a syntax linter which does the following, for every pair <code>(slower_tactic, faster_tactic)</code>.</p>\n<ul>\n<li>look for occurrences of the <code>slower_tactic</code> tactic<ul>\n<li>careful: do ignore default parameters</li>\n<li>occurrences inside proofs (of theorems, instances or definitions) should be fine</li>\n</ul>\n</li>\n<li>try to replace this by the <code>faster_tactic</code> tactic</li>\n<li>elaborate the result: if there are no errors, print a message about the replacement. Otherwise, do nothing.</li>\n</ul>\n</blockquote>\n<p>Since I imagine that this would be very slow like <code>tryAtEachStep</code>, it might be a good idea to categorize these slow linters in such a way that one could manually run them for a specific file/theorem: one could use this to golf-lint only files changed in a PR, for example. (This could also contain linters regarding simp - for example, permuting <code>simp only</code> calls with multiple theorems to see if there exists a potential call to <code>simp_rw</code>)</p>\n<p>(note: <a href=\"#narrow/channel/287929-mathlib4/topic/linter.20requests/near/497381095\">I just noticed that this was mentioned about 10 messages ago</a> - since this is being brought up more often, though, it might be a good time to consider implementing such a system.)</p>",
        "id": 506887053,
        "sender_full_name": "Tristan Figueroa-Reid",
        "timestamp": 1742451227
    },
    {
        "content": "<p>Also (taking advantage of the slowness of this linter) it would be nice if that tactic was transitive - e.g. cases when <code>simp_all</code> can just be <code>simp</code>.</p>",
        "id": 507098415,
        "sender_full_name": "Tristan Figueroa-Reid",
        "timestamp": 1742516394
    },
    {
        "content": "<p>The file <a href=\"https://tqft.net/mathlib4files/CategoryTheory/Bicategory/Functor/Lax\">file#CategoryTheory/Bicategory/Functor/Lax</a> has this in its first few non-docstring lines</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">Bicategory</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Bicategory</span>\n</code></pre></div>\n<p>Of course, removing the second <code>open</code> does not impact the file.</p>\n<p>Can we lint against reopening an already-open namespace?</p>",
        "id": 520273644,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1748162070
    },
    {
        "content": "<p>Perhaps one used to be <code>open_locale</code></p>",
        "id": 520274910,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1748163295
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"286014\">Robin Carlier</span> <a href=\"#narrow/channel/287929-mathlib4/topic/linter.20requests/near/520273644\">said</a>:</p>\n<blockquote>\n<p>Can we lint against reopening an already-open namespace?</p>\n</blockquote>\n<p>This is probably incredibly difficult since eg <code>open Foo Bar Foo</code> means</p>\n<ol>\n<li>\"Open <code>Foo</code>\"</li>\n<li>\"Open <code>Bar</code> and <code>Foo.Bar</code>\"</li>\n<li>\"Open <code>Foo</code>, <code>Bar.Foo</code> and <code>Foo.Bar.Foo</code>\"</li>\n</ol>",
        "id": 520275025,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1748163417
    },
    {
        "content": "<p>True - but there is a different, more pragmatic way: lint in \"superfluous opens\". Whenever an <code>open</code> statement can be removed and the file still compiles, emit a warning that the open statement is superfluous.</p>",
        "id": 520314368,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1748197473
    },
    {
        "content": "<p>There is an \"unused variable\" linter by Damiano Testa (which should be very similar in terms of implementation), so you can probably copy a lot from there.</p>",
        "id": 520314403,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1748197515
    },
    {
        "content": "<p>The hardest part might be fixing all violations in mathlib :-)</p>",
        "id": 520314414,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1748197527
    },
    {
        "content": "<p>Speaking of, <span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span>, did you ever finish that work?</p>",
        "id": 520314673,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1748197713
    },
    {
        "content": "<p>No, I got tired of the mindless PRs after many iterations!  I can try to pick it up again, but it was not especially fun!  <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 520316759,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1748199400
    },
    {
        "content": "<p>In terms of the \"duplicated <code>open</code>\" linter, there are exceedingly few declarations that have a repeated namespace, almost all in core with repeated <code>Lean</code>.  I'll try to give an exhaustive list later, when I'm back at a computer.  I have not investigated how many namespaces appear in different orders throughout mathlib, but I suspect that most repeated <code>open</code>s could be removed.</p>",
        "id": 520316909,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1748199541
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span>  DO you mind if I merge master into <a href=\"https://github.com/leanprover-community/mathlib4/pull/17715\">#17715</a>?</p>",
        "id": 520323263,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1748204968
    },
    {
        "content": "<p>Of course not: feel free to do that and remove some unused variables!</p>",
        "id": 520323464,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1748205119
    },
    {
        "content": "<p>There are some incorrect answers that I already know, but almost all warning should be correct.</p>",
        "id": 520323560,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1748205171
    },
    {
        "content": "<p>You have to wait until the end of the file has been parsed before you get any warning though.</p>",
        "id": 520323603,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1748205208
    },
    {
        "content": "<p>(I don't remember how Elab.async affected the linter, though.)</p>",
        "id": 520323630,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1748205227
    },
    {
        "content": "<p>Done, will see what comes out</p>",
        "id": 520324750,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1748206188
    },
    {
        "content": "<p>Not much -</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">argument</span>\n<span class=\"w\">  </span><span class=\"n\">es</span><span class=\"bp\">.</span><span class=\"n\">getElems</span>\n<span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"n\">TSyntaxArray</span><span class=\"w\"> </span><span class=\"ss\">`Lean.Parser.Command.structParent</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"n\">but</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">expected</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">TSyntax</span><span class=\"w\"> </span><span class=\"ss\">`term</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n</code></pre></div>\n<p>That's not gonna be for me today</p>",
        "id": 520324968,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1748206388
    },
    {
        "content": "<p>When I'm back at a computer, I'll try to fix it and will report here!</p>",
        "id": 520333082,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1748213953
    },
    {
        "content": "<p>I have not forgotten about this, I tried fixing the linter, but there are some deeper changes that have affected the linter: I need to think about how to make it work again!</p>",
        "id": 520746050,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1748374033
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/287929-mathlib4/topic/linter.20requests/near/520275025\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"286014\">Robin Carlier</span> <a href=\"#narrow/channel/287929-mathlib4/topic/linter.20requests/near/520273644\">said</a>:</p>\n<blockquote>\n<p>Can we lint against reopening an already-open namespace?</p>\n</blockquote>\n<p>This is probably incredibly difficult since eg <code>open Foo Bar Foo</code> means</p>\n<ol>\n<li>\"Open <code>Foo</code>\"</li>\n<li>\"Open <code>Bar</code> and <code>Foo.Bar</code>\"</li>\n<li>\"Open <code>Foo</code>, <code>Bar.Foo</code> and <code>Foo.Bar.Foo</code>\"</li>\n</ol>\n</blockquote>\n<p>It turns out that Lean already stores all the various open namespaces conveniently, so the linter does not have a lot of extra work to do.</p>",
        "id": 521726997,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1748865864
    },
    {
        "content": "<p>In  <a href=\"https://github.com/leanprover-community/mathlib4/pull/25362\">#25362</a> there is a draft linter, which still needs work, but I will not have time to think about it.</p>",
        "id": 521727011,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1748865868
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/25361\">#25361</a> contains the first few exceptions that the linter flagged.</p>",
        "id": 521727014,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1748865869
    },
    {
        "content": "<p>Now that the linter ran on all of mathlib, it reports that there are approx 500 files with a duplicated <code>open</code>.</p>",
        "id": 521744985,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1748870310
    },
    {
        "content": "<p>(Does this also handle the case \"open Foo\" cannot be removed, but replaced by \"open scoped Foo\"?)</p>",
        "id": 521745631,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1748870510
    },
    {
        "content": "<p>No, this is simply checking whether the new <code>open</code> namespace creates a duplicated open namespace.</p>",
        "id": 521745783,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1748870553
    },
    {
        "content": "<p>Checking whether <code>open scoped</code> would be enough is harder, since I am not sure that there is any record in the environment of which declarations used <code>open</code>/<code>open scoped</code>, other than that they have been added to the environment.</p>",
        "id": 521747058,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1748870891
    },
    {
        "content": "<p>By the way, the linter does not detect whether an <code>open</code> is <em>unused</em>, it merely detects if it is superfluous, since the namespace is already open.</p>",
        "id": 521747402,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1748870986
    },
    {
        "content": "<p>And even the \"superfluous\" part may have false positives, due to potential intricacies in how namespaces can look like.  In the files that I looked at, there were no false positives, but sometimes it was not entirely straightforward to figure out which <code>open</code>s to remove/reorder.</p>",
        "id": 521747782,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1748871087
    },
    {
        "content": "<p>Since this came up, the linter does not prevent opening a namespace <em>and not using it</em>.  It simply prevents that an already open namespace is opened again.  So, <code>open X X</code> is not allowed, but <code>section open X end</code> is allowed.</p>",
        "id": 521756408,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1748873241
    },
    {
        "content": "<p>This was discussed in <a class=\"stream-topic\" data-stream-id=\"217875\" href=\"/#narrow/channel/217875-Is-there-code-for-X.3F/topic/weaker.20wlog/with/524085785\">#Is there code for X? &gt; weaker wlog</a>, but we should have a linter for uses of <code>wlog</code> without <code>this</code> to recommend some equivalent, more descriptive tactic. It is still up in the air what to recommend (<code>by_cases</code> with a negated statement seems to be the most used equivalent form from the conclusion of that conversation).</p>",
        "id": 524145865,
        "sender_full_name": "Tristan Figueroa-Reid",
        "timestamp": 1750008999
    },
    {
        "content": "<p>Can we lint against universes mvars? See <a href=\"#narrow/channel/287929-mathlib4/topic/.60grind.20ext.60.20and.20universe-level.20metavariable\">#mathlib4 &gt; &#96;grind ext&#96; and universe-level metavariable</a> </p>\n<p>I think the issue described in this thread shows that these are actually tech debt (they are breaking future automation, and slow things down), and I believe we’re quite in debt in Mathlib.</p>",
        "id": 529785040,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1753083833
    },
    {
        "content": "<p>So, an 80% solution would be to lint on <code>Category </code> that is not <code>Category.{v} </code>, right?</p>",
        "id": 529807995,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1753087645
    },
    {
        "content": "<p>Yes, that would be good already!</p>",
        "id": 529813337,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1753088508
    },
    {
        "content": "<p>Can there be a linter that discourages <code>=&gt;</code> in favour of <code>\\mapsto</code> (or the other way)?</p>",
        "id": 533491862,
        "sender_full_name": "David Ang",
        "timestamp": 1754669764
    },
    {
        "content": "<p>That linter is easy to write. The hard part is forming consensus on it. If you do the latter, I'm happy to do the former.</p>",
        "id": 533494296,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1754670831
    },
    {
        "content": "<p>(And we just need a volunteer to fix the several thousand such occurrences in mathlib. :-))</p>",
        "id": 533494360,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1754670860
    },
    {
        "content": "<p>can't we just be inconsistent</p>",
        "id": 533494409,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754670883
    },
    {
        "content": "<p>Or can we lint in the other direction? <span aria-label=\"innocent\" class=\"emoji emoji-1f607\" role=\"img\" title=\"innocent\">:innocent:</span></p>",
        "id": 533521733,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1754684503
    },
    {
        "content": "<p>I don't know whether it is technically possible, but I hope for a linter to detect instance diamonds in variables.</p>",
        "id": 533522797,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1754685089
    },
    {
        "content": "<p>What about a linter for universe-polymorphic types which have been initialized at universe 0?</p>",
        "id": 533555235,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754716741
    },
    {
        "content": "<p>This can of course be intentional, so you should be able to disable the linter, but it can also lead to some really annoying to debug problems.</p>",
        "id": 533555261,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754716775
    },
    {
        "content": "<p>(I'm thinking things like <code>Ordinal.{0}</code>, <code>Cardinal.{0}</code>, etc.)</p>",
        "id": 533555270,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754716789
    },
    {
        "content": "<p>Can we lint against the use of <code>↑</code> in places where it expands to a no-op?</p>",
        "id": 537676871,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1756993630
    },
    {
        "content": "<p>We have a linter that detects <em>absence</em> of a focussing dot when there are multiple goals. Can we have the converse, i.e. a linter that detects <em>presence</em> of unnecessary focussing dots when there is only a single goal anyway? I've often seen this in PR reviews.</p>",
        "id": 538208195,
        "sender_full_name": "David Loeffler",
        "timestamp": 1757333529
    },
    {
        "content": "<p>How would you differentiate the last dot in a set from a dot all on its own?</p>",
        "id": 538208488,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1757333609
    },
    {
        "content": "<p>That linter exists in a PR (I can dig up the PR later) --- the question was how to phase in that linter, as there are a many (if I remember correctly, in the order of 2000 violations). Writing an auto-fixer for this would be nice, and is perhaps not too difficult --- there was recent discussion in this direction.</p>",
        "id": 538213254,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1757334879
    },
    {
        "content": "<p>These PRs are <a href=\"https://github.com/leanprover-community/mathlib4/pull/12411\">#12411</a> and <a href=\"https://github.com/leanprover-community/mathlib4/pull/12416\">#12416</a> --- which contains both the linter implementation as well as a number of mathlib adaptations (which are by now thoroughly outdated).</p>",
        "id": 538214212,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1757335112
    },
    {
        "content": "<p>The last dot in a set already gets special treatment, in that it is allowed, but not required.</p>",
        "id": 538234196,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1757339961
    },
    {
        "content": "<p>I forget the details, but I think that this was still the case for the stricter multiGoal linter: it requires cdots in the right places, but the last one is optional.</p>",
        "id": 538234393,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1757340010
    },
    {
        "content": "<p>If I remember correctly, the way in which it worked is as follows.  Assuming that indentation is correct, which the current linter almost guarantees, you can then deduce syntactically where a proof ends and then work your way backwards to where it should have started.</p>",
        "id": 538234773,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1757340098
    },
    {
        "content": "<p>I think there is an issue in that whether or not to put the last dot is sometimes a matter of taste and perhaps <em>should</em> be up to the contributor. For example, if there is a <code>by_cases</code>,  you may or may not want that the second case has a focusing dot depending on whether or not the first case is considered a trivial side case.</p>",
        "id": 538283636,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1757353263
    },
    {
        "content": "<p>Should the dot be forbidden in:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">close_the_main_goal_with_some_hyp</span><span class=\"o\">]</span>\n<span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">close_the_side_goal</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 538285827,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1757354127
    },
    {
        "content": "<p>The dot here acts as a partial indication that this can't be combined into a single <code>rw</code></p>",
        "id": 538285866,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1757354144
    },
    {
        "content": "<p>I don't have a strong opinion for what the linter <em>should</em> do with the non-mergeable <code>rw</code>.  What it very likely <em>does</em> is to flag that cdot as redundant.  Tracking metavariables  across tactic calls is usually straightforward, but can be arbitrarily complicated, and the linter defers almost all of its logic to simply counting how many goals are present.  So, one goal means \"same\" goal, even if it really should be a side goal.</p>",
        "id": 538295797,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1757357852
    },
    {
        "content": "<p>The flexible linter has a somewhat more refined view on metavariable tracking, but the multiGoal mostly (maybe only) tracks number of available goals before and after the tactic calls.</p>",
        "id": 538296028,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1757357943
    },
    {
        "content": "<p>Hello, I'd like to suggest a linter for unnecessary usage of <code>|&gt;</code> and <code>&lt;|</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">fib</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">Injective</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">fib</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"mi\">5</span>\n</code></pre></div>\n<p>I like using these but sometimes after a refactor they become unnecessary, and I don't always notice. Thoughts?</p>",
        "id": 541869919,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1759043093
    },
    {
        "content": "<p>Also in a similar vein, a linter that forces using <code>&lt;|</code> or <code>|&gt;</code> or dot notation where possible. e.g.</p>\n<ul>\n<li><code>Polynomial.degree X</code> =&gt; <code>X.degree</code></li>\n<li><code>Nat.fib (2 * 3)</code> =&gt; <code>Nat.fib &lt;| 2 * 3</code></li>\n<li><code>(2 * X).degree</code> =&gt; <code>2 * X |&gt;.degree</code></li>\n</ul>\n<p>These are style choices so I'm not talking about enabling them in mathlib, but rather letting users choose to enable them on their local VSCode</p>",
        "id": 541870267,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1759043436
    },
    {
        "content": "<p>Personally, I find that</p>\n<ul>\n<li><code>Nat.fib (2 * 3)</code> =&gt; <code>Nat.fib &lt;| 2 * 3</code></li>\n<li><code>(2 * X).degree</code> =&gt; <code>2 * X |&gt;.degree</code></li>\n</ul>\n<p>is opposite to my preference.</p>",
        "id": 541881164,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1759054860
    },
    {
        "content": "<p>We could have a linter that suggests to change <code>replace h</code> into <code>have h</code> if there was no variable <code>h</code> before.</p>",
        "id": 554519471,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1762645385
    },
    {
        "content": "<p>And perhaps for <code>obtain</code> when there's no pattern, just an identifier</p>",
        "id": 554541228,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1762672042
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/blob/302e37129c5daf7153b1a259be84e862de08147d/Mathlib/FieldTheory/Minpoly/IsIntegrallyClosed.lean#L97-L98\">This simp_rw</a> can be replaced with either <code>simp</code> or <code>rw</code> (with the same list of lemmas), and if it's replaced with <code>simp</code> we can remove the first 3 lemmas (though the unused simp linter doesn't flag them all).<br>\nMaybe a linter that suggests such replacements is good? Though <code>simp_rw</code> might have benefits I'm not aware of, maybe it's faster</p>",
        "id": 554662124,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1762769666
    },
    {
        "content": "<p>There is a benefit of <code>simp_rw</code> over <code>simp</code> that you can see all of the rewrites happen in the infoview as you move your cursor through the list of arguments. This is the same as in <code>rw</code>.</p>",
        "id": 554664413,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1762770479
    },
    {
        "content": "<p>Additionally, if your <code>simp_rw</code> call breaks, you'll typically know exactly at which point things start to go wrong. And sometimes <code>simp [...]</code> can be sensitive to the order that it applies the lemma - for example if you have a lemma that simplifies <code>f x = y</code> but you also added <code>eq_comm</code> which should only apply <em>after</em> the first lemma</p>",
        "id": 554693050,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1762779194
    },
    {
        "content": "<p>So replacing <code>simp_rw</code> -&gt; <code>rw</code> (when possible) is always non-worse (same or better), right?</p>",
        "id": 554804518,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1762814152
    },
    {
        "content": "<p>Unless it has weird performance impact, or it implies splitting a single <code>simp_rw</code> into alternating <code>rw</code>/<code>simp_rw</code>, I think I'd agree with that</p>",
        "id": 554805038,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1762814425
    },
    {
        "content": "<p>In the draft pull request <a href=\"https://github.com/leanprover-community/mathlib4/pull/31386\">#31386</a> i have a couple of python scripts that I've used to detect and fix files that had more than one H1 header in docstrings. After processing the results, I found that there were almost no false positives among the &gt;100 files flagged.</p>\n<p>This makes me wonder whether the detection script could be transformed into a useful linter. Not sure whether this is something I want to invest effort in yet, but I thought I should air the possibility in order to get a sense of how valuable community members would perceive this to be.</p>",
        "id": 556672637,
        "sender_full_name": "Harald Husum",
        "timestamp": 1763286279
    },
    {
        "content": "<p>The current python linters that are present in mathlib are mostly considered technical debt, waiting to be replaced by Lean scripts.</p>\n<p>So, I would prefer if this were Lean-based, rather than python-based.</p>",
        "id": 556679152,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1763292370
    },
    {
        "content": "<p>At some point we'll be switching to using <a href=\"https://github.com/leanprover/verso\">Verso</a> in our docstrings, so if we want to lint docstrings, it might be worth looking into whether we should build something using that. (FWIW it looks like the markup for headers is the same as in markdown)</p>",
        "id": 556681696,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1763295327
    },
    {
        "content": "<p>I agree that it is best to wait for Verso docstrings for this kind of linter, because it seems much more reliable once there is a robust markdown-like parser that can be used to identify headers.</p>",
        "id": 556682372,
        "sender_full_name": "Chris Henson",
        "timestamp": 1763296192
    },
    {
        "content": "<p>Thanks for the feedback, guys. FWIW, I took it for granted that it would have to be ported to Lean. But waiting for Verso seems like a good idea.</p>\n<p>The last PR with fixes of these issues was merged today, so hopefully there won't be too many files to deal with when the time comes to make a linter out of this.</p>",
        "id": 556909113,
        "sender_full_name": "Harald Husum",
        "timestamp": 1763406039
    },
    {
        "content": "<p>A potential linter could be one checking for \"bad\" uses of constructors (ones which abuse def-eq). By this I mean that certain types come with a preferred constructor that is not the standard one, e.g. in category theory we have the constructor <code>Prod.mkHom</code> that avoids def-eq abuse:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- Construct a morphism in a product category by giving its constituent components.</span>\n<span class=\"sd\">This constructor should be preferred over `Prod.mk`, because lean infers better the</span>\n<span class=\"sd\">source and target of the resulting morphism. -/</span>\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">mkHom</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X₁</span><span class=\"w\"> </span><span class=\"n\">X₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Y₁</span><span class=\"w\"> </span><span class=\"n\">Y₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X₁</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">X₂</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Y₁</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">Y₂</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X₁</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Y₁</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X₂</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Y₂</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"bp\">⟩</span>\n</code></pre></div>\n<p>The linter could work by having a list of \"preferred constructors\", so in this case whenever a morphism of type <code>(X₁, Y₁) ⟶ (X₂, Y₂)</code> is constructed using the standard constructor, the linter would flag this, and ask the user to either disable the linter if the reason is good, or use <code>mkHom</code>(which also comes with notation). The reason I ask is that the file that defines <code>Prod.mkHom</code> itself is riddled with uses of the old constructor as well!</p>\n<p>I couldn't find if this had been suggested before.</p>",
        "id": 558814435,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1763817388
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"132603\">Calle Sönne</span> <a href=\"#narrow/channel/287929-mathlib4/topic/linter.20requests/near/558814435\">said</a>:</p>\n<blockquote>\n<p>in category theory we have the constructor <code>Prod.mkHom</code> that avoids def-eq abuse</p>\n</blockquote>\n<p>It is certainly not meant to avoid defeq abuse. It's instead meant to help unification out</p>",
        "id": 558815736,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1763818755
    },
    {
        "content": "<p>I am more and more leaning towards the stance that anything counting as defeq abuse should be completely disallowed by setting the transparency or visibility appropriately. Eg if a constructor is truly meant not to be used, then it should be <code>private</code>.</p>",
        "id": 558815868,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1763818880
    },
    {
        "content": "<p>There's a master student at my uni playing around with detecting defeq abuse, and it's been a nightmare explaining him the rules <span aria-label=\"half frown\" class=\"emoji emoji-1f615\" role=\"img\" title=\"half frown\">:half_frown:</span></p>",
        "id": 558815925,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1763818932
    },
    {
        "content": "<p>Is there documentation that spells out these defeq abuse rules?</p>",
        "id": 558816073,
        "sender_full_name": "Chris Henson",
        "timestamp": 1763819119
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/287929-mathlib4/topic/linter.20requests/near/558815736\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"132603\">Calle Sönne</span> <a href=\"#narrow/channel/287929-mathlib4/topic/linter.20requests/near/558814435\">said</a>:</p>\n<blockquote>\n<p>in category theory we have the constructor <code>Prod.mkHom</code> that avoids def-eq abuse</p>\n</blockquote>\n<p>It is certainly not meant to avoid defeq abuse. It's instead meant to help unification out</p>\n</blockquote>\n<p>Okay I don't actually know what \"defeq abuse\" means exactly, but have I understood correctly that its there to help out simp?</p>",
        "id": 558816172,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1763819241
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/287929-mathlib4/topic/linter.20requests/near/558815868\">said</a>:</p>\n<blockquote>\n<p>I am more and more leaning towards the stance that anything counting as defeq abuse should be completely disallowed by setting the transparency or visibility appropriately. Eg if a constructor is truly meant not to be used, then it should be <code>private</code>.</p>\n</blockquote>\n<p>Well in this case this would mean making <code>Prod.mk</code> private which I don't think is a good idea.</p>",
        "id": 558816224,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1763819296
    },
    {
        "content": "<p>Defeq abuse happens when we set our declarations to the secret \"human-irreducible\" transparency that Lean doesn't know about</p>",
        "id": 558816475,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1763819573
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"132603\">Calle Sönne</span> <a href=\"#narrow/channel/287929-mathlib4/topic/linter.20requests/near/558816224\">said</a>:</p>\n<blockquote>\n<p>in this case this would mean making <code>Prod.mk</code> private which I don't think is a good idea.</p>\n</blockquote>\n<p>No, that's not really what it means. It instead means that <code>(X₁, Y₁) ⟶ (X₂, Y₂)</code> should be defined as a custom one-field structure whose constructor should be made private.</p>",
        "id": 558816604,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1763819684
    },
    {
        "content": "<p>I still don't get it. If I have a definition and I have a bunch of places I'm using it how do I tell if it's defeq abuse?</p>",
        "id": 558816620,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763819702
    },
    {
        "content": "<p>You can't. That's my point</p>",
        "id": 558816632,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1763819717
    },
    {
        "content": "<p>That's why we should be more diligent making things private/irreducible so that the only available spelling of an operation is the preferred one</p>",
        "id": 558816680,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1763819765
    },
    {
        "content": "<p>Okay I agree with this :)</p>",
        "id": 558818100,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1763821127
    },
    {
        "content": "<p>PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/32587\">#32587</a> fixes some trivial documentation mis-formatting which is caused by the presence of \"non-breaking space\" Unicode characters (which look identical to usual spaces but aren't read as such by the docs compiler).  <span class=\"user-mention\" data-user-id=\"459227\">@Violeta Hernández</span> and I both agree it would be nice to have a linter against this – I'm not sure there's any good reason for a non-breaking space ever to appear in a Lean code file.</p>",
        "id": 562609304,
        "sender_full_name": "David Loeffler",
        "timestamp": 1765262853
    },
    {
        "content": "<p>This would be an easy text-based linter - happy to review a PR!</p>",
        "id": 562619853,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1765267984
    },
    {
        "content": "<p>Non-breaking space linter PR up at <a href=\"https://github.com/leanprover-community/mathlib4/pull/32646\">#32646</a>.</p>",
        "id": 562672353,
        "sender_full_name": "David Loeffler",
        "timestamp": 1765283664
    },
    {
        "content": "<p>Can we have a linter for using the <code>if</code> tactic inside proofs? <code>by_cases</code> is usually much more readable.</p>",
        "id": 569202525,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1768986885
    },
    {
        "content": "<p>A few tactic analysis linters what would be great to have: look for pairs of tactics that can be combined.</p>\n<ul>\n<li>by_cases followed by push_neg in the second branch (-&gt; <code>by_cases!</code>); similarly for <code>by_contra</code> and <code>wlog</code></li>\n<li><code>rw</code> followed by <code>assumption</code> (-&gt; <code>rwa</code>)</li>\n<li><del>can we also look for <code>rw</code> followed by an <code>exact</code> which could be an assumption?</del> edit: this might not be a good idea though, see below</li>\n<li><code>filter_upwards</code> followed by <code>intro</code></li>\n</ul>",
        "id": 569202869,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1768986984
    },
    {
        "content": "<p>You can also combine two consecutive <code>intro</code>/<code>intros</code>/<code>refine</code>/<code>apply</code>/<code>exact</code>/<code>exacts</code>/<code>use</code>/<code>exists</code>s if line length permits (usually, though I once encountered a case where combining breaks things)</p>",
        "id": 569239922,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1768997853
    },
    {
        "content": "<p>I sometimes dislike <code>rwa</code> when reading proofs, because it doesn't tell me which assumption was used. Why is <code>rwa</code> even a thing in the first place?</p>",
        "id": 569245385,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1768999645
    },
    {
        "content": "<p>Okay, but then would you also remove (or frown upon) <code>assumption</code>?</p>",
        "id": 569246725,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1769000080
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"933054\">Snir Broshi</span> <a href=\"#narrow/channel/287929-mathlib4/topic/linter.20requests/near/569239922\">said</a>:</p>\n<blockquote>\n<p>You can also combine two consecutive <code>intro</code>/<code>intros</code>/<code>refine</code>/<code>apply</code>/<code>exact</code>/<code>exacts</code>/<code>use</code>/<code>exists</code>s if line length permits (usually, though I once encountered a case where combining breaks things)</p>\n</blockquote>\n<p>Subsequent <code>intro</code>s are already linted (by default). <code>use</code> or <code>exists</code> are a good idea, agreed.</p>",
        "id": 569248492,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1769000601
    },
    {
        "content": "<p>With <code>refine</code>/<code>apply</code>/<code>exact</code>/<code>exacts</code>, I'm not convinced by a general rule: combining these is not always a good idea, on my opinion.</p>",
        "id": 569248588,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1769000633
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/channel/287929-mathlib4/topic/linter.20requests/near/569245385\">said</a>:</p>\n<blockquote>\n<p>I sometimes dislike <code>rwa</code> when reading proofs, because it doesn't tell me which assumption was used. Why is <code>rwa</code> even a thing in the first place?</p>\n</blockquote>\n<p><code>rwa</code> has a number of surprises: <code>rwa at h</code> does not mean <code>h</code> is used to close the goal, if <code>rw</code> closes the original goal but leaves a side condition then <code>rwa</code> tries to use <code>assumption</code> instead on that side condition, ...</p>",
        "id": 569249249,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1769000801
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/channel/287929-mathlib4/topic/linter.20requests/near/569246725\">said</a>:</p>\n<blockquote>\n<p>Okay, but then would you also remove (or frown upon) <code>assumption</code>?</p>\n</blockquote>\n<p>I'm not saying we should ban <code>assumption</code> (for example <code>all_goals assumption</code> is a nice thing), but I think replacing <code>exact h</code> with <code>assumption</code> is not a good golf. And I don't think people would replace <code>exact h</code> with <code>assumption</code> very often, but the very fact that <code>rwa</code> exists is an incentive to replace <code>exact h</code> with <code>assumption</code> in the form of <code>rwa</code>.</p>",
        "id": 569251039,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1769001259
    },
    {
        "content": "<p>I'm not a big fan of <code>rwa</code> either: there are situations where it is acceptable, but should not be used extensively, in my opinion.</p>",
        "id": 569251945,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1769001493
    },
    {
        "content": "<p>Two more ideas:</p>\n<ul>\n<li><code>have := something</code> followed by <code>positivity</code> should be written <code>positivity [something]</code></li>\n<li><code>have := something</code> followed by <code>finiteness</code> should be written <code>finiteness [something]</code><br>\nBoth cases only apply to reasonably short proof terms; I think \"does the have use <code>:=</code>, no <code>by</code> and no <code>name</code>\" should be a decent heuristic. I'm not sure if the tactic analysis framework has easy access to this information, though.</li>\n</ul>",
        "id": 569252883,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1769001760
    },
    {
        "content": "<p>This applies to <code>grind</code> as well, and I think you could also check if the <code>have</code> can be eliminated entirely.</p>",
        "id": 569253277,
        "sender_full_name": "Chris Henson",
        "timestamp": 1769001863
    },
    {
        "content": "<p>Does <code>grind</code> have an unused argument linter yet? Or should we make one by simply trying to remove arguments one by one?</p>",
        "id": 569253540,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1769001941
    },
    {
        "content": "<p>I know there are places with unused args that I found while making the latest weekly linting PR, so I don't think so. Maybe this is not straightforward, because <code>grind?</code> doesn't suggest a minimal set either. When doing it by hand, I remove one by one.</p>",
        "id": 569254308,
        "sender_full_name": "Chris Henson",
        "timestamp": 1769002163
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"238446\">Anne Baanen</span> <a href=\"#narrow/channel/287929-mathlib4/topic/linter.20requests/near/569249249\">said</a>:</p>\n<blockquote>\n<p>if <code>rw</code> closes the original goal but leaves a side condition then <code>rwa</code> tries to use <code>assumption</code> instead on that side condition, ...</p>\n</blockquote>\n<p>Didn't that get fixed?</p>",
        "id": 569257211,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1769002967
    },
    {
        "content": "<p>Apparently not</p>",
        "id": 569257656,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1769003100
    },
    {
        "content": "<p>Recording some linter ideas from <a class=\"message-link\" href=\"/#narrow/channel/287929-mathlib4/topic/Possible.20PR.3A.20Poisson.20integral.20and.20Herglotz.20representation/near/569703507\">#mathlib4 &gt; Possible PR: Poisson integral and Herglotz representation @ 💬</a>:</p>\n<ul>\n<li>ensure people write π, not Real.pi</li>\n<li>ensure neighbourhoods notation is used</li>\n</ul>",
        "id": 570438742,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1769554810
    },
    {
        "content": "<p>(<span class=\"user-mention\" data-user-id=\"412682\">@Moritz Doll</span> then replied saying he might be interested in writing a \"properly use notation\" linter.)</p>",
        "id": 570438791,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1769554836
    },
    {
        "content": "<p>There is a deprecatedSyntax linter that can probably be used for this.</p>",
        "id": 570464457,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1769572807
    },
    {
        "content": "<p>I'll be happy to review a PR adding such a check!</p>",
        "id": 570511639,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1769593810
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/channel/287929-mathlib4/topic/linter.20requests/near/570464457\">said</a>:</p>\n<blockquote>\n<p>There is a deprecatedSyntax linter that can probably be used for this.</p>\n</blockquote>\n<p>Thanks that is a good reference, I found the <code>cdotLinter</code>, which is already pretty close. I want write a version where you can tag a notation, so that it automatically gets added to a list which the linter checks, so it is slightly more complicated</p>",
        "id": 570513794,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1769594436
    },
    {
        "content": "<p>Making this genuinely user extensible seems a little tricky to \"get right\": the new command should have a place for the old syntax, one for the new syntax and one for the error message.  Also, right now, these checks can be activated or deactivated individually.  If you want to preserve that functionality, there should also be a mechanism that would create the various options.</p>",
        "id": 570515420,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1769594889
    },
    {
        "content": "<p>One way to get started would be to move part of the logic to an environment extension, storing <code>(deprecated syntax, preferred syntax, warning message)</code>.</p>",
        "id": 570515424,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1769594891
    },
    {
        "content": "<p>Further linter requests:</p>\n<ol>\n<li>Detect use of <code>@</code> notation in term mode that isn't actually necessary.</li>\n<li>Detect syntactically identical tactic branches e.g. <code>X; \\. Y; \\. Y</code> and suggest <code>X &lt;;&gt; Y</code> instead.</li>\n<li>Detect when a tactic block generates a term that pretty prints with length &lt; \\epsilon * (length of tactic block), but doesn't need to \"name lemmas\" particularly more.</li>\n</ol>",
        "id": 571506383,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1770059356
    },
    {
        "content": "<p>I think there should be a linter that checks whether definitions marked as <code>meta</code> are actually used for meta purposes. This would mean that it is either used in another <code>meta</code> definition, or that it is used to implement a tactic/attribute/command/elaborator/delaborator/app_unexpander/initialize etc.</p>\n<p>And for files that are <code>meta import</code>ed, there should be at least one definition in there that wasn't already marked <code>meta</code>, and satisfies the above criterion.</p>",
        "id": 572666735,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1770601292
    },
    {
        "content": "<p>Could we have a linter for</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"bp\">...</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>but where substituting the <code>exact</code> into the refine results in a typechecking error?</p>",
        "id": 572903100,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1770677396
    },
    {
        "content": "<p>The general pattern of <code>refine</code> followed by <code>exact</code> is okay for pedagogical purposes (\"here is the structure of the term I need, but there are some tedious proofs I will defer until later\" --- although even then refactoring to a <code>have</code> followed by an <code>exact</code> seems much clearer as long as the type annotation on the <code>have</code> is not insane), but I would really like to avoid using <code>refine</code> then <code>exact</code> to achieve some more complicated elaboration guidance that is not explained in the source.</p>",
        "id": 572903113,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1770677401
    },
    {
        "content": "<p>Perhaps, before having such a linter, reviewers could simply watch out for this antipattern and flag it.</p>",
        "id": 572903121,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1770677404
    },
    {
        "content": "<p>I would like to point out some <a href=\"https://github.com/leanprover-community/mathlib4/pull/20041/changes#diff-c6b46002c08f8c26d5c700de95584cef6c08445b15cf30d5422a28ef175dd7c0R348-R349\">examples</a> of this antipattern, introduced in <a href=\"https://github.com/leanprover-community/mathlib4/pull/20041\">#20041</a>, which today wasted my time diagnosing when their elaboration changed slightly, and I was dumped into a type-checking problem without enough context. I've PR'd a change to these proofs in <a href=\"https://github.com/leanprover-community/mathlib4/pull/35059\">#35059</a>; I'm not claiming that the replacement proofs are particularly better except that they work on both <code>master</code> and <code>nightly-testing</code>. If someone would like to replace them again in a follow-up PR that would be great.</p>",
        "id": 572903127,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1770677405
    },
    {
        "content": "<p>Linking to <a class=\"message-link\" href=\"/#narrow/channel/287929-mathlib4/topic/Type.20typo/near/572874336\">#mathlib4 &gt; Type typo @ 💬</a>, containing a discussion about a linter for <code>Type</code> in arguments of declarations (it's fine in return types). Someone would need to survey the existing exceptions.</p>",
        "id": 572919471,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1770685609
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/channel/287929-mathlib4/topic/linter.20requests/near/572903121\">said</a>:</p>\n<blockquote>\n<p>Perhaps, before having such a linter, reviewers could simply watch out for this antipattern and flag it.</p>\n</blockquote>\n<p>It is somewhat hard to spot this, right? Because half of the time, it might pass as \"pedagogical purposes\" if you don't inspect very carefully.</p>",
        "id": 572957159,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1770706445
    },
    {
        "content": "<p>Would you like to help with writing a linter? A linter is even better than relying on manual review :-)</p>",
        "id": 572973357,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1770712239
    },
    {
        "content": "<p>Not sure if you are asking me or Kim. But I currently don't have the skills to write that linter, and don't have the time to learn those skills <span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span></p>",
        "id": 572976545,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1770713195
    },
    {
        "content": "<p>I think that the tactic framework that Anne developed should make that fairly accessible, but I am not currently able to volunteer for this task!</p>",
        "id": 572976696,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1770713246
    },
    {
        "content": "<p>The tactic analysis framework part seems straightforward, but what would be the best way to identify which <code>?_</code> corresponds to the term from <code>exact</code>?</p>",
        "id": 573039933,
        "sender_full_name": "Chris Henson",
        "timestamp": 1770730205
    },
    {
        "content": "<p>Would linting for <code>refine</code> followed by <code>exact</code> (and the goal is closed then) --- but where the equivalent <code>exact</code> call fails, do the trick? It would catch some of the errors above, at least.</p>",
        "id": 573040498,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1770730331
    },
    {
        "content": "<p>Yes, detecting <code>refine</code> followed by <code>exact</code> seems most straightforward and limits you to roughly this. My question was about how to distinguish between the holes that are solved by unification versus where we want to replace with the term from <code>exact</code>.</p>",
        "id": 573042530,
        "sender_full_name": "Chris Henson",
        "timestamp": 1770730838
    },
    {
        "content": "<p>When using <code>refine</code>, the holes solved by unification are written as <code>_</code>, and the holes that leave a new goal are written as <code>?_</code>. So you should be able to tell this purely from the syntax.</p>",
        "id": 573047163,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1770731930
    },
    {
        "content": "<p>They <em>should</em> be written this way, but nothing is stopping you from writing <code>?_</code> where <code>_</code> should be used, right? Otherwise, I agree.</p>",
        "id": 573047892,
        "sender_full_name": "Chris Henson",
        "timestamp": 1770732106
    },
    {
        "content": "<p>I agree with what Jovan said.  There are some rare cases where this may not apply, but you may uncover situations were you <em>can</em> replace <code>?_</code> by <code>_</code> and maybe you <em>should</em>!</p>",
        "id": 573048021,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1770732136
    },
    {
        "content": "<p><code>refine</code> should mostly fail, if you tell it to not unify stuff that it could.</p>",
        "id": 573048128,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1770732160
    },
    {
        "content": "<p>If you just look for <code>refine</code> followed by <code>exact</code> there will be a lot of cases where this was a decision due to line length or proof readability, so checking the failure of the replacement will really be essential, I think.</p>",
        "id": 573048529,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1770732264
    },
    {
        "content": "<p>If okay for the linter to also identify these replacements of <code>?_</code> for <code>_</code>, then then it seems fine to replace the first <code>?_</code> syntactically and rerun the tactic, as the tactic analysis framework allows. This seems to make most sense as an addition to the weekly linting set.</p>",
        "id": 573049373,
        "sender_full_name": "Chris Henson",
        "timestamp": 1770732484
    },
    {
        "content": "<p>(And as you say, just report a warning on failure because most times it will still succeed.)</p>",
        "id": 573050419,
        "sender_full_name": "Chris Henson",
        "timestamp": 1770732732
    },
    {
        "content": "<p>If a <code>refine</code> creates one goal, and the number of <code>?_</code> is not one, then something fishy is going on and so I'd say it's worth having a linter warning for this too.</p>",
        "id": 573052278,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1770733191
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/channel/287929-mathlib4/topic/linter.20requests/near/572903100\">said</a>:</p>\n<blockquote>\n<p>Could we have a linter for</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"bp\">...</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>but where substituting the <code>exact</code> into the refine results in a typechecking error?</p>\n</blockquote>\n<p>I'm not sure that this is a antipattern in general. <br>\nIf the elaborator needs help, this pattern is an easy way to tell it \"elaborate this argument last\".<br>\nWhat is the proposed fix if this linter fires? Give more implicit arguments explicitly? </p>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LibraryNote.comp_of_eq_lemmas#doc\">docs#LibraryNote.comp_of_eq_lemmas</a> contains a concrete example: suppose we want to prove the following in term mode without using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ContinuousAt.comp_of_eq#doc\">docs#ContinuousAt.comp_of_eq</a>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x₀</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ContinuousAt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">uncurry</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x₀</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x₀</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">ContinuousAt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">x₀</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Now the following isn't pretty, but how would you like it to be formatted instead? (The linter should probably give such instructions):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x₀</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ContinuousAt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">uncurry</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x₀</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x₀</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">ContinuousAt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">x₀</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">ContinuousAt</span><span class=\"bp\">.</span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">uncurry</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">continuousAt_id</span><span class=\"bp\">.</span><span class=\"n\">prodMk</span><span class=\"w\"> </span><span class=\"n\">continuousAt_id</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hf</span>\n</code></pre></div>",
        "id": 573074626,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1770737631
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"687698\">Chris Henson</span> <a href=\"#narrow/channel/287929-mathlib4/topic/linter.20requests/near/573047892\">said</a>:</p>\n<blockquote>\n<p>They <em>should</em> be written this way, but nothing is stopping you from writing <code>?_</code> where <code>_</code> should be used, right? Otherwise, I agree.</p>\n</blockquote>\n<p>Can you give an example where you can use both <code>?_</code> and <code>_</code> in a <code>refine</code>, and Lean doesn't give an error in either case? I think that Lean (mostly) checks that you're using the correct one.</p>",
        "id": 573075043,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1770737712
    },
    {
        "content": "<p>Maybe this is too minimized, but I had in mind examples like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AddCommMagma</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">add_comm</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">add_comm</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span>\n</code></pre></div>\n<p>where you could easily write either for an instance parameter while typing quickly.</p>",
        "id": 573081281,
        "sender_full_name": "Chris Henson",
        "timestamp": 1770739108
    },
    {
        "content": "<p>Ah I see! Indeed I think having a linter warning for this would be nice.</p>",
        "id": 573081934,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1770739237
    },
    {
        "content": "<p>Maybe this should be a separate linter? Based on the original discussion I have written an initial version of a linter using the tactic analysis framework. It's not more than a dozen lines when limited to finishing <code>exact</code>/<code>refine</code>, so I think the more important piece is Floris's questions about if this is really an antipattern and what the suggested alternative is.</p>",
        "id": 573087276,
        "sender_full_name": "Chris Henson",
        "timestamp": 1770740451
    },
    {
        "content": "<p>I think what is causing the problem in the original example that <span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> encountered is that there was a <code>▸</code> rewrite happening inside the <code>refine</code>, making the proof much more brittle.</p>",
        "id": 573089482,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1770740979
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 573093066,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1770741771
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"286014\">@Robin Carlier</span> <a href=\"https://github.com/leanprover-community/mathlib4/pull/34387#issuecomment-3896592621\">said on github</a>:</p>\n<blockquote>\n<p>Perhaps we could even consider linting against exposed <code>Classical.choose _</code>, forcing APIs to provide both the definition and a characterizing property?</p>\n</blockquote>",
        "id": 573719096,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1770981551
    },
    {
        "content": "<p>I was considering whether we could write a linter about rfl theorems of the form theorem foo : f args = value := rfl which were not labelled as @[simp]. Probably this should be restricted to cases where f is defined the in same file as foo.<br>\nThere would be some false positives, surely, so some extra noise to turn these off. But this seems to be a quite common reviewer suggestion that turns up in PRs, so is high value from the point of view of automating review work.<br>\nRecent examples: <a href=\"https://github.com/leanprover-community/mathlib4/pull/35432\">#35432</a> (<span class=\"user-mention\" data-user-id=\"240862\">@Oliver Nash</span>)</p>",
        "id": 575129111,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1771727046
    },
    {
        "content": "<p>Another one we could do is have a (user extensible via registration) list of types, e.g. Equiv, Iso, Functor, LinearMap, ... where it is a linter warning if you fail to write @[simps] or have at least some simp lemmas for projections?<br>\nAgain, this comes up regularly in manual reviews. This might be a bit harder to specify well, however, and it may only work as an environment linter, because it has to wait to see if simp lemmas are written manually after the definition.<br>\nRecent examples: <a href=\"https://github.com/leanprover-community/mathlib4/pull/35452\">#35452</a> (<span class=\"user-mention\" data-user-id=\"286014\">@Robin Carlier</span> / <span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span>)</p>",
        "id": 575129257,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1771727169
    },
    {
        "content": "<p>Another one is arguments duplicated with section variables. Maybe the test is just \"can any argument which has identical type to something in the current section variables (are those even available to a linter?) be omitted without changing the elaboration of the theorem?\"<br>\nRecent examples: <a href=\"https://github.com/leanprover-community/mathlib4/pull/35479\">#35479</a></p>",
        "id": 575129531,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1771727464
    },
    {
        "content": "<p>And then we could lint (only as an environment linter), for named instances where the name is never used in Mathlib.<br>\nRecent example: <a href=\"https://github.com/leanprover-community/mathlib4/pull/35488\">#35488</a></p>",
        "id": 575129592,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1771727527
    },
    {
        "content": "<p>A thing to keep in mind about linting against named instances is that when the instance carries data and has a <code>@[simps]</code> tag, naming it is a way to somehow control the name of the resulting lemmas even if the instance name is not explicitly mentioned in Mathlib.</p>",
        "id": 575165301,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1771769841
    },
    {
        "content": "<p>What about a linter for public declarations containing the word <code>aux</code>? There seem to be <a href=\"https://leanprover-community.github.io/mathlib4_docs/search.html?q=_aux\">hundreds of these</a>. And surely we'd prefer for these to have better names, or be private altogether.</p>",
        "id": 575874643,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1772054966
    }
]