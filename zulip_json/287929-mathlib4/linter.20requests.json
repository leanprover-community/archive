[
    {
        "content": "<p>Perhaps a separate topic to record these is useful? </p>\n<p>I have one: a linter that warns you if you are building data using tactics.</p>",
        "id": 463994608,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1724232354
    },
    {
        "content": "<p>Oh, this could leverage a lot of the <code>have</code> vs <code>let</code> linter.</p>",
        "id": 464012131,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1724237200
    },
    {
        "content": "<p>Maybe this is not possible or already exists, but I would love to have a linter that checks for pointless parentheses (i.e. pairs of parentheses that can be deleted with no ill effect).</p>",
        "id": 464013619,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1724237685
    },
    {
        "content": "<p>Linters can do <em>a lot</em> of things and this is certainly in scope!</p>",
        "id": 464014235,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1724237838
    },
    {
        "content": "<p>There is a \"pedantic\" linter in the works that checks how closely your code matches the output of pretty-printing it.  I suspect that unnecessary parenthesie are there too, but there is a lot.  (<a href=\"https://github.com/leanprover-community/mathlib4/pull/15535\">#15535</a>)</p>",
        "id": 464014540,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1724237906
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/15941\">#15941</a> looks at some of its warnings on mathlib: help fixing these (if appropriate) or merging some of the fixes is welcome.</p>",
        "id": 464041616,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1724244066
    },
    {
        "content": "<p>Would it be possible to have a linter for putting hypotheses in <code>variable</code>? From what I understand doing so is not ideal</p>",
        "id": 464520104,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724379022
    },
    {
        "content": "<p>It would, but I have argued it <em>is</em> ideal in some situations</p>",
        "id": 464556708,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1724393714
    },
    {
        "content": "<p>Here's another idea: a linter for using <code>Type</code> instead of <code>Type*</code></p>",
        "id": 465427054,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724760500
    },
    {
        "content": "<p>One a linter when using <code>Type _</code> instead of <code>Type*</code>. (This was discussed before; in a calm moment, I'll edit in the link.)</p>",
        "id": 465458223,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1724766261
    },
    {
        "content": "<p>Just for completeness sake: \"a linter that flags unwanted unicode\".</p>\n<p>I have no idea how to implement it technically (been reading the metaprogramming book but not sure how to parse individual characters) and also there would need to be some discussion about what \"unwanted\" should be. (My suggestion would be \"everything that's not on a whitelist, which can grow over time\").</p>\n<p>Previously discussed <a href=\"#narrow/stream/287929-mathlib4/topic/Whitelist.20for.20Unicode.3F/near/448721083\">here</a></p>",
        "id": 465582179,
        "sender_full_name": "Adomas Baliuka",
        "timestamp": 1724798925
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"638715\">Adomas Baliuka</span> <a href=\"#narrow/stream/287929-mathlib4/topic/linter.20requests/near/465582179\">said</a>:</p>\n<blockquote>\n<p>Just for completeness sake: \"a linter that flags unwanted unicode\".</p>\n<p>I have no idea how to implement it technically (been reading the metaprogramming book but not sure how to parse individual characters) and also there would need to be some discussion about what \"unwanted\" should be. (My suggestion would be \"everything that's not on a whitelist, which can grow over time\").</p>\n<p>Previously discussed <a href=\"#narrow/stream/287929-mathlib4/topic/Whitelist.20for.20Unicode.3F/near/448721083\">here</a></p>\n</blockquote>\n<p>In terms of infrastructure, you could certainly piggy-back on the text-based linters in <code>Mathlib.Tactic.Linter.TextBased</code> (or try to use a syntax linter... but that might be harder/you may have to distinguish more cases). The former are text-based, so have no understanding of Lean syntax (in particular, the linter would also complain about using unicode symbols in comments etc., which might actually be fine).</p>\n<p>Or is your question more about the \"splitting the string into unicode codepoints\"?</p>",
        "id": 465689967,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1724834709
    },
    {
        "content": "<p>(Though, searching for \"is this a substring\" <em>hopefully</em> would side-step this question.)</p>",
        "id": 465690244,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1724834762
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 465720683,
        "sender_full_name": "Adomas Baliuka",
        "timestamp": 1724840116
    },
    {
        "content": "<p>Looks like a reasonable start. Perhaps the following is obvious to you (in that case, please proceed), otherwise:</p>\n<ul>\n<li>you need to define a <code>newUnicode</code> variant of the styleError</li>\n<li>you should add your linter to <code>allLinters</code></li>\n<li>Right now, your check is not quite what we want, as it would also complain about the letter <code>a</code>, the number <code>0</code> or some common symbols. But the idea works.</li>\n</ul>",
        "id": 465721513,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1724840315
    },
    {
        "content": "<p>(Edit: I see you deleted your post now. It contained a start towards linting against the above.)</p>",
        "id": 465721579,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1724840333
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"634338\">@Michael Rothgang</span> Thanks! I deleted because I didn't want to hijack this thread and, as you said, had to do some more modifications that cannot be usefully shortened into what could be posted here. I think I will just make a PR and see what happens.</p>",
        "id": 465722254,
        "sender_full_name": "Adomas Baliuka",
        "timestamp": 1724840477
    },
    {
        "content": "<p>How about: linter for theorem and instance names that are too long!</p>",
        "id": 467072145,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725322933
    },
    {
        "content": "<p>We've got a bunch of bad autogenerated instance names like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=NumberField.instIsLocalizedModuleIntNonZeroDivisorsSubtypeMemSubmoduleRingOfIntegersCoeToSubmoduleValFractionalIdealRestrictScalarsSubtype#doc\">docs#NumberField.instIsLocalizedModuleIntNonZeroDivisorsSubtypeMemSubmoduleRingOfIntegersCoeToSubmoduleValFractionalIdealRestrictScalarsSubtype</a>, which are so long you can't even call them explicitly without triggering the long line linter</p>",
        "id": 467072378,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725323053
    },
    {
        "content": "<p>And they clutter search results on the docs</p>",
        "id": 467072422,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725323087
    },
    {
        "content": "<p>Violeta, you have no idea what instance names we had when you were away <span aria-label=\"face with hand over mouth\" class=\"emoji emoji-1f92d\" role=\"img\" title=\"face with hand over mouth\">:face_with_hand_over_mouth:</span></p>",
        "id": 467128376,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1725343728
    },
    {
        "content": "<p>I still come across the old instance names while searching for lemmas on <a href=\"http://moogle.ai\">moogle.ai</a>, some of those can fill my whole screen!</p>",
        "id": 467129607,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1725344002
    },
    {
        "content": "<p>Would collapsing subsequent calls of <code>subst</code> be a good linter? (Are there any linters that look at adjacent tactic calls at all, like collapsing <code>rw/rwa ...</code> and <code>assertion</code> to <code>rwa</code>?)</p>",
        "id": 497344961,
        "sender_full_name": "Tristan Figueroa-Reid",
        "timestamp": 1738566289
    },
    {
        "content": "<p>A brief check suggests that there are about 15 files containing consecutive <code>subst</code>s.</p>",
        "id": 497380927,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1738576094
    },
    {
        "content": "<p>In terms of actual implementation of the linter, I do not think that there are already linters that check consecutive tactics \"syntactically\".  There are some linters that track metavariables, looking for two tactics modifying a given goal in sequence (possibly with some different intervening tactics in-between).  If you decide to do the metavariable-tracking, then the linter will be quite a bit more involved.</p>",
        "id": 497380961,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1738576101
    },
    {
        "content": "<p>Here are a couple of examples of some straightforward and not-so-straightforward lints:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hb</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">ha</span>\n<span class=\"w\">  </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">hb</span>\n<span class=\"w\">  </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">hc</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hb</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">hb</span>\n<span class=\"w\">  </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">hc</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hb</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">ha</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">id</span>\n<span class=\"w\">  </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">hb</span><span class=\"w\"> </span><span class=\"n\">hc</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hb</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">ha</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">right</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">trivial</span>\n<span class=\"w\">  </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">hb</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 497381009,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1738576112
    },
    {
        "content": "<p>Some of the <code>subst</code>s above are \"syntactically\" consecutive, others are \"semantically\" consecutive.</p>",
        "id": 497381048,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1738576118
    },
    {
        "content": "<p>There are some ongoing discussions about general linter performances, but the idea of collapsing consecutive <code>subst</code>s seems reasonable.  Still, unless this is intended mostly as a learning exercise, try to gather some support, since every new linter means adding more potential warnings and there is a fine balance between being useful and being annoying!</p>",
        "id": 497381073,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1738576123
    },
    {
        "content": "<p>There are a few linters that maybe should not be running constantly, but rather every once in a while in an automated process and I think that this linter would be one of them: it is rare to have consecutive <code>subst</code>s, so having the linter constantly running may be a little wasteful, but it is also good to clean up code, even if \"after the fact\".</p>",
        "id": 497381095,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1738576127
    },
    {
        "content": "<p>This kind of periodic clean up is not automated, but I have been thinking about it for some time and would like to see it implemented.</p>",
        "id": 497381102,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1738576128
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"767695\">Tristan Figueroa-Reid</span> <a href=\"#narrow/channel/287929-mathlib4/topic/linter.20requests/near/497344961\">said</a>:</p>\n<blockquote>\n<p>Would collapsing subsequent calls of <code>subst</code> be a good linter? (Are there any linters that look at adjacent tactic calls at all, like collapsing <code>rw/rwa ...</code> and <code>assertion</code> to <code>rwa</code>?)</p>\n</blockquote>\n<p>I have added this to the <a href=\"https://github.com/leanprover-community/mathlib4/issues/7217\">wishlist</a>, along with some of the earlier suggestions <span class=\"user-mention\" data-user-id=\"459227\">@Violeta Hernández</span> and <span class=\"user-mention\" data-user-id=\"306577\">@Matthew Ballard</span>  made, hope that's all right.</p>",
        "id": 497502127,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1738606117
    },
    {
        "content": "<p>My wish for today: write a \"low-level performance optimisation tactic linter\", which tries to replace one tactic with a \"faster\" one if that is possible. Let's use the replacement \"continuity -&gt; fun_prop\" as an example. This cannot always be done, but if it can, fun_prop is usually faster (sometimes by a lot). This linter would tell you \"this continuity call can be replaced by fun_prop\" could be useful.</p>\n<p>More specifically, I'm thinking of a syntax linter which does the following, for every pair <code>(slower_tactic, faster_tactic)</code>.</p>\n<ul>\n<li>look for occurrences of the <code>slower_tactic</code> tactic<ul>\n<li>careful: do ignore default parameters</li>\n<li>occurrences inside proofs (of theorems, instances or definitions) should be fine</li>\n</ul>\n</li>\n<li>try to replace this by the <code>faster_tactic</code> tactic</li>\n<li>elaborate the result: if there are no errors, print a message about the replacement. Otherwise, do nothing.</li>\n</ul>\n<p>As a start, the pair <code>(continuity, fun_prop)</code> and <code>(measurability, fun_prop)</code> could be a start.</p>",
        "id": 504596190,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1741616288
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> In case you're bored and want to write a performance-enhancing linter instead :-)</p>",
        "id": 504596273,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1741616306
    },
    {
        "content": "<p>My experience with figuring out what is faster using linters is that it is hard to avoid \"caching\": linters will usually re-elaborate some syntax that has already been elaborated and, in the process, will have access to cached computations.  This makes speed tests performed by linters somewhat unreliable.</p>",
        "id": 504602297,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1741617486
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"634338\">Michael Rothgang</span> <a href=\"#narrow/channel/287929-mathlib4/topic/linter.20requests/near/504596190\">said</a>:</p>\n<blockquote>\n<p>As a start, the pair <code>(continuity, fun_prop)</code> and <code>(measurability, fun_prop)</code> could be a start.</p>\n</blockquote>\n<p>Seems like something <a href=\"https://github.com/dwrensha/tryAtEachStep\">tryAtEachStep</a> could be helpful with.</p>",
        "id": 504619860,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1741620997
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/channel/287929-mathlib4/topic/linter.20requests/near/504602297\">said</a>:</p>\n<blockquote>\n<p>My experience with figuring out what is faster using linters is that it is hard to avoid \"caching\": linters will usually re-elaborate some syntax that has already been elaborated and, in the process, will have access to cached computations.  This makes speed tests performed by linters somewhat unreliable.</p>\n</blockquote>\n<p>Good point! In the case of fun_prop and continuity, in my experience the former is ~always a lot faster, so I don't need any speed comparisons. Telling me which ones can be replaced should suffice. :-)</p>",
        "id": 504646949,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1741627425
    },
    {
        "content": "<p>A pair I've encountered a few times is <code>(aesop, simp_all)</code>.</p>",
        "id": 506689727,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1742380408
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"634338\">Michael Rothgang</span> <a href=\"#narrow/channel/287929-mathlib4/topic/linter.20requests/near/504596190\">said</a>:</p>\n<blockquote>\n<p>More specifically, I'm thinking of a syntax linter which does the following, for every pair <code>(slower_tactic, faster_tactic)</code>.</p>\n<ul>\n<li>look for occurrences of the <code>slower_tactic</code> tactic<ul>\n<li>careful: do ignore default parameters</li>\n<li>occurrences inside proofs (of theorems, instances or definitions) should be fine</li>\n</ul>\n</li>\n<li>try to replace this by the <code>faster_tactic</code> tactic</li>\n<li>elaborate the result: if there are no errors, print a message about the replacement. Otherwise, do nothing.</li>\n</ul>\n</blockquote>\n<p>Since I imagine that this would be very slow like <code>tryAtEachStep</code>, it might be a good idea to categorize these slow linters in such a way that one could manually run them for a specific file/theorem: one could use this to golf-lint only files changed in a PR, for example. (This could also contain linters regarding simp - for example, permuting <code>simp only</code> calls with multiple theorems to see if there exists a potential call to <code>simp_rw</code>)</p>\n<p>(note: <a href=\"#narrow/channel/287929-mathlib4/topic/linter.20requests/near/497381095\">I just noticed that this was mentioned about 10 messages ago</a> - since this is being brought up more often, though, it might be a good time to consider implementing such a system.)</p>",
        "id": 506887053,
        "sender_full_name": "Tristan Figueroa-Reid",
        "timestamp": 1742451227
    },
    {
        "content": "<p>Also (taking advantage of the slowness of this linter) it would be nice if that tactic was transitive - e.g. cases when <code>simp_all</code> can just be <code>simp</code>.</p>",
        "id": 507098415,
        "sender_full_name": "Tristan Figueroa-Reid",
        "timestamp": 1742516394
    }
]