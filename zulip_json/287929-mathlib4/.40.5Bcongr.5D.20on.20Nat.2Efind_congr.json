[
    {
        "content": "<p>In <a href=\"https://github.com/leanprover-community/mathlib4/pull/22811\">#22811</a>, <a href=\"https://github.com/leanprover-community/mathlib4/pull/22811#discussion_r1988792379\">Anne suggested</a> that the following lemma is tagged <code>@[congr]</code>. But I don't understand what that does. Seemingly, <code>congr</code> the tactic behaves the same way. What would be the right example to test the behavior?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Find</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">congr</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"c1\">-- presence or absence doesn't change the example below</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">find_congr</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidablePred</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">hp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">hq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hpq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">find</span><span class=\"w\"> </span><span class=\"n\">hp</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">find</span><span class=\"w\"> </span><span class=\"n\">hq</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">le_antisymm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">find_mono</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">hpq</span><span class=\"bp\">.</span><span class=\"n\">mpr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">find_mono</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">hpq</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidablePred</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">hp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">hq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hpq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">find</span><span class=\"w\"> </span><span class=\"n\">hp</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">find</span><span class=\"w\"> </span><span class=\"n\">hq</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">congr</span>\n<span class=\"w\">  </span><span class=\"n\">guard_target</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">q</span>\n<span class=\"w\">  </span><span class=\"n\">ext</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hpq</span>\n</code></pre></div>",
        "id": 504857730,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1741703318
    },
    {
        "content": "<p>I don't believe <code>congr</code> tries applying user congruence theorems. The <code>congr!</code> tactic tries them however.</p>\n<p>The <code>@[congr]</code> attribute has the biggest effect on <code>simp</code>. It helps <code>simp</code> navigate into expressions. It's unclear whether <code>find_congr</code> would help <code>simp</code>, or whether it can even function correctly as a congruence lemma for simp. (Also, the fact it's an iff rather than = might throw simp off, I'm not sure.)</p>",
        "id": 504895914,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741710734
    },
    {
        "content": "<p>This is what the generated congruence lemma looks like roughly (didn't verify it). The <code>hq</code> argument likely will use <code>hpq ▸  hp</code> if the hpq argument isn't <code>rfl</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">find_congr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hpq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidablePred</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidablePred</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">find</span><span class=\"w\"> </span><span class=\"n\">hp</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">find</span><span class=\"w\"> </span><span class=\"n\">hq</span>\n</code></pre></div>",
        "id": 504896704,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741710926
    },
    {
        "content": "<p>What would be the guidance here then? Place the attr, don't place the attr, place but rephrase <code>hpq</code> as <code>p = q</code>?</p>",
        "id": 504896886,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1741710965
    },
    {
        "content": "<p>My guidance is \"don't place <code>@[congr]</code> unless you have concrete evidence you need it\"</p>",
        "id": 504896992,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741710999
    },
    {
        "content": "<p>And in this case, the auto-generated congruence lemma looks fine. I think the main reasons to write your own <code>@[congr]</code> lemma are (1) if you can slip in additional hypotheses about the domain in (like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.prod_congr#doc\">docs#Finset.prod_congr</a> or <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.filter_congr#doc\">docs#List.filter_congr</a>, though these are not marked <code>@[cong]</code>) or (2) if the auto-generated congruence lemma used the wrong heuristics, like some arguments that you want to rewrite were \"fixed\" because of a dependence that somehow doesn't matter.</p>",
        "id": 504897946,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741711259
    },
    {
        "content": "<p>Thanks! So I'll take the \"status quo\" guidance. Should there be docs relating how the <code>congr</code> attribute relates to (or doesn't) to the <code>congr</code> family of tactics?</p>",
        "id": 504898470,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1741711402
    },
    {
        "content": "<p>Yes there should be more documentation on this.</p>\n<p>What I hope to see is that in the not-too-distant future <code>congr!</code> will be merged into <code>congr</code>, so that difference will go away.</p>\n<p>I feel like <code>@[congr]</code> congruence lemmas are a really niche topic, even in a future where <code>congr</code> itself can use them. They have a lot of capacity to create havoc, and what's good as a congruence lemma for <code>simp</code> isn't necessarily good for <code>congr</code> and isn't necessarily good for <code>conv</code> tactics like <code>arg</code> — we might need separate attributes for these purposes too.</p>\n<p>I made <code>congr!</code> tactic use <code>@[congr]</code> lemmas just to potentially see additional hypotheses that might be useful to close goals, but now that I see that none of these map/filter lemmas have <code>@[congr]</code>, it's probably best to remove this feature, or at least shift it to a separate attribute. Too bad that attribute can't be called <code>@[congr]</code>, which will cause persistent confusion.</p>",
        "id": 504901612,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741712171
    },
    {
        "content": "<p>I would put in a vote, if it was possible, to rename the <code>@[congr]</code> attribute then =)</p>",
        "id": 504902827,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1741712483
    },
    {
        "content": "<p>to <code>simp_helper_congr</code> or something</p>",
        "id": 504902873,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1741712496
    },
    {
        "content": "<p>Regarding <a href=\"https://github.com/leanprover-community/mathlib4/pull/22811\">#22811</a>, I'm not sure we want the lemma at all, given that <code>congr!</code> can pretty much do all the work.</p>",
        "id": 504903185,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1741712565
    },
    {
        "content": "<p>Or even <code>simp_rw</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">find_congr</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidablePred</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">hp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">hq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hpq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">find</span><span class=\"w\"> </span><span class=\"n\">hp</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">find</span><span class=\"w\"> </span><span class=\"n\">hq</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">funext</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">propext</span><span class=\"w\"> </span><span class=\"n\">hpq</span>\n<span class=\"w\">  </span><span class=\"n\">simp_rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 504903391,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1741712619
    },
    {
        "content": "<p>I think I'd expect find_congr to be something  stronger like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- If a predicate `p` holds at `x` and agrees with `q` up to that `x`, then ... -/</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">find_congr</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidablePred</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hpq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">find</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">find</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">from</span><span class=\"w\"> </span><span class=\"n\">hpq</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">le_rfl</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 504904400,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1741712875
    },
    {
        "content": "<p>I'll add that stronger lemma</p>",
        "id": 504911035,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1741714784
    },
    {
        "content": "<p>That's a nice strengthening.</p>\n<p>Renaming <code>@[congr]</code> to <code>@[simp_congr]</code> would be a big improvement. I don't know if we can do that, but I'll investigate. Possibly we could make it be <code>@[simp congr]</code>. This would go hand-in-hand with a feature to have per-simp-set congruence lemmas. It sounds low-priority to me, especially without any known applications. (I'm imagining that you have some functions where you want to rewrite only a specific argument, holding the others fixed. You could make a simp set with congruence lemmas that target that specific argument. It'll take a real application of this though to move forward.)</p>",
        "id": 504913705,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741715569
    }
]