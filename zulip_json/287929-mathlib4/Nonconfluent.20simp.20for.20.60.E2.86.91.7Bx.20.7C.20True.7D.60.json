[
    {
        "content": "<p>Although there is <code>Set.coe_setOf {α : Type u} (p : α → Prop) : ↑{x | p x} = { x // p x }</code>, the following fails:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"c\">/-</span>\n<span class=\"cm\">  unsolved goals</span>\n\n<span class=\"cm\">  α : Type u_1</span>\n<span class=\"cm\">  ⊢ ↑Set.univ = { x // True }</span>\n<span class=\"cm\">  -/</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n</code></pre></div>\n<p>I ran into this when trying to show that <code>Nat.card {x : Fin n // True} = n</code>.</p>\n<p>Should there be a simp lemma for rewriting <code>{ x // True }</code> into <code>↑Set.univ</code>?</p>",
        "id": 490060024,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1734647625
    },
    {
        "content": "<p>This is equality of types so it makes me feel a bit queezy.</p>",
        "id": 490065029,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1734650388
    },
    {
        "content": "<p>Me too, though apparently this case is supported? It seems to be a simp confluence issue; <code>simp [-Set.setOf_true]</code> solves the original goal</p>",
        "id": 490065204,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1734650501
    },
    {
        "content": "<p>Here's what I was looking at:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">19</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">19</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">ncard</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">card_coe_set_eq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">coe_setOf</span><span class=\"o\">,</span>\n<span class=\"w\">      </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">card_congr</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">subtypePiEquivPi</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">19</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">card_pi</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">prod_univ_add</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">9</span><span class=\"o\">)]</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span>\n<span class=\"w\">    </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>This proof works, but it breaks down when replacing 2 by 200, because the <code>rfl</code> at the end can't expand that much.</p>\n<p>And the only reason for working with types instead of sets was that there seems to be no equivalent to <code>Equiv.subtypePiEquivPi</code> that works with sets. Unfortunately I can't manage to rewrite back to the <code>setOf</code> representation, because I can't rewrite under a binder, and <code>simp_rw [← Set.coe_setOf]</code> gets stuck in a loop.</p>",
        "id": 490067604,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1734651939
    },
    {
        "content": "<p>I would guess the answer is to add a <code>Set</code> version of <code>Equiv.subtypePiEquivPi</code></p>",
        "id": 490068012,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1734652191
    },
    {
        "content": "<p>Another point about <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Logic/Equiv/Basic.html#Equiv.subtypePiEquivPi\">Equiv.subtypePiEquivPi</a> is that, similar to <code>Classical.skolem</code>, it contains a term that usually can't be figured out by unifiication, namely the <code>p a (f a)</code> in <code>{ f : (a : α) → β a // ∀ (a : α), p a (f a) }</code>. Should the <code>p</code> be made an explicit parameter? (in <code>Classical.skolem</code>, it is not so bad because the lemma is the other way around, with the bad term on the rhs)</p>",
        "id": 490068788,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1734652643
    },
    {
        "content": "<p>Or even better could there be some hint to the unification algorithm for how to deal with such unifications? The difficulty is that the term <code>f a</code> is not a single free variable, so it can't be abstracted as easily.</p>",
        "id": 490068982,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1734652776
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Nonconfluent.20simp.20for.20.60.E2.86.91.7Bx.20.7C.20True.7D.60/near/490065029\">said</a>:</p>\n<blockquote>\n<p>This is equality of types so it makes me feel a bit queezy.</p>\n</blockquote>\n<p>As long as it stays defeq it's fine, I think</p>",
        "id": 490189904,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1734710701
    },
    {
        "content": "<p>The way you would usually encounter <code>{x // True}</code> in simp is by running simp on <code>{x // some complicated expression}</code>. So simp would already do some non-defeq rewrites of this type. At that point the defeq rewrite into <code>↑Set.univ</code> is not much to worry about.</p>",
        "id": 490190915,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1734711048
    },
    {
        "content": "<p>Does <code>simp</code> do non-defeq rewrites in types?</p>",
        "id": 490190992,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1734711084
    },
    {
        "content": "<p>Yes:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 490191196,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1734711155
    },
    {
        "content": "<p>That's not a type here, it's only a term. For example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"n\">rfl</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"bp\">.</span><span class=\"n\">intro</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">fail_if_success</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">const_apply</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 490191823,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1734711416
    },
    {
        "content": "<p>Wait, I thought a term <code>x</code> is a type if and only if <code>x : Type _</code> holds.</p>",
        "id": 490192079,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1734711515
    },
    {
        "content": "<p>It is a type, I meant \"in contexts where it's a type of some other term\"</p>",
        "id": 490192251,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1734711585
    },
    {
        "content": "<p>But if I add this simp lemma, it does (defeq) simp the type:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">subtype_true</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">_</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"n\">rfl</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"bp\">.</span><span class=\"n\">intro</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">const_apply</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 490193001,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1734711844
    },
    {
        "content": "<p>(it's using <code>Function.const_one</code> since you imported Mathlib)</p>",
        "id": 490193253,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1734711940
    },
    {
        "content": "<p>Oh oops, it doesn't</p>",
        "id": 490193257,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1734711941
    },
    {
        "content": "<p>it does use it</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">subtype_true</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">_</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"n\">rfl</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"bp\">.</span><span class=\"n\">intro</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp?</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">const_apply</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">const_one</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">says</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">subtype_true</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 490193285,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1734711955
    },
    {
        "content": "<p>in any case, that's my point - it only does <code>dsimp</code> on types, I think</p>",
        "id": 490193442,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1734711992
    },
    {
        "content": "<p>Hmm, then would it make sense to tag this lemma as a non-dsimp lemma? And is that even possible?</p>",
        "id": 490193898,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1734712128
    },
    {
        "content": "<p>I think that happens if the proof isn't literally <code>rfl</code></p>",
        "id": 490199102,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1734714013
    },
    {
        "content": "<p>Then should this lemma be added with the proof <code>id rfl</code>?</p>",
        "id": 490210213,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1734718868
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"690858\">Daniel Weber</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Nonconfluent.20simp.20for.20.60.E2.86.91.7Bx.20.7C.20True.7D.60/near/490190992\">said</a>:</p>\n<blockquote>\n<p>Does <code>simp</code> do non-defeq rewrites in types?</p>\n</blockquote>\n<p>It's not about types vs terms, but which arguments are dependent on what. In Jovan's rewriting types in an equality example, there's no dependence in <code>@Eq X a b</code> for <code>a</code> and <code>b</code>, but <code>X</code> is depended upon. Types are commonly depended upon, but there are plenty of examples where terms are depended upon. In general, <code>simp</code> falls back to <code>dsimp</code> for arguments that are depended upon, with some exceptions (for example, if it's a proof or a Decidable instance that's the dependent, <code>simp</code> has a procedure to use the full <code>simp</code> procedure anyway).</p>",
        "id": 490212006,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1734719689
    },
    {
        "content": "<p>For what it's worth, I've found simp lemmas that go between subtypes and coerced sets to cause issues. In the past, it made me think that they should not be simp lemmas at all, and they should be opt-in.</p>\n<p>The alternative is to commit to choosing, for example, coerced sets to be the simp normal form for subtypes in general, and to never use subtypes directly.</p>",
        "id": 490213827,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1734720580
    },
    {
        "content": "<p>Would there be any disadvantage to comitting to coerced set notation as the default, and banishing any occurrences of {x // _} from Mathlib?</p>",
        "id": 490225500,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1734726193
    },
    {
        "content": "<p>Not sure. I floated this idea once awhile back, but I don't remember much agreement, and it seems like a lot of work. (Assuming no complications, I would think this would be a big improvement to normalize!)</p>",
        "id": 490226970,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1734726945
    },
    {
        "content": "<p>The only thing that worried me a bit is that the definitional equality of the types doesn't hold in reducible transparency, but I don't think this is a problem.</p>",
        "id": 490227313,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1734727126
    },
    {
        "content": "<p>I also noticed a discrepancy in the pretty printer: it shows <code>{a | True}</code>, but <code>{ a // True }</code> has extra spaces</p>",
        "id": 490227415,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1734727187
    }
]