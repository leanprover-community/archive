[
    {
        "content": "<p>I'm looking into formalizing the notion that a <code>Float</code> approximates a real number.</p>\n<p>For some reason the following code works for <code>ℚ</code>, but for some reason it throws an error for <code>ℝ</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">IsApproxℚ</span> <span class=\"o\">:</span> <span class=\"n\">Float</span> <span class=\"bp\">→</span> <span class=\"n\">ℚ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">|</span> <span class=\"n\">ofNat</span> <span class=\"o\">(</span><span class=\"n\">base</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsApproxℚ</span> <span class=\"o\">(</span><span class=\"n\">Float.ofNat</span> <span class=\"n\">base</span><span class=\"o\">)</span> <span class=\"n\">base</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">IsApproxℚ</span> <span class=\"o\">(</span><span class=\"n\">Float.ofNat</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">IsApproxℚ.ofNat</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">IsApproxℝ</span> <span class=\"o\">:</span> <span class=\"n\">Float</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">|</span> <span class=\"n\">ofNat</span> <span class=\"o\">(</span><span class=\"n\">base</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsApproxℝ</span> <span class=\"o\">(</span><span class=\"n\">Float.ofNat</span> <span class=\"n\">base</span><span class=\"o\">)</span> <span class=\"n\">base</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">IsApproxℝ</span> <span class=\"o\">(</span><span class=\"n\">Float.ofNat</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">IsApproxℝ.ofNat</span>\n</code></pre></div>\n<p>Why is that? Can I make this work somehow?</p>",
        "id": 401106843,
        "sender_full_name": "Markus Schmaus",
        "timestamp": 1699520054
    },
    {
        "content": "<p>Here is the error message:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">tactic</span> <span class=\"bp\">'</span><span class=\"n\">apply'</span> <span class=\"n\">failed</span><span class=\"o\">,</span> <span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">unify</span>\n  <span class=\"n\">IsApproxℝ</span> <span class=\"o\">(</span><span class=\"n\">Float.ofNat</span> <span class=\"bp\">?</span><span class=\"n\">base</span><span class=\"o\">)</span> <span class=\"bp\">↑?</span><span class=\"n\">base</span>\n<span class=\"k\">with</span>\n  <span class=\"n\">IsApproxℝ</span> <span class=\"o\">(</span><span class=\"n\">Float.ofNat</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"mi\">1</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">IsApproxℝ</span> <span class=\"o\">(</span><span class=\"n\">Float.ofNat</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"mi\">1</span>\n</code></pre></div>",
        "id": 401107035,
        "sender_full_name": "Markus Schmaus",
        "timestamp": 1699520115
    },
    {
        "content": "<p>If you try</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">convert</span> <span class=\"n\">IsApproxℝ.ofNat</span> <span class=\"mi\">1</span>\n</code></pre></div>\n<p>instead of <code>apply</code>, you will see what is the issue that Lean is facing.  Essentially, you need to provide a proof that one <code>1</code> is equal to another <code>1</code>!</p>",
        "id": 401108697,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1699520512
    },
    {
        "content": "<p>That's very useful.  This results in two goals, one that <code>1 = ↑1</code> and another that <code>ℝ</code> is inhabited. Curiously, for 2 it's only necessary to show that <code>ℝ</code> is inhabited. Why is this only necessary for <code>ℝ</code>, but not for <code>ℚ</code>?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">IsApproxℝ</span> <span class=\"o\">:</span> <span class=\"n\">Float</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">|</span> <span class=\"n\">ofNat</span> <span class=\"o\">(</span><span class=\"n\">base</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">exact</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">IsApproxℝ</span> <span class=\"o\">(</span><span class=\"n\">Float.ofNat</span> <span class=\"n\">base</span><span class=\"o\">)</span> <span class=\"n\">base</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">IsApproxℝ</span> <span class=\"o\">(</span><span class=\"n\">Float.ofNat</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">convert</span> <span class=\"n\">IsApproxℝ.ofNat</span> <span class=\"mi\">1</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Nat.cast_one</span><span class=\"o\">]</span>\n  <span class=\"n\">exact</span> <span class=\"n\">Inhabited.default</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">IsApproxℝ</span> <span class=\"o\">(</span><span class=\"n\">Float.ofNat</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">convert</span> <span class=\"n\">IsApproxℝ.ofNat</span> <span class=\"mi\">2</span>\n  <span class=\"n\">exact</span> <span class=\"n\">Inhabited.default</span>\n</code></pre></div>",
        "id": 401112191,
        "sender_full_name": "Markus Schmaus",
        "timestamp": 1699521410
    },
    {
        "content": "<p>Probably because in the case of the rationals the proof is <code>rfl</code> and in the case of the reals it's not. Your <code>apply</code> proof only works <em>assuming</em> that the two 1's are equal by definition, so whether it works in practice all depends on the underlying definitions of things, which is sort of random.</p>",
        "id": 401113250,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1699521699
    }
]