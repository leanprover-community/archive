[
    {
        "content": "<p>I want to create a FirstOrder.Language for the language of set theory, with one relation symbol for \\in (and if necessary another relation symbol for =). I have the following idea, but I think I need to replace <code>ZFSet</code> with a type that has only <code>ZFSet</code> as a member. If I do this will it give me the first-order language I intend? If so, how do I do this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">FOST</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FirstOrder</span><span class=\"bp\">.</span><span class=\"n\">Language</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">  </span><span class=\"n\">Functions</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">PEmpty</span><span class=\"o\">),</span>\n<span class=\"w\">  </span><span class=\"n\">Relations</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">↦</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">ZFSet</span><span class=\"bp\">.</span><span class=\"n\">Mem</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">PEmpty</span><span class=\"o\">)</span>\n<span class=\"o\">}</span>\n</code></pre></div>",
        "id": 570288174,
        "sender_full_name": "C7X",
        "timestamp": 1769511072
    },
    {
        "content": "<p>I think I have solved this, by looking at how it was done in the Flypitch project's <a href=\"https://github.com/flypitch/flypitch/blob/master/src/zfc.lean\"><code>zfc.lean</code></a>and mathlib4's <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/ModelTheory/Arithmetic/Presburger/Basic.html#FirstOrder.Language.presburger\"><code>FirstOrder.Language.presburger</code></a>. For future readers, here's my example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">FOSTRel</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mem</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FOSTRel</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">FOST</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FirstOrder</span><span class=\"bp\">.</span><span class=\"n\">Language</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">  </span><span class=\"n\">Functions</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">PEmpty</span><span class=\"o\">),</span>\n<span class=\"w\">  </span><span class=\"n\">Relations</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">FOSTRel</span>\n<span class=\"o\">}</span>\n</code></pre></div>",
        "id": 570313132,
        "sender_full_name": "C7X",
        "timestamp": 1769518646
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"919332\">C7X</span> <a href=\"#narrow/channel/287929-mathlib4/topic/How.20to.20create.20a.20FirstOrder.2ELanguage.3F/near/570313132\">said</a>:</p>\n<blockquote>\n<p>I think I have solved this, by looking at how it was done in the Flypitch project's <a href=\"https://github.com/flypitch/flypitch/blob/master/src/zfc.lean\"><code>zfc.lean</code></a>and mathlib4's <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/ModelTheory/Arithmetic/Presburger/Basic.html#FirstOrder.Language.presburger\"><code>FirstOrder.Language.presburger</code></a>. For future readers, here's my example:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">FOSTRel</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mem</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FOSTRel</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">FOST</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FirstOrder</span><span class=\"bp\">.</span><span class=\"n\">Language</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">  </span><span class=\"n\">Functions</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">PEmpty</span><span class=\"o\">),</span>\n<span class=\"w\">  </span><span class=\"n\">Relations</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">FOSTRel</span>\n<span class=\"o\">}</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Looking back at my recent attempt to do L (which did not go much beyond writing the definition down), I think you're going to want these instances eventually.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">FOSTRel</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mem</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FOSTRel</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n<span class=\"w\">  </span><span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">FOST</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FirstOrder</span><span class=\"bp\">.</span><span class=\"n\">Language</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">  </span><span class=\"n\">Functions</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">PEmpty</span><span class=\"o\">),</span>\n<span class=\"w\">  </span><span class=\"n\">Relations</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">FOSTRel</span>\n<span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">FirstOrder</span><span class=\"bp\">.</span><span class=\"n\">Language</span><span class=\"bp\">.</span><span class=\"n\">IsRelational</span>\n</code></pre></div>",
        "id": 570369391,
        "sender_full_name": "James E Hanson",
        "timestamp": 1769531963
    },
    {
        "content": "<p>Oh wow, I was trying to define L with this too, thanks for the advice!</p>",
        "id": 570369897,
        "sender_full_name": "C7X",
        "timestamp": 1769532079
    },
    {
        "content": "<p>You're also maybe going to want a type class for languages that extend FOST and a term-forming function for the in-relation.</p>\n<p>I can DM you what I did if you want.</p>",
        "id": 570370076,
        "sender_full_name": "James E Hanson",
        "timestamp": 1769532117
    },
    {
        "content": "<p>Sure, that would be great!</p>",
        "id": 570370319,
        "sender_full_name": "C7X",
        "timestamp": 1769532175
    },
    {
        "content": "<p>Also, if I recall correctly, <a href=\"https://github.com/flypitch/flypitch\">the Flypitch project</a>'s paper mentioned the idea of maybe eventually doing L, so maybe <span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> would have some relevant suggestions.</p>",
        "id": 570370530,
        "sender_full_name": "James E Hanson",
        "timestamp": 1769532227
    },
    {
        "content": "<p>Anyway, I kind of suspect that while the definition in terms of first-order definability is very easy to write down, the more common definition in terms of rudimentary functions or the Gödel operations are maybe going to be easier to work with in Lean.</p>",
        "id": 570371496,
        "sender_full_name": "James E Hanson",
        "timestamp": 1769532496
    },
    {
        "content": "<p>But maybe not. The existing Mathlib implementation of downward Löwenheim–Skolem may end up saving a lot of time if and when you get to condensation.</p>",
        "id": 570371704,
        "sender_full_name": "James E Hanson",
        "timestamp": 1769532545
    },
    {
        "content": "<p>That's nice! I feel <code>inductive</code> is usually better than <code>if</code> in defining FO symbols, since it 1. gives names for symbols 2. Allows you to do <code>match</code> or <code>cases</code> on variables of type <code>Functions n</code> or <code>Relations n</code></p>",
        "id": 570442355,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1769556689
    },
    {
        "content": "<p>I'm also trying to define L recently. Flypitch uses an extended language that includes function symbols for empty sets, powersets, etc, which is good in defining formulas like \"x is a function\" or the axiom of choice. But it's hard to give interpretations when I want to say \"every <code>ZFSet</code> has a structure of set theory\" since arbitrary sets are not closed under these functions.</p>",
        "id": 570443223,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1769557243
    },
    {
        "content": "<p>Meanwhile, it's natural to use a language that contains purely one symbol of membership (and the equality), but it then seems harder to define the axioms of ZFC in this language. I find <a href=\"https://github.com/leanprover-community/mathlib4/pull/26644\">#26644</a> has a very nice idea on addressing this, it defines <code>Class</code> formulas that are predicates over all sets, but also allows one to use it as if using a term (and such formula is only meaningful if the <code>Class</code> is actually a set).</p>",
        "id": 570443974,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1769557698
    },
    {
        "content": "<p>Great!</p>\n<blockquote>\n<ol start=\"2\">\n<li>Allows you to do <code>match</code> or <code>cases</code> on variables of type <code>Functions n</code> or <code>Relations n</code></li>\n</ol>\n</blockquote>\n<p>I don't understand this yet, so I will guess that it comes up when I've done more work with FirstOrder (so far I just started).</p>\n<blockquote>\n<p><code>Class</code> formulas</p>\n</blockquote>\n<p>I'll also have to look at how notations like <code>∀'</code> work here, if they allow brief definition of formal formulas. Thanks for the pointer!</p>",
        "id": 570452709,
        "sender_full_name": "C7X",
        "timestamp": 1769563772
    },
    {
        "content": "<p>(Oh, hi C7X! Glad to finally see you around here)</p>",
        "id": 575887966,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1772060026
    },
    {
        "content": "<p>(Hi!)</p>",
        "id": 575888000,
        "sender_full_name": "C7X",
        "timestamp": 1772060039
    }
]