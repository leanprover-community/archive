[
    {
        "content": "<p>There's been some discussion of this on github, and I thought I'd summarise the key points of this discussion in one place.</p>\n<p>Currently we have three type of first-order formula in the model theory library. We have <code>BoundedFormula</code>, <code>Formula</code>, and <code>Sentence</code>. <code>Formula</code> and <code>Sentence</code> are both defined as abbreviations in terms of <code>BoundedFormula</code>. </p>\n<ul>\n<li><code>BoundedFormula L α n</code> is the type of formulas with free variables indexed by <code>α</code> and <code>n</code> additional free variables. The <code>n</code> additional free variables are the variables that may later be bounded by applying an <code>all</code> constructor. This implementation is forced because of universe issues, you could try making a constructor <code>all : Formula (Option α) -&gt; Formula  α</code>, but then this forces <code>Formula</code> to go up a universe as one of the constructors takes a type as an argument.</li>\n<li><code>Formula L α</code> is the type of formulas with free variables indexed by <code>α</code>, defined to be <code>BoundedFormula L α 0</code></li>\n<li><code>Sentence L</code> is the type of formulas with no free variables, defined to be <code>Formula L Empty</code>.</li>\n</ul>\n<p>There are different functions for talking about the semantics of each of these formulas. <code>BoundedFormula.Realize</code>, <code>Formula.Realize</code> and <code>Sentence.Realize</code>. My understanding is that the main motivation for having these three different functions for talking about the semantics of formulas is that in the special case that <code>n = 0</code>, <code>BoundedFormula.Realize</code> takes an argument <code>Fin 0 -&gt; M</code>, and these arguments are always equal of course, but may not be syntactically or definitionally equal. </p>\n<p>This duplication leads to a lot of duplication in the model theory library. For example we have both<code>Term.equal</code> which is a <code>Formula</code> and <code>Term.bdEqual</code> which is a <code>BoundedFormula</code>. These both need <code>simp</code> lemmas about their semantics, and additionally, because <code>Formula</code> is reducible, I could apply <code>BoundedFormula.Realize</code>to  <code>Term.equal</code> and then maybe we need a third simp lemma for that.</p>\n<p>I don't have a good answer for what the solution is here. I suspect that making <code>BoundedFormula</code> a implementation detail that should often be mentioned by users and adding a definition <code>Formula.all : Formula L (Option α) -&gt; Formula L α</code> or similar might be a good idea. I think better support for equality of terms <code>Fin 0 -&gt; _</code> or <code>Empty -&gt; _</code> will also help here.</p>",
        "id": 500004630,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1739706896
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span>  <span class=\"user-mention\" data-user-id=\"302826\">@Aaron Anderson</span></p>",
        "id": 500005233,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1739707427
    },
    {
        "content": "<p>Maybe <span class=\"user-mention\" data-user-id=\"116045\">@Jesse Michael Han</span> and <span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> have something to say here</p>",
        "id": 500006115,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1739708268
    },
    {
        "content": "<p>Some functions notably missing from this setup are substitution of terms (which may have free variables) into other terms, and into formulae: my impression, last I looked, is that this is all much easier to work with if you use _purely_ BoundedFormula.</p>",
        "id": 500041726,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1739737200
    },
    {
        "content": "<p>This is maybe a bit ugly, but would it help to completely eliminate <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">\\alpha</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span> from the story, and just work with a hard-coded <code>Var := Nat</code> or something like that?</p>",
        "id": 500185054,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1739798479
    },
    {
        "content": "<p>That would eliminate the universe bump in <code>all</code>, right?</p>",
        "id": 500185102,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1739798492
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Model.20Theory.3A.20BoundedFormula.2C.20Formula.20and.20Sentence/near/500041726\">said</a>:</p>\n<blockquote>\n<p>Some functions notably missing from this setup are substitution of terms (which may have free variables) into other terms, and into formulae: my impression, last I looked, is that this is all much easier to work with if you use _purely_ BoundedFormula.</p>\n</blockquote>\n<p>This doesn't look particularly hard to me. The interface is not there, but it's not hard to define.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">ModelTheory</span><span class=\"bp\">.</span><span class=\"n\">Satisfiability</span>\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">linter</span><span class=\"bp\">.</span><span class=\"n\">style</span><span class=\"bp\">.</span><span class=\"n\">header</span><span class=\"w\"> </span><span class=\"n\">false</span>\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">FirstOrder</span>\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Language</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Language</span><span class=\"o\">}</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Formula</span><span class=\"bp\">.</span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">Formula</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">Formula</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Language</span><span class=\"bp\">.</span><span class=\"n\">BoundedFormula</span><span class=\"bp\">.</span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"n\">f</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">realize_subst</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">Structure</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">Formula</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Formula</span><span class=\"bp\">.</span><span class=\"n\">Realize</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">Realize</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">realize</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Formula</span><span class=\"bp\">.</span><span class=\"n\">subst</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Formula</span><span class=\"bp\">.</span><span class=\"n\">Realize</span><span class=\"o\">]</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">Language</span>\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">FirstOrder</span>\n</code></pre></div>",
        "id": 500228323,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1739808320
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Model.20Theory.3A.20BoundedFormula.2C.20Formula.20and.20Sentence/near/500185054\">said</a>:</p>\n<blockquote>\n<p>This is maybe a bit ugly, but would it help to completely eliminate <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">\\alpha</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span> from the story, and just work with a hard-coded <code>Var := Nat</code> or something like that?</p>\n</blockquote>\n<p>I think this would make life very difficult, the type <code>α</code> is usually a sum or sigma type, or combination thereof, and working with this is a lot easier than whatever embedding into nat you chose. You would also have the problem that the semantics would then depend on the semantics of variables not in the image of this map (which wouldn't appear in the formula, but you have to deal with reasoning about that). You also have the problem of variables being bound in one position in the formula, but free in another, which seems like it would make things like relabelling quite complicated.</p>",
        "id": 500230982,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1739808952
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110044\">Chris Hughes</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Model.20Theory.3A.20BoundedFormula.2C.20Formula.20and.20Sentence/near/500228323\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Model.20Theory.3A.20BoundedFormula.2C.20Formula.20and.20Sentence/near/500041726\">said</a>:</p>\n<blockquote>\n<p>Some functions notably missing from this setup are substitution of terms (which may have free variables) into other terms, and into formulae: my impression, last I looked, is that this is all much easier to work with if you use _purely_ BoundedFormula.</p>\n</blockquote>\n<p>This doesn't look particularly hard to me. The interface is not there, but it's not hard to define.</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">ModelTheory</span><span class=\"bp\">.</span><span class=\"n\">Satisfiability</span>\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">linter</span><span class=\"bp\">.</span><span class=\"n\">style</span><span class=\"bp\">.</span><span class=\"n\">header</span><span class=\"w\"> </span><span class=\"n\">false</span>\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">FirstOrder</span>\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Language</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Language</span><span class=\"o\">}</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Formula</span><span class=\"bp\">.</span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">Formula</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">Formula</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Language</span><span class=\"bp\">.</span><span class=\"n\">BoundedFormula</span><span class=\"bp\">.</span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"n\">f</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">realize_subst</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">Structure</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">Formula</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Formula</span><span class=\"bp\">.</span><span class=\"n\">Realize</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">Realize</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">realize</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Formula</span><span class=\"bp\">.</span><span class=\"n\">subst</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Formula</span><span class=\"bp\">.</span><span class=\"n\">Realize</span><span class=\"o\">]</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">Language</span>\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">FirstOrder</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Ah! For some reason I thought <code>BoundedFormula.subst</code> didn't exist; you're completely right and this is easy.</p>",
        "id": 500239022,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1739811046
    },
    {
        "content": "<p>I think for a lot of applications, we want some form of the ability to just use an arbitrary type as variables. However, there are potentially ways to have the basic definition of a formula have just <code>Fin n</code> as its variable type.<br>\nAt a most basic level, the information of a <code>Formula α</code> can always be captured with a <code>BoundedFormula Empty n</code> and a function <code>f : Fin n → α</code>.</p>",
        "id": 500244370,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1739812506
    },
    {
        "content": "<p>One idea I've had has to do with the fact that there is yet another layer of definition that is relevant - formulas modulo some theory. These are closer to what is actually talked about in model theory (nobody really cares about the difference between <code>∀ ¬ φ(x)</code> and <code>¬ ∃ φ(x)</code>). I tried to implement these in <a href=\"https://github.com/leanprover-community/mathlib4/pull/16801\">#16801</a>, but in addition to me getting caught up with teaching, one of the big issues was that this doubles the number of definitions, when there are already too many!</p>",
        "id": 500245553,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1739812932
    },
    {
        "content": "<p>These would be really nice to have though, because then, for instance, formulas actually form a meaningful boolean algebra.</p>",
        "id": 500245674,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1739812986
    },
    {
        "content": "<p>As an experiment, I think it would be interesting to create a branch where there are just two definitions of a formula, a low-level one and a high-level one: </p>\n<ul>\n<li><code>Formula n</code> is basically the current <code>BoundedFormula Empty n</code>, with variables indexed by <code>Fin n</code>, it plays well with quantifiers, and is good for setting up the basic recursive definitions.</li>\n<li>For a theory <code>T</code>, <code>T.Formula α</code> is what you would want to work with for applications. This could be implemented as an equivalence class of pairs <code>⟨n, φ, f⟩</code>, where <code>φ : Formula n</code> and <br>\n<code>f : Fin n → α</code>.</li>\n</ul>",
        "id": 500246639,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1739813391
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110044\">Chris Hughes</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Model.20Theory.3A.20BoundedFormula.2C.20Formula.20and.20Sentence/near/500230982\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Model.20Theory.3A.20BoundedFormula.2C.20Formula.20and.20Sentence/near/500185054\">said</a>:</p>\n<blockquote>\n<p>This is maybe a bit ugly, but would it help to completely eliminate <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">\\alpha</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span> from the story, and just work with a hard-coded <code>Var := Nat</code> or something like that?</p>\n</blockquote>\n<p>I think this would make life very difficult, the type <code>α</code> is usually a sum or sigma type, or combination thereof, and working with this is a lot easier than whatever embedding into nat you chose. You would also have the problem that the semantics would then depend on the semantics of variables not in the image of this map (which wouldn't appear in the formula, but you have to deal with reasoning about that). You also have the problem of variables being bound in one position in the formula, but free in another, which seems like it would make things like relabelling quite complicated.</p>\n</blockquote>\n<p>What applications do we actually have using variables indexed by <code>α</code>?<br>\nI think <span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> has added all those applications as part of Ax-Grothendieck.</p>\n<p>I ask because I'd like to see how much (outside of the basic model theory library itself) would be changed by altering the way those variables are introduced.</p>",
        "id": 504591542,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1741615390
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"302826\">Aaron Anderson</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Model.20Theory.3A.20BoundedFormula.2C.20Formula.20and.20Sentence/near/500246639\">said</a>:</p>\n<blockquote>\n<p>As an experiment, I think it would be interesting to create a branch where there are just two definitions of a formula, a low-level one and a high-level one: </p>\n<ul>\n<li><code>Formula n</code> is basically the current <code>BoundedFormula Empty n</code>, with variables indexed by <code>Fin n</code>, it plays well with quantifiers, and is good for setting up the basic recursive definitions.</li>\n<li>For a theory <code>T</code>, <code>T.Formula α</code> is what you would want to work with for applications. This could be implemented as an equivalence class of pairs <code>⟨n, φ, f⟩</code>, where <code>φ : Formula n</code> and <br>\n<code>f : Fin n → α</code>.</li>\n</ul>\n</blockquote>\n<p>I can think of another way to introduce variables indexed by <code>α</code> - technically don't, and instead define <code>Formula α</code>as a sentence in a language with extra constants indexed by <code>α</code>.</p>",
        "id": 504591895,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1741615455
    },
    {
        "content": "<p>As far as I know, this could be difficult to deal with, but it has some advantages, such as easier inductive definitions and the fact that then a type is technically just a theory, so we can use the same API for both.</p>",
        "id": 504592317,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1741615551
    },
    {
        "content": "<p>For ax Grothendieck you have to quantify over the coefficients of the MV polynomials in question, so that's one variable for each monomial. And then for injectivity and surjectivity you need two elements of C^n as well, so overall alpha is the sum of all that.</p>",
        "id": 504594254,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1741615917
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110044\">Chris Hughes</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Model.20Theory.3A.20BoundedFormula.2C.20Formula.20and.20Sentence/near/504594254\">said</a>:</p>\n<blockquote>\n<p>For ax Grothendieck you have to quantify over the coefficients of the MV polynomials in question, so that's one variable for each monomial. And then for injectivity and surjectivity you need two elements of C^n as well, so overall alpha is the sum of all that.</p>\n</blockquote>\n<p>Yes, I think the Ax-Grothendieck application is proof enough that we want some kind of <code>Formula α</code>. I just think at the moment this is the only use case where <code>Formula α</code> obviously wins over <code>BoundedFormula Empty n</code>.</p>",
        "id": 504613199,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1741619602
    },
    {
        "content": "<p>Furthermore, I think that anything to do with rings would be easier to work with in the context of formulas modulo a theory. If we defined <code>T.Term α</code> to be the type of all terms mod equivalence under the theory <code>T</code>, and similarly <code>T.Formula α</code> to be the type of all formulas mod <code>T</code>-equivalence, then <code>T.Term α</code> would be in natural bijection with <code>MVPolynomial α</code>.</p>",
        "id": 504614569,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1741619880
    },
    {
        "content": "<p>I still don't see why we need bounded formula. Doesn't <code>Formula (Fin n)</code> work just fine?</p>\n<p>For terms modulo a theory I have a PR open that defines <code>FunctionalFormula</code> which would be a generalization of this that also included all definable functions, so for example you could have a sqrt function in real closed fields, or a division function in fields without having to make this part of the theory. </p>\n<p>I agree that formulas modulo equivalence is a good idea. My only concern is about properties that aren't preserved under equivalence, like being quantifier free, but I don't think this is much of an issue as it's rare to need to distinguish between quantifier free and equivalent to a quantifier free formula.</p>\n<p>The last thing I would change is that I think Theories should be sets of formulas closed under deduction. This is how I was taught it, and you get a sensible partial order with the right notion of equality. You can of course then talk about the theory generated by a set.</p>",
        "id": 504636379,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1741624338
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110044\">Chris Hughes</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Model.20Theory.3A.20BoundedFormula.2C.20Formula.20and.20Sentence/near/504636379\">said</a>:</p>\n<blockquote>\n<p>I still don't see why we need bounded formula. Doesn't <code>Formula (Fin n)</code> work just fine?</p>\n</blockquote>\n<p>Personally, I think that enough of the basic definitions involve recursion on formulas that <code>BoundedFormula</code>s are probably essential.</p>",
        "id": 504646872,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1741627403
    },
    {
        "content": "<p>You can define custom induction principles for this. I think this might be necessary anyway as I think different theorems might require different induction principles anyway.</p>",
        "id": 504697691,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1741644897
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110044\">Chris Hughes</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Model.20Theory.3A.20BoundedFormula.2C.20Formula.20and.20Sentence/near/504636379\">said</a>:</p>\n<blockquote>\n<p>The last thing I would change is that I think Theories should be sets of formulas closed under deduction. This is how I was taught it, and you get a sensible partial order with the right notion of equality. You can of course then talk about the theory generated by a set.</p>\n</blockquote>\n<p>Some version of this should happen. I worry firstly that defining theories could be mildly inconvenient. The perhaps bigger issue is the order.<br>\nIf we provide a <code>SetLike</code> instance, then <code>T ≤ T'</code> means that <code>T ⊆ T'</code>, or that <code>T'</code> implies <code>T</code>. This seems reasonable on the face of it, but some things feel a bit backward to me:</p>\n<ul>\n<li><code>⊤</code> is the inconsistent theory.</li>\n<li>There is a natural boolean algebra structure (which I desperately want to implement) on formulas, where <code>⊤</code> is true and <code>⊥</code> is false. The map from <code>φ</code> to the theory generated by <code>{φ}</code> then becomes antimonotone.</li>\n</ul>",
        "id": 504952429,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1741726112
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110044\">Chris Hughes</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Model.20Theory.3A.20BoundedFormula.2C.20Formula.20and.20Sentence/near/504636379\">said</a>:</p>\n<blockquote>\n<p>I agree that formulas modulo equivalence is a good idea. My only concern is about properties that aren't preserved under equivalence, like being quantifier free, but I don't think this is much of an issue as it's rare to need to distinguish between quantifier free and equivalent to a quantifier free formula.</p>\n</blockquote>\n<p>I think that equivalent to a quantifier-free formula is really what we want. For this, I think we define quantifier complexity first on <code>BoundedFormula</code>s, as is currently done, in the way that is easiest to compute with. Then we define sublattices of the boolean algebra of formulas mod <code>T</code> for different complexity levels - equivalent to quantifier-free, equivalent to universal, equivalent to existential, etc.</p>",
        "id": 504955039,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1741726892
    },
    {
        "content": "<p>Then <code>φ</code> is in the lattice, say, of quantifier-free formulas mod <code>T</code> if and only if embeddings of models of <code>T</code> preserve <code>φ</code> in both directions.</p>",
        "id": 504955323,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1741726976
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"302826\">Aaron Anderson</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Model.20Theory.3A.20BoundedFormula.2C.20Formula.20and.20Sentence/near/504952429\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110044\">Chris Hughes</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Model.20Theory.3A.20BoundedFormula.2C.20Formula.20and.20Sentence/near/504636379\">said</a>:</p>\n<blockquote>\n<p>The last thing I would change is that I think Theories should be sets of formulas closed under deduction. This is how I was taught it, and you get a sensible partial order with the right notion of equality. You can of course then talk about the theory generated by a set.</p>\n</blockquote>\n<p>Some version of this should happen. I worry firstly that defining theories could be mildly inconvenient. The perhaps bigger issue is the order.<br>\nIf we provide a <code>SetLike</code> instance, then <code>T ≤ T'</code> means that <code>T ⊆ T'</code>, or that <code>T'</code> implies <code>T</code>. This seems reasonable on the face of it, but some things feel a bit backward to me:</p>\n<ul>\n<li><code>⊤</code> is the inconsistent theory.</li>\n<li>There is a natural boolean algebra structure (which I desperately want to implement) on formulas, where <code>⊤</code> is true and <code>⊥</code> is false. The map from <code>φ</code> to the theory generated by <code>{φ}</code> then becomes antimonotone.</li>\n</ul>\n</blockquote>\n<p>I agree about the order. A Theory is a bit like a filter, and we have the backwards order on filters, so that could work on theories as well</p>",
        "id": 504955474,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1741727022
    },
    {
        "content": "<p>You're totally right - the order on Theories should absolutely match Filters, and should match that API.</p>",
        "id": 504956134,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1741727235
    },
    {
        "content": "<p>the order is also \"backwards\" on topologies if you believe that a topology <em>is</em> a collection of open sets (as opposed to this being an implementation detail), and T1 &lt;= T2 means that the identity function from (X,T1) to (X,T2) is continuous.</p>",
        "id": 504958371,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1741727947
    },
    {
        "content": "<p>If you imagined a topology to be \"equal\" to the collection of sets which aren't open then the order wouldn't be \"backwards\".</p>",
        "id": 504958480,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1741727986
    },
    {
        "content": "<p>If you imagine a filter on a type just to be some abstract category-theoretic completion of the category of subsets of the type (there is such a way of describing it but I forgot the details, it is something like the pro-category?) then again you don't come away with the impression that \"the order is backwards\" because with this implementation you think of a filter as being a generalized subset.</p>",
        "id": 504959208,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1741728205
    },
    {
        "content": "<p>With filters, you also have this complement isomorphism with sets closed under subset, finite union and empty set. And then the order would be correct.</p>",
        "id": 504960351,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1741728552
    },
    {
        "content": "<p>So you can think about the Finite Cofilter instead of the Cofinite Filter</p>",
        "id": 504960396,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1741728574
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110044\">Chris Hughes</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Model.20Theory.3A.20BoundedFormula.2C.20Formula.20and.20Sentence/near/504960351\">said</a>:</p>\n<blockquote>\n<p>With filters, you also have this complement isomorphism with sets closed under subset, finite union and empty set. And then the order would be correct.</p>\n</blockquote>\n<p>So... order ideals?</p>",
        "id": 504960763,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741728681
    },
    {
        "content": "<p>Yes, after looking up the definition of order ideal, it seems so</p>",
        "id": 504961149,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1741728807
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110044\">Chris Hughes</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Model.20Theory.3A.20BoundedFormula.2C.20Formula.20and.20Sentence/near/504955474\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"302826\">Aaron Anderson</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Model.20Theory.3A.20BoundedFormula.2C.20Formula.20and.20Sentence/near/504952429\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110044\">Chris Hughes</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Model.20Theory.3A.20BoundedFormula.2C.20Formula.20and.20Sentence/near/504636379\">said</a>:</p>\n<blockquote>\n<p>The last thing I would change is that I think Theories should be sets of formulas closed under deduction. This is how I was taught it, and you get a sensible partial order with the right notion of equality. You can of course then talk about the theory generated by a set.</p>\n</blockquote>\n<p>Some version of this should happen. I worry firstly that defining theories could be mildly inconvenient. The perhaps bigger issue is the order.<br>\nIf we provide a <code>SetLike</code> instance, then <code>T ≤ T'</code> means that <code>T ⊆ T'</code>, or that <code>T'</code> implies <code>T</code>. This seems reasonable on the face of it, but some things feel a bit backward to me:</p>\n<ul>\n<li><code>⊤</code> is the inconsistent theory.</li>\n<li>There is a natural boolean algebra structure (which I desperately want to implement) on formulas, where <code>⊤</code> is true and <code>⊥</code> is false. The map from <code>φ</code> to the theory generated by <code>{φ}</code> then becomes antimonotone.</li>\n</ul>\n</blockquote>\n<p>I agree about the order. A Theory is a bit like a filter, and we have the backwards order on filters, so that could work on theories as well</p>\n</blockquote>\n<p>I think it would be best to pick the order which makes the <a href=\"https://en.wikipedia.org/wiki/Galois_connection#Syntax_and_semantics\">syntax-semantics adjunction for first-order logic</a> a galois connection, without inserting OrderDual a bunch of times</p>",
        "id": 504961728,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1741728985
    },
    {
        "content": "<p>If one argues like that then you might want to deduce \"I think it would be best to pick the order which makes Galois theory a Galois connection, given that this is what it's named after, without inserting OrderDual a bunch of times\", and then you would necessarily have to choose a very odd-looking order on either subgroups of a group or subfields of a field :-(</p>",
        "id": 504962445,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1741729226
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110044\">Chris Hughes</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Model.20Theory.3A.20BoundedFormula.2C.20Formula.20and.20Sentence/near/504960351\">said</a>:</p>\n<blockquote>\n<p>With filters, you also have this complement isomorphism with sets closed under subset, finite union and empty set. And then the order would be correct.</p>\n</blockquote>\n<p>Rather annoyingly, I don't think this is correct. You have to take \"sets not in the filter\" rather than \"sets whose complement is in the filter\". That's why I said \"sets which are not open\" rather than \"closed sets\" in the topology example. If you have loads of open sets, then you have hardly any non-open sets, but you also have loads of closed sets.</p>",
        "id": 504962631,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1741729300
    },
    {
        "content": "<p>If you take subsets not in the filter then its not closed under finite union :(</p>",
        "id": 504962796,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741729349
    },
    {
        "content": "<p>Yeah, there is that. I think that <code>`T₁ ≤ T₂ → T₁ ⊨ φ → T₂ ⊨ φ</code> might be the thing you end up needing the most.</p>",
        "id": 504962806,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1741729355
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Model.20Theory.3A.20BoundedFormula.2C.20Formula.20and.20Sentence/near/504962631\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110044\">Chris Hughes</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Model.20Theory.3A.20BoundedFormula.2C.20Formula.20and.20Sentence/near/504960351\">said</a>:</p>\n<blockquote>\n<p>With filters, you also have this complement isomorphism with sets closed under subset, finite union and empty set. And then the order would be correct.</p>\n</blockquote>\n<p>Rather annoyingly, I don't think this is correct. You have to take \"sets not in the filter\" rather than \"sets whose complement is in the filter\". That's why I said \"sets which are not open\" rather than \"closed sets\" in the topology example. If you have loads of open sets, then you have hardly any non-open sets, but you also have loads of closed sets.</p>\n</blockquote>\n<p>I should have said image under complement I think</p>",
        "id": 504962878,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1741729385
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Model.20Theory.3A.20BoundedFormula.2C.20Formula.20and.20Sentence/near/504962796\">said</a>:</p>\n<blockquote>\n<p>If you take subsets not in the filter then its not closed under finite union</p>\n</blockquote>\n<p>Yes, \"subsets not in the filter\" stinks as a mathematical property, it's just an artificial way of giving a definition which is mathematically equivalent to a filter and for which the ordering we have in mathlib is not \"backwards\", so it's really just an indication that this whole concept of whether an ordering is \"backwards\" is not really well-defined.</p>",
        "id": 504962980,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1741729420
    },
    {
        "content": "<p>It doesn't stink that hard if you say subsets in the order ideal instead. I don't know that it's that artificial</p>",
        "id": 504963161,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1741729482
    },
    {
        "content": "<p>Yes, but the order on ideals is still backwards</p>",
        "id": 504963238,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1741729509
    },
    {
        "content": "<p>I'm arguing that this concept of \"backwards\" only comes from having a map from <code>Filter X</code> or <code>Theory X</code> to some other type which you are convinced has a natural ordering (e.g. <code>Set (Set X))</code> in the filter case), and this map might be \"the standard implementation of the concept\" but what I'm arguing is that there may be other implementations.</p>",
        "id": 504963586,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1741729624
    },
    {
        "content": "<p>I was thinking about this recently. There's this fact about polynomials which says that they \"go to +-infinity\"at +-infinity, which in terms of filters and Tendsto would be <code>Filter.Tendsto f.eval Filter.Cobounded Filter.Cobounded</code>. But on this particular filter it feels more natural to say the preimage of any bounded set is bounded.</p>",
        "id": 504963733,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1741729681
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Model.20Theory.3A.20BoundedFormula.2C.20Formula.20and.20Sentence/near/504963238\">said</a>:</p>\n<blockquote>\n<p>Yes, but the order on ideals is still backwards</p>\n</blockquote>\n<p>If you implement topologies as closed sets rather than open sets, then it's still true that T1 &lt;= T2 iff T1 has <em>more</em> closed sets than T2, even though closed sets are the opposite of open sets. The more open sets you have, the more closed sets you have. Similarly if you implement a filter as the sets whose complement is in the filter (i.e. the ideal) then you still have F1 &lt;= F2 iff F1 has more sets in it than F2.</p>",
        "id": 504964060,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1741729783
    },
    {
        "content": "<p>Oh, yes, you're right</p>",
        "id": 504964185,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1741729813
    },
    {
        "content": "<p>If you implement the order on ideals sanely (such that <code>s ⊆ t ↔ principal s ≤ principal t</code>) then we have <code>principal s ≤ i ↔ s ∈ i</code>, so I think the order is very much not backwards.</p>",
        "id": 504964523,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741729940
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Model.20Theory.3A.20BoundedFormula.2C.20Formula.20and.20Sentence/near/504963586\">said</a>:</p>\n<blockquote>\n<p>I'm arguing that this concept of \"backwards\" only comes from having a map from <code>Filter X</code> or <code>Theory X</code> to some other type which you are convinced has a natural ordering (e.g. <code>Set (Set X))</code> in the filter case), and this map might be \"the standard implementation of the concept\" but what I'm arguing is that there may be other implementations.</p>\n</blockquote>\n<p>You're right that neither order is really \"forwards\" or \"backwards\" - one could order theories based on having more or fewer axioms, or one could order theories based on having more or fewer models. The question is just which of these dual orders is more mathlib-appropriate, and I'm convinced now it should be the latter. (One could also view closed-under-deduction theories as the closed sets in a type space, in which case they also get this ordering.)</p>",
        "id": 504964696,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1741730010
    },
    {
        "content": "<p>In geometry there is this fundamental construction which goes from commutative rings to spaces; if I speak vaguely then this can apply to all kinds of geometric objects, but the construction is that given a space, you consider the ring of all functions on the space, and conversely given a ring, you consider the prime or maximal ideals of the ring (which choice you make depends on which century you're in and also which kind of geometric objects you're considering). These are adjoint functors between \"algebra\" and \"geometry\" but in this example I've always felt that you simply cannot get away from the fact that it's contravariant. Given a map of spaces X -&gt; Y, then for a function on X you can't push it forwards to a function on Y (because it might take different values at different element of X which map to the same element of Y) but given a function on Y you can always pull it back to a function on X, so you get a map Ring(Y) -&gt; Ring(X). This is an example of a beautiful adjunction for which it really is impossible to remove the ^ops. I don't know if the syntax/semantics duality has the same properties though.</p>",
        "id": 504968937,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1741731383
    }
]