[
    {
        "content": "<p>I got stuck while proving some lemmas about <code>MonotoneOn</code>. Here is the <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> :</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Function</span>\n<span class=\"kd\">universe</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">PartialOrder</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">t0</span> <span class=\"o\">[</span><span class=\"n\">SemilatticeSup</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf_mono</span> <span class=\"o\">:</span> <span class=\"n\">Monotone</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf_anti</span> <span class=\"o\">:</span> <span class=\"n\">Antitone</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">t1</span> <span class=\"o\">[</span><span class=\"n\">Preorder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">SemilatticeSup</span> <span class=\"n\">s</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf_mono</span> <span class=\"o\">:</span> <span class=\"n\">MonotoneOn</span> <span class=\"n\">f</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf_anti</span> <span class=\"o\">:</span> <span class=\"n\">AntitoneOn</span> <span class=\"n\">f</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">x</span> <span class=\"n\">hx</span> <span class=\"n\">y</span> <span class=\"n\">hy</span>\n  <span class=\"k\">let</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"n\">Set.restrict</span> <span class=\"n\">s</span> <span class=\"n\">f</span>\n  <span class=\"k\">have</span> <span class=\"n\">hg_mono</span> <span class=\"o\">:</span> <span class=\"n\">Monotone</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"k\">have</span> <span class=\"n\">hg_anti</span> <span class=\"o\">:</span> <span class=\"n\">Antitone</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">exact</span> <span class=\"n\">t0</span> <span class=\"n\">g</span> <span class=\"n\">hg_mono</span> <span class=\"n\">hg_anti</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">hy</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>The last line throws an error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">application</span> <span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"n\">t0</span> <span class=\"n\">g</span> <span class=\"n\">hg_mono</span>\n<span class=\"n\">argument</span>\n  <span class=\"n\">hg_mono</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"bp\">@</span><span class=\"n\">Monotone</span> <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"n\">β</span> <span class=\"o\">(</span><span class=\"n\">Subtype.preorder</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"n\">PartialOrder.toPreorder</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"bp\">@</span><span class=\"n\">Monotone</span> <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"n\">β</span> <span class=\"n\">PartialOrder.toPreorder</span> <span class=\"n\">PartialOrder.toPreorder</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n</code></pre></div>\n<p>What should I do?</p>",
        "id": 391310611,
        "sender_full_name": "Wen Yang",
        "timestamp": 1694831393
    },
    {
        "content": "<p><code> [Preorder α] (s : Set α) [SemilatticeSup s]</code> doesn't really make sense, you are putting an order structure on alpha and then a different one on the elements of alpha that happen to be in <code>s</code> so the notitions of <code>&lt;</code> need not be related in any way. What statement are you trying to express with that line?</p>",
        "id": 391311257,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1694831674
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"127136\">@Alex J. Best</span> I want <code>s</code> to inherit a preorder from <code>α</code>, and then I assume that <code>s</code> is a join-semilattice.</p>",
        "id": 391312127,
        "sender_full_name": "Wen Yang",
        "timestamp": 1694832121
    },
    {
        "content": "<p>You'll probably need to state the existence of sups within <code>s</code> manually then. I'm not sure if we have any sort of unbundled Sup closedness for sets inside a preorder</p>",
        "id": 391314326,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1694833176
    },
    {
        "content": "<p>I just found this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- Porting note:</span>\n<span class=\"c1\">-- If we decide we want `Elem` to semireducible rather than reducible, we will need:</span>\n<span class=\"c1\">--   instance : Preorder (↑s) := Subtype.instPreorderSubtype _</span>\n<span class=\"c1\">-- here, along with appropriate lemmas.</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">monotoneOn_iff_monotone</span>\n</code></pre></div>\n<p>Maybe I could learn from it.</p>",
        "id": 391315889,
        "sender_full_name": "Wen Yang",
        "timestamp": 1694833889
    },
    {
        "content": "<p><del>This works for me:</del></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Preorder</span> <span class=\"n\">s</span> <span class=\"n\">where</span>\n  <span class=\"n\">le</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">x.val</span> <span class=\"bp\">≤</span> <span class=\"n\">y.val</span>\n  <span class=\"n\">lt</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">x.val</span> <span class=\"bp\">&lt;</span> <span class=\"n\">y.val</span>\n  <span class=\"n\">le_refl</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">Eq.ge</span> <span class=\"n\">rfl</span>\n  <span class=\"n\">le_trans</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span> <span class=\"o\">:=</span> <span class=\"n\">le_trans</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span>\n  <span class=\"n\">lt_iff_le_not_le</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">lt_iff_le_not_le</span>\n</code></pre></div>\n<p>Wrong. It doesn't work.<br>\nBut why not have such <code>instance</code> globally for every <code>Preorder α</code> and every <code>s : Set α</code>?</p>",
        "id": 391323781,
        "sender_full_name": "Wen Yang",
        "timestamp": 1694837781
    },
    {
        "content": "<p>I added <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SupClosed#doc\">docs#SupClosed</a> recently,<br>\nI can give you an instance for subtypes from it.</p>",
        "id": 391334147,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1694843663
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> Do we always have to <code>instance</code> manually? I think it would be convenient if there were some uniform and easy way to inherit the preorder from <code>α</code>.</p>",
        "id": 391341313,
        "sender_full_name": "Wen Yang",
        "timestamp": 1694848027
    },
    {
        "content": "<p>The instance you have above is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Subtype.preorder#doc\">docs#Subtype.preorder</a></p>",
        "id": 391342957,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694849120
    },
    {
        "content": "<p><del>Hmm, that doesn't exist. <a href=\"https://leanprover-community.github.io/mathlib_docs/find/subtype.preorder\">docs3#subtype.preorder</a></del></p>",
        "id": 391343068,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694849176
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> . Now I use <code>Subtype s</code> instead of <code>s</code>. However, another strange thing happened:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Function</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Order.Lattice</span>\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"c1\">-- theorem t0 {α : Type u} [Preorder α] [SemilatticeSup α] -- the first case</span>\n<span class=\"c1\">-- (kernel) declaration has metavariables 't0.hf'</span>\n<span class=\"c1\">-- application type mismatch</span>\n<span class=\"c1\">--   Monotone.forall_le_of_antitone ?m.228 hf_anti</span>\n<span class=\"c1\">-- argument</span>\n<span class=\"c1\">--   hf_anti</span>\n<span class=\"c1\">-- has type</span>\n<span class=\"c1\">--   @Antitone α β inst✝² PartialOrder.toPreorder f : Prop</span>\n<span class=\"c1\">-- but is expected to have type</span>\n<span class=\"c1\">--   @Antitone α β PartialOrder.toPreorder PartialOrder.toPreorder f : Prop</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">t0</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">SemilatticeSup</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"c1\">-- the second case</span>\n<span class=\"c1\">-- application type mismatch</span>\n<span class=\"c1\">--   t0 g hg_mono</span>\n<span class=\"c1\">-- argument</span>\n<span class=\"c1\">--   hg_mono</span>\n<span class=\"c1\">-- has type</span>\n<span class=\"c1\">--   @Monotone (Subtype s) β (Subtype.preorder s) PartialOrder.toPreorder g : Prop</span>\n<span class=\"c1\">-- but is expected to have type</span>\n<span class=\"c1\">--   @Monotone (Subtype s) β PartialOrder.toPreorder PartialOrder.toPreorder g : Prop</span>\n    <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">PartialOrder</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf_mono</span> <span class=\"o\">:</span> <span class=\"n\">Monotone</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf_anti</span> <span class=\"o\">:</span> <span class=\"n\">Antitone</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n  <span class=\"n\">le_antisymm</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"n\">y</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n    <span class=\"n\">hf</span> <span class=\"o\">:=</span> <span class=\"n\">Monotone.forall_le_of_antitone</span> <span class=\"n\">hf_mono</span> <span class=\"n\">hf_anti</span> <span class=\"o\">(</span><span class=\"n\">Eq.ge</span> <span class=\"n\">rfl</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">t1</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Preorder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n    <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">PartialOrder</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">SemilatticeSup</span> <span class=\"o\">(</span><span class=\"n\">Subtype</span> <span class=\"n\">s</span><span class=\"o\">)]</span>\n    <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf_mono</span> <span class=\"o\">:</span> <span class=\"n\">MonotoneOn</span> <span class=\"n\">f</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf_anti</span> <span class=\"o\">:</span> <span class=\"n\">AntitoneOn</span> <span class=\"n\">f</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">x</span> <span class=\"n\">hx</span> <span class=\"n\">y</span> <span class=\"n\">hy</span>\n  <span class=\"k\">let</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Subtype</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"n\">Set.restrict</span> <span class=\"n\">s</span> <span class=\"n\">f</span>\n  <span class=\"k\">have</span> <span class=\"n\">hg_mono</span> <span class=\"o\">:</span> <span class=\"n\">Monotone</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"k\">have</span> <span class=\"n\">hg_anti</span> <span class=\"o\">:</span> <span class=\"n\">Antitone</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">exact</span> <span class=\"n\">t0</span> <span class=\"n\">g</span> <span class=\"n\">hg_mono</span> <span class=\"n\">hg_anti</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">hy</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 391349460,
        "sender_full_name": "Wen Yang",
        "timestamp": 1694853411
    },
    {
        "content": "<p>You shouldn't be using <code>Subtype s</code></p>",
        "id": 391350029,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694853765
    },
    {
        "content": "<p>Well, but I think there is something here that goes against mathematical intuition.​</p>",
        "id": 391351029,
        "sender_full_name": "Wen Yang",
        "timestamp": 1694854442
    },
    {
        "content": "<p>Maybe I should try <code>IsPreorder</code> from <code>Mathlib/Init/Algebra/Classes.lean</code>.</p>",
        "id": 391351343,
        "sender_full_name": "Wen Yang",
        "timestamp": 1694854597
    },
    {
        "content": "<p>What are you trying to do, mathematically?</p>",
        "id": 391351402,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1694854640
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> Suppose <code>f</code> is increasing and decreasing. I want to show that <code>f</code> is a constant function under certain conditions. And I think a join-semilattice is sufficient.</p>",
        "id": 391351818,
        "sender_full_name": "Wen Yang",
        "timestamp": 1694854893
    },
    {
        "content": "<p>I don't see why you would need subtypes for that.</p>",
        "id": 391351904,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1694854941
    },
    {
        "content": "<p>I just think it's a natural idea to inherit the original structure to the subset.</p>",
        "id": 391352182,
        "sender_full_name": "Wen Yang",
        "timestamp": 1694855131
    },
    {
        "content": "<p>Here's a proof for directed orders:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Order.Directed</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Preorder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">PartialOrder</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsDirected</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">≤</span> <span class=\"bp\">·</span><span class=\"o\">)]</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Monotone.constant</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">Monotone</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf'</span> <span class=\"o\">:</span> <span class=\"n\">Antitone</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">hac</span><span class=\"o\">,</span> <span class=\"n\">hbc</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">exists_ge_ge</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n  <span class=\"n\">exact</span> <span class=\"n\">le_antisymm</span> <span class=\"o\">((</span><span class=\"n\">hf</span> <span class=\"n\">hac</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"bp\">$</span> <span class=\"n\">hf'</span> <span class=\"n\">hbc</span><span class=\"o\">)</span> <span class=\"o\">((</span><span class=\"n\">hf</span> <span class=\"n\">hbc</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"bp\">$</span> <span class=\"n\">hf'</span> <span class=\"n\">hac</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 391352373,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1694855240
    },
    {
        "content": "<p>And here's a version where you only assume monotonicity on a set:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">MonotoneOn.constant</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">MonotoneOn</span> <span class=\"n\">f</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf'</span> <span class=\"o\">:</span> <span class=\"n\">AntitoneOn</span> <span class=\"n\">f</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">DirectedOn</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">≤</span> <span class=\"bp\">·</span><span class=\"o\">)</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hb</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">hc</span><span class=\"o\">,</span> <span class=\"n\">hac</span><span class=\"o\">,</span> <span class=\"n\">hbc</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hs</span> <span class=\"n\">_</span> <span class=\"n\">ha</span> <span class=\"n\">_</span> <span class=\"n\">hb</span>\n  <span class=\"n\">exact</span> <span class=\"n\">le_antisymm</span> <span class=\"o\">((</span><span class=\"n\">hf</span> <span class=\"n\">ha</span> <span class=\"n\">hc</span> <span class=\"n\">hac</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"bp\">$</span> <span class=\"n\">hf'</span> <span class=\"n\">hb</span> <span class=\"n\">hc</span> <span class=\"n\">hbc</span><span class=\"o\">)</span> <span class=\"o\">((</span><span class=\"n\">hf</span> <span class=\"n\">hb</span> <span class=\"n\">hc</span> <span class=\"n\">hbc</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"bp\">$</span> <span class=\"n\">hf'</span> <span class=\"n\">ha</span> <span class=\"n\">hc</span> <span class=\"n\">hac</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 391352726,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1694855421
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"416034\">Wen Yang</span> <a href=\"#narrow/stream/287929-mathlib4/topic/mismatch.20.60Monotone.60.20after.20.60Set.2Erestrict.60/near/391352182\">said</a>:</p>\n<blockquote>\n<p>I just think it's a natural idea to inherit the original structure to the subset.</p>\n</blockquote>\n<p>It is not so natural because the lattice structure on your set might have little to do with the one on the original order. In comparison, directness can be stated directly.</p>",
        "id": 391352823,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1694855474
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> Thank you very much! I will add your lemmas to my PR.</p>",
        "id": 391353158,
        "sender_full_name": "Wen Yang",
        "timestamp": 1694855704
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"416034\">Wen Yang</span> has marked this topic as resolved.</p>",
        "id": 391353180,
        "sender_full_name": "Notification Bot",
        "timestamp": 1694855721
    }
]