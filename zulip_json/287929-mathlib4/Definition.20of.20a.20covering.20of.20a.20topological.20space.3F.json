[
    {
        "content": "<p>Do we currently have a unified definition of what it means for a family of sets in a topological space X to be a covering of X (or of a set in X)? </p>\n<p>There seem to be quite a few lemmas (e.g. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsCompact.elim_finite_subcover#doc\">docs#IsCompact.elim_finite_subcover</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=quasiSober_of_open_cover#doc\">docs#quasiSober_of_open_cover</a>, etc) whose names, and docstrings, refer to the notion of \"cover\", but whose formal statements spell out explicitly what \"cover\" means. Is this something we should add to mathlib? Or is there already a definition lurking somewhere in the axiomatic theory of covers and sieves under <code>Mathlib.CategoryTheory.Sites</code>?</p>\n<p>(This came up in reviewing <a href=\"https://github.com/leanprover-community/mathlib4/pull/21079\">#21079</a>, which adds further results about covers of topological spaces, which could be more slickly formulated if we had a standard definition of <code>cover</code>.)</p>",
        "id": 496724483,
        "sender_full_name": "David Loeffler",
        "timestamp": 1738227962
    },
    {
        "content": "<p>I think it is a good idea to abstract this notion into its own definition with some API around it. But I'm saying that without have tried anything in Lean.</p>",
        "id": 496771579,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1738242261
    },
    {
        "content": "<p>I mainly used an indexed family of <code>TopologicalSpace.Opens</code> with a proof that the <code>iSup</code> is top. e.g. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=isEmbedding_iff_of_iSup_eq_top#doc\">docs#isEmbedding_iff_of_iSup_eq_top</a><br>\nBut I agree we would definitely benefit from a unified API.</p>",
        "id": 496785882,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1738246254
    },
    {
        "content": "<p>Oddly enough we do have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=HasSeparatingCover#doc\">docs#HasSeparatingCover</a> and some API for that</p>",
        "id": 496870749,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1738272081
    },
    {
        "content": "<p>There’s a design question here: should a covering be an <em>indexed</em> family of opens, or just a <code>Set (Opens X)</code>? If we build the indexing into the definition then there are universe issues in trying to make sense of “the type of all open covers of X” - probably these issues can be dealt with but it would complicate the API.</p>",
        "id": 496945342,
        "sender_full_name": "David Loeffler",
        "timestamp": 1738309392
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span> is there a specific reason why you prefer to work with a separate index type?</p>",
        "id": 496945799,
        "sender_full_name": "David Loeffler",
        "timestamp": 1738309631
    },
    {
        "content": "<p>Indexed families are in general nicer to work with in my opinion: for example, writing down the pullback of an open cover by a continuous map in the « set of opens » version involves throwing existentials into the mix, which is not the case with the indexed approach.</p>",
        "id": 496985340,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1738322607
    },
    {
        "content": "<p>On top of that, if you naturally have a set of opens, you can just take the inclusion as the corresponding indexed family, while to go the other direction you again have to introduce pointless existentials</p>",
        "id": 496985585,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1738322691
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"268315\">Anatole Dedecker</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Definition.20of.20a.20covering.20of.20a.20topological.20space.3F/near/496985340\">said</a>:</p>\n<blockquote>\n<p>Indexed families are in general nicer to work with in my opinion: for example, writing down the pullback of an open cover by a continuous map in the « set of opens » version involves throwing existentials into the mix, which is not the case with the indexed approach.</p>\n</blockquote>\n<p>I don't understand; it looks to me as if defining the pullback of an open cover is about equally difficult (i.e. not absolutely immediate but not terribly difficult either) with the indexed and non-indexed approaches.</p>",
        "id": 496987079,
        "sender_full_name": "David Loeffler",
        "timestamp": 1738323217
    },
    {
        "content": "<p>Here's the \"set-like\" version:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- A collection of open sets whose union is `X`. -/</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">SOpenCover</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">carrier</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Opens</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">sSup_eq_top'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">⨆</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">carrier</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">⊤</span>\n\n<span class=\"sd\">/-- An open cover is a special kind of set of opens. -/</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SetLike</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SOpenCover</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Opens</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">⟨</span><span class=\"n\">SOpenCover</span><span class=\"bp\">.</span><span class=\"n\">carrier</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SOpenCover</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"bp\">.</span><span class=\"n\">injEq</span><span class=\"w\"> </span><span class=\"bp\">..</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mpr</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">SOpenCover</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SOpenCover</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">iSup_eq_top</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">⨆</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">⊤</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"bp\">.</span><span class=\"n\">sSup_eq_top'</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">iSup_set_eq_univ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">⋃</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">univ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">SetLike</span><span class=\"bp\">.</span><span class=\"n\">coe_set_eq</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"bp\">.</span><span class=\"n\">iSup_eq_top</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">comap</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SOpenCover</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">SOpenCover</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">⟨</span><span class=\"n\">Opens</span><span class=\"bp\">.</span><span class=\"n\">comap</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">''</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">preimage_iUnion</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">iSup_set_eq_univ</span><span class=\"o\">]</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">SOpenCover</span>\n</code></pre></div>\n<p>and here's the \"indexed\" version:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- An indexed family of open sets whose union is `X`. -/</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">IOpenCover</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Opens</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">iSup_eq_top'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">iSup</span><span class=\"w\"> </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">⊤</span>\n\n<span class=\"sd\">/-- An open cover is a special kind of function into  opens. -/</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FunLike</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">IOpenCover</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Opens</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">⟨</span><span class=\"n\">IOpenCover</span><span class=\"bp\">.</span><span class=\"n\">toFun</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">IOpenCover</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"bp\">.</span><span class=\"n\">injEq</span><span class=\"w\"> </span><span class=\"bp\">..</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mpr</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">IOpenCover</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IOpenCover</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">iSup_eq_top</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">⨆</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">⊤</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"bp\">.</span><span class=\"n\">iSup_eq_top'</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">iSup_set_eq_univ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">⋃</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">univ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">SetLike</span><span class=\"bp\">.</span><span class=\"n\">coe_set_eq</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"bp\">.</span><span class=\"n\">iSup_eq_top</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">comap</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IOpenCover</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">IOpenCover</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">⟨</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">Opens</span><span class=\"bp\">.</span><span class=\"n\">comap</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">preimage_iUnion</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">iSup_set_eq_univ</span><span class=\"o\">]</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">IOpenCover</span>\n</code></pre></div>\n<p>Where are the \"pointless existentials\"?</p>",
        "id": 496988125,
        "sender_full_name": "David Loeffler",
        "timestamp": 1738323618
    },
    {
        "content": "<p>I'm guessing at the point of turning one into the other</p>",
        "id": 496992688,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1738325214
    },
    {
        "content": "<p>I think Anatole is referring to the existential in <code>Opens.comap f '' U</code>?</p>",
        "id": 496993282,
        "sender_full_name": "Christian Merten",
        "timestamp": 1738325407
    },
    {
        "content": "<p>The pointless existentials are hidden where you take the image of some set. This is of course completely manageable, but when you need to break everything down it does introduce some annoying <code>rcases</code>.</p>",
        "id": 496993318,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1738325418
    },
    {
        "content": "<p>Note also that in the first verson the simp call has to do the extra work of using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.biUnion_image#doc\">docs#Set.biUnion_image</a> (or something like that) to reindex the union</p>",
        "id": 496993471,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1738325467
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Definition.20of.20a.20covering.20of.20a.20topological.20space.3F/near/496992688\">said</a>:</p>\n<blockquote>\n<p>I'm guessing at the point of turning one into the other</p>\n</blockquote>\n<p>Trivial one-liner:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">SOpenCover</span><span class=\"bp\">.</span><span class=\"n\">ofIndexed</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Opens</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hU</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">iSup</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">⊤</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">SOpenCover</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">⟨</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">sSup_eq_iSup</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">hU</span><span class=\"bp\">⟩</span>\n</code></pre></div>",
        "id": 496994160,
        "sender_full_name": "David Loeffler",
        "timestamp": 1738325695
    },
    {
        "content": "<p>I really don't understand the enthusiasm here for indexed families here, to be honest. If someone can give an example of a natural argument which is substantially simpler using the <code>IOpenCover</code> definition than the <code>SOpenCover</code> then I'd be happy to be persuaded.</p>",
        "id": 496995952,
        "sender_full_name": "David Loeffler",
        "timestamp": 1738326291
    },
    {
        "content": "<p>Very concrete one: imagine that all of our API for open covers was made using sets of opens, and you wanted to prove that a compact space is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=TotallyBounded#doc\">docs#TotallyBounded</a> in the usual way (e.g not the current mathlib proof using ultrafilters). Since you want to get a finite set of <em>points</em> of your space, it's really natural to consider all the coverings as indexed by your space. With your version, one would first need to consider the set of all balls, then extract a finite subset of balls, and then do the extra step of finding back a center of that ball.</p>",
        "id": 496997417,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1738326769
    },
    {
        "content": "<p>I'm not saying this is hard (it's really not), but it's an extra step.</p>",
        "id": 496997480,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1738326792
    },
    {
        "content": "<p>This does raise another point: I think all of our things that look like coverings are indexed in the current state of Mathlib. E.g <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsCompact.elim_finite_subcover#doc\">docs#IsCompact.elim_finite_subcover</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LocallyFinite#doc\">docs#LocallyFinite</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=BumpCovering#doc\">docs#BumpCovering</a> (this one is for functions but still)</p>",
        "id": 496998301,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1738327051
    },
    {
        "content": "<p>Ok I guess <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=quasiSober_of_open_cover#doc\">docs#quasiSober_of_open_cover</a> is your counterexample</p>",
        "id": 496998478,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1738327104
    },
    {
        "content": "<p>I've made a PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/21442\">#21442</a> which adds a def <code>IsOpenCover</code> (a predicate on indexed families of opens in a topological space), and refactors a few lemmas in other files to use this. I'd be interested in feedback as to whether this is a reasonable approach.</p>",
        "id": 498716825,
        "sender_full_name": "David Loeffler",
        "timestamp": 1739181820
    },
    {
        "content": "<p>Looks nice!<br>\nIm not sure if we still want the <code>iSup_eq_top</code> lemmas though.</p>",
        "id": 498750647,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1739191312
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Definition.20of.20a.20covering.20of.20a.20topological.20space.3F/near/498750647\">said</a>:</p>\n<blockquote>\n<p>Looks nice!<br>\nIm not sure if we still want the <code>iSup_eq_top</code> lemmas though.</p>\n</blockquote>\n<p>Sure, I was just waiting to see if there was a consensus in favour of the change before removing the old lemmas. I've pushed a commit deprecating them to the PR (awaiting CI to tell me what breaks downstream).</p>",
        "id": 498752767,
        "sender_full_name": "David Loeffler",
        "timestamp": 1739191910
    },
    {
        "content": "<p>I just noticed the initial question. </p>\n<p>There are two types of coverings that are useful in general topology: open coverings, and locally finite closed coverings. For examples, these two kind of coverings allow to prove that a function is continuous by proving that the restrictions to the covering sets are continuous.</p>\n<p>They have a common generalization: take a family <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><msub><mi>V</mi><mi>i</mi></msub><msub><mo stretchy=\"false\">)</mo><mrow><mi>i</mi><mo>∈</mo><mi>I</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">(V_i)_{i\\in I}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">∈</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">I</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1774em;\"><span></span></span></span></span></span></span></span></span></span> of locally closed subsets of a topological space <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span>, and say it covers <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> if for every point <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">x\\in X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span>, there exists a finite subset <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>I</mi><mi>x</mi></msub></mrow><annotation encoding=\"application/x-tex\">I_x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">x</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">I</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span> such that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>∈</mo><msub><mi>V</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">x\\in V_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> for all <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo>∈</mo><msub><mi>I</mi><mi>x</mi></msub></mrow><annotation encoding=\"application/x-tex\">i\\in I_x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6986em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">x</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, and the union of the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>V</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">V_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo>∈</mo><msub><mi>I</mi><mi>x</mi></msub></mrow><annotation encoding=\"application/x-tex\">i\\in I_x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6986em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">x</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, is a neighborhood of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span> in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span>. (This could be called the Grothendieck topology of locally closed subsets.)</p>",
        "id": 502789843,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1740864492
    }
]