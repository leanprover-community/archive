[
    {
        "content": "<p>Thanks to incremental compile and the progress display bar, and simple manipulation of the code, one can identify quickly which lines in a file take most of the compile time. In one case I find this line<br>\n<a href=\"https://github.com/leanprover-community/mathlib4/blob/476f5f1808912a5922e3e3e756a0e44f55b9f1da/Mathlib/RingTheory/PowerSeries/Basic.lean#L666\">https://github.com/leanprover-community/mathlib4/blob/476f5f1808912a5922e3e3e756a0e44f55b9f1da/Mathlib/RingTheory/PowerSeries/Basic.lean#L666</a></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">convert</span><span class=\"w\"> </span><span class=\"n\">MvPowerSeries</span><span class=\"bp\">.</span><span class=\"n\">coeff_prod</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n</code></pre></div>\n<p>stopping the progress bar for 10 seconds. Is this believable? I didn't think <code>convert</code> would be a complex tactic.</p>",
        "id": 452549920,
        "sender_full_name": "Ralf Stephan",
        "timestamp": 1721388038
    },
    {
        "content": "<p>Is there (another) tool assigning percentage of compile time in a file to single lines?</p>",
        "id": 452550173,
        "sender_full_name": "Ralf Stephan",
        "timestamp": 1721388133
    },
    {
        "content": "<p>Lean has two built-in profilers: <a href=\"https://leanprover-community.github.io/extras/speedup.html\">this page</a> describes the \"old\" one, which gives line-based information. <code>trace.profiler</code> is the new one (which creates collapsible traces; I'm not sure if/where documentation for that one is).</p>",
        "id": 452551953,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1721388868
    },
    {
        "content": "<p>Wow, 10 seconds for a convert is really slow: that means something in the file needs to be fixed.</p>",
        "id": 452551985,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1721388884
    },
    {
        "content": "<p>10 seconds for a convert is absolutely normal, it means that, somewhere in the goal and somewhere in what you are trying to convert it to, there were two terms which (a) looked different (b) turned out to be equal by <code>rfl</code> and (c) to prove that they were equal by <code>rfl</code> involved unfolding and unfolding and unfolding until each term was <em>gigantic</em>. The take home is that <code>convert</code> should not be being used here and one wants instead to use <code>convert ... using ...</code> or other tactics which won't embark upon the massive unfold.</p>",
        "id": 452574883,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1721397181
    },
    {
        "content": "<p>Thanks. I'll try that. <span aria-label=\"working on it\" class=\"emoji emoji-1f6e0\" role=\"img\" title=\"working on it\">:working_on_it:</span></p>",
        "id": 452576317,
        "sender_full_name": "Ralf Stephan",
        "timestamp": 1721397511
    },
    {
        "content": "<p>In fact, if you write <code>set_option trace.profiler true in</code> before the theorem's docstring and then unfold the trace by clicking on or near the triangles, it turns out that the problem is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mf\">6.725668</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">❌</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Multiset</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"bp\">∏</span><span class=\"w\"> </span><span class=\"n\">x_1</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MvPowerSeries</span><span class=\"bp\">.</span><span class=\"n\">coeff</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Finsupp</span><span class=\"bp\">.</span><span class=\"n\">single</span><span class=\"w\"> </span><span class=\"o\">()</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">x_1</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x_1</span><span class=\"o\">))</span>\n<span class=\"w\">        </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">finsuppAntidiag</span>\n<span class=\"w\">            </span><span class=\"n\">d</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"bp\">=?=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Multiset</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"bp\">∏</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MvPowerSeries</span><span class=\"bp\">.</span><span class=\"n\">coeff</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">))</span>\n<span class=\"w\">        </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">finsuppAntidiag</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Finsupp</span><span class=\"bp\">.</span><span class=\"n\">single</span><span class=\"w\"> </span><span class=\"o\">()</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"bp\">▶</span>\n</code></pre></div>\n<p>Lean takes 6.7 seconds on my computer to <em>fail</em> to prove that two things are equal by <code>rfl</code>. </p>\n<p>Changing line 666 to <code>erw [MvPowerSeries.coeff_prod]</code> makes the proof instant, because Lean does not get induced into doing a \"heavy <code>rfl</code>\", which is the phenomenon you're running into (a <code>rfl</code> which succeeds or fails but takes an age to do so because of an explosion in the size of terms). I'm on a train so don't fancy making a PR but please feel free to make one yourself!</p>",
        "id": 452577645,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1721397781
    },
    {
        "content": "<p>The reason that just a straight <code>rw</code> fails is that if you try</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MvPowerSeries</span><span class=\"bp\">.</span><span class=\"n\">coeff_prod</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">single</span><span class=\"w\"> </span><span class=\"o\">()</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>then you get the error</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  (MvPowerSeries.coeff R (single () d)) (∏ j ∈ s, f j)\n...\n⊢ (MvPowerSeries.coeff R (single () d)) (∏ j ∈ s, f j) = ...\n</code></pre></div>\n<p>which looks counterintuitive, but if you then start looking in the innards of what's going on, you find that the <code>MvPowerSeries.coeff</code> in the lemma you're trying to use is (when written out in full)</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>@DFunLike.coe (MvPowerSeries Unit R →ₗ[R] R) (MvPowerSeries Unit R) (fun x ↦ R) LinearMap.instFunLike\n  (MvPowerSeries.coeff R (single () d)) : MvPowerSeries Unit R → R\n</code></pre></div>\n<p>whereas the <code>MvPowerSeries.coeff</code> in the goal is</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>@DFunLike.coe (R⟦X⟧ →ₗ[R] R) R⟦X⟧ (fun x ↦ R) LinearMap.instFunLike (MvPowerSeries.coeff R (single () d)) : R⟦X⟧ → R\n</code></pre></div>\n<p>so there is some slight difference here, caused by the fact that</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">PowerSeries</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">MvPowerSeries</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"n\">R</span>\n</code></pre></div>\n<p>is not an <code>abbrev</code>. Perhaps this is the root cause of the issue. <code>erw</code> is a tactic which tries harder to unify, so sees through this non-reducible definition and works successfully.</p>",
        "id": 452579311,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1721398186
    },
    {
        "content": "<p>If you change line 54 of the file from a <code>def</code> to </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">PowerSeries</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">MvPowerSeries</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"n\">R</span>\n</code></pre></div>\n<p>then two proofs break because they have <code>rfl</code>s in them which aren't needed any more because the goal is already closed (so they can just be deleted), and you can change the bad <code>convert</code> line to just a plain old <code>rw</code> because now <code>rw</code> can see through the problem which was making it break before when the definition of <code>PowerSeries</code> was more irreducible. I would regard this as a good change. It would be interesting to see what else breaks in mathlib after this change -- you can do this by making the change I suggest on a branch, fixing the <code>rfl</code> errors in that same file, and then pushing the branch to github and  opening a WIP PR and seeing what CI thinks of it. Once you've got mathlib compiling again (a green tick in CI), you can type <code>!bench</code> in your PR and you'll get a profile of how much faster or slower mathlib is compiling. Sorry I am not able to do this myself, I have ropey internet for the next hour or so.</p>",
        "id": 452581980,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1721398806
    },
    {
        "content": "<p>I would think we would want <code>MvPowerSeries</code> API to apply directly to the single variable case</p>",
        "id": 452582027,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1721398819
    },
    {
        "content": "<p>That's your way of saying \"I agree that <code>abbrev</code> is worth pursuing\" right?</p>",
        "id": 452582212,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1721398865
    },
    {
        "content": "<p>But it depends on if we spend tons of time searching for things applying to <code>\\sigma := Unit</code></p>",
        "id": 452582713,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1721399005
    },
    {
        "content": "<p>So the benchmarking is going to be interesting because you're saying that right now we don't know which way it will go.</p>",
        "id": 452582894,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1721399054
    },
    {
        "content": "<p>Then it should be a structure probably</p>",
        "id": 452582942,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1721399070
    },
    {
        "content": "<p>Yeah, depends on the performance impact on the field</p>",
        "id": 452583064,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1721399117
    },
    {
        "content": "<p>The first variant with <code>erw</code> is <a href=\"https://github.com/leanprover-community/mathlib4/pull/14910\">#14910</a>. Since, with <code>abbrev</code>, the fixes in <code>RingTheory/LaurentSeries.lean</code> will require me some time to get a grip on the subject, you may either help at <a href=\"https://github.com/leanprover-community/mathlib4/pull/14913\">#14913</a>, or merge <a href=\"https://github.com/leanprover-community/mathlib4/pull/14910\">#14910</a>. I may be half a math, but I'm definitely no polymath.</p>",
        "id": 452587220,
        "sender_full_name": "Ralf Stephan",
        "timestamp": 1721400250
    },
    {
        "content": "<p>This exposes a rather nasty diamond</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Polynomial</span>\n\n<span class=\"kd\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])</span>\n\n<span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RatFunc</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LaurentSeries</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">with_unfolding_all</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"c1\">-- fails</span>\n</code></pre></div>",
        "id": 452600793,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1721403659
    },
    {
        "content": "<p>Fails on current master</p>",
        "id": 452601387,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1721403865
    },
    {
        "content": "<p>I think the problem comes from <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RatFunc.coeAlgHom#doc\">docs#RatFunc.coeAlgHom</a></p>",
        "id": 452606115,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1721404975
    },
    {
        "content": "<p>Let me see if I can do something</p>",
        "id": 452606169,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1721404985
    },
    {
        "content": "<p>Well, thinking more about it I don't think we can make it defeq: on the RHS everything is clear, the coercion is defined coefficientwise. But on the LHS something nontrivial is happening, a polynomial is viewed as a rational function (and this is trivial), but then to prove that a rational function \"is\" a power series one has to prove something.</p>",
        "id": 452610133,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1721405685
    },
    {
        "content": "<p>Maybe <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RatFunc.coe_coe#doc\">docs#RatFunc.coe_coe</a> should be <code>simp</code>?</p>",
        "id": 452610473,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1721405750
    },
    {
        "content": "<p>Unless we decide that the coercion from polynomials to power series is \"going through <code>RatFunc</code>\"</p>",
        "id": 452611255,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1721405880
    },
    {
        "content": "<p>Can we define a morphism out of the fraction ring that has good defeq properties wrt the base ring? If we can then it should be fixable. But I have to go now</p>",
        "id": 452615054,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1721406687
    },
    {
        "content": "<p>TIL: <code>irreducible_def</code> involves an <code>opaque</code></p>",
        "id": 452618254,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1721407778
    },
    {
        "content": "<p>Currently I don't think they're defeq in any sense</p>",
        "id": 452621662,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1721408808
    },
    {
        "content": "<p>Certainly, most weakenings of <code>Field</code> to something less restrictive will not just prevent <code>DefEq</code> but even <code>PropEq</code>.</p>",
        "id": 452621860,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1721408874
    },
    {
        "content": "<p><code>RatFunc F</code> does not contain <code>F</code> if <code>F</code> has non-zero nilpotent elements, right?</p>",
        "id": 452622085,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1721408931
    },
    {
        "content": "<p>I am just trying to get it to unfold until really break</p>",
        "id": 452622353,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1721409003
    },
    {
        "content": "<p>No defeq + coercions makes this really fiddly</p>",
        "id": 452624385,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1721409626
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 452624506,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1721409663
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- The coercion `RatFunc F → LaurentSeries F` as bundled alg hom. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">coeAlgHom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RatFunc</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">→ₐ</span><span class=\"o\">[</span><span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]]</span><span class=\"w\"> </span><span class=\"n\">LaurentSeries</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">liftAlgHom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">ofId</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span>\n<span class=\"w\">    </span><span class=\"n\">nonZeroDivisors_le_comap_nonZeroDivisors_of_injective</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span>\n<span class=\"w\">      </span><span class=\"n\">Polynomial</span><span class=\"bp\">.</span><span class=\"n\">algebraMap_hahnSeries_injective</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">coeAlgHom</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">ofId</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">LaurentSeries</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"c1\">--fails</span>\n</code></pre></div>\n<p>This seems already a problem</p>",
        "id": 452624586,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1721409691
    },
    {
        "content": "<p>Some of that is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RatFunc.liftOn#doc\">docs#RatFunc.liftOn</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RatFunc.mk#doc\">docs#RatFunc.mk</a> both use <code>irreducible_def</code>'s</p>",
        "id": 452624937,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1721409796
    },
    {
        "content": "<p>When I debug <code>convert</code> lines, I usually do <code>convert ... using 0</code> and increment <code>0</code> a step at a time until something bad happens.</p>\n<p>Then there are also configuration options you can use with <code>convert (config := { ... }) ... using ...</code>; <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Tactic/CongrExclamation.html#Congr!.Config\">here's the documentation</a></p>\n<p>For example, you can do <code>(config := { closePost := false })</code> to make it not try to apply <code>rfl</code> when closing sub-goals once nothing else applies. You can also do <code>with_reducible convert ...</code> to make it apply <code>rfl</code> only at reducible transparency. It already tries <code>rfl</code> before descending into a term at reducible transparency (controlled by <code>closePre</code> and <code>preTransparency</code>).</p>",
        "id": 452625315,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1721409920
    },
    {
        "content": "<p>Something benchmark-able is queued up for bot</p>",
        "id": 452627396,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1721410668
    },
    {
        "content": "<p>I don't understand how the <code>abbrev</code> alters the instance ordering.</p>",
        "id": 452627587,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1721410759
    },
    {
        "content": "<p>Benchmarking seems <a href=\"http://speed.lean-fro.org/mathlib4/compare/ce145c44-6443-408e-9a0f-b8ce5724f554/to/aedb5498-6c6f-4f20-8386-6f04110a2697\">happy</a></p>",
        "id": 452638777,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1721414137
    },
    {
        "content": "<p>Which branch are you talking about?</p>",
        "id": 452662758,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1721421064
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/14913\">#14913</a></p>",
        "id": 452662991,
        "sender_full_name": "Ralf Stephan",
        "timestamp": 1721421176
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306577\">Matthew Ballard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/compiling.20behaviour.20within.20one.20file/near/452600793\">said</a>:</p>\n<blockquote>\n<p>This exposes a rather nasty diamond</p>\n</blockquote>\n<p>By chance, I found something about it in an interview with <span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> :</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">With</span><span class=\"w\"> </span><span class=\"n\">rational</span><span class=\"w\"> </span><span class=\"n\">functions</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">find</span><span class=\"w\"> </span><span class=\"n\">it</span><span class=\"w\"> </span><span class=\"n\">particularly</span><span class=\"w\"> </span><span class=\"n\">interesting</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">because</span><span class=\"w\"> </span><span class=\"n\">we</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">diamond</span><span class=\"bp\">.</span>\n<span class=\"n\">From</span><span class=\"w\"> </span><span class=\"n\">polynomials</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">you</span><span class=\"w\"> </span><span class=\"n\">can</span><span class=\"w\"> </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">rational</span><span class=\"w\"> </span><span class=\"n\">functions</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">and</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">Laurent</span><span class=\"w\"> </span><span class=\"n\">series</span><span class=\"bp\">.</span>\n<span class=\"n\">Or</span><span class=\"w\"> </span><span class=\"n\">you</span><span class=\"w\"> </span><span class=\"n\">can</span><span class=\"w\"> </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"k\">from</span><span class=\"w\"> </span><span class=\"n\">polynomials</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">power</span><span class=\"w\"> </span><span class=\"n\">series</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">and</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">Laurent</span><span class=\"w\"> </span><span class=\"n\">series</span><span class=\"bp\">.</span>\n</code></pre></div>\n<p><a href=\"https://leanprover-community.github.io/blog/posts/backstage-with-pechersky/\">https://leanprover-community.github.io/blog/posts/backstage-with-pechersky/</a></p>",
        "id": 453346371,
        "sender_full_name": "Ralf Stephan",
        "timestamp": 1721720035
    }
]