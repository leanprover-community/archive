[
    {
        "content": "<p>I want to detect all places across mathlib where a certain type (<code>ENat</code>) is defeq-abused, which for this purpose we can define as \"a defeq check which would've failed had <code>ENat</code> been <code>@[irreducible]</code>\". However, I don't want this to block later uses which depend it, so I want the check to succeed, just log it somewhere.<br>\nWhat would be a good way to do this?</p>",
        "id": 482865506,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1731852893
    },
    {
        "content": "<p>Just make it irreducible in a PR and then fix CI by writing <code>unseal PNat in</code> in front of every declaration that fails?</p>",
        "id": 482867454,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1731854490
    },
    {
        "content": "<p>That'll likely take many iterations, could that be automated somehow?</p>",
        "id": 482867613,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1731854621
    },
    {
        "content": "<p>As you might imagine, I would suggest a linter: you make the linter re-elaborate every declaration prefixing it with <code>attribute [irreducible] ENat</code> (untested, I'm not sure this would work), and report failures using a <code>try ... catch</code> for instance.</p>",
        "id": 482868519,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1731855317
    },
    {
        "content": "<p>This is slightly tricky, since re-elaborating will have to happen changing the name of the declaration and I don't have a \"good\" solution to this, just approximate hacks.</p>",
        "id": 482868605,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1731855363
    },
    {
        "content": "<p>Do you happen to have an example linter re-elaborating all declarations I could adapt?</p>",
        "id": 482871349,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1731857328
    },
    {
        "content": "<p>Not at a computer now, but an easy way is to re-elaborate the syntax inside a <code>withScope</code> adding an extra namespace.  Not all build failures will be what you want, but most of them should!</p>",
        "id": 482875332,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1731860353
    },
    {
        "content": "<p>I have no idea how to write a linter - which mathlib linter would be best as a model for this?</p>",
        "id": 482885332,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1731868301
    },
    {
        "content": "<p>I'll be unable to help for a few hours, but will try once I'm back.  Otherwise, ping me again tomorrow and I'll do it then!  <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 482885645,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1731868548
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/17715\">#17715</a> does something similar for certain declarations (theorems and lemmas), but also does a bunch of other things, so you can ignore quite a bit of that linter.</p>",
        "id": 482885752,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1731868621
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/19177\">#19177</a> is a prototype, but I have done very few checks to make sure that it does, at least usually, the right checks!</p>",
        "id": 482912662,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1731892797
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 482918532,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1731897226
    },
    {
        "content": "<p>Hmm, making <code>ENat</code> an <code>@[irreducible]</code> isn't strong enough in some cases, for example here</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"kn\">local</span><span class=\"w\"> </span><span class=\"n\">irreducible</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">ENat</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"bp\">∞</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"bp\">∞</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">WithTop</span><span class=\"bp\">.</span><span class=\"n\">coe_lt_coe</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">lt_succ_self</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Is there a way to simulate it being opaque?</p>",
        "id": 482935977,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1731909584
    },
    {
        "content": "<p>That should be possible by directly modifying the <code>Environment</code>, right? Replacing the <code>defnInfo</code> with a <code>opaqueInfo</code>. How badly should I expect things to break, doing that?</p>",
        "id": 482940022,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1731911534
    },
    {
        "content": "<p>Hmm, even that doesn't help -- the problematic thing which gets unfolded here is one of <code>ENat</code>'s instances, not <code>ENat</code> itself</p>",
        "id": 482940912,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1731912008
    },
    {
        "content": "<p>I think that modifying the environment will be <em>much</em> harder.</p>",
        "id": 482958824,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1731918760
    },
    {
        "content": "<p>I tried doing that, it doesn't even help</p>",
        "id": 482958981,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1731918813
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"690858\">Daniel Weber</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Locating.20defeq.20abuse/near/482940912\">said</a>:</p>\n<blockquote>\n<p>Hmm, even that doesn't help -- the problematic thing which gets unfolded here is one of <code>ENat</code>'s instances, not <code>ENat</code> itself</p>\n</blockquote>\n<p>Making <code>ENat</code> opaque means that the expression obtained by unfolding something using it will be type incorrect, but the equality test can just ignore that</p>",
        "id": 482979968,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1731924850
    },
    {
        "content": "<p>I see there's <a href=\"https://github.com/leanprover/lean4/blob/7dc1ceb8d4312850b39cef9e751e0a3b651946e3/src/Lean/Meta/Basic.lean#L509\">recordUnfold</a>, is there a way to see it specifically?</p>",
        "id": 483856117,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1732262856
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 483856528,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1732263015
    },
    {
        "content": "<p>Using <code>set_option diagnostics true</code> works, I'll check if I can incorporate it to the linter</p>",
        "id": 483857114,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1732263260
    },
    {
        "content": "<p>I'm trying to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.withOptions#doc\">docs#Lean.withOptions</a> to do the <code>elabCommand</code> with the appropriate options, but I'm getting a <code>failed to synthesize  MonadWithOptions CommandElabM</code> error message. What is the correct way to do this?</p>",
        "id": 483923650,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1732285942
    },
    {
        "content": "<p>You can probably just add this instance locally. Many sensible instances are not declared because core hasn't needed them yet.</p>",
        "id": 483925052,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1732286417
    },
    {
        "content": "<p>You can also <code>elabCommand $ &lt;- `(command| set_option diagnostics true)</code>, now that I think about it.</p>",
        "id": 483925821,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1732286689
    },
    {
        "content": "<p>I think I found how I can do this, it can just be modified in <code>withScope</code></p>",
        "id": 483927089,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1732287121
    },
    {
        "content": "<p>Btw, I do not know if you were already planning to do this, but feel free to push directly to the PR!  I tried to put a single entry-point for the declaration to inspect, so that, if this turns out to be useful, a similar diagnostic could be run on other declaration.  Other than that, I don't think that I had any other specific design constraints.</p>",
        "id": 483929793,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1732287884
    },
    {
        "content": "<p>I made <a href=\"https://github.com/leanprover-community/mathlib4/pull/19372\">#19372</a>. I can merge it to the PR, I think</p>",
        "id": 483930017,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1732287946
    },
    {
        "content": "<p>It's ok, whatever is more convenient!</p>",
        "id": 483930722,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1732288157
    },
    {
        "content": "<p>In <a href=\"https://github.com/leanprover-community/mathlib4/blob/bcfe9ac8ef66da2223bd327a912e8a9b2634e434/Mathlib/Tactic/Linter/FindDefEqAbuse.lean#L85-L90\">https://github.com/leanprover-community/mathlib4/blob/bcfe9ac8ef66da2223bd327a912e8a9b2634e434/Mathlib/Tactic/Linter/FindDefEqAbuse.lean#L85-L90</a> I'm trying to figure out if the definition is data or a proof, but it's misfiring on <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=multiplicity#doc\">docs#multiplicity</a>, thinking it's a proof. What could be the cause of that? Is there a better approach to take? I don't think it can be figured out just from the syntax, as I want it to work for <code>instance</code> which can be both a <code>Prop</code> and a <code>Type _</code></p>",
        "id": 483952193,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1732294669
    },
    {
        "content": "<p>There's a function for this: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.isProof#doc\">docs#Lean.Meta.isProof</a></p>",
        "id": 483956932,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1732296221
    },
    {
        "content": "<p>I think it can't find the name in the environment in the linter, but I'm not sure why</p>",
        "id": 484032405,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1732337871
    },
    {
        "content": "<p>I'm having trouble understanding what's going on here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">diagnostics</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">diagnostics</span><span class=\"bp\">.</span><span class=\"n\">threshold</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"bp\">∞</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hn</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">cast_lt</span><span class=\"bp\">.</span><span class=\"n\">mpr</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">lt_add_one</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans_le</span><span class=\"w\"> </span><span class=\"n\">hn</span>\n</code></pre></div>\n<p>why is <code>ENat</code> unfolded 114 times? I assume it happens during typeclass inference, but I don't see what could cause it to be unfolded - I thought typeclass inference only unfolds instances and <code>abbrev</code>s?</p>",
        "id": 484040590,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1732346247
    }
]