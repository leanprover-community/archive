[
    {
        "content": "<p><code>lemma foo {R}...</code> and <code>lemma foo {R : Type*} ...</code> produce the same code (I think). Do we have a preferred spelling? In mathlib the latter is surely more common, but the former al appear.</p>",
        "id": 482224606,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1731518878
    },
    {
        "content": "<p>Does the former have a universe metavariable?</p>",
        "id": 482224771,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1731518923
    },
    {
        "content": "<p>I was also going to ask if the former was rather <code>R : Type _</code>.</p>",
        "id": 482224830,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1731518944
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306577\">Matthew Ballard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60lemma.20foo.20.7BR.7D.60.20or.20.60lemma.20foo.20.7BR.20.3A.20Type*.7D.60/near/482224771\">said</a>:</p>\n<blockquote>\n<p>Does the former have a universe metavariable?</p>\n</blockquote>\n<p>I mean something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 482224971,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1731518998
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60lemma.20foo.20.7BR.7D.60.20or.20.60lemma.20foo.20.7BR.20.3A.20Type*.7D.60/near/482224830\">said</a>:</p>\n<blockquote>\n<p>I was also going to ask if the former was rather <code>R : Type _</code>.</p>\n</blockquote>\n<p>Ah, this is interesting and seems a good reason to prefer <code>{R : Type*}</code></p>",
        "id": 482225083,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1731519020
    },
    {
        "content": "<p>You can verify this quite easily with </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universe</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ULift</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 482225157,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1731519041
    },
    {
        "content": "<p>Note that you get <code>R : Type u</code> in the infovew</p>",
        "id": 482225207,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1731519055
    },
    {
        "content": "<p>And using <code>R : Type*</code> results in a universe error.</p>",
        "id": 482225260,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1731519070
    },
    {
        "content": "<p>I think most people use <code>{R}</code> to mean <code>{R : Type*}</code>, this is why it's maybe better to use <code>Type*</code> explicitly (of course in most cases it doesn't matter)</p>",
        "id": 482225591,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1731519177
    },
    {
        "content": "<p>This is made murkier by the fact that <code>variable (R : Type*) ... variable {R}</code> does mean the same, but just updates the binder info.</p>",
        "id": 482225751,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1731519234
    },
    {
        "content": "<p>But inside a statement, this is definitely not a binder update and really generating a new variable.</p>",
        "id": 482225882,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1731519274
    },
    {
        "content": "<p>Just to be clear, </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hR</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">37</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">trivial</span>\n</code></pre></div>\n<p>results in <code>{R : ℕ}</code>. I thought the rule was \"whatever it takes to make it typecheck\".</p>",
        "id": 482226710,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1731519562
    },
    {
        "content": "<p>oh wow</p>",
        "id": 482226929,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1731519629
    },
    {
        "content": "<p>I think the rule is rather \"write the types of all your assumptions explicitly unless it would be a maintenance burden to do so\", where the exception includes lemmas like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RingHom.coe_mk#doc\">docs#RingHom.coe_mk</a></p>",
        "id": 482227109,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1731519701
    },
    {
        "content": "<p>I think it should be \"don't have a metavariable left over.\" Of the examples here only Ricardo's does since the level is free in the statement.</p>",
        "id": 482238136,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1731523590
    },
    {
        "content": "<p>So I guess my question is whether do we want a policy about this is not.</p>",
        "id": 482258077,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1731530812
    },
    {
        "content": "<p>We have <code>Type*</code> in mathlib to solve this \"<code>{R}</code> might have a type that's more specialized than you think\" problem.</p>\n<p>For <span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span>'s example, you want to use <code>Type u</code> instead of <code>Type*</code> because you have a universe level variable already.</p>\n<p>The reason <code>{R}</code> appears like <code>R : Type u_1</code> in the infoview is that for theorems there's a step where the universe level metavariables become fresh level parameters right before entering the theorem body. It turns out you can't see this universe level metavariable no matter where you click, but you can infer this happens in examples like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">β</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>where you can see in the infoview that <code>α β : Sort u_1</code> (they have the same type). Using <code>{α β : Type*}</code> instead alerts you to to the fact alpha and beta are in their own universe levels.</p>",
        "id": 482259993,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1731531553
    },
    {
        "content": "<p>I now understand what happens, I mean if we want to forbid <code>{R}</code> in mathlib or we are happy with it.</p>",
        "id": 482260158,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1731531604
    },
    {
        "content": "<p>I'm suggesting that we should prefer <code>Type*</code> if <code>R</code> is a type since we added <code>Type*</code> to avoid problems that <code>Type _</code> has.</p>",
        "id": 482261066,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1731531942
    },
    {
        "content": "<p>However, if we know <code>R</code> doesn't need to be universe polymorphic, and it's constrained by the rest of the lemma, I don't see any harm in <code>{R}</code>.</p>",
        "id": 482261257,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1731531999
    },
    {
        "content": "<p>Can you lint against this easily?</p>",
        "id": 482261351,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1731532041
    },
    {
        "content": "<p>An example of what I mean in that last comment are things like <code>example {p} [Decidable p] ...</code> where <code>p</code> must be a <code>Prop</code></p>",
        "id": 482261448,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1731532076
    },
    {
        "content": "<p>But there's a fine line between intentionally constrained and unintentionally constrained (we've accidentally had declarations before that were inadvertently specialized to Prop before!) so maybe this isn't worth having an exception over.</p>",
        "id": 482261619,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1731532140
    },
    {
        "content": "<p>I'm pretty strongly against banning <code>{R}</code> variables, and use them heavily (these are not uncorrelated <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span> )</p>",
        "id": 482396309,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1731592307
    },
    {
        "content": "<p>The reason is because inferring the type can in many cases be the <em>most</em> maintainable option, because it is more adaptive to changes. Obviously this can be overdone, but type variables are usually uninteresting to track</p>",
        "id": 482396643,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1731592390
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60lemma.20foo.20.7BR.7D.60.20or.20.60lemma.20foo.20.7BR.20.3A.20Type*.7D.60/near/482227109\">said</a>:</p>\n<blockquote>\n<p>I think the rule is rather \"write the types of all your assumptions explicitly unless it would be a maintenance burden to do so\", where the exception includes lemmas like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RingHom.coe_mk#doc\">docs#RingHom.coe_mk</a></p>\n</blockquote>\n<p>I am very much in favor of this rule, and also that the return type of definitions should (almost) always be given.<br>\nNot specifying the types of types is not terrible, but it's pretty nice if you can read from the source code whether something is intended to be a <code>Type _</code> or a <code>Sort _</code>.</p>",
        "id": 482397997,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1731592769
    },
    {
        "content": "<p>We still have some <code>Type _</code> and <code>Sort _</code> in mathlib btw, see eg <a href=\"https://github.com/leanprover-community/mathlib4/pull/19029\">#19029</a></p>",
        "id": 482398451,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1731592870
    },
    {
        "content": "<p>Reading <code>Sort _</code> from the source code tells you nothing <span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span>, since the <code>_</code> can be inferred as <code>(u + 1)</code> aka <code>Type u</code>!</p>",
        "id": 482402493,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1731593895
    },
    {
        "content": "<p>True. Replace what I said with <code>Type*</code>/<code>Sort*</code>.</p>",
        "id": 482413193,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1731596628
    }
]