[
    {
        "content": "<p>It may be useful to post some code I used today. In a large refactor, I renamed <code>Finsupp.total</code> to <code>Finsupp.linearCombination</code>. The main pain point was to rename all lemmas whose named contained <code>total</code>. The meta-code I used to find them is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Command</span><span class=\"w\"> </span><span class=\"n\">Meta</span>\n\n<span class=\"c1\">-- Generalized monad for `Lean.Name.isBlackListed`</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Name</span><span class=\"bp\">.</span><span class=\"n\">isBlackListed'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MonadEnv</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">declName</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">declName</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"ss\">``sorryAx</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">declName</span><span class=\"w\"> </span><span class=\"n\">matches</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">str</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"s2\">\"inj\"</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">declName</span><span class=\"w\"> </span><span class=\"n\">matches</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">str</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"s2\">\"noConfusionType\"</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">env</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getEnv</span>\n<span class=\"w\">  </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"w\"> </span><span class=\"n\">declName</span><span class=\"bp\">.</span><span class=\"n\">isInternalDetail</span>\n<span class=\"w\">   </span><span class=\"bp\">||</span><span class=\"w\"> </span><span class=\"n\">isAuxRecursor</span><span class=\"w\"> </span><span class=\"n\">env</span><span class=\"w\"> </span><span class=\"n\">declName</span>\n<span class=\"w\">   </span><span class=\"bp\">||</span><span class=\"w\"> </span><span class=\"n\">isNoConfusion</span><span class=\"w\"> </span><span class=\"n\">env</span><span class=\"w\"> </span><span class=\"n\">declName</span>\n<span class=\"w\">  </span><span class=\"bp\">&lt;||&gt;</span><span class=\"w\"> </span><span class=\"n\">isRec</span><span class=\"w\"> </span><span class=\"n\">declName</span><span class=\"w\"> </span><span class=\"bp\">&lt;||&gt;</span><span class=\"w\"> </span><span class=\"n\">isMatcher</span><span class=\"w\"> </span><span class=\"n\">declName</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">FindUnused</span>\n\n<span class=\"sd\">/-- Remove all blacklisted names from the given environment.</span>\n<span class=\"sd\">This might not be accurate since the blacklist function is a heuristic. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">filterNames</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MonadEnv</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">env</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HashMap</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">HashMap</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">env'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">env</span>\n<span class=\"w\">  </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">env</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">isBlackListed'</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"n\">env'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">env'</span><span class=\"bp\">.</span><span class=\"n\">erase</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">env'</span>\n\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"#lemmas\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">env</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">filterNames</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getEnv</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">constants</span><span class=\"bp\">.</span><span class=\"n\">map₁</span>\n<span class=\"w\">    </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">env</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"ss\">`Finsupp.linearCombination</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">type</span><span class=\"bp\">.</span><span class=\"n\">getUsedConstants</span><span class=\"w\"> </span><span class=\"bp\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">toString</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">findSubstr?</span><span class=\"w\"> </span><span class=\"s2\">\"total\"</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">isSome</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">        </span><span class=\"n\">dbg_trace</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"bp\">#</span><span class=\"n\">lemmas</span>\n</code></pre></div>\n<p>The two auxiliary functions were stolen from an old Zulip message by <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>. Then the lemmas command look at all declarations and print the names of the declarations whose type involve <code>Finsupp.linearCombination</code> and whose name includes <code>total</code>. Of course in the future we will have much better ways of doing this using <a href=\"https://github.com/leanprover-community/mathlib4/pull/13973\">#13973</a>, but I thought the above trick can already be useful to other people.</p>",
        "id": 466126315,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1724972958
    },
    {
        "content": "<p>Note I’m defining a command because I always forget how to simply run code in <code>CommandElabM</code> without defining a command.</p>",
        "id": 466126442,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1724973027
    },
    {
        "content": "<p><code>run_cmd</code>?</p>",
        "id": 466129164,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1724974601
    }
]