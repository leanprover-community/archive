[
    {
        "content": "<p>Why are <a href=\"https://github.com/leanprover-community/mathlib4/blob/ae91682d714ec14c07b645dc8434123b078cb762/Mathlib/Algebra/Polynomial/Basic.lean#L58-L65\"><code>Polynomial</code></a> and <a href=\"https://github.com/leanprover-community/mathlib4/blob/ae91682d714ec14c07b645dc8434123b078cb762/Mathlib/Algebra/Polynomial/Module/Basic.lean#L19-L39\"><code>PolynomialModule</code></a> two different definitions? </p>\n<p>In mathlib, they are respectively defined like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Polynomial</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Semiring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"n\">ofFinsupp</span><span class=\"w\"> </span><span class=\"bp\">::</span>\n<span class=\"w\">  </span><span class=\"n\">toFinsupp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AddMonoidAlgebra</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">PolynomialModule</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→₀</span><span class=\"w\"> </span><span class=\"n\">M</span>\n</code></pre></div>\n<p>If you unfold <code>AddMonoidAlgebra R ℕ</code> it is just <code>ℕ →₀ R</code>. These two definition look like they contain the same type of data but with different instances. Should these definitions be merged? And would a PR be welcomed?</p>\n<p>For context of why this came up, I'm working on Chapter 10 of MIL and want to show:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">LinearAlgebra</span><span class=\"bp\">.</span><span class=\"n\">Matrix</span><span class=\"bp\">.</span><span class=\"n\">Determinant</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">LinearAlgebra</span><span class=\"bp\">.</span><span class=\"n\">Eigenspace</span><span class=\"bp\">.</span><span class=\"n\">Minpoly</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">LinearAlgebra</span><span class=\"bp\">.</span><span class=\"n\">Charpoly</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Polynomial</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">LinearMap</span><span class=\"w\"> </span><span class=\"n\">End</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsCoprime</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">End</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">ker</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">aeval</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">⊔</span><span class=\"w\"> </span><span class=\"n\">ker</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">aeval</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">ker</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">aeval</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"bp\">*</span><span class=\"n\">Q</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Ideally I'd like to show that these are equivalent using the theorem <code>Polynomial.roots_mul</code> (i.e. the kernel of these expressions occur when the image of φ equals the roots of the polynomial when evaluated on the elements of the module; so showing the kernels are equal is equivalent to showing the roots of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo>∗</mo><mi>Q</mi></mrow><annotation encoding=\"application/x-tex\">P*Q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">Q</span></span></span></span> are equal to the roots <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span></span> unioned with the roots of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Q</mi></mrow><annotation encoding=\"application/x-tex\">Q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">Q</span></span></span></span>). But the regular <code>Polynomial K</code> definition cannot be evaluated on the elements of a module.</p>",
        "id": 538746256,
        "sender_full_name": "Luna",
        "timestamp": 1757543198
    },
    {
        "content": "<p>There's some ongoing work refactoring <code>AddMonoidAlgebra</code> by <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> , which I think aims to replace the first one with <code>Polynomial := AddMonoidAlgebra R ℕ</code> (which is also what it used to be defined as!)</p>",
        "id": 538747553,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1757544077
    },
    {
        "content": "<p>Indeed. The current blocker is <a href=\"https://github.com/leanprover-community/mathlib4/pull/29207\">#29207</a>, where I would like some help to debug an obscure error</p>",
        "id": 538773319,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1757567390
    },
    {
        "content": "<p>Update here: Progress is steady, but the current refactor (<a href=\"https://github.com/leanprover-community/mathlib4/pull/25273\">#25273</a>, making <code>MonoidAlgebra</code> a one-field structure) has got a long way to go, and the refactor you actually want (making <code>Polynomial</code> an <code>abbrev</code> for <code>AddMonoidAlgebra</code>) must wait on that.</p>",
        "id": 566200807,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1767506574
    },
    {
        "content": "<p>What happens if you make <code>Polynomial</code> an <code>abbrev</code> without making <code>AddMonoidAlgebra</code> a one-field structure?</p>",
        "id": 573701128,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1770975633
    },
    {
        "content": "<p>To answer one of the original questions, <code>Polynomial</code> and <code>PolynomialModule</code> should not be merged - If <code>R</code> acts on <code>M</code>,  we don't want an instance of <code>Polynomial R</code> acting on <code>Polynomial M</code>, because we would get two inequivalent actions when <code>M = Polynomial R</code>. We use the type synonym <code>PolynomialModule M</code> to get around that problem. The docstring on <code>PolynomialModule</code> gives some more details about the possible actions.</p>",
        "id": 573929542,
        "sender_full_name": "Scott Carnahan",
        "timestamp": 1771106866
    }
]