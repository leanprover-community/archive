[
    {
        "content": "<p>I started out trying to make <code>push_neg</code> be aware of <code>Finite</code> and <code>Infinite</code>, but figured out that the tactic should be made extensible with a tag. I have now implemented this tactic here: <a href=\"https://github.com/leanprover-community/mathlib4/pull/21769\">#21769</a>.</p>\n<p>As requested by <span class=\"user-mention\" data-user-id=\"387244\">@Ya√´l Dillies</span>, this, among others, tags the lemma <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.nonempty_iff_ne_empty#doc\">docs#Finset.nonempty_iff_ne_empty</a>.</p>\n<p>Given this tactic, it is really easy to extend it to work with any constant, not just <code>Not</code>. So I have generalized it, so that when you write <code>push C</code>, then it will rewrite any expression that has head constant <code>C</code>, using the lemmas tagged with <code>push</code>.</p>\n<p>The implementation is to use <code>simp</code> rewriting, and use a simproc for a few rewrites that can't be implemented with just a lemma (i.e. preserving variable names, folding <code>¬¨(a = b)</code> into <code>a ‚â† b</code>, and choosing which lemma to use at <code>¬¨(a ‚àß b)</code>). Unlike in <code>simp</code>, the rewrites are done before the subterms are rewritten. This is a more efficient approach when using <code>push</code> lemmas.</p>\n<p>Many proofs can be simplified with this new tactic.</p>",
        "id": 499492535,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1739458145
    },
    {
        "content": "<p>Thousands of lemmas could be tagged with <code>push</code>! If it's not too hard, can we also a version that pulls the constant as far out as possible? cf <code>push_cast</code> vs <code>norm_cast</code></p>",
        "id": 499492981,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1739458252
    },
    {
        "content": "<p>As a follow up, I think is would be nice to see more tactics making use of <code>push_neg</code> in the way that <code>contrapose!</code> and <code>by_contra!</code> do. When refactoring proofs, I kept running into the pattern of <code>by_cases h : p</code> followed by a <code>push_neg at h</code> in the second branch. Other candidates for a <code>!</code> version could be <code>wlog</code>, <code>absurd</code> and <code>split_ifs</code>.</p>",
        "id": 499493811,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1739458455
    },
    {
        "content": "<p>This would also allow one to write <code>by_cases h: ¬¨p</code>, in order to swap the order of the two cases, without adding too many <code>¬¨</code> to the goals</p>",
        "id": 499494156,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1739458551
    },
    {
        "content": "<p>You can also do</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">by_cases</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span>\n<span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">neg</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">pos</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n</code></pre></div>",
        "id": 499495296,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1739458809
    },
    {
        "content": "<p>Since this tactic requires special handling of <code>‚â†</code>, I thought it was also going to be necessary for <code>‚àâ</code>, but it turns out that <code>‚àâ</code> is just notation, and isn't its own constant. Wouldn't it be more convenient if the same held for <code>‚â†</code>? Then you could rewrite the underlying equality without having to first unfold the <code>Ne</code>.</p>",
        "id": 499495579,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1739458873
    },
    {
        "content": "<p>Maybe, but then you wouldn't get anything to dot notate on. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ne.symm#doc\">docs#Ne.symm</a>, the most important lemma to have dot notation for, doesn't have an analogue with <code>‚àâ</code></p>",
        "id": 499496592,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1739459134
    },
    {
        "content": "<p>Makes sense (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ne.symm#doc\">docs#Ne.symm</a>)</p>",
        "id": 499497650,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1739459384
    },
    {
        "content": "<p>I've also added an option for a discharger in the tactic, because lemmas about <code>log_mul</code> and <code>log_sqrt</code> have side goals. I haven't tested this yet, but it may be handy to define <code>push_log</code> as <code>push (disch := positivity) Real.log</code>.</p>",
        "id": 499501188,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1739460115
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> mentioned that <code>push_neg</code> takes extra care to preserve variable names. Which is something that other tactics sometimes mess up. How does <code>push</code> fare in this regard?</p>",
        "id": 499505667,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1739461027
    },
    {
        "content": "<p>(support for) preserving variable names in binders is coming in the next Lean release, right?</p>",
        "id": 499506014,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739461092
    },
    {
        "content": "<p>The lemmas about exists and forall aren't tagged by <code>@[push]</code>, but instead are rewritten in the simproc (using the same implementation as was originally there), So variable names are preserved.</p>",
        "id": 499506071,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1739461105
    },
    {
        "content": "<p>But if one were to add other <code>push</code> lemmas with binders, it wouldn't preserve the variable names (at least until the next release)</p>",
        "id": 499506812,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1739461258
    },
    {
        "content": "<p>Hmm, I could also add a <code>push_lambda</code> version of the tactic that can push things like <code>fun x =&gt; a x + b x</code> into <code>(fun x =&gt; a x) + (fun x =&gt; b x)</code>, if that is useful. And a <code>push_forall</code> for things like <code>‚àÄ a, p ‚Üí q a</code> into <code>p ‚Üí ‚àÄ a, q a</code>. (These need special casing because forall and lambda aren't constants)</p>",
        "id": 499509748,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1739461894
    },
    {
        "content": "<p>They need special casing in the implementation of the tactic. But it could still be <code>push lambda</code> from the user perspective, right?</p>",
        "id": 499518300,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1739463605
    },
    {
        "content": "<p>First of all, this is great! I have a bunch of simp attributes <code>push_neg</code>, <code>push_smul</code>, <code>push_exp</code>, .. and it was on my todo list to implement tactic like this. So thanks for doing this!</p>\n<hr>\n<p>An idea for possible extension:</p>\n<p>I also have attributes <code>pull_neg</code>, <code>pull_smul</code>, <code>pull_exp</code>, ... to do the reverse. Also for a theorem <code>f_linear : IsLinearMap ùïú f</code> I can call command <code>#generate_linear_map_simps f_linear</code> that automatically generates simp theorems for <code>f x + f y = f (x + y)</code> or <code>- f x = f (- x)</code> which can be used left to right by <code>simp [push_add, push_neg]</code> or right to left <code>simp [pull_add,pull_neg]</code>. The main point of doing this is that  the equality <code>f (- x) = - f x</code> is not a valid simp theorem as it has variable head. The command <code>#generate_linear_map_simps f_linear</code> allows you to quickly instantiate this theorems for concrete <code>f</code>.</p>\n<p>So <code>simp [pull_neg,pull_add]</code> is effectively <code>push</code> for all linear maps.</p>\n<hr>\n<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/channel/287929-mathlib4/topic/I.20made.20an.20extensible.20.60push.60.20tactic.20generalizing.20.60push_neg.60/near/499492535\">said</a>:</p>\n<blockquote>\n<p>Unlike in <code>simp</code>, the rewrites are done before the subterms are rewritten. This is a more efficient approach when using <code>push</code> lemmas.</p>\n</blockquote>\n<p>Is this true? Isn't this what pre/post  <code>simp ‚Üë</code>/<code>simp ‚Üì</code> is for? i.e. if you mark your theorems with <code>@[simp ‚Üì]</code> the theorem is applied <strong>before</strong> subterms are visited.</p>",
        "id": 499529149,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1739465861
    },
    {
        "content": "<p>Yes, but nobody seems to actually use pre lemmas in simp</p>",
        "id": 499529861,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1739466011
    },
    {
        "content": "<p>You can also call simp as <code>simp [‚Üìthm, ‚Üìattr,  ‚Üìsiproc]</code> to specifically say apply theorem/simp attribute/simproc as <em>pre</em>, so you do not have to mark theorems themselves. </p>\n<p>Sometimes I wonder how much speed up could be gained in mathlib by being more careful about pre/post for simp theorem. In my applications when transforming programs using simp this can make a big difference.</p>",
        "id": 499531016,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1739466280
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"346070\">Tomas Skrivan</span> <a href=\"#narrow/channel/287929-mathlib4/topic/I.20made.20an.20extensible.20.60push.60.20tactic.20generalizing.20.60push_neg.60/near/499529149\">said</a>:</p>\n<blockquote>\n<p>The main point of doing this is that the equality <code>f (- x) = - f x</code> is not a valid simp theorem as it has variable head.</p>\n</blockquote>\n<p>I don't follow, for <code>map_neg</code> the head is <code>DFunLike.coe</code>, for your example <code>f</code> is a constant name, right?</p>",
        "id": 499531421,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739466365
    },
    {
        "content": "<p>I'm not talking about <code>LinearMap</code> but about <code>IsLinearMap</code> i.e. you have a predicate on <code>f : X -&gt; Y</code>.</p>",
        "id": 499533153,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1739466797
    },
    {
        "content": "<p>Maybe this is non issue for mathlib as it mainly works with bundled linear maps but in SciLean I mostly work with unbundled maps.</p>",
        "id": 499533493,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1739466878
    },
    {
        "content": "<p>I think your <code>#generate_linear_map_simps</code> was confusing me, which surely only works for one particular <code>f</code>?</p>",
        "id": 499533814,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739466969
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/channel/287929-mathlib4/topic/I.20made.20an.20extensible.20.60push.60.20tactic.20generalizing.20.60push_neg.60/near/499529861\">said</a>:</p>\n<blockquote>\n<p>Yes, but nobody seems to actually use pre lemmas in simp</p>\n</blockquote>\n<p>I'm not understanding this \"yes but\". People might not be using the feature, but it's definitely there and has been there for a long time; saying \"unlike in simp\" is not correct. I think the issue is that people haven't had much guidance on pre-simp lemmas.</p>\n<p>By the way, I once looked into trying to make <code>push_neg</code> operate only on the \"spine\" of an expression by default. At least pedagogically, it's odd to me that it pushes negations everywhere, even deep within subexpressions. Is this something we would want to look into? Or are we all happy with the push-everything-pushable semantics?</p>",
        "id": 499533969,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739467014
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/287929-mathlib4/topic/I.20made.20an.20extensible.20.60push.60.20tactic.20generalizing.20.60push_neg.60/near/499533814\">said</a>:</p>\n<blockquote>\n<p>I think your <code>#generate_linear_map_simps</code> was confusing me, which surely only works for one particular <code>f</code>?</p>\n</blockquote>\n<p>Sorry I didn't explain that well. Yes you have to call <code>#generate_linear_map_simps</code> for every concrete <code>f</code>.</p>",
        "id": 499534182,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1739467078
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/287929-mathlib4/topic/I.20made.20an.20extensible.20.60push.60.20tactic.20generalizing.20.60push_neg.60/near/499533969\">said</a>:</p>\n<blockquote>\n<p>By the way, I once looked into trying to make <code>push_neg</code> operate only on the \"spine\" of an expression by default. At least pedagogically, it's odd to me that it pushes negations everywhere, even deep within subexpressions. Is this something we would want to look into? Or are we all happy with the push-everything-pushable semantics?</p>\n</blockquote>\n<p>I personally have not had the need for this feature.  However, if it were implemented, it could follow the <code>congr i</code> syntax, like <code>push_neg 7</code>?  Or did want more granular control as a <code>gcongr</code>/<code>congrm</code> pattern match?</p>",
        "id": 499534817,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1739467227
    },
    {
        "content": "<p>Ah, no, it wouldn't be for the depth, I don't think that would be particularly useful. Imagine that there's a negation in the hypothesis of an implication. Should <code>push_neg</code> affect that hypothesis too? In a workshop, some students found that behavior to be surprising.</p>\n<p>It's similar to <code>ring</code> vs <code>ring_nf</code>. The latter does ring normalization everywhere, but the former just applies to the target equality itself.</p>",
        "id": 499537985,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739468060
    },
    {
        "content": "<p>Oh, I see, I had not understood the use-case that you mention.  I agree that it could be confusing, but I also do not think that I came across the issue.</p>",
        "id": 499539824,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1739468554
    },
    {
        "content": "<p>Before looking into it, I expected that <code>push_neg</code> would only push the negation that started at the root of the expression. I think it is like this mostly because it is more tricky to implement, because you would have to keep track of which <code>Not</code> was \"pushed\" by the tactic, and which was there to begin with.</p>",
        "id": 499544785,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1739469877
    },
    {
        "content": "<p>Yeah, that's what I ran into in my investigations. It's too convenient using simp.</p>\n<p>By the way, something I've wanted to see is for <code>push_neg</code> to be a simple wrapper around <code>simp</code> itself. There should be a user-accessible simproc so that people can write <code>simp [‚ÜìpushNeg]</code> or at least a simp set so they can write <code>simp [pushNeg]</code>, where the simp set contains the simproc. This would be convenient because then other simp lemmas can be interleaved. It's much more composable than a separate tactic.</p>",
        "id": 499546569,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739470352
    },
    {
        "content": "<p>That's not to say that there shouldn't be a <code>push_neg</code>, just that a <code>pushNeg</code> simproc would give flexibility when it's wanted.</p>",
        "id": 499546880,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739470442
    },
    {
        "content": "<p>Thanks for making this! This implements one of the tactics on my <a href=\"https://github.com/leanprover-community/mathlib4/issues/10361\">wishlist</a> - hopefully you don't mind but I've linked your PR to that issue.</p>",
        "id": 499550830,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1739471518
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>, great idea, I've added the <code>pushNeg</code> <code>simproc_decl</code> now, which can be used with <code>simp [‚ÜìpushNeg]</code>.</p>",
        "id": 499558621,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1739473620
    },
    {
        "content": "<p>Again the main motivation for not using <code>simp</code> was keeping bound variable names.</p>",
        "id": 499594905,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1739484815
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> You mean the motivation for not implementing it as a simp set of simp lemmas, right? With a simproc, bound variable names is not an issue.</p>",
        "id": 499595243,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739484938
    },
    {
        "content": "<p>Yes</p>",
        "id": 499595286,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1739484956
    },
    {
        "content": "<p>I don‚Äôt know anything about <code>simproc</code></p>",
        "id": 499595363,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1739484970
    },
    {
        "content": "<p>Maybe you're thinking of the Lean 3 implementation of <code>push_neg</code> <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span>.</p>\n<p>When it got ported to Lean 4, Alice Laroche made use of the <code>simp</code> machinery to do the transformation. (With the consequence that the Lean 4 version does <code>push_neg</code> in places that the Lean 3 never did.)</p>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/blob/1a4b99a6a24399ca4e2201084601a1cbfee170b2/Mathlib/Tactic/PushNeg.lean#L137\">This function</a> has the signature of a simproc. In that last message, Jovan made the simproc be usable in a simp argument list.</p>",
        "id": 499596845,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739485525
    },
    {
        "content": "<p>Does it mean the Lean 4 version does not preserve variable names?</p>",
        "id": 499597032,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1739485593
    },
    {
        "content": "<p>That would be a very bad surprise that will hit me hard in a couple of weeks.</p>",
        "id": 499597085,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1739485615
    },
    {
        "content": "<p>No, that's the point, simp preserves variable names. It's <em>simp lemmas</em> that don't (yet) preserve variables names, because simp lemmas are applied using unification, and unification doesn't copy binder names.</p>",
        "id": 499597136,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739485630
    },
    {
        "content": "<p>A simproc is an arbitrary transformation that can hook into the simp machinery. It can preserve variable names if it wants to (and the pushNeg simproc does)</p>",
        "id": 499597210,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739485666
    },
    {
        "content": "<p>I‚Äôm asking about the current version of push_neg</p>",
        "id": 499597425,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1739485743
    },
    {
        "content": "<p>The current version of push_neg, which is implemented using simp since 2022, preserves binder names, as far as I know.</p>",
        "id": 499597514,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739485784
    },
    {
        "content": "<p>Ok, great</p>",
        "id": 499597670,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1739485840
    },
    {
        "content": "<p>(I was telling you about the current version of push_neg for what it's worth.)</p>",
        "id": 499597936,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739485948
    },
    {
        "content": "<p>It would be really nice to have an extensible <code>push_neg</code> in Mathlib! E.g., I often wanted it to support <code>Filter.Eventually</code>/<code>Filter.Frequently</code>.</p>",
        "id": 499632575,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1739505585
    },
    {
        "content": "<p>Thanks for the suggestion! In the PR, I have now tagged a bunch of lemmas with <code>push</code>:</p>\n<h1>push_neg</h1>\n<ul>\n<li><code>Filter.Eventually</code>/<code>Filter.Frequently</code></li>\n<li>(Set.)<code>Finite</code>/<code>Infinite</code></li>\n<li>(Set./Finset.)<code>Nonempty</code>/<code>_ = ‚àÖ</code>/<code>Empty</code></li>\n<li>\n<p><code>¬¨n &gt; 0</code> -&gt; <code>n = 0</code> instead of <code>n ‚â§ 0</code> when possible (e.g. in <code>Nat</code>) (and similar for <code>1</code>, <code>‚ä§</code>, <code>‚ä•</code>)<br>\n  This is because <code>n = 0</code> is generally nicer than <code>n ‚â§ 0</code>. For the reverse opposite statement, I think it's not clear which form is nicer to use: <code>0 &lt; n</code> or <code>n ‚â† 0</code>.</p>\n</li>\n<li>\n<p><code>x ‚àâ s·∂ú</code> -&gt; <code>x ‚àà s</code></p>\n</li>\n</ul>\n<h1>push</h1>\n<p>I've tagged relevant lemmas for a couple of constants:</p>\n<ul>\n<li><code>Real.log</code>, which can be used as <code>push (disch := positivity) Real.log</code></li>\n<li>Set membership: for example <code>push _ ‚àà _</code> rewrites <code>x ‚àà {a : p a}·∂ú</code> -&gt; <code>¬¨ p x</code></li>\n<li>Set complement</li>\n<li><code>-</code>, <code>‚Åª¬π</code>and <code>^</code>.</li>\n<li><code>And</code>, <code>Or</code>, <code>Exists</code>, <code>Forall</code></li>\n<li><code>fun</code>, for pushing through <code>+</code> <code>*</code> etc. (Note that these lemmas can't make use of the discrimination tree properly, unless we switch to my <code>RefinedDiscrTree</code>)</li>\n</ul>",
        "id": 500012391,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1739713786
    },
    {
        "content": "<p>It is a bit cumbersome to write out names like <code>HPow.hPow</code>, So I extended the notation so that you can provide a pattern, and the tactic will look at the head constant of the pattern. For example, <code>push ‚àÄ _, _</code>, <code>push fun _ ‚Ü¶ _</code>, <code>push _ ‚àà _</code>, <code>push _ ^ _</code>. And <code>push_neg</code> is equivalent to either <code>push Not</code> or <code>push ¬¨_</code></p>",
        "id": 500012640,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1739713994
    },
    {
        "content": "<p>The PR is getting really big, so should I split it into the following 3 parts?</p>\n<ul>\n<li>add the new implementation of the tactic, without tagging new lemmas</li>\n<li>add tags for many push_neg lemmas</li>\n<li>add tags for many push lemmas</li>\n</ul>",
        "id": 500012779,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1739714120
    },
    {
        "content": "<p>Here is the first part as a PR on its own: <a href=\"https://github.com/leanprover-community/mathlib4/pull/21965\">#21965</a></p>",
        "id": 500051227,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1739745462
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/channel/287929-mathlib4/topic/I.20made.20an.20extensible.20.60push.60.20tactic.20generalizing.20.60push_neg.60/near/500012640\">said</a>:</p>\n<blockquote>\n<p>It is a bit cumbersome to write out names like <code>HPow.hPow</code>, So I extended the notation so that you can provide a pattern, and the tactic will look at the head constant of the pattern. For example, <code>push ‚àÄ _, _</code>, <code>push fun _ ‚Ü¶ _</code>, <code>push _ ‚àà _</code>, <code>push _ ^ _</code>. And <code>push_neg</code> is equivalent to either <code>push Not</code> or <code>push ¬¨_</code></p>\n</blockquote>\n<p>This sounds useful! Do you need the underscores? Or could it be made to work with <code>push ‚àÄ</code> etc...?</p>",
        "id": 500183284,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1739798052
    },
    {
        "content": "<p>I could special case some notations like forall, but I don't know how to make that work with all notations.</p>",
        "id": 500251468,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1739815485
    },
    {
        "content": "<p>I think consistency would be nicer. This syntax is used in other places.</p>",
        "id": 500261739,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1739820451
    },
    {
        "content": "<p>I'd say let's not try to get token parsing to work ‚Äî it seems like a nightmare to me, if you were to try to make it use the general <code>term</code> syntax!</p>",
        "id": 500261925,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739820555
    },
    {
        "content": "<p>Here's an option though, to let people define tokens one-by-one from outside of <code>push</code> itself:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"n\">declare_syntax_cat</span><span class=\"w\"> </span><span class=\"n\">push_token</span>\n<span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"n\">ident</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">push_token</span>\n\n<span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"s2\">\"push\"</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ppSpace</span><span class=\"w\"> </span><span class=\"n\">push_token</span><span class=\"o\">)</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">tactic</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">Command</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"declare_push_token \"</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">str</span><span class=\"w\"> </span><span class=\"s2\">\" =&gt; \"</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">liftTermElabM</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">realizeGlobalConstNoOverloadWithInfo</span><span class=\"w\"> </span><span class=\"n\">id</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">id'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ident</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">mkIdentFrom</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">canonical</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">pushNegSyntaxName</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">mkIdent</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"bp\">.</span><span class=\"n\">mkSimple</span><span class=\"w\"> </span><span class=\"n\">s!</span><span class=\"s2\">\"pushNegToken_{s}\"</span>\n<span class=\"w\">  </span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">Command</span><span class=\"bp\">.</span><span class=\"n\">elabCommand</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span>\n<span class=\"w\">    </span><span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">pushNegSyntaxName</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">str</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">push_token</span>\n<span class=\"w\">    </span><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"w\">    </span><span class=\"kd\">@[</span><span class=\"n\">macro</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">pushNegSyntaxName</span><span class=\"kd\">]</span>\n<span class=\"w\">    </span><span class=\"n\">aux_def</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">pushNegSyntaxName</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Macro</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">push_token</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">id'</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">)</span>\n\n<span class=\"n\">declare_push_token</span><span class=\"w\"> </span><span class=\"s2\">\"¬¨\"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Not</span>\n</code></pre></div>",
        "id": 500263519,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739821389
    },
    {
        "content": "<p>Then it would be the responsibility of the <code>push</code> tactic to do macro expansion of its <code>push_token</code> until it gets an <code>ident</code>.</p>",
        "id": 500264045,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739821663
    },
    {
        "content": "<p>Just putting this idea out there. <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span>'s point about consistency with other syntaxes makes sense too. Writing <code>push _ ‚àà _</code> is clear, and <code>push ‚àà</code> doesn't look like anything else in Lean.</p>",
        "id": 500264513,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739821898
    },
    {
        "content": "<p>Though perhaps <code>push [‚àà]</code> isn't too out of place, if there are delimiters to contain the seemingly-invalid syntax.</p>",
        "id": 500264592,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739821935
    },
    {
        "content": "<p>Should I also make a PR that changes the name of the <code>PushNeg</code> file to <code>Push</code>, so that the diff in the other PR becomes more useable?</p>",
        "id": 500753093,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1740003244
    },
    {
        "content": "<p>Sure, why not? Would be easy to review!</p>",
        "id": 500757604,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1740005160
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/22108\">#22108</a></p>",
        "id": 500760491,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1740006528
    },
    {
        "content": "<p>I tried to use the <code>binderNameHint</code> gadget to remove the need for special handling of forall and exists in <code>push_neg</code>. However, I found it didn't work for the forall (<span class=\"user-mention\" data-user-id=\"470149\">@Joachim Breitner</span>).<br>\nMWE:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">not_forall_eq</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"bp\">¬¨</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚Üî</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">‚àÉ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">binderNameHint</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">¬¨</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">not_forall</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬¨</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">not_forall_eq</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- preserves binder name</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬¨</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">not_forall_eq</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- changes binder name to `x`</span>\n</code></pre></div>\n<p>I think this is a matter of the order of the arguments to <code>isDefEq</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Qq</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Qq</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Meta</span>\n\n<span class=\"n\">run_meta</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">mkFreshExprMVarQ</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">withoutModifyingMCtx</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">isDefEq</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">    </span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"c1\">-- fun y =&gt; y = 0</span>\n<span class=\"w\">  </span><span class=\"n\">withoutModifyingMCtx</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">isDefEq</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">c</span>\n<span class=\"w\">    </span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"c1\">-- fun x =&gt; x = 0</span>\n</code></pre></div>",
        "id": 510531213,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1743982899
    },
    {
        "content": "<p>Yes, indeed, forall is too special in Lean. With exits you can rewrite <code>Exists s</code> and preserve the lambda in <code>s</code>, but with forall, in <code>‚àÉ x, s x</code> the <code>s</code> is not a manifest lambda from the original goal, so while pattern  matching the rewrite lean will eta-expand or something something like that to produce it, and that's where we get the <code>fun x =&gt;</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">not_forall_eq</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"bp\">¬¨</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚Üî</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">‚àÉ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">binderNameHint</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">¬¨</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">not_forall</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬¨</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">not_forall_eq</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- preserves binder name</span>\n\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">true</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">error: unsolved goals</span>\n<span class=\"sd\">‚ä¢ ‚àÉ x, ¬¨x = 0</span>\n<span class=\"sd\">---</span>\n<span class=\"sd\">info: [Meta.Tactic.simp.unify] eq_self:1000, failed to unify</span>\n<span class=\"sd\">      ?a = ?a</span>\n<span class=\"sd\">    with</span>\n<span class=\"sd\">      n = 0</span>\n<span class=\"sd\">[Meta.Tactic.simp.rewrite] not_forall_eq:1000:</span>\n<span class=\"sd\">      ¬¨‚àÄ (n : Nat), n = 0</span>\n<span class=\"sd\">    ==&gt;</span>\n<span class=\"sd\">      ‚àÉ x, binderNameHint x (fun x =&gt; x = 0) ¬¨x = 0</span>\n<span class=\"sd\">[Meta.Tactic.simp.unify] eq_self:1000, failed to unify ?a = ?a with x = 0</span>\n<span class=\"sd\">-/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬¨</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">not_forall_eq</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- changes binder name to `x`</span>\n</code></pre></div>\n<p>Not sure if there is a good way to fix that.</p>",
        "id": 512138461,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1744652199
    },
    {
        "content": "<p>My PR (<a href=\"https://github.com/leanprover-community/mathlib4/pull/21965\">#21965</a>) has been updated, with a follow up <a href=\"https://github.com/leanprover-community/mathlib4/pull/29000\">#29000</a> that adds some basic tagging.</p>\n<p>Since this discussion, I have changed the syntax for <code>push</code>. As this came up during the review, I'd like to ask what people think about it.</p>\n<ul>\n<li>You can give the constant by name, e.g. <code>push Not</code> or <code>push log</code></li>\n<li>You can use <code>¬∑</code> notation to refer to a notation constant, e.g. <code>push ¬∑ ‚àà ¬∑</code>, <code>push ‚àë x, ¬∑</code>, <code>push fun y ‚Ü¶ ¬∑</code> or <code>push ‚àÄ z, ¬∑</code>.</li>\n</ul>\n<p>The <code>¬∑</code> notation is based on the way in which <code>simp</code> allows you to refer to a notation constant by writing <code>simp [¬∑ ‚àà ¬∑]</code> (but <code>simp</code> doesn't support this when there is a binder in the notation, I've added this). The question is whether the loose <code>¬∑</code> could be confusing, or if people like this notation.</p>",
        "id": 536499306,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1756330518
    },
    {
        "content": "<p>I'd prefer a syntax with parentheses e.g. <code>push (¬∑ ‚àà ¬∑)</code>, for uniformity with similar syntax.</p>",
        "id": 536516774,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1756344103
    },
    {
        "content": "<p>Have you checked that <code>(by push ¬∑ ‚àà ¬∑)</code> doesn't expand to <code>fun x1 x2 =&gt; by push x1 ‚àà x2</code>?</p>\n<p>The <code>simp</code> notation has this issue... You need to write <code>simp [(¬∑ ‚àà ¬∑)]</code> to avoid it.</p>",
        "id": 536516916,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1756344230
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>, good point. <code>(by push ¬∑ ‚àà ¬∑)</code> indeed does the wrong thing. And <code>push (¬∑ ‚àà ¬∑)</code> works as a workaround. </p>\n<p>Should we only allow the version with brackets?</p>",
        "id": 536595427,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1756384312
    },
    {
        "content": "<p>Either that or support <code>‚àë x, _</code> instead</p>",
        "id": 536596323,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1756384597
    },
    {
        "content": "<p>/poll What syntax should push use?<br>\npush (¬∑ ‚àà ¬∑), push (‚àë x, ¬∑)<br>\npush _ ‚àà _, push ‚àë x, _</p>",
        "id": 536597831,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1756385084
    },
    {
        "content": "<p>Ok, I have now switched back to the <code>_</code> notation. A significant difference with the original implementation is that the elaborator only acts at the syntax level,  instead of first elaborating into an <code>Expr</code>. This allows it to reject the term if it doesn't have underscores. For example, <code>push ‚àë x, 1</code> is now not accepted anymore.</p>",
        "id": 536629769,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1756394024
    }
]