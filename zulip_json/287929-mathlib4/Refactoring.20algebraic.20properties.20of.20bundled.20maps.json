[
    {
        "content": "<p>In <a href=\"https://github.com/leanprover-community/mathlib4/pull/33477\">#33477</a> I started a refactor of introducing type-classes for <code>FunLike</code> and algebraic operations that capture properties like <code>(f + g) x = f x + g x</code>. Reasons for having this are twofold: (a) there are a couple of lemmas that are duplicated with various types of functions, but that are only using equalities as above, most importantly <code>Finset.prod_apply</code>, which states that <code>(∏ i ∈ s, f i) x = ∏ i ∈ s, f i x</code>. (b) when defining function spaces, there is a lot of boilerplate in defining the <code>add_apply</code> lemmas (you want them to be <code>simp</code>) and also to obtain various instances like <code>AddCommGroup</code> (which follows trivially from the corresponding properties on the codomain).<br>\nIn <a href=\"https://github.com/leanprover-community/mathlib4/pull/33477\">#33477</a>, specifically <code>Mathlib.Analysis.Distribution.SchwartzSpace</code> I have an example of how much boilerplate we could get rid of and how defining function spaces gets simplified.<br>\nThe problem however is obviously performance, because this will stress the typeclass inference system more.<br>\nThe benchmark for just changing <code>AddHom</code> and <code>AddMonoidHom</code>, (and <code>SchwartzMap</code>, but that one does not really contribute) is<br>\ninstructions: +3.0T (+1.6%), wall-clock: +30s (+2.3%).<br>\nRefactoring something like <code>LinearMap</code> and <code>ContinuousLinearMap</code> will be somewhat annoying I assume and also negatively impact the performance, so I would like to know whether this refactor is appreciated and how much performance we are willing to sacrifice.</p>\n<p>Earlier discussions are at (I started a new topic, because my old one was a <code>Is there code for X</code>):<br>\n<a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/.60FunLike.60.20with.20additional.20algebraic.20structure/with/566022971\">https://leanprover.zulipchat.com/#narrow/channel/217875-Is-there-code-for-X.3F/topic/.60FunLike.60.20with.20additional.20algebraic.20structure/with/566022971</a><br>\nand <a href=\"#narrow/channel/287929-mathlib4/topic/AddMonoidHomClass.20confusion/with/502885117\">https://leanprover.zulipchat.com/#narrow/channel/287929-mathlib4/topic/AddMonoidHomClass.20confusion/with/502885117</a></p>",
        "id": 566142461,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1767439299
    },
    {
        "content": "<p><span aria-label=\"ping pong\" class=\"emoji emoji-1f3d3\" role=\"img\" title=\"ping pong\">:ping_pong:</span> for feedback on this potential refactor. I would like to have an opinion of someone more familiar with type classes/inference system to judge whether this is worth doing.<br>\nIt is a lot of work refactoring all bundled <code>FunLike</code> types, so I don't want to put in serious efforts for nothing.</p>",
        "id": 574115350,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1771250200
    }
]