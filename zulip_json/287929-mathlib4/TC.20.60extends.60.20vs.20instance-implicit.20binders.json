[
    {
        "content": "<p>I noticed mathlib uses 2 ways to have one typeclass <code>Foo</code> depend on another typeclass <code>Bar</code>: using <code>extends</code>, as in <code>class Foo (a : Type) extends Bar a</code> or to use an instance binder, as in <code>class Foo (a : Type) [Bar a]</code>.<br>\nI was wondering what the considerations are for when to use either option?<br>\nIn particular, I noticed some classes that seem to use both, like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">GMonoid</span> <span class=\"o\">[</span><span class=\"n\">AddMonoid</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"kd\">extends</span> <span class=\"n\">GMul</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">GOne</span> <span class=\"n\">A</span> <span class=\"n\">where</span>\n</code></pre></div>",
        "id": 338833145,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1677675883
    },
    {
        "content": "<p>A more understandable case is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Module#doc\">docs4#Module</a></p>",
        "id": 338838576,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1677677131
    },
    {
        "content": "<p>Or <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ContinuousMul#doc\">docs4#ContinuousMul</a></p>",
        "id": 338838727,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1677677163
    },
    {
        "content": "<p>That is a great question! I call the first one \"bundled inheritance\" and the second \"unbundled inheritance\" in my <a href=\"https://drops.dagstuhl.de/opus/volltexte/2022/16713\">paper on classes in mathlib3</a>. To avoid telling you just to RTFM, I'll try and write the summary:</p>",
        "id": 338839077,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1677677238
    },
    {
        "content": "<p>Bundled inheritance is generally cleaner to read and write: instead of <code>[Semiring R] [AddCommMonoid M] [Module R M]</code> it would be nicer to just write <code>[SemiModule R M]</code>. The shorter notation also has practical advantages beyond aesthetics: unbundled inheritance causes <a href=\"https://www.ralfj.de/blog/2019/05/15/typeclasses-exponential-blowup.html\">exponential blowup</a> of term size as your algebraic hierarchy grows deeper. So the rule of thumb in mathlib is to bundle by default, unless there is a good reason to avoid it:</p>\n<p>Bundled inheritance requires that the parameter list of the subclass is a subset of the superclass's: <code>Module R M</code> depends on both R and M, so the hypothetical instance <code>Module R M → AddCommMonoid M</code> generated by <code>extends</code> cannot apply reliably since Lean would have to guess a suitable value for <code>R</code>. This is the main reason for unbundling.</p>\n<p>The secondary reason for unbundling is that you'd get a combinatorial explosion of potential bundled classes: a multiplication operator could be <code>Comm</code> or not, <code>Assoc</code> or not, <code>Cancel</code> or not, etc... So we use unbundled mixins like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsDomain#doc\">docs4#IsDomain</a> (replacing, back in mathlib3 the previous <code>domain</code> and <code>integral_domain</code> class with one <code>is_domain</code> class).</p>\n<p>A final consideration new for Lean 4 is that the handling of <code>outParam</code> is different (IMO, worse), so classes like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SetLike#doc\">docs4#SetLike</a> will have unbundled subclasses like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SubmonoidClass#doc\">docs4#SubmonoidClass</a>. (Once the port is done I plan to do the same for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FunLike#doc\">docs4#FunLike</a> which currently still uses bundled inheritance.)</p>",
        "id": 338842155,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1677677906
    },
    {
        "content": "<blockquote>\n<p>A final consideration new for Lean 4 is that the handling of outParam is different (IMO, worse)</p>\n</blockquote>\n<p>Can you elaborate on that remark?  Little has changed in outParams specifically.  (Or do you mean the whole <code>{}</code> vs. <code>[]</code> thing?)</p>",
        "id": 338918965,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1677694574
    },
    {
        "content": "<p>There's another crucial feature of (\"semi\"-)unbundled classes that I don't think you mentioned explicitly in the ITP paper.  Namely that when have <code>[SemiModule R M] [SemiModule R N]</code>, we want the same semiring structure on <code>R</code> and <code>R</code>.  If the semiring structure is unbundled, then we get this for free because we only have a single <code>[Semiring R]</code> argument. But if <code>SemiModule</code> was fully bundled then those would be two unrelated (and possibly different) semiring structures.</p>",
        "id": 338921314,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1677695159
    },
    {
        "content": "<p>I think this probably falls into the \"combinatorial explosion\" argument, in that you can fix it with <code>[SemiModule2 R M N]</code></p>",
        "id": 338924893,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1677696093
    },
    {
        "content": "<p>A related issue is that we can't define a <code>[SemiModule2 R M N] : SemiModule R M</code> instance.</p>",
        "id": 338925795,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1677696350
    },
    {
        "content": "<p>Ah, but that issue _is_ mentioned in Anne's post above :)</p>",
        "id": 338926426,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1677696519
    },
    {
        "content": "<p>The typeclass that prompted this question from me is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">MvQPF</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">TypeVec.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">MvFunctor</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"n\">where</span>\n</code></pre></div>\n<p>There aren't many other typeclasses that apply to <code>TypeVec n -&gt; Type _</code>, and the <code>MvFunctor</code> typeclass has the same parameter as <code>MvQPF</code>, so this seems like a prime example of where bundling would be appropriate, right?</p>",
        "id": 338936756,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1677699100
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"238446\">Anne Baanen</span> <a href=\"#narrow/stream/287929-mathlib4/topic/TC.20.60extends.60.20vs.20instance-implicit.20binders/near/338842155\">said</a>:</p>\n<blockquote>\n<p>Once the port is done I plan to do the same for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FunLike#doc\">docs4#FunLike</a> which currently still uses bundled inheritance.</p>\n</blockquote>\n<p>What do you think about my proposal <a href=\"https://github.com/leanprover-community/mathlib4/pull/2202\">!4#2202</a>?</p>",
        "id": 338976096,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1677713516
    },
    {
        "content": "<p>I saw that you've reacted to my Zulip message but I'm bad at translating smiles into words.</p>",
        "id": 338976201,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1677713565
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110043\">Gabriel Ebner</span> <a href=\"#narrow/stream/287929-mathlib4/topic/TC.20.60extends.60.20vs.20instance-implicit.20binders/near/338918965\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>A final consideration new for Lean 4 is that the handling of outParam is different (IMO, worse)</p>\n</blockquote>\n<p>Can you elaborate on that remark?  Little has changed in outParams specifically.  (Or do you mean the whole <code>{}</code> vs. <code>[]</code> thing?)</p>\n</blockquote>\n<p>This is the <code>{}</code> vs <code>[]</code> thing, specifically <a href=\"https://github.com/leanprover-community/mathlib4/blob/b21620a738bdb033f8e5b97ca769d89ae650bfbc/Mathlib/Order/Hom/Lattice.lean#L241\">taking an instance depending on an <code>outParam</code> that can't be found through unification</a>.</p>",
        "id": 339023714,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1677743093
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/287929-mathlib4/topic/TC.20.60extends.60.20vs.20instance-implicit.20binders/near/338976096\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"238446\">Anne Baanen</span> <a href=\"#narrow/stream/287929-mathlib4/topic/TC.20.60extends.60.20vs.20instance-implicit.20binders/near/338842155\">said</a>:</p>\n<blockquote>\n<p>Once the port is done I plan to do the same for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FunLike#doc\">docs4#FunLike</a> which currently still uses bundled inheritance.</p>\n</blockquote>\n<p>What do you think about my proposal <a href=\"https://github.com/leanprover-community/mathlib4/pull/2202\">!4#2202</a>?</p>\n</blockquote>\n<p>Thank you for the reminder! It looks very interesting and neat, specifically the approach to moving design patterns (bundled morphisms and their associated typeclasses) into code (the <code>BundledHom</code> structure). I have not had a chance to test it out yet, so I can't tell whether my initial thoughts apply in practice, and you have thought of most of my concerns.</p>\n<p>Still, I'm somewhat wary of the <code>(p : (A → B) → Prop)</code> predicates as parameters to the classes. These can have quite nontrivial equalities and equivalences that typeclasses cannot see through, or see through only very slowly. For example: if someone writes a monoid hom when an additive hom is expected, will Lean end up trying to unify <code>*</code> with <code>+</code>? This tends to get expensive quite quickly. Quite probably, we're okay as long as we stick to predicates of the form <code>structure IsMonoidHom extends IsMulHom, IsOneHom</code> (rather than <code>IsMonoidHom := IsMulHom ∧ IsOneHom</code>; we'd also avoid issues that would arise if someone writes the predicate as <code>IsOneHom ∧ IsMulHom</code> ).</p>",
        "id": 339026578,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1677744132
    },
    {
        "content": "<p>Could you please add this concern to the issue?</p>",
        "id": 339026968,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1677744258
    },
    {
        "content": "<p><code>Is*Hom</code> should be structures but we should have automation that runs <code>mk_iff</code>, then use it to define instances for <code>comp</code>/<code>id</code>/whatever.</p>",
        "id": 339027185,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1677744332
    },
    {
        "content": "<p>Comment added! I'll try and make some time this afternoon to experiment with your proposal, maybe see if I can manage to redefine <code>MonoidHom</code>.</p>",
        "id": 339027962,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1677744554
    }
]