[
    {
        "content": "<p>Consider the following definition of a polynomial map between two modules (in forthcoming work by <span class=\"user-mention\" data-user-id=\"406490\">@María Inés de Frutos Fernández</span> and me) :</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- A polynomial map M → N between A-modules is a functorial family</span>\n<span class=\"sd\">  of maps R ⊗[A] M → R ⊗[A] N, for all A-algebras R -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">ext</span><span class=\"kd\">]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">PolynomialMap</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"n\">where</span>\n  <span class=\"n\">toFun</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"n\">S</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">N</span>\n  <span class=\"n\">isCompat</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"n\">S</span><span class=\"o\">]</span>  <span class=\"o\">{</span><span class=\"n\">S'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">S'</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"n\">S'</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">→ₐ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">S'</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">φ.toLinearMap.rTensor</span> <span class=\"n\">N</span> <span class=\"bp\">∘</span> <span class=\"n\">toFun</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"n\">toFun</span> <span class=\"n\">S'</span> <span class=\"bp\">∘</span> <span class=\"n\">φ.toLinearMap.rTensor</span> <span class=\"n\">M</span>\n</code></pre></div>\n<p>To make the definition work, it is necessary to limit the quantification and insist that <code>S</code> has <code>Type u</code>, and indeed Lean can decide that for themself as you observe when you replace <code>S : Type u</code> by <code>S : Type _</code>. </p>\n<p>My issue is that I want to plugin general stuff with <code>S = MvPolynomial ι R</code>, and the universe builder imposes <code>ι : Type u</code>: Lean does not realize that this would work if, eg, <code>ι := Fin n</code> for a natural integer <code>n</code>, or more generally if <code>ι : Type v</code> with <code>max u v = u</code>. In have played a little bit with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ULift.down#doc\">docs#ULift.down</a>, but that becomes ugly. </p>\n<p>Are there tricks to do that ?</p>\n<p>One thing I can imagine, given <code>f : PolynomialMap R M N</code>, is constructing  more general versions of <code>toFun</code> and <code>isCompat</code> which hold for any universes, but I don't know whether there are techniques for that.</p>",
        "id": 423548591,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1709019729
    },
    {
        "content": "<p>(For this I need, given <code>S : Type v</code>and any finitely generated subalgebra <code>A</code> of <code>S</code>, to define an algebra <code>S' : Type u</code> which is isomorphic to  <code>A</code>.)</p>",
        "id": 423550204,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1709020520
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130609\">@Antoine Chambert-Loir</span> I'm looking at <a href=\"https://www2.math.uu.se/~qimh/Polynomial%20Maps.pdf\">https://www2.math.uu.se/~qimh/Polynomial%20Maps.pdf</a> which defines the notion of <em>numerical map</em>. It is strongly related to polynomial map, but not exactly the same. However, it doesn't rely on any universes.</p>",
        "id": 423550507,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1709020671
    },
    {
        "content": "<p>Would that notion work for you? It requires working with binomial rings, which might be a problem for your applications??</p>",
        "id": 423550597,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1709020701
    },
    {
        "content": "<p>I didn't know of that reference, which is nice, and which deserves to be formalizes as well. However, we want polynomial maps to study the divided power algebra, as in Roby's paper,  and we will need more than that.</p>",
        "id": 423550963,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1709020867
    },
    {
        "content": "<p>That is what I feared...</p>",
        "id": 423551722,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1709021211
    },
    {
        "content": "<p>On the other hand, the following thing “should” be known (and is mathematically obvious, and is implicitely used in everything about essentially small categories) :</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.RingTheory.FiniteType</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Algebra.FiniteType</span> <span class=\"n\">R</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">),</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">CommSemiring</span> <span class=\"n\">A</span><span class=\"o\">),</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">),</span>  <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">S</span><span class=\"o\">),</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 423552075,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1709021390
    },
    {
        "content": "<p>Yes, certainly</p>",
        "id": 423552375,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1709021543
    },
    {
        "content": "<p>And it's also mathematically obvious that you only need to consider finite type <code>R</code>-algebras in the definition of polynomial maps.</p>",
        "id": 423552537,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1709021635
    },
    {
        "content": "<p>So one thing you could do, is keep the current definition, with its restrictive universes, and then prove a lemma that deduces the more general statement for <code>S</code> that live in an arbitrary universe.</p>",
        "id": 423552725,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1709021717
    },
    {
        "content": "<p>Yes, I think I'll do that. (And my example is almost done, thanks to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Algebra.FiniteType.iff_quotient_mvPolynomial%27%27#doc\">docs#Algebra.FiniteType.iff_quotient_mvPolynomial''</a>)</p>",
        "id": 423552871,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1709021788
    },
    {
        "content": "<p>Whenever I see this sort of thing (mathematicians doing serious things and being delayed because of spurious universe issues) my immediate thought is to just ignore the universes and make things less polymorphic. I bet my bottom dollar that nobody is ever going to come along in a few years' time and say \"oh no, I desperately need this for different universes in my application\", so my feeling is that it's just generalisation for navel-gazing's sake. Before I started on this lean thing I'd never heard of universes (full disclosure, this is a lie but I'm pretending it's true to make my point), and I cannot imagine an application of crystalline cohomology which would ever go outside <code>Type</code>. The community has this attitude that \"they're there so we must ensure that we work in full generally\" but as I've said many times, when I teach I just don't bother the students with the idea of universes at all and part of me can't see the point of them.</p>\n<p>In short Antoine I would not be at all worried about you being not maximally universe polymorphic, this is already happening in the category of modules etc and nobody noticed in LTE.</p>",
        "id": 423558660,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709023965
    },
    {
        "content": "<p>Yes, but if I do this less polymorphic, everything will have to be in <code>Type</code>.</p>",
        "id": 423559005,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1709024037
    },
    {
        "content": "<p>And? :)</p>",
        "id": 423559096,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1709024050
    },
    {
        "content": "<p>As Kevin says, nothing but the fact that this disturbs me.</p>",
        "id": 423559250,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1709024081
    },
    {
        "content": "<p>If lean didn't have universes then we'd be in this situation anytway and no mathematician would be remotely bothered</p>",
        "id": 423559926,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709024196
    },
    {
        "content": "<p>Another alternative is to define copies of the naturals, integers, reals, and <code>Fin n</code> in an arbitrary universe, using <code>ULift</code>. I would imagine that people would be happy with this. That way you can just stick to one universe <code>u</code> and probably nobody will notice you're not being maximally polymorphic. The fact that nobody did this yet makes me think that secretly nobody actually cares</p>",
        "id": 423560386,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709024314
    },
    {
        "content": "<p>Good luck deciding whether the canonical 37-dimensional real vector space in universe u is supposed to be <code>ULift (Fin 37 -&gt; Real)</code> or <code>(Ulift (Fin 37)) -&gt; Ulift Real</code>.</p>",
        "id": 423561163,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709024593
    },
    {
        "content": "<p>Correct answer: \"canonical is meaningless\" <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 423563777,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1709025570
    },
    {
        "content": "<p>Additionally, it is very much possible to retrofit more universe polymorphism once it's actually needed. For example, I recall that a lot of linear algebra definitions, especially on the dimension, started out with the field and the vector space living in the same <code>Type u</code> and this went well for years until we needed to change it.</p>",
        "id": 423572902,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1709028657
    },
    {
        "content": "<p>But here, there will be an issue, because a polynomial map <em>is</em> a functor, and it is not <em>a priori</em> clear that it suffices to define that functor on a given universe. (Although, as discussed above, in the present case, it does, but this requires a theorem.)</p>",
        "id": 423573328,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1709028786
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Universes/near/423558660\">said</a>:</p>\n<blockquote>\n<p>I cannot imagine an application of crystalline cohomology which would ever go outside <code>Type</code>.</p>\n</blockquote>\n<p>I do not agree! If <code>X</code> is a <code>k</code>-scheme.{0}, then the underlying category of the crystalline site <code>X/W_n</code> is not a small category, it may only be \"essentially small\" (for the étale site, it is not even be essentially small, unless we assume <code>X</code> is Noetherian and take a variant where we take only finite type étale maps to <code>X</code> instead of \"locally of finite type\").</p>\n<p>If <code>C : Type u</code> is an abelian category (with morphisms in <code>Type v</code>), then the hom sets in the derived category will tend to be in <code>Type (max u v)</code> instead of <code>Type v</code>. (Then, if <code>C</code> is a category of sheaves on the typical algebraic geometry site, we go out of <code>Type 0</code>, see the file <code>AlgebraicGeometry.Sites.BigZariski</code>.) In certain circumstances, it is possible to show that some homs (e.g. Ext-groups) are small, but it is far from easy. (For example, if <code>C</code> is a Grothendieck abelian category, the homs in the derived category should be <code>Small.{v}</code>.)</p>\n<p>When formalizing the localization of categories, I had to find a predicate which does not require to \"quantify over all universes\" in order to get a reasonably good API.</p>\n<p>I am not saying that we should be universe polymorphic everywhere it is possible, and certainly in the first attempts to formalize a theorem, it is advisable to not care too much about it, but eventually some not-very-rewarding tasks of this type have to be done.</p>",
        "id": 423588226,
        "sender_full_name": "Joël Riou",
        "timestamp": 1709033958
    },
    {
        "content": "<p>I definitely agree that for big sites you need to be careful with universes! But it is not clear to me that you ever need to do commutative algebra with a module whose underlying type is not a set (i.e. in <code>Type 0</code>), even if you're thinking about the (big) crystalline site.</p>",
        "id": 423616914,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709043864
    },
    {
        "content": "<p>Actually, what I am saying is that even what we call the \"small\" étale/crystalline site does not have to be \"small\" in the type theoretical sense!</p>\n<p>In mathlib, the small Zariski site shall definitely be small: for a topological space <code>X : Type u</code>, the type <code>Opens X</code> is also <code>Type u</code> because it is implemented using <code>Set X</code>. If instead, we had defined an open of <code>X</code> to be a topological space <code>U : Type u</code> equipped a map <code>f : U → X</code> that happens to be an open immersion, then this category of \"open immersions to X\" would be equivalent to <code>Opens X</code>, but it would be <code>Type (u + 1)</code>! (Anyway, I would agree that for coherent cohomology, <code>Type 0</code> should be enough.)</p>\n<p>Now, consider the small crystalline site attached to some <code>X</code>. However it is defined, it involves a nil-immersion of an open <code>U</code> of <code>X</code> to some scheme <code>Y</code>. Even if we choose <code>U : Opens X</code> (rather than saying <code>U ⟶ X</code> is any open immersion), we have to \"choose\" <code>Y</code>, and the consequence is that the underlying category of the small crystalline site shall be at least <code>Type (u + 1)</code>. Similar remarks apply to the small étale site. (In case of the crystalline site, it might be possible to show that the category is essentially <code>u</code>-small, but still the natural universe parameter is greater than <code>u</code>.)</p>",
        "id": 423624732,
        "sender_full_name": "Joël Riou",
        "timestamp": 1709045725
    },
    {
        "content": "<p>Yeah I definitely agree that we need universes to deal with what is going on there. But what I'm saying is that when you're actually doing commutative algebra rather than category theory, the objects are all sets.</p>",
        "id": 423625322,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709045866
    },
    {
        "content": "<p>The one possible counterexample I know to this would be defining etale or crystalline cohomology via some non-set limit over covers and you'll end up with abelian groups in a larger universe. And then I'm in two minds about whether we work to prove that they descend to a smaller universe (fortunately we still seem pretty far from this discussion!). But when doing the actual lifting calculations you're still working with two schemes in <code>Type</code>.</p>",
        "id": 423625839,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709045990
    },
    {
        "content": "<p>Looking forward to AIM :-)</p>",
        "id": 423626047,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709046027
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Universes/near/423561163\">said</a>:</p>\n<blockquote>\n<p>Good luck deciding whether the canonical 37-dimensional real vector space in universe u is supposed to be <code>ULift (Fin 37 -&gt; Real)</code> or <code>(Ulift (Fin 37)) -&gt; Ulift Real</code>.</p>\n</blockquote>\n<p>Well, after having thought about it, I believe it should be the latter.</p>",
        "id": 423771511,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1709110269
    },
    {
        "content": "<p>In which case you can at least move from your initial worry (\"everything needs to be in <code>Type</code> and that feels weird\") to perhaps something that will worry you less and which is already happening in some places in category theory (\"everything needs to be in the same universe <code>u</code>\") by using a universe-polymorphic <code>Fin n</code>.</p>",
        "id": 423776300,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709112002
    },
    {
        "content": "<p>Good luck persuading core that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fin#doc\">docs#Fin</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat#doc\">docs#Nat</a> should be universe polymorphic.</p>",
        "id": 423781142,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709113701
    },
    {
        "content": "<p>(I'm not convinced it's a good idea myself, but I doubt my attempt to make <code>IO</code> universe polymorphic is going to go anywhere either)</p>",
        "id": 423781222,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709113724
    },
    {
        "content": "<p>One obvious downside to making <code>Nat</code> universe-polymorphic is that you need a definition <code>Nat.universeJump</code>, and a theorem about <em>every single operation</em> that you might perform on <code>Nat</code> commutes with it. Things aren't quite as bad with <code>ULift.up</code>, as at least we don't have to show that factorial commutes with it</p>",
        "id": 423781423,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709113805
    },
    {
        "content": "<p>I was imagining doing this in mathlib, and just for <code>Fin n</code> for now, which would solve Antoine's original problem.</p>",
        "id": 423782183,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709114066
    },
    {
        "content": "<p>Could I get the beginners explanation for why the solution isn't to make <code>Type n</code> a subtype of <code>Type (n+1)</code>?  Is it just that dependent type theories (and inference algorithms) are generally allergic to subtyping, even in very regular cases?</p>",
        "id": 423782187,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1709114066
    },
    {
        "content": "<p>Good luck persuading core of that too:-)</p>",
        "id": 423782277,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709114098
    },
    {
        "content": "<p>IIRC some implementations of CIC do that (I’m tempted to say that’s the case in Coq, but the truth is that universe management in Coq seems to be quite different to what it is in Lean, and comes with its own problems)</p>",
        "id": 423787517,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1709115792
    },
    {
        "content": "<p>Coq definitely has universe cumulativity. It also has both \"parametric universes\" i.e. constants with universe arguments like lean, as well as \"symbolic universes\" (forget the actual name) which are constants that have \"fixed\" but abstract universes, as though you defined a <code>constant u : Universe</code> and used it in a given definition. This latter category has no equivalent in lean; Coq has to maintain a partial ordering on all symbolic universes and every use of a constant or implicit application of cumulativity introduces a new ordering constraint, and Coq will give an error if the partial order ever becomes inconsistent. (This all seems quite nightmarish and I'm glad Lean steered clear of it.)</p>",
        "id": 423874272,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1709143578
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Universes/near/423563777\">said</a>:</p>\n<blockquote>\n<p>Correct answer: \"canonical is meaningless\" <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>\n</blockquote>\n<p>Canonical answer, even.</p>",
        "id": 423951388,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1709183089
    },
    {
        "content": "<p>I was going to say something about sheafification on the fpqc site of a field being universe raising as well as being possibly dependent on the choice of larger universe, but apparently this is just ignored by people actually doing algebraic geometry :-)</p>",
        "id": 423951544,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1709183250
    },
    {
        "content": "<p>(there's no “ironic” emoji, alas...)</p>",
        "id": 423957804,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1709188300
    },
    {
        "content": "<p>Joel's comments indicate that there are people doing algebraic geometry here who understand this sort of thing all too well! Fortunately (unfortunately?) we're still not at the point where we have to worry about this in Mathlib's development of algebraic geometry. Roll on AIM!</p>",
        "id": 423977899,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709198189
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130609\">Antoine Chambert-Loir</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Universes/near/423548591\">said</a>:</p>\n<blockquote>\n<p>My issue is that I want to plugin general stuff with <code>S = MvPolynomial ι R</code>, and the universe builder imposes <code>ι : Type u</code>: Lean does not realize that this would work if, eg, <code>ι := Fin n</code> for a natural integer <code>n</code>, or more generally if <code>ι : Type v</code> with <code>max u v = u</code>. In have played a little bit with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ULift.down#doc\">docs#ULift.down</a>, but that becomes ugly. </p>\n</blockquote>\n<p>Could you try <code>ι : Type</code> because then Lean should be able to see that <code>MvPolynomial ι R</code> is in <code>Type u</code>?</p>",
        "id": 424003772,
        "sender_full_name": "Joël Riou",
        "timestamp": 1709207661
    },
    {
        "content": "<p>But if I use <code>ι : Type</code> in the general function, I won't be able to apply it when <code>ι</code> is another universe.<br>\nI decided to take the steepest way, namely agreeing that <code>PolynomialMap</code> restricts universes (as it must), but I will provide the general theorem without any restriction. And then <code>ι</code> will be allowed to live in any universe it pleases them.</p>",
        "id": 424006823,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1709208892
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Universes/near/423874272\">said</a>:</p>\n<blockquote>\n<p>Coq definitely has universe cumulativity. It also has both \"parametric universes\" i.e. constants with universe arguments like lean, as well as \"symbolic universes\" (forget the actual name) which are constants that have \"fixed\" but abstract universes, as though you defined a <code>constant u : Universe</code> and used it in a given definition. This latter category has no equivalent in lean; Coq has to maintain a partial ordering on all symbolic universes and every use of a constant or implicit application of cumulativity introduces a new ordering constraint, and Coq will give an error if the partial order ever becomes inconsistent. (This all seems quite nightmarish and I'm glad Lean steered clear of it.)</p>\n</blockquote>\n<p>There's progress on cumulative algebraic universes (in Rocq). <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> does Lean need cumulativity, or do you just want to restructure mathlib to only use two instead of four universes  (as you suggested in your lecture) ?<br>\n<a href=\"https://msp.cis.strath.ac.uk/types2025/abstracts/TYPES2025_paper21.pdf\">https://msp.cis.strath.ac.uk/types2025/abstracts/TYPES2025_paper21.pdf</a></p>",
        "id": 524728254,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1750258969
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"259452\">@Bas Spitters</span> Lean doesn't have cumulativity, and there are no plans to add it (and thank goodness for that, I don't want to think about what that would mean for lean4lean). I don't think it would be helpful for decreasing universe usage, but my goal as elaborated in my lecture is less to change what mathlib is doing and more to do a more precise analysis of existing proofs so that more of it is marked as \"not really using universes at all\"</p>",
        "id": 524802320,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1750294977
    },
    {
        "content": "<p>I agree such an analysis would be interesting. </p>\n<p>Back in 2015, <span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> wrote. <br>\n\"... universe cumulativity is rarely needed. There are only a handful of definitions or theorems (less than 10) currently in the HoTT library where lifts are needed\"<br>\n<a href=\"https://homotopytypetheory.org/2015/12/02/the-proof-assistant-lean/\">https://homotopytypetheory.org/2015/12/02/the-proof-assistant-lean/</a></p>\n<p>I'm wondering how many lifts are currently used in the Lean libraries.</p>",
        "id": 524827745,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1750317410
    },
    {
        "content": "<p>It's occasionally useful to have a copy of Nat in every universe level.</p>",
        "id": 524828556,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1750317606
    },
    {
        "content": "<p>For base types like Nat, would it be useful to have a PNat (like PUnit, instead of standing for \"positive\") instead of either lifting or having cumulativity?</p>",
        "id": 524868019,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1750333727
    },
    {
        "content": "<p>Actually, lifting Nat sounds awkward, since the successor constructor still takes an unlifted natural number.</p>",
        "id": 524868278,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1750333838
    },
    {
        "content": "<p>There might be a better way of searching for this, but<br>\n<a href=\"https://loogle.lean-lang.org/?q=%22Ulift%22\">https://loogle.lean-lang.org/?q=%22Ulift%22</a> <br>\ngives 661 hits, showing only 200.</p>",
        "id": 524871431,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1750334945
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"259452\">Bas Spitters</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Universes/near/524871431\">said</a>:</p>\n<blockquote>\n<p>There might be a better way of searching for this, but<br>\n<a href=\"https://loogle.lean-lang.org/?q=%22Ulift%22\">https://loogle.lean-lang.org/?q=%22Ulift%22</a> <br>\ngives 661 hits, showing only 200.</p>\n</blockquote>\n<p>This tells you how many lemmas mention <code>ULift</code>. It does not count number of definitions (or theorems) that use <code>ULift</code> in its value (or proof).</p>",
        "id": 524920047,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1750351258
    },
    {
        "content": "<p>You could get that number, but that requires a little bit of metaprogramming.</p>",
        "id": 524920086,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1750351275
    },
    {
        "content": "<p>The lack of universe cumulativity is definitely an obstacle in certain places. It means that a morphism in the category of groups is less general than a group homomorphism, since the former can only be between two groups in the same universe level.<br>\nThis also comes up in other places, e.g. in an old version of the proof of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ContDiffWithinAt.comp#doc\">docs#ContDiffWithinAt.comp</a> (see <a href=\"https://github.com/leanprover-community/mathlib4/blob/8fea0ef4f2fb3e534fb87a0bb0b54ef0b3e2b1ca/Mathlib/Analysis/Calculus/ContDiff/Basic.lean#L570\">this doc</a>).</p>\n<p>So universe cumulativity is definitely nice to have sometimes. But there is no realistic way we'll get it into the kernel now. Mario mentioned in his talk at Big Proof (or maybe in private conversation) that the unique typing property is deeply baked into the type-checking algorithm of Lean.</p>",
        "id": 524921085,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1750351741
    },
    {
        "content": "<p>And universe cumulativity gives some other weird behavior/properties, I believe. So even if it were possible, I'm not even sure if it would be desirable overall.</p>",
        "id": 524921246,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1750351807
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> In the abstract I linked above, they conjecture that with cumulativity, one would still get the principle typing property. That might suffice.</p>",
        "id": 524930908,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1750356901
    },
    {
        "content": "<p>How could you possibly have unique typing in the presence of universe cumulativity? Because then <code>Type : Type 1</code> and <code>Type : Type 2</code>, but <code>Type 1 ≠ Type 2</code>. Or have I fundamentally misunderstood something?</p>",
        "id": 524943801,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1750364545
    },
    {
        "content": "<p>you don't get unique types, but you get principal types which is some kind of analogue</p>",
        "id": 524943834,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1750364576
    },
    {
        "content": "<p>that is, if <code>e : A</code> then there exists some <code>A'</code> such that <code>e : A'</code> and for all <code>e : B</code> , <code>A' &lt;= B</code></p>",
        "id": 524943896,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1750364621
    },
    {
        "content": "<p>People might find this recent thesis useful/interesting: <a href=\"https://arxiv.org/abs/2505.13495\">https://arxiv.org/abs/2505.13495</a> &lt;--treats impredicative W-types (given the question at the end of Mario's talk)</p>",
        "id": 524981155,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1750398282
    },
    {
        "content": "<p>Note that part of the challenge there is that lean doesn't have an impredicative <code>Type</code>. If it did, a lot of constructions would be easier</p>",
        "id": 524981234,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1750398363
    },
    {
        "content": "<p>It's easy to use impredicative encodings for types which are supposed to live in <code>Prop</code>, but you have to do complicated things if it's a <code>Type</code></p>",
        "id": 524981264,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1750398392
    },
    {
        "content": "<p>OK, thanks. Wasn't sure how it related to what you were doing</p>",
        "id": 524981295,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1750398412
    },
    {
        "content": "<p>because the impredicative thing ends up in the wrong universe and/or has an induction principle which is too weak</p>",
        "id": 524981316,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1750398431
    },
    {
        "content": "<p>If you are in system F then it all works great</p>",
        "id": 524981361,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1750398472
    }
]