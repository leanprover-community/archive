[
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Iso</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">easy</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚âÖ</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚•§</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">hom</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">inv</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">ùüô</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"c1\">-- works</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">less_easy</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚âÖ</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚•§</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"bp\">‚•§</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">hom</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">inv</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">ùüô</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"c1\">-- fails; simp [‚Üê G.map_comp] works.</span>\n</code></pre></div>\n<p>Here, the fix is easy and <code>simp [‚Üê Functor.map_comp]</code> does the job, but in more complex proofs, it sometimes happens that a simp call get \"stuck\" on expressions like this, so has to be turned to a big <code>simp only</code> call, followed by a regular simp call. </p>\n<p>In <code>CategoryTheory/NatIso.lean</code>, it seems a similar problem is taken care of by having <code>simp</code> lemmas for some nested expressions, e.g <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Iso.inv_hom_id_app_app_app#doc\">docs#CategoryTheory.Iso.inv_hom_id_app_app_app</a>. Should we add similar simp lemmas stating <code>F‚ÇÅ.map (F‚ÇÇ.map ‚ãØ F‚Çô.map (e.hom)) ‚â´ F‚ÇÅ.map (F‚ÇÇ.map ‚ãØ F‚Çô.map (e.inv)) = ùüô _</code> up to a reasonable <code>n</code> (e.g n = 5)? This is a bit ugly and I wonder if there is a better way to do such things.</p>",
        "id": 511649190,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1744377311
    },
    {
        "content": "<p>We could certainly add a few more of such lemmas like <code>Functor.map_map_hom_inv_id</code>, but I would say only if it improves automation significantly for specific new additions to the library. I added <code>Iso.inv_hom_id_app_app_app</code> specifically in order to deal with functors in three variables, and hopefully, we should not need more...</p>",
        "id": 511711599,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1744396173
    },
    {
        "content": "<p>Can this be done with a <code>simproc</code>?</p>",
        "id": 511786143,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1744442350
    },
    {
        "content": "<p>I would suggest just waiting for the arrival of <code>grind</code>. My experiments so far with the category theory library suggest that it works very well in situations like this.</p>",
        "id": 512082347,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1744637897
    },
    {
        "content": "<p>I did not have the patience to wait for <code>grind</code>, and in <a href=\"#narrow/channel/144837-PR-reviews/topic/.2324452.20.2B.20.2324454.3A.20.60rotate_isos.60.20tactic\">#PR reviews &gt; #24452 + #24454: &#96;rotate_isos&#96; tactic</a>  I propose a tactic that can in particular generate \"on the fly\" such lemmas.</p>",
        "id": 515098525,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1745940970
    },
    {
        "content": "<p>I found myself very annoyed by this again (in the context rather big computations with bicategories, where I would end up with terms of the form <code>`A ‚óÅ B ‚óÅ C ‚óÅ D ‚óÅ e.inv ‚ñ∑ E ‚ñ∑ F ‚ñ∑ G ‚ñ∑ H ‚â´ A ‚óÅ B ‚óÅ C ‚óÅ D ‚óÅ e.hom ‚ñ∑ E ‚ñ∑ F ‚ñ∑ G ‚ñ∑ H</code> that wouldn‚Äôt simplify without doing some backwards rewriting dance.)</p>\n<p>So as Kevin suggested, I figured that might be a job for a simproc (and also an occasion for me to learn a few things), and I wrote <a href=\"https://github.com/leanprover-community/mathlib4/pull/33822\">#33822</a>. Compared to my last attempt in the post above (which tried to do things in a very brute-forcy and ad hoc way), this time my attempt uses the <code>@[push]</code> attribute and the <code>push</code> tactic/simproc behind the curtains, so the simproc capabilities to \"understand\" new instances of this patterns are easily extended simply by registering the right <code>IsIso</code> instances and tagging the right lemmas with <code>@[push]</code> (unsurprisingly, it suffices to tag the lemmas that \"push\" the inverses inwards, this is somewhat opposite to the simp normal forms in the library, which tend to \"pull\" inverses outwards e.g <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Functor.map_inv#doc\">docs#CategoryTheory.Functor.map_inv</a>).</p>",
        "id": 567323210,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1768054313
    },
    {
        "content": "<p>Are you planning to also add the rotate_isos tactic/simproc after <a href=\"https://github.com/leanprover-community/mathlib4/pull/33822\">#33822</a> is merged, or does the <code>cancelIso</code> simproc suffice?</p>",
        "id": 567387254,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1768134214
    },
    {
        "content": "<p>Yes, I am planning to revive <code>rotate_isos</code> as well (it is still wip right now), as the main use case for <code>rotate_isos</code> was the elaborator <code>rotate_isos%</code> that generates rotated versions of lemmas on the fly, which can‚Äôt really be handled by <code>cancelIso</code> alone. The implementation would be using cancelIso under the hood.</p>",
        "id": 567388659,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1768136117
    }
]