[
    {
        "content": "<p>I want to prove the following lemma which i had hoped <code>simp</code> or <code>aesop</code> would do, that is not the case. An extremely ugly proof which unfold everything down to the API of limits can be found, but it if that is the only proof, then that suggest some API is missing.</p>\n<p>Here's a mwe:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">ChosenFiniteProducts</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">section</span>\n\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">v‚ÇÅ</span><span class=\"w\"> </span><span class=\"n\">u‚ÇÅ</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">Limits</span><span class=\"w\"> </span><span class=\"n\">MonoidalCategory</span><span class=\"w\"> </span><span class=\"n\">ChosenFiniteProducts</span>\n\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"kn\">local</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">ChosenFiniteProducts</span><span class=\"bp\">.</span><span class=\"n\">ofFiniteProducts</span>\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"kn\">local</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">monoidalOfChosenFiniteProducts</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u‚ÇÅ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v‚ÇÅ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">HasFiniteLimits</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">A'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">A'</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚óÅ</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">prod</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">ùüô</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span>\n</code></pre></div>",
        "id": 499771251,
        "sender_full_name": "Sina Hazratpour ìÉµ",
        "timestamp": 1739547338
    },
    {
        "content": "<p>Perhaps</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">A'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">A'</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚óÅ</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">prod</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">ùüô</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">ext</span>\n<span class=\"w\">  </span><span class=\"bp\">¬∑</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">whiskerLeft_fst</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"n\">comp_id</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">prod</span><span class=\"bp\">.</span><span class=\"n\">map_fst</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">ùüô</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n<span class=\"w\">  </span><span class=\"bp\">¬∑</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">whiskerLeft_snd</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">prod</span><span class=\"bp\">.</span><span class=\"n\">map_snd</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">ùüô</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n</code></pre></div>",
        "id": 499772457,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1739547665
    },
    {
        "content": "<p>I would say that you're not supposed to be in this situation where one side has morphisms involving <code>X ‚äó Z</code> and the other has morphisms involving <code>X ‚®Ø Z</code>. So if possible I would say you should back up and see how you ended up in this situation.</p>",
        "id": 499773404,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1739547942
    },
    {
        "content": "<p>Interesting! The reason my proof got long was that <code>simp [prod.map_fst]</code> or <code>rw [prod.map_fst (ùüô X) g]</code> was not working after the first line. Any idea as to why?</p>",
        "id": 499773757,
        "sender_full_name": "Sina Hazratpour ìÉµ",
        "timestamp": 1739548043
    },
    {
        "content": "<p>What I'm saying is you shouldn't even be talking about <code>prod.map (ùüô X) g</code>, but about <code>(ùüô X) ‚äó g</code>.</p>",
        "id": 499773997,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1739548115
    },
    {
        "content": "<p>I have no idea what the actual use case is but what if the right hand side is some generic category-theoretic construct which simps to that.</p>",
        "id": 499774609,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1739548274
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260921\">Markus Himmel</span> <a href=\"#narrow/channel/287929-mathlib4/topic/API.20for.20interface.20of.20ChosenFiniteProducts.20and.20FiniteProducts/near/499773404\">said</a>:</p>\n<blockquote>\n<p>I would say that you're not supposed to be in this situation where one side has morphisms involving <code>X ‚äó Z</code> and the other has morphisms involving <code>X ‚®Ø Z</code>. So if possible I would say you should back up and see how you ended up in this situation.</p>\n</blockquote>\n<p>i don't know about that; Sometimes you want to promote <code>HasFiniteProduct</code> to <code>ChosenFiniteProduct</code>. In particular, i am solving a TODO in <code>CategoryTheory.Over.Pullback</code> which asks to show if a category <code>C</code> is cartesian closed then <code>star X : C ‚•§ Over X</code><br>\nhas a right adjoint <code>sectionsFunctor</code>. Now, <code>star</code> is defined by the algebras of the prod<code>Comonad</code> which uses <code>HasBinaryProducts</code> while the right adjoint (the section functor) only makes sense in the cartesian closed structure coming from the following instances: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"kn\">local</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">ChosenFiniteProducts</span><span class=\"bp\">.</span><span class=\"n\">ofFiniteProducts</span>\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"kn\">local</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">monoidalOfChosenFiniteProducts</span>\n</code></pre></div>\n<p>Therefore the need to have interface lemma like i mentioned.</p>\n<p>unless we redo <code>star</code> and directly define it in terms of  <code>ChosenFiniteProducts</code>! But where does the buck stop with this approach, we don't want to replace all <code>HasFiniteProducts</code> with  <code>ChosenFiniteProducts</code>, do we?</p>",
        "id": 499774757,
        "sender_full_name": "Sina Hazratpour ìÉµ",
        "timestamp": 1739548317
    },
    {
        "content": "<p>Could you share a mathlib branch so that I can see the place in your code where you need this?</p>",
        "id": 499775161,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1739548418
    },
    {
        "content": "<p>it's in the file <code>CategoryTheory.Comma.Over.Sections</code> of the LCCC PR: </p>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/21525/files#diff-be27792f64b32cb78937c6244c8d305283c48d5c725fff684bf1dc21882a9a32\">https://github.com/leanprover-community/mathlib4/pull/21525/files#diff-be27792f64b32cb78937c6244c8d305283c48d5c725fff684bf1dc21882a9a32</a></p>",
        "id": 499776678,
        "sender_full_name": "Sina Hazratpour ìÉµ",
        "timestamp": 1739548875
    },
    {
        "content": "<p>The last line of <code>homEquiv_naturality_left_symm</code> in <code>coreHomEquiv</code>(line 173) uses </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">whiskerLeft_prod_map</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">A'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">A'</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"bp\">‚óÅ</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">prod</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">ùüô</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n</code></pre></div>",
        "id": 499777577,
        "sender_full_name": "Sina Hazratpour ìÉµ",
        "timestamp": 1739549123
    },
    {
        "content": "<p>So my claim here is that the real problem is in the definition of <code>sectionsUncurry</code>. Here you're constructing something using <code>Over.homMk ?_ ?_</code>, and the first thing is supposed to be of the form <code>((star I).obj A).left ‚ü∂ X.left</code>. The <code>dsimp</code>-normal form of that is <code>I ‚®Ø A ‚ü∂ X.left</code>, but you're providing something of type <code>I ‚äó A ‚ü∂ X.left</code> and this leads to the problems down the line.</p>\n<p>I claim that the correct way to fix this would be this: introduce an explicit isomorphism</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">prodIsoTensorObj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚®Ø</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">‚âÖ</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚äó</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Iso.refl</span><span class=\"w\"> </span><span class=\"n\">_</span>\n</code></pre></div>\n<p>which translates between the monoidal world and the binary product world, and show that under this iso, <code>prod.fst</code> becomes <code>ChosenFiniteProducts.fst</code>, <code>prod.map</code> becomes tensor, etc.</p>\n<p>I have applied this to your code and I think things are working better; for example, some terminal <code>rfl</code> are no longer there because <code>simp</code> can solve goals by itself: <a href=\"https://github.com/leanprover-community/mathlib4/commit/b9152e80d4ed675dc691a76071f08b0a04b5e455\">https://github.com/leanprover-community/mathlib4/commit/b9152e80d4ed675dc691a76071f08b0a04b5e455</a></p>",
        "id": 499782261,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1739550622
    },
    {
        "content": "<p>Very good observation! <br>\nNow that I look back, this is also the same way we did it in LCCCs, we constructed and used a dependent version of <code>prodIsoTensorObj</code>.</p>",
        "id": 499784814,
        "sender_full_name": "Sina Hazratpour ìÉµ",
        "timestamp": 1739551471
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260921\">@Markus Himmel</span> I'm not great with the git, what is the git command to merge your last commit on that branch?</p>",
        "id": 499785274,
        "sender_full_name": "Sina Hazratpour ìÉµ",
        "timestamp": 1739551627
    },
    {
        "content": "<p><code>git merge markus/sina</code> should work</p>",
        "id": 499786294,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1739551969
    },
    {
        "content": "<p>I'm on the branch <code>sina-locally-cartesian-closed-categories</code> and <code>git merge markus/sina</code> results in <br>\n<code>merge: markus/sina - not something we can merge</code></p>",
        "id": 499786797,
        "sender_full_name": "Sina Hazratpour ìÉµ",
        "timestamp": 1739552127
    },
    {
        "content": "<p>ah, never mind, ofc i forgot <code>origin</code> haha. now it's merged, thanks!</p>",
        "id": 499787488,
        "sender_full_name": "Sina Hazratpour ìÉµ",
        "timestamp": 1739552323
    }
]