[
    {
        "content": "<p>I am confused about the point of <code>IsAdjoinRoot</code>. I thought it was an axiomatisation of the construction <code>AdjoinRoot</code>, but the definition appears to be \"I am algebra isomorphic to <code>AdjoinRoot</code>.\" In fact, as <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> has pointed out in another thread, this class even carries the data of the isomorphism!<br>\nThe file <code>AdjoinRoot</code> instructs me to abstract to <code>IsAdjoinRoot</code> instead. I think this is a good idea, but I am unclear where the <em>abstraction</em> comes in. Perhaps the definition of <code>IsAdjoinRoot</code> should be changed?</p>",
        "id": 529955328,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1753126969
    },
    {
        "content": "<p>The abstraction should come in the form of the underlying isomorphims being an implementation detail</p>",
        "id": 529970183,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1753134302
    },
    {
        "content": "<p>In that no user of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsAdjoinRoot#doc\">docs#IsAdjoinRoot</a> should have to know about it</p>",
        "id": 529970230,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1753134323
    },
    {
        "content": "<p>I don't understand what you mean, sorry<br>\nLike, currently the exact definition is \"R-algebra with a surjective R-hom from R[X] with kernel (f)\"<br>\nthat's not really an abstraction of \"R-algebra that is R-isomorphic to R[X]/(f)\"</p>",
        "id": 529970453,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1753134468
    },
    {
        "content": "<p>It's an abstraction because it means that any API you would write for <code>AdjoinRoot</code> can now be written for <code>IsAdjoinRoot</code> instead and you save the user transporting across the isomorphism</p>",
        "id": 529970812,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1753134692
    },
    {
        "content": "<p>Ah, sure<br>\nYes OK this is what I want<br>\nI'm going to add to <code>IsAdjoinRoot</code></p>",
        "id": 529970914,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1753134744
    },
    {
        "content": "<p>thank you!</p>",
        "id": 529970920,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1753134748
    },
    {
        "content": "<p>On the other hand, I think something we're starting to learn from writing API in this way for things like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AddMonoidHomClass#doc\">docs#AddMonoidHomClass</a> is that actually having these explicit isomorphisms we tried to get rid of is a feature because it helps sort out simp-normal forms.</p>",
        "id": 529970980,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1753134788
    },
    {
        "content": "<p>Well in this case you're still carrying the isomorphism around, right? So it's no loss</p>",
        "id": 529971125,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1753134853
    },
    {
        "content": "<p>No, the point is whether the casting operation appears in the statements, not in the implementation</p>",
        "id": 529971279,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1753134945
    },
    {
        "content": "<p>Anyway, I think adding to IsAdjoinRoot for now is reasonable</p>",
        "id": 529971312,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1753134970
    },
    {
        "content": "<p>Could you give a concrete example? I'm very confused what you mean</p>",
        "id": 529971343,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1753134989
    },
    {
        "content": "<p>I don't remember much about <code>AdjoinRoot</code>, but if you're choosing between</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AdjoinRoot</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>and</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f2</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsAdjoinRoot</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n</code></pre></div>\n<p>then with the second one you need annoying lemmas to rewrite <code>f2 (toAdjoinRoot (x : S)) = f2 x</code></p>",
        "id": 529971870,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1753135313
    },
    {
        "content": "<p>Also I think you tricked me into thinking that the isomorphism (an <code>AlgEquiv</code>?) actually exists, I can't find it</p>",
        "id": 529971906,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1753135332
    },
    {
        "content": "<p>Things I want to add to <code>IsAdjoinRoot</code>:<br>\n(1) change the definition to use <code>AlgHom</code> so we can make use of all the API<br>\n(2) convert to and from algebra isomorphism with <code>R[X]/span {f}</code><br>\n(3) show that if <code>x</code> is algebraic over <code>F</code> and primitive in <code>E/F</code> then <code>IsAdjoinRoot E (minpoly F x)</code></p>\n<p>(3) is the important one, (1) and (2) are for usability</p>",
        "id": 529971935,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1753135355
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60IsAdjoinRoot.60/near/529971906\">said</a>:</p>\n<blockquote>\n<p>Also I think you tricked me into thinking that the isomorphism (an <code>AlgEquiv</code>?) actually exists, I can't find it</p>\n</blockquote>\n<p>Yeah it's mathematically equivalent but not actually written down</p>",
        "id": 529971972,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1753135378
    },
    {
        "content": "<p>2 sounds like a nice result to have, I'm less convinced 1 is actually helpful</p>",
        "id": 529972063,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1753135438
    },
    {
        "content": "<p>I guess try 1 in a standalone PR if you care, and see if it makes existing code easier</p>",
        "id": 529972151,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1753135483
    },
    {
        "content": "<p>Well we wouldn't make the map in the definition a morphism of abelian groups and then add extra axioms stating that it's multiplicative and preserves 1</p>",
        "id": 529972159,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1753135487
    },
    {
        "content": "<p>We wrote the API why not use it, yk</p>",
        "id": 529972178,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1753135503
    },
    {
        "content": "<p>OTOH there <em>is</em> a good reason not to make the definition \"<code>AlgEquiv</code> with <code>R[X]/span {f}</code>\": that would require the data of the inverse</p>",
        "id": 529972374,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1753135605
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"400289\">Artie Khovanov</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60IsAdjoinRoot.60/near/529972178\">said</a>:</p>\n<blockquote>\n<p>We wrote the API why not use it, yk</p>\n</blockquote>\n<p>Well, the Ideal API is for rings not algebras, and <code>algebraMap</code> is used much more than the alghom version <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Algebra.ofId#doc\">docs#Algebra.ofId</a>, so it's plausible you'll find it turns out less convenient.</p>",
        "id": 529973846,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1753136618
    },
    {
        "content": "<p>hm OK<br>\nI guess I'll see<br>\n<code>IsAdjoinRoot</code> is only currently implemented in one place</p>",
        "id": 529973930,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1753136692
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60IsAdjoinRoot.60/near/529971870\">said</a>:</p>\n<blockquote>\n<p>I don't remember much about <code>AdjoinRoot</code>, but if you're choosing between</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AdjoinRoot</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>and</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f2</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsAdjoinRoot</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n</code></pre></div>\n<p>then with the second one you need annoying lemmas to rewrite <code>f2 (toAdjoinRoot (x : S)) = f2 x</code></p>\n</blockquote>\n<p>This can't be an instance (you haven't specified which root your isomorphism maps <code>X</code> to). But I think I understand.</p>",
        "id": 529974273,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1753136905
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> do you know if there is an abstraction of <code>Ideal.ker</code>? Or do we have to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/RingTheory/Ideal/Quotient/Operations.html#Ideal.quotientEquiv\">Ideal.quotientEquiv</a> to fix things given <code>Ideal.ker f = I</code>?</p>",
        "id": 529980513,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1753141840
    },
    {
        "content": "<p>What purpose would an abstraction serve?</p>",
        "id": 529982989,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1753143947
    },
    {
        "content": "<p>same reason we have all the others, means you don't need to fix definitions in eg first isomorphism theorem<br>\nbut yeah you get the same problems you said about map typeclasses</p>",
        "id": 529983044,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1753144001
    },
    {
        "content": "<p>I assume we don't have one?</p>",
        "id": 529983071,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1753144024
    },
    {
        "content": "<p>Where would you draw the line? Should we have <code>Set.IsUnion</code>? <code>Nat.IsAdd</code>?</p>",
        "id": 529983239,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1753144177
    },
    {
        "content": "<p>I'm asking what we have, I'm not proposing to add or remove abstraction classes</p>",
        "id": 529983274,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1753144204
    },
    {
        "content": "<p>Although personally I'm in favour of using classes for substructures and against using classes for maps<br>\nHowever changing the status quo is effort</p>",
        "id": 529983297,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1753144234
    },
    {
        "content": "<p>I thought we might have kernels because they at least satisfy a mathematical universal property</p>",
        "id": 529983316,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1753144253
    },
    {
        "content": "<p>I think the key thing here is that this is avoidable by using just a regular equality</p>",
        "id": 529983357,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1753144294
    },
    {
        "content": "<p>And so any caller can substitute that equality first</p>",
        "id": 529983380,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1753144311
    },
    {
        "content": "<p>Well, quotientEquiv is still a pain to use</p>",
        "id": 529983402,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1753144327
    },
    {
        "content": "<p>I think a mwe would help for that</p>",
        "id": 529983422,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1753144348
    },
    {
        "content": "<p>You can't just substitute the type <code>R⧸I</code> under <code>I=J</code></p>",
        "id": 529983426,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1753144353
    },
    {
        "content": "<p>Are you sure?</p>",
        "id": 529983480,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1753144381
    },
    {
        "content": "<p>I hadn't noticed until now that quotientEquiv takes precisely the type of argument I was arguing against!</p>",
        "id": 529983598,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1753144470
    },
    {
        "content": "<p>does it? I thought it takes a concrete equiv, not a class</p>",
        "id": 529983653,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1753144514
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 529983770,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1753144601
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60IsAdjoinRoot.60/near/529983380\">said</a>:</p>\n<blockquote>\n<p>And so any caller can substitute that equality first</p>\n</blockquote>\n<p>This is evil equality though:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">test_def</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">→+*</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ideal</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">RingHom</span><span class=\"bp\">.</span><span class=\"n\">ker</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">≃+*</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">RingHom</span><span class=\"bp\">.</span><span class=\"n\">ker</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"bp\">≃+*</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">e</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">→+*</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ideal</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">RingHom</span><span class=\"bp\">.</span><span class=\"n\">ker</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">≃+*</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">RingHom</span><span class=\"bp\">.</span><span class=\"n\">ker</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"bp\">≃+*</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">test_def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">e'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">test_def</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 529984098,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1753144911
    },
    {
        "content": "<p>You're not supposed to make definitions using <code>rw</code>, <code>test_def</code> will be unusable. You're supposed to be using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ideal.quotEquivOfEq#doc\">docs#Ideal.quotEquivOfEq</a> there.</p>",
        "id": 530079329,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1753167129
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60IsAdjoinRoot.60/near/529983239\">said</a>:</p>\n<blockquote>\n<p>Where would you draw the line? Should we have <code>Set.IsUnion</code>? <code>Nat.IsAdd</code>?</p>\n</blockquote>\n<p>Funnily, we did use just that in homology, there is a predicate for saying that \"m is the next integer of n\", because it's useful to be able to write (Int.negSucc 0) as the predecessor of 0</p>",
        "id": 530106379,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753177389
    }
]