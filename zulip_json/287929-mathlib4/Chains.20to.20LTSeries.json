[
    {
        "content": "<p>I am at the tail end of finishing my formalization of the statement: \"integral extensions preserve Krull dimension\". Unfortunately, , since I was bad at parsing the mathlib4 library when I started this mini project, I formalized all of my \"helper\" lemmas in terms of  finite subsets of PrimeSpectrum A which were totally ordered. In other words, the objects I was dealing with, and inductively applying Going Up to were things like S : Set (PrimeSpectrum A) with attributes S.Finite and IsChain ( . &lt; . ) S.</p>\n<p>In hindsight, this was probably not the best way to write everything as Krull DImension is defined using LTSeries which seem to me to be injective functions from Fin(n) to Set(PrimeSpectrum A) preserving the order on Fin(n). Rather than rewrite all of my Lemma's I thought I could prove the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">krullDim_chain_leq</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PartialOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PartialOrder</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">},</span>\n<span class=\"w\">    </span><span class=\"n\">IsChain</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">IsChain</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">krullDim</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">krullDim</span><span class=\"w\"> </span><span class=\"n\">β</span>\n</code></pre></div>\n<p>The strategy of the proof is as follows:<br>\n1) Start with an LTSeries in alpha <br>\n2) Turn the LTSeries into a set<br>\n3) Show this set is finite and is a chain<br>\n4) Use the hypothesis H to get a finite chain  T of the same cardinality in beta<br>\n5) Turn T back into an LTSeries</p>\n<p>I am stuck on step 5, i.e. I have a finite chain T of the same cardinality of the set in alpha, but I cannot seem figure out how to get it to be an LTSeries. Does anyone have any advice on how one could approach this?</p>",
        "id": 530183387,
        "sender_full_name": "Quinn La Fond",
        "timestamp": 1753201797
    },
    {
        "content": "<p>repeatedly extract the minimum</p>",
        "id": 530208869,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753212321
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"816344\">@Aaron Liu</span>  I agree that that makes sense from a mathematical pov, but I am unsure of how to implement in this procedure in lean.</p>",
        "id": 530210186,
        "sender_full_name": "Quinn La Fond",
        "timestamp": 1753212922
    },
    {
        "content": "<p>There should be a theorem that says a finite chain has a minimum element</p>",
        "id": 530210252,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753212950
    },
    {
        "content": "<p>you can recursively define the <code>n</code>th element from the bottom as the minimum element of the chain minus all the <code>i</code>th elements for which <code>i &lt; n</code></p>",
        "id": 530210419,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753213045
    },
    {
        "content": "<p>Yes I have the minimum element, I meant how do I recursively define an LTSeries? It is a function from Fin(n) for some n to a partially ordered set. I don't know how to actually construct such a function.</p>",
        "id": 530258854,
        "sender_full_name": "Quinn La Fond",
        "timestamp": 1753244107
    },
    {
        "content": "<p>Same as you do normally (or have you never done so before?)</p>",
        "id": 530263951,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753247928
    },
    {
        "content": "<p>Call the function from inside itself</p>",
        "id": 530263961,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753247942
    },
    {
        "content": "<p>If you can trouble come back with an error message and we can help you fix it</p>",
        "id": 530263987,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753247962
    },
    {
        "content": "<p>I have never done so before lol I am very much learning by doing atm</p>",
        "id": 530264196,
        "sender_full_name": "Quinn La Fond",
        "timestamp": 1753248113
    },
    {
        "content": "<p>(I also emberrasingly do not know what it means to call the function from inside itself)</p>",
        "id": 530264325,
        "sender_full_name": "Quinn La Fond",
        "timestamp": 1753248203
    },
    {
        "content": "<p>Have you done recursive functions in other programming languages before?</p>",
        "id": 530264411,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753248251
    },
    {
        "content": "<p>Do you know what it means to call a function?</p>",
        "id": 530264434,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753248272
    },
    {
        "content": "<p>I vaguely recall doing this in C like 4 years ago for a computational physics course but that was my only prior exposure to programming languages before this</p>",
        "id": 530387350,
        "sender_full_name": "Quinn La Fond",
        "timestamp": 1753287860
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Chains.20to.20LTSeries/near/530264434\">said</a>:</p>\n<blockquote>\n<p>Do you know what it means to call a function?</p>\n</blockquote>\n<p>This is like asking the computer to invoke something you've already defined right?</p>",
        "id": 530387522,
        "sender_full_name": "Quinn La Fond",
        "timestamp": 1753287918
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"927532\">Quinn La Fond</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Chains.20to.20LTSeries/near/530183387\">said</a>:</p>\n<blockquote>\n<p>I am stuck on step 5, i.e. I have a finite chain T of the same cardinality of the set in alpha, but I cannot seem figure out how to get it to be an LTSeries. Does anyone have any advice on how one could approach this?</p>\n</blockquote>\n<p>My advice is: post a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a></p>",
        "id": 530400876,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1753292414
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  I read the mean working example page, but I am not totally sure how to provide such an example. I would say that I am essentially trying to prove the following lemma:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Order</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">chain_to_LTseries</span><span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PartialOrder</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">T_chain</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsChain</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T_finite</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">Finite</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T_nonempty</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">Nonempty</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">T_series</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LTSeries</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">T_series</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\">  </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I think my main problem is that I don't really know how to recursively define a function...</p>",
        "id": 530425668,
        "sender_full_name": "Quinn La Fond",
        "timestamp": 1753301647
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"816344\">@Aaron Liu</span> Do you have any further insight on this?</p>",
        "id": 531172891,
        "sender_full_name": "Quinn La Fond",
        "timestamp": 1753634631
    },
    {
        "content": "<p>Maybe try something simpler first</p>",
        "id": 531172984,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753634664
    },
    {
        "content": "<p>Such as?</p>",
        "id": 531173018,
        "sender_full_name": "Quinn La Fond",
        "timestamp": 1753634677
    },
    {
        "content": "<p>define a function recursively</p>",
        "id": 531173536,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753634873
    },
    {
        "content": "<p>try the fibonacci sequence</p>",
        "id": 531173559,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753634882
    },
    {
        "content": "<p>I understand conceptually how recursion is supposed to work, I just don't fully understand how it is supposed to work in Lean from a syntax pov.</p>",
        "id": 531173834,
        "sender_full_name": "Quinn La Fond",
        "timestamp": 1753634994
    },
    {
        "content": "<p>I think that's why he suggested fibonacci</p>",
        "id": 531173998,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753635060
    },
    {
        "content": "<p>More specifically, in the NNG you have only been exposed to proving theorems (and in Lean, theorems have no data), so now you're stepping onto a new zone</p>",
        "id": 531174168,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753635127
    },
    {
        "content": "<p>it's a non-trivial step to go from proving theorems to constructing \"data\"</p>",
        "id": 531174209,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753635143
    },
    {
        "content": "<p>I see, I will search for some way of doing this then.</p>",
        "id": 531174348,
        "sender_full_name": "Quinn La Fond",
        "timestamp": 1753635196
    },
    {
        "content": "<p>thank you</p>",
        "id": 531174373,
        "sender_full_name": "Quinn La Fond",
        "timestamp": 1753635205
    },
    {
        "content": "<p>you can look into the library and see how various functions are defined</p>",
        "id": 531174585,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753635291
    },
    {
        "content": "<p>which would naturally include the Fibonacci</p>",
        "id": 531174603,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753635297
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.fib#doc\">docs#Nat.fib</a> is defined with some stream iterator to make it more efficient</p>",
        "id": 531175326,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753635591
    },
    {
        "content": "<p>don't know why they couldn't have just used a <code>@[csimp]</code> lemma</p>",
        "id": 531175379,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753635607
    },
    {
        "content": "<p>what doe this mean</p>",
        "id": 531175482,
        "sender_full_name": "Quinn La Fond",
        "timestamp": 1753635645
    },
    {
        "content": "<p>you'll have to be a bit more specific</p>",
        "id": 531175526,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753635662
    },
    {
        "content": "<p>wow I checked to source and it's not even a stream iterator</p>",
        "id": 531175711,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753635722
    },
    {
        "content": "<p>the docstring is outdated</p>",
        "id": 531175729,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753635728
    },
    {
        "content": "<p>Kenny stated I should look at how the Fibonacci sequence is defined in library, you then remarked that Nat.fib is defined with some stream iterator; why the remark?</p>",
        "id": 531175737,
        "sender_full_name": "Quinn La Fond",
        "timestamp": 1753635731
    },
    {
        "content": "<p>it's not the most obvious choice</p>",
        "id": 531175823,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753635768
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"927532\">@Quinn La Fond</span> look at <a href=\"https://github.com/leanprover/lean4/blob/30ceb3260d7d7536092fedff969b4b2e8de7f942/src/Init/Prelude.lean#L1678-L1687\">Nat.add</a> then</p>",
        "id": 531176095,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753635864
    },
    {
        "content": "<p>(and try to ignore the <code>@&amp;</code>)</p>",
        "id": 531176185,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753635893
    },
    {
        "content": "<p>Hmm, so should I be defining my LTSeries as function outside of the lemma I am trying to prove?</p>",
        "id": 531176579,
        "sender_full_name": "Quinn La Fond",
        "timestamp": 1753636037
    },
    {
        "content": "<p>yes definitely</p>",
        "id": 531176607,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753636049
    },
    {
        "content": "<p>Ok and so the naive idea is something like:</p>\n<p>def  f : Fin( Nat.card T) \\rightarrow \\beta <br>\n |zero =&gt; minimal element of T <br>\n |succ b =&gt; minimal elment of T\\ {f(b),\\dots, f(0)}</p>\n<p>I need to specify that \\beta is partially ordered, and that T is a finite nonempty chain, and it looks like I can declare these things before the colon as I would with a lemma. Am I allowed to prove things inside this def though? I tried using an rcases tactic to get a minimal element of T but lean yelled at me...</p>",
        "id": 531177803,
        "sender_full_name": "Quinn La Fond",
        "timestamp": 1753636475
    },
    {
        "content": "<p>you can't use <code>rcases</code> here since you're creating data</p>",
        "id": 531177887,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753636503
    },
    {
        "content": "<p>try <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Exists.choose#doc\">docs#Exists.choose</a> instead</p>",
        "id": 531177922,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753636511
    },
    {
        "content": "<p>Should I not be using an := by after the def f : Fin (Nat.card T) \\rightarrow \\beta?</p>",
        "id": 531179637,
        "sender_full_name": "Quinn La Fond",
        "timestamp": 1753637144
    },
    {
        "content": "<p>you generally shouldn't use tactics in defs</p>",
        "id": 531181017,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753637655
    },
    {
        "content": "<p>the reason is because since you are making data you care about which data you end up making, and when using tactics you don't get to control what they output</p>",
        "id": 531181188,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753637719
    },
    {
        "content": "<p>I see. How do I get the minimum the set T inductively then? Do I specify such a hypothesis?</p>",
        "id": 531181982,
        "sender_full_name": "Quinn La Fond",
        "timestamp": 1753638036
    },
    {
        "content": "<p>you should prove a theorem saying that there exists a minimum and then choose one out noncomputably</p>",
        "id": 531182098,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753638074
    },
    {
        "content": "<p>in order to get it computably you will need a few more assumptions</p>",
        "id": 531182260,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753638139
    },
    {
        "content": "<p>I mean there is a theorem already written because T is a chain. T_finite.exists_minmal T_Nonempty gives the the hypothesis exists minimal element of T.</p>",
        "id": 531182354,
        "sender_full_name": "Quinn La Fond",
        "timestamp": 1753638177
    },
    {
        "content": "<p>great</p>",
        "id": 531182383,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753638187
    },
    {
        "content": "<p>now use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Exists.choose#doc\">docs#Exists.choose</a> to choose one out</p>",
        "id": 531182407,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753638196
    },
    {
        "content": "<p>How does that syntax work without tactics? like naively I want to do H :=T_finite.exists_minmal T_Nonempty and then apply Exists.choose at H.</p>",
        "id": 531182575,
        "sender_full_name": "Quinn La Fond",
        "timestamp": 1753638265
    },
    {
        "content": "<p>how about <code>let H := (T_finite.exists_minimal T_Nonempty).choose</code></p>",
        "id": 531182715,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753638319
    },
    {
        "content": "<p>does that work for you</p>",
        "id": 531182732,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753638325
    },
    {
        "content": "<p>This worked:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">order_chain</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PartialOrder</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T_chain</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsChain</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">T_finite</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">Finite</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T_nonempty</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">Nonempty</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">T_finite</span><span class=\"bp\">.</span><span class=\"n\">exists_minimal</span><span class=\"w\"> </span><span class=\"n\">T_nonempty</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">choose</span>\n</code></pre></div>\n<p>I am not sure if this the best way forward though...</p>",
        "id": 531183183,
        "sender_full_name": "Quinn La Fond",
        "timestamp": 1753638508
    },
    {
        "content": "<p>I have to run, but  I will be back in an hour or two. Thank you for all the help.</p>",
        "id": 531183239,
        "sender_full_name": "Quinn La Fond",
        "timestamp": 1753638531
    },
    {
        "content": "<p>What do you think of the zero case?</p>",
        "id": 531197590,
        "sender_full_name": "Quinn La Fond",
        "timestamp": 1753644183
    },
    {
        "content": "<p>I would need a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a></p>",
        "id": 531197639,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753644201
    },
    {
        "content": "<p>Hmm, what would that look like in this case?</p>",
        "id": 531197864,
        "sender_full_name": "Quinn La Fond",
        "timestamp": 1753644291
    },
    {
        "content": "<p>Like in particular, if I do not know how to finish the rest of the construction yet, what is a minimum working example?</p>",
        "id": 531198057,
        "sender_full_name": "Quinn La Fond",
        "timestamp": 1753644369
    },
    {
        "content": "<p>just <code>sorry</code> out the rest</p>",
        "id": 531198327,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753644474
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">order_chain</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PartialOrder</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T_chain</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsChain</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">T_finite</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">Finite</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T_nonempty</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">Nonempty</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">T_finite</span><span class=\"bp\">.</span><span class=\"n\">exists_minimal</span><span class=\"w\"> </span><span class=\"n\">T_nonempty</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">choose</span>\n</code></pre></div>\n<p>For some reason sorry doesn't help but if I just look at Fin(1) instead this works I think</p>",
        "id": 531199243,
        "sender_full_name": "Quinn La Fond",
        "timestamp": 1753644850
    },
    {
        "content": "<p>you're missing imports</p>",
        "id": 531199342,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753644888
    },
    {
        "content": "<p>oh right:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">PrimeSpectrum</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Order</span>\n<span class=\"kn\">noncomputable</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">order_chain</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PartialOrder</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T_chain</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsChain</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">T_finite</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">Finite</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T_nonempty</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">Nonempty</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">T_finite</span><span class=\"bp\">.</span><span class=\"n\">exists_minimal</span><span class=\"w\"> </span><span class=\"n\">T_nonempty</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">choose</span>\n</code></pre></div>",
        "id": 531199719,
        "sender_full_name": "Quinn La Fond",
        "timestamp": 1753645059
    },
    {
        "content": "<p>Oh I think this how I should sorry out the rest:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">PrimeSpectrum</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Order</span>\n<span class=\"kn\">noncomputable</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">order_chain</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PartialOrder</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T_chain</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsChain</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">T_finite</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">Finite</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">card_T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T_nonempty</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">Nonempty</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_⟩</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">T_finite</span><span class=\"bp\">.</span><span class=\"n\">exists_minimal</span><span class=\"w\"> </span><span class=\"n\">T_nonempty</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">choose</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_⟩</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 531200737,
        "sender_full_name": "Quinn La Fond",
        "timestamp": 1753645487
    },
    {
        "content": "<p>oh yeah so far it's good</p>",
        "id": 531200878,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753645540
    },
    {
        "content": "<p>but matching on <code>Fin</code> like that is not something I would recommend if you're going to make it recursive</p>",
        "id": 531200950,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753645570
    },
    {
        "content": "<p>Why not/what do you mean</p>",
        "id": 531200988,
        "sender_full_name": "Quinn La Fond",
        "timestamp": 1753645587
    },
    {
        "content": "<p>since it will force you to do well-founded recursion</p>",
        "id": 531201029,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753645604
    },
    {
        "content": "<p>what does that mean</p>",
        "id": 531201100,
        "sender_full_name": "Quinn La Fond",
        "timestamp": 1753645630
    },
    {
        "content": "<p>I don't really have another option an LTSeries S is a function from Fin(length)\\rightarrow to Beta</p>",
        "id": 531201192,
        "sender_full_name": "Quinn La Fond",
        "timestamp": 1753645670
    },
    {
        "content": "<p>I would suggest you use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fin.induction#doc\">docs#Fin.induction</a> instead</p>",
        "id": 531201241,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753645690
    },
    {
        "content": "<p>OK, how do I change my zero case to use Fin.induction?</p>",
        "id": 531201504,
        "sender_full_name": "Quinn La Fond",
        "timestamp": 1753645806
    },
    {
        "content": "<p>unfortunately I don't think it will work in this case</p>",
        "id": 531201664,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753645870
    },
    {
        "content": "<p>how about currying it and doing <code>(n : Nat) → n &lt; Nat.card T → β</code> instead?</p>",
        "id": 531201749,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753645911
    },
    {
        "content": "<p>I still don't understand what is wrong. If I can prove some generalization of exists_minimal for T\\{b_0,\\dots, b_i} for all i &lt; n, and any b_i it should be fine right?</p>",
        "id": 531201783,
        "sender_full_name": "Quinn La Fond",
        "timestamp": 1753645924
    },
    {
        "content": "<p>the problem is it won't reduce definitionally</p>",
        "id": 531201819,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753645940
    },
    {
        "content": "<p>this causes trouble sometimes so I try to avoid it if possible</p>",
        "id": 531201870,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753645965
    },
    {
        "content": "<p>What do you mean currying it? And what do you mean it won't reduce definitionally?</p>",
        "id": 531201885,
        "sender_full_name": "Quinn La Fond",
        "timestamp": 1753645970
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">PrimeSpectrum</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Order</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">set_diff_finite</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PartialOrder</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T_finite</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">Finite</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">T_finite</span><span class=\"bp\">.</span><span class=\"n\">subset</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">hx</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"o\">)</span>\n\n\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">strict_set_diff_nonempty</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PartialOrder</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T_finite</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">Finite</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S_subset_T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">S_strict</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">set_diff_finite</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">T_finite</span><span class=\"w\"> </span><span class=\"n\">S</span>\n<span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">S_finite</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">T_finite</span><span class=\"bp\">.</span><span class=\"n\">subset</span><span class=\"w\"> </span><span class=\"n\">S_subset_T</span>\n<span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">ncard_diff</span><span class=\"w\"> </span><span class=\"n\">S_subset_T</span><span class=\"w\"> </span><span class=\"n\">S_finite</span>\n<span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">S_strict</span>\n<span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">sub_pos_of_lt</span><span class=\"w\"> </span><span class=\"n\">S_strict</span>\n<span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h2</span>\n<span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[(</span><span class=\"n\">T</span><span class=\"bp\">\\</span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ncard_pos</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h2</span>\n\n<span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h2</span>\n\n<span class=\"kn\">noncomputable</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">order_set</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PartialOrder</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">--(T_chain : IsChain (· &lt; ·) T)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">T_finite</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">Finite</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">card_T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T_nonempty</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">Nonempty</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">T</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_⟩</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T_finite</span><span class=\"bp\">.</span><span class=\"n\">exists_minimal</span><span class=\"w\"> </span><span class=\"n\">T_nonempty</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">choose</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T_finite</span><span class=\"bp\">.</span><span class=\"n\">exists_minimal</span><span class=\"w\"> </span><span class=\"n\">T_nonempty</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">choose_spec</span><span class=\"bp\">.</span><span class=\"m\">1</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hm</span><span class=\"bp\">⟩</span>\n\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">),</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">order_set</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">T_finite</span><span class=\"w\"> </span><span class=\"n\">card_T</span><span class=\"w\"> </span><span class=\"n\">T_nonempty</span>\n<span class=\"w\">    </span><span class=\"bp\">⟨</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">,</span><span class=\"w\">  </span><span class=\"n\">lt_trans</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">is_lt</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">)</span><span class=\"bp\">=</span><span class=\"n\">b</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">S_eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">({</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">),</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">order_set</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">T_finite</span><span class=\"w\"> </span><span class=\"n\">card_T</span><span class=\"w\"> </span><span class=\"n\">T_nonempty</span>\n<span class=\"w\">    </span><span class=\"bp\">⟨</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">,</span><span class=\"w\">  </span><span class=\"n\">lt_trans</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">is_lt</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">)</span><span class=\"bp\">=</span><span class=\"n\">b</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">tauto</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">TS_finite</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">set_diff_finite</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">T_finite</span><span class=\"w\"> </span><span class=\"n\">S</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">S_subset_T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">hx</span>\n<span class=\"w\">      </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">S_eq</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hx</span>\n<span class=\"w\">      </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hx</span>\n<span class=\"w\">      </span><span class=\"n\">rcases</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">i_mapto_x</span><span class=\"w\"> </span><span class=\"bp\">⟩</span>\n<span class=\"w\">      </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">i_mapto_x</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"n\">simp</span>\n\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">S_strict</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">        </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">order_set</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">T_finite</span><span class=\"w\"> </span><span class=\"n\">card_T</span><span class=\"w\"> </span><span class=\"n\">T_nonempty</span>\n<span class=\"w\">        </span><span class=\"bp\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">lt_trans</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">is_lt</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"bp\">⟩</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"m\">1</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">S_eq'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">image</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">        </span><span class=\"n\">simp</span>\n<span class=\"w\">        </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">c</span>\n<span class=\"w\">        </span><span class=\"n\">constructor</span>\n<span class=\"w\">        </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">cin</span>\n<span class=\"w\">        </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">S_eq</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">cin</span>\n<span class=\"w\">        </span><span class=\"n\">tauto</span>\n<span class=\"w\">        </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">cin</span>\n<span class=\"w\">        </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">S_eq</span><span class=\"o\">]</span>\n<span class=\"w\">        </span><span class=\"n\">tauto</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">S_card_le_a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\">  </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"k\">by</span>\n<span class=\"w\">        </span><span class=\"n\">simp</span>\n<span class=\"w\">        </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">S_eq'</span><span class=\"o\">]</span>\n<span class=\"w\">        </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">)))</span><span class=\"bp\">.</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">          </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">infer_instance</span>\n<span class=\"w\">          </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">finite_univ_iff</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">        </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">card_image_le</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:=</span><span class=\"n\">g</span><span class=\"o\">)</span>\n<span class=\"w\">        </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">          </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">        </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h1</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">H</span>\n<span class=\"w\">        </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">H</span>\n<span class=\"w\">        </span><span class=\"n\">simp</span>\n<span class=\"w\">        </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">H</span>\n\n<span class=\"w\">      </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">LE</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"bp\">.</span><span class=\"n\">trans_lt</span><span class=\"w\"> </span><span class=\"n\">S_card_le_a</span><span class=\"w\"> </span><span class=\"n\">ha</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">TS_nonempty</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\">   </span><span class=\"n\">strict_set_diff_nonempty</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">T_finite</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">S_subset_T</span><span class=\"w\"> </span><span class=\"n\">S_strict</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">TS_finite</span><span class=\"bp\">.</span><span class=\"n\">exists_minimal</span><span class=\"w\"> </span><span class=\"n\">TS_nonempty</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">choose</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">\\</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">TS_finite</span><span class=\"bp\">.</span><span class=\"n\">exists_minimal</span><span class=\"w\"> </span><span class=\"n\">TS_nonempty</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">choose_spec</span><span class=\"bp\">.</span><span class=\"m\">1</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hm</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hmin</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"n\">rcases</span><span class=\"w\"> </span><span class=\"n\">hm</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"w\"> </span><span class=\"n\">alpha</span><span class=\"w\"> </span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">beta</span><span class=\"bp\">⟩</span>\n<span class=\"w\">      </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">alpha</span>\n\n\n\n\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hmin</span><span class=\"w\"> </span><span class=\"bp\">⟩</span>\n</code></pre></div>\n<p>Is it not recommended to use tactics like this ? I tried my best to figure out how to write this but at the end of the day I fell back into what I was more comfortable with. At the moment it seems like it will do what I want it to do, but I guess we will see later when I have try and post compose with inclusion function into beta (is this something I can do?)</p>",
        "id": 531278742,
        "sender_full_name": "Quinn La Fond",
        "timestamp": 1753681034
    },
    {
        "content": "<p>If you're just doing <code>let</code> and <code>have</code> then the tactics aren't buying you anything since term mode also have those</p>",
        "id": 531325857,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753696991
    },
    {
        "content": "<p>Well I use exact at the end and simp a couple of times</p>\n<p>Also if I don't have by then the hypotheses from have don't show up on the right side of the screen</p>",
        "id": 531401818,
        "sender_full_name": "Quinn La Fond",
        "timestamp": 1753717359
    },
    {
        "content": "<p>oh don't use <code>simp</code></p>",
        "id": 531402301,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753717494
    },
    {
        "content": "<p>that's not good</p>",
        "id": 531402311,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753717496
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"927532\">Quinn La Fond</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Chains.20to.20LTSeries/near/531401818\">said</a>:</p>\n<blockquote>\n<p>Also if I don't have by then the hypotheses from have don't show up on the right side of the screen</p>\n</blockquote>\n<p>This usually means you cursor is not in the right place</p>",
        "id": 531402383,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753717520
    },
    {
        "content": "<p>Why is simp bad?</p>",
        "id": 531402517,
        "sender_full_name": "Quinn La Fond",
        "timestamp": 1753717563
    },
    {
        "content": "<p>it gives you casts</p>",
        "id": 531402585,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753717581
    },
    {
        "content": "<p>Is it ok to use simp when proving the have statements</p>",
        "id": 531402609,
        "sender_full_name": "Quinn La Fond",
        "timestamp": 1753717589
    },
    {
        "content": "<p>only use <code>simp</code> if the type of your goal is <code>Prop</code></p>",
        "id": 531402761,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753717639
    },
    {
        "content": "<p>for example if your goal is <code>⊢ a = b</code> then it's okay to use <code>simp</code></p>",
        "id": 531402823,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753717659
    },
    {
        "content": "<p>ok I actually didnt need the simp at all so I removed it</p>",
        "id": 531402977,
        "sender_full_name": "Quinn La Fond",
        "timestamp": 1753717700
    },
    {
        "content": "<p>if your goal is <code>⊢ Fin (m + n)</code> then don't use <code>simp</code></p>",
        "id": 531403045,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753717721
    },
    {
        "content": "<p>ok that makes sense I think</p>",
        "id": 531403159,
        "sender_full_name": "Quinn La Fond",
        "timestamp": 1753717760
    },
    {
        "content": "<p>So I am now running into the problem that when I call the function I defined, I can't access the hypothesis that that the value of this function is a minimum of some subset of T. is there a way to get this after using .choose?</p>",
        "id": 531973150,
        "sender_full_name": "Quinn La Fond",
        "timestamp": 1753933191
    },
    {
        "content": "<p>Would be easier if you had a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>, but from just reading your question the answer should be <code>.choose_spec</code></p>",
        "id": 531990870,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1753943300
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">PrimeSpectrum</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Order</span>\n<span class=\"kn\">noncomputable</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">order_chain</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PartialOrder</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T_chain</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsChain</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">T_finite</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">Finite</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T_nonempty</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">Nonempty</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">T_finite</span><span class=\"bp\">.</span><span class=\"n\">exists_minimal</span><span class=\"w\"> </span><span class=\"n\">T_nonempty</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">choose</span>\n</code></pre></div>\n<p>If I define the above function, then given a finite nonempty chain T, something like </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">rcases</span><span class=\"w\"> </span><span class=\"n\">order_chain</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">T_chain</span><span class=\"w\"> </span><span class=\"n\">T_finite</span><span class=\"w\"> </span><span class=\"n\">T_nonempty</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"bp\">\\&lt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">\\&gt;</span>\n</code></pre></div>\n<p>gives the hypothesis a : Beta, b : a \\in T, but I don't get any hypotheses of the form  Minimal (fun x ↦ x ∈ T) a</p>",
        "id": 532159746,
        "sender_full_name": "Quinn La Fond",
        "timestamp": 1753992725
    },
    {
        "content": "<p>In particular I cannot change .choose to .choose_spec because then I don't have the element Beta, I have the element in beta+something else.</p>",
        "id": 532183327,
        "sender_full_name": "Quinn La Fond",
        "timestamp": 1754002995
    },
    {
        "content": "<p>The above wasn't quite a MWE <span aria-label=\"sweat\" class=\"emoji emoji-1f613\" role=\"img\" title=\"sweat\">:sweat:</span> Is the following one accurate?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PartialOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PartialOrder</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span>\n\n<span class=\"kn\">noncomputable</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">order_chain</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T_finite</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">Finite</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T_nonempty</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">Nonempty</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T_finite</span><span class=\"bp\">.</span><span class=\"n\">exists_minimal</span><span class=\"w\"> </span><span class=\"n\">T_nonempty</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">choose</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T_finite</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">Finite</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T_nonempty</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">Nonempty</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rcases</span><span class=\"w\"> </span><span class=\"n\">order_chain</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">T_finite</span><span class=\"w\"> </span><span class=\"n\">T_nonempty</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Minimal</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">trivial</span>\n</code></pre></div>",
        "id": 532235616,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1754030096
    },
    {
        "content": "<p>If so, then indeed you won't be able to fill in that <code>sorry</code></p>",
        "id": 532235684,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1754030121
    },
    {
        "content": "<p>Why did you write T : Set (\\alpha \\times Beta)?</p>",
        "id": 532334464,
        "sender_full_name": "Quinn La Fond",
        "timestamp": 1754063785
    },
    {
        "content": "<p>Oh I see, my \\&lt; a , b\\&gt; is a : N and b : a &lt;1 which are the necessary hypotheses to feed something to Fin 1.</p>",
        "id": 532340166,
        "sender_full_name": "Quinn La Fond",
        "timestamp": 1754065817
    },
    {
        "content": "<p>you can use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.orderIsoOfFin#doc\">docs#Finset.orderIsoOfFin</a> on the subtype of your chain which is a linear order</p>",
        "id": 532345688,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754067720
    },
    {
        "content": "<p>Is this a different approach than defining my function from Fin (Nat.card T)\\rightarrow Beta?</p>",
        "id": 532352927,
        "sender_full_name": "Quinn La Fond",
        "timestamp": 1754070644
    },
    {
        "content": "<p>well you get an order isomorphism instead</p>",
        "id": 532352979,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754070668
    },
    {
        "content": "<p>My beta is a partial order thought not a linear order.</p>",
        "id": 532357697,
        "sender_full_name": "Quinn La Fond",
        "timestamp": 1754072569
    },
    {
        "content": "<p>the subtype of your chain is a linear order</p>",
        "id": 532357753,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754072589
    },
    {
        "content": "<p>I see so this would give me a function Fin Nat.card T \\rightarrow T?</p>",
        "id": 532360857,
        "sender_full_name": "Quinn La Fond",
        "timestamp": 1754074008
    },
    {
        "content": "<p>Is there not a way to just carry this hypothesis with me though? Like it seems odd to me that wit the expression  (something).choose I can't access the propositions of that something.</p>",
        "id": 532369154,
        "sender_full_name": "Quinn La Fond",
        "timestamp": 1754077607
    },
    {
        "content": "<p>can you provide a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>?</p>",
        "id": 532369192,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754077626
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PartialOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PartialOrder</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span>\n\n<span class=\"kn\">noncomputable</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">order_chain</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T_finite</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">Finite</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T_nonempty</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">Nonempty</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T_finite</span><span class=\"bp\">.</span><span class=\"n\">exists_minimal</span><span class=\"w\"> </span><span class=\"n\">T_nonempty</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">choose</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T_finite</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">Finite</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T_nonempty</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">Nonempty</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rcases</span><span class=\"w\"> </span><span class=\"n\">order_chain</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">T_finite</span><span class=\"w\"> </span><span class=\"n\">T_nonempty</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Minimal</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">trivial</span>\n</code></pre></div>\n<p>I am essentially just trying to fill in that sorry, but the only hypothesis (T_finite.exists_minimal T_nonempty).choose gives me is that a \\in beta.</p>",
        "id": 532369689,
        "sender_full_name": "Quinn La Fond",
        "timestamp": 1754077894
    },
    {
        "content": "<p>the problem is <code>rcases</code> forgets the value you pass it</p>",
        "id": 532369797,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754077954
    },
    {
        "content": "<p>you should use <code>let</code> instead</p>",
        "id": 532369809,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754077959
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PartialOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PartialOrder</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span>\n\n<span class=\"kn\">noncomputable</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">order_chain</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T_finite</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">Finite</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T_nonempty</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">Nonempty</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T_finite</span><span class=\"bp\">.</span><span class=\"n\">exists_minimal</span><span class=\"w\"> </span><span class=\"n\">T_nonempty</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">choose</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T_finite</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">Finite</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T_nonempty</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">Nonempty</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">order_chain</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">T_finite</span><span class=\"w\"> </span><span class=\"n\">T_nonempty</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">a_eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">order_chain</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">T_finite</span><span class=\"w\"> </span><span class=\"n\">T_nonempty</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">tauto</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Minimal</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">   </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">order_chain</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">a_eq</span>\n<span class=\"w\">   </span><span class=\"gr\">sorry</span>\n\n<span class=\"w\">  </span><span class=\"n\">trivial</span>\n</code></pre></div>\n<p>So this gives me that a= (T_finite.exists_minimal T_nonempty).choose, but how I don't how to access the hypothesis that a is now minimal with respect T.</p>",
        "id": 532370240,
        "sender_full_name": "Quinn La Fond",
        "timestamp": 1754078166
    },
    {
        "content": "<p>it's <code>(T_finite.exists_minimal T_nonempty).choose_spec</code></p>",
        "id": 532370298,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754078208
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PartialOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PartialOrder</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span>\n\n<span class=\"kn\">noncomputable</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">order_chain</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T_finite</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">Finite</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T_nonempty</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">Nonempty</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T_finite</span><span class=\"bp\">.</span><span class=\"n\">exists_minimal</span><span class=\"w\"> </span><span class=\"n\">T_nonempty</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">choose</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T_finite</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">Finite</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T_nonempty</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">Nonempty</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">order_chain</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">T_finite</span><span class=\"w\"> </span><span class=\"n\">T_nonempty</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">a_eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">order_chain</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">T_finite</span><span class=\"w\"> </span><span class=\"n\">T_nonempty</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">tauto</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Minimal</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">   </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">order_chain</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">a_eq</span>\n<span class=\"w\">   </span><span class=\"n\">exact</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">T_finite</span><span class=\"bp\">.</span><span class=\"n\">exists_minimal</span><span class=\"w\"> </span><span class=\"n\">T_nonempty</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">choose_spec</span>\n\n\n<span class=\"w\">  </span><span class=\"n\">trivial</span>\n</code></pre></div>\n<p>I don't totally understand why this works...like how does lean know that a is the same as this arbitrary (T_finite.exists_minimal T_nonempty).choose_spec?</p>",
        "id": 532370502,
        "sender_full_name": "Quinn La Fond",
        "timestamp": 1754078292
    },
    {
        "content": "<p>because a <code>let</code> variable is definitionally equal to its value</p>",
        "id": 532370565,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754078323
    },
    {
        "content": "<p>You can try <code>#check (T_finite.exists_minimal T_nonempty).choose_spec</code> to see its type</p>",
        "id": 532370615,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754078349
    },
    {
        "content": "<p>ok thank you i think that makes sense.</p>",
        "id": 532370678,
        "sender_full_name": "Quinn La Fond",
        "timestamp": 1754078381
    }
]