[
    {
        "content": "<p>Hopefully I'm not opening Pandora's box here, but I think we have somewhat of an unfortunate situation around unbundled relation typeclasses. Instead of having one single spelling, we seem to have three spellings used throughout different parts of Lean/Mathlib.</p>\n<p>a) What appears to be the most common one, the <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsRefl#doc\">docs#IsRefl</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsIrrefl#doc\">docs#IsIrrefl</a>, etc. typeclasses defined in <code>Mathlib.Order.Defs.Unbundled</code>.<br>\nb) The predicates <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Reflexive#doc\">docs#Reflexive</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Irreflexive#doc\">docs#Irreflexive</a>, etc. also defined lower in the file, which see some but seemingly not nearly as much use.<br>\nc) The Core typeclasses <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.Refl#doc\">docs#Std.Refl</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.Irrefl#doc\">docs#Std.Irrefl</a>, etc. which see zero use in Mathlib.</p>\n<p>This became a particular annoyance to me recently, when I found out I couldn't use the new <code>List.le</code> lemmas in Core because there's no useful instances for the <code>Std</code> typeclasses they use.</p>",
        "id": 499843145,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1739572325
    },
    {
        "content": "<p>Personally I think the predicates from (b) can just be deprecated, since using a typeclass rather than a \"raw\" proposition provides useful functionality (for instance, one can use theorems about <code>List.sort (· &lt; ·)</code> or <code>List.sort (· ≤ ·)</code> and have transitivity inferred). Whether we replace the core predicates by the Mathlib ones or the other way around I don't really care for.</p>",
        "id": 499843841,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1739572654
    },
    {
        "content": "<p>I feel like this is also important for <a href=\"#narrow/channel/287929-mathlib4/topic/Simp.20turning.20.60.E2.89.A0.60.20into.20.60.C2.AC.20.3D.60\">#mathlib4 &gt; Simp turning &#96;≠&#96; into &#96;¬ =&#96;</a> if we want a <code>Not.symm</code> in core (for which we would have to have a <code>Std.Symm</code> class in core). I think due to how it was handled with <code>IsAssociative / Std.Associative</code> it's probably reasonable to move over to the <code>Std</code> variants and deprecate <code>IsRefl</code> / <code>IsSymm</code> / etc. Regarding b) we'd probably just want <code>Std.refl_iff</code> etc. and then the need for such predicates decreases significantly</p>",
        "id": 523905691,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1749806392
    },
    {
        "content": "<p>I think core would also be happy with having the <code>Is*</code> classes in core and deprecating the <code>Std.*</code> names if mathlib prefers that.</p>",
        "id": 523907979,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1749807174
    },
    {
        "content": "<p>Yeah you're right that would probably cause less impact on mathlib</p>",
        "id": 523908450,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1749807328
    },
    {
        "content": "<p>Hmm one relevant difference between them though is that <code>IsRefl</code> takes the type as a explicit parameter and <code>Std.Refl</code> as an implicit</p>",
        "id": 523910035,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1749807938
    }
]