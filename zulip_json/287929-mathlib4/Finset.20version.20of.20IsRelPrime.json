[
    {
        "content": "<p>In PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/33744\">#33744</a> I introduced a definition <code>CommonDivisorsAreUnits</code> for a finite set of elements in a monoid. Upon further review, I realized that this is simply the <code>Finset</code> analogue of <code>IsRelPrime</code>. I would therefore like to rename the definition to <code>Finset.IsRelPrime</code> and relocate it to a more appropriate file.</p>\n<p>I see two plausible options:</p>\n<ol>\n<li><code>Algebra.Divisibility.Units</code>, where <code>IsRelPrime</code> is currently defined;</li>\n<li>a new file <code>Algebra.Divisibility.Finset</code>.</li>\n</ol>\n<p>Which of these would be preferable, or is there a better alternative?</p>",
        "id": 567132890,
        "sender_full_name": "Boris Bilich",
        "timestamp": 1767962339
    },
    {
        "content": "<p><del>Is it just <code>s.Pairwise IsRelPrime</code>?</del> No, it's about having <code>s.gcd = 1</code> (but w/o <code>EuclideanDomain</code>).</p>",
        "id": 567133212,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1767962462
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/GCDMonoid/Finset.html#Finset.gcd\">Finset.gcd</a> does work for NormalizedGCDMonoid, a typeclass UFDs can be equipped with (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=instNonemptyNormalizedGCDMonoidOfUniqueFactorizationMonoid#doc\">docs#instNonemptyNormalizedGCDMonoidOfUniqueFactorizationMonoid</a>).</p>",
        "id": 567355330,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1768090251
    },
    {
        "content": "<p>But this <code>Finset.IsRelPrime</code> works for any monoid.</p>",
        "id": 567356314,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1768091836
    },
    {
        "content": "<ul>\n<li>I would define it for a <code>Set</code>, not just a <code>Finset</code>. You use no <code>Finset</code>-specific operations in the definition.</li>\n<li>I would underline in the name that it's not about being pairwise rel prime. I'm not sure what's the right way to do it.</li>\n</ul>",
        "id": 567356367,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1768091920
    },
    {
        "content": "<p>For the purpose of the PR, it seems to me that <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/GCDMonoid/Finset.html#Finset.gcd_mul_left\">Finset.gcd_mul_left</a> is good enough.</p>",
        "id": 567358725,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1768095794
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Finset.20version.20of.20IsRelPrime/near/567358725\">said</a>:</p>\n<blockquote>\n<p>For the purpose of the PR, it seems to me that <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/GCDMonoid/Finset.html#Finset.gcd_mul_left\">Finset.gcd_mul_left</a> is good enough.</p>\n</blockquote>\n<p>I followed you advice and discovered that my proof actually works now for <code>[NormalizedGCDMonoid R]</code> in place of <code>[UniqueFactorizationMonoid R]</code>. Therefore I now have a slightly more general theorem that says that the class group of a Normalized GCD Domain is trivial. I suspect that \"normalized\" can be dropped here but I am not sure how, everything in <code>Mathlib.Algebra.GCDMonoid.Finset</code> is assumed normalized for some reason that is not immediately clear to me.</p>",
        "id": 567375593,
        "sender_full_name": "Boris Bilich",
        "timestamp": 1768119797
    },
    {
        "content": "<p>Probably because the <code>Std.Commutative lcm</code> instance needs <code>NormalizedGCDMonoid</code></p>",
        "id": 567394087,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1768142539
    },
    {
        "content": "<p>So you need it to fold</p>",
        "id": 567394092,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1768142546
    },
    {
        "content": "<p>Requiring the normUnit to be a monoid homomorphism makes it sometimes impossible to put a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=NormalizationMonoid#doc\">docs#NormalizationMonoid</a> structure on a GCD monoid (see <a href=\"https://github.com/leanprover-community/mathlib3/pull/17984\">mathlib3#17984</a>). For this reason mathlib doesn't know that the polynomial ring over a GCD domain is a GCD domain even though <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/RingTheory/Polynomial/Content.html#Polynomial.normalizedGcdMonoid\">Polynomial.normalizedGcdMonoid</a> is there. I wonder if the condition is really necessary (maybe the normalization map being idempotent is good for most applications?). Now is probably a good time to investigate such questions again.</p>",
        "id": 567395213,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1768143667
    },
    {
        "content": "<p>Oh the correct condition is probably a <code>normalize</code> map that is a right inverse of the quotient map <code>M → Associates M</code>. I propose to rename the current NormalizationMonoid to StrongNormalizationMonoid and leave the original name for this condition, and provide an instance from the strong one to the weak one. It would be more convenient to attempt the refactoring after <a href=\"https://github.com/leanprover-community/mathlib4/pull/33851\">#33851</a>.</p>",
        "id": 567500347,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1768215671
    },
    {
        "content": "<p>In <a href=\"https://github.com/leanprover-community/mathlib4/pull/34179\">#34179</a> I continue the work of <span class=\"user-mention\" data-user-id=\"307953\">@Ruben Van de Velde</span> (2021) in <a href=\"https://github.com/leanprover-community/mathlib3/pull/9443\">mathlib3#9443</a> and replace the two conditions</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">normUnit_mul</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">normUnit</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">normUnit</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">normUnit</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"w\">  </span><span class=\"n\">normUnit_coe_units</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"bp\">ˣ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">normUnit</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"bp\">⁻¹</span>\n</code></pre></div>\n<p>in the definition of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=NormalizationMonoid#doc\">docs#NormalizationMonoid</a> by</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">normUnit_one</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">normUnit</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"n\">normUnit_mul_units</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"bp\">ˣ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">normUnit</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"bp\">⁻¹</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">normUnit</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>\n<p>and rename the old version to StrongNormalizationMonoid. After this change, every cancellative monoid with zero admits a NormalizationMonoid structure, and every GCDMonoid admits a NormalizedGCDMonoid structure. As a consequence, mathlib finally knows that the polynomial ring over a GCD domain is a GCD domain:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Polynomial</span><span class=\"bp\">.</span><span class=\"n\">instGCDMonoid</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">GCDMonoid</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">GCDMonoid</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Even though one can't generalize <code>Multiset/Finset.gcd</code> to <code>GCDMonoid</code>s (it's easy to make <code>gcd</code> commutative by choosing a right inverse to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Sym2.mk#doc\">docs#Sym2.mk</a>, but associativity is also needed for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Multiset.fold#doc\">docs#Multiset.fold</a> and can't be easily achieved without normalization), we can put an arbitrary <code>NormalizedGCDMonoid</code> structure on any <code>GCDMonoid</code> in order to make use of <code>Finset.gcd</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">letI</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">arbitrary</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">NormalizedGCDMonoid</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and in <a href=\"https://github.com/leanprover-community/mathlib4/pull/33744\">#33744</a>, this should be enough to establish the trivial class group result to arbitrary GCDMonoids.</p>",
        "id": 568161724,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1768470030
    },
    {
        "content": "<p>Huh, I completely forgot I tried that</p>",
        "id": 568162232,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1768470156
    },
    {
        "content": "<p>I found it via Mathlib Changelog when I tried to track down why NormalizationMonoid was so defined :) It was <a href=\"https://github.com/leanprover-community/mathlib3/pull/233\">mathlib3#233</a> in 2018.</p>",
        "id": 568164387,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1768470720
    }
]