[
    {
        "content": "<p>Consider the following experiment:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">ModelTheory</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Combinatorics</span><span class=\"bp\">.</span><span class=\"n\">Quiver</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">γ</span><span class=\"w\"> </span><span class=\"n\">δ</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">γ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">δ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bad_x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">γ</span><span class=\"o\">)(</span><span class=\"n\">bad_y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">δ</span><span class=\"o\">)(</span><span class=\"n\">good_x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)(</span><span class=\"n\">good_y</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">proof_good</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">bad_x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">good_x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">bad_y</span>\n<span class=\"c\">/-</span><span class=\"cm\"> prints ↑(f good_x) = bad_y: Prop ; automatic coercion of a type to its</span>\n<span class=\"cm\">   universe. -/</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">bad_x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">good_y</span>\n<span class=\"c\">/-</span><span class=\"cm\"> Application mismatch at bad_x-/</span>\n</code></pre></div>\n<p>I wonder if there is a coercion operator that, <br>\ngiven <code>proof_good: bad_x ∈ S</code>, coerces <code>bad_x : γ</code> to something like a \"<code>↓bad_x : S</code>\"<br>\nso that type checking <code>check f ↓bad_x = good_y</code> passes . <br>\nI searched the documentation with key words like <code>mem coe</code> but did not<br>\nfind something that does this job. </p>\n<p>Could someone please help me with this? Thanks a lot in advance!</p>",
        "id": 448704908,
        "sender_full_name": "Shaopeng",
        "timestamp": 1719955181
    },
    {
        "content": "<p><code>S</code> is a term, not a type. When you treat it as a type by writing <code>good_x: S</code> (which is arguably not advisable if you can avoid it) Lean creates a new type <code>↑S</code> (a so-called subtype). A term of this type is a pair <code>⟨x, h⟩</code> with <code>x : γ</code> and <code>h : x ∈ S</code> (this is the preferred interface for working with elements of sets). So you could make your <code>↓bad_x</code> with <code>⟨bad_x, proof_good⟩</code>. Note that you can't hope for anything like <code>↓bad_x</code> to work directly, you need access to <code>proof_good</code> somehow.</p>\n<p>I'd say that \"automatic coercion of a type to its universe\" could more accurately be expressed as an automatic coercion from the subtype <code>↑T</code> to the type <code>δ</code></p>",
        "id": 448709379,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1719957177
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/.22Downward.22.20coercion.20upon.20proof.20of.20memberships.3F/near/448709379\">said</a>:</p>\n<blockquote>\n<p><code>S</code> is a term, not a type. When you treat it as a type by writing <code>good_x: S</code> (which is arguably not advisable if you can avoid it) Lean creates a new type <code>↑S</code> (a so-called subtype). A term of this type is a pair <code>⟨x, h⟩</code> with <code>x : γ</code> and <code>h : x ∈ S</code> (this is the preferred interface for working with elements of sets). So you could make your <code>↓bad_x</code> with <code>⟨bad_x, proof_good⟩</code>. Note that you can't hope for anything like <code>↓bad_x</code> to work directly, you need access to <code>proof_good</code> somehow.</p>\n<p>I'd say that \"automatic coercion of a type to its universe\" could more accurately be expressed as an automatic coercion from the subtype <code>↑T</code> to the type <code>δ</code></p>\n</blockquote>\n<p>Thank you so much for your clear explanation and remarks, Professor Buzzard. Understood! <br>\nAnd will use <code>good_x: ↑S</code> etc in the future:)</p>",
        "id": 448711272,
        "sender_full_name": "Shaopeng",
        "timestamp": 1719958030
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/.22Downward.22.20coercion.20upon.20proof.20of.20memberships.3F/near/448709379\">said</a>:</p>\n<blockquote>\n<p>Note that you can't hope for anything like <code>↓bad_x</code> to work directly, you need access to <code>proof_good</code> somehow.</p>\n</blockquote>\n<p>you might somehow make lean try to infer it from context? some kind of elaborator/macro/notation magic?</p>",
        "id": 448794290,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1719997461
    },
    {
        "content": "<p>I believe Iris does some fancy proof inference - albeit on their own logic with only limited properties and on limited examples. But I think inferring the proof is what would be needed to make the 'downcoercing' work.</p>",
        "id": 449129918,
        "sender_full_name": "Ira Fesefeldt",
        "timestamp": 1720111744
    },
    {
        "content": "<p>what i meant was that you might be able to write a macro meaning <code>(⟨x,‹x ∈ s›⟩:s)</code>, which tells lean to look for the proof in the current context, not generate the proof on the fly</p>",
        "id": 449131457,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1720112311
    },
    {
        "content": "<p>the notation doesn't need to know that the proof exists, so you can still have <code>↓bad_x</code></p>",
        "id": 449131611,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1720112387
    },
    {
        "content": "<p>Ah, I see. Fair enough.</p>",
        "id": 449131701,
        "sender_full_name": "Ira Fesefeldt",
        "timestamp": 1720112407
    },
    {
        "content": "<p>although i do suppose getting lean to pick <code>s</code> to be the expected type might need something stronger than just a macro...</p>",
        "id": 449132017,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1720112506
    },
    {
        "content": "<p>Thanks a lot for the followup discussion, Edward and Ira!</p>",
        "id": 449234011,
        "sender_full_name": "Shaopeng",
        "timestamp": 1720163230
    }
]