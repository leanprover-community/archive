[
    {
        "content": "<p>In  informal categoric reasoning, we often reason via UP. </p>\n<p>Say, to prove FF of the embedding <code>Cat A B  ⥤ Dist A B</code>,  where given functors <code>F  G : A ⥤ B</code> we have set isomorphisms<br>\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi><mi>a</mi><mi>t</mi><mo stretchy=\"false\">(</mo><mi>F</mi><mo separator=\"true\">,</mo><mi>G</mi><mo stretchy=\"false\">)</mo><mo>≃</mo><mi>E</mi><mi>n</mi><mi>d</mi><mtext> </mtext><mi>B</mi><mo stretchy=\"false\">(</mo><mi>F</mi><mo>−</mo><mo separator=\"true\">,</mo><mi>G</mi><mo>=</mo><mo stretchy=\"false\">)</mo><mo>≃</mo><mi>E</mi><mi>n</mi><mi>d</mi><mtext> </mtext><mo stretchy=\"false\">[</mo><msup><mi>B</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup><mo separator=\"true\">,</mo><mi>S</mi><mi>e</mi><mi>t</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">(</mo><mi>B</mi><mo stretchy=\"false\">(</mo><mo>−</mo><mo separator=\"true\">,</mo><mi>F</mi><mo>=</mo><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mi>B</mi><mo stretchy=\"false\">(</mo><mo>−</mo><mo separator=\"true\">,</mo><mi>G</mi><mo>=</mo><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo>≃</mo><mi>N</mi><mi>a</mi><mi>t</mi><mo stretchy=\"false\">(</mo><mi>B</mi><mo stretchy=\"false\">(</mo><mo>−</mo><mo separator=\"true\">,</mo><mi>F</mi><mo>=</mo><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mi>B</mi><mo stretchy=\"false\">(</mo><mo>−</mo><mo separator=\"true\">,</mo><mi>G</mi><mo>=</mo><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">Nat(F,G) ≃ End~ B(F-,G=) ≃ End ~[B^{op},Set](B(-,F=), B(-,G=))≃ Nat(B(-,F=),B(-,G=)) </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≃</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">d</span><span class=\"mspace nobreak\"> </span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord\">−</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≃</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">d</span><span class=\"mspace nobreak\"> </span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">t</span><span class=\"mclose\">]</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mopen\">(</span><span class=\"mord\">−</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mopen\">(</span><span class=\"mord\">−</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mclose\">))</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≃</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mopen\">(</span><span class=\"mord\">−</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mopen\">(</span><span class=\"mord\">−</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mclose\">))</span></span></span></span></p>\n<p>The first (and last) equivalence is a \"lie\" as terminal wedges are only defined up to iso, so <code>Nat(F,G)</code> is not equivalent to \"the\" end, but is <em>an</em> End. If we naively define <code>abbrev End :=  Σ w : Wedge F, Limits.IsTerminal w</code>, we actually have a set of ends, all of which are set-isomorphic to each other.</p>\n<p>So either  <code>Nat(F,G) ∈ End B(F-,G=)</code> or  <code>End</code> can be quotiented to get <code>Nat(F,G) ≃ Q(End B(F-,G=))</code></p>\n<p>Is there already some facility in Mathlib for such quotient where every path is an iso ?<br>\nIs it the prefered way to deal with UPs ?</p>\n<p>How to translate UP reasoning with the least amount of syntactic noise ?</p>",
        "id": 463602923,
        "sender_full_name": "Nicolas Rolland",
        "timestamp": 1724134123
    },
    {
        "content": "<p>If you have two objects in a contractible groupoid, then they admit a unique isomorphism between them.  Are you asking how to spell that in mathlib?</p>",
        "id": 463658966,
        "sender_full_name": "Scott Carnahan",
        "timestamp": 1724149608
    },
    {
        "content": "<p>I am asking if there is already some syntactic sugar, or boilerplate code, to make Lean expression look like informal category, where such kind of reasoning is everywhere.</p>\n<p>It relies on  contractible groupoid (+ some isos of, when chaining  such groupoids  equivalence ), but maybe there is already something plugged in, given how often we reason that way in category.</p>\n<p>Or not, and then wouldn't it make sense to have such facility ?</p>",
        "id": 463663037,
        "sender_full_name": "Nicolas Rolland",
        "timestamp": 1724151228
    }
]