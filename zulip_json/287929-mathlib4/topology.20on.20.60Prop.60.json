[
    {
        "content": "<p>Why is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=sierpinskiSpace#doc\">docs#sierpinskiSpace</a> the default topological space on <code>Prop</code>? This makes the topology on <code>Prop</code> different from the topology on <code>Bool</code>. This just seems to me like a bad idea.</p>\n<p>In <code>Prop</code>, <code>{True}</code> is open and <code>{False}</code> is closed. <code>univ</code> and <code>∅</code> are clopen.<br>\nIn <code>Bool</code>, all sets are clopen.</p>",
        "id": 503683974,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741231665
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=continuous_empty_function#doc\">docs#continuous_empty_function</a> right next to it is weird too. It assumes the codomain is empty, when the same result holds assuming the domain is empty.</p>",
        "id": 503684130,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741231762
    },
    {
        "content": "<p>The sierpinski topology is the one where the continuous sets (as indicator functions) are the open sets.</p>",
        "id": 503685265,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741232451
    },
    {
        "content": "<p>I think the topology on Bool is instead the one that makes its recursor continuous (at least the non-dependent one).</p>",
        "id": 503685607,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741232691
    },
    {
        "content": "<p>Is there any part of the library which is using either of these topologies?</p>",
        "id": 503718634,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1741245870
    },
    {
        "content": "<p>I can't remember the use of it, but <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=TopologicalSpace.productOfMemOpens_isEmbedding#doc\">docs#TopologicalSpace.productOfMemOpens_isEmbedding</a> is kind of neat. Each T0 space <code>X</code> embeds into <code>Opens X -&gt; Prop</code>, where, thinking of <code>Opens X -&gt; Prop</code> as <code>Set (Opens X)</code>, the embedding sends each point to its open neighborhood filter.</p>",
        "id": 503722456,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741247016
    },
    {
        "content": "<p>(It would be nice if there were a way to query for all direct uses of the topology on <code>Prop</code>.)</p>",
        "id": 503723599,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741247367
    },
    {
        "content": "<p>The Sierpinski topology is also the correct one from the point of view of the Alexandrov topology associated with the preorder on Prop</p>",
        "id": 503731085,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1741249790
    },
    {
        "content": "<p>Perhaps the difference between Prop and Bool is that <code>-&gt;</code> has type Prop -&gt; Prop -&gt; Prop but there seems to be no booly analogue of this, and this gives an asymmetry in Prop which is not so well reflected in the Bool world.</p>",
        "id": 503732662,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1741250262
    },
    {
        "content": "<p>Maybe it's counterintuitive and I have never seen it used in programming, but we do have a Boolean analogue, both in Lean and general programming languages. It's just spelled like <code>≤</code> (decidable and coerced to Bool in Lean). A similar counterintuitive operator is Xnor, which is spelled like<code>==</code>...</p>",
        "id": 504552271,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1741606939
    },
    {
        "content": "<p>&lt;= on Bool is Prop-valued, so you also need to apply the coercion, which is what made me claim that the Bool analogue didn't really exist.</p>",
        "id": 504553338,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1741607173
    },
    {
        "content": "<p>The Sierpinski topology is useful on occasion, but I can't help but think the best setup would be to have both topologies available, and only used as instances locally. The other (discrete) topology would make it very easy to talk about several of the constructions in Stone duality, for instance.</p>",
        "id": 504610012,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1741618947
    },
    {
        "content": "<p>But couldn't we use the \"type alias\" <code>Bool</code> for the latter application?</p>",
        "id": 504620336,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1741621097
    },
    {
        "content": "<p>Pinning <span class=\"user-mention\" data-user-id=\"411579\">@Sam van G</span> who might have an opinion!</p>",
        "id": 504797881,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1741688749
    },
    {
        "content": "<p>Hi! I am not quite sure what the question is, but as some of the messages<br>\nabove also indicate, the Sierpinski topology on the two element set classifies<br>\nopen sets while the discrete topology classifies clopen sets. In Stone<br>\nduality, Sierpinski can be used as the dualizing object for obtaining a dual<br>\nadjunction between frames and topological spaces, while discrete gives a dual<br>\nequivalence between Boolean algebras and Boolean spaces (= profinite sets). So<br>\nyes, both topologies on the two element set are sometimes useful.</p>",
        "id": 504808919,
        "sender_full_name": "Sam van G",
        "timestamp": 1741691628
    }
]