[
    {
        "content": "<p>I'm making this post to solicit feedback on my lean4 matroid repo : <a href=\"https://github.com/apnelson1/Matroid\">https://github.com/apnelson1/Matroid</a></p>\n<p>This work has undergone many iterations in the last couple of years,  including huge refactors to make it more sane, and most recently a porting to lean4; now I think it's basically in a decent state for mathlib . The reason I haven't PRed it yet is that I'm waiting on a couple of PRs currently in the queue (<a href=\"https://github.com/leanprover-community/mathlib4/pull/5908\">#5908</a> and <a href=\"https://github.com/leanprover-community/mathlib4/pull/5911\">#5911</a>) to give me some API for <code>enat</code> set cardinality and some minimality/maximality stuff that I need. (This is all in the <code>ForMathlib</code> subfolder). </p>\n<p>I'm imagining that the sequence of PRs for the project itself will take quite some reviewing, since this adds up to a lot of new stuff, so I'm hoping to get a jump on at least the first one by inviting anyone interested to take a look now. </p>\n<p>The first PR will be the contents of the file <a href=\"https://github.com/apnelson1/Matroid/blob/main/Matroid/Basic.lean\">https://github.com/apnelson1/Matroid/blob/main/Matroid/Basic.lean</a>, which defines matroids, and contains definitions of bases, independence, and bases of sets, and gives a few different constructors for matroids via sets of axioms.  The docstring contains a detailed discussion of what I would consider the important design decisions. These decisions are mostly my own, and I'd be very happy to learn from experts how I could improve things.  </p>\n<p>The rest of the project is less well-document but I think it's nearly all in good shape - it contains around 5k loc,  with API for the majority of basic matroid notions including duality, minors, circuits, closure, flats, hyperplanes, uniform matroids, the rank function, and relaxation. Apart from one or two leaf files, it's all <code>sorry</code>-free. </p>\n<p>Notable omissions are linear representations of matroids and graph representations of matroids, which are important topics but are still work in progress.</p>",
        "id": 377143033,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1689900350
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"329425\">@Peter Nelson</span> I'll review <a href=\"https://github.com/leanprover-community/mathlib4/pull/5908\">#5908</a> tomorrow.</p>",
        "id": 377159478,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1689907725
    },
    {
        "content": "<p>Just to comment: For having helped Alena a bit with her sorries, I think the entire repo needs a general cleanup and design review. Once that's done, in mathlib it goes.</p>",
        "id": 377191213,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1689922231
    },
    {
        "content": "<p>Yes, a design review is what I'm asking for. Do you have any specific comments?</p>",
        "id": 377307546,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1689947333
    },
    {
        "content": "<p>Having only looked very briefly: is there a reason you need the ground set in matroids vs using the type directly?</p>",
        "id": 377319685,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689949473
    },
    {
        "content": "<p>For instance, why not</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Matroid</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"o\">(</span><span class=\"n\">Base</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">exists_base'</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">B</span><span class=\"o\">,</span> <span class=\"n\">Base</span> <span class=\"n\">B</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">base_exchange'</span> <span class=\"o\">:</span> <span class=\"n\">Matroid.ExchangeProperty</span> <span class=\"n\">Base</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">maximality'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">Matroid.ExistsMaximalSubsetProperty</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">B</span><span class=\"o\">,</span> <span class=\"n\">Base</span> <span class=\"n\">B</span> <span class=\"bp\">∧</span> <span class=\"bp\">·</span> <span class=\"bp\">⊆</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>instead of your</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[ext]</span> <span class=\"kd\">structure</span> <span class=\"n\">Matroid</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"o\">(</span><span class=\"n\">ground</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">Base</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">exists_base'</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">B</span><span class=\"o\">,</span> <span class=\"n\">Base</span> <span class=\"n\">B</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">base_exchange'</span> <span class=\"o\">:</span> <span class=\"n\">Matroid.ExchangeProperty</span> <span class=\"n\">Base</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">maximality'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">X</span> <span class=\"bp\">⊆</span> <span class=\"n\">ground</span> <span class=\"bp\">→</span>\n    <span class=\"n\">Matroid.ExistsMaximalSubsetProperty</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">B</span><span class=\"o\">,</span> <span class=\"n\">Base</span> <span class=\"n\">B</span> <span class=\"bp\">∧</span> <span class=\"bp\">·</span> <span class=\"bp\">⊆</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">subset_ground'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">B</span><span class=\"o\">,</span> <span class=\"n\">Base</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">B</span> <span class=\"bp\">⊆</span> <span class=\"n\">ground</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 377319949,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689949518
    },
    {
        "content": "<p>Yes, this is discussed in the docstring at the top. It's basically because of how often one needs to consider a number of related matroids on related but distinct ground sets.</p>",
        "id": 377320038,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1689949535
    },
    {
        "content": "<p><a href=\"https://github.com/apnelson1/Matroid/blob/main/Matroid/Basic.lean#L70\">https://github.com/apnelson1/Matroid/blob/main/Matroid/Basic.lean#L70</a></p>",
        "id": 377320089,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1689949547
    },
    {
        "content": "<p>Many of the concerns there feel like they could also be applied to vector spaces, which we solved by having a separate <code>Module _ V</code> typeclass and a <code>Submodule R V</code> structure (and <code>ModuleCat.{R} _</code> which bundles the ground type). Would a similar approach work for matroids, or are they not similar enough for the analogy to hold?</p>",
        "id": 377322293,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689949966
    },
    {
        "content": "<p>I was thinking about this earlier today, comparing it to the choices made for graphs. For graphs, this would affect graph homomorphisms, since a graph homomorphism is a map on vertices that carries adjacent vertices to adjacent vertices. If they used ground sets, then you'd need to either work with functions on the ambient type that restrict to the ground sets or with functions on the subtypes. With the first, you lose extensionality, and with the second, you have the annoyance of subtypes.</p>\n<p>Are matroid homomorphisms used much in the literature? I once saw a definition for strong maps (inverse images of flats are flats), but I have no idea how important these are.</p>",
        "id": 377322624,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1689950033
    },
    {
        "content": "<p>(For simple graphs, there <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph#doc\">docs#SimpleGraph</a> with a fixed vertex type and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.Subgraph#doc\">docs#SimpleGraph.Subgraph</a> for bundling in a ground set; here you can use the coincidence that the Subgraphs of the complete graph give you the alternative definition of a simple graph. Only SimpleGraph has homomomorphisms. <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> I think this is closer of an analogy than Module/Submodule.)</p>",
        "id": 377323645,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1689950222
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Matroids.20in.20mathlib.20-.20feedback.3F/near/377322293\">said</a>:</p>\n<blockquote>\n<p>Many of the concerns there feel like they could also be applied to vector spaces, which we solved by having a separate <code>Module _ V</code> typeclass and a <code>Submodule R V</code> structure (and <code>ModuleCat.{R} _</code> which bundles the ground type). Would a similar approach work for matroids, or are they not similar enough for the analogy to hold?</p>\n</blockquote>\n<p>To be fair, converting between these different POVs can be quite painful. (i) The DG-algebra challenge is still an open problem. (ii) Working with graded rings/modules is not as smooth in Lean as in the informal counterpart.</p>",
        "id": 377324166,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1689950319
    },
    {
        "content": "<p>Strong/weak maps do show up, but aren't particularly central, at least to the research on my personal radar. (I have weak maps defined in my lean3 repo, where I hadn't yet adopted this 'ground set is a <code>Set</code>' approach). </p>\n<p>A similar issue shows up when I define matroid isomorphisms in the <code>Equiv</code>file. They are defined using <code>LocalEquiv</code>, which is a little awkward. Dealing with minors, which are everywhere in the literature, is so absolutely hellish if the ground set is a type, that I've learned to live with such things.</p>",
        "id": 377324460,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1689950381
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span>, I agree that the Module/Submodule/ModuleCat design may not be perfect; but there's a lot of value to using the same approach throughout mathlib for consistency</p>",
        "id": 377324766,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689950437
    },
    {
        "content": "<p>I've thought about the module/submodule analogy; in fact, it kinda got me to where I am now with this. For matroid theory, one ends up being drawn towards absolutely everything in the API existing for the analogous object to a <code>Submodule</code>, and getting to a point where the <code>Module</code> object is secondary.</p>",
        "id": 377325216,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1689950532
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Matroids.20in.20mathlib.20-.20feedback.3F/near/377324766\">said</a>:</p>\n<blockquote>\n<p>there's a lot of value to using the same approach throughout mathlib for consistency</p>\n</blockquote>\n<p>Just so long as it's not a <a href=\"https://en.wikipedia.org/wiki/Wikipedia:Emerson_and_Wilde_on_consistency\">foolish consistency</a>.</p>\n<p>Already it's different because Module/Submodule/ModuleCat is designed around using typeclasses for implementing the usual synecdoche (that <code>M</code> <em>is</em> a module). Matroids don't use synecdoche.</p>",
        "id": 377325456,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1689950582
    },
    {
        "content": "<p>Typeclasses also implement transparent coercions between different structures in the algebraic hierarchy, but I'm not sure matroids need that either.</p>",
        "id": 377326108,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1689950710
    },
    {
        "content": "<p>I think the concrete problem with the ground set being a type is that you can't talk about minors reasonably. See the lemmas here, for example : <a href=\"https://github.com/apnelson1/Matroid/blob/main/Matroid/Minor.lean#L560\">https://github.com/apnelson1/Matroid/blob/main/Matroid/Minor.lean#L560</a> </p>\n<p>They are mathematically trivial, but would have formal statements involving canonical maps between images/preimages of coercions of four sets between multiple subtypes, subtypes of subtypes, etc.  I tried this for a long long time, becoming intimately familiar with <code>preimage_image_coe</code>-type lemmas, but it just isn't sustainable.</p>",
        "id": 377326919,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1689950863
    },
    {
        "content": "<p>Another potential design for minors (which definitely involves a tradeoff) is to introduce another type that records what should be deleted and what should be contracted. This at least works for graphs (you record a set of edges to keep and a subset of those edges to contract), but the issue is that you can't apply any theorems about graphs to minors without using a toGraph function.</p>\n<p>It seems that the reasons for wanting this in graphs (such as avoiding quotient types until you really need them) don't apply to matroids though.</p>",
        "id": 377329074,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1689951253
    },
    {
        "content": "<p>It's nice that for matroids with an embedded ground set you can get contraction-deletion as an <code>Eq</code></p>",
        "id": 377329475,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1689951346
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Matroids.20in.20mathlib.20-.20feedback.3F/near/377329475\">said</a>:</p>\n<blockquote>\n<p>It's nice that for matroids with an embedded ground set you can get contraction-deletion as an <code>Eq</code></p>\n</blockquote>\n<p>Yes. The first time I used <code>rw</code> with such an equality (after months of DTT hell) filled me with joy!</p>",
        "id": 377329764,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1689951397
    },
    {
        "content": "<p>I actually think a similar approach <em>might</em> be reasonable for minors in graph theory in some cases. If you have an embedded edge and vertex set, then you can contract an edge uv by choosing one of the ends uv to contract it to, so you get a graph whose vertex and edge sets live in the same type, avoiding quotients. Tradeoffs abound, of course.</p>",
        "id": 377330788,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1689951593
    },
    {
        "content": "<p>Yeah, though it's too bad that choosing representatives isn't very stable (ex: contracting an edge between two contracted components yields a representative that might have no relation to either components' representative), and the edge set won't generally be a subset of the original edge set.</p>",
        "id": 377332102,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1689951828
    },
    {
        "content": "<p>the edge set will still be a subset if you have an edge type (if you're doing anything with minors, this seems almost a necessity to me)</p>",
        "id": 377332390,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1689951875
    },
    {
        "content": "<p>(to be clear, I mean a type in which the edges are an embedded set)</p>",
        "id": 377333052,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1689951996
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Matroids.20in.20mathlib.20-.20feedback.3F/near/377322624\">said</a>:</p>\n<blockquote>\n<p>Are matroid homomorphisms used much in the literature? I once saw a definition for strong maps (inverse images of flats are flats), but I have no idea how important these are.</p>\n</blockquote>\n<p>On this topic, much of the interest of strong/weak maps can be captured in the special case where they are between two matroids on the same ground set; so my approach doesn't rule that out. Homomorphisms aren't really well-defined for general matroids, but they are pretty much just linear maps in the representable case, and that is quite compatible with the 'embedded ground sets' approach as well; elements outside the ground set are just 'zero'.</p>",
        "id": 377342457,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1689953723
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/6352\">#6352</a><br>\nI started this before my kid was born; he's now 2.5 years old and I'm finally making a matroid PR!</p>",
        "id": 381583918,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1691088757
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Matroids.20in.20mathlib.20-.20feedback.3F/near/377322624\">said</a>:</p>\n<blockquote>\n<p>Are matroid homomorphisms used much in the literature? I once saw a definition for strong maps (inverse images of flats are flats), but I have no idea how important these are.</p>\n</blockquote>\n<p>The classic theory of matroids isn't categorized, but there is now a definition of a morphism of matroids in this <a href=\"https://web.math.princeton.edu/~huh/MatroidMorphism.pdf\">paper by Eur and Huh</a>. It is not clear to me how much this definition will fit the need.</p>",
        "id": 435056632,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1713901470
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2312380.20direct.20sum.20of.20matroids/near/435051742\">said</a>:</p>\n<blockquote>\n<p>I think a lot of this is sort of a symptom that the design of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Matroid#doc\">docs#Matroid</a> doesn't mesh well with the rest of the library (c.f. the discussion <a href=\"#narrow/stream/287929-mathlib4/topic/Matroids.20in.20mathlib.20-.20feedback.3F/near/377319685\">here</a>), and it forces you to write <code>A : set \\alpha</code> and use <code>A \\inter B</code> everywhere, instead of just using <code>A : Set \\beta</code></p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> </p>\n<p>You've raised this point  in review, and I want to reiterate that I really don't know a better way, and having the design of matroids 'mesh well' with mathlib would make  it incredibly difficult to make even this simplest statements that appear in actual proofs. I know this because I tried for a long time - the current approach was suggested to me by <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> last year, as a response to the issues that came up. </p>\n<p>Here is the specific problem. In matroid theory, statements like <code>M / C \\ D / e \\ f = M / (C ∪ {e}) \\ (D ∪ {f})</code>, or more generally 'contractions and deletions commute' are everywhere, and need to be possible to state. If each matroid is tied to a type, then that <code>=</code> is a disastrous combination of isomorphisms, and we descend into DTT hell.  If there is a <code>Minor M</code> type for each <code>E : Type</code> and <code>M : Matroid E</code> (in the vein of <code>SimpleGraph.Subgraph</code>), then we end up needing to duplicate the entire API for <code>Minor</code>,  which is tantamount to the current approach anyway. </p>\n<p>If you can show me a way to reasonably state <code>M / C \\ D / e \\ f = M / (C ∪ {e}) \\ (D ∪ {f}) </code> that isn't the current approach, I would really love to hear it. Otherwise, I think options are some 'principled' answer involving unavailable HOTT, or treating matroids as the set-theoretic objects they are in practice. </p>\n<p>On that topic, I think that the same issues will arise when doing serious work on minors of graphs. A student of mine will be embarking on this journey for his PhD project later this year.</p>",
        "id": 435206456,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1713969847
    },
    {
        "content": "<p>Something that I found to be frustrating when working on the graph theory library is how I had to keep re-explaining why it is that graphs are not algebraic objects, so the design patterns we've learned for how to deal with algebraic objects do not necessarily apply.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Matroids.20in.20mathlib.20-.20feedback.3F/near/377325456\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Matroids.20in.20mathlib.20-.20feedback.3F/near/377324766\">said</a>:</p>\n<blockquote>\n<p>there's a lot of value to using the same approach throughout mathlib for consistency</p>\n</blockquote>\n<p>Already it's different because Module/Submodule/ModuleCat is designed around using typeclasses for implementing the usual synecdoche (that <code>M</code> <em>is</em> a module). Matroids don't use synecdoche.</p>\n</blockquote>\n<ol>\n<li>These combinatorial objects do not use coercions and typeclasses to make it so you can identify the ground set with the object.</li>\n<li>These combinatorial objects are not associated to a particular type. The common case is studying multiple objects with the same ground set, unlike algebraic objects where there's \"the\" set of operations.</li>\n</ol>\n<p>Can we agree to let combinatorics explore these new design patterns here without needing to keep re-justifying why the algebraic hierarchy pattern isn't appropriate?</p>\n<p>Also: I think the fact that deletion-contraction was proved using an <code>Eq</code> is <em>very</em> strong evidence that <span class=\"user-mention\" data-user-id=\"329425\">@Peter Nelson</span> came up with a great design for matroids. Let's not talk about \"symptoms\" that it was designed incorrectly unless there's an alternative working design backing that up.</p>",
        "id": 435210023,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713970772
    },
    {
        "content": "<p>I was careful to chose my words above; I don't think the design of Matroid is incorrect, merely that it's out-of-distribution for the way various bits of API elsewhere in mathlib are designed. I completely agree that it's fine to let combinatorics explore new design patterns, and part of that is noting friction (but continuing despite it) that appears between the two designs.</p>",
        "id": 435211820,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1713971100
    },
    {
        "content": "<p>I think it's fine taking note of design tradeoffs, but they're tradeoffs.</p>\n<p>My belief is that, if they must be called symptoms, they are symptoms of the underlying design complexities. The complexities will express symptoms <em>somewhere</em> no matter the design. For example, you may see DTT hell rather than a clean deletion-contraction Eq. I think it's unfair to phrase it as \"a symptom of the design of Matroid,\" which is a sort of sentiment that I personally find to be discouraging. Unless the design isn't already at the Pareto frontier, it's not fair to bring up deficiencies along single axes like it's an issue with the design.</p>\n<p>To what extent is this an issue with <code>Matroid</code> not \"meshing well\" with mathlib, or rather is it mathlib not yet having the supporting set theory? I'm not sure there's any project that hasn't contributed something to it. I think it would be short-sighted to design based on what set theory is already there.</p>",
        "id": 435217213,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713972178
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329425\">Peter Nelson</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Matroids.20in.20mathlib.20-.20feedback.3F/near/435206456\">said</a>:</p>\n<blockquote>\n<p>If you can show me a way to reasonably state <code>M / C \\ D / e \\ f = M / (C ∪ {e}) \\ (D ∪ {f})</code> that isn't the current approach</p>\n</blockquote>\n<p>Just to check; is this \"current approach\" in mathlib, in a branch, or in a repo elsewehere?</p>",
        "id": 435234581,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1713977554
    },
    {
        "content": "<p><a href=\"https://github.com/apnelson1/Matroid/blob/main/Matroid/Minor/Basic.lean\">https://github.com/apnelson1/Matroid/blob/main/Matroid/Minor/Basic.lean</a></p>\n<p>Minors work smoothly if the ground set is a <code>Set</code>.</p>",
        "id": 435234925,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1713977667
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 435291547,
        "sender_full_name": "nicheng0019",
        "timestamp": 1714004177
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2312380.20direct.20sum.20of.20matroids/near/435315835\">said</a>:</p>\n<blockquote>\n<p>For the record, I already gave you an alternative design which seems strictly better to me (from poking around in your repo), namely remove the <code>ground</code> field and instead have a <code>IsSupportedOn</code> predicate checking that everything is defined on a given ground set.</p>\n</blockquote>\n<p>How exactly would this work? From the way I understand it, a <code>supportedOn</code> predicate would give <code>Eq</code> for my example, but it would also give no way to distinguish between a matroid not containing <code>e</code>, and one where <code>e</code> is a loop.</p>\n<p>And this would (for instance) break duality - it would require something like <code>Matroid.dualWRT (E : Set α) </code> rather than <code>Matroid.dual</code>. This would cascade to every piece of the theory that considers loops, which do not dualize to loops. Statements that want to talk about loops would have to remember the ground set explicitly. So then <code>{M : Matroid α // M.supportedOn E}</code> would come into play in any proof where you need to keep track of the ground set. And this gives worse versions of all the problems I've mentioned.</p>",
        "id": 435361480,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1714042006
    },
    {
        "content": "<p>And the real problem is that if a <code>Matroid</code> doesn't know its ground set, a <code>Matroid</code> isn't actually a matroid, in that it doesn't carry as much information. So while you have <code>M / C \\ D / e \\ f = M / (C ∪ {e}) \\ (D ∪ {f})</code>, you also have mathematically incorrect statements as theorems, like <code>M / {e,f} = M / e</code> for a parallel pair <code>e,f</code>. (even if <code>M</code> itself is loopless).</p>",
        "id": 435387687,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1714051143
    },
    {
        "content": "<p>Let me summarize the situation. Peter Nelson put a lot of effort into definitions and results related to matroids. However, most of this work hasn't been integrated into Mathlib yet. Because of that, Ivan and I are in the process of re-doing a good portion of that work. Additionally, since Peter and Ivan&amp;I worked in isolation, all of us have made some design decisions that make sense in the context of our own work, but might not be ideal in the long run. As a result, now we find it difficult to consolidate our contributions and to move on to formalizing more complex results.</p>\n<p>I would like all of us to team up and combine our efforts. To make it easier to proceed, we should review our work, decide on a good architecture, refactor the existing code, and make a large consolidated pull request with all the materials we have so far. What do you think?</p>",
        "id": 435544786,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1714121945
    },
    {
        "content": "<blockquote>\n<p>and make a large consolidated pull request with all the materials we have so far. What do you think?</p>\n</blockquote>\n<p>This seems doomed to be stuck in  review. In the short term, I think it would be better for you to contribute your matroid work directly to <span class=\"user-mention\" data-user-id=\"329425\">@Peter Nelson</span>'s repository, assuming Peter is on board with that.</p>",
        "id": 435545308,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1714122147
    },
    {
        "content": "<p>Having this come up has given me a good opportunity to think about what the issues are and why they led to the decisions they did, and I think it's good to have some of the discussion recorded here. The following is in a sense a restatement of what <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> has said, but I hope it helps for those curious. </p>\n<p>Here is a design question about a more familiar mathematical object than a matroid. (the fact that it is mathematically completely unhinged is not the point.) </p>\n<p>Suppose I have produced a 'union' operation on groups, so </p>\n<ul>\n<li>for groups <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mo>=</mo><mo stretchy=\"false\">(</mo><mi>S</mi><mo separator=\"true\">,</mo><mo>∗</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">G = (S, *)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">∗</span><span class=\"mclose\">)</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mo>=</mo><mo stretchy=\"false\">(</mo><msup><mi>S</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo separator=\"true\">,</mo><msup><mo>∗</mo><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">G = (S&#x27;, *&#x27;)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0019em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mbin\">∗</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> on sets <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mo separator=\"true\">,</mo><msup><mi>S</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">S,S&#x27;</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9463em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span>, there is a group <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mo>∪</mo><msup><mi>G</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo>=</mo><mo stretchy=\"false\">(</mo><mi>S</mi><mo>∪</mo><msup><mi>S</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo separator=\"true\">,</mo><msup><mo>∗</mo><mrow><mo mathvariant=\"normal\">′</mo><mo mathvariant=\"normal\">′</mo></mrow></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">G \\cup G&#x27; = (S \\cup S&#x27;, *&#x27;&#x27;)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7519em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0019em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mbin\">∗</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′′</span></span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> on the union of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>S</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mi mathvariant=\"normal\">.</mi></mrow><annotation encoding=\"application/x-tex\">S&#x27;.</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7519em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mord\">.</span></span></span></span> (<strong>Here, S and S' might intersect nontrivially</strong>) </li>\n</ul>\n<p>Suppose that I also have a 'difference' operation on groups, so </p>\n<ul>\n<li>For each group <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mo>=</mo><mo stretchy=\"false\">(</mo><mi>S</mi><mo separator=\"true\">,</mo><mo>∗</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">G = (S, *)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">∗</span><span class=\"mclose\">)</span></span></span></span> and each subset <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span>, then there is a group <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mi mathvariant=\"normal\">\\</mi><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">G \\backslash X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord\">\\</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>S</mi><mi mathvariant=\"normal\">\\</mi><mi>X</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(S \\backslash X)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord\">\\</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span></span></span></span>.</li>\n</ul>\n<p>Now I tell you that I have proved that my operations obey the following commutative/ associative/distribute-type laws, so </p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>G</mi><mo>∪</mo><msup><mi>G</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo stretchy=\"false\">)</mo><mo>∪</mo><msup><mi>G</mi><mrow><mo mathvariant=\"normal\">′</mo><mo mathvariant=\"normal\">′</mo></mrow></msup><mo>=</mo><mi>G</mi><mo>∪</mo><mo stretchy=\"false\">(</mo><msup><mi>G</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo>∪</mo><msup><mi>G</mi><mrow><mo mathvariant=\"normal\">′</mo><mo mathvariant=\"normal\">′</mo></mrow></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(G \\cup G&#x27;) \\cup G&#x27;&#x27; = G \\cup (G&#x27; \\cup G&#x27;&#x27;)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0019em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7519em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0019em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0019em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′′</span></span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mi mathvariant=\"normal\">\\</mi><mi>X</mi><mi mathvariant=\"normal\">\\</mi><mi>Y</mi><mo>=</mo><mi>G</mi><mi mathvariant=\"normal\">\\</mi><mi>Y</mi><mi mathvariant=\"normal\">\\</mi><mi>X</mi><mo>=</mo><mi>G</mi><mi mathvariant=\"normal\">\\</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo>∪</mo><mi>Y</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">G \\backslash X \\backslash Y = G \\backslash Y \\backslash X = G \\backslash (X \\cup Y)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord\">\\</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mord\">\\</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord\">\\</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mord\">\\</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord\">\\</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mclose\">)</span></span></span></span> for all <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo separator=\"true\">,</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">X,Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> contained in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span>, and </li>\n<li>for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> contained in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>G</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">G&#x27;</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7519em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span>, we have <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>G</mi><mo>∪</mo><msup><mi>G</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">\\</mi><mi>X</mi><mo>=</mo><mo stretchy=\"false\">(</mo><mi>G</mi><mi mathvariant=\"normal\">\\</mi><mi>X</mi><mo stretchy=\"false\">)</mo><mo>∪</mo><mo stretchy=\"false\">(</mo><msup><mi>G</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mi mathvariant=\"normal\">\\</mi><mi>X</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">.</mi></mrow><annotation encoding=\"application/x-tex\">(G \\cup G&#x27;) \\backslash X = (G \\backslash X) \\cup (G&#x27; \\backslash X).</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0019em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mord\">\\</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">G</span><span class=\"mord\">\\</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0019em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mord\">\\</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span><span class=\"mord\">.</span></span></span></span> </li>\n</ul>\n<p>How do I formalize these statements? </p>\n<p>As far as I can tell, it's a good thing that the above is mathematically nonsense, because mathlib's <code>Group</code> would have nothing pretty to offer. (at least nothing I'd want to interact with). This is fine, because it <em>is</em> nonsense. That's not what groups are for. </p>\n<p>For combinatorial objects like graphs and matroids, on the other hand, these are analagous to things we actually do! We glue things together on common intersections, throw things away, identify different things, fiddle with adjacency/independence predicates, and lots more. And not always in algebraically principled ways. And ideally, we need these things to be flexible enough to have <code>Eq</code> and rewrites wherever possible. </p>\n<p>In my opinion, designs for combinatorics that embrace the set theory more than most of mathlib, are the way forward.</p>",
        "id": 435595186,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1714140860
    },
    {
        "content": "<p>Hi Peter,</p>\n<p>I've been trying to find someone who is interested in the matroids for Laurent series- the ones involving <code>L[[t₁,...,tₙ]]</code> and <code>L((t₁,...,tₙ))</code></p>\n<p>I thought you would know or would be interested in the matroids associated to these, roughly analogous to the ones for transcendence degree, and maybe evening adding them in as examples.</p>\n<p>The most interesting part to me is that <code>L((t,s))</code> has no natural locally compact topology.</p>",
        "id": 435670966,
        "sender_full_name": "Dean Young",
        "timestamp": 1714172644
    },
    {
        "content": "<p>I don’t know anything about that, sorry!</p>",
        "id": 435752698,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1714220321
    },
    {
        "content": "<p>(<span class=\"user-mention\" data-user-id=\"329425\">@Peter Nelson</span>, note that you can make LaTeX work in your message above by using <code>$$ $$</code> instead of <code>$ $</code>)</p>",
        "id": 435755373,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1714222731
    },
    {
        "content": "<p>In your example of glueing together G and G' with nontrivial intersection, is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∗</mo></mrow><annotation encoding=\"application/x-tex\">*</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4653em;\"></span><span class=\"mord\">∗</span></span></span></span> required to agree with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mo>∗</mo><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">*&#x27;</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7519em;\"></span><span class=\"mord\"><span class=\"mbin\">∗</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span> on that intersection?</p>",
        "id": 435758223,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1714225311
    },
    {
        "content": "<p>I can say yes for now to make things easier, but probably in some (analogous) applications the answer is no, for example the union of two graphs with disjoint edge sets and intersecting vertex sets.</p>",
        "id": 435758345,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1714225429
    },
    {
        "content": "<p>I think in the \"yes\" case the existing <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Subgroup#doc\">docs#Subgroup</a> design is adequate and works well in algebra. The \"no\" case sounds like the interesting one</p>",
        "id": 435762290,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1714228552
    },
    {
        "content": "<p>Doesn’t <code>Subgroup</code> presuppose a global ambient group structure? I’m certainly not going to be that generous.</p>",
        "id": 435762407,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1714228640
    },
    {
        "content": "<p>It does, but it's not yet clear to me that that's actually really consuming any generosity; if the largest object you're going to talk about is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>G</mi><mn>1</mn></msub><mo>∪</mo><msub><mi>G</mi><mn>2</mn></msub><mo>∪</mo><msub><mi>G</mi><mn>3</mn></msub></mrow><annotation encoding=\"application/x-tex\">G_1 ∪ G_2 ∪ G_3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> then you can just pretend you are working in some arbitrary ambient group G such that <code> (⊤ : Subgroup G) = G₁ ⊔ G₂ ⊔ G₃</code> (and in most cases you'll find you don't use this assumption).</p>",
        "id": 435762984,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1714229090
    },
    {
        "content": "<p>The point of the ambient group is to <em>enforce in the type system</em> that your <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∗</mo></mrow><annotation encoding=\"application/x-tex\">*</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4653em;\"></span><span class=\"mord\">∗</span></span></span></span> operator always agrees on intersections</p>",
        "id": 435763068,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1714229155
    },
    {
        "content": "<p>Maybe a good example of where this lack of generosity manifests in mathlib today is when talking about subgroups of a ring, where no global inverse is available. There our solution is to talk about <code>Subgroup Rˣ</code> instead, which is usually not too painful.</p>",
        "id": 435763880,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1714229800
    },
    {
        "content": "<p>I think I’m still missing something. What are the type signatures of the relevant functions for associativity, and if my proof that the union group operation gives a group is long and complicated, where is that mathematics hiding?</p>",
        "id": 435767859,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1714232898
    },
    {
        "content": "<p>The associativity lemma in this case would just be <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=sup_assoc#doc\">docs#sup_assoc</a>, which follows from a lattice instance somewhere.</p>\n<blockquote>\n<p>and if my proof that the union group operation gives a group is long and complicated, where is that mathematics hiding?</p>\n</blockquote>\n<p>The mathematics is hiding in showing that the <code>Subgroup</code> is closed under the ambient <code>*</code> operations, as the \"agreement on intersections\" requirement means that there isn't actually any new group structure to define.</p>",
        "id": 435768311,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1714233138
    },
    {
        "content": "<p>Ah thanks, I understand - the case resolved by the <code>Sub_</code> pattern is where there is at most one substructure for each set in the ambient type. This isn’t the case for matroids or graphs with minors, so I’ll revise my earlier answer to ‘no’.</p>",
        "id": 435769033,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1714233543
    },
    {
        "content": "<p>Or slightly more generally, I suppose, it resolves the case where substructures are <code>SetLike</code>, as with <code>Subgraph</code></p>",
        "id": 435769794,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1714234210
    }
]