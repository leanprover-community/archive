[
    {
        "content": "<p>DFunLike has the type <code>(F : Sort u) (α : outParam (Sort v)) (β : outParam (α → Sort w))</code>, which means (as I understand it) that it picks the first <code>DFunLike</code> instance for <code>F</code> that it sees, and then picks <code>α</code> and <code>β</code> based on that.</p>\n<p>I've got a case where I would really like to equip one class with multiple DFunLike instances. I've defined the type <code>HermitianPreservingMap m n α</code> of linear maps from <code>Matrix m m α</code> to <code>Matrix n n α</code> that are <em>Hermitian preserving</em>, that is, if the input is Hermitian then the output is Hermitian. And I've defined the type <code>HermitianMat n α := selfAdjoint (Matrix n n α)</code>, and built a bunch of API around that type.</p>\n<p>The most natural FunLike instance for HermitianPreservingMap is then mapping <code>HermitianMat m α</code> to <code>HermitianMat n α</code>. But, at times, I would like to apply this to a plain-old matrix (that isn't Hermitian). Functional extensionality still works: the set of Hermitian matrices span (as a <code>α</code>-vector space) the space of all matrices. So it would be nice to also define a FunLike instance mapping <code>Matrix m m α</code> to <code>Matrix n n α</code>.</p>\n<p>(This is a bit of a simplification, but this is the core problem.)</p>\n<p>But if I try to define two FunLike instances, it causes lots of problems with inference, I <em>think</em> because of the outParam annotation. So I'm trying to both understand why it's made like that, and what I should do.</p>",
        "id": 520484727,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1748274345
    },
    {
        "content": "<p>I think the answer might be something about letting there be a <code>CoeHead</code> from <code>HermitianPreservingMap</code> down to <code>LinearMap</code> or something, but I'm very fuzzy on how that actually is supposed to work.</p>",
        "id": 520484961,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1748274424
    },
    {
        "content": "<p>I think it's because <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CoeFun#doc\">docs#CoeFun</a> also has the <code>outParam</code></p>",
        "id": 520485155,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1748274490
    },
    {
        "content": "<p>Bumping this: what is the <em>intended</em> or <em>standard</em> way to deal with a type that is, quite naturally, a \"function\" on two different types?</p>\n<p>Another example: for <code>U : Matrix.unitaryGroup n ℂ</code>, I would like to both have it acting on \"kets\" and \"mixed states\" in quantum mechanics.</p>\n<p>That is,  I have the type <code>Ket n</code> for normalized vectors <code>n -&gt; ℂ</code>, and a type <code>MState n</code> for mixed states - PSD matrices with trace 1. These are both pretty standard objects in quantum mechanics. Unitaries naturally act on ket's by multiplication (and of course, they preserve the norm), and they act on mixed states by conjugation (this preserver the PSD condition and the trace). Both would be valid DFunLike instances: they have functional extensionality. And indeed people often do things like composing these (multiplying the unitaries), etc. etc. and I would like to be able to talk about this.</p>\n<p>Is there a good solution to this?</p>",
        "id": 522156447,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1748964780
    },
    {
        "content": "<p>Well I think the idea is that <code>CoeFun</code> (which <code>DFunLike</code> is implemented with) is meant to allow for everything that you could do for regular functions but not more. With regular functions you can't provide parameters of different types <em>unless</em> you add implicit parameters or coercions. I opted for implicits since they work better here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Meta</span>\n\n<span class=\"sd\">/-- Class used to tag fun-likes with multiple parameter types -/</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">MultiFunLike</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">MultiFunLikeRule</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">γ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">γ</span><span class=\"w\"> </span><span class=\"n\">a</span>\n\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">MultiFunLike</span><span class=\"bp\">.</span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MultiFunLike</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">fn</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">γ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MultiFunLikeRule</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">γ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">γ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">MultiFunLikeRule</span><span class=\"bp\">.</span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"n\">fn</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"n\">run_meta</span>\n<span class=\"w\">  </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">registerCoercion</span><span class=\"w\"> </span><span class=\"ss\">``MultiFunLike.coe</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">coeFun</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">numArgs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">coercee</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">})</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MultiFunLike</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CoeFun</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">γ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MultiFunLikeRule</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">γ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">γ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">MultiFunLike</span><span class=\"bp\">.</span><span class=\"n\">coe</span>\n\n<span class=\"c1\">-- coerces to `not` and `Nat.succ`</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">NotSucc</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mk</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MultiFunLike</span><span class=\"w\"> </span><span class=\"n\">NotSucc</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨⟩</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MultiFunLikeRule</span><span class=\"w\"> </span><span class=\"n\">NotSucc</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"bp\">⟩</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MultiFunLikeRule</span><span class=\"w\"> </span><span class=\"n\">NotSucc</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"bp\">⟩</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">NotSucc</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"c1\">-- NotSucc.mk false : Bool</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">NotSucc</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"c1\">-- NotSucc.mk 0 : Nat</span>\n</code></pre></div>",
        "id": 522166859,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1748967467
    },
    {
        "content": "<p>Note that an other case where something has multiple coercions to functions (though in this case the individual coercions are not injective) is functors in category theory: they act on objects, and on every hom-type between objects.<br>\nThe <code>CategoryTheory</code> part of the library is probably way too deep in the current design to even consider a refactor if \"multiple coercions to functions\" were a thing though (I once experimented and tried to put a <code>DFunlike</code> on natural transformations, and soon gave up).</p>",
        "id": 522167968,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1748967798
    },
    {
        "content": "<p>@Robin Arnez: Hmm! Well that's a super interesting way to do it. I'll consider it, but also it makes me pretty nervous -- it feels like probably re-inventing the wheel a bit, and I'll have e.g. conflicts if I wanted to use this with anything that expects a DFunLike. Like, I don't think this would easily work with <code>LinearMapClass</code> then, for instance. Of course I could add the typeclass inference from a MultiFunLikeRule to a DFunLike, but then inference will get stuck there again, which is the original problem.</p>\n<p>So I guess the answer is, right now it's really intended that you're always supposed to pick one canonical function to cast to. Alright.</p>",
        "id": 522168748,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1748968033
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"286014\">@Robin Carlier</span>: What does the category theory library do, then? Pick one of the coercions to be the \"canonical\" one, and refer the other one just by a field name + with manual \"ext\" lemmas and so on?</p>",
        "id": 522168849,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1748968067
    },
    {
        "content": "<p>Okay, actually it looks there's just neither one.</p>",
        "id": 522169030,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1748968132
    },
    {
        "content": "<p>None of those: we use <code>F.obj _</code> and <code>F.map _</code> everywhere, and also have <code>Functor.ext</code> (which is avoided because \"equality of objects in categories is bad and functors are objects of functor categories\").</p>",
        "id": 522169115,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1748968158
    },
    {
        "content": "<p>(admittedly, coercions to functions would only be quality of life in category theory, not a game-changing addition)</p>",
        "id": 522169924,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1748968397
    },
    {
        "content": "<p>I see.<br>\nI would be fine just picking one (or neither), but in order to use <code>LinearMapClass</code> I need to have a <code>DFunLike</code>. And I have two distinct <code>LinearMapClass</code> types I want to provide.</p>\n<p>I guess a solution would be to define something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">MyType</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span><span class=\"w\"> </span><span class=\"c1\">--thing I want two instances on</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FunLike</span><span class=\"w\"> </span><span class=\"n\">MyType</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span><span class=\"w\"> </span><span class=\"c1\">--first instance</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LinearMapClass</span><span class=\"w\"> </span><span class=\"n\">MyType</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span><span class=\"w\"> </span><span class=\"c1\">--building on it</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">reducible</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"c1\">--alias that lets you pick out the other one. (*should* this be reducible?)</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">MyTypeOnX</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">MyType</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">MyType</span><span class=\"bp\">.</span><span class=\"n\">onX</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FunLike</span><span class=\"w\"> </span><span class=\"n\">MyTypeOnX</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span><span class=\"w\"> </span><span class=\"c1\">--second instance</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LinearMapClass</span><span class=\"w\"> </span><span class=\"n\">MyTypeOnX</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span><span class=\"w\"> </span><span class=\"n\">building</span><span class=\"w\"> </span><span class=\"n\">on</span><span class=\"w\"> </span><span class=\"n\">it</span>\n</code></pre></div>",
        "id": 522170258,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1748968510
    },
    {
        "content": "<p>does that look ... reasonable?</p>",
        "id": 522170288,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1748968517
    },
    {
        "content": "<p>These are actions (<code>U</code> is a function from a thing <code>X</code> to itself rather than to another thing) so you can use <code>SMul</code> to have both of these at once.</p>",
        "id": 522179338,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1748971403
    },
    {
        "content": "<p>Oh, good point, I'll probably do that for the \"unitary acting on normalized vector / mixed states\". That's nice.</p>\n<p>It doesn't let me get a LinearMapClass, though.</p>",
        "id": 522181058,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1748971925
    },
    {
        "content": "<p>I guess I'll build off the above, it mostly matches with the coercions that already exist anyway. (A positive map extends a hermitian preserving map extends a linear map, so the <code>onX</code> will just be the <code>toLinearMap</code> projections that exist anyway.)</p>",
        "id": 522181945,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1748972226
    },
    {
        "content": "<p>We have things like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearMap.mulLeft#doc\">docs#LinearMap.mulLeft</a> if you want the linear map.</p>",
        "id": 522213331,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1748984024
    },
    {
        "content": "<p>Interesting, I'll take a look. Thanks a lot for the pointers</p>",
        "id": 522213687,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1748984189
    }
]