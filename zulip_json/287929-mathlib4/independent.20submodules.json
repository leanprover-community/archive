[
    {
        "content": "<p>With the definition of isotypic component, I'm trying to show that for an arbitrary module <code>M</code>, the set of all isotypic components of <code>M</code> that come from simple modules is an independent set of submodules of <code>M</code>. How do I express that a set of submodules is independent? In particular, LinearAlgebra.LinearIndependent seems to be useful for later lemmas/theorems I want to prove, but that definition of dependence is on sets of elements of <code>M</code>. I've tried some ways to use this by grabbing representative elements from each isotypic component to perform LinearAlgebra.LinearIndependent on, but I'm getting errors. Any suggestions?</p>",
        "id": 449425085,
        "sender_full_name": "Jiang Xu Wan",
        "timestamp": 1720232027
    },
    {
        "content": "<p>Isn't there a notion of \"the sum of these submodules is direct\"?</p>",
        "id": 449430472,
        "sender_full_name": "Lior Silberman",
        "timestamp": 1720236352
    },
    {
        "content": "<p>2 messages were moved here from <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/stream/287929-mathlib4/topic/two-sided.20ideals\">#mathlib4 &gt; two-sided ideals</a> by <span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span>.</p>",
        "id": 449436387,
        "sender_full_name": "Notification Bot",
        "timestamp": 1720240015
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"724854\">@Jiang Xu Wan</span> I think <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CompleteLattice.Independent#doc\">docs#CompleteLattice.Independent</a> is what you are looking for.</p>",
        "id": 449436429,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1720240040
    },
    {
        "content": "<p>Or possibly <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=DirectSum.IsInternal#doc\">docs#DirectSum.IsInternal</a></p>",
        "id": 449462690,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1720256645
    },
    {
        "content": "<p>Here are some suggestions:</p>\n<ul>\n<li>define <code>IsIsotypicModule R M</code> to mean that the R-module M is semisimple with all simple submodules isomorphic;</li>\n<li>for <code>m : Submodule R M</code>, define <code>IsIsotypicComponent m</code> to mean that <code>m</code> is maximal among all submodules satisfying <code>IsIsotypicModule R m</code> (we probably also want to require that <code>m ≠ ⊥</code> in case M has no simple submodules; assuming M is semisimple, this only happens when M=0);</li>\n<li>show the set of all submodules satisfying <code>IsIsotypicComponent</code> satisfies <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CompleteLattice.SetIndependent#doc\">docs#CompleteLattice.SetIndependent</a>;</li>\n<li>if <code>IsIsotypicComponent m</code> is true, then for all simple submodule <code>s ≤ m</code>, we have <code>isotypic R M s = m</code> (where <code>isotypic</code> is as defined <a href=\"#narrow/stream/287929-mathlib4/topic/two-sided.20ideals/near/446708748\">here</a> in the other thread); we may want to define a function that sens <code>m</code> to an arbitrary chosen simple submodule <code>s</code>;</li>\n<li>for each isotypic component <code>m</code>, you can get a direct sum decomposition into simples using a version of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=exists_setIndependent_of_sSup_atoms_eq_top#doc\">docs#exists_setIndependent_of_sSup_atoms_eq_top</a> with <code>sSup s = ⊤</code> replaced by <code>sSup s = m</code>.</li>\n</ul>",
        "id": 449572948,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1720307067
    },
    {
        "content": "<p>whilst I didn't use most of your suggestions, I was able to prove that if <code>S</code> is simple, then <code>isotypic R M S</code> is semisimple (which took quite a bit more effort than I was expecting), which let me use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=exists_setIndependent_of_sSup_atoms_eq_top#doc\">docs#exists_setIndependent_of_sSup_atoms_eq_top</a> via <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/RingTheory/SimpleModule.html#IsSemisimpleModule.sSup_simples_eq_top\">#IsSemisimpleModule.sSup_simples_eq_top</a>. Still, thank you for bringing <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=exists_setIndependent_of_sSup_atoms_eq_top#doc\">docs#exists_setIndependent_of_sSup_atoms_eq_top</a> to my attention.</p>",
        "id": 461027396,
        "sender_full_name": "Jiang Xu Wan",
        "timestamp": 1723483950
    },
    {
        "content": "<p>Now something I'm not entirely sure how to do is how to convert the set of independent submodules from <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=exists_setIndependent_of_sSup_atoms_eq_top#doc\">docs#exists_setIndependent_of_sSup_atoms_eq_top</a> into an indexed set for use in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=DirectSum.IsInternal#doc\">docs#DirectSum.IsInternal</a> (in particular, I'm thinking to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/DirectSum/Module.html#DirectSum.isInternal_submodule_iff_independent_and_iSup_eq_top\">DirectSum.isInternal_submodule_iff_independent_and_iSup_eq_top</a> to establish that an isotypic component can be written as an internal direct sum, namely of the independent set of spanning atoms)</p>",
        "id": 461950333,
        "sender_full_name": "Jiang Xu Wan",
        "timestamp": 1723494088
    },
    {
        "content": "<p>If you have an independent set, you can use the set itself as the indexing type</p>",
        "id": 461956338,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1723496113
    },
    {
        "content": "<p>I was trying that out, but the problem is that the indexing set needs to satisfy <code>DecidableEq</code> and <code>SupSet</code>, and I couldn't synthesize those on the indexing set. I need a work-around for this</p>",
        "id": 462185430,
        "sender_full_name": "Jiang Xu Wan",
        "timestamp": 1723574185
    },
    {
        "content": "<p>I would be surprised if the indexing set has to satisfy <code>SupSet</code>. You can use <code>letI := Classical.decEq s</code> to get the former typeclass</p>",
        "id": 462188326,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1723575000
    },
    {
        "content": "<p>Okay, that helped, thanks! I just needed to make the index set be Subtype.val (and it took quite a few tries to get that to work), and I now have <code>isotypic R M S</code> is a direct sum</p>",
        "id": 462227649,
        "sender_full_name": "Jiang Xu Wan",
        "timestamp": 1723591362
    }
]