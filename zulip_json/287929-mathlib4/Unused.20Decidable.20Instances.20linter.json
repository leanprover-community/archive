[
    {
        "content": "<p>I've ported mathlib3's <code>decidable_classical</code> linter as a syntax linter in <a href=\"https://github.com/leanprover-community/mathlib4/pull/31142\">#31142</a>, and addressed the remaining 37 violations in a non-dependent PR (<a href=\"https://github.com/leanprover-community/mathlib4/pull/31831\">#31831</a>). <a href=\"https://github.com/leanprover-community/mathlib4/pull/31747\">#31747</a> turns the linter on by default, and is now green. :)</p>\n<p>After I did the bulk of porting it, I was made aware that there's an <em>environment</em> linter that's been sitting for a while at <a href=\"https://github.com/leanprover-community/mathlib4/pull/10235\">#10235</a>! :) <span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span> has used that to valiantly clean up a bunch of violations already, even though <a href=\"https://github.com/leanprover-community/mathlib4/pull/10235\">#10235</a> was never merged, which is why there were so few to catch here. Hopefully a syntax linter that runs interactively (as opposed to only in CI or during <code>#lint</code>, as an <code>env_linter</code> does) is useful enough that the unintentional rewrite was worth it. :)</p>\n<p>The backend is also set up to be similarly extensible to allow <code>Fintype</code>, <code>Encodable</code>, etc. linters (e.g. <a href=\"https://github.com/leanprover-community/mathlib4/pull/31794\">#31794</a>)</p>\n<p>I'd love to hear feedback here, especially on</p>\n<ul>\n<li>the message (formatting; is the index of the parameter useful or noise?; etc.)</li>\n<li>behavior (is it enough to lint theorem-kind decls which are user-written, or should we <em>also</em> have an env_linter? I believe it's enough, but I'm interested in edge cases.)</li>\n<li>the name: I'm proposing naming it <code>unusedDecidableInType</code> instead of <code>decidableClassical</code>, so that every linter of this form can be named according to the same pattern (<code>unused&lt;_&gt;InType</code>)</li>\n<li>anything else! :)</li>\n</ul>\n<p>Note on planned future improvements: I've opened a couple of dependent PRs that improve the logging location somewhat (to the type signature, but not yet to the binders), and eventually it would be nice to have a try-this suggestion. But try-this suggestions turn out to both require a bunch more API and be quite cursed, so I'm holding off on creating an interactive suggestion for now.</p>",
        "id": 558333633,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1763601950
    },
    {
        "content": "<p>The main reason my version didn't get merged back then was bad performance. Could you please compare how fast is your linter compared to mine?</p>",
        "id": 558342670,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1763609548
    },
    {
        "content": "<p>Sure! The <a href=\"https://radar.lean-lang.org/repos/mathlib4/commits/fbf286e796923a5e6d10158d03f57a6b5e46cba5?reference=6ff93aa9daf0335e4150c1369fadbc9c669bc613\">bench results</a> on <a href=\"https://github.com/leanprover-community/mathlib4/pull/31747\">#31747</a>, with it turned on everywhere, show no significant changes.</p>\n<p>I use a bvar approach to detect dependence instead of telescoping and collecting fvars; this is what helps it be fast, I believe.</p>\n<p>Linting wall clock time <a href=\"https://speed.lean-lang.org/mathlib4/compare/e401c9b5-69af-41fc-a00b-700c5bb1560d/to/04bd78f5-4709-4ed6-aa1d-50f39bd66bd1\">seems to</a> increase by 2.5%, but it doesn't flag it as significant. If we want to try to get this down further: I wonder if the infotree traversal could be made faster. Though, I'm not sure how much wall clock time fluctuates anyway in these results.</p>\n<p>I can't quite find bench results for yours. How did you detect performance issues?</p>",
        "id": 558343487,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1763610162
    },
    {
        "content": "<p>AFAIR, it increased the linting time by a \"significant\" amount, but this increase can be not that significant as a percentage of the total runtime.</p>",
        "id": 558343628,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1763610276
    },
    {
        "content": "<p>Hmm, yeah—this one is of course also relative to a different linting process/pool of linters by virtue of being an interactive syntax linter instead of an environment linter, and I'm not sure how that affects the metrics here.</p>",
        "id": 558343812,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1763610405
    },
    {
        "content": "<p>But I don't remember the details. I can try to resurrect that PR just to (a) rerun <code>!bench</code>; (b) see if it finds anything on top of <a href=\"https://github.com/leanprover-community/mathlib4/pull/31831\">#31831</a></p>",
        "id": 558343926,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1763610506
    },
    {
        "content": "<p>(b) is very useful information! I currently don't lint anything besides theorem-kind decls (e.g. not <code>Prop</code>-typed defs, structures, etc.) and only lint declarations with bodies. Would be great to see if that's enough.</p>\n<p>Note also that <a href=\"https://github.com/leanprover-community/mathlib4/pull/31747\">#31747</a> exempts Mathlib.Data.Fintype.Quotients, Mathlib.Logic.Encodable.Basic, and a definition in Mathlib.Computability.Halting, since these are meant to be constructive—so I would expect you to find violations in these modules when re-running.</p>",
        "id": 558344240,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1763610745
    },
    {
        "content": "<p>I'll try to do it tomorrow.</p>",
        "id": 558344425,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1763610893
    },
    {
        "content": "<p>By the way, if it helps, I don't mind doing this. :) It looks like all that needs to be done is to copy the file over into current master and add some module incantations.</p>",
        "id": 558764285,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1763766378
    },
    {
        "content": "<p>Gave it a shot just to see if it was easy, and it was! :) CI is running at the draft PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/31920\">#31920</a>.</p>",
        "id": 558765512,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1763767264
    },
    {
        "content": "<p>Okay! Results are in. Here's a breakdown, cleaned up and made readable.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>env_linter results, commentated</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\"><pre><span></span><code>/- The `decidableClassical` linter reports:\nUSES OF `Decidable` SHOULD BE REPLACED WITH `classical` IN THE PROOF. -/\n</code></pre></div>\n<h3>Syntax linter not imported</h3>\n<p>The following do not import <code>Mathlib.Tactic.Linter</code>, so the syntax linter is not available. But if we do import it:</p>\n<p><span aria-label=\"document\" class=\"emoji emoji-1f4c4\" role=\"img\" title=\"document\">:document:</span> <em>Mathlib.Logic.Basic</em></p>\n<div class=\"codehilite\"><pre><span></span><code>dec_em argument 2 inst✝ : Decidable p\n@Not.decidable_imp_symm argument 3 inst✝ : Decidable a\n</code></pre></div>\n<p><code>alias</code>es for <code>Decidable.em</code> and <code>Decidable.not_imp_symm</code>: aliases are not picked up by the syntax linter, and the declarations they are aliases for start with <code>Decidable</code>, which exempts them</p>\n<div class=\"codehilite\"><pre><span></span><code>dec_em&#39; argument 2 inst✝ : Decidable p\n</code></pre></div>\n<p>caught by syntax linter as expected</p>\n<p><span aria-label=\"document\" class=\"emoji emoji-1f4c4\" role=\"img\" title=\"document\">:document:</span> <em>Mathlib.Order.Heyting.Regular</em></p>\n<div class=\"codehilite\"><pre><span></span><code>Heyting.isRegular_of_decidable argument 2 inst✝ : Decidable p\n</code></pre></div>\n<p>caught by syntax linter as expected</p>\n<h3>Already caught, exempted for constructive reasons</h3>\n<p><span aria-label=\"document\" class=\"emoji emoji-1f4c4\" role=\"img\" title=\"document\">:document:</span> <em>Mathlib.Logic.Encodable.Basic</em></p>\n<div class=\"codehilite\"><pre><span></span><code>@Encodable.axiom_of_choice argument 5 inst✝ : (x : α) → (y : β x) → Decidable (R x y)\n@Encodable.skolem argument 5 inst✝ : (x : α) → (y : β x) → Decidable (P x y)\n</code></pre></div>\n<p><span aria-label=\"document\" class=\"emoji emoji-1f4c4\" role=\"img\" title=\"document\">:document:</span> <em>Mathlib.Computability.Halting</em></p>\n<div class=\"codehilite\"><pre><span></span><code>@ComputablePred.computable_iff_re_compl_re argument 4 inst✝ : DecidablePred p\n</code></pre></div>\n<p><span aria-label=\"document\" class=\"emoji emoji-1f4c4\" role=\"img\" title=\"document\">:document:</span> <em>Mathlib.Data.Fintype.Quotient</em></p>\n<div class=\"codehilite\"><pre><span></span><code>@Quotient.list_ind argument 2 inst✝ : DecidableEq ι\n@Quotient.ind_fintype_pi argument 3 inst✝ : DecidableEq ι\n@Quotient.induction_on_fintype_pi argument 3 inst✝ : DecidableEq ι\n</code></pre></div>\n<h3>False positives from <code>env_linter</code>:</h3>\n<p><span aria-label=\"document\" class=\"emoji emoji-1f4c4\" role=\"img\" title=\"document\">:document:</span> <em>Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks</em></p>\n<div class=\"codehilite\"><pre><span></span><code>@CategoryTheory.Limits.WidePullbackShape.instDecidableEqHom.decEq argument 4 inst✝ : DecidableEq J✝\n@CategoryTheory.Limits.WidePushoutShape.instDecidableEqHom.decEq argument 4 inst✝ : DecidableEq J✝\n</code></pre></div>\n<p>Both are <code>DecidableEq</code> instances created by <code>deriving</code>, e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- The type of arrows for the shape indexing a wide pushout. -/</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Hom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">WidePushoutShape</span><span class=\"w\"> </span><span class=\"n\">J</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">WidePushoutShape</span><span class=\"w\"> </span><span class=\"n\">J</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">w</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Hom</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">X</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">J</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Hom</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span>\n\n<span class=\"c1\">-- See https://github.com/leanprover/lean4/issues/10295</span>\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">nolint</span><span class=\"w\"> </span><span class=\"n\">unusedArguments</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">instDecidableEqHom</span><span class=\"bp\">.</span><span class=\"n\">decEq</span>\n</code></pre></div>\n<p>which I suspect makes them false positives.</p>\n<p><span aria-label=\"document\" class=\"emoji emoji-1f4c4\" role=\"img\" title=\"document\">:document:</span> <em>Mathlib.LinearAlgebra.RootSystem.GeckConstruction.Basic</em></p>\n<div class=\"codehilite\"><pre><span></span><code>@RootPairing.GeckConstruction.h_mem_cartanSubalgebra argument 14 inst✝ : DecidableEq ι\n</code></pre></div>\n<p>The type <em>does</em> explicitly depend on the instance (via <code>cartanSubalgebra</code>):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">h_mem_cartanSubalgebra</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">support</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">cartanSubalgebra</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n</code></pre></div>\n<h3>New violations in master!</h3>\n<p>Also picked up by syntax linter after merging master:</p>\n<p><span aria-label=\"document\" class=\"emoji emoji-1f4c4\" role=\"img\" title=\"document\">:document:</span> <em>Mathlib.RingTheory.TensorProduct.IsBaseChangePi</em></p>\n<div class=\"codehilite\"><pre><span></span><code>@IsBaseChange.directSum argument 7 inst✝⁶ : DecidableEq ι\n@IsBaseChange.directSumPow argument 7 inst✝⁶ : DecidableEq ι\n@IsBaseChange.finsuppPow argument 7 inst✝⁶ : DecidableEq ι\n</code></pre></div>\n<h3>Syntax linter miss: <code>noncomputable def</code></h3>\n<p>The current version of the syntax linter doesn't pick up defs.</p>\n<p><span aria-label=\"document\" class=\"emoji emoji-1f4c4\" role=\"img\" title=\"document\">:document:</span> <em>Mathlib.RingTheory.TensorProduct.IsBaseChangeFree</em></p>\n<p>But this def is data-carrying, and not a <code>Prop</code>.<br>\nIs its use of <code>DecidableEq</code> in the body warranted for unfolding/defeq reasons?</p>\n<div class=\"codehilite\"><pre><span></span><code>noncomputable def basis :\n    Module.Basis ι S W where\n  repr := (ibc.equiv.symm.trans (b.repr.baseChange R S _ _)).trans\n      (finsuppPow ι (linearMap R S)).equiv\n</code></pre></div>\n<div class=\"codehilite\"><pre><span></span><code>@IsBaseChange.basis argument 15 inst✝ : DecidableEq ι\n</code></pre></div>\n</div></div>",
        "id": 558773539,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1763774147
    },
    {
        "content": "<p>The upshot: I feel pretty confident in the syntax linter! :) It's picked up everything I believe it should except that <code>noncomputable def</code>, and I'm not completely sure about that one.</p>",
        "id": 558773618,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1763774235
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"548935\">Thomas Murrills</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Unused.20Decidable.20Instances.20linter/near/558773539\">said</a>:</p>\n<blockquote>\n<h3>False positives from <code>env_linter</code>:</h3>\n<p><span aria-label=\"document\" class=\"emoji emoji-1f4c4\" role=\"img\" title=\"document\">:document:</span> <em>Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks</em></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">@</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Limits</span><span class=\"bp\">.</span><span class=\"n\">WidePullbackShape</span><span class=\"bp\">.</span><span class=\"n\">instDecidableEqHom</span><span class=\"bp\">.</span><span class=\"n\">decEq</span><span class=\"w\"> </span><span class=\"n\">argument</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">✝</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">J</span><span class=\"bp\">✝</span>\n<span class=\"bp\">@</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Limits</span><span class=\"bp\">.</span><span class=\"n\">WidePushoutShape</span><span class=\"bp\">.</span><span class=\"n\">instDecidableEqHom</span><span class=\"bp\">.</span><span class=\"n\">decEq</span><span class=\"w\"> </span><span class=\"n\">argument</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">✝</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">J</span><span class=\"bp\">✝</span>\n</code></pre></div>\n<p>Both are <code>DecidableEq</code> instances created by <code>deriving</code>, e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- The type of arrows for the shape indexing a wide pushout. -/</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Hom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">WidePushoutShape</span><span class=\"w\"> </span><span class=\"n\">J</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">WidePushoutShape</span><span class=\"w\"> </span><span class=\"n\">J</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">w</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Hom</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">X</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">J</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Hom</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span>\n\n<span class=\"c1\">-- See https://github.com/leanprover/lean4/issues/10295</span>\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">nolint</span><span class=\"w\"> </span><span class=\"n\">unusedArguments</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">instDecidableEqHom</span><span class=\"bp\">.</span><span class=\"n\">decEq</span>\n</code></pre></div>\n<p>which I suspect makes them false positives.</p>\n</blockquote>\n<p>Depending on what you mean by false positive, I don't think this is a false positive. These types are subsingleton, so you definitely don't need the decEq arguments.</p>",
        "id": 558774256,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763774889
    },
    {
        "content": "<p>I was partially thinking \"and we don't want to lint automatically generated decls\" (maybe we do, at least ones generated by <code>deriving</code>?), but also thought that the <code>[nolint unusedArguments]</code> was in some way affirming this type as \"correct\", and hadn't considered what you said. :)</p>\n<p>But, it does go against my intuitions here. It happens to be true that we can rewrite this particular definition without <code>[DecidableEq J]</code>—but in general, we don't want to suggest using classicality in any subsingleton <code>Type u</code>s (as the linter would do), right?</p>",
        "id": 558777427,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1763778350
    },
    {
        "content": "<p>These autogenerated <code>DecidableEq</code> instances assume <code>DecidableEq</code> but never use it. So, they're wrong. There is a Lean core issue tracking this.</p>",
        "id": 558777637,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1763778561
    },
    {
        "content": "<p><code>Mathlib.RingTheory.TensorProduct.IsBaseChangeFree</code>: I guess, the <code>DecidableEq</code> assumption is used in the <em>proofs</em> only, not in computing the data. I can check it later tonight.</p>",
        "id": 558777725,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1763778635
    },
    {
        "content": "<p>I think that we should compare the performance of two linters (disabling <code>Finite</code>/<code>Fintype</code> etc in my version).</p>",
        "id": 558777809,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1763778734
    },
    {
        "content": "<p>Ah, I've just realized I left <code>inhabitedNonempty</code> on. <span aria-label=\"woman facepalming\" class=\"emoji emoji-1f926-200d-2640\" role=\"img\" title=\"woman facepalming\">:woman_facepalming:</span> Let me fix that and re-bench.</p>",
        "id": 558777892,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1763778840
    },
    {
        "content": "<p>Though, if we want to compare like to like, we should really use the bvar machinery in the env linter and the telescoping machinery in the syntax linter, and compare all four... <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>\n<p>The syntax linter by nature has to do some infotree searching but can run asynchronously on each declaration, and the env_linter is applied to more declarations. It's not clear to me how these might affect the metrics either way!</p>",
        "id": 558778482,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1763779552
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> I remember that you had an opinion on this topic.</p>",
        "id": 558778637,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1763779763
    },
    {
        "content": "<p>(I'll note that there is one part of the telescoping machinery I'm a little suspicious of: checking whether hypotheses of non-<code>Prop</code>s are used in the <em>body</em> of these <code>def</code>s after erasing proofs. I restrict my attention to theorems for now.)</p>",
        "id": 558778888,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1763780067
    },
    {
        "content": "<p>I found some <code>def</code>s that used <code>Decidable</code> assumptions for proofs but not for data.</p>",
        "id": 558778952,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1763780144
    },
    {
        "content": "<p>Oh, okay, nice! We should definitely do that in the syntax linter too, then—as long as it's performant. :)</p>",
        "id": 558780219,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1763781630
    },
    {
        "content": "<p>I remember that Kyle has ideas about performance but the suggestions were beyond my understanding of Lean metaprogramming at that time.</p>",
        "id": 558780281,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1763781688
    },
    {
        "content": "<p>So, let's wait.</p>",
        "id": 558780285,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1763781692
    },
    {
        "content": "<p>For sure. :) I'd also like to add it as a subsequent feature to the syntax linter in a future PR, so that it's easier to review.</p>",
        "id": 558780323,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1763781732
    },
    {
        "content": "<p>Ah, I assumed Kyle's comment had been incorporated into the PR already.</p>",
        "id": 558780354,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1763781765
    },
    {
        "content": "<p>(I'm benching Kyle's version now as well, without checking it works.)</p>",
        "id": 558780604,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1763782054
    },
    {
        "content": "<p>(There is one futher optimization that could be done: don't erase proofs, but merely avoid them while traversing the expression to collect fvars.)</p>",
        "id": 558780663,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1763782125
    },
    {
        "content": "<p>Aside: I clean up those new violations in <a href=\"https://github.com/leanprover-community/mathlib4/pull/31934\">#31934</a>.</p>",
        "id": 558781130,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1763782643
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Unused.20Decidable.20Instances.20linter/near/558777725\">said</a>:</p>\n<blockquote>\n<p><code>Mathlib.RingTheory.TensorProduct.IsBaseChangeFree</code>: I guess, the <code>DecidableEq</code> assumption is used in the <em>proofs</em> only, not in computing the data. I can check it later tonight.</p>\n</blockquote>\n<p>I'm not surprised, but it seems you were right about this. :) The instance becomes completely unnecessary in that file after fixing the violations picked up by the linters in its import <code>Mathlib.RingTheory.TensorProduct.IsBaseChangePi</code>.</p>",
        "id": 558781693,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1763783316
    },
    {
        "content": "<p>By the way, <span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span>, Kim asked as a review question on <a href=\"https://github.com/leanprover-community/mathlib4/pull/31142\">#31142</a> why we filter out declarations in the <code>Decidable</code> namespace. </p>\n<p>I assumed it's because theorems in the decidable namespace are allowed to be \"about\" <code>Decidable*</code> classes without \"using\" them, but ultimately I had cargo culted this later on after having seen yours. :) Is that right, or am I misunderstanding?</p>",
        "id": 559133900,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1764012397
    },
    {
        "content": "<p>Yes, we have theorems like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Decidable.eq_or_ne#doc\">docs#Decidable.eq_or_ne</a> that depend on <code>Decidable</code> to avoid classical reasoning.</p>",
        "id": 559142302,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1764015098
    },
    {
        "content": "<p>Also, here's a summary of the bench results:</p>\n<ul>\n<li>I benched the environment linter as well as Kyle's suggested optimization to it (after fixing a code typo) at <a href=\"https://github.com/leanprover-community/mathlib4/pull/31920\">#31920</a>. Kyle's improvements did make it more efficient, but it still showed up as changing linting by +6.7%. <a href=\"https://radar.lean-lang.org/repos/mathlib4/commits/f24d9836a331a3d33250ab19b4e6de1f71d3133b?reference=82d756ea359cfa0f2c10bc00b8a997822c3b32ea\">Here</a> are the radar results for Kyle's tweaks to the env linter.<ul>\n<li>But: this is an increase relative to environment linting. It doesn't really compare like to like.</li>\n</ul>\n</li>\n<li>I benched the syntax linter at <a href=\"https://github.com/leanprover-community/mathlib4/pull/31747\">#31747</a>, results <a href=\"https://radar.lean-lang.org/repos/mathlib4/commits/bee96eeeb51c4b0b65d2b0690423e1f5dd71dd46?reference=b3cf7a02d3df909b93210a065e3be9de016129c5\">here</a>. It found no significant changes, but is relative to the whole build, which is much bigger.</li>\n<li>So, I put your and Kyle's telescoping implementation into the syntax linter: <a href=\"https://github.com/leanprover-community/mathlib4/pull/32066\">#32066</a>. I commented out all the features not present in the current syntax linter (erasing proofs, checking def values, etc.) so that we're <em>just</em> comparing the telescoping approach to the bvar approach, and not also doing extra work. That comparison is <a href=\"https://radar.lean-lang.org/repos/mathlib4/commits/daef4ad1fea76223b8a21cfdf1761cc9bc6e8480?reference=bee96eeeb51c4b0b65d2b0690423e1f5dd71dd46\">here</a> (with the bvar method as the reference commit).<ul>\n<li>It seems that the telescoping causes radar to mention \"minor changes\" of +0.2% to instructions across the whole build.</li>\n<li>It seems that telescoping also adds a few seconds to the clock.</li>\n</ul>\n</li>\n</ul>\n<p>All in all, these aren't huge changes. We could probably get away with them, and I don't notice a delay while editing interactively. However, the bvar approach seems a hair more performant.</p>\n<p>If we <a href=\"https://radar.lean-lang.org/repos/mathlib4/commits/daef4ad1fea76223b8a21cfdf1761cc9bc6e8480?reference=f24d9836a331a3d33250ab19b4e6de1f71d3133b\">compare syntax linting to environment linting</a>, using just the telescoping approach in both, we seem to find that environment linting adds less time to the clock. But, I do believe that the value of an interactive syntax linter one way or another is high enough that we probably ought to go for it. :)</p>\n<p>What are your thoughts here? Kim has reviewed and delegated the syntax linter PR to me, so I can pull the trigger if we agree it would be useful to have it in. But I'd like your input first.</p>",
        "id": 559144431,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1764015876
    },
    {
        "content": "<p>I would love to have some version of this linter (syntax or environment) in Mathlib. I have no opinion on which approach is better.</p>",
        "id": 559145338,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1764016138
    },
    {
        "content": "<p>Ok, great. :) I'll pull the trigger on the syntax linter, then! <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span></p>",
        "id": 560011662,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1764016943
    },
    {
        "content": "<p>Also, not sure I said it explicitly, but apologies for missing your prior work here; it did turn out to be very useful to see the way it was factored to be generic, helped with some specific things like the <code>Decidable</code> name prefix checking, and the work you'd done prior made it feasible to actually turn the linter on.</p>\n<p>I know you haven't asked for it, but I think it's only fair to add you as co-author to the current PR to recognize that work, even though the PRs are different. (And technically, the <code>Decidable</code> name prefix check comes <em>directly</em> from your PR, so there is a defensible link! :) )</p>",
        "id": 560011819,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1764016992
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> I've exempted Mathlib.Order.Heyting.Regular from the linter; my intuition is that we want this file to be intuitionistic, but I'd like to confirm that with you (since you're the only author on that file), as the linter fires on <code>isRegular_of_decidable</code>. :)</p>",
        "id": 560638178,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1764261721
    },
    {
        "content": "<p>Ahah, yes indeed! To be quite fair, this is the only lemma in the whole file that deserves to be nolinted</p>",
        "id": 560638471,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1764261811
    },
    {
        "content": "<p>True! I had exempted the whole file with <code>set_option linter.unusedDecidableInType</code> to \"future-proof\" it (and left a comment, since I'm guessing the whole file really should be intuitionistic, on principle?), but octopus-react to this message and I'll move it to just that declaration <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 560658518,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1764270243
    },
    {
        "content": "<p>This linter just checks the type, not the body of the proof, right? So if for instance I use a term elaborator within the proof that depends on a <code>DecidableEq</code> instance, this is expected to trigger a warning?</p>",
        "id": 561169311,
        "sender_full_name": "Chris Henson",
        "timestamp": 1764598057
    },
    {
        "content": "<p>yes</p>",
        "id": 561169672,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764598141
    },
    {
        "content": "<p>hmm</p>",
        "id": 561170298,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764598286
    },
    {
        "content": "<p>but what if the statement contains a proof?</p>",
        "id": 561170378,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764598301
    },
    {
        "content": "<p>does it check those?</p>",
        "id": 561170403,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764598305
    },
    {
        "content": "<p>Not yet; two later improvements in that vein I’d like to incorporate are</p>\n<ul>\n<li>that (not counting dependence from proofs in the statement)</li>\n<li>not counting dependence from proofs in the body of a <code>def</code></li>\n</ul>\n<p>Note that the challenge here is not figuring out how to do this, but staying performant-enough while doing it across all of mathlib. But luckily we haven’t exhausted the possibilities for improving performance yet; there are things to experiment with. <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 561190158,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1764602244
    }
]