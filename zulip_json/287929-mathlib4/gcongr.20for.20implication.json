[
    {
        "content": "<p>How hard would it be to modify <code>gcongr</code> to support implication? I imagine it utilizing stuff like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=forall_imp#doc\">docs#forall_imp</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Exists.imp#doc\">docs#Exists.imp</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=And.imp#doc\">docs#And.imp</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Or.imp#doc\">docs#Or.imp</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Not.imp#doc\">docs#Not.imp</a>, but also more specific stuff like <code>a ≤ b → c ≤ d → (b &lt; c → a &lt; d)</code>, and there could be a macro for <code>revert h; gcongr</code> or <code>apply (_ : _ → _) h; gcongr</code> as a weaker form of <code>convert</code></p>",
        "id": 472712972,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1727275028
    },
    {
        "content": "<p>I think that would be nice! It's probably a bit of work to implement, since implication is not a constant, and so has to be special-cased.</p>",
        "id": 472720955,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1727277259
    },
    {
        "content": "<p>I'll try to implement it</p>",
        "id": 472728660,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1727279569
    },
    {
        "content": "<p>Is there a definition <code>fun (a b : Prop) ↦ a → b</code> somewhere?</p>",
        "id": 472739678,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1727283452
    },
    {
        "content": "<p>Since you're talking about metaprogramming, what what sort of function do you mean? Literally some sort of <code>Imp</code> declaration (which you can write as <code>(· → ·)</code> by the way), or something to construct implications when metaprogramming?</p>",
        "id": 472741132,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727283944
    },
    {
        "content": "<p>Just some sort of <code>Imp</code> declaration, so I'd only have to convert implications to it and then it's a relation</p>",
        "id": 472741339,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1727284010
    },
    {
        "content": "<p>I encountered a problem that <code>gcongr</code> introduces all hypothesis to the main goal it produces, but when the main goal is actually an implication we don't want to introduce the last hypothesis. Is there a version of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.MVarId.introsWithBinderIdents#doc\">docs#Lean.MVarId.introsWithBinderIdents</a> I can use to introduce all variables except the last one?</p>",
        "id": 472743094,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1727284746
    },
    {
        "content": "<p>After some looking, I don't see any <code>Imp</code>-like function. Depending on where this is in the code, you might consider special-casing implications in the code so that implication still acts like a relation.</p>",
        "id": 472743638,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727284946
    },
    {
        "content": "<p>For your <code>introsWithBinderIndents</code> question, is that function already in the gcongr code, or are you using it because you happen to have BinderIdents? Usually I see <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.MVarId.intros#doc\">docs#Lean.MVarId.intros</a> in tactics.  Too bad it's not public, but in the module where it's defined there's a function <code>getIntrosSize</code> you could use, and then use that for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.MVarId.introN#doc\">docs#Lean.MVarId.introN</a></p>",
        "id": 472743958,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727285078
    },
    {
        "content": "<p>That's the function already in the code</p>",
        "id": 472743998,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1727285099
    },
    {
        "content": "<p>I see. I also see that <code>introsWithBinderIdents</code> makes use of <code>getIntrosSize</code> to compute how many times to intro. Anyway, the answer is very very likely \"no\" to you question about there being any pre-existing function that does intros-but-one.</p>\n<p>I guess your idea to use an <code>Imp</code> function would help here, to be able to hide that it's an implication.</p>",
        "id": 472744733,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727285405
    },
    {
        "content": "<p>I see, then I'll copy <code>introsWithBinderIdents</code> but edit it to use <code>getIntrosSize - 1</code></p>",
        "id": 472744910,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1727285498
    },
    {
        "content": "<p>How about instead making <code>introNWithBinderIdents</code> that takes in a number of variables to intro, then implement <code>introsWithBinderIdents</code> in terms of that.</p>",
        "id": 472745486,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727285717
    },
    {
        "content": "<p>I managed to get it to (seemingly) work for stuff like <code>(∃ x, a x ∧ b x) → ∃ x, c x ∧ d x</code>, but there's a problem with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=forall_imp#doc\">docs#forall_imp</a> - it sees it as <code>(∀ (a : α), p a) → ((a : α) → q a)</code> and then complains that <code>(a : α) → q a</code> isn't a valid relation. Is there a better solution to that than trying all suffixes as a possible RHS?</p>",
        "id": 472745964,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1727285907
    },
    {
        "content": "<p>Are you reimplementing <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Mathlib.Tactic.Peel.peel#doc\">docs#Mathlib.Tactic.Peel.peel</a> ?</p>",
        "id": 472746257,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1727286046
    },
    {
        "content": "<p>I'm trying to implement it as part of <code>gcongr</code></p>",
        "id": 472746564,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1727286187
    },
    {
        "content": "<p>There's actually a version of this (with special-casing of implication, done as a separate attribute <code>@[grw]</code>, but basically the same idea) implemented on <a href=\"https://github.com/leanprover-community/mathlib4/tree/HM-grw-attribute\">branch#HM-grw-attribute</a>:<br>\n<a href=\"https://github.com/leanprover-community/mathlib4/blob/ef82c2de29ac2f582687c38f809f199ed3373698/Mathlib/Tactic/GRW/Core.lean#L39-L60\">https://github.com/leanprover-community/mathlib4/blob/ef82c2de29ac2f582687c38f809f199ed3373698/Mathlib/Tactic/GRW/Core.lean#L39-L60</a></p>",
        "id": 472755234,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1727289734
    },
    {
        "content": "<p>The history of that branch is that it was going to be a follow-up to <a href=\"https://github.com/leanprover-community/mathlib4/pull/8167\">#8167</a>, which never got merged (there was a slow review process and we lost the original author).</p>",
        "id": 472755347,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1727289796
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"690858\">@Daniel Weber</span>, any chance you would like to adopt <a href=\"https://github.com/leanprover-community/mathlib4/pull/8167\">#8167</a>?</p>",
        "id": 472755408,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1727289823
    },
    {
        "content": "<p>I don't think I could do it well, it seems quite complex and I don't know metaprogramming well</p>",
        "id": 472804951,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1727319926
    }
]