[
    {
        "content": "<p>I'm kind of curious about the level of effort required to prove that the theory of algebraically closed fields of fixed characteristic is categorical at a given cardinal.</p>\n<p>It looks like a couple of lemmas needed are:</p>\n<ul>\n<li>An algebraically closed field of cardinality k has a transcendence base of size k</li>\n<li>Two fields of the same char with the same cardinality transcendence base are isomorphic</li>\n</ul>\n<p>I hope I got those right.</p>\n<p>How close are we to proving those theorems in the current ecosystem?</p>",
        "id": 432970253,
        "sender_full_name": "Cody Roux",
        "timestamp": 1712950633
    },
    {
        "content": "<p>Are the things in <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/FieldTheory/IsAlgClosed/Classification.html\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/FieldTheory/IsAlgClosed/Classification.html</a> relevant?</p>",
        "id": 432972243,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1712951573
    },
    {
        "content": "<p>Oh yeah! What do you know. Wow it feels very accessible to prove completeness of closed fields!</p>",
        "id": 432974615,
        "sender_full_name": "Cody Roux",
        "timestamp": 1712952583
    },
    {
        "content": "<p>I would generally suggest clicking on \"Imported by\" on the right hand side of that page to see if anything within Mathlib builds on top of these results, but in this case there's nothing</p>",
        "id": 432975128,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1712952778
    },
    {
        "content": "<p>For note: These theorems, combined with Łoś–Vaught <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/ModelTheory/Satisfiability.html#Cardinal.Categorical.isComplete\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/ModelTheory/Satisfiability.html#Cardinal.Categorical.isComplete</a> brings completeness of complete fields within striking distance</p>",
        "id": 432975201,
        "sender_full_name": "Cody Roux",
        "timestamp": 1712952815
    },
    {
        "content": "<p>Sadly completeness only implies decidability on paper; the algorithm is completely impractical</p>",
        "id": 432975297,
        "sender_full_name": "Cody Roux",
        "timestamp": 1712952855
    },
    {
        "content": "<p>But it has cool applications! E.g. a proof of Ax-Grothendieck uses this.</p>",
        "id": 432975359,
        "sender_full_name": "Cody Roux",
        "timestamp": 1712952895
    },
    {
        "content": "<p>You might be interested in <a href=\"https://github.com/Jlh18/ModelTheory8Report/blob/main/report/m4r.pdf\">https://github.com/Jlh18/ModelTheory8Report/blob/main/report/m4r.pdf</a> (its in lean 3 but still cool!)</p>",
        "id": 432979820,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1712955058
    },
    {
        "content": "<p>Wow the whole thing is already done! I'm constantly amazed at the maturity of the lib. A tiny bit sad this hasn't been ported yet.</p>\n<p>I guess the very last step would be trying to make this a \"tactic\" that reduces a proposition over </p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span></span></p>\n<p>to </p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi mathvariant=\"normal\">∃</mi><mi>n</mi><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">∀</mi><mi>p</mi><mo>&gt;</mo><mi>n</mi><mo separator=\"true\">,</mo><msub><mover accent=\"true\"><mi mathvariant=\"double-struck\">F</mi><mo stretchy=\"true\">‾</mo></mover><mi>p</mi></msub><mtext> </mtext><mo>…</mo></mrow><annotation encoding=\"application/x-tex\">\\exists n, \\forall p &gt; n, \\overline{\\mathbb{F}}_p\n\\ \\ldots</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\">∃</span><span class=\"mord mathnormal\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.175em;vertical-align:-0.2861em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord overline\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8889em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">F</span></span></span><span style=\"top:-3.8089em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"overline-line\" style=\"border-bottom-width:0.04em;\"></span></span></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mspace\"> </span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">…</span></span></span></span></span></p>\n<p>has anyone done <em>that</em>?</p>",
        "id": 432992730,
        "sender_full_name": "Cody Roux",
        "timestamp": 1712961934
    },
    {
        "content": "<p>I'm not aware of that.</p>",
        "id": 433012477,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1712980292
    },
    {
        "content": "<p>Cody the Ax-Grothendieck thing above was just a masters project I supervised. I don't think anyone is trying to port it right now and I can't claim that it was done in the best way because the supervisor knew very little about what was going on in that project.</p>",
        "id": 433033705,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1713001405
    },
    {
        "content": "<p>Is <a href=\"https://github.com/leanprover-community/mathlib4/pull/6468\">#6468</a> a port to Lean 4? (Many pieces of it were merged, but as far as I can see, the remainders are available for somebody to pick up and finish.)</p>",
        "id": 433034030,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1713001765
    },
    {
        "content": "<p>Looks like it! Certainly Chris (the author of the PR) helped a lot with the project</p>",
        "id": 433034122,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1713001840
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116028\">Cody Roux</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Status.20of.20field.20theory.20in.20Mathlib.204/near/432992730\">said</a>:</p>\n<blockquote>\n<p>Wow the whole thing is already done! I'm constantly amazed at the maturity of the lib. A tiny bit sad this hasn't been ported yet.</p>\n<p>I guess the very last step would be trying to make this a \"tactic\" that reduces a proposition over </p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span></span></p>\n<p>to </p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi mathvariant=\"normal\">∃</mi><mi>n</mi><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">∀</mi><mi>p</mi><mo>&gt;</mo><mi>n</mi><mo separator=\"true\">,</mo><msub><mover accent=\"true\"><mi mathvariant=\"double-struck\">F</mi><mo stretchy=\"true\">‾</mo></mover><mi>p</mi></msub><mtext> </mtext><mo>…</mo></mrow><annotation encoding=\"application/x-tex\">\\exists n, \\forall p &gt; n, \\overline{\\mathbb{F}}_p\n\\ \\ldots</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\">∃</span><span class=\"mord mathnormal\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.175em;vertical-align:-0.2861em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord overline\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8889em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">F</span></span></span><span style=\"top:-3.8089em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"overline-line\" style=\"border-bottom-width:0.04em;\"></span></span></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mspace\"> </span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">…</span></span></span></span></span></p>\n<p>has anyone done <em>that</em>?</p>\n</blockquote>\n<p>I'm a little bit late here, but I would argue that this tactic is not the main thing that you need.</p>\n<p>Most example of first order properties are infinite collections of formulas, or formulas that themselves depend on some Lean variables. For example the Ax-Grothendieck theorem has to be split into an infinite collection of formulas, one for each set of monomials in the polynomial map.</p>\n<p>Another application I've seen of this is that for any finite semigroup <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span>, the statement <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> has a faithful representation of dimension <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> is a first order formula. Another example is the fact that adjoining a square root of -1 to a real closed field gives an algebraically closed field (I think this would be one formula for each <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> to say that every polynomial of degree <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> had a root, as well as some work to prove that evaluating a polynomial over the extension was definable as a function on pairs of elements of the base field).</p>\n<p>I think the main thing required here is just a library with a lot of different ways of constructing these formulas. (I think this is the answer to a lot of questions. Where people think automation is needed, a bigger library would often work instead). For example, for the fact about semigroups above you will need to know that matrix multiplication is a definable function. You also need constructors for quantifying over an arbitrary finite set of variables <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FirstOrder.Language.Formula.iAlls#doc\">docs#FirstOrder.Language.Formula.iAlls</a>, and definitions for proving that properties of definable functions like injectivity are first order and so on <a href=\"https://github.com/leanprover-community/mathlib4/pull/20180\">mathlib4#20180</a></p>",
        "id": 491403533,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1735651302
    },
    {
        "content": "<p>Maybe we just need a really (really!) complete library. But this does seem like a departure from informal maths, where one says \"oh and just look at our informal development, you can observe that everything is first order\". Now instead we need to build all these observations in by hand. Maybe it's the computer scientist in me, but some of this has to be automatable, no?</p>\n<p>Otherwise it feels like we're just building a theorem prover \"one floor down\".</p>",
        "id": 491408833,
        "sender_full_name": "Cody Roux",
        "timestamp": 1735655455
    },
    {
        "content": "<p>I would love to have some tactic (or more general meta code) that transports terms across some isomorphism of structures (in the sense of model theory).</p>",
        "id": 491409237,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1735655737
    },
    {
        "content": "<p>And perhaps a <code>los</code> tactic that lets you prove a first order goal about an ultraproduct by proving it on a large set of the factors</p>",
        "id": 491409356,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1735655828
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> probably has useful comments here (coming from his work on o-minimality).</p>",
        "id": 491409658,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1735656073
    },
    {
        "content": "<p>That would be nice, though I personally feel like people use ultraproducts when they could use completeness. Maybe the former avoids this problem of \"syntactification\"</p>",
        "id": 491412155,
        "sender_full_name": "Cody Roux",
        "timestamp": 1735657966
    },
    {
        "content": "<p>I think it's likely that mathlib would handle ultraproducts better than the syntactic approach, simply because the library has been set up to deal with isomorphisms and products and so forth of algebraic structures already, so lemmas about how matrices behave acros homomorphisms are already there, but the corresponding infrastructure isn't there in a model-theoretic way. I don't have a stance on which is better out of syntactic or ultraproducts, probably the best one is whichever is more familiar to the user and mathlib should aim to support both.</p>",
        "id": 491440011,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1735677437
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116028\">Cody Roux</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Status.20of.20field.20theory.20in.20Mathlib.204/near/491408833\">said</a>:</p>\n<blockquote>\n<p>Maybe we just need a really (really!) complete library. But this does seem like a departure from informal maths, where one says \"oh and just look at our informal development, you can observe that everything is first order\". Now instead we need to build all these observations in by hand. Maybe it's the computer scientist in me, but some of this has to be automatable, no?</p>\n<p>Otherwise it feels like we're just building a theorem prover \"one floor down\".</p>\n</blockquote>\n<p>I think the closest practical approach to this is to have really nice notation for writing down formulas, but the user would still be writing a <code>Formula</code>, and not a Lean term with a tactic to reverse engineer the FirstOrder Formula whose semantics are the Lean term. <code>simp</code> is very good at proving that formulas have the expected semantics once you've written down the formula. (Incidentally I'd love to have nice notation like this in other areas of mathlib as well, for example it would be great to use lambda calculus to write down morphisms in a Cartesian closed category).</p>\n<p>I do think there's an awful lot of things that feel automatable in mathlib but aren't automated. Every time you define a new algebraic object there's a long list of <code>simp</code> lemmas to prove that feel very repetitive but the practice seems to say that they're not quite repetitive enough to be able to automate yet. But maybe we haven't tried hard enough.</p>",
        "id": 491442551,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1735679643
    },
    {
        "content": "<p>Hmmm, maybe this is a good opportunity for a macro dsl, whatever they're called.</p>",
        "id": 491443902,
        "sender_full_name": "Cody Roux",
        "timestamp": 1735680857
    }
]