[
    {
        "content": "<p>I noticed a property of functions that keeps popping up in many places, <code>∀ x, f x = 0 → x = 0</code>, and was wondering whether we can give this property a name and replace all occurrences of it in Mathlib.<br>\nOr maybe there already is such a property defined, and a lot of theorems missed it.</p>\n<p>There are 66 occurrences of <code>(\\w+) = 0 → \\1 = 0</code> in Mathlib, here are some of them:</p>\n<ul>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=QuadraticMap.Anisotropic#doc\">docs#QuadraticMap.Anisotropic</a></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearMap.disjoint_ker#doc\">docs#LinearMap.disjoint_ker</a></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearMap.ker_eq_bot%27#doc\">docs#LinearMap.ker_eq_bot'</a></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RingHom.ker_eq_bot_iff_eq_zero#doc\">docs#RingHom.ker_eq_bot_iff_eq_zero</a></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AddGroupNorm#doc\">docs#AddGroupNorm</a></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AddGroupNormClass#doc\">docs#AddGroupNormClass</a></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=NonarchAddGroupNorm#doc\">docs#NonarchAddGroupNorm</a></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=NonarchAddGroupNormClass#doc\">docs#NonarchAddGroupNormClass</a></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Polynomial.natDegree_pos_of_eval%E2%82%82_root#doc\">docs#Polynomial.natDegree_pos_of_eval₂_root</a></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Polynomial.degree_pos_of_eval%E2%82%82_root#doc\">docs#Polynomial.degree_pos_of_eval₂_root</a></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Polynomial.natDegree_pos_of_aeval_root#doc\">docs#Polynomial.natDegree_pos_of_aeval_root</a></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Polynomial.degree_pos_of_aeval_root#doc\">docs#Polynomial.degree_pos_of_aeval_root</a></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=seminormFromBounded_is_norm_iff#doc\">docs#seminormFromBounded_is_norm_iff</a></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ENormedSpace#doc\">docs#ENormedSpace</a></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearMap.separatingLeft_iff_linear_nontrivial#doc\">docs#LinearMap.separatingLeft_iff_linear_nontrivial</a></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.measure_lt_one_eq_integral_div_gamma#doc\">docs#MeasureTheory.measure_lt_one_eq_integral_div_gamma</a></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.measure_le_eq_lt#doc\">docs#MeasureTheory.measure_le_eq_lt</a></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsIntegralClosure.isFractionRing_of_algebraic#doc\">docs#IsIntegralClosure.isFractionRing_of_algebraic</a></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=integralClosure.isFractionRing_of_algebraic#doc\">docs#integralClosure.isFractionRing_of_algebraic</a></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Polynomial.gaussNorm_eq_zero_iff#doc\">docs#Polynomial.gaussNorm_eq_zero_iff</a></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PowerSeries.gaussNorm_eq_zero_iff#doc\">docs#PowerSeries.gaussNorm_eq_zero_iff</a></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Polynomial.integralNormalization_eval%E2%82%82_eq_zero_of_commute#doc\">docs#Polynomial.integralNormalization_eval₂_eq_zero_of_commute</a></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Polynomial.integralNormalization_eval%E2%82%82_eq_zero#doc\">docs#Polynomial.integralNormalization_eval₂_eq_zero</a></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Polynomial.integralNormalization_aeval_eq_zero#doc\">docs#Polynomial.integralNormalization_aeval_eq_zero</a></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=algebraicIndependent_iff#doc\">docs#algebraicIndependent_iff</a></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AlgebraicIndependent.eq_zero_of_aeval_eq_zero#doc\">docs#AlgebraicIndependent.eq_zero_of_aeval_eq_zero</a></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=algebraicIndependent_subtype#doc\">docs#algebraicIndependent_subtype</a></li>\n</ul>\n<p>It's hard to find theorems about an unnamed property, which evidently is pretty common, so I suggest creating a name for it and using it in all the above definitions.</p>\n<p>A possible name is <code>HasTrivialKernel</code> or something, although this name also suggests that <code>f 0 = 0</code> which I'm not sure is always true for theorems that use this property.</p>\n<p>When <code>f</code> is a homomorphism between rings this is equivalent to <code>f</code> being injective, but I don't think the same is true for semirings. If we were to define this property, I think we should only require <code>FunLike</code> and <code>Zero</code>.</p>\n<p>Thoughts?</p>",
        "id": 538498035,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1757440636
    },
    {
        "content": "<p>Indeed it's not the same as injectivity for semirings, there's a semiring {0,1,2,...,n} with an \"absorbing n\" i.e. x+y=n if the \"actual\" value of x+y is &gt;=n and similarly for times; the natural map from the naturals to this semiring satisfies your property if n&gt;=1 but it's not injective. This probably just shows that it's not an interesting notion for semirings (unless you're interested in counterexamples)</p>",
        "id": 538499718,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1757441127
    },
    {
        "content": "<p>What about calling it <code>InjectiveAt</code>? So this is <code>InjectiveAt f 0</code>. That could be defined for any function (or <code>FunLike</code>). Then you could prove how e.g. <code>InjectiveAt f 0</code> implies/is equivalent to <code>Function.Injective</code> on appropriate structures, also you allow <code>InjectiveAt f 1</code> as a natural multiplicative analog.</p>",
        "id": 538562584,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1757475742
    },
    {
        "content": "<p>What's the conclusion of <code>InfectiveAt f 1</code>? <code>x = 1</code> or <code>x = 0</code>? I found 5 usages of such a statement in Mathlib, 3 of them with <code>x = 1</code> and 2 with <code>x = 0</code></p>",
        "id": 538572677,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1757484062
    },
    {
        "content": "<p>Oh, I meant that it would be 1. Interesting, I hadn't really thought about there being <code>f x = 1 -&gt; x = 0</code> but I guess it's not unreasonable (some sort of 'exponential' map?)</p>",
        "id": 538646646,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1757509515
    }
]