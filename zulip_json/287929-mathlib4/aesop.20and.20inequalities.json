[
    {
        "content": "<p>I find it pretty unfortunate that <code>aesop</code> can't solve goals like these:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">aesop</span><span class=\"w\"> </span><span class=\"c1\">-- fails</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">aesop</span><span class=\"w\"> </span><span class=\"c1\">-- fails</span>\n</code></pre></div>\n<p>It's possible to sidestep this, though my solution is quite a bit of a hack.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">aesop</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">le_iff_lt_or_eq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">lt_asymm</span><span class=\"o\">])</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">aesop</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">lt_asymm</span><span class=\"o\">])</span>\n</code></pre></div>\n<p>Is there some other (better) way to get <code>aesop</code> to solve goals like these? I know of the <code>order</code> tactic of course, but what I'm describing is often the final state in a much larger goal, which <code>aesop</code> falls short of solving.</p>",
        "id": 563448547,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1765537753
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">aesop</span><span class=\"w\"> </span><span class=\"n\">safe</span><span class=\"w\"> </span><span class=\"n\">forward</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">le_of_lt</span>\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">aesop</span><span class=\"w\"> </span><span class=\"n\">safe</span><span class=\"w\"> </span><span class=\"n\">forward</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">lt_of_le_of_ne</span>\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">aesop</span><span class=\"w\"> </span><span class=\"n\">safe</span><span class=\"w\"> </span><span class=\"n\">forward</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">not_lt_of_ge</span>\n</code></pre></div>\n<p>are tags which would solve this, perhaps they might want to be added?</p>",
        "id": 563451130,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1765538610
    },
    {
        "content": "<p>On that note, what do <code>safe</code> and <code>unsafe</code> mean for applied lemmas?</p>",
        "id": 563451308,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1765538676
    },
    {
        "content": "<p><code>safe</code> = Aesop will never look at the parent goal of the rule again, so you should make sure that a provable goal remains provable after the rule is applied. E.g. <code>apply x &lt;= y /\\ x /= y -&gt; x &lt; y</code> is safe because no information is lost. <code>unsafe</code> = Aesop will try other rules that may apply to the parent goal. E.g. <code>apply x &lt; y -&gt; x &lt;= y</code> is unsafe because you could prove le via eq as well.</p>\n<p>Forward rules are generally safe because they only add stuff to the context and don't destroy information, though it practice it can occasionally make sense to make a forward rule unsafe as well, to deprioritise it.</p>",
        "id": 563452858,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1765539209
    },
    {
        "content": "<p>I've thought about this before, and I'm not sure <code>aesop</code>'s branching search is well-suited to closing these sorts of trivial order goals efficiently. I worry adding those forward rules will just slow every Aesop call with an inequality in the context down.</p>\n<p>Perhaps we could gate the proposed forward order rules behind a ruleset that you can then activate? Or maybe is there a way to get Aesop to call finishing tactics like <code>order</code> to close goals?</p>",
        "id": 563458973,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1765541294
    },
    {
        "content": "<p>Either a ruleset or a discharger seem like really nice solutions.</p>",
        "id": 563460294,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1765541735
    },
    {
        "content": "<p>Adding <code>order</code> and similar tactics is definitely worth a try imo.</p>\n<p>I think Mathlib should also experiment with more aggressive rule sets, e.g. more forward rules. We've tried fairly hard to make forward rules efficient to apply, so I suspect even if Aesop ends up using a lot of them, it shouldn't degrade performance too much. (Currently, <code>simp</code> absolutely dominates Aesop processing time, anything else doesn't really make a difference. ^^) If this approach does run into performance issues, I'd be happy to hear about them.</p>",
        "id": 563460880,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1765541917
    },
    {
        "content": "<p>I believe <code>linarith</code> solves both. Is there a reason to not use <code>linarith</code> instead ?</p>",
        "id": 563464616,
        "sender_full_name": "TongKe Xue",
        "timestamp": 1765543208
    },
    {
        "content": "<blockquote>\n<p>I know of the <code>order</code> tactic of course, but what I'm describing is often the final state in a much larger goal, which <code>aesop</code> falls short of solving.</p>\n</blockquote>",
        "id": 563464682,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1765543234
    },
    {
        "content": "<p>Similar remark applies for <code>linarith</code>, I'm trying to prove much larger goals and I'm getting left with these subgoals which <code>aesop</code> can't finish off</p>",
        "id": 563464749,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1765543259
    },
    {
        "content": "<p>If you're willing to hack on aesop, I think the following is possible.<br>\nWith slight loss of generality, assume we only have <code>\\leq</code> and not <code>\\le</code>.</p>\n<p>All the linear ineqs can be written up as</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"n\">leq</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">v</span>\n</code></pre></div>\n<p>where v is the list of vars, M is matrix, and C is a vec of constants.</p>\n<p>Then we compute the nullspace of M (ensuring cancelling of vars), take a basis of that null space, and see of any of the dot product with C to a value &lt; 0.</p>\n<p>If so, we have a contradiction.</p>\n<p>I've never studied aesop, so no idea how hard to hack this in.</p>",
        "id": 563473853,
        "sender_full_name": "TongKe Xue",
        "timestamp": 1765546059
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/287929-mathlib4/topic/aesop.20and.20inequalities/near/563464682\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>I know of the <code>order</code> tactic of course, but what I'm describing is often the final state in a much larger goal, which <code>aesop</code> falls short of solving.</p>\n</blockquote>\n</blockquote>\n<p>Could you add linarith as a low priority tactical to aesop? Re-implementing a LIA procedure using aesop seems like a good recipe for unpredictability and inefficient proofs.</p>",
        "id": 563487958,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1765550024
    },
    {
        "content": "<p>For example <code>aesop (add safe tactic (by linarith))</code> or if that turns out to be too eager give it a penalty? <code>aesop (add safe 10 tactic (by linarith))</code> or something like that</p>",
        "id": 563489015,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1765550324
    },
    {
        "content": "<p>I think adding <code>order</code> this way is too a good idea<br>\n<code>order</code> closes lots of goals that <code>linarith</code> cannot because <code>linarith</code> needs a ring structure, <code>order</code> isn't a downgrade</p>",
        "id": 563495384,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1765551943
    },
    {
        "content": "<p>Here is a problem I am running into with adding forward rules aggressively to <code>aesop</code>: <code>simp_all</code> erases hypotheses that it can prove from the other hypotheses. This invariant is very unhelpful because typeclass search can't see through implications . Here is a minimal example of the issue:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">my_class</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">aesop</span><span class=\"w\"> </span><span class=\"n\">safe</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">library_lemma</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">my_class</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">test_aesop</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">my_class</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">h0</span>\n<span class=\"w\">  </span><span class=\"n\">aesop</span><span class=\"w\"> </span><span class=\"c1\">-- fails</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">test_manual</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">my_class</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">h0</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">library_lemma</span><span class=\"w\"> </span><span class=\"c1\">-- succeeds</span>\n</code></pre></div>",
        "id": 563726508,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1765765278
    },
    {
        "content": "<p>Changing the normalisation step to <code>simp at [*]</code> works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">test_aesop</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">my_class</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">aesop</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">config</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">useSimpAll</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"n\">safe</span><span class=\"w\"> </span><span class=\"n\">forward</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>but then you don't get the automatic rewriting that <code>simp_all</code> provides. Maybe <code>simp [*] at *</code> is a good compromise?</p>",
        "id": 563727167,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1765766126
    },
    {
        "content": "<p>And by the way the following, which is closer to my real use case, doesn't work at all <span aria-label=\"cry\" class=\"emoji emoji-1f622\" role=\"img\" title=\"cry\">:cry:</span> </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">SetLike</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">my_class</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">aesop</span><span class=\"w\"> </span><span class=\"n\">safe</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"kd\">]</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">library_lemma</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">my_class</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">test_aesop</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">my_class</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n\n<span class=\"w\">  </span><span class=\"n\">aesop</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">config</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">useSimpAll</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"n\">safe</span><span class=\"w\"> </span><span class=\"n\">forward</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- fails, made no progress</span>\n</code></pre></div>",
        "id": 563727299,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1765766319
    },
    {
        "content": "<p>The latter issue is the one you reported, right? So this should be fixed.</p>\n<p><code>simp_all</code> rewriting hyps to <code>True</code> is indeed a problem. Conceptually, I think it would make sense to downgrade Aesop's <code>simp</code> to <code>simp at *</code> and to reimplement a version of the propositional reasoning that <code>simp_all</code> provides in Aesop. This would also be good for performance; <code>simp at *</code> may even be cacheable. But it would also be a fairly major operation.</p>",
        "id": 563882007,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1765819402
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256311\">Jannis Limperg</span> <a href=\"#narrow/channel/287929-mathlib4/topic/aesop.20and.20inequalities/near/563882007\">said</a>:</p>\n<blockquote>\n<p>The latter issue is the one you reported, right? So this should be fixed.</p>\n</blockquote>\n<p>So it is!</p>",
        "id": 563919511,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1765830807
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256311\">Jannis Limperg</span> <a href=\"#narrow/channel/287929-mathlib4/topic/aesop.20and.20inequalities/near/563882007\">said</a>:</p>\n<blockquote>\n<p>Conceptually, I think it would make sense to downgrade Aesop's <code>simp</code> to <code>simp at *</code> and to reimplement a version of the propositional reasoning that <code>simp_all</code> provides in Aesop.</p>\n</blockquote>\n<p>Is this not as simple as adding (dependent) arrow elimination as a safe forward rule? Probably there is something I am missing.</p>",
        "id": 563921668,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1765831623
    },
    {
        "content": "<p><code>simp_all</code> supports much more fancy simplifications, e.g. <code>P /\\ (Q \\/ R)</code> becomes <code>P /\\ R</code> if <code>h : Not Q</code> is in the context. It might be possible to isolate this functionality, though. So we would have a first <code>simp</code> pass that does <code>simp only [&lt;all h : P or h : Not P&gt;]</code>, then a second one that does non-contextual <code>simp at *</code> (cacheable?). This almost certainly gives worse performance because in CategoryTheory specifically, terms are huge and so each <code>simp</code> pass is very expensive. But I generally think sensible behaviour is more important than speed (up to a point).</p>",
        "id": 563941983,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1765840493
    },
    {
        "content": "<p>I wonder if the <code>simp_all only</code> behaviour can be implemented without using <code>simp</code></p>",
        "id": 563942106,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1765840572
    },
    {
        "content": "<p>Yeah, but not sure how much we can optimise beyond what <code>simp</code> already does. Actually, maybe you could do a raw traversal without locally nameless opening/abstraction; that would be very fast.</p>",
        "id": 563942410,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1765840795
    }
]