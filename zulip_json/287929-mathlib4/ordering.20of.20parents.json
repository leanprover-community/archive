[
    {
        "content": "<p>One thing I’ve noticed from looking at regressions with the left to right semantics is the following pattern </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">NonUnitalSeminormedRing</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Norm</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">NonUnitalRing</span> <span class=\"n\">α</span><span class=\"o\">,</span>\n  <span class=\"n\">PseudoMetricSpace</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n  <span class=\"sd\">/-- The distance is induced by the norm. -/</span>\n  <span class=\"n\">dist_eq</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">dist</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">norm</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n  <span class=\"sd\">/-- The norm is submultiplicative. -/</span>\n  <span class=\"n\">norm_mul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">norm</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">norm</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">norm</span> <span class=\"n\">b</span>\n</code></pre></div>\n<p>which itself is ok. But becomes problematic when using existing instances to construct new ones. </p>\n<p>Here many instances come from “Analysis-land” which means they involve <code>Norm</code> and <code>PseudoMetricSpace</code> fields and often involve some algebraic fields (e.g. <code>Add</code>)  </p>\n<p>When one builds the instance as </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">{</span> <span class=\"n\">mainlyAnalysisButSomeAlg</span><span class=\"o\">,</span> <span class=\"n\">purelyAlg</span> <span class=\"k\">with</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>we end up doing some deep eta expansions on <code>NonUnitalRing</code> to use the algebraic fields from the first instance. </p>\n<p>What should be done here? </p>\n<ul>\n<li>Be more disciplined?</li>\n<li>Move the algebra instances to the front? (for the <code>class</code> itself also?) </li>\n<li>Something else?</li>\n</ul>",
        "id": 419920463,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1707164057
    },
    {
        "content": "<p>Probably the depth of the nesting for a class should play a large factor in the ordering of parent classes (unless it is all data)</p>",
        "id": 419920681,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1707164153
    },
    {
        "content": "<p>Has anyone written a tool for listing the classes in mathlib by depth of extension?</p>",
        "id": 419921071,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1707164300
    },
    {
        "content": "<p><a href=\"http://speed.lean-fro.org/mathlib4/compare/917c35cd-a528-43f1-a89c-cd8bd7242c56/to/0a70caf9-1e49-4e33-a913-23e1ebbc505c\">Here</a> is some positive evidence for this ordering - from <a href=\"https://github.com/leanprover-community/mathlib4/pull/10287\">#10287</a></p>",
        "id": 419951058,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1707178111
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306577\">Matthew Ballard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/ordering.20of.20parents/near/419920463\">said</a>:</p>\n<blockquote>\n<ul>\n<li>Something else?</li>\n</ul>\n</blockquote>\n<p>One thing I've been keen on, but has met with some resistance in the past, is to separate the data fields in the algebraic hierarchy from those in the analysis hierarchy (almost) entirely, and then have mixins for the interactions between the two.</p>\n<p>I think <span class=\"user-mention\" data-user-id=\"110050\">@Sébastien Gouëzel</span>'s usual rejoinder is something like (please forgive me if I get it wrong): but <code>(Nontrivially)NormedField</code>s are soooo common that it's better if we have an explicit class for these. In that case, I agree, and we can have a <em>few</em> overlaps (primarily just <code>NormedField</code> and variations thereof). But I think having all the duplication of <code>{NonUnital}{Semi}Normed{Comm}Ring</code> is overkill (especially because at some point I'm sure we'll want <code>NonAssoc</code> variants), and it certainly makes it harder to change assumptions.</p>\n<p>This would have the benefit that you should in general be able to build these instances as:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">{</span> <span class=\"n\">purelyAnalysisData</span><span class=\"o\">,</span> <span class=\"n\">purelyAlgData</span><span class=\"o\">,</span> <span class=\"n\">interactionProps</span> <span class=\"k\">with</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 419964659,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1707187186
    },
    {
        "content": "<p>A more general approach would be to separate the data fields from the prop fields. Within a hierarchy, the data fields basically never change (eg in the algebraic hierarchy we get at most <code>zero</code>, <code>one</code>, <code>add</code>,  <code>sub</code>, <code>neg</code>,  <code>mul</code>, <code>div</code>, <code>inv</code>, <code>nsmul</code>, <code>zsmul</code>,  <code>qsmul</code>, <code>natCast</code>, <code>intCast</code>, <code>ratCast</code>) while the prop fields accumulate in complicated ways.</p>",
        "id": 419998521,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1707208797
    },
    {
        "content": "<p>I'm claiming it's more general because if you apply this principle to analytic algebraic objects, you get something like <code>(purelyAnalyticData, purelyAlgebraicData), (purelyAnalyticProps, purelyAlgebraicProps, interactionProps)</code> and I think the resulting classes will be small enough that inference will be fast. If they are not, we can split them up into <code>purelyAnalyticData, purelyAlgebraicData, (purelyAnalyticProps, purelyAlgebraicProps, interactionProps)</code> or even <code>purelyAnalyticData, purelyAlgebraicData, purelyAnalyticProps, purelyAlgebraicProps, interactionProps</code> (this last case is like an \"unbundled mixin\" and has the advantage of not forcing us to write tons and tons of classes about all possible interactions).</p>",
        "id": 419999117,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1707209031
    },
    {
        "content": "<p>The problem with this approach of course is that <code>variable</code> declarations become longer. But since any given <code>purelyAlgebraicProps</code> class requires exactly one specific <code>purelyAlgebraicData</code> (by which I mean it's defined as <code>class purelyAlgebraicProps (α) [purelyAlgebraicData α] ...</code>), the <code>variable</code> declaration could automagically figure out the supremum of all <code>purelyAlgebraicData</code> assumptions needed by the <code>purelyAlgebraicProps</code> present within it, and add that supremum as an assumption.</p>",
        "id": 419999550,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1707209210
    },
    {
        "content": "<p>Probably for simplicity we'll need to tag <code>purelyAlgebraicProps</code> classes with the <code>purelyAlgebraicData</code> class they need.</p>",
        "id": 419999647,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1707209244
    },
    {
        "content": "<p>We might be able to make more use of <code>variable!</code> to hide the issues, if this ends up spiraling out of control</p>",
        "id": 420032654,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1707221161
    },
    {
        "content": "<p>Or notation for a collection of variables, i.e., <code>instanceNotation Foo A := {Bar A, Baz A}</code> and that <code>variable [Foo A]</code> is internally unfolded to <code>variable [Bar A] [Baz A]</code> (but printed as <code>[Foo A]</code> in the info view). That would also make something like <code>[IsROrC k] [HilbertSpace k E]</code> possible.</p>",
        "id": 420165763,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1707269948
    },
    {
        "content": "<p><code>variable!</code> supports something like that, but it eliminates itself: <a href=\"https://github.com/leanprover-community/mathlib4/blob/49212605e40e9d9fcbcd9968ce362f91dad303ca/test/Variable.lean#L149-L160\">https://github.com/leanprover-community/mathlib4/blob/49212605e40e9d9fcbcd9968ce362f91dad303ca/test/Variable.lean#L149-L160</a></p>\n<p>Core has something called <code>class abbrev</code> that's sort of like what you're saying, and it's implemented as a class that can synthesize instances itself from instances for everything it extends.</p>",
        "id": 420166324,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1707270367
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/7873\">#7873</a> seems to follow the “Deeper structure first” philosophy and does clearly improve performance</p>",
        "id": 420322721,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1707332618
    },
    {
        "content": "<p>Is there any way to do a <em>small-ish</em> test to see whether separating the data and prop fields as mentioned above would help or hinder performance? It would likely be a ton of work to do it across the whole library, but I'm not sure what a reliable proxy would be.</p>",
        "id": 420337069,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1707337791
    },
    {
        "content": "<p>We probably want a slim mathlib repo for testing things like this</p>",
        "id": 420337314,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1707337869
    },
    {
        "content": "<p>In the draft <a href=\"https://github.com/leanprover/lean4/pull/5770\">lean4#5770</a>, incidentally there's a feature behind a flag for making sure all parents are in a (locally) consistent ordering. It's computing the C3 linearization (as seen in languages like Python with it's MRO — method resolution order). If you're not familiar, if you imagine the set of all structures/classes as forming a poset with the has-parent relation, then it is trying to find a total order of the transitive closure of the parents of a given structure/class with the property that each list of direct parents are in order. The algorithm is a little more restrictive than that, but that's the idea.</p>\n<p>This feature was motivated by getting dot notation to work reliably for structures with diamond inheritance, but if it helps mathlib get its parent classes in order, all the better.</p>\n<p>In <a href=\"https://arxiv.org/pdf/2401.12740\">https://arxiv.org/pdf/2401.12740</a>, Hivert and Thiéry note that for SageMath, maintaining parent orders that C3 can linearize is unscalable when you have thousands of classes. They have some tips though to make it work nonetheless. For example, we could support adding global constraints for some key classes (Add always comes after Mul, Module always comes after Ring, things like that) that would help. They also describe some tools for an algorithm to add in \"non-direct parents\" to guide C3 to a solution. We could also make our C3 suggest putting Prop parents after non-Prop parents.</p>",
        "id": 477828192,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729362369
    }
]