[
    {
        "content": "<p>How do I recurse over Fin (n + 1)? I'm trying to define the composition of m morphisms in the simplex category.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">multi_comp</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Arrow</span> <span class=\"n\">SimplexCategory</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">right</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">left</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">comp</span> <span class=\"n\">n</span>\n<span class=\"n\">where</span>\n  <span class=\"n\">comp</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Arrow</span> <span class=\"n\">SimplexCategory</span>\n    <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"mi\">0</span>\n    <span class=\"bp\">|</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">succ</span> <span class=\"bp\">≫</span> <span class=\"n\">comp</span> <span class=\"n\">i</span>\n</code></pre></div>\n<p>This gives me an error </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">invalid</span> <span class=\"n\">patterns</span><span class=\"o\">,</span> <span class=\"bp\">`</span><span class=\"n\">i</span><span class=\"bp\">`</span> <span class=\"n\">is</span> <span class=\"n\">an</span> <span class=\"n\">explicit</span> <span class=\"n\">pattern</span> <span class=\"kd\">variable</span><span class=\"o\">,</span> <span class=\"n\">but</span> <span class=\"n\">it</span> <span class=\"n\">only</span> <span class=\"n\">occurs</span> <span class=\"k\">in</span> <span class=\"n\">positions</span> <span class=\"n\">that</span> <span class=\"n\">are</span> <span class=\"n\">inaccessible</span> <span class=\"n\">to</span> <span class=\"n\">pattern</span> <span class=\"n\">matching</span>\n  <span class=\"o\">{</span>\n    <span class=\"n\">val</span> <span class=\"o\">:=</span>\n      <span class=\"bp\">.</span><span class=\"o\">(</span><span class=\"k\">match</span> <span class=\"bp\">↑</span><span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">%</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"k\">with</span>\n        <span class=\"bp\">|</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n        <span class=\"bp\">|</span> <span class=\"n\">x</span><span class=\"bp\">@</span><span class=\"n\">h</span><span class=\"o\">:(</span><span class=\"n\">Nat.succ</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Nat.modCore</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">),</span>\n    <span class=\"n\">isLt</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">%</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"bp\">%</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 391881696,
        "sender_full_name": "Herman Rohrbach",
        "timestamp": 1695119434
    },
    {
        "content": "<p>Welcome <span class=\"user-mention\" data-user-id=\"646581\">@Herman Rohrbach</span>!</p>\n<p>This definition is a bit tricky to write down, because you need to convince the kernel of the equality of source/domain of some objects at the right moment. You have the assumption <code>hf</code>, but you'll have to inject it into the actual term at some point.</p>",
        "id": 391891123,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1695122808
    },
    {
        "content": "<p>Using a <code>Fin (n + 1)</code>-indexed collection of arrows might not be the optimal way of formalizing this concept.</p>",
        "id": 391891206,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1695122842
    },
    {
        "content": "<p>Mathlib has a bunch of stuff on paths and walks in graph theory. You might be able to use some of those techniques here as well.</p>",
        "id": 391891506,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1695122952
    },
    {
        "content": "<p>Thank you for the welcome <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> !</p>\n<p>I'm glad to know I'm not the only one who thinks this is a little tricky. I'll take a look at some of the graph theory in mathlib to see if I can find a better way of doing this.</p>",
        "id": 391896908,
        "sender_full_name": "Herman Rohrbach",
        "timestamp": 1695124860
    },
    {
        "content": "<p>I would see two ways to do this (in any category <code>C</code>):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.AlgebraicTopology.SimplexCategory</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">v</span> <span class=\"n\">u</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">CategoryTheory</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Category.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- this is a little bit cheating, assuming the `n` composable arrows already</span>\n<span class=\"c1\">-- form a functor `Fin (n + 1) ⥤ C`, see also `AlgebraicTopology.Nerve`</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">ComposableArrows</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">⥤</span> <span class=\"n\">C</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"n\">n</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">composableArrows.composition</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">ComposableArrows</span> <span class=\"n\">C</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">F.obj</span> <span class=\"mi\">0</span> <span class=\"bp\">⟶</span> <span class=\"n\">F.obj</span> <span class=\"o\">(</span><span class=\"n\">Fin.last</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">F.map</span> <span class=\"o\">(</span><span class=\"n\">homOfLE</span> <span class=\"o\">(</span><span class=\"n\">Fin.zero_le</span> <span class=\"n\">_</span><span class=\"o\">))</span>\n\n<span class=\"c1\">-- alternative approach using inductive types (similar to `Combinatorics.Quiver.Path`)</span>\n\n<span class=\"sd\">/-- `ComposableArrowsFromTo n X Y` is the type of `n` composable arrows from `X` to `Y`. -/</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">ComposableArrowsFromTo</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ComposableArrowsFromTo</span> <span class=\"mi\">0</span> <span class=\"n\">X</span> <span class=\"n\">X</span>\n  <span class=\"bp\">|</span> <span class=\"n\">comp</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">ComposableArrowsFromTo</span> <span class=\"n\">n</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">⟶</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n      <span class=\"n\">ComposableArrowsFromTo</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">X</span> <span class=\"n\">Z</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ComposableArrowsFromTo.composition</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">ComposableArrowsFromTo</span> <span class=\"n\">n</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">id</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">𝟙</span> <span class=\"n\">_</span>\n  <span class=\"bp\">|</span> <span class=\"n\">comp</span> <span class=\"n\">α</span> <span class=\"n\">f</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">α.composition</span> <span class=\"bp\">≫</span> <span class=\"n\">f</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">C</span><span class=\"o\">)</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">ComposableArrows'</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">source</span> <span class=\"o\">:</span> <span class=\"n\">C</span>\n  <span class=\"n\">target</span> <span class=\"o\">:</span> <span class=\"n\">C</span>\n  <span class=\"n\">arrows</span> <span class=\"o\">:</span> <span class=\"n\">ComposableArrowsFromTo</span> <span class=\"n\">n</span> <span class=\"n\">source</span> <span class=\"n\">target</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">C</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ComposableArrows'.composition</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">ComposableArrows'</span> <span class=\"n\">C</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α.source</span> <span class=\"bp\">⟶</span> <span class=\"n\">α.target</span> <span class=\"o\">:=</span>\n  <span class=\"n\">α.arrows.composition</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">CategoryTheory</span>\n</code></pre></div>\n<p>I think it would be interesting to define equivalences between these two types <code>ComposableArrows C n</code> and <code>ComposableArrows' C n</code>, the more interesting part being promoting <code>n</code> composable arrows into a functor from <code>Fin (n+1)</code>.</p>\n<p>When I implemented Verdier's construction of spectral sequences, I had to consider categories of <code>n</code> composable arrows for <code>n = 1, 2, 3, 4, 5, 6, 7</code>. It would be great if I had a nice constructor for this rather than my very crude current definition:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Arrow₇</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span><span class=\"n\">X₀</span> <span class=\"n\">X₁</span> <span class=\"n\">X₂</span> <span class=\"n\">X₃</span> <span class=\"n\">X₄</span> <span class=\"n\">X₅</span> <span class=\"n\">X₆</span> <span class=\"n\">X₇</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span>\n  <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X₀</span> <span class=\"bp\">⟶</span> <span class=\"n\">X₁</span>\n  <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">X₁</span> <span class=\"bp\">⟶</span> <span class=\"n\">X₂</span>\n  <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">X₂</span> <span class=\"bp\">⟶</span> <span class=\"n\">X₃</span>\n  <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">X₃</span> <span class=\"bp\">⟶</span> <span class=\"n\">X₄</span>\n  <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">X₄</span> <span class=\"bp\">⟶</span> <span class=\"n\">X₅</span>\n  <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">X₅</span> <span class=\"bp\">⟶</span> <span class=\"n\">X₆</span>\n  <span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">X₆</span> <span class=\"bp\">⟶</span> <span class=\"n\">X₇</span>\n</code></pre></div>",
        "id": 391994360,
        "sender_full_name": "Joël Riou",
        "timestamp": 1695157319
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span>  Thank you for your extensive thoughts on the matter, I like your suggestions! The first one is nice because it makes it easy to check e.g. if every morphism has a certain <code>MorphismProperty</code>, but the second one might be easier to construct. </p>\n<p>I noticed that in <code>SimplexCategory</code>, almost everything has been implemented except the fact that it is generated by face and degeneracy maps, so I thought I'd give that a go as a little project to get to know category theory and algebraic topology in mathlib a little bit.</p>",
        "id": 392264708,
        "sender_full_name": "Herman Rohrbach",
        "timestamp": 1695281862
    },
    {
        "content": "<p>Yeah, that project would be really good. It's been on my radar for &gt; 4 years, but I never got around to actually doing it.</p>",
        "id": 392266174,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1695282435
    },
    {
        "content": "<p>I think it could be phrased as some sort of induction principle.</p>",
        "id": 392266197,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1695282451
    },
    {
        "content": "<p>It's not just that it's generated by these maps, we also know the precise relations, right?</p>",
        "id": 392268055,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1695283257
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> That was my feeling as well. There are already lemmas telling us we can split off face and degeneracy maps as long as the input map is not injective or surjective, and we should use those until we're 'left' with a bijection which is the identity by another lemma. </p>\n<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Yes, and these have already been proved in mathlib, so it's just this final step that is missing.</p>",
        "id": 392269354,
        "sender_full_name": "Herman Rohrbach",
        "timestamp": 1695283694
    },
    {
        "content": "<p>Do we have the statement that the known easy relations generate all the relations in a precise sense? i.e. \"there are no more relations\"?</p>",
        "id": 392270030,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1695283928
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> I think we do, in the sense that any category whose objects are the usual finite ordinals [n] and whose morphisms are generated by the face and degeneracy maps subject to the simplicial relations must be the simplex category, see e.g. MacLane's Categories for the working mathematician, Section VII.5.</p>",
        "id": 392273696,
        "sender_full_name": "Herman Rohrbach",
        "timestamp": 1695285169
    },
    {
        "content": "<p>Yes, sorry for the misunderstanding -- I know it's a theorem, I'm asking if we have it in mathlib!</p>",
        "id": 392275777,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1695285873
    },
    {
        "content": "<p>The theorem is not in mathlib. We have notions of path category of a quiver (\"free category\" generated by some arrows), and also that of quotient category by a congruence generated by some relations among morphisms, so that it is certainly possible to state the presentation theorem for <code>SimplexCategory</code>.</p>\n<p>About <code>ComposableArrows</code> in general, I was able to get reasonably good constructors for functors <code>Fin (n + 1) ⥤ C</code>, see <a href=\"https://github.com/leanprover-community/mathlib4/blob/jriou_localization/Mathlib/CategoryTheory/ComposableArrows.lean\">https://github.com/leanprover-community/mathlib4/blob/jriou_localization/Mathlib/CategoryTheory/ComposableArrows.lean</a> and especially <a href=\"https://github.com/leanprover-community/mathlib4/blob/1d6d79c4498537deabead84846eb4eba11456ba4/Mathlib/CategoryTheory/ComposableArrows.lean#L272\">https://github.com/leanprover-community/mathlib4/blob/1d6d79c4498537deabead84846eb4eba11456ba4/Mathlib/CategoryTheory/ComposableArrows.lean#L272</a></p>",
        "id": 392288808,
        "sender_full_name": "Joël Riou",
        "timestamp": 1695290481
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/287929-mathlib4/topic/n.20composable.20morphisms/near/392266197\">said</a>:</p>\n<blockquote>\n<p>I think it could be phrased as some sort of induction principle.</p>\n</blockquote>\n<p>This sounds similar to how we handled naturality in the snake lemma in LTE.</p>",
        "id": 392312542,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1695299679
    },
    {
        "content": "<p>Using <span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span> 's idea for an inductive type, I have now managed to show that monomorphisms in <code>SimplexCategory</code> admit a decomposition into face maps.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.AlgebraicTopology.SimplicialSet</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.CategoryTheory.MorphismProperty</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.CategoryTheory.CommSq</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Image</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">CategoryTheory</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">v</span> <span class=\"n\">u</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">CategoryTheory</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Category.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">ComposableWithProperty</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">MorphismProperty</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">ComposableWithProperty</span> <span class=\"n\">P</span> <span class=\"n\">X</span> <span class=\"n\">X</span>\n  <span class=\"bp\">|</span> <span class=\"n\">append</span> <span class=\"o\">{</span><span class=\"n\">Y</span> <span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">ComposableWithProperty</span> <span class=\"n\">P</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">⟶</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ComposableWithProperty</span> <span class=\"n\">P</span> <span class=\"n\">X</span> <span class=\"n\">Z</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">ComposableWithProperty</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">MorphismProperty</span> <span class=\"n\">C</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">toComposable</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ComposableWithProperty</span> <span class=\"n\">P</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span>\n  <span class=\"n\">nil.append</span> <span class=\"n\">f</span> <span class=\"n\">hf</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">total_comp</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">ComposableWithProperty</span> <span class=\"n\">P</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">𝟙</span> <span class=\"n\">_</span>\n  <span class=\"bp\">|</span> <span class=\"n\">append</span> <span class=\"n\">α</span> <span class=\"n\">f</span> <span class=\"n\">hf</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">α.total_comp</span> <span class=\"bp\">≫</span> <span class=\"n\">f</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">length</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">ComposableWithProperty</span> <span class=\"n\">P</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">append</span> <span class=\"n\">α</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">α.length</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">total_comp_append</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">ComposableWithProperty</span> <span class=\"n\">P</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">⟶</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n    <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">α.append</span> <span class=\"n\">f</span> <span class=\"n\">hf</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">total_comp</span> <span class=\"bp\">=</span> <span class=\"n\">α.total_comp</span> <span class=\"bp\">≫</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">total_comp</span><span class=\"o\">]</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">ComposableWithProperty</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">SimplexCategory</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Simplicial</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">gt_not_inj</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">mk</span> <span class=\"n\">m</span> <span class=\"bp\">⟶</span> <span class=\"n\">mk</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n    <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">&gt;</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"bp\">¬</span><span class=\"n\">Function.Injective</span> <span class=\"n\">f.toOrderHom</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">contrapose</span>\n  <span class=\"n\">simp</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span>\n  <span class=\"k\">have</span> <span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">Mono</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">mono_iff_injective</span><span class=\"o\">]</span>\n  <span class=\"n\">exact</span> <span class=\"n\">len_le_of_mono</span> <span class=\"n\">hf</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">lt_not_surj</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">mk</span> <span class=\"n\">m</span> <span class=\"bp\">⟶</span> <span class=\"n\">mk</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n    <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"bp\">¬</span><span class=\"n\">Function.Surjective</span> <span class=\"n\">f.toOrderHom</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">contrapose</span>\n  <span class=\"n\">simp</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span>\n  <span class=\"k\">have</span> <span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">Epi</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">epi_iff_surjective</span><span class=\"o\">]</span>\n  <span class=\"n\">exact</span> <span class=\"n\">len_le_of_epi</span> <span class=\"n\">hf</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">DegeneracyMap</span> <span class=\"o\">:</span> <span class=\"n\">MorphismProperty</span> <span class=\"n\">SimplexCategory</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">f</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)),</span> <span class=\"n\">Arrow.mk</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">Arrow.mk</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">FaceMap</span> <span class=\"o\">:</span> <span class=\"n\">MorphismProperty</span> <span class=\"n\">SimplexCategory</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">f</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)),</span> <span class=\"n\">Arrow.mk</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">Arrow.mk</span> <span class=\"o\">(</span><span class=\"n\">δ</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">face_decomp</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">mk</span> <span class=\"n\">n</span> <span class=\"bp\">⟶</span> <span class=\"n\">mk</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">m</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">Mono</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n    <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">ComposableWithProperty</span> <span class=\"n\">FaceMap</span> <span class=\"o\">(</span><span class=\"n\">mk</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mk</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">m</span><span class=\"o\">))),</span>\n    <span class=\"n\">α.total_comp</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">m</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">have</span> <span class=\"n\">hid</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"mi\">𝟙</span> <span class=\"o\">(</span><span class=\"n\">mk</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">apply</span> <span class=\"n\">eq_id_of_mono</span> <span class=\"n\">f</span>\n    <span class=\"n\">use</span> <span class=\"n\">ComposableWithProperty.nil</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">ComposableWithProperty.total_comp</span><span class=\"o\">,</span> <span class=\"n\">hid</span><span class=\"o\">]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"n\">m</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">have</span> <span class=\"n\">hm</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">Nat.succ</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n    <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">lt_not_surj</span> <span class=\"n\">f</span> <span class=\"n\">hm</span>\n    <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">eq_comp_δ_of_not_surjective</span> <span class=\"n\">f</span> <span class=\"n\">h</span>\n    <span class=\"n\">choose</span> <span class=\"n\">i</span> <span class=\"n\">g</span> <span class=\"n\">hg</span> <span class=\"n\">using</span> <span class=\"n\">h</span>\n    <span class=\"k\">have</span> <span class=\"n\">hg₂</span> <span class=\"o\">:</span> <span class=\"n\">Mono</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"k\">have</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Mono</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"bp\">≫</span> <span class=\"o\">(</span><span class=\"n\">δ</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">hg</span><span class=\"o\">]</span>\n        <span class=\"n\">exact</span> <span class=\"n\">hf</span>\n      <span class=\"n\">exact</span> <span class=\"n\">mono_of_mono</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">δ</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n    <span class=\"n\">specialize</span> <span class=\"n\">ih</span> <span class=\"n\">g</span> <span class=\"n\">hg₂</span>\n    <span class=\"n\">choose</span> <span class=\"n\">α</span> <span class=\"n\">hα</span> <span class=\"n\">using</span> <span class=\"n\">ih</span>\n    <span class=\"k\">have</span> <span class=\"n\">hδ</span> <span class=\"o\">:</span> <span class=\"n\">FaceMap</span> <span class=\"o\">(</span><span class=\"n\">δ</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">constructor</span>\n      <span class=\"n\">use</span> <span class=\"n\">i</span>\n    <span class=\"n\">use</span> <span class=\"n\">α.append</span> <span class=\"o\">(</span><span class=\"n\">δ</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">hδ</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">ComposableWithProperty.total_comp_append</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">δ</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">hδ</span><span class=\"o\">,</span> <span class=\"n\">hα</span><span class=\"o\">]</span>\n    <span class=\"n\">exact</span> <span class=\"n\">hg.symm</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">SimplexCategory</span>\n</code></pre></div>\n<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span>  Is this the kind of inductive proof you had in mind? Obviously it shouldn't be too hard to prove something similar for epimorphisms and degeneracy maps, using a <code>RevComposableWithProperty</code> where the arrows are appended on the left instead of on the right of the diagram.</p>",
        "id": 395263536,
        "sender_full_name": "Herman Rohrbach",
        "timestamp": 1696599936
    },
    {
        "content": "<p>Nice work!</p>",
        "id": 395273482,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1696603013
    },
    {
        "content": "<p>The induction principle that I had in mind was more of the form: If you want to construct/prove something for all maps in the simplex category, then you only need to do it for face/degeneracy maps and show that it behaves well with respect to some compositions.</p>",
        "id": 395273705,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1696603083
    },
    {
        "content": "<p>That makes sense, it would be great to be able to construct simplicial objects by defining n-simplices, face and degeneracy maps and proving the simplicial identities (which I guess would be a consequence of the kind of thing you propose). I think the statement I formalized could be a step in that direction, I'll think about it some more.</p>",
        "id": 395275058,
        "sender_full_name": "Herman Rohrbach",
        "timestamp": 1696603523
    },
    {
        "content": "<p>Yes, and yes, and yes please (-;</p>",
        "id": 395276239,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1696603916
    },
    {
        "content": "<p>I wonder whether all sufficiently concrete categories in mathlib (<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"normal\">Δ</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">\\Delta^{op}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord\">Δ</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span></span></span></span> in this case) should come equipped with an \"induction principle\" for constructing functors out of them? Also, what about an induction principle for constructing natural transformations (i.e. morphisms between simplicial objects in the simplicial case)?</p>",
        "id": 395291638,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1696608738
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">abbrev</span> <span class=\"n\">ComposableArrows</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">⥤</span> <span class=\"n\">C</span>\n</code></pre></div>\n<p>This is a powerful idea. I'm working on Van Kampen and need to define a functor out of the fundamental groupoid by partitioning a path into small paths contained in some open set in an open cover, defining the functor on these small paths, and then composing the resulting morphisms, which is quite complicated if you think about it. Then I revisited this thread and immediately realized what I should really do is to show that any path on X induces a functor <code>I ⥤ FundamentalGroupoid X</code>, where I is the unit interval. You can extend this to two dimensions and show a homotopy induces a functor out of <code>I × I</code> (with the product order), and given a monotone sequence from <code>Fin (n+1)</code> to <code>I</code> you can compose with the induced functor and then use <code>composableArrows.composition</code>. To show the definition is independent of the partition you choose, normally you'd take a common refinement, which would be a mess to formalize; with this approach you can fix a finite partition and patch together functors defined on these subintervals to get a functor defined on all of <code>I</code>, and show independence inductively on larger and larger intervals, which will make the proof a lot simpler.</p>",
        "id": 399407412,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1698717358
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> FYI <a href=\"https://github.com/leanprover-community/mathlib4/pull/7999\">#7999</a> is a PR by Joel that contains the defn of <code>ComposableArrows</code>.</p>",
        "id": 399422726,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1698724677
    },
    {
        "content": "<p>Thanks! I'm not seeing the PR being particularly useful to me, but the inspiration is real.</p>",
        "id": 399426427,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1698726612
    }
]