[
    {
        "content": "<p>In the following example, why isn't <code>simp</code> using <code>map_one</code>?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.FunLike.Basic</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"n\">P</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">MulOneClass</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MulOneClass</span> <span class=\"n\">N</span><span class=\"o\">]</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">OneHom</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">One</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">One</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"n\">where</span>\n  <span class=\"n\">toFun</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"n\">N</span>\n  <span class=\"n\">map_one'</span> <span class=\"o\">:</span> <span class=\"n\">toFun</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">OneHomClass</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"bp\">&lt;|</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">outParam</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">One</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">outParam</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">One</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"kd\">extends</span> <span class=\"n\">FunLike</span> <span class=\"n\">F</span> <span class=\"n\">M</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">N</span> <span class=\"n\">where</span>\n  <span class=\"n\">map_one</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">OneHom.oneHomClass</span> <span class=\"o\">:</span> <span class=\"n\">OneHomClass</span> <span class=\"o\">(</span><span class=\"n\">OneHom</span> <span class=\"n\">M</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"n\">where</span>\n  <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"n\">OneHom.toFun</span>\n  <span class=\"n\">coe_injective'</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">f</span><span class=\"bp\">;</span> <span class=\"n\">cases</span> <span class=\"n\">g</span><span class=\"bp\">;</span> <span class=\"n\">congr</span>\n  <span class=\"n\">map_one</span> <span class=\"o\">:=</span> <span class=\"n\">OneHom.map_one'</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">map_one</span> <span class=\"o\">[</span><span class=\"n\">OneHomClass</span> <span class=\"n\">F</span> <span class=\"n\">M</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n  <span class=\"n\">OneHomClass.map_one</span> <span class=\"n\">f</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">MulHom</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Mul</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Mul</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"n\">where</span>\n  <span class=\"n\">toFun</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"n\">N</span>\n  <span class=\"n\">map_mul'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">toFun</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">toFun</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">toFun</span> <span class=\"n\">y</span>\n\n<span class=\"kd\">infixr</span><span class=\"o\">:</span><span class=\"mi\">25</span> <span class=\"s2\">\" →ₙ* \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">MulHom</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">MulHomClass</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"bp\">&lt;|</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">outParam</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Mul</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">outParam</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Mul</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"kd\">extends</span> <span class=\"n\">FunLike</span> <span class=\"n\">F</span> <span class=\"n\">M</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">N</span> <span class=\"n\">where</span>\n  <span class=\"n\">map_mul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">f</span> <span class=\"n\">y</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">map_mul</span> <span class=\"o\">[</span><span class=\"n\">MulHomClass</span> <span class=\"n\">F</span> <span class=\"n\">M</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">f</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n  <span class=\"n\">MulHomClass.map_mul</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">MonoidHom</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">MulOneClass</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MulOneClass</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"kd\">extends</span>\n  <span class=\"n\">OneHom</span> <span class=\"n\">M</span> <span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">M</span> <span class=\"bp\">→ₙ*</span> <span class=\"n\">N</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">MonoidHomClass</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"bp\">&lt;|</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">outParam</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">MulOneClass</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">outParam</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">MulOneClass</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"kd\">extends</span>\n  <span class=\"n\">MulHomClass</span> <span class=\"n\">F</span> <span class=\"n\">M</span> <span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">OneHomClass</span> <span class=\"n\">F</span> <span class=\"n\">M</span> <span class=\"n\">N</span>\n\n<span class=\"kd\">infixr</span><span class=\"o\">:</span><span class=\"mi\">25</span> <span class=\"s2\">\" →* \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">MonoidHom</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">MonoidHom.monoidHomClass</span> <span class=\"o\">:</span> <span class=\"n\">MonoidHomClass</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"bp\">→*</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"n\">where</span>\n  <span class=\"n\">coe</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">f.toFun</span>\n  <span class=\"n\">coe_injective'</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">cases</span> <span class=\"n\">f</span>\n    <span class=\"n\">cases</span> <span class=\"n\">g</span>\n    <span class=\"n\">congr</span>\n    <span class=\"n\">apply</span> <span class=\"n\">OneHom.oneHomClass.coe_injective'</span>\n    <span class=\"n\">exact</span> <span class=\"n\">h</span>\n  <span class=\"n\">map_mul</span> <span class=\"o\">:=</span> <span class=\"n\">MonoidHom.map_mul'</span>\n  <span class=\"n\">map_one</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">f.toOneHom.map_one'</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">MonoidHom.comp</span> <span class=\"o\">[</span><span class=\"n\">MulOneClass</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MulOneClass</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MulOneClass</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">hnp</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">→*</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hmn</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→*</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→*</span> <span class=\"n\">P</span> <span class=\"n\">where</span>\n  <span class=\"n\">toFun</span> <span class=\"o\">:=</span> <span class=\"n\">hnp</span> <span class=\"bp\">∘</span> <span class=\"n\">hmn</span>\n  <span class=\"n\">map_one'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"n\">FunLike.coe_eq_coe_fn</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">map_one</span><span class=\"o\">,</span> <span class=\"n\">map_one</span><span class=\"o\">]</span> <span class=\"c1\">-- map_one can be applied manually</span>\n<span class=\"c1\">-- fails to complete goal: by simp [-FunLike.coe_eq_coe_fn]</span>\n  <span class=\"n\">map_mul'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"n\">FunLike.coe_eq_coe_fn</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 311227341,
        "sender_full_name": "Winston Yin",
        "timestamp": 1669015266
    },
    {
        "content": "<p>I wonder if this is the same issue as I'm having with EmbeddingLike, see <a href=\"#narrow/stream/287929-mathlib4/topic/EmbeddingLike\">https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/EmbeddingLike</a></p>",
        "id": 311262287,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1669029777
    },
    {
        "content": "<p>I think this is likely a serious problem</p>",
        "id": 311262323,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1669029793
    },
    {
        "content": "<p>Is this related to the head symbol simp optimization thingy?</p>",
        "id": 311263592,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1669030293
    },
    {
        "content": "<p><del>I can't replicate</del> misread the issue</p>",
        "id": 311264422,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669030604
    },
    {
        "content": "<p>I wonder if this is the same as <a href=\"https://github.com/leanprover/lean4/issues/1869\">https://github.com/leanprover/lean4/issues/1869</a>.</p>",
        "id": 311894968,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1669231695
    },
    {
        "content": "<p>Hmm that issue seems to be about <code>simp</code> attribute applied to <code>Prop</code> fields of structures. In my case, <code>map_one</code> is defined as a standalone <code>simp</code> theorem.</p>",
        "id": 311932536,
        "sender_full_name": "Winston Yin",
        "timestamp": 1669256401
    },
    {
        "content": "<p>Is this the same issue?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Order.Hom.Basic</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">ex</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">PartialOrder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">OrderHom.id.comp</span> <span class=\"n\">OrderHom.id</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">OrderHom.comp_coe</span><span class=\"o\">]</span> <span class=\"c1\">-- no change</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">OrderHom.comp_coe</span><span class=\"o\">]</span>  <span class=\"c1\">-- no change</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">OrderHom.comp_coe</span><span class=\"o\">]</span>         <span class=\"c1\">-- better!</span>\n  <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 317419180,
        "sender_full_name": "Reid Barton",
        "timestamp": 1671731017
    },
    {
        "content": "<p>MWE</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">THom</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n  <span class=\"n\">toFun</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">THom.comp</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">THom</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">THom</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">THom</span> <span class=\"n\">a</span> <span class=\"n\">c</span> <span class=\"o\">:=</span>\n<span class=\"k\">fun</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">g.1</span> <span class=\"bp\">∘</span> <span class=\"n\">f.1</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">theorem</span> <span class=\"n\">THom.comp_toFun</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">THom</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">THom</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n  <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">f.comp</span> <span class=\"n\">g</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toFun</span> <span class=\"bp\">=</span> <span class=\"n\">g.toFun</span> <span class=\"bp\">∘</span> <span class=\"n\">f.toFun</span> <span class=\"o\">:=</span>\n<span class=\"n\">rfl</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">THom.id</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">THom</span> <span class=\"n\">a</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">@</span><span class=\"n\">_root_.id</span> <span class=\"n\">a</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">ex2</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">THom.id.comp</span> <span class=\"n\">THom.id</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toFun</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">THom.comp_toFun</span><span class=\"o\">]</span>   <span class=\"c1\">-- does nothing</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">THom.comp_toFun</span><span class=\"o\">]</span>          <span class=\"c1\">-- works</span>\n  <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 317752418,
        "sender_full_name": "Reid Barton",
        "timestamp": 1671904352
    },
    {
        "content": "<p>Maybe <code>simp</code> somehow can't simplify function applications properly?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Meta.Tactic.simp.unify</span><span class=\"o\">]</span> <span class=\"bp\">@</span><span class=\"n\">THom.comp_toFun</span><span class=\"o\">:</span><span class=\"mi\">1000</span><span class=\"o\">,</span> <span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">unify</span>\n      <span class=\"o\">(</span><span class=\"n\">THom.comp</span> <span class=\"bp\">?</span><span class=\"n\">f</span> <span class=\"bp\">?</span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toFun</span>\n    <span class=\"k\">with</span>\n      <span class=\"n\">THom.toFun</span> <span class=\"o\">(</span><span class=\"n\">THom.comp</span> <span class=\"n\">THom.id</span> <span class=\"n\">THom.id</span><span class=\"o\">)</span> <span class=\"n\">x</span>\n</code></pre></div>",
        "id": 317752591,
        "sender_full_name": "Reid Barton",
        "timestamp": 1671904510
    },
    {
        "content": "<p>Of course they don't unify, because of the <code>x</code></p>",
        "id": 317752596,
        "sender_full_name": "Reid Barton",
        "timestamp": 1671904520
    },
    {
        "content": "<p>Looks like this is <a href=\"https://github.com/leanprover/lean4/issues/1937\">https://github.com/leanprover/lean4/issues/1937</a></p>",
        "id": 317752723,
        "sender_full_name": "Reid Barton",
        "timestamp": 1671904667
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/287929-mathlib4/topic/simp.20not.20using.20a.20simp.20lemma/near/317752596\">said</a>:</p>\n<blockquote>\n<p>Of course they don't unify, because of the <code>x</code></p>\n</blockquote>\n<p>I don't understand this. Why don't they unify? This works in Lean 3:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- lean 3</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">THom</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">toFun</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">THom.comp</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">THom</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">THom</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">THom</span> <span class=\"n\">a</span> <span class=\"n\">c</span> <span class=\"o\">:=</span>\n<span class=\"k\">fun</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">g.1</span> <span class=\"bp\">∘</span> <span class=\"n\">f.1</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">theorem</span> <span class=\"n\">THom.comp_toFun</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">THom</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">THom</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n  <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">f.comp</span> <span class=\"n\">g</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toFun</span> <span class=\"bp\">=</span> <span class=\"n\">g.toFun</span> <span class=\"bp\">∘</span> <span class=\"n\">f.toFun</span> <span class=\"o\">:=</span>\n<span class=\"n\">rfl</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">THom.id</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">THom</span> <span class=\"n\">a</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">@</span><span class=\"n\">_root_.id</span> <span class=\"n\">a</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">ex2</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">THom.id.comp</span> <span class=\"n\">THom.id</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toFun</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">THom.comp_toFun</span><span class=\"o\">],</span>   <span class=\"c1\">-- does something</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 317758590,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1671910153
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- lean 4</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"c1\">-- does something</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>That unifies fine.</p>",
        "id": 317758714,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1671910248
    },
    {
        "content": "<p>Right, simp should work. But for some reason it tries to unify the LHS of <code>comp_toFun</code> with the entire LHS of the goal--maybe because it counted some arguments wrong or something.</p>",
        "id": 317758774,
        "sender_full_name": "Reid Barton",
        "timestamp": 1671910294
    },
    {
        "content": "<p>Yeah, it is something more specific than \"simp a function application, with a lemma about the function\".</p>",
        "id": 317758792,
        "sender_full_name": "Reid Barton",
        "timestamp": 1671910317
    },
    {
        "content": "<p>On the lean4 issue linked above, <span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span> says it happens when there is a structure field projection involved</p>",
        "id": 317758885,
        "sender_full_name": "Reid Barton",
        "timestamp": 1671910370
    },
    {
        "content": "<p>Aah I see, I had not properly grokked the trace output.</p>",
        "id": 317759242,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1671910705
    },
    {
        "content": "<p>Is this issue</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.CategoryTheory.StructuredArrow</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">CategoryTheory</span> <span class=\"n\">Limits</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">C</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Category</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Category</span> <span class=\"n\">D</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">SmallCategory</span> <span class=\"n\">J</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">F</span><span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">⥤</span> <span class=\"n\">D</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">K</span><span class=\"o\">:</span> <span class=\"n\">J</span> <span class=\"bp\">⥤</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">:</span> <span class=\"n\">Cone</span> <span class=\"n\">K</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">Cone</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"bp\">⋙</span> <span class=\"n\">F</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">j₁</span> <span class=\"n\">j₂</span><span class=\"o\">:</span> <span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"o\">:</span> <span class=\"n\">j₁</span> <span class=\"bp\">⟶</span> <span class=\"n\">j₂</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"n\">f₂</span><span class=\"o\">:</span> <span class=\"n\">s.pt</span> <span class=\"bp\">⟶</span> <span class=\"n\">F.obj</span> <span class=\"n\">c.pt</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">StructuredArrow.mk</span> <span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"bp\">≫</span> <span class=\"n\">F.map</span> <span class=\"o\">(</span><span class=\"n\">c.π.app</span> <span class=\"n\">j₂</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">StructuredArrow</span> <span class=\"n\">s.pt</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"bp\">⋙</span> <span class=\"n\">F</span><span class=\"o\">))</span> <span class=\"bp\">=</span>\n          <span class=\"n\">StructuredArrow.mk</span> <span class=\"o\">(</span><span class=\"n\">s.π.app</span> <span class=\"n\">j₂</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">StructuredArrow.mk</span> <span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"bp\">≫</span> <span class=\"n\">F.map</span> <span class=\"o\">(</span><span class=\"n\">c.π.app</span> <span class=\"n\">j₁</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">StructuredArrow</span> <span class=\"n\">s.pt</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"bp\">⋙</span> <span class=\"n\">F</span><span class=\"o\">))</span> <span class=\"bp\">=</span>\n          <span class=\"n\">StructuredArrow.mk</span> <span class=\"o\">(</span><span class=\"n\">s.π.app</span> <span class=\"n\">j₁</span><span class=\"o\">))</span>\n\n<span class=\"kd\">example</span><span class=\"o\">:</span> <span class=\"n\">φ</span> <span class=\"bp\">≫</span> <span class=\"o\">(</span><span class=\"n\">eqToHom</span> <span class=\"n\">foo</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">right</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">eqToHom</span> <span class=\"n\">bar</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">right</span> <span class=\"bp\">≫</span> <span class=\"n\">φ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"c1\">-- does nothing</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Comma.eqToHom_right</span><span class=\"o\">]</span> <span class=\"c1\">-- a `simp` lemma</span>\n  <span class=\"n\">simp</span> <span class=\"c1\">-- small progress</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Comma.eqToHom_right</span><span class=\"o\">]</span> <span class=\"c1\">-- a `simp` lemma</span>\n  <span class=\"n\">simp</span>\n  <span class=\"n\">done</span>\n</code></pre></div>\n<p>related to the discussion above or is this an unrelated problem?</p>",
        "id": 353943416,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1682696654
    },
    {
        "content": "<p>This is about <a href=\"https://github.com/leanprover-community/mathlib4/pull/3703\">!4#3703</a>, right?</p>",
        "id": 356806514,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1683577259
    },
    {
        "content": "<p>I've left a porting note. It's <a href=\"https://github.com/leanprover-community/mathlib4/blob/96888ccb794e493bfb3343f6737e563963be174d/Mathlib/CategoryTheory/Functor/Flat.lean#L244-L253\">here</a> and again a few lines later.</p>",
        "id": 356808764,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1683578037
    },
    {
        "content": "<p>Making <code>StructuredArrow</code> reducible solves everything here</p>",
        "id": 356810888,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1683578805
    },
    {
        "content": "<p>The problem is that <code>eqToHom_right</code> is about <code>Comma (Functor.fromPUnit S) T</code>, but our goal contains <code>StructuredArrow S T</code>.</p>\n<p>For whatever reason, <code>simp</code> isn't happy to unfold things, but <code>rw</code> is.</p>\n<p>I suspect this is like <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/stream/287929-mathlib4/topic/LinearAlgebra.2EDual\">#mathlib4 &gt; LinearAlgebra.Dual</a>, where making things reducible is the right call.</p>",
        "id": 356811211,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1683578949
    },
    {
        "content": "<p>A note on <code>simp</code> debugging: you should always start with <code>trace.Meta.Tactic.simp</code>. If, like here, it doesn't even say that it tried to apply the lemma and failed, then it's not a problem with TC synth or unification, but with simp lemma indexing (the discrimination tree)</p>",
        "id": 356812023,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1683579234
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/simp.20not.20using.20a.20simp.20lemma/near/356811211\">said</a>:</p>\n<blockquote>\n<p>For whatever reason, <code>simp</code> isn't happy to unfold things, but <code>rw</code> is.</p>\n</blockquote>\n<p>Since <code>StructuredArrow</code> is an implicit parameter to <code>eqToHom</code>, it might be the case that <code>rw</code> succeeds because the unifier always unfolds non-irreducible defs when visiting implicit parameters, while the discrimination tree does not have such a special case. In the end it is expected that simp lemma indexing trades some accuracy for performance.</p>",
        "id": 356821763,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1683583276
    },
    {
        "content": "<p>In this particular case I don't think we're getting any advantage by not making the definition <code>reducible</code></p>",
        "id": 356821839,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1683583317
    },
    {
        "content": "<p>I will try it out in Mathlib3 to find out... (edit: <a href=\"https://github.com/leanprover-community/mathlib/pull/18973\">#18973</a>)</p>",
        "id": 356821899,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1683583329
    },
    {
        "content": "<p>That sounds like the right call, but just to further illustrate the issue: using</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"o\">(</span><span class=\"n\">eqToHom</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"n\">no_index</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">H</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">right</span> <span class=\"bp\">=</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>in <code>eqToHom_right</code> also fixes the proof</p>",
        "id": 356822074,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1683583420
    },
    {
        "content": "<p>So should this change be made to mathlib?</p>",
        "id": 356824628,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1683584761
    },
    {
        "content": "<p>Which change? Mine (<a href=\"https://github.com/leanprover-community/mathlib/pull/18973\">#18973</a>) or Sebastian's?</p>",
        "id": 356824762,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1683584815
    },
    {
        "content": "<p>I was asking about Sebastian's but anything is fine. I just wanted to make progress with <a href=\"https://github.com/leanprover-community/mathlib4/pull/3703\">!4#3703</a></p>",
        "id": 356825685,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1683585281
    },
    {
        "content": "<p>My preference would be to try these reducibility changes and see if that allows us to remove most of the workarounds from the file, rather than just merge things with the workaround and clean up later; but I've no feel for how important doing this file quickly is. The argument for sorting out the workarounds first is that it may make downstream files easier too.</p>",
        "id": 356826028,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1683585441
    },
    {
        "content": "<p>I don't think <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span>'s solution scales very well here; we don't really want to tell lean that every lemma about <code>Comma</code> should be no-indexed to allow it to work for semireducible aliases</p>",
        "id": 356826185,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1683585510
    },
    {
        "content": "<p>I've just checked that Sebastian's suggested change lets me remove three workarounds in <a href=\"https://github.com/leanprover-community/mathlib4/pull/3703\">!4#3703</a>; I'll now check that yours does too.</p>",
        "id": 356826211,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1683585527
    },
    {
        "content": "<p>(To be clear sebastian's comment is very helpful here, especially for debugging; I just don't think it's something mathlib can exploit much)</p>",
        "id": 356826471,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1683585645
    },
    {
        "content": "<p>Yeah your change also lets me remove the workarounds, although it breaks mathlib a bit more than Sebastian's suggestion (I also had to edit <code>CategoryTheory.Elements</code> (I had to add two <code>rfl</code>s after <code>simp</code>s) and <code>CategoryTheory.Comma</code> (a new goal appeared which <code>simp</code> closed))</p>",
        "id": 356827994,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1683586344
    }
]