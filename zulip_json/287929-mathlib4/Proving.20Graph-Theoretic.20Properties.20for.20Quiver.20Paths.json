[
    {
        "content": "<ol>\n<li>Background</li>\n</ol>\n<p>I'm working with <code>Quiver.Path</code> from <code>Mathlib.Combinatorics.Quiver.Path.Vertices</code> and need to establish two standard graph-theoretic results about simple paths (paths with no repeated vertices). Currently, I have these as axioms in my code, but I'd like to prove them properly or determine if they already exist in mathlib.</p>\n<ol start=\"2\">\n<li>The Two Properties</li>\n</ol>\n<p>A) Simple Path Length Bound</p>\n<p><strong>Statement:</strong> A simple path in a finite quiver has length strictly less than the number of vertices.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">axiom</span><span class=\"w\"> </span><span class=\"n\">quiver_simple_path_bound</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Quiver</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Path</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span>\n\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h_simple</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p.vertices.Nodup</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n\n<span class=\"w\">    </span><span class=\"n\">p.length</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">Fintype.card</span><span class=\"w\"> </span><span class=\"n\">V</span>\n</code></pre></div>\n<p><strong>Intuition:</strong> Since <code>p.vertices</code> has no duplicates and contains <code>p.length + 1</code> elements (via <code>vertices_length</code>), we need <code>p.length + 1 ≤ Fintype.card V</code>, which gives us <code>p.length &lt; Fintype.card V</code>.</p>\n<p>B) Existence of Simple Subpath (Cycle Removal)</p>\n<p><strong>Statement:</strong> Every path contains a simple subpath (with no repeated vertices) connecting the same endpoints.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">axiom</span><span class=\"w\"> </span><span class=\"n\">quiver_exists_simple_subpath</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Quiver</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Path</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n\n<span class=\"w\">    </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Path</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">q.vertices.Nodup</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">q.length</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">p.length</span>\n</code></pre></div>\n<p><strong>Intuition:</strong> If a path has cycles (repeated vertices), we can remove them to obtain a simple path with the same endpoints and shorter or equal length.</p>\n<ol start=\"3\">\n<li>Questions</li>\n</ol>\n<p>3.1. <strong>Do these results already exist in mathlib?</strong> I searched but couldn't find them. They seem like fundamental results that might be useful beyond my specific application.</p>\n<p>3.2. <strong>What's the best approach to prove these?</strong> For the first property, I'm thinking:</p>\n<p>- Use <code>p.vertices.length = p.length + 1</code> (from <code>vertices_length</code>)</p>\n<p>- Use that <code>p.vertices.Nodup</code> implies <code>p.vertices.length ≤ Fintype.card V</code></p>\n<p>- Combine these to get the bound</p>\n<p>For the second property, I'm less certain. Perhaps:</p>\n<p>- Define a function that removes cycles by detecting the first repeated vertex</p>\n<p>- Show this produces a valid path with the same endpoints</p>\n<p>- Show termination and preservation of properties</p>\n<p>3.3. <strong>Would mathlib be interested in PRs for these results?</strong> They seem generally useful for anyone working with paths in quivers/graphs.</p>\n<ol start=\"4\">\n<li>Context</li>\n</ol>\n<p>I'm using these to prove that reachability in finite quivers can be decided by checking paths up to a bounded length (which enables computational verification). The derived result is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">exists_simple_path_bounded</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Quiver</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Path</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n\n<span class=\"w\">    </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Path</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">q.vertices.Nodup</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">q.length</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">Fintype.card</span><span class=\"w\"> </span><span class=\"n\">V</span>\n</code></pre></div>\n<p>Any guidance, pointers to existing lemmas, or suggestions for proving these would be greatly appreciated!</p>",
        "id": 561068414,
        "sender_full_name": "Nicolas Rouquette",
        "timestamp": 1764567567
    },
    {
        "content": "<p>I think it might be a good idea to look at <code>SimpleGraph.Walk</code>, <code>SimpleGraph.Path</code>, <code>SimpleGraph.Walk.bypass</code> (for the second property). (I'm not sure on all the answers, but hope this helps you in the right direction)</p>",
        "id": 561079648,
        "sender_full_name": "Pim Otte",
        "timestamp": 1764573122
    },
    {
        "content": "<p><a href=\"https://github.com/or4nge19/MCMC/tree/19016763bafc712c840940ed878ff3abfd41e8bb/MCMC/PF/Combinatorics/Quiver\">here</a> You can find some useful API for cycles and simple paths which I'm planning to PR to mathlib, though they are not yet updated to the latest PR for SStronglyConnected quivers. With these your theorem should  be easy to put together. <br>\nIf you are working with undirected graphs, you may rather look at SimpleGraph APi as above. Quiver can represent undirected graphs via SymmetricQuiver, but SimpleGraph is more idiomatic for that</p>",
        "id": 561422689,
        "sender_full_name": "Matteo Cipollina",
        "timestamp": 1764684635
    },
    {
        "content": "<p>I think the SimpleGraph walk api sets itself up for failure by using dependent type indices. There was a discussion on the graph theory channel for better definitions of walks and paths. You could adapt some of them for quivers and see how that works out</p>",
        "id": 561424890,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764685128
    },
    {
        "content": "<p>Thanks, <span class=\"user-mention\" data-user-id=\"779253\">@Matteo Cipollina</span>; your work-in-progress MCMC is very helpful in proving the two axioms I need. For now, I'm pinning my dependencies to Lean4 and Mathlib v4.25.0; I see that you're on the bleeding edge of <code>main</code>. So for the time being, I'm copying just the part of your MCMC/PF/Combinatorics/Quiver that I need with proper attribution to you. Please let me know when you submit a PR with your code.</p>",
        "id": 561987854,
        "sender_full_name": "Nicolas Rouquette",
        "timestamp": 1764888433
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"779253\">@Matteo Cipollina</span> I've been trying to build the files you mentioned:<br>\n<a href=\"https://github.com/or4nge19/MCMC/blob/main/MCMC/PF/Combinatorics/Quiver/Path.lean\">https://github.com/or4nge19/MCMC/blob/main/MCMC/PF/Combinatorics/Quiver/Path.lean</a><br>\n<a href=\"https://github.com/or4nge19/MCMC/blob/main/MCMC/PF/Combinatorics/Quiver/Cyclic.lean\">https://github.com/or4nge19/MCMC/blob/main/MCMC/PF/Combinatorics/Quiver/Cyclic.lean</a></p>\n<p>The 1st one contains a lemma: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">length_lt_card_of_isStrictlySimple</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Path</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsStrictlySimple</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">V</span>\n</code></pre></div>\n<p>that directly corresponds to an axiom I used:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">quiver_simple_path_bound</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Quiver</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Path</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h_simple</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">vertices</span><span class=\"bp\">.</span><span class=\"n\">Nodup</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">V</span>\n</code></pre></div>\n<p>This lemma should help me prove my 2nd axiom with <code>[DecidableEq V]</code>.</p>\n<p>However, I'm having problems using these files.</p>\n<p>The MCMC repo uses the \"HEAD\"  revision of Mathlib4; presumably this means <code>master</code>.<br>\n<a href=\"https://github.com/or4nge19/MCMC/blob/main/lakefile.toml\">https://github.com/or4nge19/MCMC/blob/main/lakefile.toml</a></p>\n<p>I am using Lean <code>v4.25.2</code> and I'm running into a problem w/ undefined symbols with Mathlib4 <code>v4.25.2</code>:</p>\n<ul>\n<li><code>List.exists_mem_split</code></li>\n<li>tactic <code>tsub_self</code></li>\n<li><code>List.dropLast_append_singleton</code></li>\n<li><code>List.ne_nil_of_head?_eq_some</code></li>\n<li><code>List.get_idxOf_of_mem</code> </li>\n</ul>\n<p>If I try switching to Mathlib4 <code>master</code>, then I get a deluge of SSL certificate problems.</p>\n<p>Suggestions?</p>",
        "id": 562025130,
        "sender_full_name": "Nicolas Rouquette",
        "timestamp": 1764913289
    },
    {
        "content": "<p>The problem is that I haven't yet updated the repository to the latest mathlib merged PR on Quiver, I'll try to update it today or tmr and let you know.</p>",
        "id": 562047399,
        "sender_full_name": "Matteo Cipollina",
        "timestamp": 1764924426
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"779253\">@Matteo Cipollina</span> ! I switched to v4.26.0-rc2 and used your key theorems as axioms to prove the Quiver path properties that I need for my project. You can find the details of my proofs <a href=\"https://github.com/NicolasRouquette/wip-graph-theory/blob/main/Project/GraphTheory.lean\">here</a>.</p>",
        "id": 562190646,
        "sender_full_name": "Nicolas Rouquette",
        "timestamp": 1764972602
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"779253\">@Matteo Cipollina</span> Any progress on your MCMC update?</p>",
        "id": 567805146,
        "sender_full_name": "Nicolas Rouquette",
        "timestamp": 1768320721
    },
    {
        "content": "<p>I'm updating right now to 4.27.0-rc2, as soon as I merge the update I'll help you on the file. Apologies for the delay</p>",
        "id": 567809580,
        "sender_full_name": "Matteo Cipollina",
        "timestamp": 1768321829
    },
    {
        "content": "<p>Thanks! I look forward to your update! Meanwhile, I used your theorems as axioms in my code to prove the theorems I needed, see: </p>\n<p><a href=\"https://github.com/NicolasRouquette/wip-graph-theory/blob/main/Project/GraphTheory.lean\">https://github.com/NicolasRouquette/wip-graph-theory/blob/main/Project/GraphTheory.lean</a></p>\n<p>Will this be compatible with your MCMC work (I'm currently on Lean 4.27.0-rc1; will also update to rc2)?</p>",
        "id": 567811770,
        "sender_full_name": "Nicolas Rouquette",
        "timestamp": 1768322374
    },
    {
        "content": "<p>I prefer to update it to the latest so I can continue the mathlib PRs, from rc1 to rc2 should be easy because there will be lints for any deprecated API (they last 6 months if I'm not wrong). <br>\nI've seen your file and I'm keen to help you complete it :)</p>",
        "id": 567813753,
        "sender_full_name": "Matteo Cipollina",
        "timestamp": 1768322905
    },
    {
        "content": "<p>The MCMC <a href=\"https://github.com/or4nge19/MCMC\">repository</a> is now updated to 4.27.0-rc1 (which is actually latest stable mathlib - you were correct).<br>\nI think the 3rd axiom is not true in general as stated so I have took the opportunity to correct it. Hope this helps!<br>\n :</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">MCMC</span><span class=\"bp\">.</span><span class=\"n\">PF</span><span class=\"bp\">.</span><span class=\"n\">Combinatorics</span><span class=\"bp\">.</span><span class=\"n\">Quiver</span><span class=\"bp\">.</span><span class=\"n\">Path</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Find</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">!</span>\n<span class=\"cm\">Bridge module for NR's graph-theory axioms.</span>\n\n\n<span class=\"cm\">Note: I think the third axiom as stated in the original file (strict `&lt; Fintype.card V` for *all*</span>\n<span class=\"cm\">positive-length paths, including loops `a = b`) is not provable in general: a quiver can</span>\n<span class=\"cm\">have a Hamiltonian cycle of length `Fintype.card V`, and even the one-vertex quiver with a</span>\n<span class=\"cm\">loop gives an immediate counterexample.</span>\n\n<span class=\"cm\">We provide the strongest generally valid theorem we can prove from the current</span>\n<span class=\"cm\">MCMC development: the strict bound for the non-loop case `a ≠ b`.</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">AsyncDSLMath</span><span class=\"bp\">.</span><span class=\"n\">Abstractions</span><span class=\"bp\">.</span><span class=\"n\">GraphTheory</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Quiver</span>\n\n<span class=\"sd\">/-- Simple path bound</span>\n\n<span class=\"sd\">If a path has no repeated vertices, then its length is strictly less than the number of</span>\n<span class=\"sd\">vertices.</span>\n\n<span class=\"sd\">This is `Quiver.Path.length_lt_card_of_isStrictlySimple` from</span>\n<span class=\"sd\">`MCMC.PF.Combinatorics.Quiver.Path`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">quiver_simple_path_bound</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Quiver</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Path</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h_simple</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">vertices</span><span class=\"bp\">.</span><span class=\"n\">Nodup</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Quiver</span><span class=\"bp\">.</span><span class=\"n\">Path</span><span class=\"bp\">.</span><span class=\"n\">IsStrictlySimple</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">using</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">Quiver</span><span class=\"bp\">.</span><span class=\"n\">Path</span><span class=\"bp\">.</span><span class=\"n\">length_lt_card_of_isStrictlySimple</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">hp</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Quiver</span><span class=\"bp\">.</span><span class=\"n\">Path</span><span class=\"bp\">.</span><span class=\"n\">IsStrictlySimple</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">h_simple</span><span class=\"o\">)))</span>\n\n<span class=\"sd\">/-- Cycle removal / simple subpath extraction</span>\n\n<span class=\"sd\">Every path admits a (strictly) simple path with the same endpoints and length bounded by the</span>\n<span class=\"sd\">original path length.</span>\n\n<span class=\"sd\">We choose a shortest-length path among all paths from `a` to `b` (which exists because `p`</span>\n<span class=\"sd\">itself is such a path), then use `Quiver.Path.isStrictlySimple_of_shortest`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">quiver_exists_simple_subpath</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Quiver</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Path</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Path</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"bp\">.</span><span class=\"n\">vertices</span><span class=\"bp\">.</span><span class=\"n\">Nodup</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">classical</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Path</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hP</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">n0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">find</span><span class=\"w\"> </span><span class=\"n\">hP</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hn0_spec</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">n0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">find_spec</span><span class=\"w\"> </span><span class=\"n\">hP</span>\n<span class=\"w\">  </span><span class=\"n\">rcases</span><span class=\"w\"> </span><span class=\"n\">hn0_spec</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">q</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hq_len</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hmin_all</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Path</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n0</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">r</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">r</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"bp\">⟩</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">find_min'</span><span class=\"w\"> </span><span class=\"n\">hP</span><span class=\"w\"> </span><span class=\"n\">this</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hmin_q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Path</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">r</span>\n<span class=\"w\">    </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">n0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hq_len</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">hmin_all</span><span class=\"w\"> </span><span class=\"n\">r</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hq_simple_strict</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Quiver</span><span class=\"bp\">.</span><span class=\"n\">Path</span><span class=\"bp\">.</span><span class=\"n\">IsStrictlySimple</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"n\">Quiver</span><span class=\"bp\">.</span><span class=\"n\">Path</span><span class=\"bp\">.</span><span class=\"n\">isStrictlySimple_of_shortest</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">hmin_q</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hq_nodup</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"bp\">.</span><span class=\"n\">vertices</span><span class=\"bp\">.</span><span class=\"n\">Nodup</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Quiver</span><span class=\"bp\">.</span><span class=\"n\">Path</span><span class=\"bp\">.</span><span class=\"n\">IsStrictlySimple</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">hq_simple_strict</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">q</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hq_nodup</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">?_⟩</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hmin_q</span><span class=\"w\"> </span><span class=\"n\">p</span>\n\n<span class=\"sd\">/-- A provable version of NR’s `quiver_shortest_path_bound` for the non-loop case.</span>\n\n<span class=\"sd\">If `a ≠ b`, any path from `a` to `b` has positive length, and we can extract a strictly</span>\n<span class=\"sd\">simple subpath and apply `quiver_simple_path_bound`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">quiver_shortest_path_bound_of_ne</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Quiver</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hab</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Path</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Path</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">q</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hq_simple</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hq_le</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">quiver_exists_simple_subpath</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">p</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hq_bound</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">quiver_simple_path_bound</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">hq_simple</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hq_pos</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">by_contra</span><span class=\"w\"> </span><span class=\"n\">h0</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hlen0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">eq_zero_of_not_pos</span><span class=\"w\"> </span><span class=\"n\">h0</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Quiver</span><span class=\"bp\">.</span><span class=\"n\">Path</span><span class=\"bp\">.</span><span class=\"n\">eq_of_length_zero</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">hlen0</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hab</span><span class=\"w\"> </span><span class=\"n\">this</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">q</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hq_pos</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hq_bound</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">AsyncDSLMath</span><span class=\"bp\">.</span><span class=\"n\">Abstractions</span><span class=\"bp\">.</span><span class=\"n\">GraphTheory</span>\n</code></pre></div>",
        "id": 567910808,
        "sender_full_name": "Matteo Cipollina",
        "timestamp": 1768371577
    }
]