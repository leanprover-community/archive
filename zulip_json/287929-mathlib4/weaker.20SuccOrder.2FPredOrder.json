[
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/rooted.20trees/near/462343055\">said</a>:</p>\n<blockquote>\n<p>It is, yes (at least so long as you don't care about infinite dangling bits). But from your description it's not very clear how exactly you want to manipulate rooted trees</p>\n</blockquote>\n<p>I don't think this is true at all. The axiom <code>le_of_pred_lt</code> states that every node that is the predecessor of another node has a unique successor, so there cannot be any branches in your tree.</p>\n<p>I think the <code>SuccOrder</code>/<code>PredOrder</code> classes are too strong. I would like to have classes where the final axiom is removed. This is also useful in the Carleson project, where we are working with a finite rooted trees as an order: <a href=\"https://github.com/fpvandoorn/carleson/blob/master/Carleson/GridStructure.lean#L180-L191\">https://github.com/fpvandoorn/carleson/blob/master/Carleson/GridStructure.lean#L180-L191</a></p>",
        "id": 462549240,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1723728064
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/rooted.20trees/near/462549240\">said</a>:</p>\n<blockquote>\n<p>I don't think this is true at all. The axiom <code>le_of_pred_lt</code> states that every node that is the predecessor of another node has a unique successor, so there cannot be any branches in your tree.</p>\n</blockquote>\n<p>Sorry yeah. I automatically switched off that requirement in my head. What I had in mind was an order <code>α</code> with an endomorphism <code>pred : α → α</code> such that <code>pred a ⩿ a</code> and <code>¬ IsMin a → pred a ⋖ a</code></p>",
        "id": 462549510,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1723728172
    },
    {
        "content": "<p>Well, other then using a wrong definition of trees, I finished formalizing the proof. Hopefully it wouldn't be too hard to fix my definition.</p>",
        "id": 462571433,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1723734472
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/rooted.20trees/near/462549240\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/rooted.20trees/near/462343055\">said</a>:</p>\n<blockquote>\n<p>It is, yes (at least so long as you don't care about infinite dangling bits). But from your description it's not very clear how exactly you want to manipulate rooted trees</p>\n</blockquote>\n<p>I don't think this is true at all. The axiom <code>le_of_pred_lt</code> states that every node that is the predecessor of another node has a unique successor, so there cannot be any branches in your tree.</p>\n<p>I think the <code>SuccOrder</code>/<code>PredOrder</code> classes are too strong. I would like to have classes where the final axiom is removed. This is also useful in the Carleson project, where we are working with a finite rooted trees as an order: <a href=\"https://github.com/fpvandoorn/carleson/blob/master/Carleson/GridStructure.lean#L180-L191\">https://github.com/fpvandoorn/carleson/blob/master/Carleson/GridStructure.lean#L180-L191</a></p>\n</blockquote>\n<p>What would be a good to resolve that in Mathlib? I think defining<code>WeakPredOrder</code> and <code>WeakSuccOrder</code> without it (and making <code>PredOrder</code>/<code>SuccOrder</code> extend it) could work well enough, although it will require some work to figure out how to handle the existing lemmas</p>",
        "id": 462575060,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1723735372
    },
    {
        "content": "<p>Yeah, adding <code>WeakPredOrder</code> and <code>WeakSuccOrder</code> would be good. Although my preference would be that those actually become the default classes, and that the current classes become <code>StrongPredOrder</code>/<code>StrongSuccOrder</code> or something. The weaker ones feel a lot more natural. E.g. if <code>X</code> is a <code>WeakSuccOrder</code> then <code>WithTop X</code> is one too - this doesn't hold for the current <code>SuccOrder</code>.<br>\nAlso, types that are both <code>WeakPredOrder</code> + <code>WeakSuccOrder</code> are also both <code>StrongPredOrder</code> and <code>StrongSuccOrder</code>.</p>",
        "id": 462663885,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1723767958
    },
    {
        "content": "<p>Couldn't that cause a problem with dependencies, or are renames generally ok in Mathlib?</p>",
        "id": 462671272,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1723771750
    },
    {
        "content": "<p>Use <code>@[deprecated (since := \"2024-08-16\")] alias X := Y</code> to indicate the replacements, and you're good to go!</p>",
        "id": 462684753,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1723777999
    },
    {
        "content": "<p>We want to keep the old name, but change its meaning, so an alias couldn't work. I think this is the same problem as <a href=\"#narrow/stream/287929-mathlib4/topic/Deprecation.20.26.20recycling.20lemma.20names\">https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Deprecation.20.26.20recycling.20lemma.20names</a></p>",
        "id": 462685193,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1723778266
    },
    {
        "content": "<p>Careful explanation in the PR description, so that someone tripped up by the change can at least jump to source, git blame, and then read the explanation.</p>",
        "id": 462685721,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1723778501
    },
    {
        "content": "<p>But yes, Mathlib is generally pretty bold about this. We're trying to reform. :-)</p>",
        "id": 462685830,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1723778532
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/rooted.20trees/near/462663885\">said</a>:</p>\n<blockquote>\n<p>if <code>X</code> is a <code>WeakSuccOrder</code> then <code>WithTop X</code> is one too - this doesn't hold for the current <code>SuccOrder</code>.</p>\n</blockquote>\n<p>We do have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=WithTop.succOrderOfNoMaxOrder#doc\">docs#WithTop.succOrderOfNoMaxOrder</a> though, but yes, point taken</p>",
        "id": 462721540,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1723791107
    },
    {
        "content": "<p>I think your refactor is plenty reasonable since your proposed weaker typeclass is in fact equivalent to my current one in the case of a linear order, which is really all I cared about when I originally introduced it</p>",
        "id": 462722099,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1723791285
    },
    {
        "content": "<p>I'll work on it, then</p>",
        "id": 462739577,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1723796583
    },
    {
        "content": "<p>I'm working on it on <a href=\"https://github.com/leanprover-community/mathlib4/pull/15881\">#15881</a>, but I'm having some trouble in <a href=\"https://tqft.net/mathlib4files/Mathlib/Order/SuccPred/Limit\">file#Mathlib/Order/SuccPred/Limit</a>. In particular, are <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Order.isSuccLimitRecOn_succ%27#doc\">docs#Order.isSuccLimitRecOn_succ'</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SuccOrder.limitRecOn_succ#doc\">docs#SuccOrder.limitRecOn_succ</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PredOrder.limitRecOn_pred#doc\">docs#PredOrder.limitRecOn_pred</a> true for weak succ/pred orders?</p>",
        "id": 462776559,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1723811434
    },
    {
        "content": "<p>No, can't be, since now every element can be the successor of several ones, so you can't ensure you know how the data was created</p>",
        "id": 462777268,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1723811703
    },
    {
        "content": "<p>I see, thanks, I moved those results (and what depends on them) to a section which assumes a strong order</p>",
        "id": 462780492,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1723812734
    },
    {
        "content": "<p>My preference would for those lemmas to assume <code>LinearOrder</code></p>",
        "id": 462780661,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1723812790
    },
    {
        "content": "<p>Is there a benefit to that over assuming <code>StrongSuccOrder</code> and having an instance <code>LinearOrder + SuccOrder -&gt; StrongSuccOrder</code>?</p>",
        "id": 462802273,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1723819826
    },
    {
        "content": "<p>Yes, your suggestion loops with the <code>StrongSuccOrder → SuccOrder</code> instance</p>",
        "id": 462802380,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1723819868
    },
    {
        "content": "<p>Oh, so that can't be added as an instance?</p>",
        "id": 462802427,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1723819892
    },
    {
        "content": "<p>Well, Lean 4 claims to have <del>cured cancer</del> allowed looping instances, but in practice the algorithm seems to fail to notice it is looping in some cases <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 462802562,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1723819940
    },
    {
        "content": "<p>+I don't have any non-silly example of a strong non-linear succ order. Here is a silly example: <code>ℕ ⊕ ℕ</code></p>",
        "id": 462802616,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1723819966
    },
    {
        "content": "<p>fwiw, mathlib has rooted trees in the form of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Quiver.Arborescence#doc\">docs#Quiver.Arborescence</a></p>",
        "id": 462847424,
        "sender_full_name": "David Wärn",
        "timestamp": 1723837580
    },
    {
        "content": "<p>So, what exactly do <code>PredOrder</code> and <code>StrongPredOrder</code> represent when not used with linear orders?</p>",
        "id": 462876238,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1723857534
    },
    {
        "content": "<p>Would it be accurate to say they both represent trees? Where <code>pred x</code> gives you the root of the branch containing <code>x</code></p>",
        "id": 462876373,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1723857665
    },
    {
        "content": "<p>Then the difference between both is that <code>PredOrder</code> can have more than one leaf per branch, while <code>StrongPredOrder</code> cannot</p>",
        "id": 462876385,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1723857685
    },
    {
        "content": "<p>I think that's all worth writing in some docstring.</p>",
        "id": 462876404,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1723857711
    },
    {
        "content": "<p>Also, the fact that <code>PartialOrder + SuccOrder</code> gains almost no generality over <code>LinearOrder + SuccOrder</code> seems like something important to note.</p>",
        "id": 462876456,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1723857750
    },
    {
        "content": "<p>Another way to think about it is that in a <code>SuccOrder</code>, <code>succ a</code>is the unique least element greater than <code>a</code>. A <code>StrongSuccOrder</code> guarantees that <code>a</code> is also the unique greatest element lesser than <code>succ a</code> (save for the <code>IsMax a</code> case)</p>",
        "id": 462876958,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1723858276
    },
    {
        "content": "<p>Hey, wait a second. Do we even need <code>StrongSuccOrder</code>?</p>",
        "id": 462879524,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1723860650
    },
    {
        "content": "<p>I agree with Yaël that all the examples of it that aren't linear orders are silly. I think it's little but a source of confusion that successor orders on partial orders exist at all.</p>",
        "id": 462879580,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1723860686
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 462879585,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1723860699
    },
    {
        "content": "<p>Why not simply use <code>LinearOrder</code> + <code>SuccOrder</code>?</p>",
        "id": 462879667,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1723860725
    },
    {
        "content": "<p>33 messages were moved here from <a class=\"stream-topic\" data-stream-id=\"217875\" href=\"/#narrow/stream/217875-Is-there-code-for-X.3F/topic/rooted.20trees\">#Is there code for X? &gt; rooted trees</a> by <span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span>.</p>",
        "id": 462981056,
        "sender_full_name": "Notification Bot",
        "timestamp": 1723900138
    },
    {
        "content": "<p>I would also be happy to get rid of the strong versions (i.e. just remove the last axiom from the current <code>SuccOrder</code>/<code>PredOrder</code>).</p>\n<p>Unless I made a mistake, this is I believe this is a full characterization of strong succ-orders:<br>\n<code>X</code> Is a strong succ-order iff <code>X</code> is (order-)isomorphic to <code>(i : ι) × α i</code> lexicographically ordered, where</p>\n<ul>\n<li><code>ι</code> is any partial order</li>\n<li><code>α i</code> is isomorphic to <code>ℤ</code>, <code>ℕ</code>, <code>ℕᵒᵈ</code> or <code>Fin n</code> (<code>n ≥ 1</code>)</li>\n<li>if <code>α i</code> has a maximal element, then <code>i</code> is a maximal element</li>\n</ul>\n<p>This also shows how similar strong succ-orders and strong pred-orders are: strong pred-orders are the same, except that in the last bullet point \"maximal\" is replaced by \"minimal\".</p>\n<p>I think that because of this characterization, it is unlikely we will find interesting nonlinear strong succ-orders.</p>",
        "id": 462981492,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1723900515
    },
    {
        "content": "<p>I see there's a consensus, so I'll do that</p>",
        "id": 462985807,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1723903208
    },
    {
        "content": "<p>Yes, I agree with this characterisation</p>",
        "id": 462988302,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1723904308
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/15881\">#15881</a> passes CI now</p>",
        "id": 462999055,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1723909269
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/stream/287929-mathlib4/topic/weaker.20SuccOrder.2FPredOrder/near/462981492\">said</a>:</p>\n<blockquote>\n<p>This also shows how similar strong succ-orders and strong pred-orders are: strong pred-orders are the same, except that in the last bullet point \"maximal\" is replaced by \"minimal\".</p>\n</blockquote>\n<p>Just to note, this doesn't mean they're the same! A good example is <code>Ordinal</code>, which is a succ order but not a pred order (since <code>ω</code> has no predecessor but is not minimal)</p>",
        "id": 463283643,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724036785
    },
    {
        "content": "<p>Is any <code>IsSuccArchimedean</code> + <code>LinearOrder</code> also <code>IsPredArchimedean</code> though?</p>",
        "id": 463284486,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724037422
    },
    {
        "content": "<p>In terms of this characterization, a linear strong succ-order being achimedean means that <code>ι</code> is a singleton, doesn't it?</p>",
        "id": 463294606,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1724040221
    },
    {
        "content": "<p>I think so, and all of <code>ℤ</code>, <code>ℕ</code>, <code>ℕᵒᵈ</code> and <code>Fin n</code> are both succ and pred archimedean</p>",
        "id": 463298847,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724041677
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/stream/287929-mathlib4/topic/weaker.20SuccOrder.2FPredOrder/near/463284486\">said</a>:</p>\n<blockquote>\n<p>Is any <code>IsSuccArchimedean</code> + <code>LinearOrder</code> also <code>IsPredArchimedean</code> though?</p>\n</blockquote>\n<p>I believe that currently <code>IsSuccArchimedean</code>and <code>IsPredArchimedean</code> are always equivalent, not just for linear orders.<br>\nIn terms of the characterization, they both hold iff <code>ι</code> holds the trivial order.</p>",
        "id": 463363654,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1724061961
    },
    {
        "content": "<p>Only if both a <code>SuccOrder</code> and <code>PredOrder</code> exists, no? Your characterization doesn't hold for non-linear orders</p>",
        "id": 463369451,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1724063868
    },
    {
        "content": "<p>Where does my characterization fail for non-linear orders?</p>",
        "id": 463369684,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1724063957
    },
    {
        "content": "<p>I meant a non-linear weak order</p>",
        "id": 463370333,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1724064197
    },
    {
        "content": "<p>Yes, I mean that strong succ-order + <code>IsSuccArchimedean</code> is equivalent to strong pred-order + <code>IsPredArchimedean</code>.</p>",
        "id": 463370632,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1724064288
    },
    {
        "content": "<p>So, ehm. I was thinking about weakening these even further.</p>",
        "id": 467548394,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725458778
    },
    {
        "content": "<p>Specifically, I wanted to generalize <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ordinal.pred#doc\">docs#Ordinal.pred</a> to any succ-order. This isn't a true predecessor, since it satisfies e.g. <code>pred ω = ω</code> even though <code>ω</code> isn't minimal.</p>",
        "id": 467548658,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725458843
    },
    {
        "content": "<p>But talking about this on <a href=\"https://github.com/leanprover-community/mathlib4/pull/16463\">#16463</a>, I realized that we might actually be able to generalize things further.</p>",
        "id": 467548804,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725458875
    },
    {
        "content": "<p>For <em>any</em> preorder, you can define a function <code>pred</code> (or dually <code>succ</code>) satisfying the following axioms</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">WeakPredOrder</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Preorder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">pred</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">pred_wcovBy</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">pred</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">⩿</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"n\">pred_of_covBy</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">⋖</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">pred</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">⋖</span><span class=\"w\"> </span><span class=\"n\">b</span>\n</code></pre></div>\n<p>This function is not in general unique - in general, <code>pred a</code> is just some random element covered by <code>a</code> if it exists. It should be unique for linear orders, though. Our current <code>SuccOrder</code> / <code>PredOrder</code> can instead be rewritten so as to constrain this function. I think this should give something equivalent to what we currently have</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">PredOrder'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Preorder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">WeakPredOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">isMin_of_isSuccLimit</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsSuccLimit</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">IsMin</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"n\">eq_left_of_covBy</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">⋖</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">⋖</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span>\n</code></pre></div>\n<p>That is, a <code>PredOrder</code> is an order where every non-minimal element covers another unique element.</p>",
        "id": 467552867,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725459628
    },
    {
        "content": "<p>isMin_of_isSuccLimit is only nontrivial for infinite types, right?</p>",
        "id": 467554580,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1725459900
    },
    {
        "content": "<p>And it's also a consequence of archimedeaness</p>",
        "id": 467554943,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1725459974
    },
    {
        "content": "<p>I believe so. For the record, the definition of <code>IsSuccLimit a</code> is simply <code>∀ b, ¬ b ⋖ a</code>.</p>",
        "id": 467555218,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725460038
    },
    {
        "content": "<p>If <code>IsSuccLimit a</code> and <code>¬ IsMin a</code>, take <code>b &lt; a</code>. You can then build an increasing sequence of elements all greater than <code>a</code>, using that none of them can cover <code>a</code>, to prove <code>α</code> is infinite.</p>",
        "id": 467555399,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725460080
    },
    {
        "content": "<p><code>eq_left_of_covBy</code> should always be true for linear (directed?) orders</p>",
        "id": 467555722,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725460123
    },
    {
        "content": "<p>Definitely not true for codirected orders. Take eg <code>ℕ × ℕ</code></p>",
        "id": 467556080,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1725460180
    },
    {
        "content": "<p>What do you think about this redesign? Is it a good idea?</p>",
        "id": 467557119,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725460388
    },
    {
        "content": "<p>I can try to prove the expected results first just to make sure everything is sound. Basically:</p>\n<ul>\n<li>the new classes should be equivalent to the old ones</li>\n<li><code>WeakSuccOrder</code> is non-empty for any preorder</li>\n<li>if a partial order is a <code>SuccOrder</code>, then <code>WeakSuccOrder</code> is a subsingleton</li>\n<li>if an order is linear, <code>WeakSuccOrder</code> is a subsingleton</li>\n</ul>",
        "id": 467558228,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725460632
    },
    {
        "content": "<p>I personally think of <code>pred</code> as (a slight generalization of) modeling a parent in a forest. I think the current <code>PredOrder</code> models a graph-theoretic forest, while this <code>WeakPredOrder</code> models the parent in a more general <a href=\"https://en.wikipedia.org/wiki/Tree_%28set_theory%29\">set-theoretic tree</a>. Do you think this intuition is correct?</p>",
        "id": 467560993,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1725461114
    },
    {
        "content": "<p>I think it's still accurate to say <code>WeakPredOrder</code> gives you a parent - the difference is that the parent can not exist, or not be unique.</p>",
        "id": 467562678,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725461403
    },
    {
        "content": "<p>It is however unique at least in two cases: when you do have a <code>PredOrder</code>, or in a linear order.</p>",
        "id": 467562876,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725461434
    },
    {
        "content": "<p>For instance, in the order with A &lt; C, B &lt; C, both A and B are possible (weak) predecessors of C. But every element has a unique successor.</p>",
        "id": 467563128,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725461481
    },
    {
        "content": "<p>I think looking at it when it isn't unique feels a bit weird. What are some usecases for that? The only thing I can think of are path decompositions in trees</p>",
        "id": 467565126,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1725461778
    },
    {
        "content": "<p>I'm not really sure if there's a lot of use in the case where successors/predecessors aren't unique. The idea is rather, you can always build a <code>WeakSuccOrder</code>, and under extra conditions like having a <code>SuccOrder</code> or a <code>LinearOrder</code>, it will be unique and thus nicely behaved.</p>",
        "id": 467566291,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725461977
    },
    {
        "content": "<p>Do we care about definitional equalities? If not, then we can define <code>succ</code> and <code>pred</code> for any preorder</p>",
        "id": 467566621,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1725462020
    },
    {
        "content": "<p>We definitely do care, having <code>succ x = x + 1</code> on naturals / ordinals is super nice.</p>",
        "id": 467566794,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725462042
    },
    {
        "content": "<p>Well actually it's not so nice since this definitional equality is not syntactical, and most of the succ-pred API is based on rewriting</p>",
        "id": 467567006,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1725462080
    },
    {
        "content": "<p>My suggestion of throwing away the defeqs for <code>succ</code> and <code>pred</code> would come along with a new typeclass <code>AddSuccOrder</code> stating <code>succ x = x + 1</code> and providing the <code>succ</code> API translated to <code>· + 1</code></p>",
        "id": 467567424,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1725462143
    },
    {
        "content": "<p>What would the instances of it be? Just Nat and Ordinal? Maybe ENat too</p>",
        "id": 467568107,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725462260
    },
    {
        "content": "<p>Also Int</p>",
        "id": 467568195,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1725462275
    },
    {
        "content": "<p>Well, def-eqs are overrated anyways. It would in fact be pretty nice to have <code>succ</code> and <code>pred</code> on arbitrary preorders.</p>",
        "id": 467568486,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725462329
    },
    {
        "content": "<p>But if they're not unique, how would you have it as a typeclass?</p>",
        "id": 467570728,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1725462743
    },
    {
        "content": "<p>Path decompositions still are a valid use, so I don't think always defining it with choice is good</p>",
        "id": 467571729,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1725462934
    },
    {
        "content": "<p>Just thought of another disadvantage of defining them with choice like that: proving results of the form <code>succ x = f x</code> would be more annoying. You'd first have to construct the <code>SuccOrder</code> instance, probably using <code>f</code> indirectly, then argue separately that <code>f</code> satisfies the characterizing properties of <code>succ</code> and that it's thus equal.</p>",
        "id": 467572479,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725463076
    },
    {
        "content": "<p>Doesn't that just mean you need another constructor?</p>",
        "id": 467572734,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1725463132
    },
    {
        "content": "<p>Hmm. I guess you could have a constructor for <code>SuccOrder</code> from an arbitrary successor function, and a theorem saying that <code>succ</code> equals the function that you passed in.</p>",
        "id": 467572927,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725463175
    },
    {
        "content": "<p>But the typeclass approach is definitely cleaner.</p>",
        "id": 467572983,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725463193
    },
    {
        "content": "<p>In my view at least</p>",
        "id": 467573102,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725463210
    },
    {
        "content": "<p>I wouldn't be so sure! I think the typeclass-less approach is worth trying</p>",
        "id": 467573259,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1725463233
    },
    {
        "content": "<p>Something else I don't like is that we couldn't be able to easily state results like \"<code>WeakPredOrder</code> is a subsingleton\". We could only say that a function satisfying the properties of <code>WeakPredOrder</code> equals the one we chose through choice, which is mathematically the same but still a bit more contrived.</p>",
        "id": 467574833,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725463523
    },
    {
        "content": "<p>Surely stating that instances are unique is <em>more</em> contrived than stating that successor functions are unique?</p>",
        "id": 467575399,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1725463630
    },
    {
        "content": "<p>Hm. I guess you can restate \"there is a unique <code>WeakPredOrder</code> as \"every element covers at most one other one\" which is certainly much more natural.</p>",
        "id": 467577430,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725464048
    },
    {
        "content": "<p>I'll make a draft PR for this, maybe this afternoon.</p>",
        "id": 467577507,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725464073
    },
    {
        "content": "<p>I strongly suggest you first add <code>SuccAddOrder</code> so as not to lose the API for <code>ℕ</code>/<code>ℤ</code>/<code>Ordinal</code></p>",
        "id": 467577704,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1725464121
    },
    {
        "content": "<p>Do you think that path decompositions should be done separately, and not as weak successor orders?</p>",
        "id": 467581421,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1725464840
    },
    {
        "content": "<p>What do you mean, concretely?</p>",
        "id": 467581870,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1725464906
    },
    {
        "content": "<p>On trees (PredOrder, IsPredArchimedean, OrderBot), a WeakSuccOrder is exactly a choice of a child for every non-leaf element, which is the same as a path decomposition</p>",
        "id": 467587921,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1725465790
    },
    {
        "content": "<p>I admit to not knowing what path decompositions are, but the Wikipedia article seems to suggest they're a graph rather than an order notion</p>",
        "id": 467590996,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725466216
    },
    {
        "content": "<p>I think the idea is that the edges go from x to succ x.</p>",
        "id": 467592200,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1725466368
    },
    {
        "content": "<p>Ah, I see. Yeah, I guess <code>WeakPredOrder</code> could be used for that. But these <code>SuccOrder</code> / <code>PredOrder</code> definitions are meant for use in orders, and there might be a better and more convenient way to state this for trees.</p>",
        "id": 467594818,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725466768
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/weaker.20SuccOrder.2FPredOrder/near/467577704\">said</a>:</p>\n<blockquote>\n<p>I strongly suggest you first add <code>SuccAddOrder</code> so as not to lose the API for <code>ℕ</code>/<code>ℤ</code>/<code>Ordinal</code></p>\n</blockquote>\n<p>The PR now exists at <a href=\"https://github.com/leanprover-community/mathlib4/pull/16484\">#16484</a>. I was able to deprecate quite a few statements, so this might take a bit to build.</p>",
        "id": 467639697,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725477430
    },
    {
        "content": "<p>Just managed to find this thread eventually to work out why some proof I had was breaking.</p>",
        "id": 486050250,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1733305452
    },
    {
        "content": "<p>(I had only assumed PartialOrder which of course no longer works.)</p>",
        "id": 486050318,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1733305472
    },
    {
        "content": "<p>I don't think anything ever came out of this?</p>",
        "id": 486050541,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1733305549
    },
    {
        "content": "<p>Except for <code>SuccAddOrder</code></p>",
        "id": 486050568,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1733305559
    },
    {
        "content": "<p>(I abandoned my idea to generalize <code>Pred</code> to cover <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ordinal.pred#doc\">docs#Ordinal.pred</a> once I realized that <code>pred x = x - 1</code>, which implies a different refactor should be happening instead)</p>",
        "id": 486050755,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1733305617
    }
]