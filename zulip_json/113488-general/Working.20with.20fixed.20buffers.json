[
    {
        "content": "<p>I do try to implement symmetric encryption algorithm in Lean4 and struggle to write code which modify fixed buffer. Here is how I do it now. I need to update things in specific places, accoring do algorithm, and Lean cannot infer <code>Fin r0.size</code> when working with literal.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">r0</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">UInt8</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">mkArray</span><span class=\"w\"> </span><span class=\"mi\">17</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">i15</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">17</span><span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">15</span><span class=\"w\"> </span><span class=\"c1\">-- Fin r0.size</span>\n<span class=\"n\">r0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"bp\">.</span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"n\">r0</span><span class=\"w\"> </span><span class=\"n\">i15</span><span class=\"w\"> </span><span class=\"n\">key</span><span class=\"o\">[</span><span class=\"mi\">30</span><span class=\"o\">]</span><span class=\"bp\">!</span>\n</code></pre></div>\n<p>I see 2 issues here, </p>\n<ul>\n<li>I have to introduce variable to be able put literal into <code>Array.set</code> </li>\n<li>\n<ul>\n<li>and I have to specify <code>Fin 17</code> instead of <code>Fin r0.size</code> which make it less obvious to see that 17 here and in r0 are connected.</li>\n</ul>\n</li>\n</ul>\n<p>I may try to utilize</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Array</span><span class=\"bp\">.</span><span class=\"n\">set!</span><span class=\"w\"> </span><span class=\"n\">r0</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r0</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">key</span><span class=\"o\">[</span><span class=\"mi\">30</span><span class=\"o\">]</span><span class=\"bp\">!</span>\n</code></pre></div>\n<p>but <code>set!</code> seems to be last resort. Maybe there libraries which try to provide nice primitives for array indexes, or fixed size arrays. I maybe was despearate enough to write my own, but I really don't enough knowledgeable for that.</p>",
        "id": 476038241,
        "sender_full_name": "Andrii Kurdiumov",
        "timestamp": 1728540015
    },
    {
        "content": "<p>There is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Batteries.Vector#doc\">docs#Batteries.Vector</a> for fixed size arrays (as well as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Mathlib.Vector#doc\">docs#Mathlib.Vector</a>)</p>",
        "id": 476192779,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1728583988
    },
    {
        "content": "<p>I would say both of the will have same issues as Array, because Vector.get use Fin n as an index. That type I would say a bit problematic for general purpose programming.</p>\n<p>I understand that maybe I should try to reformulate algorithm in more mathy way, but I hope that maybe somebody also notice these economic issues and it was somehow solved, even in narrow cases.</p>",
        "id": 476200185,
        "sender_full_name": "Andrii Kurdiumov",
        "timestamp": 1728585804
    },
    {
        "content": "<p>There are programming versions like <code>get!</code> for all these data structures</p>",
        "id": 476207406,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1728588073
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"709598\">Andrii Kurdiumov</span> <a href=\"#narrow/stream/113488-general/topic/Working.20with.20fixed.20buffers/near/476200185\">said</a>:</p>\n<blockquote>\n<p>I would say both of the will have same issues as Array, because Vector.get use Fin n as an index. That type I would say a bit problematic for general purpose programming.</p>\n<p>I understand that maybe I should try to reformulate algorithm in more mathy way, but I hope that maybe somebody also notice these economic issues and it was somehow solved, even in narrow cases.</p>\n</blockquote>\n<p>I think the implementation of <code>Vector</code> in batteries does actually have the things you're asking for, here's an example in which the bounds proofs are synthesized and no  local variables or explicit <code>Fin</code> elements are needed (and you'll get a compile-time error if the index is OOB):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Batteries</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Batteries</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Vector</span><span class=\"o\">)</span>\n\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">BufSize</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">17</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">UInt8</span><span class=\"w\"> </span><span class=\"n\">BufSize</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Id</span><span class=\"bp\">.</span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">key</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">UInt8</span><span class=\"w\"> </span><span class=\"n\">BufSize</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"bp\">.</span><span class=\"n\">mkVector</span><span class=\"w\"> </span><span class=\"n\">BufSize</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">r0</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">UInt8</span><span class=\"w\"> </span><span class=\"n\">BufSize</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"bp\">.</span><span class=\"n\">mkVector</span><span class=\"w\"> </span><span class=\"n\">BufSize</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"n\">r0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">r0</span><span class=\"bp\">.</span><span class=\"n\">setN</span><span class=\"w\"> </span><span class=\"mi\">11</span><span class=\"w\"> </span><span class=\"n\">key</span><span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">r0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">r0</span><span class=\"bp\">.</span><span class=\"n\">setN</span><span class=\"w\"> </span><span class=\"mi\">15</span><span class=\"w\"> </span><span class=\"n\">key</span><span class=\"o\">[</span><span class=\"mi\">4</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">r0</span><span class=\"o\">[</span><span class=\"mi\">15</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">r0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">r0</span><span class=\"bp\">.</span><span class=\"n\">setN</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Will produce an error since 19 is OOB: `could not synthesize default value for parameter 'h' using tactics`</span>\n<span class=\"w\">  </span><span class=\"c1\">--r0 := r0.setN 19 x</span>\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">r0</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">q</span>\n</code></pre></div>\n<p>The APIs provided for data structures/collections frequently have more than one means of getting and setting values that do different things depending on how much proof you have or want to provide. For example, <code>Vector</code> has <code>get</code>, <code>getN</code>, and <code>getD</code>. In this case what you want is <code>getN</code>, which tries to synthesize the bounds check proof using <code>get_elem_tactic</code>.</p>\n<p>This kind of integer indexing and bounds proof synthesis stuff got much better with <code>get_elem_tactic</code>. The indexing operations with <code>xs[i]</code> are handled by typeclasses <code>GetElem</code> and <code>GetElem?</code> that are quite smart.</p>",
        "id": 476388798,
        "sender_full_name": "Chris Bailey",
        "timestamp": 1728653217
    },
    {
        "content": "<p>Thank you. Now I lm enlightened. At least I see why suggestion to use batteries working. I somehow miss setN. Will try it then.</p>",
        "id": 476406398,
        "sender_full_name": "Andrii Kurdiumov",
        "timestamp": 1728658930
    }
]