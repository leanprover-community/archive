[
    {
        "content": "<p>Hi all,</p>\n<p>I've been wondering what strategies people use to make sure that the theorem statements they write define what they think they do. For example, here is an incorrect statement of Fermat's last theorem (the last conjunction should be an implication):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Fermat's_last_theorem</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∀</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"n\">c</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">^</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">^</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"bp\">^</span><span class=\"n\">n</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>And here is one way that I would go about verifying the theorem statement:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">Fermat's_last_theorem</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">λ</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fermat's_last_theorem</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">left</span>\n<span class=\"w\">    </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"k\">from</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">not_lt_zero</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">this</span>\n</code></pre></div>\n<p>But (coming from a software engineering background), I'm interested in a more test-driven development style of writing these assertions. That is, writing a proof of a proposition that my intended theorem implies, before I have defined the proposition, and then once I have a correct statement of the theorem (according to this particular implication), the proof goes through. One idea I had is something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fermat's_last_theorem</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"bp\">^</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"bp\">^</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"bp\">^</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">first</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>This way, the proof will pass with a <code>sorry</code> if the theorem is not stated correctly, and once it is, the <code>first</code> tactic will stop hitting the <code>sorry</code>.</p>\n<p>But this still seems fragile/not robust enough, since for example it wouldn't work for applying this statement of Fermat's last theorem, but if you restated the theorem using implications in place of all conjunctions, then it would.</p>",
        "id": 480253621,
        "sender_full_name": "Derrik Petrin",
        "timestamp": 1730584924
    },
    {
        "content": "<p>As far as I know, the current best answer to your question involves two parts:</p>\n<ol>\n<li>\n<p>Ask an experienced Lean user to verify your Lean formalisation<br>\nThere are some pitfalls of Lean (for example, relating to natural number subtraction as opposed to integer subtraction), which take time to learn. For some of them, there exists a prototype linter.</p>\n</li>\n<li>\n<p>Prove some interesting theorem about your statement.<br>\nThis will both week out false statements (you'll have trouble proving them :-)) and will test if your formalisation is <em>workable</em>: not all ways to state your given result will be equally convenient to work with, and working with it will reveal this.</p>\n</li>\n</ol>\n<p>In general, finding (the right/usable) definitions and statements is generally \"the hard part\" of formalisation, much harder than \"just proving it\". Many definitions go through several versions before (or after) landing in mathlib.</p>",
        "id": 480254941,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1730586331
    },
    {
        "content": "<p>I haven't thought much about using TDD practices. That's a nice idea (a sophisticated version: use <code>plausible</code>, formerly known as <code>slim_check</code>, to try to find a counterexample to your statement). I suspect it will not find all issues - some combination of the above still seems needed.</p>",
        "id": 480255052,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1730586433
    },
    {
        "content": "<p>Where is <code>plausible</code> defined? I don't see it in the version of <code>mathlib</code> I have, but I do see <code>slim_check</code>. <code>slim_check</code> definitely looks closer to what I'm thinking! It sounds kind of like the spirit of the Hypothesis Python testing framework.</p>",
        "id": 480256103,
        "sender_full_name": "Derrik Petrin",
        "timestamp": 1730587502
    },
    {
        "content": "<p>Yeah, <code>slim_check</code> moved into a separate library called <code>Plausible</code> in the last week</p>",
        "id": 480256779,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1730588209
    },
    {
        "content": "<p>There's some mathematical objects where you can verify the correctness of a statement just by proving a certain result. To give an example I've been working with, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ONote.opow#doc\">docs#ONote.opow</a> is a quite complicated algorithm for exponentiating ordinals less than epsilon-0, but <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ONote.repr_opow#doc\">docs#ONote.repr_opow</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ONote.nf_opow#doc\">docs#ONote.nf_opow</a> serve as proofs of its correctness regardless.</p>",
        "id": 480262938,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730594360
    },
    {
        "content": "<p>Generally I agree the best way to weed out bad definitions is by proving things about them. If you have a wrong definition then some of the basic results will almost inevitably break. If you have a bad theorem statement then you'll have trouble showing the implications that it should entail.</p>",
        "id": 480263055,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730594477
    },
    {
        "content": "<p>Though sometimes a \"bad definition\" can be relative. Another example I've come across is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=StrictOrder.cof#doc\">docs#StrictOrder.cof</a>. This isn't the correct definition of cofinality for partial orders, but since the current API just uses it for well-orders it hasn't caused much issue as of yet.</p>",
        "id": 480263154,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730594580
    }
]