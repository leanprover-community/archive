[
    {
        "content": "<p>So my use case is I want to understand the \"boundaries\" of theorems, what I can stub/sorry so that I can construct a graph of a more complex proof/construction in mathlib. In metamath everything is very explicit. All hypotheses are explicit, and every proof step is explicit. I want to do something similar with regards to the proof of <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/FieldTheory/IsAlgClosed/AlgebraicClosure.html#AlgebraicClosure.instIsAlgClosureOfIsAlgebraic\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/FieldTheory/IsAlgClosed/AlgebraicClosure.html#AlgebraicClosure.instIsAlgClosureOfIsAlgebraic</a> theorem.</p>\n<p>What would be the best way to trace the theorem down to its dependent theorems? Is there any utility that I can run over the database, that spits out a theorem list X used in the proof of theorem Y. Because then I could build a graph of all theorems I need to port over to get a good understanding of what I necessarily need to understand.</p>\n<p>In particular I'm worried about the following two points:</p>\n<ul>\n<li>How do I distinguish when I need data and when I don't? (I plan to start a backwards trace from the theorem I want to port, in particular, when can I stub proofs with sorry to achieve modularity) </li>\n<li>How can I make sure that tactics aren't doing something that is \"too much magic\". In particular how do I deconstruct tactics and figure out how to simpify them (going lower in the abstraction hierarchy)</li>\n</ul>\n<p>I think I'd rather state my \"wish\" first. I'd like to input a theorem R in the mathlib4 database that outputs a graph G with R as the root and I want two vertices A and B to be connected A-&gt;B if B is part of the proof of A.</p>\n<p>Here is an example for <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/CharP/Frobenius.html#iterateFrobenius_add\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/CharP/Frobenius.html#iterateFrobenius_add</a><br>\nEdges would go to: RingHom.ext, iterate_frobenius_add_apply.</p>\n<p>Then I could use those two newly added theorems and continue: for example with iterate_frobenius_add_apply I would get iterateFrobenius_def, add_comm, pow_add, pow_mul.</p>\n<p>Are there any utilities that I can use, if there aren't, are there any API's such that I can query the database and build it myself? When I talked to <span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span> she helped me remove \"import Mathlib\" to the minimal set of imports with a trace option that gave the correct output.</p>",
        "id": 510784002,
        "sender_full_name": "metakuntyyy",
        "timestamp": 1744068342
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"725717\">metakuntyyy</span> <a href=\"#narrow/channel/113488-general/topic/modularising.2Ftracing.20theorems/near/510784002\">said</a>:</p>\n<blockquote>\n<ul>\n<li>How can I make sure that tactics aren't doing something that is \"too much magic\". In particular how do I deconstruct tactics and figure out how to simpify them (going lower in the abstraction hierarchy)</li>\n</ul>\n</blockquote>\n<p>You can see what a tactic outputs using <code>show_term</code></p>",
        "id": 510784309,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744068500
    },
    {
        "content": "<p>Here's some code I wrote just now that can get you all the constants used in a theorem:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"n\">run_meta</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"ss\">``iterateFrobenius_add</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">getConstInfo</span><span class=\"w\"> </span><span class=\"n\">name</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">const</span><span class=\"bp\">.</span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">val?</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">const</span><span class=\"bp\">.</span><span class=\"n\">value?</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">typeConsts</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"bp\">.</span><span class=\"n\">getUsedConstants</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">valConsts?</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">val?</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Expr</span><span class=\"bp\">.</span><span class=\"n\">getUsedConstants</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">allConsts</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">typeConsts</span><span class=\"bp\">.</span><span class=\"n\">mergeUnsortedDedup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">valConsts?</span><span class=\"bp\">.</span><span class=\"n\">getD</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[])</span>\n<span class=\"w\">  </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">allConsts</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">MessageData</span><span class=\"bp\">.</span><span class=\"n\">ofConstName</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toList</span>\n</code></pre></div>",
        "id": 510786676,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744069908
    },
    {
        "content": "<p>This prints</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>[CommSemiring,\n Nat,\n ExpChar,\n AddCommMonoidWithOne.toAddMonoidWithOne,\n NonAssocSemiring.toAddCommMonoidWithOne,\n Semiring.toNonAssocSemiring,\n CommSemiring.toSemiring,\n Eq,\n RingHom,\n iterateFrobenius,\n HAdd.hAdd,\n instHAdd,\n instAddNat,\n RingHom.comp,\n RingHom.ext,\n iterateFrobenius_add_apply]\n</code></pre></div>",
        "id": 510786730,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744069930
    },
    {
        "content": "<p>You can also filter for just the theorems:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"n\">run_meta</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"ss\">``iterateFrobenius_add</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">getConstInfo</span><span class=\"w\"> </span><span class=\"n\">name</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">const</span><span class=\"bp\">.</span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">val?</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">const</span><span class=\"bp\">.</span><span class=\"n\">value?</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">typeConsts</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"bp\">.</span><span class=\"n\">getUsedConstants</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">valConsts?</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">val?</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Expr</span><span class=\"bp\">.</span><span class=\"n\">getUsedConstants</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">allConsts</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">typeConsts</span><span class=\"bp\">.</span><span class=\"n\">mergeUnsortedDedup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">valConsts?</span><span class=\"bp\">.</span><span class=\"n\">getD</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[])</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">thms</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">allConsts</span><span class=\"bp\">.</span><span class=\"n\">filterM</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">ConstantInfo</span><span class=\"bp\">.</span><span class=\"n\">isTheorem</span><span class=\"w\"> </span><span class=\"bp\">&lt;$&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">getConstInfo</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">thms</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">MessageData</span><span class=\"bp\">.</span><span class=\"n\">ofConstName</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toList</span>\n</code></pre></div>",
        "id": 510787183,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744070187
    },
    {
        "content": "<p>This prints</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>[RingHom.ext, iterateFrobenius_add_apply]\n</code></pre></div>",
        "id": 510787202,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744070203
    },
    {
        "content": "<p>Oh wow, that is really great. Do you know by any chance how this interacts with tactics in particular those that do \"lots of magic\"?<br>\nWIll it print everything that those tactics also use?</p>\n<p>I will definitely experiment with that one a bit.</p>",
        "id": 510791542,
        "sender_full_name": "metakuntyyy",
        "timestamp": 1744072606
    },
    {
        "content": "<p>It doesn't print everything the tactic uses, only the stuff that ends up in the proof.</p>",
        "id": 510793720,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744073972
    },
    {
        "content": "<p><code>linarith</code> for example internally uses the simplex algorithm to find contradictions (see <a href=\"https://tqft.net/mathlib4files/Tactic/Linarith/Oracle/SimplexAlgorithm\">file#Tactic/Linarith/Oracle/SimplexAlgorithm</a> and its imports if you're interested), but you see none of this in the generated proof term, because the proof doesn't need all the details of how a contradiction is found, it only needs the contradiction.</p>",
        "id": 510795111,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744074734
    },
    {
        "content": "<p>Ok that's a good point regarding linarith. It has \"two\" steps, the algorithm and the certificate. The algorithm (here a made up algorithm is used) \"finds\" a solution, lets say x&lt;2 and y&gt;3 and z=5 leads to a contradiction. Do the values end up in a proof, even though the algorithm had to calculate say thousand different failed cases that were necessary for the algorithm to find a solution?</p>\n<p>In other words, let's assume I want to prove that graph A is colourable with three colours while graph B is not. And let's assume I have a specific tactic sat3, that proves those colourabilites while searching for all graphs. It is clear that the proof that graph A is colourable only needs to output the colouring and not all previously failed calculations. But to prove that graph B is not it would need to output to the kernel that it checked all cases.</p>\n<p>Do those proof terms end up being part of this output, or are they opaque in a sense that the meta tactics have no access to them?</p>",
        "id": 511018527,
        "sender_full_name": "metakuntyyy",
        "timestamp": 1744143484
    },
    {
        "content": "<p>The proof term is what gets sent to the kernel. Tactics and such can see them, but there's generally no point, since all proofs are equal anyways.</p>",
        "id": 511019021,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744143662
    },
    {
        "content": "<p>Ah so I can print out the full proof term for every theorem?</p>",
        "id": 511019142,
        "sender_full_name": "metakuntyyy",
        "timestamp": 1744143718
    },
    {
        "content": "<p>Yes, just <code>set_option pp.proofs true</code> and then <code>#print theorem_name</code></p>",
        "id": 511019377,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744143820
    },
    {
        "content": "<p>Depending on what you call the “full proof term”, you probably also want to set other pretty-printing options (maybe even <code>pp.all</code>).</p>",
        "id": 511019780,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1744143991
    },
    {
        "content": "<p>Ok I've tried both your options, they work. I think \"set_option pp.all true\" might be a little too much overkill. I am now trying to figure out what kind of options there are </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"#printalloptions\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">opts</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">getOptions</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">kvs</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">opts</span><span class=\"bp\">.</span><span class=\"n\">entries</span>\n</code></pre></div>\n<p>Unfortunately I get a very weird error that I can't decipher.<br>\nError Message:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">mismatch</span>\n<span class=\"w\">  </span><span class=\"n\">opts</span><span class=\"bp\">.</span><span class=\"n\">entries</span>\n<span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Name</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">DataValue</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"n\">but</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">expected</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">Command</span><span class=\"bp\">.</span><span class=\"n\">CommandElabM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">191518</span><span class=\"w\"> </span><span class=\"bp\">__</span><span class=\"n\">discr</span><span class=\"bp\">✝¹</span><span class=\"w\"> </span><span class=\"bp\">__</span><span class=\"n\">discr</span><span class=\"bp\">✝</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">✝</span><span class=\"w\"> </span><span class=\"n\">opts</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n</code></pre></div>",
        "id": 511023579,
        "sender_full_name": "metakuntyyy",
        "timestamp": 1744145523
    },
    {
        "content": "<p>Apparently this fixed it </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">pp</span><span class=\"bp\">.</span><span class=\"n\">all</span><span class=\"w\"> </span><span class=\"n\">true</span>\n\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"#printalloptions\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">opts</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getOptions</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">entries</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">opts</span><span class=\"bp\">.</span><span class=\"n\">entries</span>\n<span class=\"w\">  </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">entries</span>\n\n<span class=\"bp\">#</span><span class=\"n\">printalloptions</span>\n</code></pre></div>\n<p>I still have to research what the difference between the left arrow and := is</p>",
        "id": 511025408,
        "sender_full_name": "metakuntyyy",
        "timestamp": 1744146269
    },
    {
        "content": "<p>The <code>←</code> assignment runs a monadic value, while the <code>:=</code> binds a value without running anything. So if you have <code>e : m Bool</code> then <code>let c ← e</code> will leave <code>c : Bool</code> and <code>let c := e</code> will leave <code>c : m Bool</code>.</p>",
        "id": 511029269,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744147922
    },
    {
        "content": "<p>Is this related to the \"state\" that the do command introduced. Is that to make \"getOptions\" pure it has to introduce an environment to inject and running the monadic value gives you the state? </p>\n<p>I assume getOptions is not \"pure\" by itself, to make it pure we need to inject the state as a parameter.</p>\n<p>If I translated this in Rust would this syntax fit:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">fn</span><span class=\"w\"> </span><span class=\"n\">getOptions</span><span class=\"o\">(</span><span class=\"n\">state</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"o\">(</span><span class=\"n\">State</span><span class=\"o\">,</span><span class=\"n\">Options</span><span class=\"o\">)</span><span class=\"bp\">;</span>\n</code></pre></div>\n<p>Basically something that returns me the state and options back. If I modify the state I have to pass the state into future calls?</p>\n<p>Did I understand that correctly?</p>",
        "id": 511030098,
        "sender_full_name": "metakuntyyy",
        "timestamp": 1744148304
    },
    {
        "content": "<p>Something like that. When you do the <code>:=</code> this is <del>guaranteed</del> supposed to have no side effects, and when you do <code>←</code>, there are side effects.</p>",
        "id": 511031591,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744148973
    },
    {
        "content": "<p>Thank you very much for the patience and help. I'll experiment and play around a bit with all this information and see if how far I can make it before getting stuck.</p>",
        "id": 511032049,
        "sender_full_name": "metakuntyyy",
        "timestamp": 1744149163
    },
    {
        "content": "<p>Another tip: type <code>set_option pp.</code> and then trigger auto-complete to see what pretty-printing options exist.</p>",
        "id": 511121103,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1744190491
    }
]