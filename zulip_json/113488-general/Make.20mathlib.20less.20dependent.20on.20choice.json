[
    {
        "content": "<p>Dear all,<br>\nFor various reasons, I recently became interested in trying to make mathlib a little less dependent on the axiom of choice.</p>\n<p>Using the script written by <span class=\"user-mention\" data-user-id=\"376152\">@Paul Lezeau</span> and <span class=\"user-mention\" data-user-id=\"873547\">@Robin Arnez</span> <a href=\"#narrow/channel/113488-general/topic/Checking.20which.20axioms.20are.20used.20in.20a.20project/near/574192900\">here</a> we know that 387254 declarations in mathlib (including various dependencies) use choice, this is roughly 55% of the total declarations.</p>\n<p>Of course, there are genuine mathematical reasons to use choice, and avoiding it is in general a difficult problem (likely open for many advanced results, and certainly nontrivial even on paper). On the other hand, mathlib contains many declarations where avoiding choice is mathematically trivial. One example (the first one I encountered in practice) is <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Fintype/Basic.html#Fin.fintype\">Fin.fintype</a>, which you can check depends on <code>Classical.choice</code>.</p>\n<p>My current idea is to eliminate uses of choice in such mathematically trivial situations. This is therefore unrelated to the broader question \"Is there a choice-free proof of X?\" More precisely, I am only interested in those X for which the answer is clearly yes.</p>\n<p>An important point is that I am <em>not</em> proposing to modify mathlib itself, but rather to maintain a parallel version that depends less on choice, with a minimal diff. I have started working in this direction in <a href=\"https://github.com/leanprover-community/mathlib4/pull/35027\">#35027</a>, where I remove choice from <code>Fin.fintype</code>. As you can see, the diff is relatively small (about 60 lines correspond to the script mentioned above), and in practice it mainly consists of removing uses of <code>grind</code> in very basic lemmas about lists. This already results in more than 200 declarations no longer depending on choice.</p>\n<p>I would be interested in hearing opinions about such a project, especially whether others might be interested in contributing. At the moment, I think maintaining this as a PR is the most convenient way to proceed: it allows people to inspect the diff and also provides the cache. If you look at the PR, you will see that some lemmas that use choice live in core, so I cannot modify them directly in a mathlib PR. Instead, I have reproved them in a separate namespace. If anyone has a better idea for handling this, I would be very happy to hear suggestions.</p>\n<p>Also, I don’t have a coherent roadmap. At the moment I’m proceeding opportunistically, removing uses of choice in lemmas that arise in another project where I’m trying to stay choice-free (for example I currently need a choice-free version of <code>Finset.powerset</code>).</p>",
        "id": 575083961,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1771676865
    },
    {
        "content": "<p>Could this sort of work be in a repo with Mathlib as a dependency that is focused on reproving things without choice? I'm imagining a command elaborator like <code>theorem</code>, but that is used to register a choice-free equivalent of an existing declaration. Maybe it could solve the awkwardness of choice in core by registering these in a way that can be referenced in the metaprogram for checking dependency on choice.</p>",
        "id": 575086304,
        "sender_full_name": "Chris Henson",
        "timestamp": 1771678964
    },
    {
        "content": "<p>I have no idea if this is doable with metaprogramming (it would be very nice!). The important point is that a modification to declaration X should propagate to all declarations depending on X.</p>",
        "id": 575086464,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1771679121
    },
    {
        "content": "<p>And with my current approach this happens in mathlib, but not in core. I am not familiar with how to modify core (and having cache for mathlib), this is why I choose this suboptimal approach.</p>",
        "id": 575086571,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1771679231
    },
    {
        "content": "<p>I'm curious about your motivation for this project :-)</p>",
        "id": 575087140,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1771679878
    },
    {
        "content": "<p>I started because I wanted to formalize a bit of <a href=\"https://en.wikipedia.org/wiki/Synthetic_differential_geometry\">Synthetic differential geometry</a>. This happens in a topos, so one can work in the internal logic, i.e. forgetting about toposes and pretending to be in the usual world of mathematics, but without excluded middle, so without choice in Lean (for my project I added the axiom of unique choice, but this is another story). At first I just wanted to see what happens with mathlib, since we use classical reasoning freely.</p>",
        "id": 575087397,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1771680094
    },
    {
        "content": "<p>I was quite surprised that things went reasonably well even with powerful tactics (for example <code>ring</code> works like a charm). The first issue I encountered was the ridiculous use of choice in <em>writing</em> <code>(2 : R)</code>, see <a href=\"https://github.com/leanprover-community/mathlib4/pull/32467\">#32467</a>. Then I had to manipulate various sums over <code>Fin</code> and there things were not so nice.</p>",
        "id": 575087515,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1771680207
    },
    {
        "content": "<p>But I realized that very often the use of choice could be tracked back to a single <code>grind</code> line in a very trivial result, and that the ratio (number of lines to modify)/(number of theorems that become choice free) can, at least at the beginning, be very very small. This why I had the idea of starting doing this. Note that currently, if I could modify core, the diff would be only 5 or 6 lines, and there are 435 theorems that become sorry free (and if the modification would be actually in core this number would probably be considerably higher).</p>",
        "id": 575087670,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1771680365
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"634338\">@Michael Rothgang</span> am I correct in saying that you asked <a href=\"#narrow/channel/428973-nightly-testing/topic/How.20to.20test.20making.20a.20core.20change.20with.20mathlib.3F/with/568156530\">here</a> how to modify core in such a way to have cache in mathlib depending on the new version? Is the guide reliable now?</p>",
        "id": 575090909,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1771683740
    },
    {
        "content": "<p>I wasn't asking about having mathlib cache per se, but that might have been implied by it. I didn't have the chance to come back to the thread yet, so I don't know if the instructions are fully up-to-date now.</p>",
        "id": 575100777,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1771693620
    },
    {
        "content": "<p>I think trying to avoid choice/LEM <em>sometimes</em> creates proofs that are easier to follow (similar to how <code>apply foo; ...</code> is easier to follow than <code>have := ...; exact foo this</code>), and such improvements should make their way into main Mathlib.</p>",
        "id": 575102532,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1771695467
    },
    {
        "content": "<p>How about a project to replace most usages of <code>Quot.out</code>/<code>Quotient.out</code> with induction/recursion? This is a use of choice that is generally frowned upon. It won't necessarily make stuff avoid choice entirely, but it seems aligned with the general goal.</p>",
        "id": 575102537,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1771695470
    },
    {
        "content": "<p>It's very difficult to guess where choice is used. Of course there are results that surely depend on choice, but in practice I think it's much more efficient to target extremely basic declaration, at least at the beginning. You may replace <code>Quotient.out</code> by induction and discover that your theorem still depends on choice for ridiculous reasons. If you think using induction could improve readability of a proof you can actually open a PR to mathlib, it is a welcome contribution.</p>",
        "id": 575102715,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1771695681
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span>, have you tried cutting some non-essential uses at the stem? Many uses of <code>Classical.choice</code> rely only on some theorems like <code>Classical.em</code>. Making the latter an axiom and removing the theorem should already drastically reduce the uses of <code>Classical.choice</code>.</p>\n<p>There is a hierarchy here:</p>\n<ul>\n<li>\n<p><code>Classical.em</code> basically just means that the metatheory of Lean is classical. This is very mild and most mathematicians are happy with a classical metatheory.</p>\n</li>\n<li>\n<p><code>Classical.propDecidable</code> is stronger, it says that the internal logic of Lean is classical. For example, this means that every <code>Type u</code> is a Boolean topos from the category theory point of view.</p>\n</li>\n<li>\n<p><code>Classical.choice</code> is strongest but it is the status quo.</p>\n</li>\n</ul>\n<p>(There are of course several intermediate steps but they are not so important for now.)</p>",
        "id": 575105755,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1771698985
    },
    {
        "content": "<p>Well, my mathematical goal is exactly to avoid excluded middle, so in practice this means avoiding choice in Lean.</p>",
        "id": 575105813,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1771699043
    },
    {
        "content": "<p><code>Classical.em</code> or <code>Classical.propDecidable</code>?</p>",
        "id": 575105855,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1771699096
    },
    {
        "content": "<p>But currently my question is rather what is the best way of doing this from a practical point of view. It's more a software engineering problem than a mathematical question.</p>",
        "id": 575105927,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1771699126
    },
    {
        "content": "<p>I want to avoid <code>Classical.em</code>.</p>",
        "id": 575105944,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1771699137
    },
    {
        "content": "<p>Why do you need an intuitionistic metatheory? That is very rare.</p>",
        "id": 575105970,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1771699167
    },
    {
        "content": "<p>Honestly I don't know anything about this, so it's possible I am saying nonsense. But if I understand correctly the internal logic of a topos is an intuitionistic theory, and I started formalizing synthetic differential geometry in Lean, working internally. Of course the metatheorem that says I can work internally \"as I do usual mathematics, but I cannot use excluded middle\" is not in Lean, but I am just pretending it is. I apologize if what I am saying is imprecise/nonsensical.</p>",
        "id": 575106100,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1771699321
    },
    {
        "content": "<p>This raised the very practical question of proving theorems using mathlib in such a way that <code>#print axioms foo</code> does not display <code>Classical.choice</code>, and I ended up doing so essentially because I am curious about how far I can go.</p>",
        "id": 575106165,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1771699398
    },
    {
        "content": "<p>Let me stress again that mathematically what I am doing is completely trivial. I am talking about modifications like those in <a href=\"https://github.com/leanprover/lean4/pull/12635\">lean4#12635</a>. Now these declarations don't depend on choice anymore, and this gives like 400 less declarations in mathlib that use choice. It's much easier than actually asking \"is there an intuitionistic proof of this not so trivial theorem?\"</p>",
        "id": 575106654,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1771699846
    },
    {
        "content": "<p><code>Classical.em</code> doesn't prevent <code>Type u</code> to be internally intuitionistic. It mostly means that you're using classical logic to reason about <code>Type u</code>. There are a few small consequences to this, such as Markov's Prinicple, <code>∀ (p : Nat → Bool), ¬(∀ n, p n) → (∃ n, p n)</code>, which is provable using <code>Classical.em</code>.</p>\n<p>Several automation tools could just run on <code>Classical.em</code>, so your project could be progressive: eliminate <code>Classical.choice</code> but keep <code>Classical.propDecidable</code>, then eliminate <code>Classical.propDecidable</code> but keep <code>Classical.em</code>, then eliminate <code>Classical.em</code>.</p>",
        "id": 575106818,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1771700003
    },
    {
        "content": "<p>I don't see how to actually check something does not depend on <code>Classical.em</code>. Note in Lean it is not an axiom, it is proved using <code>Classical.choice</code>, so if a declaration does not depend on choice than that's ok, but on the other hand it's difficult to say \"X uses <code>Classical.em</code> but not full choice\".</p>",
        "id": 575106993,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1771700159
    },
    {
        "content": "<p>The same for the others <code>Classical.foo</code>. The only actual axiom is choice.</p>",
        "id": 575107030,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1771700194
    },
    {
        "content": "<p>you can probably (try to) transitively inspect theorems to see if <code>Classical.em</code> is part of the proof bodies?</p>",
        "id": 575107051,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1771700212
    },
    {
        "content": "<p>since i don't believe inlining the proof that <code>Classical.em</code> follows from <code>Classical.choice</code> is allowed with mathlib's style guide</p>",
        "id": 575107150,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1771700304
    },
    {
        "content": "<p>Yes, the linked metaprogram for choice collects constants, right? I don't think it is specific to axioms.</p>",
        "id": 575107239,
        "sender_full_name": "Chris Henson",
        "timestamp": 1771700377
    },
    {
        "content": "<p>Maybe, but that's quite orthogonal to what I want to do. I am sure my theorem has an intuitionistic proof (it seems clear to me, and this is people working synthetic differential geometry, or related area, are expert in noticing uses of classical reasoning). What I am less sure about is if I can actually prove it using mathlib.</p>",
        "id": 575107347,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1771700476
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"687698\">Chris Henson</span> <a href=\"#narrow/channel/113488-general/topic/Make.20mathlib.20less.20dependent.20on.20choice/near/575107239\">said</a>:</p>\n<blockquote>\n<p>Yes, the linked metaprogram for choice collects constants, right? I don't think it is specific to axioms.</p>\n</blockquote>\n<p>It's better to ask the authors since I basically know nothing about metaprogramming, but this is my impression too.</p>",
        "id": 575107425,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1771700560
    },
    {
        "content": "<p>Make a draft PR to core changing <code>Classical.em</code> to an axiom. That will create a PR testing toolchain and a mathlib-testing branch that you can play with at will.</p>",
        "id": 575108010,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1771701199
    },
    {
        "content": "<p>But what's the point?</p>",
        "id": 575108232,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1771701463
    },
    {
        "content": "<p>I am still trying to understand how all the process of creating a toolchain etc etc works, so give me some days to play with <a href=\"https://github.com/leanprover/lean4/pull/12635\">lean4#12635</a> :)</p>",
        "id": 575108303,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1771701536
    },
    {
        "content": "<p>For example I see that now there is a toolchain, but I think to mathlib PR (I rebased onto <code>nightly-with-mathlib</code> but nothing happened).</p>",
        "id": 575108340,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1771701592
    },
    {
        "content": "<p>ah, now there is a mathlib available, so it was just a matter of time</p>",
        "id": 575108386,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1771701634
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/channel/113488-general/topic/Make.20mathlib.20less.20dependent.20on.20choice/near/575108232\">said</a>:</p>\n<blockquote>\n<p>But what's the point?</p>\n</blockquote>\n<p>The point is to refine what is actually needed for a result (in which topoi or models, say, a result can live).  This should have implications not just for reverse mathematics but for future versions where Mathlib splinters into the versions needed for people working in various systems.</p>\n<p>Making one Mathlib for formalization is presently handy and useful as a test case.  Expecting one Mathlib to do what is needed ten or more years from now appears to me to be untenable.</p>",
        "id": 575108464,
        "sender_full_name": "J. J. Issai (project started by GRP)",
        "timestamp": 1771701746
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/channel/113488-general/topic/Make.20mathlib.20less.20dependent.20on.20choice/near/575108232\">said</a>:</p>\n<blockquote>\n<p>But what's the point?</p>\n</blockquote>\n<p>I interpreted this question as asking what is the purpose of changing <code>Classical.em</code> to an axiom when it seems this is not required for the dependency analysis.</p>",
        "id": 575108709,
        "sender_full_name": "Chris Henson",
        "timestamp": 1771702075
    },
    {
        "content": "<p>Yes, I agree that different people have different goals and there is not such a thing as a perfect library.</p>\n<p>Here I exactly want to see how complicated is to maintain a parallel version of mathlib that is adapted to what I am interested in at the moment. Since AFAIK it's a pretty new thing I think it is reasonable to start with very humble goals, and is especially important to keep the diff as small as possible. We all know how painful is to bump mathlib in a downstream project, and merging master after a lot of modifications, possibly to core, batteries and mathlib, can become very quickly a nightmare.</p>\n<p>Let's see if this is doable in a specific case, then people are of course free to do the same with their favorite theory (for example I think that adding unique choice is a very reasonable thing to do, but again, this is not the point).</p>",
        "id": 575108768,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1771702156
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/channel/113488-general/topic/Make.20mathlib.20less.20dependent.20on.20choice/near/575108232\">said</a>:</p>\n<blockquote>\n<p>But what's the point?</p>\n</blockquote>\n<p>How else can you tweak core and have all of mathlib built for you automatically?</p>",
        "id": 575109169,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1771702658
    },
    {
        "content": "<p>This was the point of my suggestion towards the beginning of the thread about a command elab for reproving theorems. My idea is that we don't need to rebuild anything upstream, just provide an alternate proof that is shown to not make use of whatever <code>Classical</code> constants we would like to avoid. (Then this updates our notion of dependency)</p>",
        "id": 575109473,
        "sender_full_name": "Chris Henson",
        "timestamp": 1771703051
    },
    {
        "content": "<p>If you don't have it already, you can request write access to Mathlib Testing so you can tweak the <code>lean4-pr-testing</code> branch too.</p>",
        "id": 575109478,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1771703060
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"687698\">Chris Henson</span> <a href=\"#narrow/channel/113488-general/topic/Make.20mathlib.20less.20dependent.20on.20choice/near/575109473\">said</a>:</p>\n<blockquote>\n<p>This was the point of my suggestion towards the beginning of the thread about a command elab for reproving theorems. My idea is that we don't need to rebuild anything upstream, just provide an alternate proof that is shown to not make use of whatever <code>Classical</code> constants we would like to avoid. (Then this updates our notion of dependency)</p>\n</blockquote>\n<p>That sounds like maximizing work for minimal effect. The saying is that Lean automation freely uses <code>Classical.choice</code>. In reality, almost none of this automation uses choice directly, they mostly use some degree of excluded middle. I would bet that changing <code>Classical.em</code> to an axiom instead of a theorem that uses <code>Classical.choice</code> will dramatically decrease the uses of choice everywhere.</p>",
        "id": 575109728,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1771703401
    },
    {
        "content": "<p>If you just need a one time analysis of the effect of this one change, I completely agree. It is worth doing to measure the effect of choice being used just for excluded middle.</p>\n<p>What was asked about though was how to \"maintain a parallel version [of Mathlib] that depends less on choice\", which I seem to have interpreted differently. For this I think there can be an upfront cost (I think relatively modest) of some metaprogramming, but then in return you get the ability to have a repo downstream of Mathlib that achieves this goal while having a very ordinary process of further updates to Lean and Mathlib.</p>",
        "id": 575110762,
        "sender_full_name": "Chris Henson",
        "timestamp": 1771704614
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119741\">François G. Dorais</span> <a href=\"#narrow/channel/113488-general/topic/Make.20mathlib.20less.20dependent.20on.20choice/near/575106818\">said</a>:</p>\n<blockquote>\n<p><code>Classical.em</code> doesn't prevent <code>Type u</code> to be internally intuitionistic. It mostly means that you're using classical logic to reason about <code>Type u</code>. There are a few small consequences to this, such as Markov's Prinicple, <code>∀ (p : Nat → Bool), ¬(∀ n, p n) → (∃ n, p n)</code>, which is provable using <code>Classical.em</code>.</p>\n</blockquote>\n<p>I would bet that Markov's principle is also not acceptable from the point of view of synthetic differential geometry.</p>",
        "id": 575111451,
        "sender_full_name": "James E Hanson",
        "timestamp": 1771705376
    },
    {
        "content": "<p>Also, if <code>Prop</code> is classical but <code>Type u</code> is internally intuitionistic, what type is the subobject classifier?</p>",
        "id": 575111624,
        "sender_full_name": "James E Hanson",
        "timestamp": 1771705585
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"687698\">Chris Henson</span> <a href=\"#narrow/channel/113488-general/topic/Make.20mathlib.20less.20dependent.20on.20choice/near/575110762\">said</a>:</p>\n<blockquote>\n<p>If you just need a one time analysis of the effect of this one change, I completely agree. It is worth doing to measure the effect of choice being used just for excluded middle.</p>\n<p>What was asked about though was how to \"maintain a parallel version [of Mathlib] that depends less on choice\", which I seem to have interpreted differently. For this I think there can be an upfront cost (I think relatively modest) of some metaprogramming, but then in return you get the ability to have a repo downstream of Mathlib that achieves this goal while having a very ordinary process of further updates to Lean and Mathlib.</p>\n</blockquote>\n<p>Do I understand correctly that you are saying it is possible to override the current, say, <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Data/List/Nat/Range.html#List.nodup_range\">List.nodup_range</a> with a theorem with the same name but with a different proof and only acting on mathlib? This would be the perfect solution, but not that this is in a <em>very basic</em> file, so for example you need to be sure your metacode doesn't use the original, choice dependent, version.</p>",
        "id": 575112091,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1771706086
    },
    {
        "content": "<p>Anyway I <em>think</em> the branch in <a href=\"https://github.com/leanprover-community/mathlib4-nightly-testing/pull/188\">nightly#188</a> does more or less what I want: it depends on the modified version of core and it has only a one line modification with respect to mathlb. I waiting for the cache, but it seems what I wanted.</p>",
        "id": 575112204,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1771706226
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/channel/113488-general/topic/Make.20mathlib.20less.20dependent.20on.20choice/near/575112091\">said</a>:</p>\n<blockquote>\n<p>Do I understand correctly that you are saying it is possible to override the current, say, <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Data/List/Nat/Range.html#List.nodup_range\">List.nodup_range</a> with a theorem with the same name but with a different proof and only acting on mathlib?</p>\n</blockquote>\n<p>What do you mean by only acting on mathlib?</p>",
        "id": 575112331,
        "sender_full_name": "James E Hanson",
        "timestamp": 1771706352
    },
    {
        "content": "<p>not touching core, so without messing up with toolchains and stuff like that.</p>",
        "id": 575112406,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1771706446
    },
    {
        "content": "<p>What are you afraid it would mess up exactly?</p>",
        "id": 575112566,
        "sender_full_name": "James E Hanson",
        "timestamp": 1771706631
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> I am imagining a syntax like </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">reprove</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">nodup_range</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>where it looks up the existing declaration, requires a proof of the same signature not using choice, then registers this in a list of constants that have been reproven without choice.</p>",
        "id": 575112588,
        "sender_full_name": "Chris Henson",
        "timestamp": 1771706661
    },
    {
        "content": "<p>I'm asking because it's relatively easy to use environment hacking to just replace an existing definition/theorem with a different one (or even with an axiom). This would apply to the environment in which you prove theorems, but it wouldn't affect things like metaprogramming.</p>",
        "id": 575112626,
        "sender_full_name": "James E Hanson",
        "timestamp": 1771706719
    },
    {
        "content": "<p>One could in principle use this to check how many theorems in Mathlib really use choice rather than just LEM, for instance.</p>",
        "id": 575112637,
        "sender_full_name": "James E Hanson",
        "timestamp": 1771706735
    },
    {
        "content": "<p>I am not afraid of messing up things, I am just wondering what is the easiest solution in practice. Something that allows me to update core/batteries/mathlib without suffering too much.</p>",
        "id": 575112973,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1771707213
    },
    {
        "content": "<p>Directly manipulating the environment is an interesting alternative, though I'm more paranoid about unintended consequences.</p>",
        "id": 575113061,
        "sender_full_name": "Chris Henson",
        "timestamp": 1771707341
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/channel/113488-general/topic/Make.20mathlib.20less.20dependent.20on.20choice/near/575112973\">said</a>:</p>\n<blockquote>\n<p>I am not afraid of messing up things, I am just wondering what is the easiest solution in practice. Something that allows me to update core/batteries/mathlib without suffering too much.</p>\n</blockquote>\n<p>Like I said earlier, make a draft PR on Lean Core. Then you get CI to build Mathlib. It takes a while to build but it's way more convenient than a local build. You also get build cache... There's really no downside.</p>",
        "id": 575113517,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1771707895
    },
    {
        "content": "<p>I already did that and I am testing everything. I am not familiar with the process so I am a little slow, but so far so good.</p>",
        "id": 575113550,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1771707940
    },
    {
        "content": "<p>The core PR is <a href=\"https://github.com/leanprover/lean4/pull/12635\">lean4#12635</a> and with the corresponding branch <code>lean-pr-testing-12635</code> on <code>mathlib4-nightly-testing</code>. Since I also want to modify mathlib I opened <a href=\"https://github.com/leanprover-community/mathlib4-nightly-testing/pull/188\">nightly#188</a> to see the diff. Testing on my project now.</p>",
        "id": 575113632,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1771708038
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"904624\">James E Hanson</span> <a href=\"#narrow/channel/113488-general/topic/Make.20mathlib.20less.20dependent.20on.20choice/near/575111451\">said</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">would</span><span class=\"w\"> </span><span class=\"n\">bet</span><span class=\"w\"> </span><span class=\"n\">that</span><span class=\"w\"> </span><span class=\"n\">Markov's</span><span class=\"w\"> </span><span class=\"n\">principle</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">also</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">acceptable</span><span class=\"w\"> </span><span class=\"k\">from</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">point</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">view</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">synthetic</span><span class=\"w\"> </span><span class=\"n\">differential</span><span class=\"w\"> </span><span class=\"n\">geometry</span><span class=\"bp\">.</span>\n</code></pre></div>\n<p>I'm curious how that would matter, Markov's principle is generally used to prove that: \"if it's not true that a Turing machine never terminates, then it terminates.\" That's a very mild assumption, often called \"Russian School Constructivism\".</p>",
        "id": 575113723,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1771708134
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/channel/113488-general/topic/Make.20mathlib.20less.20dependent.20on.20choice/near/575113632\">said</a>:</p>\n<blockquote>\n<p>The core PR is <a href=\"https://github.com/leanprover/lean4/pull/12635\">lean4#12635</a> and with the corresponding branch <code>lean-pr-testing-12635</code> on <code>mathlib4-nightly-testing</code>. Since I also want to modify mathlib I opened <a href=\"https://github.com/leanprover-community/mathlib4-nightly-testing/pull/188\">nightly#188</a> to see the diff. Testing on my project now.</p>\n</blockquote>\n<p>You should PR into Mathlib, not Mathlib Testing.</p>",
        "id": 575114217,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1771708694
    },
    {
        "content": "<p>but then I see all the diff wrt to current mathlib, and this is completely unrelated to the modifications I made.</p>",
        "id": 575114249,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1771708735
    },
    {
        "content": "<p>Can't you see the diff from your pr branch?</p>",
        "id": 575114281,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1771708778
    },
    {
        "content": "<p>I'm asking because I never saw the need to do this so I'm curious what additional info you get?</p>",
        "id": 575114341,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1771708853
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119741\">François G. Dorais</span> <a href=\"#narrow/channel/113488-general/topic/Make.20mathlib.20less.20dependent.20on.20choice/near/575113723\">said</a>:</p>\n<blockquote>\n<p>I'm curious how that would matter, Markov's principle is generally used to prove that: \"if it's not true that a Turing machine never terminates, then it terminates.\" That's a very mild assumption, often called \"Russian School Constructivism\".</p>\n</blockquote>\n<p>Markov's principle tends to not hold in toposes of sheaves, and my understanding is that the commonly considered models of SDG are closely related to toposes of sheaves (although I can't find anything about whether they satisfy MP in particular at the moment).</p>\n<p>Beyond that, constructive mathematicians generally don't like to assume MP unless they have to, and more specifically the fact that it is provable in this context at all feels like a sign that maybe more is provable that you wouldn't want for SDG.</p>",
        "id": 575114442,
        "sender_full_name": "James E Hanson",
        "timestamp": 1771709014
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/compare/master...leanprover-community:mathlib4-nightly-testing:lean-pr-testing-12635\">Here</a> the diff wrt to master. Unless I misunderstood something it is huge.</p>",
        "id": 575114443,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1771709014
    },
    {
        "content": "<p>mmm, it is huge because of <code>set_option backward.isDefEq.respectTransparency false in</code>. Maybe this is not the best week to try to play with modifications in core <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 575114488,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1771709099
    },
    {
        "content": "<p>Well if you want to test a Lean change against mathlib you'll need all the fixes for stuff between the latest release and your PR and these are on mathlib4-nightly-testing. And you conveniently get a branch there if you have a Lean PR with passing CI so it's quite natural to add onto that instead of mathlib directly.</p>",
        "id": 575114550,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1771709195
    },
    {
        "content": "<p>Anyway, <a href=\"https://github.com/leanprover/lean4/pull/12635\">lean4#12635</a> is +18-7 and <a href=\"https://github.com/leanprover-community/mathlib4-nightly-testing/pull/188\">nightly#188</a> is a one liner modification. And the script gives... 1296 declarations don't depend on choice anymore.</p>",
        "id": 575114603,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1771709238
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"873547\">Robin Arnez</span> <a href=\"#narrow/channel/113488-general/topic/Make.20mathlib.20less.20dependent.20on.20choice/near/575114550\">said</a>:</p>\n<blockquote>\n<p>Well if you want to test a Lean change against mathlib you'll need all the fixes for stuff between the latest release and your PR and these are on mathlib4-nightly-testing. And you conveniently get a branch there if you have a Lean PR with passing CI so it's quite natural to add onto that instead of mathlib directly.</p>\n</blockquote>\n<p>Yeah, that is my point. All the rest is unrelated to what I am doing.</p>",
        "id": 575114637,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1771709280
    },
    {
        "content": "<p>If you want it to land to Mathlib <code>master</code>, then you should add an attribute <code>@[allowedAxioms]</code> that checks if a declaration uses these axioms only, and reports one of the \"top\" level dependencies that causes unwanted dependency, if there are any.</p>",
        "id": 575114727,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1771709407
    },
    {
        "content": "<p>(and tag theorems you care about with <code>@[allowedAxioms .noChoice]</code> or <code>@[allowedAxioms -choice]</code> - not sure which syntax is better)</p>",
        "id": 575114769,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1771709463
    },
    {
        "content": "<p>Wow! It looks like you accidentally found a new way to mangle the setup. Not sure how that happened. Do you mind if I have a try at fixing it?</p>",
        "id": 575114794,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1771709494
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119741\">@François G. Dorais</span> are you talking to me? Feel free to do whatever you want!</p>",
        "id": 575114823,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1771709536
    },
    {
        "content": "<p>Then you'll have to convince the FRO to merge the core PR, of course. AFAIR, Leo didn't want to support classical reasoning with arguments along the lines of \"not important enough to think about not breaking it\".</p>",
        "id": 575114872,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1771709608
    },
    {
        "content": "<p>What do you mean? How is this mangled?</p>",
        "id": 575114888,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1771709634
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/channel/113488-general/topic/Make.20mathlib.20less.20dependent.20on.20choice/near/575114872\">said</a>:</p>\n<blockquote>\n<p>AFAIR, Leo didn't want to support classical reasoning with arguments along the lines of \"not important enough to think about not breaking it\".</p>\n</blockquote>\n<p>Did you mean to say 'non-classical reasoning'?</p>",
        "id": 575114967,
        "sender_full_name": "James E Hanson",
        "timestamp": 1771709734
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/channel/113488-general/topic/Make.20mathlib.20less.20dependent.20on.20choice/near/575114872\">said</a>:</p>\n<blockquote>\n<p>Then you'll have to convince the FRO to merge the core PR, of course. AFAIR, Leo didn't want to support classical reasoning with arguments along the lines of \"not important enough to think about not breaking it\".</p>\n</blockquote>\n<p>This is exactly why I am going through this process of having a modified version of core. I perfectly know it's almost impossible such a thing is going to be accepted, and even if it is it's just a matter of time before I will find another use of <code>grind</code> getting choice into the story. </p>\n<p>I don't want to change the official version of core, not even mathlib. I just want to make it easy in practice to use my version, and available to anyone is interested.</p>",
        "id": 575115014,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1771709789
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span> That is not useful. The only way to change Leo's mind is to provide a product that meets in the middle, ideally with no compromises on Leo's part. This is _not_ impossible. The <em>product</em> is the key part.</p>",
        "id": 575115031,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1771709810
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/channel/113488-general/topic/Make.20mathlib.20less.20dependent.20on.20choice/near/575114823\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"119741\">François G. Dorais</span> are you talking to me? Feel free to do whatever you want!</p>\n</blockquote>\n<p>I just shuffled the mess, sorry <span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span> Revert if you want. There were some recent changes that may be making things different from what I normally expect. I'll look at it again tomorrow...</p>",
        "id": 575115698,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1771710664
    },
    {
        "content": "<p>No worries! I am force pushing the branch on my computer, without your last commits.</p>",
        "id": 575115750,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1771710738
    },
    {
        "content": "<p>I'd have no issue with an <code>allowed_axioms</code> tag used for whatever basic subset of Mathlib we want to keep choice out of. I'm fine with this, as long as the subset stays small. The moment that we have to start doing any sort of sacrifices in design is the moment where I feel like the cost outweighs the gains.</p>",
        "id": 575130497,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1771728456
    },
    {
        "content": "<p>An example I like to give. In the CGT repo, the basic type of games <a href=\"https://vihdzp.github.io/combinatorial-games/find/?pattern=IGame#doc\">CGT#IGame</a> requires choice to even define, for technical reasons that boil down to the usage of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Shrink#doc\">docs#Shrink</a>. But the benefit is that we can get to proving stuff on games as they are defined in the literature almost immediately.</p>\n<p>Meanwhile, Mathlib has a nearly analogous type <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ZFSet#doc\">docs#ZFSet</a> (which is really just a one-sided game), which doesn't require choice, but it does require an auxiliary type <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PSet#doc\">docs#PSet</a> with no mathematical meaning, as well as hundreds of lines of API where we define functions and relations on this type, so we can later lift them via a convoluted quotient. These are the sorts of situations where I feel like avoiding choice is just a hindrance.</p>",
        "id": 575130794,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1771728906
    },
    {
        "content": "<p>Do I understand correctly that your goal is to eventually (or figure out whether it is theoretically possible to eventually) reason about objects within Lean+3 axioms by defining an internal logic, proving theorems in Lean+2 axioms, and then using metaprogramming to transform proofs in Lean+2 axioms into proof objects in Lean+3 axioms?</p>\n<p>If so, I wonder if the fact that certain theorems are proven without choice can be implemented at the time the metaprogram is run rather than requiring theorems to be proven directly in Lean+2 axioms. I'm not quite sure how to describe it, but I'm imagining a sort of predicate like <code>ProvableWithoutChoice</code>, where <code>ProvableWithoutChoice P</code> is to <code>P</code> as <code>ComputablePred P</code> is to <code>DecidablePred P</code>. That is, ultimately all we care about is the proof of <code>ProvableWithoutChoice P</code> and while one way to prove this is to prove <code>P</code> in Lean+2 axioms and then run a metaprogram on that proof, another way is to start with a proof of <code>P</code> in Lean+3 axioms and run a metaprogram on it to eliminate uses of Classical.choice (which could would by performing substitutions where if <code>P</code> depends on <code>Classical.choice</code> through referencing a proof of <code>Q</code> but there is also a proof of <code>ProvableWithoutChoice Q</code>, then the metaprogram could eliminate the reference to <code>Q</code>).</p>\n<p>The design principle I'm imagining is that the result of <code>#print axioms</code> should not become part of the public API of a lemma. Instead, to record if a lemma's proof doesn't use choice, we could do something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">create_metaproof</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">allowed_axioms</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"ss\">`propext</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"ss\">`Quot.sound</span><span class=\"kd\">]</span><span class=\"o\">)]</span>\n<span class=\"n\">public</span><span class=\"w\"> </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">my_theorem</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>which would, using the same mechanism as <code>@[to_additive]</code>, generate an additional declaration, which is <code>my_theorem.metaproof : ProvableWithoutChoice P</code>. Importantly, the proof of <code>my_theorem</code> is not allowed to use the tactic <code>classical</code> but it is allowed to reference another theorem <code>Q</code> whose proof depends on <code>Classical.choice</code>,  as long as a <code>ProvableWithoutChoice Q</code> exists somewhere.</p>\n<p>I'm not arguing that this would actually be easier than simply sectioning off part of Mathlib to not use choice (and my proposal requires you to be choice-conscious in early parts of Mathlib anyways), but I think that if you want to use choice-free proofs to prove things about internal objects, you need some sort of meta-proof registry anyways (to avoid re-scanning all of mathlib over and over again) and you might as well build the choice-free proofs system into the meta-proof registry anyways rather than trying to make the result of <code>#print axioms</code> part of the public API of a lemma. It also allows you to record that things in core don't depend on choice without actually having to modify core.</p>",
        "id": 575132451,
        "sender_full_name": "Niels Voss",
        "timestamp": 1771731160
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"521331\">Niels Voss</span> <a href=\"#narrow/channel/113488-general/topic/Make.20mathlib.20less.20dependent.20on.20choice/near/575132451\">said</a>:</p>\n<blockquote>\n<p>I'm not quite sure how to describe it, but I'm imagining a sort of predicate like <code>ProvableWithoutChoice</code>, where <code>ProvableWithoutChoice P</code> is to <code>P</code> as <code>ComputablePred P</code> is to <code>DecidablePred P</code>.</p>\n</blockquote>\n<p>Note that to do this, <code>ProvableWithoutChoice</code> can't just be a predicate <code>Prop → Prop</code> in the same way that <code>ComputablePred</code> is just a predicate of type <code>{α : Type u} → [Primcodable α] → (α → Prop) → Prop</code>. Because Lean (with choice) proves there are in total only four predicates of type <code>Prop → Prop</code>! They are the constant functions <code>fun _ =&gt; True</code>, <code>fun _ =&gt; False</code>, as well as <code>id</code> and <code>Not</code>. So in order to be something sensible <code>ProvableWithoutChoice</code> has to be doing something weird to distinguish equal inputs.</p>",
        "id": 575135531,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1771735039
    },
    {
        "content": "<p>That's a good point; you would need some sort of parsing algorithm similar to <code>Std.Do.SPred</code> or a proof theory defined on <code>Expr</code> (like maybe something like lean4lean), which makes things much more complicated than I realized, and removes some of the benefits of my proposed approach.</p>",
        "id": 575139630,
        "sender_full_name": "Niels Voss",
        "timestamp": 1771739665
    },
    {
        "content": "<p>A related dream (but this really just a dream) is to have a <code>toposify</code> or <code>externalize</code> tactic that takes a choice free proof about R-modules and proves the same theorem (in the appropriate sense) for sheaf of modules.</p>",
        "id": 575139732,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1771739811
    },
    {
        "content": "<p>If someone wants to play with my branches note that I closed <a href=\"https://github.com/leanprover/lean4/pull/12635\">lean4#12635</a> and opened <a href=\"https://github.com/leanprover/lean4/pull/12637\">lean4#12637</a> that, if I didn't mess anything up, is based on 4.29-rc1, that is what current mathlib is using. The idea is then to have a branch of batteries using this the modified toolchain and then a PR to mathlib (not nightly testing) using the new toolchain and batteries. In this way this should be identical to current mathlib master except for the modifications I made, and it totally unrelated to nightly stuff.</p>",
        "id": 575146200,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1771747935
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/113488-general/topic/Make.20mathlib.20less.20dependent.20on.20choice/near/575135531\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"521331\">Niels Voss</span> <a href=\"#narrow/channel/113488-general/topic/Make.20mathlib.20less.20dependent.20on.20choice/near/575132451\">said</a>:</p>\n<blockquote>\n<p>I'm not quite sure how to describe it, but I'm imagining a sort of predicate like <code>ProvableWithoutChoice</code>, where <code>ProvableWithoutChoice P</code> is to <code>P</code> as <code>ComputablePred P</code> is to <code>DecidablePred P</code>.</p>\n</blockquote>\n<p>Note that to do this, <code>ProvableWithoutChoice</code> can't just be a predicate <code>Prop → Prop</code> in the same way that <code>ComputablePred</code> is just a predicate of type <code>{α : Type u} → [Primcodable α] → (α → Prop) → Prop</code>. Because Lean (with choice) proves there are in total only four predicates of type <code>Prop → Prop</code>! They are the constant functions <code>fun _ =&gt; True</code>, <code>fun _ =&gt; False</code>, as well as <code>id</code> and <code>Not</code>. So in order to be something sensible <code>ProvableWithoutChoice</code> has to be doing something weird to distinguish equal inputs.</p>\n</blockquote>\n<p>Indeed, the right way to do this is probably by having a type of proofs <code>Proof</code>, as well as a type class <code>Proof.Proves</code> and a predicate <code>Proof.IsNonClassical</code>?</p>",
        "id": 575150368,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1771753344
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119741\">François G. Dorais</span> <a href=\"#narrow/channel/113488-general/topic/Make.20mathlib.20less.20dependent.20on.20choice/near/575113723\">said</a>:</p>\n<blockquote>\n<p>I'm curious how that would matter, Markov's principle is generally used to prove that: \"if it's not true that a Turing machine never terminates, then it terminates.\" That's a very mild assumption, often called \"Russian School Constructivism\".</p>\n</blockquote>\n<p>It is only a mild assumption when your motivation for constructive logic is through computation. If you're coming from geometry, even when your metatheory is classical, Markov's principle holds when the topology is sufficiently regular. I don't have a good intuition for when it holds over gros sites, but one datapoint is that it holds for synthetic Stone duality.</p>",
        "id": 575153810,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1771757113
    },
    {
        "content": "<p>Still not an expert, but in the internal logic of the small zariski site of a scheme X the structure sheaf becomes a non reduced field, or something like that, anyway an object that classically obviously does not exist. In synthetic differential geometry the situation is very similar, the main object is a ring with a property that classically is impossible.</p>",
        "id": 575155013,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1771758570
    },
    {
        "content": "<p>If your ultimate goal is \"turn this proof about modules into a proof about sheaves of modules\" then my guess is that what you're suggesting (a huge foundational upheaval) is not the way to go about this. Usually the way to write a tactic is to come up with some easy examples of what you want it to do, and then write code which does then, and then try and figure out how to write meta code which produces this code. Do you have any concrete toy examples of theorems about sheaves of modules that you want to prove using this method? I'm wondering if this choice-removal is a red herring.</p>",
        "id": 575158160,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1771762495
    },
    {
        "content": "<p>My current concrete goal is to see if it is possible to formalize in Lean and using mahtlib, the internal logic of synthetic differential geometry. This is an intuitionistic theory so I cannot use mathlib's theorem that depend on choice, and this is why I am reproving them without choice. I perfectly realize that not a lot people will care about this goal, and that probably other proof assistants are better in avoiding choice. I am just curious to see <em>in practice</em> how difficult is to do the same with mathlib. (And honestly I am already happy I've learnt how to build a toolchain.)</p>\n<p>The rest is just publicity to advertise this kind of problems, but I don't expect to have anything concrete soon (unless someone else gets involved). Anyway, experts tell me that, as an example where this approach of working internally in a topos really helps, is to show that a sheaf of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"script\">O</mi><mi>X</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathcal{O}_X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">O</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">X</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>-modules on a reduced scheme <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> is locally free on a dense subset of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span>. But again, I don't think setting up all the machinery is easier than just proving the lemma (and I don't even know if it possibile to set up the machinery).</p>",
        "id": 575160232,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1771764684
    },
    {
        "content": "<p>Anyway, to people who want to experiment:</p>\n<ul>\n<li><a href=\"https://github.com/leanprover/lean4/pull/12637\">lean4#12637</a> is the PR to core, that creates the toolchain <code>lean4-pr-releases:pr-release-12637</code>, where a couples of basic results about lists don't depend on choice anymore.</li>\n<li><a href=\"https://github.com/leanprover-community/batteries/pull/1690\">batteries#1690</a> uses the <code>batteries</code> branch <code>riccardo/less_choice</code> that in turn uses the toolchain above. Currently this is the only modification, but it seems likely something will have to be changed even in <code>batteries</code>.</li>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/35641\">#35641</a> is a \"normal\" <code>mathlib</code> PR, but uses the toolchain and <code>batteries</code> mentioned above. Note that it is a PR to <code>master</code>, so the diff you see is the real one, in practice it can be treated as any other PR (but I don't want to merge it, I just want the cache!).</li>\n</ul>\n<p>As you can see the diff is very small, but already with so few modifications to mathlib (+ dependencies) we go from 387284 declarations using choice to 385303. I understand it's not super interesting for mathematicians, but technically this means 1981 theorems now have one less assumption.</p>",
        "id": 575161188,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1771765682
    },
    {
        "content": "<p>I'm aware of this claim about a sheaf being locally free on a dense subset being an application of constructive methods  in algebraic geometry; what I'm saying is that if your actual goal is this then I think the first step isn't the foundational upheaval, the first step is writing a proof of the module statement (the not not free thing) without using choice, and then writing a proof of the sheaf statement in the form which you ultimately want the tactic to produce. Then you can take stock and ask whether you actually need the foundational upheaval in order to get there, or whether you can simply make the tactic without the foundational upheaval, instead being \"inspired by the foundational upheaval\".</p>",
        "id": 575161997,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1771766478
    },
    {
        "content": "<p>I think what I'm saying is that if your goal is to remove AC from the proofs of certain specific statements, then you might want to try writing down those proofs first and seeing where AC is used, rather than trying to remove AC from the proofs of as many statements as possible via some kind of splattergun approach, and hoping you get lucky.</p>",
        "id": 575162238,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1771766742
    },
    {
        "content": "<p>This is what I am doing now (I started a couple of days ago, so I don't know where it is going). For example one can see that <code>Finset.image</code> depends on choice. Why? It's not easy to guess, but in this case it turned out quite easy to remove the dependency by hand, and I am happy about it (since in my project I want to manipulate various sums I need <code>Finset.image</code>).  Something should be doable with a bit of metaprogramming (and I want to learn how to do it!) is to find, given a declaration <code>X</code>, the list of declarations <code>Y</code> used in the proof of <code>X</code> that depend on choice in a minimal sense (those directly connected to choice in the graph of dependencies, if <code>X</code> uses <code>A</code> that uses <code>B</code> that uses <code>C</code> that uses choice I want to see <code>C</code>, not <code>A</code> and <code>B</code>).</p>",
        "id": 575162738,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1771767276
    },
    {
        "content": "<p>So maybe my personal motivation is just to learn something new rather than proving another theorem, but if people find the approach interesting even better!</p>",
        "id": 575162773,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1771767318
    },
    {
        "content": "<p>Come to London, we have metaprogramming experts here :-)</p>",
        "id": 575163450,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1771767957
    },
    {
        "content": "<p>Here is a question about the topos application to alg geometry: if you take the statement about modules, and write the proof in full, then presumably the corresponding statement and proof about sheaves of modules is literally some kind of line by line translation, so in some sense it's the same as what <code>to_additive</code> is doing? I think it would be very instructive to write both proofs in full so that one can see exactly what the translation process looks like in practice.</p>",
        "id": 575163496,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1771768003
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113488-general/topic/Make.20mathlib.20less.20dependent.20on.20choice/near/575163450\">said</a>:</p>\n<blockquote>\n<p>Come to London, we have metaprogramming experts here :-)</p>\n</blockquote>\n<p>I am arriving in March!</p>",
        "id": 575164918,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1771769475
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113488-general/topic/Make.20mathlib.20less.20dependent.20on.20choice/near/575163496\">said</a>:</p>\n<blockquote>\n<p>Here is a question about the topos application to alg geometry: if you take the statement about modules, and write the proof in full, then presumably the corresponding statement and proof about sheaves of modules is literally some kind of line by line translation, so in some sense it's the same as what <code>to_additive</code> is doing? I think it would be very instructive to write both proofs in full so that one can see exactly what the translation process looks like in practice.</p>\n</blockquote>\n<p>i think this is good for getting intuition, but if we want something of this shape in mathlib, we should wait untill we have the internal language of topoi formalized in mathlib, since what you're suggesting includes proofs of \"this notion on sheaves corresponds to this internal notion\" as well as \"the ususal rules of deduction are sound in the internal language of a topos\".</p>",
        "id": 575166111,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1771770785
    },
    {
        "content": "<p>and only the second part of that is relevant to any potential metaprogram, i think</p>",
        "id": 575166177,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1771770853
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/channel/113488-general/topic/Make.20mathlib.20less.20dependent.20on.20choice/near/575150368\">said</a>:</p>\n<blockquote>\n<p>Indeed, the right way to do this is probably by having a type of proofs <code>Proof</code>, as well as a type class <code>Proof.Proves</code> and a predicate <code>Proof.IsNonClassical</code>?</p>\n</blockquote>\n<p>We have been working on this machinery in <a href=\"https://github.com/sinhp/HoTTLean/\">HoTTLean</a>. (We are interested in models of HoTT there, but the machinery is general and also applicable to sheaf models of SDG).</p>\n<p>We are working in type theory so there isn't exactly a type of <code>Proof</code>s but rather a type of terms-of-some-type; but that's probably what you meant anyway. Our analogue of the <code>create_metaproof</code> attribute that <span class=\"user-mention\" data-user-id=\"521331\">@Niels Voss</span> suggested is <code>@[reflect]</code>. It takes a Lean definition and produces a deeply embedded \"reflection\", i.e., given <code>def foo : T := a</code>, it produces a (Lean) proof that <code>𝕋 ∣ · ⊢ a : T</code> which we can read as \"type theory proves that <code>a</code> is a closed term of type <code>T</code> using axioms <code>𝕋</code>\". Then <code>ProvableWithoutChoice</code>/<code>Proof.IsNonClassical</code> amounts to <code>Classical.choice ∉ 𝕋</code>. See <a href=\"https://github.com/sinhp/HoTTLean/pull/168/changes#diff-984ff10ff002a37878ab1152be88c6e7e02a74099cf0c8469e10219baf219942\">here</a> for some example uses. (Btw, <code>@[reflect]</code> has already been discussed <a href=\"#narrow/channel/116395-maths/topic/Facts.20on.20sheaves.20and.20schemes.20via.20constructive.20logic/near/261257358\">back in 2021</a>).</p>",
        "id": 575176617,
        "sender_full_name": "𝚠𝚘𝚓𝚌𝚒𝚎𝚌𝚑 𝚗𝚊𝚠𝚛𝚘𝚌𝚔𝚒",
        "timestamp": 1771780420
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113488-general/topic/Make.20mathlib.20less.20dependent.20on.20choice/near/575158160\">said</a>:</p>\n<blockquote>\n<p>Do you have any concrete toy examples of theorems about sheaves of modules that you want to prove using this method?</p>\n</blockquote>\n<p>One example that Ingo Blechschmidt sometimes highlights is as follows. (I am no algebraic geometer, so apologies for any potential mistakes.) Let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>𝒪</mi><mi>X</mi></msub></mrow><annotation encoding=\"application/x-tex\">𝒪_X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathscr\" style=\"margin-right:0.08078em;\">O</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.0808em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">X</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> be the structure sheaf of a ringed space, and let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>→</mo><msub><mi>M</mi><mn>1</mn></msub><mo>→</mo><msub><mi>M</mi><mn>2</mn></msub><mo>→</mo><msub><mi>M</mi><mn>3</mn></msub><mo>→</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0 → M_1 → M_2 → M_3 → 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> be an exact sequence of sheaves of modules over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>𝒪</mi><mi>X</mi></msub></mrow><annotation encoding=\"application/x-tex\">𝒪_X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathscr\" style=\"margin-right:0.08078em;\">O</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.0808em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">X</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>. If <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">M_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>M</mi><mn>3</mn></msub></mrow><annotation encoding=\"application/x-tex\">M_3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> are of finite type, then so is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>M</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">M_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>. (Is this in mathlib? I couldn't find it by Stacks tag 01B7.) Then the way to prove this via <code>toposify</code> is to translate a constructive proof of the \"de-sheafified\" statement which is as follows. Let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>→</mo><msub><mi>M</mi><mn>1</mn></msub><mo>→</mo><msub><mi>M</mi><mn>2</mn></msub><mo>→</mo><msub><mi>M</mi><mn>3</mn></msub><mo>→</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0 → M_1 → M_2 → M_3 → 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> be an exact sequence of modules. If the outer ones are finitely generated, then the middle one is as well. (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Module.Finite.of_exact#doc\">docs#Module.Finite.of_exact</a>).</p>",
        "id": 575180333,
        "sender_full_name": "𝚠𝚘𝚓𝚌𝚒𝚎𝚌𝚑 𝚗𝚊𝚠𝚛𝚘𝚌𝚔𝚒",
        "timestamp": 1771784125
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113488-general/topic/Make.20mathlib.20less.20dependent.20on.20choice/near/575163496\">said</a>:</p>\n<blockquote>\n<p>if you take the statement about modules, and write the proof in full, then presumably the corresponding statement and proof about sheaves of modules is literally some kind of line by line translation</p>\n</blockquote>\n<p>It's not super clear to me what line-by-line might mean for Lean proof terms. Let me interpret that as \"a metaprogram that takes a <code>Lean.Expr</code> of the internal proof (e.g. in constructive ring theory) and produces another <code>Lean.Expr</code> for the external one (e.g. about sheaves) by a somewhat direct recursion\". There is a sort of syntactic, recursive translation from constructive-internal-statement to sheaf-statement given by <a href=\"https://ncatlab.org/nlab/show/Kripke-Joyal+semantics\">Kripke-Joyal semantics</a>, but this is for translating <em>statements</em>, not proofs. I have once attempted to translate proof terms concurrently with K-J, so perhaps the sort of thing you mean. I ran into so many issues that I am now convinced the correct approach is rather what we are doing with HoTTLean, deep embedding of type theory and all. But I don't mean to discourage anyone from trying!</p>",
        "id": 575181220,
        "sender_full_name": "𝚠𝚘𝚓𝚌𝚒𝚎𝚌𝚑 𝚗𝚊𝚠𝚛𝚘𝚌𝚔𝚒",
        "timestamp": 1771784971
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/channel/113488-general/topic/Make.20mathlib.20less.20dependent.20on.20choice/near/575166111\">said</a>:</p>\n<blockquote>\n<p>if we want something of this shape in mathlib, we should wait untill we have the internal language of topoi formalized in mathlib, since what you're suggesting includes proofs of \"this notion on sheaves corresponds to this internal notion\" as well as \"the ususal rules of deduction are sound in the internal language of a topos\"</p>\n</blockquote>\n<p>I should remark on one thing: it is common to talk about the 'internal language of topoi', but in classical literature that language is some kind of higher-order logic rather than dependent type theory (so more like Isabelle than Lean). <em>Actually interpreting dependent type theory</em> in a (let's say sheaf) topos remains an active area of research. One obstacle is that it's technically challenging to build a <em>universe</em> in such a topos (see e.g. <a href=\"https://arxiv.org/abs/2202.12012\">Strict universes for Grothendieck topoi</a> for one construction), and you need a universe if the internal logic is to support a <code>Type</code> universe. One would probably struggle to do any math in Lean without quantifying over <code>Type</code>! So what we have in HoTTLean is a 'natural model' which one could think of as an adjusted definition of topos that assumes you have already solved this problem. (See also <a href=\"#narrow/channel/116395-maths/topic/Categorical.20logic.20in.20Lean.3F.20.28algebraic.20theories.2C.20etc.2E.29/near/562106936\">this previous discussion</a>.)</p>",
        "id": 575182518,
        "sender_full_name": "𝚠𝚘𝚓𝚌𝚒𝚎𝚌𝚑 𝚗𝚊𝚠𝚛𝚘𝚌𝚔𝚒",
        "timestamp": 1771785940
    },
    {
        "content": "<p>FInally, with apologies for hijacking this thread somewhat, I also have a call to action for those interested in developing the hypothetical <code>toposify</code>. I believe the HoTTLean approach is promising, but there are many technical problems to solve before it can be used for anything like those sheaf-of-modules statements or SDG. To list some, we only support a very minimal fragment of Lean, there are performance issues in the <code>@[reflect]</code> macro, and we don't quite know how to effectively work with \"this notion on sheaves corresponds to this internal notion\" yet. (I also discussed some of these in my <a href=\"https://youtu.be/w0J-zcudg18\">talk</a> on Thursday.) I think there are paths to solving these, but it will require effort. We are actively looking for help and new contributors! If there is enough interest, maybe we could even start a Zulip stream for the project?</p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"w0J-zcudg18\" href=\"https://youtu.be/w0J-zcudg18\"><img src=\"https://uploads.zulipusercontent.net/f32bd3a3f08c38fd62b7a798960937d1f00b5ce4/68747470733a2f2f692e7974696d672e636f6d2f76692f77304a2d7a6375646731382f6d7164656661756c742e6a7067\"></a></div>",
        "id": 575183826,
        "sender_full_name": "𝚠𝚘𝚓𝚌𝚒𝚎𝚌𝚑 𝚗𝚊𝚠𝚛𝚘𝚌𝚔𝚒",
        "timestamp": 1771786977
    },
    {
        "content": "<p>I agree. This issue needs a team with both theory experts (in topos theory and type theory) and expert users (for API and applications). I would be happy to engage in such a team.</p>",
        "id": 575184195,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1771787200
    },
    {
        "content": "<p>Going back the experiment I described at the beginning, the main place for having a look is now <a href=\"https://github.com/leanprover-community/mathlib4/pull/35685\">#35685</a>.</p>",
        "id": 575376891,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1771873245
    },
    {
        "content": "<p>By the way, I am writing an article on synthetic differential geometry with <span class=\"user-mention\" data-user-id=\"974502\">@Gabriella Clemente</span>, you can see the code <a href=\"https://github.com/riccardobrasca/SDG\">here</a>.</p>",
        "id": 576214887,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1772184741
    }
]