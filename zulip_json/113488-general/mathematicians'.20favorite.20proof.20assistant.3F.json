[
    {
        "content": "<p>Among proof assistants, I think Lean currently has the most working mathematicians whose research interests don't fall into foundations of mathematics. Do you think this is true? Am I missing something?</p>",
        "id": 351505672,
        "sender_full_name": "Bulhwi Cha",
        "timestamp": 1682051445
    },
    {
        "content": "<p>You are not missing anything.</p>",
        "id": 351506885,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1682052337
    },
    {
        "content": "<p>Thanks for the reply. This was the reason that <span class=\"user-mention\" data-user-id=\"454439\">@shimsw20</span> and I chose Lean over Coq.</p>",
        "id": 351507219,
        "sender_full_name": "Bulhwi Cha",
        "timestamp": 1682052570
    },
    {
        "content": "<p>I think that this is true but it might also be just a sociological issue rather than \"mathematicians all got together and chose the best one\"</p>",
        "id": 351533047,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1682062894
    },
    {
        "content": "<p>The question was about \"favorite\", not \"best\" :)</p>",
        "id": 351533185,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1682062933
    },
    {
        "content": "<p>Right, but my point is that the reason that lean is many mathematician's favourite might not be because of a belief that it's the best for mathematics</p>",
        "id": 351534093,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1682063187
    },
    {
        "content": "<p>I am curious to know how this happened though. As far as I know, Coq has been around for much longer. Why did the need to develop Lean arise? What problem was it trying to solve that couldn't be solved in Coq? Why did it catch on with mathematicians much more than a tool with a longer history (and so presumably more stuff to build on top of, when lean initially started out)?</p>",
        "id": 351534645,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1682063343
    },
    {
        "content": "<p>Why do mathematicians prefer lean to coq? Is this purely because of mathlib (one of my reasons)? Is it the usability (again,one of my reasons)?</p>",
        "id": 351535150,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1682063471
    },
    {
        "content": "<p>In my case, it's the fault of Kevin and the Natural Number Game</p>",
        "id": 351535476,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1682063562
    },
    {
        "content": "<p>I think that one thing lean had going for it historically was \"no history\", whereas many of the other provers had picked up a following amongst constructivists, computer scientists, people interested in univalence etc. These things are completely unrelated to what is actually happening in mathematics departments. Whereas when people started building <code>mathlib</code> as a classical mathematics library, Mario and Johannes were just like \"well if that's what you guys want, go for it\".</p>",
        "id": 351535486,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1682063567
    },
    {
        "content": "<p>So quickly <code>mathlib</code> established itself as a library which was using the language familiar to mathematicians. Whereas if you read the Coq odd order paper it's full of \"well here mathematicians used the complex numbers but they don't have decidable equality so here we go on a massive detour using the following ideas\" and mathematicians reading this just think \"?\"</p>",
        "id": 351535866,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1682063672
    },
    {
        "content": "<p>I'd never even heard of decidable equality when I joined the lean community and I'd been a professional number theorist for 20 years by that point.</p>",
        "id": 351536062,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1682063735
    },
    {
        "content": "<p>There's also just some social accidents: helpful devs, Mario ready to answer our questions 24 hours a day, gitter was nice to use ...</p>",
        "id": 351536253,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1682063793
    },
    {
        "content": "<p>Hales in his 2017 Big Proof talk suggested using lean for his formal abstracts project and this was good evidence for me that at least one of the experts who had seen a lot of theorem provers and were interested in the mathematics happening in mathematics departments thought that this was the right tool</p>",
        "id": 351536306,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1682063818
    },
    {
        "content": "<p>Re Scott's comments: yes that was also key. As a mathematician with absolutely no CS or type theory or logic background, I found essentially no readable literature, but Mario was prepared to answer my many many questions on the lean chat.</p>",
        "id": 351536665,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1682063926
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/113488-general/topic/mathematicians'.20favorite.20proof.20assistant.3F/near/351536253\">said</a>:</p>\n<blockquote>\n<p>There's also just some social accidents: helpful devs, Mario ready to answer our questions 24 hours a day, gitter was nice to use ...</p>\n</blockquote>\n<p>Was lean the first to have a chat room? I see that Isabelle and coq also have their respective zulipchats</p>",
        "id": 351536864,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1682063988
    },
    {
        "content": "<p>No idea</p>",
        "id": 351537050,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1682064040
    },
    {
        "content": "<p>We certainly had zulipchat before they did. But we had gitter before that.</p>",
        "id": 351537147,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1682064062
    },
    {
        "content": "<p>Lean had one in summer 2017 because Scott, Patrick and me were all asking questions, and Mario and Johannes and Simon Hudon were answering</p>",
        "id": 351537341,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1682064121
    },
    {
        "content": "<p>That was gitter</p>",
        "id": 351537448,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1682064145
    },
    {
        "content": "<p>It felt quite exciting like mathoverflow was exciting in 2009 (Scott and I were both there then too!) -- a bunch of experts answering questions and it being completely under the radar of most people</p>",
        "id": 351537796,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1682064243
    },
    {
        "content": "<p>And before that was the lean-user mailing list, which is what most systems used as the main medium for decades and some (most?) continue to do</p>",
        "id": 351537909,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1682064284
    },
    {
        "content": "<p>The gitter chat is still all up and accessible, although it's very difficult to search.</p>",
        "id": 351538035,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1682064325
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/mathematicians'.20favorite.20proof.20assistant.3F/near/351536306\">said</a>:</p>\n<blockquote>\n<p>Hales in his 2017 Big Proof talk suggested using lean for his formal abstracts project and this was good evidence for me that at least one of the experts who had seen a lot of theorem provers and were interested in the mathematics happening in mathematics departments thought that this was the right tool</p>\n</blockquote>\n<p>This is very on spot, and I think that also you <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> might be one of the main reasons for Lean popularity, for the same reasons as <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> and also for the promotion and outreach (perhaps \"inreach\" would be a more suitable term).</p>",
        "id": 351596658,
        "sender_full_name": "Pedro Sánchez Terraf",
        "timestamp": 1682077415
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/113488-general/topic/mathematicians'.20favorite.20proof.20assistant.3F/near/351536864\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/113488-general/topic/mathematicians'.20favorite.20proof.20assistant.3F/near/351536253\">said</a>:</p>\n<blockquote>\n<p>There's also just some social accidents: helpful devs, Mario ready to answer our questions 24 hours a day, gitter was nice to use ...</p>\n</blockquote>\n<p>Was lean the first to have a chat room? I see that Isabelle and coq also have their respective zulipchats</p>\n</blockquote>\n<p>Wrt Isabelle, their Zulip is fairly new and they work almost exclusively with mailing lists: One for development, and the main, all-purpose one (which you could think of as a merger of all active channels here).</p>",
        "id": 351597376,
        "sender_full_name": "Pedro Sánchez Terraf",
        "timestamp": 1682077555
    },
    {
        "content": "<p>The success of Lean among mathematicians was definitely not predicted. <span class=\"user-mention\" data-user-id=\"110865\">@Jeremy Avigad</span> was quite skeptical at the beginning about mathlib being successfully run as a completely open source project. I prefer Lean over Coq interface-wise, but the technical differences are not massive. Culturally though there is a much bigger difference, and (speaking for myself) the Lean community resonates with me much better than either Coq or Isabelle, for different reasons (and of course there is some feedback involved there - I have tried to foster a productive and welcoming environment as long as I have been involved in the Lean project). I am still a leader in the Metamath community, but it is much smaller, and I would not really suggest it to be used by mathematicians without giving it an interface overhaul<a href=\"https://github.com/digama0/mm0\">*</a> first.</p>",
        "id": 351612322,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1682080909
    },
    {
        "content": "<p>I'm not a mathematician, but I tried Coq and I disliked its syntax very much. Luckily I found Lean afterwards</p>",
        "id": 351628090,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1682084064
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"451983\">Arthur Paulino</span> <a href=\"#narrow/stream/113488-general/topic/mathematicians'.20favorite.20proof.20assistant.3F/near/351628090\">said</a>:</p>\n<blockquote>\n<p>I'm not a mathematician, but I tried Coq and I disliked its syntax very much. Luckily I found Lean afterwards</p>\n</blockquote>\n<p>For me it was some combination of syntax (I care about good PL syntax), mathlib, and tooling, not necessarily in that order.  If there is one lesson I have learnt from this, it is that no matter how technically awesome a new PL or software can be, UX matters and can make or break your project.</p>",
        "id": 351630492,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1682084559
    },
    {
        "content": "<p>And for me and some of my friends, TPIL has made a big difference too. I like how it starts off with the PL style term language and then progresses to tactics. With Coq  and Isabelle tutorials, it is hard to build a mental model of what is going on underneath, when they start off with arbitrary tactics,  each with its own strange way of specifying the parameters it needs.</p>",
        "id": 351632340,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1682084918
    },
    {
        "content": "<p>My journey to Lean was (I think) longer and more varied than most, so I'll give my 2 cents (actually, reader beware, this is a long story, so maybe it's 2 dollars). I include approximate dates for when things occurred for me, but they may not be entirely accurate because I'm just going off of memory and some touchstones, but I don't have logs.</p>\n<p>TL;DR: I played around with a bunch of programming languages and proof assistants and found Lean before it became \"popular\", although I didn't interact with the community hardly at all. I found it's nice syntax (e.g., <code>assume</code> and <code>have</code>, <code>begin ... end</code>, use of Unicode) appealing easy to read and understand. Moreover, the focus of other communities on things that weren't important to me (e.g., constructivism) made me eschew those.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>My journey to Lean</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>I started down this path as a mathematician who wanted to do some programming on the side, and I dabbled in various languages (Python, C, etc.), but another mathematician mentioned Haskell to me and I thought it was great (built-in Big Ints! <code>[1..]</code> for the natural numbers! I was excited). This happened circa 2014-2015.</p>\n<p>But then I realized it was limited. I couldn't for example, create the type <code>fin n</code> to do proper modular arithmetic. At the time I didn't really understand dependent type theory, and I learned you could do this with sufficiently many language extensions in Haskell, but it was a bit hacky and I also realized you couldn't prove the properties you wanted about the things you were defining (e.g., you could create functors, but you couldn't guarantee they were lawful). This was really occurred to me mid-2016.</p>\n<p>So I went in search of other things, and I found Idris. It was cool because then I could prove things and that was satisfying, but I found it hard to really get anything off the ground. This is in part because (a) the library was <em>very</em> small at the time, (b) I was doing many things from scratch and (c) Idris is really focused more on being a general purpose programming language. I spent probably 6 months fiddling with Idris.</p>\n<p>This led me to explore more. I learned about many things around this time, and it's hard to remember exactly which came first, but I started reading the HoTT book and got very excited at first, but then found it quite difficult after the first few chapters, and I decided I didn't really like the idea of there being multiple distinct constructions of the real numbers (I had virtually no exposure to constructive mathematics at that time), and going through higher inductive types just to get one of the most fundamental objects in mathematics seemed like a pain. So, I semi-abandoned that but came back to look at the HoTT book for several years thereafter. This was early 2017.</p>\n<p>I also went looking around at other things, but not any of them did I spend any more time on than a few weeks or a month: Agda, Coq, Metamath. I liked Agda pretty well, but to me (all the opinions expressed here are my own experience and may not be representative of reality) it seemed the community was very much of the mind: \"take whatever axioms you want,\" and I didn't find this particularly appealing. Coq was okay, but the community and material was so focused on constructivism, and I wasn't sold on it (again, you just lose so many properties of the real numbers, and, since I work in C⋆-algebras, it's really not something I'm willing to sacrifice; by this point I had read a bit of <em>Constructive Analysis</em>). I didn't like Metamath (sorry Mario! <span aria-label=\"smiling face\" class=\"emoji emoji-263a\" role=\"img\" title=\"smiling face\">:smiling_face:</span>), but that's because I just found it so hard to decipher. I found the syntax daunting, and while it seemed simple (you just have to substitute!) it was immensely difficult for me to get anywhere. </p>\n<p>Finally, around the end of 2017 or early 2018, I found Lean. I know it may sound stupid to many, but the syntax and Unicode support were <em>huge</em> for me. It just made everything more readable (this is partly why I liked Agda too, but for some reason I had trouble inputting the Unicode in emacs, I don't recall why, as I'm sure there has to be support for it in the Agda mode). I started just building things from scratch. I started by just defining <code>ℕ</code> from scratch (I even used <code>prelude</code> for a bit before it became unbearable without tactics; remember, I used Idris so I was comfortable with term mode proofs, and then I just did <code>namespace hidden</code> and allowed myself <code>rw</code> <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span>) and proving the basic properties. It was basically a roll-your-own natural number game.</p>\n<p>Throughout this, I just read the source whenever I had issues. When I got to <code>≤</code> I was super confused by the source because I didn't understand inductive predicates well, which I certainly should have by this point. It took me a bit to understand that. I then built the integers too. Mind you, I was doing this <em>entirely alone</em>, which was my standard method of learning. I didn't even join Zulip until (checking Zulip: Dec 30, 2018), and even then I remained silent and didn't even read much of what people said for several years. </p>\n<p>At this point, I also had less time to spend doing this because I was in the midst of my first few years as a faculty member, and I needed to focus on teaching and publishing. So, I spent much less time on Lean for a while, but in that time Kevin released the NNG, I watched the videos for Lean Together 2019 and just soaked in whatever I could. I did build the real numbers via Dedekind cuts in late 2020 (mainly to keep teaching myself how to do things), and was going to contribute it to mathlib, but then learned it wasn't really wanted (of course I understand why now). Finally, at the end of 2021 I was finishing up the tenure process, <span class=\"user-mention\" data-user-id=\"311453\">@Frédéric Dupuis</span> had just defined C⋆-algebras, and I was ready to contribute, so I jumped in and actually started participating in the community and on Zulip.</p>\n</div></div>",
        "id": 351644917,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1682087396
    },
    {
        "content": "<p>While I am also not a mathematician, my journey to Lean shares a surprising number of features with others despite our different backgrounds. I was a CS person who had used Haskell and wanted to do some elementary theorem proving, so I went looking for system that could help me do that more rigorously. I read about the big names (Coq, Idris, etc.), but was turned off by their syntax and editor support, which were quite outdated and aesthetically displeasing to my eye. I then stumbled upon Lean 3 and found its UX satisfying, so I ended up using it to prove some toy theorems and then to do the much the same as Jireh (build up logic and numbers from scratch). I enjoyed it, so I stuck with it. I was also essentially silent on the Zulip forums until Lean 4. In direct contrast to the mathematicians, my biggest qualms with Lean were its emphasis on classical logic (I much prefer constructivism) and its overabundance of Unicode, but there were enough positives (and enough opportunities to avoid those aspects) to overwhelm the negatives.</p>",
        "id": 352994254,
        "sender_full_name": "Mac Malone",
        "timestamp": 1682554310
    },
    {
        "content": "<p>Anecdotal evidence from maths students also says that Unicode matters a lot to them -- \"it looks the same as it does in the textbooks\" -- (in contrast with some people from computer science backgrounds who I've heard railing against the idea)</p>",
        "id": 353122996,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1682578870
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/mathematicians'.20favorite.20proof.20assistant.3F/near/353122996\">said</a>:</p>\n<blockquote>\n<p>Anecdotal evidence from maths students also says that Unicode matters a lot to them -- \"it looks the same as it does in the textbooks\" -- (in contrast with some people from computer science backgrounds who I've heard railing against the idea)</p>\n</blockquote>\n<p>One such situation : <a href=\"https://github.com/tlaplus/rfcs/issues/5\">https://github.com/tlaplus/rfcs/issues/5</a></p>",
        "id": 353150872,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1682582617
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 353655531,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1682660488
    },
    {
        "content": "<p>The reason Lean became the most popular theorem prover is, in my opinion, the presence of video tutorials, rich math library, excellent auto-generated documentation, readable language specification and handbook, NNG and few other introductory games, and of course a very nice and welcoming Zulip community.</p>\n<p>Other communities did very little on popularizing and advertizing their theorem provers. Only professional mathematicians who know what they are doing use their provers for research. But new users who just want to \"play\" with a theorem prover find the lack of nice documentation and tutorials as a big hindrance and get repelled from learning the syntax.</p>\n<p>Most Lean users are not professional mathematicians, but students (or other people) who just want to play and experiment with a new toy. As they play, they learn more and eventually become capable of proving advanced theorems and helping others. The most important ingredient, in my opinion, are the video tutorials, interactive games and readable language specification (written in a form of a tutorial), so that anyone can easily start proving simple stuff, without having to spend few weeks trying to understand convoluted documentation.</p>",
        "id": 353671447,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1682663115
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"456794\">Patrick Johnson</span> <a href=\"#narrow/stream/113488-general/topic/mathematicians'.20favorite.20proof.20assistant.3F/near/353671447\">said</a>:</p>\n<blockquote>\n<p>The reason Lean became the most popular theorem prover</p>\n</blockquote>\n<p>amongst mathematicians. It is not the theorem prover with the largest user base. Coq and Isabelle have more users, and there might be others.</p>\n<blockquote>\n<p>Other communities did very little on popularizing and advertizing their theorem provers. Only professional mathematicians who know what they are doing use their provers for research.</p>\n</blockquote>\n<p>Nope. The other provers have large communities of CS researchers using them. Almost no professional mathematician uses a theorem prover. If they do, they most likely use Lean or one of the HoTT systems.</p>",
        "id": 353674986,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1682663619
    },
    {
        "content": "<p>Especially for most CS researchers using Isabelle there is very likely no reason to use Lean. If they just want to verify algorithms or semantics of something the automation of Isabelle makes this infinitely more easy than in Lean. There is not really a killer feature of Lean (to my knowledge, I'll be happily proven wrong) that would convince a CS researcher working in algorithms or semantics with Isabelle to switch to Lean right now.</p>",
        "id": 353676502,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1682663839
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> Would the extremely flexible syntax of Lean 4 be such a feature? I guess it's one of the easiest ways to handroll a DSL...</p>",
        "id": 353678534,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1682664124
    },
    {
        "content": "<p>Hm, Lean does not necessarily make it easier although it is indeed more flexible. Consider for example this expression definition/syntax in Isabelle: <a href=\"https://isabelle.in.tum.de/library/HOL/HOL-IMP/Com.html\">https://isabelle.in.tum.de/library/HOL/HOL-IMP/Com.html</a>  and then for example small step semantics defined as an inductive relation on top of it: <a href=\"https://isabelle.in.tum.de/library/HOL/HOL-IMP/Small_Step.html\">https://isabelle.in.tum.de/library/HOL/HOL-IMP/Small_Step.html</a> doesn't look too bad does it?^^ But indeed as syntax gets more complicated the Isabelle limitations start to show harder.</p>",
        "id": 353681065,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1682664451
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113488-general/topic/mathematicians'.20favorite.20proof.20assistant.3F/near/353674986\">said</a>:</p>\n<blockquote>\n<p>amongst mathematicians. It is not the theorem prover with the largest user base. Coq and Isabelle have more users, and there might be others</p>\n</blockquote>\n<p>Did I say \"largest user base\"? The term \"popular\" is clearly subjective. If a new user wants to learn to use a theorem prover, it is higly likely that he would choose Lean rather than other provers. Again, this is clearly subjective.</p>",
        "id": 353686819,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1682665320
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113488-general/topic/mathematicians'.20favorite.20proof.20assistant.3F/near/353674986\">said</a>:</p>\n<blockquote>\n<p>Nope. The other provers have large communities of CS researchers using them. Almost no professional mathematician uses a theorem prover. If they do, they most likely use Lean or one of the HoTT systems.</p>\n</blockquote>\n<p>This is again subjective. What one may consider a part of CS, other may consider a part of pure math. Maybe I should have used the term \"professional scientist\" instead of \"professional mathematician\". The point I am trying to make is that other theorem provers are not advertized enough (this is my subjective opinion). In contrast, Lean has much better tutorials (including video tutorials), which someone who is not a \"professional scientist\" finds enough to start playing with Lean (again, this is my subjective opinion, none of these assertions can be precisely defined, nor can they be formalized, so arguing whether they are true or not is pointless).</p>",
        "id": 353686970,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1682665332
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/113488-general/topic/mathematicians'.20favorite.20proof.20assistant.3F/near/353676502\">said</a>:</p>\n<blockquote>\n<p>Especially for most CS researchers using Isabelle there is very likely no reason to use Lean. If they just want to verify algorithms or semantics of something the automation of Isabelle makes this infinitely more easy than in Lean. There is not really a killer feature of Lean (to my knowledge, I'll be happily proven wrong) that would convince a CS researcher working in algorithms or semantics with Isabelle to switch to Lean right now.</p>\n</blockquote>\n<p>We need to separate algorithms and semantics here.  The semantics (and some FV and crypto) people are pretty much the only major theorem prover users in CS. The majority of the formal verification community is focused on model checking methods. Thus many projects used for verification use something like TLA.</p>\n<p>For a very small epsilon, Epsilon people in the algorithms community care about theorem provers or formalization. I have met quite a few who did so in the past, mostly in Isabelle and Coq, and they were heavily turned off by the bad syntax, tooling, learning curve, and lack of coherent libraries that automated basic proof steps across multiple domains. The reactions were considerably more intense than I wish to describe here. </p>\n<p>The algorithms formalisation community is much smaller and has very little intersection with modern theory work in CS. They mostly work with Isabelle (apparently writing automation for generating equation theorems for recursive function definitions is simpler in HOL as against type theory (paraphrased)).</p>",
        "id": 353730576,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1682671388
    },
    {
        "content": "<p>But the reason the latter community doesn't work with mainstream theorists is basically down to the limitations that I describe in paragraph 2. I showed Lean to a very senior and respected theorist in this field who had dabbled in verification some years ago.</p>",
        "id": 353731646,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1682671520
    },
    {
        "content": "<p>His response: He loved it and said that in comparison tools like Isabelle were clearly showing their age. He found it considerably easier to understand what the theorems were saying</p>",
        "id": 353732111,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1682671574
    },
    {
        "content": "<p>So <span class=\"user-mention\" data-user-id=\"456794\">@Patrick Johnson</span> 's argument also holds for researchers. Simplicity matters. Usability matters. Large math library matters. It might not be entirely meaningful to judge theorem provers by how popular they are among Computer Scientists at present, since there are many who have avoided using TPs in the first place, for non-technical usability reasons, that lean appears to address.</p>",
        "id": 353733628,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1682671778
    },
    {
        "content": "<p>As a corollary, there are a large number of (theoretical and sometimes practical) computer scientists, who just want to do good old fashioned classical math, covering linear algebra, combinatorics, probability, and some analysis. They don't care about constructivism. They don't care to go through hoops to install software tools (git might be an exception). No theorem prover has caught their collective imagination yet. Lean by virtue of mathlib might be the best poised, modulo some obstacles that currently exist.</p>",
        "id": 353760772,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1682675166
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 353936573,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1682695928
    }
]