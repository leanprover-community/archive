[
    {
        "content": "<p>In Lean 4 can you write a function that pattern matches against a Prop?</p>\n<p>My first attempt looked like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">propToSomething</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Something</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">),</span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">),</span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">atomic</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>But I get an error. I imagine that there is something special about Prop that makes this not work. Is there any way to do something similar, maybe involving metaprogramming or something? </p>\n<p>Basically, I'm looking for a way to map the logical structure of a term of type Prop into something else.</p>",
        "id": 470777995,
        "sender_full_name": "Avi Craimer",
        "timestamp": 1726531433
    },
    {
        "content": "<p><code>Prop</code> is not an inductive type. Your choices, depending on what you are wanting to do next, are to build an inductive type that models the class of propositions you are interested in (probably with a realisation function to <code>Prop</code>), or to do some metaprogramming and look at the <code>Expr</code> objects rather than the propositions themselves. But that will help you write tactics, not directly to do proofs.</p>",
        "id": 470778684,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1726531684
    },
    {
        "content": "<p>Thanks. If I wanted to try the metaprogramming route how to I convert a Prop into an Expr object?</p>",
        "id": 470780705,
        "sender_full_name": "Avi Craimer",
        "timestamp": 1726532433
    },
    {
        "content": "<p>You can't do that.</p>",
        "id": 470784218,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1726533168
    },
    {
        "content": "<p>(i.e. you need to start somewhere you have access to an <code>Expr</code>. There is a <code>toExpr</code> function, but, for essentially the reasons you've already encountered, it is not possible to write a <code>ToExpr Prop</code> instance.)</p>",
        "id": 470784569,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1726533223
    },
    {
        "content": "<p>Ok, got it. So it sounds like you're saying that the metaprogramming route isn't actually an option (<del>or maybe I'm misunderstanding something</del>). [Edit: the discussion with Mario below confirmed that I was not misunderstanding here. Metaprogramming cannot do what I was asking for.]</p>\n<p>The other option you mentioned is to make an inductive type that can converted to a Prop. Here is what I came up with. </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">PropInductive</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">atom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">:</span><span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">neg</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">pInd</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PropInductive</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">and</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">left</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PropInductive</span><span class=\"o\">)(</span><span class=\"n\">right</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PropInductive</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">or</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">left</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PropInductive</span><span class=\"o\">)(</span><span class=\"n\">right</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PropInductive</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">implies</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">left</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PropInductive</span><span class=\"o\">)(</span><span class=\"n\">right</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PropInductive</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">uQuant</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\">  </span><span class=\"n\">PropInductive</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">eQuant</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\">  </span><span class=\"n\">PropInductive</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">PropInductive</span><span class=\"bp\">.</span><span class=\"n\">toProp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">pInd</span><span class=\"o\">:</span><span class=\"n\">PropInductive</span><span class=\"w\"> </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">pInd</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">atom</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">p</span>\n<span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">neg</span><span class=\"w\"> </span><span class=\"n\">pInd</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">toProp</span><span class=\"w\"> </span><span class=\"n\">pInd</span><span class=\"o\">)</span>\n<span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">and</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">toProp</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\">  </span><span class=\"n\">toProp</span><span class=\"w\"> </span><span class=\"n\">q</span>\n<span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">or</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\">  </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">toProp</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">toProp</span><span class=\"w\"> </span><span class=\"n\">q</span>\n<span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">implies</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">toProp</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">toProp</span><span class=\"w\"> </span><span class=\"n\">q</span>\n<span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">uQuant</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">toProp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">))</span>\n<span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">eQuant</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">toProp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>This works but in the opposite direction form what I was hoping for. I wanted to derive an inductive expression from a Prop. Is this forbidden for consistency reasons? Like is there something unsound about having a Prop imply something about types in higher universes? </p>\n<p>I'm trying to understand the principle behind why Prop works this way in Lean.</p>",
        "id": 470804568,
        "sender_full_name": "Avi Craimer",
        "timestamp": 1726539869
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"346046\">Avi Craimer</span> <a href=\"#narrow/stream/113488-general/topic/Pattern.20match.20against.20a.20Prop.3F/near/470780705\">said</a>:</p>\n<blockquote>\n<p>Thanks. If I wanted to try the metaprogramming route how to I convert a Prop into an Expr object?</p>\n</blockquote>\n<p>When writing metaprograms such as tactics, you don't need to convert the Prop you are given to an Expr because the metaprogram doesn't receive a Prop in the first place, it receives the Expr representing that Prop. The goal, the arguments, the hypotheses - everything is either Syntax or Expr already</p>",
        "id": 470807289,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726540553
    },
    {
        "content": "<p>Regarding your question: Prop has a bunch of properties that imply that it has exactly two elements up to equality. For example <code>(p /\\ q) = (q /\\ p)</code> is a provable theorem, but this is very problematic if you would like to have a function that maps the first object to <code>T.and (f p) (f q)</code> and the second to <code>T.and (f q) (f p)</code> since every function must take equal values to equal values</p>",
        "id": 470808370,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726540797
    },
    {
        "content": "<p>Ah, okay, so it has to do with the two-value thing. I find it very confusing honestly since in many ways when working with theorems it seems that Prop has lots of values, but then I guess they all reduce to just True and False. </p>\n<p>What I still don't understand is this.  Somehow internally Lean is keeping track of the difference between different proposition expression otherwise it wouldn't even be possible to print p ∧ q differently than q ∧ p. So what is the pretty printer using to generate the string?</p>",
        "id": 470810361,
        "sender_full_name": "Avi Craimer",
        "timestamp": 1726541233
    },
    {
        "content": "<p>like I said, in the metaprogramming world there isn't a Prop in sight, only Exprs representing Props</p>",
        "id": 470810515,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726541275
    },
    {
        "content": "<p>You can produce elements of custom types using code evaluation but there is no reason to ever do that for Prop because it has no computational content. So metaprograms exclusively work with Expr here</p>",
        "id": 470810806,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726541341
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Pattern.20match.20against.20a.20Prop.3F/near/470810515\">said</a>:</p>\n<blockquote>\n<p>like I said, in the metaprogramming world there isn't a Prop in sight, only Exprs representing Props</p>\n</blockquote>\n<p>I guess I'm asking about how it is possible for an Expr to <em>represent</em> a Prop?  </p>\n<p>My question can be restated as this: when I'm using Lean interactively and I see my defined element or Prop being printed in the Tactics state as anything other than True or False,  how is this representation programmatically generated from the proposition I defined?  In the theory you've laid out it sounds like any Prop I define is always and automatically defining one of two values. So representing more than two props would require a computational connection between Prop definitions and values of Expr?  </p>\n<p>Is it that when the user defines  Prop at the object level they are simultaneously defining an Expr at the meta level?<br>\n[Edit: Based on what I can infer from Mario's answers below, something like the above is indeed what is going on]</p>\n<p>If so, my question becomes, is it possible to access the meta-level representation of a Prop from within an ordinary program?</p>\n<p>I should add that I know almost nothing about metaprogramming in Lean <span aria-label=\"dotted line face\" class=\"emoji emoji-1fae5\" role=\"img\" title=\"dotted line face\">:dotted_line_face:</span></p>",
        "id": 470813581,
        "sender_full_name": "Avi Craimer",
        "timestamp": 1726541955
    },
    {
        "content": "<p>when you see <code>p /\\ q</code> in the tactic state, in the computer it is actually some expr like <code>.app (.app (.const `And []) p) q</code></p>",
        "id": 470815085,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726542322
    },
    {
        "content": "<p>the sense in which this an Expr that represents a prop is that if you call that expression <code>e</code> then calling <code>inferType e</code> will return <code>.const `Prop []</code>, which is the expr representing <code>Prop</code></p>",
        "id": 470815353,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726542417
    },
    {
        "content": "<p>I think you need to <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> a bit and talk about what is going to call your function, how will it be used and why does it need this information</p>",
        "id": 470815868,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726542535
    },
    {
        "content": "<p>I read the article you linked to. I'm getting the message that you'd rather I stop asking more follow up questions so I will. I'll just say that at this point I don't think my follow ups were about any proposed solution, just trying to understand how things work. Your answers are a bit cryptic.</p>",
        "id": 470816346,
        "sender_full_name": "Avi Craimer",
        "timestamp": 1726542650
    },
    {
        "content": "<p>No I'm not asking you to stop asking follow up questions, I'm asking you to dig into the reasons that lead you to think that you want a function out of Prop because I'm sure that's not actually what your goal is (it's solution oriented, not problem oriented)</p>",
        "id": 470816660,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726542720
    },
    {
        "content": "<p>The answer to your <em>direct</em> question is no, as Kim said, but the more <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> style answer is \"you must be confused about something because you shouldn't be in this situation in the first place\"</p>",
        "id": 470817347,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726542848
    },
    {
        "content": "<p>I'll do my best to describe my problem. </p>\n<p>I am building a library for the Relational Calculus. I'm trying to prove that a logic defined in terms of the calculus is inter-expressible with at least a part of the logic of propositions in Lean. I know that the proper way do to this is probably to define some kind of object level type that represents the predicate logic I'm interested in and then prove a relationship between this and the relational calculus. However, doing so appears to be beyond my skill at this time. Even understanding the Mathlib4 modules for Logic and ModelTheory are beyond me. I thought it might be nice and simple I could just deconstruct and reconstruct Lean propositions in terms of their structure.</p>",
        "id": 470818531,
        "sender_full_name": "Avi Craimer",
        "timestamp": 1726543128
    },
    {
        "content": "<p>I see. In that case I will come closer to Kim's answer again: this is not a metaprogramming activity, you really do want to pattern match on object level propositions and this cannot be done. You basically have one deeply embedded logic (the relational calculus) and one shallowly embedded logic (lean's Prop) and you want to relate them with a theorem. You can relate them with a metaprogram, but to do so with a theorem in lean you need both sides to be deeply embedded, and this is what Logic and ModelTheory are about</p>",
        "id": 470819536,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726543507
    },
    {
        "content": "<p>But you can probably simplify things by defining your own version of propositional logic or first order logic if that's what you want</p>",
        "id": 470819670,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726543541
    },
    {
        "content": "<p>Thanks for taking the time to answer my questions. </p>\n<p>While I understand that it won't solve my problem,  after this conversation, I'm very curious to now how the <code>Expr</code> that represents a <code>Prop</code> is generated. </p>\n<p>i.e., something like what you wrote above as:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"ss\">`And</span><span class=\"w\"> </span><span class=\"o\">[])</span>\n</code></pre></div>",
        "id": 470820460,
        "sender_full_name": "Avi Craimer",
        "timestamp": 1726543743
    },
    {
        "content": "<p>it's produced by the elaborator based on the syntax <code>p /\\ q</code>, which is produced by the parser</p>",
        "id": 470857440,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726545823
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"346046\">Avi Craimer</span> has marked this topic as resolved.</p>",
        "id": 470858251,
        "sender_full_name": "Notification Bot",
        "timestamp": 1726545984
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/.E2.9C.94.20Pattern.20match.20against.20a.20Prop.3F/near/470808370\">said</a>:</p>\n<blockquote>\n<p>Prop has a bunch of properties that imply that it has exactly two elements up to equality</p>\n</blockquote>\n<p>i'm not sure that the interpretation of <code>Prop</code> as only having 2 possible values is quite right? i think you could argue any independent proposition is its own value?</p>",
        "id": 470900070,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1726559904
    },
    {
        "content": "<p>Nope, every <code>Prop</code> is either inhabited or empty. All the inhabited <code>Prop</code>s are equal, and all the uninhabited <code>Prop</code>s are equal.</p>",
        "id": 470902536,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1726560322
    },
    {
        "content": "<p>e.g. <code>(7=3)=(2=1) </code> (because both <code>7=3</code> and <code>2=1</code> are uninhabited), while <code>FLT=(37=37)</code>, because <code>FLT</code> and <code>37=37</code> both admit a proof.</p>",
        "id": 470903059,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1726560401
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"684366\">@Edward van de Meent</span> If someone gave you a term of type <code>Equiv Bool Prop</code>, do you think that would imply that <code>Prop</code> has exactly two elements?</p>",
        "id": 470906759,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1726561221
    },
    {
        "content": "<p>it seems i forgot the meaning of \"excluded middle\" <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 470910880,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1726562549
    },
    {
        "content": "<p>Even intuitionistically <code>Prop</code> doesn’t have any third (or more) possible value</p>",
        "id": 470936680,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1726568141
    },
    {
        "content": "<p>Intuitionistically, <code>Prop</code> also doesn't <em>not</em> have a third possible value though, right?</p>",
        "id": 470947993,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1726571430
    },
    {
        "content": "<p>Why should there not be some sort of <code>Independent:Prop</code> value?</p>",
        "id": 470949611,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1726571876
    },
    {
        "content": "<p>(not necessarily unique)</p>",
        "id": 470949708,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1726571896
    },
    {
        "content": "<p>If I were to add <code>axiom P:Prop</code>, because you can't prove it equal to True nor equal to False, it might as well be a third value, no?</p>",
        "id": 470950421,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1726572098
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/.E2.9C.94.20Pattern.20match.20against.20a.20Prop.3F/near/470947993\">said</a>:</p>\n<blockquote>\n<p>Intuitionistically, <code>Prop</code> also doesn't <em>not</em> have a third possible value though, right?</p>\n</blockquote>\n<p>No, it <em>does not</em> have a third possible value. Prop having 3 or more elements implies false, intuitionistically</p>",
        "id": 470951067,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726572300
    },
    {
        "content": "<p>if you try to write down what it means for a proposition to not be true and not be false you've already stated a contradiction</p>",
        "id": 470951238,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726572348
    },
    {
        "content": "<p>however, what you can't say is that intutitionistic logic has two truth values. It just doesn't have anything other than 2 truth values</p>",
        "id": 470951558,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726572428
    },
    {
        "content": "<p>if you consider \"not being equal\" different from mathlibs \"≠\", but rather \"there is no proof that these are equal\", it is consistent. (for example, you would have <code>(P = True) = P</code> rather than <code>(P = True) = True</code> or <code>(P = True) = False</code>)</p>",
        "id": 470959306,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1726574601
    },
    {
        "content": "<p>that's true even in classical logic though</p>",
        "id": 470964535,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726576175
    },
    {
        "content": "<p>so depending on how you count, <code>Prop</code> can have more values than 2?</p>",
        "id": 470964964,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1726576280
    },
    {
        "content": "<p>the quotient of formulas by provable equivalence is almost certainly countably infinite</p>",
        "id": 470967818,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726577040
    },
    {
        "content": "<p>i feel like that would be a consequence of gödel's incompleteness theorem...</p>",
        "id": 470968254,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1726577157
    },
    {
        "content": "<p>indeed, although applied directly it only gives you one value</p>",
        "id": 470968410,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726577193
    },
    {
        "content": "<p>in lean you can cheat and use any of the easy independent statements like <code>Nat = Int</code></p>",
        "id": 470968523,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726577227
    },
    {
        "content": "<p>e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>for each <code>i</code>, <code>phi i := Foo i = Nat</code> is an independent proposition and equality of any two of them is also independent</p>",
        "id": 470968856,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726577313
    },
    {
        "content": "<p>I was thinking about this yesterday... Can't boolean logic be modeled by any boolean lattice? And, can't boolean lattices have more than two elements?</p>",
        "id": 471105260,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726610352
    },
    {
        "content": "<p>I imagine there's a difference between propositions being equivalent (and thus equal by <code>propeq</code>), and actually being equal elements of the model.</p>",
        "id": 471105351,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726610386
    },
    {
        "content": "<p>I think you can have both equivalence and equality be the same, and also have a large boolean lattice, but you have to use an appropriate interpretation of LEM. For example, <code>Set A</code> is a boolean lattice, which we might think of here as a set of parallel worlds in which a given proposition is independently true or false. Then <code>p \\/ !p</code> is saying that in every world, either <code>p</code> or <code>!p</code> holds, but it doesn't have to be the same one uniformly across all worlds. <code>p = q</code> says that <code>p</code> and <code>q</code> are equivalent in every world, so <code>propext</code> is satisfied and model equality agrees with propositional equality/bi-implication, but <code>p = true \\/ p = false</code> does not mean there are only two propositions, only that in every world, <code>p</code> is equivalent to either <code>true</code> or <code>false</code></p>",
        "id": 471111175,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726612524
    }
]