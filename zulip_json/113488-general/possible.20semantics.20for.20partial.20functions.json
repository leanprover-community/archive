[
    {
        "content": "<p>I know that <code>partial def</code> is currently opaque, so it cannot be reasoned about but I was recently thinking if it could be defined. I had two ideas but I will not be surprised if it was already discussed somewhere.</p>",
        "id": 562306839,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1765111932
    },
    {
        "content": "<ol>\n<li>Using <code>Acc</code> on possible inputs, we evaluate the function if there is no infinite decreasing chain of inputs in the argument, otherwise <code>Classical.choice</code>.</li>\n</ol>\n<p>Pros &amp; cons:</p>\n<ul>\n<li><span aria-label=\"check\" class=\"emoji emoji-2705\" role=\"img\" title=\"check\">:check:</span> very close to how well-founded recursion is defined</li>\n<li><span aria-label=\"cross mark\" class=\"emoji emoji-274c\" role=\"img\" title=\"cross mark\">:cross_mark:</span> requires to know in advance which inputs we recurse on</li>\n<li><span aria-label=\"cross mark\" class=\"emoji emoji-274c\" role=\"img\" title=\"cross mark\">:cross_mark:</span> context-sensitive, even functions that terminate in practice (e.g. because of short-circuit evaluation) could be marked as non-terminating</li>\n</ul>\n<p>Code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Semantics for a function defined by</span>\n<span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">partFunc1_eval</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">In</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">In</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">rin</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">input</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">In</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"n\">input</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">In</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">recurse</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">input</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">In</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"n\">input</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">In</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">input</span><span class=\"w\"> </span><span class=\"bp\">↦</span>\n<span class=\"w\">    </span><span class=\"n\">recurse</span><span class=\"w\"> </span><span class=\"n\">input</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">partFunc1_eval</span><span class=\"w\"> </span><span class=\"n\">rin</span><span class=\"w\"> </span><span class=\"n\">recurse</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">rin</span><span class=\"w\"> </span><span class=\"n\">input</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- could be:</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">noncomputable</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">partFunc1</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">In</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">In</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">rin</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">input</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">In</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"n\">input</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">In</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">recurse</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">input</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">In</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"n\">input</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">In</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">in1</span><span class=\"w\"> </span><span class=\"n\">in2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">In</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"n\">in2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rin</span><span class=\"w\"> </span><span class=\"n\">in2</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">in1</span>\n<span class=\"w\">  </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">input</span><span class=\"w\"> </span><span class=\"bp\">↦</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">hcomp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Acc</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">input</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">hcomp</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"o\">(</span>\n<span class=\"w\">      </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">input</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">rec_out</span><span class=\"w\"> </span><span class=\"bp\">↦</span>\n<span class=\"w\">        </span><span class=\"n\">recurse</span><span class=\"w\"> </span><span class=\"n\">input</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">rec_out</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rin</span><span class=\"w\"> </span><span class=\"n\">input</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"bp\">⟩</span>\n<span class=\"w\">    </span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">choice</span><span class=\"w\"> </span><span class=\"n\">inferInstance</span>\n</code></pre></div>",
        "id": 562306852,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1765111951
    },
    {
        "content": "<ol start=\"2\">\n<li>Using uniqueness, a function will have a particular value if it is the only value that makes sense.</li>\n</ol>\n<p>Pros &amp; cons:</p>\n<ul>\n<li><span aria-label=\"check\" class=\"emoji emoji-2705\" role=\"img\" title=\"check\">:check:</span> general, its answer will match any reasonable evaluation, even with short-circuit evaluation, recursion with higher-order function...</li>\n<li><span aria-label=\"cross mark\" class=\"emoji emoji-274c\" role=\"img\" title=\"cross mark\">:cross_mark:</span> highly uncomputable, even if we know the partial function has a fixed value, we cannot build a computable provably terminating function calculating it</li>\n</ul>\n<p>Code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Defining semantics for a function defined by</span>\n<span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">partFunc2_eval</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">In</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">recurse</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">In</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">In</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">In</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">recurse</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">partFunc2_eval</span><span class=\"w\"> </span><span class=\"n\">recurse</span><span class=\"o\">)</span>\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">Predicate `Fixes recurse input output` means that `output` is the only possible</span>\n<span class=\"cm\">result for the given `input`.</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Fixes</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">In</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">recurse</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">In</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">In</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">In</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mk</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">part</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">In</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- a partial evaluation which agrees with `Fixes`</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hpart</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">in2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">In</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">out2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">part</span><span class=\"w\"> </span><span class=\"n\">in2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">out2</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">    </span><span class=\"n\">Fixes</span><span class=\"w\"> </span><span class=\"n\">recurse</span><span class=\"w\"> </span><span class=\"n\">in2</span><span class=\"w\"> </span><span class=\"n\">out2</span>\n<span class=\"w\">  </span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">input</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">In</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">out</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- forces the new pair to be fixed too</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hfix</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">In</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"o\">,</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">in2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">In</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">part</span><span class=\"w\"> </span><span class=\"n\">in2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">in2</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">part</span><span class=\"w\"> </span><span class=\"n\">in2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">      </span><span class=\"n\">recurse</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">input</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">out</span>\n<span class=\"w\">  </span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fixes</span><span class=\"w\"> </span><span class=\"n\">recurse</span><span class=\"w\"> </span><span class=\"n\">input</span><span class=\"w\"> </span><span class=\"n\">out</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">noncomputable</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">partFunc2</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">In</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">recurse</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">In</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">In</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">In</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">input</span><span class=\"w\"> </span><span class=\"bp\">↦</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">out</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Fixes</span><span class=\"w\"> </span><span class=\"n\">recurse</span><span class=\"w\"> </span><span class=\"n\">input</span><span class=\"w\"> </span><span class=\"n\">out</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">choose</span>\n<span class=\"w\">  </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">choice</span><span class=\"w\"> </span><span class=\"n\">inferInstance</span>\n</code></pre></div>",
        "id": 562306878,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1765111978
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek Olšák</span> <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/562306852\">said</a>:</p>\n<blockquote>\n<ul>\n<li><span aria-label=\"cross mark\" class=\"emoji emoji-274c\" role=\"img\" title=\"cross mark\">:cross_mark:</span> requires to know in advance which inputs we recurse on</li>\n</ul>\n</blockquote>\n<p>Can you recurse on all the inputs at once?</p>",
        "id": 562306903,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765112024
    },
    {
        "content": "<p>I mean something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">/</span><span class=\"mi\">2</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>so I don't know what the input for the outer call will be before I know how to evaluate <code>f</code> on <code>x/2</code></p>",
        "id": 562306974,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1765112159
    },
    {
        "content": "<p>Actually, I like the option 2 more -- it provides enough space for people inventing computational tricks while still being consistent, and being non-computable is still much better than being undefined (opaque). Only that proving things about it is quite tricky -- I tried to prove that it is in fact unique, and I am getting lost in induction...</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">In</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">recurse</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">In</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">In</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"o\">)}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">input</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">In</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">out1</span><span class=\"w\"> </span><span class=\"n\">out2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fixes</span><span class=\"w\"> </span><span class=\"n\">recurse</span><span class=\"w\"> </span><span class=\"n\">input</span><span class=\"w\"> </span><span class=\"n\">out1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fixes</span><span class=\"w\"> </span><span class=\"n\">recurse</span><span class=\"w\"> </span><span class=\"n\">input</span><span class=\"w\"> </span><span class=\"n\">out2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">out1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">out2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">classical</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"n\">generalizing</span><span class=\"w\"> </span><span class=\"n\">out2</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">part1</span><span class=\"w\"> </span><span class=\"n\">hpart1</span><span class=\"w\"> </span><span class=\"n\">input</span><span class=\"w\"> </span><span class=\"n\">out1</span><span class=\"w\"> </span><span class=\"n\">hfix1</span><span class=\"w\"> </span><span class=\"n\">ih1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"n\">generalizing</span><span class=\"w\"> </span><span class=\"n\">out1</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">part2</span><span class=\"w\"> </span><span class=\"n\">hpart2</span><span class=\"w\"> </span><span class=\"n\">input</span><span class=\"w\"> </span><span class=\"n\">out2</span><span class=\"w\"> </span><span class=\"n\">hfix2</span><span class=\"w\"> </span><span class=\"n\">ih2</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">In</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">        </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">hex1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">part1</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">hex1</span><span class=\"bp\">.</span><span class=\"n\">choose</span>\n<span class=\"w\">        </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">hex2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">part2</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">hex2</span><span class=\"bp\">.</span><span class=\"n\">choose</span>\n<span class=\"w\">        </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">choice</span><span class=\"w\"> </span><span class=\"n\">inferInstance</span>\n<span class=\"w\">      </span><span class=\"n\">specialize</span><span class=\"w\"> </span><span class=\"n\">hfix1</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"w\">      </span><span class=\"n\">specialize</span><span class=\"w\"> </span><span class=\"n\">hfix2</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"w\">      </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">hfix1</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">hfix2</span>\n<span class=\"w\">        </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"c1\">-- the induction assumptions here might be insufficient...</span>\n<span class=\"w\">      </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 562315181,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1765121158
    },
    {
        "content": "<p>Here is a claim that I believe should be provable, and makes option 2 looking more computable. Maybe, I will get to proving it one day. It says that you can always emulate that semantics with an <code>Acc</code> based function as long as you modify the code of <code>recurse</code> a bit, and add a dependent restriction on the output.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">In</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">recurse</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">In</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">In</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">input</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">In</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">output</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fixes</span><span class=\"w\"> </span><span class=\"n\">recurse</span><span class=\"w\"> </span><span class=\"n\">input</span><span class=\"w\"> </span><span class=\"n\">output</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"o\">(</span>\n<span class=\"w\">      </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">In</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">In</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">In</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">recurse'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">In</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">        </span><span class=\"o\">((</span><span class=\"n\">x2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">In</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">x2</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">x2</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">        </span><span class=\"o\">{</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">})</span>\n<span class=\"w\">        </span><span class=\"o\">(</span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Acc</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">input</span><span class=\"o\">),</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">In</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">In</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">In</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">x2</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">x2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x2</span><span class=\"o\">)),</span>\n<span class=\"w\">        </span><span class=\"o\">(</span><span class=\"n\">recurse'</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x2</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">x2</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"bp\">⟩</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">recurse</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">      </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∧</span>\n<span class=\"w\">      </span><span class=\"n\">output</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">acc</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">})</span>\n<span class=\"w\">        </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">recurse'</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">val</span>\n<span class=\"w\">    </span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 562372019,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1765153717
    },
    {
        "content": "<p>I realized that due to lazy evaluation, there are still some cases that Option 2 does not capture, such as:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">partial</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">native_decide</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"w\"> </span><span class=\"o\">()</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">native_decide</span>\n</code></pre></div>",
        "id": 562622495,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1765268954
    },
    {
        "content": "<p>Deleted: doesn't work</p>",
        "id": 562622649,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1765269006
    },
    {
        "content": "<p>Deleted: doesn't work</p>",
        "id": 562633351,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1765272279
    },
    {
        "content": "<p>Ok, fully faithful semantics for partial functions doesn't exist. Trusting <code>native_decide</code> with <code>partial def</code>, leads to the existence of nonstandard natural numbers! <span aria-label=\"exploding head\" class=\"emoji emoji-1f92f\" role=\"img\" title=\"exploding head\">:exploding_head:</span> .</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">LazyNat</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">LazyNat</span><span class=\"o\">)</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Nonempty</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">LazyNat</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LazyNat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">())</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"bp\">+</span><span class=\"mi\">1</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">gtNat</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LazyNat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">false</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">())</span><span class=\"bp\">.</span><span class=\"n\">gtNat</span><span class=\"w\"> </span><span class=\"n\">b</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">gtNat_iff</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LazyNat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">gtNat</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">generalizing</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">gtNat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">toNat</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">gtNat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">toNat</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">gtNat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">toNat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"o\">]</span>\n\n<span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">nonstandard</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LazyNat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">nonstandard</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">LazyNat</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">big</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">LazyNat</span><span class=\"bp\">.</span><span class=\"n\">nonstandard</span><span class=\"w\"> </span><span class=\"o\">())</span><span class=\"bp\">.</span><span class=\"n\">toNat</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">big</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">LazyNat</span><span class=\"bp\">.</span><span class=\"n\">gtNat_iff</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">native_decide</span><span class=\"o\">)</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">big</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">LazyNat</span><span class=\"bp\">.</span><span class=\"n\">gtNat_iff</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">native_decide</span><span class=\"o\">)</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">big</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">LazyNat</span><span class=\"bp\">.</span><span class=\"n\">gtNat_iff</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">native_decide</span><span class=\"o\">)</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">big</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">LazyNat</span><span class=\"bp\">.</span><span class=\"n\">gtNat_iff</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">native_decide</span><span class=\"o\">)</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">big</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">LazyNat</span><span class=\"bp\">.</span><span class=\"n\">gtNat_iff</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">native_decide</span><span class=\"o\">)</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">big</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">50</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">LazyNat</span><span class=\"bp\">.</span><span class=\"n\">gtNat_iff</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">native_decide</span><span class=\"o\">)</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">big</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">100</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">LazyNat</span><span class=\"bp\">.</span><span class=\"n\">gtNat_iff</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">native_decide</span><span class=\"o\">)</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">big</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">1000</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">LazyNat</span><span class=\"bp\">.</span><span class=\"n\">gtNat_iff</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">native_decide</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 562681988,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1765286380
    },
    {
        "content": "<p>Well, once we have a nonstandard natural number <code>big : Nat</code>, then this should be at least an eval-consistent interpretation of <code>partial def</code> , right?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">partFunc3</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">In</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">recurse</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">In</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">In</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">In</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">big</span><span class=\"bp\">.</span><span class=\"n\">iterate</span><span class=\"w\"> </span><span class=\"n\">recurse</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">choice</span><span class=\"w\"> </span><span class=\"n\">inferInstance</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Only it is quite bad for reasoning as we don't know exactly how big <code>big</code> is. Then I was thinking of a combination</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">noncomputable</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">partFunc3'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">In</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">recurse</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">In</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">In</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">In</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">input</span><span class=\"w\"> </span><span class=\"bp\">↦</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">out</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Fixes</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">big</span><span class=\"bp\">.</span><span class=\"n\">iterate</span><span class=\"w\"> </span><span class=\"n\">recurse</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">input</span><span class=\"w\"> </span><span class=\"n\">out</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">choose</span>\n<span class=\"w\">  </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">big</span><span class=\"bp\">.</span><span class=\"n\">iterate</span><span class=\"w\"> </span><span class=\"n\">recurse</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">choice</span><span class=\"w\"> </span><span class=\"n\">inferInstance</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">input</span>\n</code></pre></div>\n<p>but that feels a little overcombined...</p>",
        "id": 562830687,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1765326604
    },
    {
        "content": "<p>There was some discussion over on <a class=\"message-link\" href=\"/#narrow/channel/270676-lean4/topic/Extrinsic.20termination.20proofs.20for.20well-founded.20recursion/near/524144154\">#lean4 &gt; Extrinsic termination proofs for well-founded recursion @ 💬</a>. Also, regarding the <code>native_decide</code> semantics: You can only ever observe a finite part of the value, so I believe it is sound to view as having as much depth as has been observed. Also, you should probably make sure that you use <code>opaque</code> instead of <code>Classical.choice</code> since otherwise all non-terminating inputs would produce the same output.</p>",
        "id": 563341453,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1765524133
    },
    {
        "content": "<p>Thanks for the link, I am curious if the <code>Myopic.Fixpoint</code> is equivalent to my proposal. Also Mario confirmed there that the intended semantics for <code>partial</code> is  to repeat <code>big</code>-times.</p>",
        "id": 563435903,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1765533915
    },
    {
        "content": "<p>Regarding <code>opaque</code>, I originally wanted it to be more explicit, ideally I would even take the <code>default</code>. For example, <code>∑' n : ℕ, 1</code> is also defined to be zero, and not something non-standardly large... Unfortunatelly, that wish seems inconsistent with the computation model.</p>",
        "id": 563439050,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1765534964
    },
    {
        "content": "<p><code>Myopic.Fixpoint</code> also uses nonempty choice: <a href=\"https://codeberg.org/preichert/lean-extrinsic-termination-proofs/src/branch/main/Myopic/Fixpoint.lean#L33-L34\">https://codeberg.org/preichert/lean-extrinsic-termination-proofs/src/branch/main/Myopic/Fixpoint.lean#L33-L34</a></p>",
        "id": 563447958,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1765537572
    },
    {
        "content": "<p>Actually, I think your <code>Terminates</code> in that thread is straightforwardly equivalent to my <code>Fixes</code>, whereas the solution by <span class=\"user-mention\" data-user-id=\"221653\">@Paul Reichert</span> is more general. But even there, there are still examples that can be computed but cannot be captured with the logic.</p>",
        "id": 563451303,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1765538672
    },
    {
        "content": "<p>For example this value cannot be proven with <code>Myopic.Fixpoint</code> (it can with <code>native decide</code> because it opts out for the default interpretation). On the other hand, I agree there is probably no reasonable model to handle these cases with forced non-standard values</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"mi\">42</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"w\"> </span><span class=\"o\">()</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"c1\">-- 42</span>\n</code></pre></div>",
        "id": 563452757,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1765539172
    },
    {
        "content": "<p>I'm not sure this is impossible for Myopic, although I haven't tried. What made you think it's impossible?</p>\n<p>Regarding Myopic, it's very general, but is a bit dangerous. The intendes semantics I mentioned are  not guaranteed by the compiler as of now (although I do not know of counterexamples), and future optimizations might violate it.</p>",
        "id": 563458692,
        "sender_full_name": "Paul Reichert",
        "timestamp": 1765541215
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek Olšák</span> <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/563447958\">said</a>:</p>\n<blockquote>\n<p><code>Myopic.Fixpoint</code> also uses nonempty choice: <a href=\"https://codeberg.org/preichert/lean-extrinsic-termination-proofs/src/branch/main/Myopic/Fixpoint.lean#L33-L34\">https://codeberg.org/preichert/lean-extrinsic-termination-proofs/src/branch/main/Myopic/Fixpoint.lean#L33-L34</a></p>\n</blockquote>\n<p>This usage of choice is of a different kind. The opaque use in the fixpoint definition Robin Arnez mentioned is here, disguised as a partial function: <a href=\"https://codeberg.org/preichert/lean-extrinsic-termination-proofs/src/branch/main/Myopic/Fixpoint.lean#L50\">https://codeberg.org/preichert/lean-extrinsic-termination-proofs/src/branch/main/Myopic/Fixpoint.lean#L50</a></p>",
        "id": 563462064,
        "sender_full_name": "Paul Reichert",
        "timestamp": 1765542313
    },
    {
        "content": "<p>To my understanding, the value is chosen by choice if there is any plausible value for the value (which is in most undefined cases), and only opted out back to the opaque <code>partial def</code>, if the value is forced to not have any standard value.</p>",
        "id": 563463618,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1765542858
    },
    {
        "content": "<p>So I think in most cases where I would use choice, you would use choice too (perhaps with some value restriction).</p>",
        "id": 563463790,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1765542917
    },
    {
        "content": "<p>The example I wrote is a function that doesn't have any plausible value on the second coordinate.</p>",
        "id": 563463920,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1765542956
    },
    {
        "content": "<p>So your implementation just calls the opaque function on it, if I understand it correctly.</p>",
        "id": 563464232,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1765543065
    },
    {
        "content": "<p>It doesn't have any plausible value because one expansion step forces <code>(f 0).2 () &gt; 0</code>, two steps force <code>(f 0).2 () &gt; 1</code>, three steps force <code>(f 0).2 () &gt; 2</code> etc.</p>",
        "id": 563464577,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1765543191
    },
    {
        "content": "<p>Where do you see a risk of being incompatible with the compiler?</p>",
        "id": 563464844,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1765543287
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek Olšák</span> <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/563463618\">said</a>:</p>\n<blockquote>\n<p>To my understanding, the value is chosen by choice if there is any plausible value for the value (which is in most undefined cases), and only opted out back to the opaque <code>partial def</code>, if the value is forced to not have any standard value.</p>\n</blockquote>\n<p>Sorry, I misunderstood your code when I wrote my answer and agree that as long as <code>Fixes</code> provides unique values -- which it seems that it does -- using <code>choice</code> here seems fine.</p>",
        "id": 563571054,
        "sender_full_name": "Paul Reichert",
        "timestamp": 1765578503
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek Olšák</span> <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/563464577\">said</a>:</p>\n<blockquote>\n<p>It doesn't have any plausible value because one expansion step forces <code>(f 0).2 () &gt; 0</code>, two steps force <code>(f 0).2 () &gt; 1</code>, three steps force <code>(f 0).2 () &gt; 2</code> etc.</p>\n</blockquote>\n<p>And I think you're right on this one, too!</p>",
        "id": 563571274,
        "sender_full_name": "Paul Reichert",
        "timestamp": 1765578661
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek Olšák</span> <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/563464844\">said</a>:</p>\n<blockquote>\n<p>Where do you see a risk of being incompatible with the compiler?</p>\n</blockquote>\n<p>There are some optimizations (constant folding, for example, or dead code elimination) that might eliminate infinite loops and let the function return garbage values. I'm not an expert with this (just one more reason to be very careful...), so I can't give you a very good example, but it seems possible that</p>\n<ul>\n<li>the compiler replaces an infinite loop with a garbage value</li>\n<li>the function terminates according to Myopic or another framework and assigns a certain known value that is different from the garbage value.</li>\n</ul>\n<p>Also, note that Myopic doesn't distinguish fixpoint functionals (e.g., a function in <code>(α → α) → α → α</code> that is iterated in order to obtain the fixpoint) that are extensionally equal. So it is possible that the actual implementation makes a recursive call but discards its value. While this recursive call can cause infinite recursion, this useless recursive call cannot be recognized <em>extensionally</em> from the functional. This means that Myopic might conclude, in its own terms, that a function \"terminates\" while it actually doesn't. This is not a soundness problem, but it might still be undesirable.</p>",
        "id": 563572328,
        "sender_full_name": "Paul Reichert",
        "timestamp": 1765579338
    },
    {
        "content": "<p>those nonstandard natural numbers are really cool</p>\n<p>it's almost like a meta-soundness bug: we have a natural number that we know will be decided as greater than every other natural number individually by <code>native_decide</code>, yet we can't prove this in the type theory and the existence of this number is type-theoretically impossible</p>",
        "id": 563660275,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1765681718
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"380294\">Matt Diamond</span> <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/563660275\">said</a>:</p>\n<blockquote>\n<p>we have a natural number that we know will be decided as greater than every other natural number individually by <code>native_decide</code>,</p>\n</blockquote>\n<p>nit: we only know it will be decided as greater than every numeral, not \"every natural number\"</p>",
        "id": 563660685,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765682453
    },
    {
        "content": "<p>true... what's the significance of that distinction, though?</p>",
        "id": 563660804,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1765682684
    },
    {
        "content": "<p>(not denying there is one, just want to understand your point better)</p>",
        "id": 563660854,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1765682771
    },
    {
        "content": "<p>if we accept the existence of these nonstandard natural numbers</p>",
        "id": 563660989,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765683080
    },
    {
        "content": "<p>surely you aren't saying it will be decided as greater than itself</p>",
        "id": 563661005,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765683106
    },
    {
        "content": "<p>is that even a well-defined question anymore I don't think it terminates so it doesn't really decide the statement at all</p>",
        "id": 563661030,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765683161
    },
    {
        "content": "<blockquote>\n<p>surely you aren't saying it will be decided as greater than itself</p>\n</blockquote>\n<p>of course not, I said greater than every other number (with the implication of \"other than itself\")</p>",
        "id": 563661329,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1765683626
    },
    {
        "content": "<p>I'm not sure what you mean by \"I don't think it terminates\"</p>\n<p>the point is that you're able to run comparisons against every other natural number using <code>native_decide</code>, and those decisions terminate</p>\n<p>of course, the process of writing those down in a file doesn't terminate, but we know at a meta-level that it will always return <code>True</code> when asked if <code>big</code> is greater than some specific concrete natural number, and no natural number has that property, yet the type of <code>big</code> is <code>Nat</code></p>",
        "id": 563661450,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1765683859
    },
    {
        "content": "<p>I guess it's not surprising that weird things happen when you let <code>native_decide</code> pierce the opacity of a <code>partial</code> def</p>",
        "id": 563661674,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1765684233
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"380294\">Matt Diamond</span> <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/563661329\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>surely you aren't saying it will be decided as greater than itself</p>\n</blockquote>\n<p>of course not, I said greater than every other number (with the implication of \"other than itself\")</p>\n</blockquote>\n<p>surely you aren't saying it will be decided as greater than (itself + 1)</p>",
        "id": 563663813,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765687388
    },
    {
        "content": "<p>ah, I see your point... yes, <code>big</code> is provably less than <code>big + k</code>, so it's not greater than all other natural numbers</p>\n<p>what's actually weird here is that this would seem to give the numerals an order type that isn't the usual <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ω</mi></mrow><annotation encoding=\"application/x-tex\">\\omega</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span></span></span></span></p>",
        "id": 563664209,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1765687990
    },
    {
        "content": "<p>that what happens with nonstandard models</p>",
        "id": 563664336,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765688178
    },
    {
        "content": "<p>yes but the type <code>Nat</code> isn't supposed to be a nonstandard model, right? like you shouldn't be able to construct <code>big</code> using the available type constructors... I don't even know if Nat is well-founded with <code>big</code> in the mix</p>",
        "id": 563664396,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1765688301
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"380294\">Matt Diamond</span> <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/563664396\">said</a>:</p>\n<blockquote>\n<p>yes but the type <code>Nat</code> isn't supposed to be a nonstandard model, right?</p>\n</blockquote>\n<p>what do you mean?</p>",
        "id": 563664427,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765688362
    },
    {
        "content": "<p>why not?</p>",
        "id": 563664563,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765688456
    },
    {
        "content": "<p>how would you construct <code>big</code> using a finite sequence of applications of <code>zero</code> and <code>succ</code>?</p>",
        "id": 563664809,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1765688570
    },
    {
        "content": "<p>perhaps I have a misunderstanding re: inductive types</p>",
        "id": 563664853,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1765688645
    },
    {
        "content": "<p>also the non-well-foundedness is a bit weird (you can write a proof that <code>big - k &lt; big</code> for all individual non-zero numerals <code>k</code>)</p>",
        "id": 563664900,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1765688716
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"380294\">Matt Diamond</span> <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/563664809\">said</a>:</p>\n<blockquote>\n<p>how would you construct <code>big</code> using a finite sequence of applications of <code>zero</code> and <code>succ</code>?</p>\n</blockquote>\n<p>how would you define a nonstandard natural in PA?</p>",
        "id": 563664902,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765688724
    },
    {
        "content": "<p>I'm not sure how that's relevant to Lean... our version of <code>Nat</code> has a specific order type that I don't think these other nonstandard models share, and it's well-founded</p>",
        "id": 563665012,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1765688880
    },
    {
        "content": "<p>PA also shows the naturals are well founded</p>",
        "id": 563665024,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765688907
    },
    {
        "content": "<p>well it's a bit weird though since PA is first-order</p>",
        "id": 563665036,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765688935
    },
    {
        "content": "<p>yes but the naturals with <code>big</code> are not well-founded, and <code>Nat</code> is well-founded</p>",
        "id": 563665039,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1765688937
    },
    {
        "content": "<p>ok there are a few things that happen when you start to talk about proof systems</p>",
        "id": 563665073,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765688972
    },
    {
        "content": "<p>there are now two different versions of everything</p>",
        "id": 563665081,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765688983
    },
    {
        "content": "<p>okay</p>",
        "id": 563665098,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1765689009
    },
    {
        "content": "<p>the \"actual\" properties of the structures and the properties you express in the formal system</p>",
        "id": 563665112,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765689042
    },
    {
        "content": "<p>so if I'm talking about Lean, then implicitly I'm working in another formal system that's strong enough to formalize how Lean works</p>",
        "id": 563665136,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765689096
    },
    {
        "content": "<p>now we know that Lean proves that <code>Nat</code> is well founded</p>",
        "id": 563665187,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765689159
    },
    {
        "content": "<p>but assuming Lean is consistent there are models of Lean where the model's <code>Nat</code> is not well founded</p>",
        "id": 563665215,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765689223
    },
    {
        "content": "<p>so what's going on here is that the statement you proved in Lean does not correspond to the property you were trying to express</p>",
        "id": 563665242,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765689276
    },
    {
        "content": "<p>which statement, specifically</p>",
        "id": 563665270,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1765689343
    },
    {
        "content": "<p>the statement of WellFoundedLT Nat</p>",
        "id": 563665297,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765689390
    },
    {
        "content": "<p>so if <code>Nat</code> doesn't correspond to the actual natural numbers anymore I hope it makes sense that <code>WellFoundedLT</code> doesn't correspond to LT being well-founded anymore</p>",
        "id": 563665344,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765689496
    },
    {
        "content": "<p>okay so how do we know what model <code>Nat</code> is referring to at a given moment</p>",
        "id": 563665360,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1765689544
    },
    {
        "content": "<p>from the context?</p>",
        "id": 563665405,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765689615
    },
    {
        "content": "<p>like just talking about Lean doesn't imply a specific model of Lean's type theory that you're using right</p>",
        "id": 563665443,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765689681
    },
    {
        "content": "<p>or even that you're using any model at all</p>",
        "id": 563665545,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765689883
    },
    {
        "content": "<p>sorry, I'm just not getting this at all... I'm just trying to point out that you can prove <code>n &lt; big</code> for a seemingly infinite number of distinct numerals, and you can prove <code>big - n &lt; big</code> for a seemingly infinite number of distinct numerals, and if you could prove either of these as a lemma in Lean which generalized these facts from individual instances to actual complete infinite sets of Nats, then you would be able to derive False, and that seems interesting to me</p>",
        "id": 563665752,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1765690287
    },
    {
        "content": "<p>maybe I'm just missing some nuance here</p>",
        "id": 563665761,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1765690313
    },
    {
        "content": "<p>I'm not saying there's an actual soundness bug, I'm just saying it's an interesting case of <code>native_decide</code> leading to funny results that would seem to (but not actually) contradict other facts that we can prove in Lean about the order type of Nat</p>\n<p>in other words (adapting Mirek's code):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Order</span><span class=\"bp\">.</span><span class=\"n\">Interval</span><span class=\"bp\">.</span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">Nat</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">LazyNat</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">LazyNat</span><span class=\"o\">)</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Nonempty</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">LazyNat</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LazyNat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">())</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"bp\">+</span><span class=\"mi\">1</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">gtNat</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LazyNat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">false</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">())</span><span class=\"bp\">.</span><span class=\"n\">gtNat</span><span class=\"w\"> </span><span class=\"n\">b</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">geNat_iff</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LazyNat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">gtNat</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">generalizing</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">gtNat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">toNat</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">gtNat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">toNat</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">gtNat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">toNat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"o\">]</span>\n\n<span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">nonstandard</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LazyNat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">nonstandard</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">LazyNat</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">big</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">LazyNat</span><span class=\"bp\">.</span><span class=\"n\">nonstandard</span><span class=\"w\"> </span><span class=\"o\">())</span><span class=\"bp\">.</span><span class=\"n\">toNat</span>\n\n<span class=\"c1\">-- there is no infinite set where `big` is greater than all members</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">Infinite</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">big</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">S</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">S_inf</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hS</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">S_inf</span><span class=\"bp\">.</span><span class=\"n\">not_bddAbove</span>\n<span class=\"w\">  </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">big</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hS</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">le</span>\n\n<span class=\"c1\">-- and yet it seems like we could assemble such a set if we kept going here!</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">big</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">LazyNat</span><span class=\"bp\">.</span><span class=\"n\">geNat_iff</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">native_decide</span><span class=\"o\">)</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">big</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">LazyNat</span><span class=\"bp\">.</span><span class=\"n\">geNat_iff</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">native_decide</span><span class=\"o\">)</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">big</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">LazyNat</span><span class=\"bp\">.</span><span class=\"n\">geNat_iff</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">native_decide</span><span class=\"o\">)</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">big</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">LazyNat</span><span class=\"bp\">.</span><span class=\"n\">geNat_iff</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">native_decide</span><span class=\"o\">)</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">big</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">50</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">LazyNat</span><span class=\"bp\">.</span><span class=\"n\">geNat_iff</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">native_decide</span><span class=\"o\">)</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">big</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">100</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">LazyNat</span><span class=\"bp\">.</span><span class=\"n\">geNat_iff</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">native_decide</span><span class=\"o\">)</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">big</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">1000</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">LazyNat</span><span class=\"bp\">.</span><span class=\"n\">geNat_iff</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">native_decide</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 563665919,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1765690587
    },
    {
        "content": "<p>This is all a bit confusing because we seem to be conflating \"in first order logic there are nonstandard models of the naturals\" with \"in Lean if you assume unsound axioms you can prove whatever you like\". </p>\n<p>In first order logic, you only have access to the principle of induction for predicates which you can write down in a certain first order language, and \"I am a numeral\" is not one of those predicates.</p>\n<p>In Lean, which uses higher order logic, you can prove that <code>Nat</code> is the standard model of the naturals, and you can also use <code>partial def</code> and <code>Lean.ofReduceBool</code> and <code>Lean.trustCompiler</code> to prove False.</p>",
        "id": 563688744,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1765718170
    },
    {
        "content": "<p>I am really pleased to have sparked such a lively discussion but I had the impression that both <span class=\"user-mention\" data-user-id=\"816344\">@Aaron Liu</span>  and <span class=\"user-mention\" data-user-id=\"380294\">@Matt Diamond</span> understand what is going on, and just argue about how to call it, and <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>'s  comment (sorry) is rather confusing.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/563688744\">said</a>:</p>\n<blockquote>\n<p>This is all a bit confusing because we seem to be conflating \"in first order logic there are nonstandard models of the naturals\" with \"in Lean if you assume unsound axioms you can prove whatever you like\". </p>\n</blockquote>\n<p>In principle, nonstandard numbers do not have to be limited to a specific logic. It is a general concept that we assume an existence of a number <code>big</code> that is guaranteed to be bigger than all the numbers expressed with an expression <code>1+1+1+...+1</code> for any number of ones in that expression (I would call it a \"standard number\" some call it a \"numeral\", just a matter of terminology). However we are only able to only get one such inequality at a time, so this cannot introduce contradiction.</p>\n<blockquote>\n<p>In Lean, which uses higher order logic, you can prove that <code>Nat</code> is the standard model of the naturals, and you can also use <code>partial def</code> and <code>Lean.ofReduceBool</code> and <code>Lean.trustCompiler</code> to prove False.</p>\n</blockquote>\n<p>I think this is conflating the insane strength of <code>Lean.ofReduceBool</code> with what we are discussing here. You can proof <code>False</code> from <code>native_decide</code> by cheating with <code>implemented_by</code>, and for example defining <code>true</code> implemented by <code>false</code>. I don't think that <code>native_decide</code> would be considered conceptually inconsistent as long as we are very careful about all <code>implemented_by</code>.</p>\n<p>On the other hand, what I showed with <code>big</code> is that if we want to model Lean together with a <code>native_decide</code> (and do not want to impose artificial hardware bounds), we have to put a nonstandard natural number into such model. So we cannot just say <code>Type</code> is a model of Lean's <code>Type</code>. We would have to do some nonstandard extension with ultraproduct, or completeness... (I expect it would probably have to go through first order)</p>",
        "id": 563691972,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1765721745
    },
    {
        "content": "<p>So you're saying that \"nonstandard model\" makes sense outside of first order logic?</p>",
        "id": 563693522,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1765723451
    },
    {
        "content": "<p>if it contains something nonstandard then I think it's fair to call it a nonstandard model</p>",
        "id": 563693565,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765723528
    },
    {
        "content": "<p>Depending of what we call first order. For example in second order logic, we might want to model the theory's \"all functions\" with all functions in reality (whatever reality means), then non-standard models do not make sense. On the other hand, if we allow the model to omit some functions, we are essentially back in the first order setup, even if we have some structure on top of it.</p>",
        "id": 563693761,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1765723821
    },
    {
        "content": "<p>So if I write <code>axiom n : Nat</code> and <code>axiom hn : forall a, a &lt; n</code> then suddenly <code>Nat</code> becomes \"nonstandard\"? I thought that \"nonstandard model\" had a well-defined meaning in first order logic and that there was some confusion applying it in other contexts, which was why I interjected.</p>",
        "id": 563693817,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1765723911
    },
    {
        "content": "<p>no it becomes unsound</p>",
        "id": 563693828,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765723924
    },
    {
        "content": "<p>Sure</p>",
        "id": 563693835,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1765723933
    },
    {
        "content": "<p>But Nat itself didn't change, is my point</p>",
        "id": 563693846,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1765723952
    },
    {
        "content": "<p>the difference between having one axiom <code>forall a, a &lt; n</code> and an infinite family of axioms <code>1+1+1+1+... &lt; n</code></p>",
        "id": 563693851,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765723956
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/563693846\">said</a>:</p>\n<blockquote>\n<p>But Nat itself didn't change, is my point</p>\n</blockquote>\n<p>this statement doesn't make sense to me</p>",
        "id": 563693870,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765723970
    },
    {
        "content": "<p>you are implying</p>\n<ul>\n<li><code>Nat</code> has a \"value\"</li>\n<li>the value of <code>Nat</code> depends on what axioms you have</li>\n</ul>",
        "id": 563693884,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765724008
    },
    {
        "content": "<p>Ok so if we add those infinitely many axioms then you're saying that it's reasonable to call Lean's nat nonstandard?</p>",
        "id": 563693887,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1765724011
    },
    {
        "content": "<p>Ok then I withdraw my objection :-)</p>",
        "id": 563693906,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1765724039
    },
    {
        "content": "<p>Some of you might find <a href=\"https://math.andrej.com/2013/08/28/the-elements-of-an-inductive-type/\">this short blog post by Andrej Bauer</a> interesting/relevant to this topic.</p>",
        "id": 563693923,
        "sender_full_name": "Chris Henson",
        "timestamp": 1765724049
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/563693884\">said</a>:</p>\n<blockquote>\n<p>you are implying</p>\n<ul>\n<li><code>Nat</code> has a \"value\"</li>\n<li>the value of <code>Nat</code> depends on what axioms you have</li>\n</ul>\n</blockquote>\n<p>Yeah that's my model of what's going on -- <code>Nat</code> has a value and it's whatever vanilla Lean assigns to it. And there are statements which are true but not provable but we don't know what they are</p>",
        "id": 563694023,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1765724186
    },
    {
        "content": "<p>But your second point certainly confuses me :-)</p>",
        "id": 563694094,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1765724248
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/563694023\">said</a>:</p>\n<blockquote>\n<p>it's whatever vanilla Lean assigns to it.</p>\n</blockquote>\n<p>What would that be? The GMP natural numbers?</p>",
        "id": 563694115,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765724270
    },
    {
        "content": "<p>I don't know because I've never read the source code, but not knowing is part of the fun</p>",
        "id": 563694141,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1765724300
    },
    {
        "content": "<p>GMP is the bignum library that Lean uses</p>",
        "id": 563694156,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765724317
    },
    {
        "content": "<p>Ok well maybe some people know</p>",
        "id": 563694176,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1765724340
    },
    {
        "content": "<p>All I know is that it doesn't matter</p>",
        "id": 563694233,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1765724403
    },
    {
        "content": "<p>or do you mean all the constructible terms of type <code>Nat</code> quotient by \"equality\"</p>",
        "id": 563694293,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765724455
    },
    {
        "content": "<p>in that case we have numbers like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=System.Platform.numBits#doc\">docs#System.Platform.numBits</a> which is either 32 or 64, but we don't know which one</p>",
        "id": 563694353,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765724539
    },
    {
        "content": "<p>But yeah your point about adding consistent axioms is confusing, maybe I have the wrong mental model. My mental model is \"you can only prove things in lean which are true in all models of Lean's type theory, but there is a secret actual model which lean uses but which I'll only know if I read the source code, which I will never do\"</p>",
        "id": 563694357,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1765724543
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/563694357\">said</a>:</p>\n<blockquote>\n<p>but there is a secret actual model which lean uses but which I'll only know if I read the source code</p>\n</blockquote>\n<p>Which source code? There's a typechecker and there's a compiler.</p>",
        "id": 563694430,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765724609
    },
    {
        "content": "<p>I think we are discussing the compiler. That <code>native_decide</code> can introduce new axioms that should be in theory consistent but not very well known.</p>",
        "id": 563694529,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1765724689
    },
    {
        "content": "<p>in that case the compiler does give you a model</p>",
        "id": 563694576,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765724742
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"380294\">Matt Diamond</span> <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/563665919\">said</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- and yet it seems like we could assemble such a set if we kept going here!</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Keep in mind that you cannot actually keep going here, no computer can evaluate this for an arbitrarily large second value so everything is indeed still fine.</p>",
        "id": 563697533,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1765728265
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/563693817\">said</a>:</p>\n<blockquote>\n<p>So if I write <code>axiom n : Nat</code> and <code>axiom hn : forall a, a &lt; n</code> then suddenly <code>Nat</code> becomes \"nonstandard\"? I thought that \"nonstandard model\" had a well-defined meaning in first order logic and that there was some confusion applying it in other contexts, which was why I interjected.</p>\n</blockquote>\n<p>I think the difference is between a \"nonstandard model\", and \"nonstandard numbers\". While they are closely related, nonstandard numbers can be introduced to basically any logic with numbers, a nonstandard model doesn't have to exist in higher order logic if we have higher requirements about the model, but then an existence of a model is not equivalent to consistency.</p>",
        "id": 563704446,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1765736189
    },
    {
        "content": "<p>Thanks for the clarification!</p>",
        "id": 563704553,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1765736372
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/563693522\">said</a>:</p>\n<blockquote>\n<p>So you're saying that \"nonstandard model\" makes sense outside of first order logic?</p>\n</blockquote>\n<p>You can faithfully interpret Lean in a first-order theory, so the concept of non-standard models of Lean still makes sense.</p>",
        "id": 563705989,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765738162
    },
    {
        "content": "<p>Which is basically what Mirek is saying.</p>",
        "id": 563706000,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765738183
    },
    {
        "content": "<p><a href=\"https://en.wikipedia.org/wiki/Higher-order_logic#Semantics\">The terminology people use is 'full' or 'standard' semantics vs. Henkin semantics.</a> Henkin semantics is basically interpreting high-order logic as a particular kind of first-order logic, and it's the only one that's actually complete for syntactic provability.</p>",
        "id": 563706148,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765738445
    },
    {
        "content": "<p>You can't write down a computably enumerable proof system that proves all of the statements that are valid in every standard model of Lean.</p>",
        "id": 563706167,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765738479
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/563688744\">said</a>:</p>\n<blockquote>\n<p>In Lean, which uses higher order logic, you can prove that <code>Nat</code> is the standard model of the naturals,</p>\n</blockquote>\n<p>So on some level, you can only prove that <code>Nat</code> is the standard model of the naturals in Lean in the same sense that you can prove that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span> is the standard model of the naturals in ZFC. There are still arithmetically non-standard models of Lean just like how there are arithmetically non-standard models of ZFC.</p>",
        "id": 563706777,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765739361
    },
    {
        "content": "<p>And what Mirek/Matt's example tells us is that the idealized version of Lean + <code>propext</code> + <code>Classical.choice</code> + <code>Lean.ofReduceBool</code> + <code>Lean.trustCompiler</code> actually doesn't have any standard models, which is pretty amusing to me.</p>",
        "id": 563706975,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765739575
    },
    {
        "content": "<p>But also <code>Lean.ofReduceBool</code> and <code>Lean.trustCompiler</code> don't really operate the way an 'axiom' does in the typical sense (or even in the typical sense of the word in type theory).</p>",
        "id": 563707041,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765739663
    },
    {
        "content": "<p>Their semantic content isn't really contained in their statements. <code>Lean.trustCompiler</code> is a proof of <code>True</code>, after all, so why is assuming it as an axiom any different from the 'axiomless' proof of <code>True</code> that you normally have? And likewise, the types of <code>Lean.ofReduceBool</code> and <code>Lean.ofReduceNat</code> just assert that a certain otherwise unaxiomatized constants are the identity functions on <code>Bool</code> and <code>Nat</code>, respectively. <a href=\"#narrow/channel/113488-general/topic/Cardinality.20model.20incompatible.20with.20Lean.20compiler/near/501673961\">Yet somehow assuming these axioms implies something non-trivial about equality of types.</a></p>\n<p>They're really more flags that tell Lean to accept certain schemas of axioms (i.e., things told to it by the compiler in a controlled way), which is why you get the <code>LazyNat</code> example and Violetta's observation about the cardinality model.</p>",
        "id": 563707235,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765739948
    },
    {
        "content": "<p>Also, this is maybe a banal observation, but I find it really amusing that assuming the axioms <code>Lean.ofReduceBool</code> and <code>Lean.trustCompiler</code> produces a theorem that can only be proven if you're not on a Windows computer:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">not_Windows</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">System</span><span class=\"bp\">.</span><span class=\"n\">Platform</span><span class=\"bp\">.</span><span class=\"n\">isWindows</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">native_decide</span>\n</code></pre></div>",
        "id": 563707437,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765740252
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"904624\">James E Hanson</span> <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/563706975\">said</a>:</p>\n<blockquote>\n<p>And what Mirek/Matt's example tells us is that the idealized version of Lean + <code>propext</code> + <code>Classical.choice</code> + <code>Lean.ofReduceBool</code> + <code>Lean.trustCompiler</code> actually doesn't have any standard models, which is pretty amusing to me.</p>\n</blockquote>\n<p>This is a funny way to state the sentiment expressed by me / Matt that although it is still consistent, it feels a bit fishy <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 563708570,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1765741719
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek Olšák</span> <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/563708570\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"904624\">James E Hanson</span> <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/563706975\">said</a>:</p>\n<blockquote>\n<p>And what Mirek/Matt's example tells us is that the idealized version of Lean + <code>propext</code> + <code>Classical.choice</code> + <code>Lean.ofReduceBool</code> + <code>Lean.trustCompiler</code> actually doesn't have any standard models, which is pretty amusing to me.</p>\n</blockquote>\n<p>This is a funny way to state the sentiment expressed by me / Matt that although it is still consistent, it feels a bit fishy <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>\n</blockquote>\n<p>Fundamentally this example is the same as PA with a new constant <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">c</span></span></span></span> and axioms asserting that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">c</span></span></span></span> is greater than any given standard natural number. This theory is conservative over PA for sentences that don't involve <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">c</span></span></span></span>, essentially for the same reason that Henrik pointed out. Any proof can only involve finitely many of these axioms, and so <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">c</span></span></span></span> can always be soundly interpreted as some large natural number relative to a given proof. It just can't be soundly interpreted as a single natural number <em>uniformly</em> for all proofs.</p>",
        "id": 563708989,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765742318
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"380294\">Matt Diamond</span> <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/563665039\">said</a>:</p>\n<blockquote>\n<p>yes but the naturals with <code>big</code> are not well-founded, and <code>Nat</code> is well-founded</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> why did I get a thumbs down here? not denying that what I said could be wrong, just curious why</p>",
        "id": 563711628,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1765745890
    },
    {
        "content": "<p>It just meant \"I think the naturals with <code>big</code> are still well-founded, because we can prove they're well-founded in Lean, and so what you're doing can't be proving that they're not well-founded\".</p>",
        "id": 563711676,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1765745968
    },
    {
        "content": "<p>there are two different version of \"well-founded\"</p>",
        "id": 563711697,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765745999
    },
    {
        "content": "<p>well-founded according to Lean and well-founded according to the meta-theory</p>",
        "id": 563711722,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765746015
    },
    {
        "content": "<p>yes, I know... that's why I said in my first message that this is \"almost like a meta-soundness bug\"... I'm aware that we're operating on multiple levels here (and I said \"almost\", not \"actually\"!)</p>",
        "id": 563711812,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1765746106
    },
    {
        "content": "<p>ok so it becomes more difficult to tell what everyone is talking about because of that</p>",
        "id": 563711881,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765746157
    },
    {
        "content": "<p>I just find it so interesting that we \"know\" Lean's compiler can verify an arbitrarily large number of proofs about individual members of an infinite (?) type (natural numbers which can be represented by raw natural number literals) yet we can't universally quantify this fact over all members of the type within Lean.</p>\n<p>I suppose we should expect that there are a lot of things about Lean that can't be proved within Lean, but it's fun to see a specific example. I'm curious if there are other examples of this where <code>native_decide</code> leads to unexpected but technically sound results.</p>",
        "id": 563729619,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1765769058
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"380294\">Matt Diamond</span> <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/563729619\">said</a>:</p>\n<blockquote>\n<p>I just find it so interesting that we \"know\" Lean's compiler can verify an arbitrarily large number of proofs about individual members of an infinite (?) type (natural numbers which can be represented by raw natural number literals) yet we can't universally quantify this fact over all members of the type within Lean.</p>\n</blockquote>\n<p>You don't even have to bring in the compiler. Lean can prove the \"ZFC + <code>n</code> inaccessible cardinals is consistent\" for each numeral <code>n</code> (you have to use ~<code>n</code>-many universes in the proof) but it can't prove the statement \"forall natural numbers n, ZFC + n inaccessible cardinals is consistent\".</p>",
        "id": 563730050,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765769394
    },
    {
        "content": "<p>that's a good example!</p>",
        "id": 563730108,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1765769438
    },
    {
        "content": "<p>that's because we can't quantify over universes, right?</p>",
        "id": 563730180,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1765769492
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"380294\">Matt Diamond</span> <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/563729619\">said</a>:</p>\n<blockquote>\n<p>unexpected but technically sound results.</p>\n</blockquote>\n<p>What counts as technically sound in your mind?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">IntEqNat</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">neg_one_eq_four_bil_ish</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"n\">IntEqNat</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">4294967295</span>\n<span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">native_decide</span>\n</code></pre></div>",
        "id": 563730278,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765769577
    },
    {
        "content": "<p>I don't believe this is inconsistent, but I can't figure out exactly which unsafe casts from <code>Int</code> to <code>Nat</code> <code>native_decide</code> counts as 'real'.</p>",
        "id": 563730378,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765769653
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"380294\">Matt Diamond</span> <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/563730180\">said</a>:</p>\n<blockquote>\n<p>that's because we can't quantify over universes, right?</p>\n</blockquote>\n<p>Also, yes this is basically why.</p>",
        "id": 563730491,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765769720
    },
    {
        "content": "<p>\"we can't prove False\" is what I had in mind, so your example counts</p>",
        "id": 563730541,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1765769756
    },
    {
        "content": "<p>Though I suspect you can't actually prove the non-axiomatic version of this using <code>native_decide</code>. I.e., something of the form:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">4294967295</span>\n</code></pre></div>\n<p>Which, again, speaks to how <code>Lean.trustCompiler</code> doesn't really operate like a normal axiom.</p>",
        "id": 563730753,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765769923
    },
    {
        "content": "<p>I wonder if there are other fun things you can do with <code>native_decide</code> and <code>partial</code>... it seems like the trick is finding properties that can be verified via a finite process but then sneaking in non-well-founded structures within a <code>partial</code> function</p>",
        "id": 563731048,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1765770116
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"904624\">James E Hanson</span> <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/563730378\">said</a>:</p>\n<blockquote>\n<p>I don't believe this is inconsistent, but I can't figure out exactly which unsafe casts from <code>Int</code> to <code>Nat</code> <code>native_decide</code> counts as 'real'.</p>\n</blockquote>\n<p>As I understand it it's sound to add axioms of the form <code>\\a \\simeq \\b</code> for types of the same cardinality, so under that same logic it should be sound to add axioms <code>cast h x = e x</code> for <code>h : \\a = \\b</code> and <code>e : \\a \\simeq \\b</code>.</p>",
        "id": 563739983,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1765778054
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/563739983\">said</a>:</p>\n<blockquote>\n<p>it should be sound to add axioms <code>cast h x = e x</code> for <code>h : \\a = \\b</code> and <code>e : \\a \\simeq \\b</code>.</p>\n</blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/Batteries/Logic.html#cast_eq_iff_heq\">Maybe I'm misunderstanding, but isn't this just provable?</a></p>",
        "id": 563740550,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765778522
    },
    {
        "content": "<p>Oh, sorry, <code>\\simeq</code>, not <code>\\asymp</code>.</p>",
        "id": 563740682,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765778577
    },
    {
        "content": "<p>What do you mean by <code>\\simeq</code>?</p>",
        "id": 563740766,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765778629
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Equiv#doc\">docs#Equiv</a><br>\nsorry, currently on mobile</p>",
        "id": 563741109,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1765778890
    },
    {
        "content": "<p>I'm confused by your statement then. If two types <code>A</code> and <code>B</code> have the same cardinality, then <code>A ≃ B</code> should be a provable theorem. Why would you need to add it as an axiom?</p>",
        "id": 563741278,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765778998
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"904624\">James E Hanson</span> <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/563730278\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"380294\">Matt Diamond</span> <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/563729619\">said</a>:</p>\n<blockquote>\n<p>unexpected but technically sound results.</p>\n</blockquote>\n<p>What counts as technically sound in your mind?</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">IntEqNat</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">neg_one_eq_four_bil_ish</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"n\">IntEqNat</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">4294967295</span>\n<span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">native_decide</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Axiomatically adding <code>ℤ = ℕ</code> is literally inconsistent with <code>native_decide</code>, I thought that was Violeta's example.</p>",
        "id": 563780826,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1765793491
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"380294\">Matt Diamond</span> <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/563731048\">said</a>:</p>\n<blockquote>\n<p>I wonder if there are other fun things you can do with <code>native_decide</code> and <code>partial</code>... it seems like the trick is finding properties that can be verified via a finite process but then sneaking in non-well-founded structures within a <code>partial</code> function</p>\n</blockquote>\n<p>Not really, as I mentioned, once you have a non-standard natural number <code>big</code>, you could define the actual meaning of <code>partial def</code> as</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">pf</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">In</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">recurse</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">In</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">In</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">input</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">In</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">recurse</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">pf</span><span class=\"w\"> </span><span class=\"n\">recurse</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">input</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">implemented_by</span><span class=\"w\"> </span><span class=\"n\">pf</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">In</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">recurse</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">In</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">In</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">In</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Out</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">big</span><span class=\"bp\">.</span><span class=\"n\">repeat</span><span class=\"w\"> </span><span class=\"n\">recurse</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">ofNonempty</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 563782938,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1765794060
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek Olšák</span> <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/563780826\">said</a>:</p>\n<blockquote>\n<p>Axiomatically adding <code>ℤ = ℕ</code> is literally inconsistent with <code>native_decide</code>, I thought that was Violeta's example.</p>\n</blockquote>\n<p>I see, that example was a bit different, well nevertheless...</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">IntEqNat</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">neg_one_eq_four_bil_ish</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"n\">IntEqNat</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">4294967295</span>\n<span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">native_decide</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">four_bil_ish_eq_four_bil_ish</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"n\">IntEqNat</span><span class=\"w\"> </span><span class=\"mi\">4294967295</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">4294967294</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">native_decide</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">add_of_sub</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">sub_eq_iff_eq_add</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">h1</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Decidable</span><span class=\"bp\">.</span><span class=\"n\">not_not</span><span class=\"bp\">.</span><span class=\"n\">mp</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">le_ab</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">not_le</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">le_ab</span>\n<span class=\"w\">  </span><span class=\"n\">replace</span><span class=\"w\"> </span><span class=\"n\">le_ab</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le_of_succ_le</span><span class=\"w\"> </span><span class=\"n\">le_ab</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">sub_eq_zero_of_le</span><span class=\"w\"> </span><span class=\"n\">le_ab</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h1</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">contradiction</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">add_of_sub</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">one_ne_zero</span><span class=\"w\"> </span><span class=\"n\">four_bil_ish_eq_four_bil_ish</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">reduceAdd</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">this</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">neg_one_eq_four_bil_ish</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">this</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">congrArg</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"n\">IntEqNat</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">this</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">this</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">info: 'contradiction' depends on axioms: [IntEqNat, propext, Lean.ofReduceBool, Lean.trustCompiler]</span>\n<span class=\"sd\">-/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">axioms</span><span class=\"w\"> </span><span class=\"n\">contradiction</span>\n</code></pre></div>",
        "id": 563786864,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1765795093
    },
    {
        "content": "<p>I don't know what exactly is going on but my understanding is that the compiler is not really built for <code>Int = Nat</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"n\">IntEqNat</span><span class=\"w\"> </span><span class=\"mi\">4294967295</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">4294967294</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">native_decide</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"n\">IntEqNat</span><span class=\"w\"> </span><span class=\"mi\">4294967295</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">4294967295</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">native_decide</span>\n</code></pre></div>",
        "id": 563790395,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1765795996
    },
    {
        "content": "<p>So this is a proof that the compiler is not using the cardinality model :-)</p>",
        "id": 563807140,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1765801002
    },
    {
        "content": "<p>I wouldn't say it's really accurate to say the compiler is 'using a particular model' at all.</p>",
        "id": 563882570,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765819561
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek Olšák</span> <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/563786864\">said</a>:</p>\n<blockquote>\n<p>I see, that example was a bit different, well nevertheless...</p>\n</blockquote>\n<p>I wonder why </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"n\">IntEqNat</span><span class=\"w\"> </span><span class=\"mi\">4294967295</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">4294967295</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">native_decide</span>\n</code></pre></div>\n<p>works then. I know that this isn't surprising logically, but on an implementation level I'm curious.</p>",
        "id": 563891432,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765822217
    },
    {
        "content": "<p>The left-hand side is the GMP value 4294967295 (encoded as a pointer) and the right-hand side is the scalar 4294967295 (encoded as 4294967295*2 + 1). In other words, this breaks the assumption that GMP values are always <code>&gt;= USize.size / 2</code>. Also funnily enough, on 32-bit builds both of these would be represented as GMP so the equality would actually hold.</p>",
        "id": 563893866,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1765822989
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133339\">@Mirek Olšák</span> you can also create \"infinite\" Lists/Arrays with a length greater than any specific numeral:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">LazyList</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">LazyList</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Nonempty</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">LazyList</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">toList</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LazyList</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">())</span><span class=\"bp\">.</span><span class=\"n\">toList</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">longerThanList</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LazyList</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">false</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">t'</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">())</span><span class=\"bp\">.</span><span class=\"n\">longerThanList</span><span class=\"w\"> </span><span class=\"n\">t'</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">longerThanList_iff</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LazyList</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">longerThanList</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">toList</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">generalizing</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">longerThanList</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">toList</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"n\">IH</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">longerThanList</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">toList</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">longerThanList</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">toList</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">IH</span><span class=\"o\">]</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">longerThan</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LazyList</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">longerThanList</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">toList</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LazyList</span><span class=\"bp\">.</span><span class=\"n\">longerThanList_iff</span><span class=\"o\">]</span>\n\n<span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">infiniteList</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LazyList</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">infiniteList</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">LazyList</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">longList</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">LazyList</span><span class=\"bp\">.</span><span class=\"n\">infiniteList</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">())</span><span class=\"bp\">.</span><span class=\"n\">toList</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">longArray</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">longList</span><span class=\"bp\">.</span><span class=\"n\">toArray</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">longList</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">10000</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">LazyList</span><span class=\"bp\">.</span><span class=\"n\">longerThan</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">native_decide</span><span class=\"o\">)</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">longArray</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">10000</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">LazyList</span><span class=\"bp\">.</span><span class=\"n\">longerThan</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">native_decide</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 563898307,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1765824606
    },
    {
        "content": "<p>(obviously not useful in any way, but still kind of amusing)</p>",
        "id": 563899136,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1765824933
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"904624\">James E Hanson</span> <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/563730278\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"380294\">Matt Diamond</span> <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/563729619\">said</a>:</p>\n<blockquote>\n<p>unexpected but technically sound results.</p>\n</blockquote>\n<p>What counts as technically sound in your mind?</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">IntEqNat</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">neg_one_eq_four_bil_ish</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"n\">IntEqNat</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">4294967295</span>\n<span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">native_decide</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>This is one of a family of very bad things you can observe using axiomatized type casts. It's really just an unsafe cast with extra steps. Try saying that Nat = String for more fun</p>",
        "id": 563907991,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765827084
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/563907991\">said</a>:</p>\n<blockquote>\n<p>Try saying that Nat = String for more fun</p>\n</blockquote>\n<p>I hoped for fun, and my Lean just crashed...</p>",
        "id": 563912037,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1765828279
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"873547\">Robin Arnez</span> <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/563893866\">said</a>:</p>\n<blockquote>\n<p>The left-hand side is the GMP value 4294967295 (encoded as a pointer) and the right-hand side is the scalar 4294967295 (encoded as 4294967295*2 + 1). In other words, this breaks the assumption that GMP values are always <code>&gt;= USize.size / 2</code>. Also funnily enough, on 32-bit builds both of these would be represented as GMP so the equality would actually hold.</p>\n</blockquote>\n<p>Thanks but why then does</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">unsafeCast</span><span class=\"w\"> </span><span class=\"mi\">4294967295</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">4294967295</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>evaluate to <code>true</code>? Why isn't casting with an axiomatic equality the same as unsafe casting at runtime? (I checked and <code>#eval (cast IntEqNat 4294967295 : Nat) = 4294967295</code> evaluates to <code>false</code>.)</p>",
        "id": 563912081,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765828294
    },
    {
        "content": "<p>Casting a Nat to a Nat I wouldn't expect any difficulties</p>",
        "id": 563912207,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765828344
    },
    {
        "content": "<p>Oh duh.</p>",
        "id": 563912259,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765828365
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"380294\">Matt Diamond</span> <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/563898307\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek Olšák</span> you can also create \"infinite\" Lists/Arrays with a length greater than any specific numeral:</p>\n</blockquote>\n<p>Sure, all I meant is that you can already have this kind of fun just with a nonstandard natural number. You can build for example</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">nonstandardList</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"n\">big</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">nonstandardFinset</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">big</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">big</span>\n<span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 563912783,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1765828532
    },
    {
        "content": "<p>You can also just do a typical kind of lazy list example.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">lazyList</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">lazyList</span><span class=\"w\"> </span><span class=\"o\">()))</span>\n</code></pre></div>",
        "id": 563913697,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765828817
    },
    {
        "content": "<p>Oh sorry, Matt already said that.</p>",
        "id": 563913786,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765828846
    },
    {
        "content": "<p>oh right, that's true... so you basically get all of these other objects for free, in a sense</p>",
        "id": 563914052,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1765828933
    },
    {
        "content": "<p>I think you don't need nonstandard models to make sense of this behavior. As others have mentioned up-thread, you can't even prove <code>big</code> is very large, let alone nonstandard. I'm pretty sure you can literally just say that <code>big = 100000</code> or so and you would have difficulty showing some behavior of <code>native_decide</code> inconsistent with this</p>",
        "id": 563916681,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765829882
    },
    {
        "content": "<p>and the underlying model here is to have <code>partial def</code> be defined by iterating the function <code>big</code> many times on the <code>default</code> value supplied by the instance</p>",
        "id": 563916848,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765829937
    },
    {
        "content": "<p>Note that this limits some compilation tricks. I tried for a while to get a contradiction by evaluating <code>nonstandard ()</code> and some of its unfoldings and note that the result is pointer-equal, but it seems the semantics of the thunks created are such that each unfolding produces a new object</p>",
        "id": 563917256,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765830068
    },
    {
        "content": "<p>If it was possible to have recursion between a value and a function I think you could get an inconsistency, e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">mutual</span>\n<span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">nonstandard</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LazyNat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">nonstandardF</span>\n<span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">nonstandardF</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LazyNat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">nonstandard</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 563917574,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765830173
    },
    {
        "content": "<p>is the idea here that the value of <code>big</code> is whatever the maximum recursion depth is + 1?</p>",
        "id": 563917595,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1765830181
    },
    {
        "content": "<p>yes</p>",
        "id": 563917627,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765830190
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/563916681\">said</a>:</p>\n<blockquote>\n<p>I think you don't need nonstandard models to make sense of this behavior. As others have mentioned up-thread, you can't even prove <code>big</code> is very large, let alone nonstandard. I'm pretty sure you can literally just say that <code>big = 100000</code> or so and you would have difficulty showing some behavior of <code>native_decide</code> inconsistent with this</p>\n</blockquote>\n<p>Having difficulty is somewhat different from impossibility. Imagine you eventually get to implement what it means to be a proof with <code>native_decide</code> &amp; <code>partial def</code> in Lean4Lean. Would you hardcode a limit on how many steps the evaluation can take? If so, why not a hard limit on the size of the proof term itself? (it also cannot be too large in practice)</p>",
        "id": 563917692,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1765830215
    },
    {
        "content": "<p>as long as <code>big</code> is larger than the largest recursion depth in any observed <code>native_decide</code> computation you are ok</p>",
        "id": 563917732,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765830230
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133339\">@Mirek Olšák</span> yes that's exactly what I'd do</p>",
        "id": 563917818,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765830255
    },
    {
        "content": "<p>it's easy enough to have a limit which is so large that you don't even need to keep track of it because the machine will break first</p>",
        "id": 563917914,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765830294
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek Olšák</span> <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/563917692\">said</a>:</p>\n<blockquote>\n<p>If so, why not a hard limit on the size of the proof term itself? (it also cannot be too large in practice)</p>\n</blockquote>\n<p>There is already such a limit <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 563918045,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765830338
    },
    {
        "content": "<p>recall some discussion previously about unsoundness in the kernel due to depth overflow</p>",
        "id": 563918113,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765830365
    },
    {
        "content": "<p>I would argue that proofs without a hard limit have nicer theoretical properties, but sure, not believing in the existence of the number 10^100 is also a valid philosophy...</p>",
        "id": 563919705,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1765830867
    },
    {
        "content": "<p>I would prefer fixing the soundness bug rather than plugging hardware constraints into proof theory but hard to convince the developers, I guess...</p>",
        "id": 563920124,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1765831016
    },
    {
        "content": "<p>It's not that the proof theory needs a hard limit, the implementation needs a limit</p>",
        "id": 563925029,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765832786
    },
    {
        "content": "<p>same here, it's a limitation on the maximum recursion depth of an observed <code>native_decide</code> computation</p>",
        "id": 563925128,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765832819
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek Olšák</span> <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/563920124\">said</a>:</p>\n<blockquote>\n<p>I would prefer fixing the soundness bug rather than plugging hardware constraints into proof theory but hard to convince the developers, I guess...</p>\n</blockquote>\n<p>what soundness bug? My point is that not only can you model this with a nonstandard model, you can do it with a standard model too, so obviously it's not unsound</p>",
        "id": 563925513,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765832981
    },
    {
        "content": "<p>I meant the bug you mentioned that panics if the recursion depth is too high.</p>",
        "id": 563926701,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1765833510
    },
    {
        "content": "<p>well there is no proposal for fixing that which will make the limit magically disappear, it's just a question of what happens when you reach the limit</p>",
        "id": 563926885,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765833577
    },
    {
        "content": "<p>ultimately implementation limits are a fact of life</p>",
        "id": 563926931,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765833598
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/563925029\">said</a>:</p>\n<blockquote>\n<p>It's not that the proof theory needs a hard limit, the implementation needs a limit</p>\n</blockquote>\n<p>Depending on what you mean by implementation. If running on a physical machine, then yes, there are numbers you have no chance of evaluating in practice. On the other hand, many languages (including Lean) abstract the physical limit away, and let you operate seemingly arbitrary values even if they don't fit a physical machine. So sure, you cannot evaluate arbitrary program on a physical machine, but you can still define what it means to be a result of an unbounded computation.</p>",
        "id": 563928414,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1765834209
    },
    {
        "content": "<p>you only get <code>native_decide</code> \"axioms\" from real hardware computations</p>",
        "id": 563928531,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765834248
    },
    {
        "content": "<p>and those have limits that you can work out in advance</p>",
        "id": 563928565,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765834259
    },
    {
        "content": "<p>My understanding of <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/562681988\">Mirek's example</a> is that laziness means that <code>LazyNat</code> at runtime, when restricted only to those terminating thunks, is a <em>coinductive</em> type instead. The coinductive natural number type (CoNat) consists of all the elements of Nat along with an additional infinity element (\"<code>nonstandard</code>\").</p>\n<p>I don't think this counts as a nonstandard model of Nat, since it wouldn't have the same induction principle as Nat.</p>",
        "id": 563928732,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1765834317
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"904624\">James E Hanson</span> <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/563706975\">said</a>:</p>\n<blockquote>\n<p>And what Mirek/Matt's example tells us is that the idealized version of Lean + <code>propext</code> + <code>Classical.choice</code> + <code>Lean.ofReduceBool</code> + <code>Lean.trustCompiler</code> actually doesn't have any standard models, which is pretty amusing to me.</p>\n</blockquote>\n<p>And just to clarify on this point, the \"axiom\" isn't <code>Lean.ofReduceBool</code> or <code>Lean.trustCompiler</code>, it's the axiom scheme that says that <code>Lean.reduceBool foo</code> reduces to <code>true</code> or <code>false</code> depending on whether the IR compiled from <code>foo</code> evaluates to true or false in the interpreter</p>",
        "id": 563928928,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765834397
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/563928531\">said</a>:</p>\n<blockquote>\n<p>you only get <code>native_decide</code> \"axioms\" from real hardware computations</p>\n</blockquote>\n<p>I don't see why this is a meaningful constraint. In the same logic, you should not claim that the theory of Lean is equivalent to ZFC + {\"there are n inaccessibles\" for n in N}  but rather that it is equivalent to ZFC + {\"there are n inaccessibles\" for n which fits into a physical machine}</p>",
        "id": 563929059,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1765834453
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> the problem is that Nat is <em>still</em> inductive notwithstanding the fact that it has infinite elements</p>",
        "id": 563929092,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765834461
    },
    {
        "content": "<p>that's why it looks nonstandard-ish</p>",
        "id": 563929141,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765834472
    },
    {
        "content": "<p>The question is how you define the lean axiomatic system <span class=\"user-mention\" data-user-id=\"133339\">@Mirek Olšák</span> . If you want to include <code>native_decide</code> \"axioms\" you need a model for how interpreter evaluation works and this is intensely machine-specific in a variety of ways</p>",
        "id": 563929519,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765834552
    },
    {
        "content": "<p>so it's not actually that weird that a machine-specific limit could pop up there</p>",
        "id": 563929645,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765834593
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/563928732\">said</a>:</p>\n<blockquote>\n<p>My understanding of <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/562681988\">Mirek's example</a> is that laziness means that <code>LazyNat</code> at runtime, when restricted only to those terminating thunks, is a <em>coinductive</em> type instead. The coinductive natural number type (CoNat) consists of all the elements of Nat along with an additional infinity element (\"<code>nonstandard</code>\").</p>\n<p>I don't think this counts as a nonstandard model of Nat, since it wouldn't have the same induction principle as Nat.</p>\n</blockquote>\n<p>Just to clarify my example, <code>LazyNat</code> is just a helper tool, the main point was the construction of <code>big : Nat</code> which is larger than any number of steps that can be performed by <code>native_decide</code></p>",
        "id": 563929903,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1765834687
    },
    {
        "content": "<p>I get that <span class=\"user-mention\" data-user-id=\"133339\">@Mirek Olšák</span>, it serves its purpose. Your element is also a perfectly defined element of the coinductive type.</p>\n<p>I just think it's worth distinguishing between nonstandard peano arithmetic and whatever captures what the runtime LazyNat type represents. Like, <code>big + 1 = big</code> is true, if we could somehow evaluate its truth at runtime, which violates no-confusion for inductive type constructors. In nonstandard PA, there's no such <code>n</code> such that <code>n + 1 = n</code>, right?</p>",
        "id": 563930066,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1765834761
    },
    {
        "content": "<p>I think it makes more sense to just stick with LazyNat because it has the laziness you need to implement terminating computations. As soon as you make <code>big : Nat</code> you have a value that won't be used in any terminating <code>native_decide</code> computation</p>",
        "id": 563930136,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765834785
    },
    {
        "content": "<p>But LazyNat is not coinductive, it's provably isomorphic to Nat</p>",
        "id": 563930340,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765834883
    },
    {
        "content": "<p>Mario, I'm saying the <em>runtime</em> type is equivalent to CoNat (with the proviso I mentioned that you only use terminating thunks). I agree that within Lean it's <code>Nat</code>.</p>",
        "id": 563930429,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1765834917
    },
    {
        "content": "<p>You can't prove that <code>nonstandard ()</code> is equal to <code>succ nonstandard</code></p>",
        "id": 563930452,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765834926
    },
    {
        "content": "<p>I get that Mario</p>",
        "id": 563930470,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1765834936
    },
    {
        "content": "<p>you can prove it's succ of something but that something is a different object with a different address</p>",
        "id": 563930532,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765834957
    },
    {
        "content": "<p>so you just made <code>big - 1</code> and it's observably nonzero and provably not <code>big</code></p>",
        "id": 563930603,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765834982
    },
    {
        "content": "<p>even though it has exactly the same code as <code>big</code> itself</p>",
        "id": 563930657,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765835010
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/563929519\">said</a>:</p>\n<blockquote>\n<p>The question is how you define the lean axiomatic system <span class=\"user-mention silent\" data-user-id=\"133339\">Mirek Olšák</span> . If you want to include <code>native_decide</code> \"axioms\" you need a model for how interpreter evaluation works and this is intensely machine-specific in a variety of ways</p>\n</blockquote>\n<p>I would expect that there are still reasonable abstract computational models that could be used to define (part of) Lean's evaluation before we start looking into hardware limits but you know probably more than me here.</p>",
        "id": 563931117,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1765835183
    },
    {
        "content": "<p>Sure, it's an abstract hypercomputer which is nevertheless a 64-bit windows :)</p>",
        "id": 563931258,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765835252
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"904624\">James E Hanson</span> <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/563912081\">said</a>:</p>\n<blockquote>\n<p>Thanks but why then does</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">unsafeCast</span><span class=\"w\"> </span><span class=\"mi\">4294967295</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">4294967295</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>evaluate to <code>true</code>? Why isn't casting with an axiomatic equality the same as unsafe casting at runtime? (I checked and <code>#eval (cast IntEqNat 4294967295 : Nat) = 4294967295</code> evaluates to <code>false</code>.)</p>\n</blockquote>\n<p>Okay I knew I didn't hallucinate that there was something weird here. Why does this happen?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">unsafeCast</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">4294967296</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span>\n<span class=\"c1\">-- Evaluates to 4294967296.</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">unsafeCast</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">4294967296</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">4294967296</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span>\n<span class=\"c1\">-- Evaluates to false.</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">unsafeCast</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">4294967296</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">unsafeCast</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">4294967296</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span>\n<span class=\"c1\">-- Evaluates to true.</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"mi\">4294967296</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">4294967296</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span>\n<span class=\"c1\">-- Evaluate to true.</span>\n</code></pre></div>",
        "id": 563932053,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765835606
    },
    {
        "content": "<p>Most likely you are creating an ill-formed value, which behaves weirdly</p>",
        "id": 563932289,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765835708
    },
    {
        "content": "<p>I recall there is some way to generate numbers that print as <code>***********</code></p>",
        "id": 563932336,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765835725
    },
    {
        "content": "<p>Is this because <code>Nat</code> and <code>Int</code> have different upper bounds for when they switch runtime representations?</p>",
        "id": 563932485,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765835786
    },
    {
        "content": "<p>that would make sense</p>",
        "id": 563932505,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765835800
    },
    {
        "content": "<p>(they do)</p>",
        "id": 563932574,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765835833
    },
    {
        "content": "<p>that number is apparently incomparable with zero</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">unsafeCast</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">4294967296</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"c1\">-- false</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">unsafeCast</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">4294967296</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"c1\">-- false</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">unsafeCast</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">4294967296</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"c1\">-- false</span>\n</code></pre></div>",
        "id": 563932971,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765835994
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek Olšák</span> <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/563931117\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/563929519\">said</a>:</p>\n<blockquote>\n<p>The question is how you define the lean axiomatic system <span class=\"user-mention silent\" data-user-id=\"133339\">Mirek Olšák</span> . If you want to include <code>native_decide</code> \"axioms\" you need a model for how interpreter evaluation works and this is intensely machine-specific in a variety of ways</p>\n</blockquote>\n<p>I would expect that there are still reasonable abstract computational models that could be used to define (part of) Lean's evaluation before we start looking into hardware limits but you know probably more than me here.</p>\n</blockquote>\n<p>even without bringing up concrete limits, it is true that for any lean proof it can only do finitely many computations with <code>native_reduce</code> so there is a uniform bound on max recursion depth in all such computations</p>",
        "id": 563933446,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765836181
    },
    {
        "content": "<p>Nothing against taking finite fragments of an infinite theory.</p>",
        "id": 563935483,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1765836876
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> If I understand correctly, you are saying that for a Lean programmer, a good mental model is something like Haskell / OCaml, with possibly infinite programs, and possibly infinite datastructures (coinductives). Unfortunatelly, this mental model is highly incompatible with Lean's logic, so logic-wise, <code>big</code> feels much more as a really large finite number than an infinite object.</p>",
        "id": 563938793,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1765838557
    },
    {
        "content": "<p>having nonterminating programs implies the existence of nonterminating proofs</p>",
        "id": 563939541,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765839040
    },
    {
        "content": "<p>so I think it doesn't really conflict with the logic</p>",
        "id": 563939554,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765839055
    },
    {
        "content": "<p>if there is a closed term of type False that's a problem whether or not the term normalizes</p>",
        "id": 563939620,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765839101
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/563917574\">said</a>:</p>\n<blockquote>\n<p>If it was possible to have recursion between a value and a function I think you could get an inconsistency, e.g.</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">mutual</span>\n<span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">nonstandard</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LazyNat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">nonstandardF</span>\n<span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">nonstandardF</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LazyNat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">nonstandard</span>\n<span class=\"kn\">end</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>What is the idea? I was a bit surprised that <code>partial def</code> cannot be a value but I don't see how I could exploit that (I was thinking if I could get inconsistency too).</p>",
        "id": 563940086,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1765839405
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133339\">@Mirek Olšák</span>  My assumptions: (1) we're talking about <code>native_decide</code> and looking at the consequences inside Lean, (2) so that means we care about a reasonable runtime model (not just a mental model) of data, and (3) the idea of 'nonstandard natural numbers' was brought up, which has a specific meaning, and the runtime type doesn't satisfy this (this third point is just to say \"it seems worth being careful about what you mean by nonstandard\").</p>\n<p>Given these, I'm saying that the Lean compiler is effectively allowing you to use <code>LazyNat</code> as if it were the greatest fixpoint instead of the least fixpoint (hence coinductive instead of inductive). Let's agree the greatest fixpoint includes computationally diverging terms to be precise (so it's also not quite CoNat). And yes, the greatest and least fixpoint are highly incompatible with each other.</p>\n<p>Since the Lean compiler assumes the programs you write <em>are</em> creating well-formed terms for the <em>inductive</em> type, what I was obliquely trying to get at earlier is that it might be possible to convince the compiler that some computation is impossible because it diverges, get it to eliminate it, then arrive at a contradiction through <code>native_decide</code>.</p>",
        "id": 563940671,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1765839761
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek Olšák</span> <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/563940086\">said</a>:</p>\n<blockquote>\n<p>What is the idea? I was a bit surprised that <code>partial def</code> cannot be a value but I don't see how I could exploit that (I was thinking if I could get inconsistency too).</p>\n</blockquote>\n<p>If <code>nonstandard : LazyNat</code> was a global constant, then it would have to be computed at initialization time and used as a closed value. As a result, all references to it will come out pointer-equal to one another, so if you start unfolding <code>nonstandard</code> you will get a sequence of succs all of which compare pointer-equal to <code>nonstandard</code>. This violates the model, which requires that they all be distinct nonstandard numbers.</p>",
        "id": 563941985,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765840493
    },
    {
        "content": "<p>Is there a way to make use of pointer-equality in computation?</p>",
        "id": 563942145,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1765840612
    },
    {
        "content": "<p>I was a bit surprised to find that the closure object <code>fun () =&gt; nonstandard ()</code> which appears inside the unfoldings of the original version are all distinct from one another, because the IR for these just say something like <code>let x.0 := nonstandard</code> which looks like it's loading a constant, but it seems to allocate a fresh closure every time</p>",
        "id": 563942219,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765840663
    },
    {
        "content": "<p>yes, the native_decide model has to make pointer-equal values <code>=</code></p>",
        "id": 563942327,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765840735
    },
    {
        "content": "<p>Why?</p>",
        "id": 563942395,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1765840782
    },
    {
        "content": "<p>Is there an example where it skips evaluation because of pointer equality?</p>",
        "id": 563942447,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1765840821
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=withPtrEq#doc\">docs#withPtrEq</a></p>",
        "id": 563942482,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765840848
    },
    {
        "content": "<p>Here's an example of what goes wrong when pointer equality doesn't match <code>=</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">withPtrEq</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">()</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">eq</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">nomatch</span><span class=\"w\"> </span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"n\">eq</span><span class=\"w\"> </span><span class=\"bp\">⟨⟩</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"c1\">-- true</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">nomatch</span><span class=\"w\"> </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">native_decide</span>\n</code></pre></div>",
        "id": 563942742,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765841019
    },
    {
        "content": "<p>also: <span aria-label=\"double exclamation\" class=\"emoji emoji-203c\" role=\"img\" title=\"double exclamation\">:double_exclamation:</span></p>",
        "id": 563942768,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765841037
    },
    {
        "content": "<p>Lol, who made it so <code>Sort u : Type u</code> :-)</p>",
        "id": 563943256,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1765841370
    },
    {
        "content": "<p>you can do the same proof with Nat = Bool, it's just more complicated. Any two types which are provably different can be used in that example</p>",
        "id": 563943388,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765841451
    },
    {
        "content": "<p>I thought <code>withPtrEq</code> could be used to obtain equality from pointer equality. So far I see it used to a mysterious proof of False with evaluation. This is because the runtime doesn't see propositions / types?</p>",
        "id": 563943509,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1765841531
    },
    {
        "content": "<p>(Goes to show once again type erasure is more complicated than you'd hope...)</p>\n<p>You haven't reported this to the Lean 4 issue tracker, have you <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>? Happy to submit it if you haven't.</p>",
        "id": 563943520,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1765841539
    },
    {
        "content": "<p>no, I just noticed this flaw now</p>",
        "id": 563943544,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765841565
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133339\">@Mirek Olšák</span> The type signature of <code>withPtrEq</code> is complicated, but the basic idea is that if two values of the same type are pointer-equal then you can obtain a proof that they are <code>=</code></p>",
        "id": 563943608,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765841624
    },
    {
        "content": "<p>Gabriel seems to have noticed it in <a href=\"https://github.com/leanprover/lean4/pull/1502\">lean4#1502</a></p>",
        "id": 563943613,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1765841627
    },
    {
        "content": "<p>oh and @Rob23oba bumped that thread just yesterday :)</p>",
        "id": 563943976,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765841879
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133339\">@Mirek Olšák</span> The types <code>True</code> and <code>False</code> are erased, so they both become the neutral value in the compiler and hence are pointer-equal, even though they are provably distinct</p>",
        "id": 563944099,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765841965
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> I feel like the labels on <a href=\"https://github.com/leanprover/lean4/pull/1502\">lean#1502</a> don't really reflect the nature of the issue</p>",
        "id": 563944381,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765842234
    },
    {
        "content": "<p>Almost wish there was a NaN-like pointer that's not equal to itself, just to implement this efficiently.</p>\n<p>(I can't convince myself this would be sufficient... Maybe it's sufficient for CSE to respect that these NaNs are not equal to each other, but that's likely a road leading toward inefficiently compiled code.)</p>",
        "id": 563944686,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1765842485
    },
    {
        "content": "<p>that was option 1 in gabriel's issue I think</p>",
        "id": 563944710,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765842508
    },
    {
        "content": "<p>I think it would work, you just need a special erased value which means \"the set of values this could represent are not necessarily all <code>=</code>\"</p>",
        "id": 563944795,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765842588
    },
    {
        "content": "<p>ideally this would be a marker on the ABI type rather than a value though</p>",
        "id": 563944912,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765842689
    },
    {
        "content": "<p>Some sort of \"can do safe ptrEq\" analysis seems appealing, since this should all be statically knowable, right? (Assuming monomorphizing is an acceptable cost.)</p>\n<p>It seems like it's an a similar direction to an ST analysis we talked about at some point, that for soundness verification, it's sufficient to verify that the types can be faithfully represented using Lean's runtime types. (Or, for a less runtime-specific point of view, that it's possible to encode/decode the type's values using an \"<code>STValue</code>\" inductive; then we pretend ST actually is recording encoded <code>STValue</code> values.) This hasn't yet been a practical soundness issue though, right?</p>",
        "id": 563945899,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1765843364
    },
    {
        "content": "<p>I think <code>withPtrEq</code> is very difficult to use and so I haven't run into these issues much because I don't even try</p>",
        "id": 563946103,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765843499
    },
    {
        "content": "<p>However, in lean4lean there is some use of <code>ptrAddr</code> which I manually monomorphized because I was worried about issues like this; that's not enough to make it sound though and it's not really practical to work inside a big quotient</p>",
        "id": 563946192,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765843576
    },
    {
        "content": "<p>I'm not even sure it's possible for l4l in the sense that it can actually give different behaviors depending on caching order</p>",
        "id": 563946269,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765843615
    },
    {
        "content": "<p><a href=\"https://github.com/digama0/lean4lean/blob/master/Lean4Lean/PtrEq.lean\">https://github.com/digama0/lean4lean/blob/master/Lean4Lean/PtrEq.lean</a></p>\n<p>^ I'll be happy if you find a better way to do this</p>",
        "id": 563946391,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765843706
    },
    {
        "content": "<p>Is this discussion somewhat related to the concept of <a href=\"https://en.wikipedia.org/wiki/%CE%A9-consistent_theory\">omega-inconsistency</a>? In particular the part about how you can prove <code>big ≠ 0</code>, <code>big ≠ 1</code>, <code>big ≠ 2</code>, and so on with <code>native_decide</code> if you had unlimited computational power.</p>",
        "id": 563965906,
        "sender_full_name": "Niels Voss",
        "timestamp": 1765861398
    },
    {
        "content": "<p>Yes, they're related.</p>",
        "id": 563969790,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765864744
    },
    {
        "content": "<p><del><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ω</mi></mrow><annotation encoding=\"application/x-tex\">\\omega</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span></span></span></span>-inconsistency is the same thing as not having an arithmetically standard model.</del> See Elliot's comment below.</p>",
        "id": 563969806,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765864764
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"904624\">@James E Hanson</span> Just to check, an arithmetically nonstandard model means it's still a model of peano arithmetic, right? The Lean runtime values for the <code>LazyNat</code> type don't form a model of peano arithmetic (one interpretation is that it's <code>Nat</code> with two extra elements: one for <code>big</code> and one for nonterminating computations).</p>",
        "id": 563969994,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1765864864
    },
    {
        "content": "<p>I'm not even completely certain yet that you can't get the Lean compiler to 'prove' false (via <code>native_decide</code>) using <code>big</code>.</p>",
        "id": 563970041,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1765864892
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> The model being exposed here through native_decide evaluations has the following elements:</p>\n<ul>\n<li><code>Nat</code></li>\n<li>a doubly infinite sequence <code>inf : Int -&gt; Lazy</code> such that <code>inf n = succ (fun _ =&gt; inf (n-1))</code></li>\n</ul>\n<p>There is no element for nonterminating computations. You can't observe (and hence obtain a native_decide axiom for) any computation that directly involves running a nonterminating subexpression.</p>",
        "id": 563984227,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765872920
    },
    {
        "content": "<p>here <code>inf 0</code> is <code>nonstandard</code>, <code>inf (-n)</code> are the sequence of values you obtain by pattern matching it and seeing the chain of <code>succ</code>'s, and <code>inf n</code> are the values you can construct by wrapping it in <code>succ</code>'s</p>",
        "id": 563984500,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765873049
    },
    {
        "content": "<p>You can construct <code>nonstandard'</code> with the same definition and you will get another infinite sequence but you won't be able to relate any of the values to <code>inf</code> so it may actually be the same sequence</p>",
        "id": 563984667,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765873118
    },
    {
        "content": "<p>when you \"complete\" this using lean logic to prove the existence of more elements given these, you end up with a nonstandard model of Nat.</p>",
        "id": 563984847,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765873180
    },
    {
        "content": "<p>So the point is that if we define</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">In</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">...</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>even through pointer equality, it is not possible to check that the inner <code>f</code> is the same as the outer <code>f</code>?</p>",
        "id": 564026703,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1765887002
    },
    {
        "content": "<p>basically yes, because <code>f</code> isn't itself a lean object, <code>papp f #[env...]</code> is, where <code>env</code> is some tuple of variables which are pre-applied to the function. In this case <code>env</code> is empty, but nevertheless <code>papp f #[]</code> doesn't have value semantics, it is generative so every time you run the code you get a new object. In some cases you might get lucky and it won't generate distinct objects but usually it will make a fresh object. It's not too different from the semantics of a constructor: <code>(a, b)</code> will construct a new tuple containing <code>a</code> and <code>b</code>, and every time you run code that does this you get an object with a different address, unless you get lucky and two objects are created near enough to be CSE'd together</p>",
        "id": 564050802,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765894191
    },
    {
        "content": "<p>In your example, the \"outer <code>f</code>\" isn't a lean object but the inner one is. You have two uses of <code>f</code>, so they will most likely both refer to the same object, but if you call that object to recurse, the recursion will almost certainly generate a separate object for its two uses of <code>f</code>, even if <code>x : In</code> is just <code>() : Unit</code></p>",
        "id": 564051495,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765894353
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/563984847\">said</a>:</p>\n<blockquote>\n<p>you end up with a nonstandard model of Nat.</p>\n</blockquote>\n<p>What sense of the word 'model' are you using here specifically?</p>",
        "id": 564082500,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765901942
    },
    {
        "content": "<p>what sense is there other than the usual?</p>",
        "id": 564085357,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765902711
    },
    {
        "content": "<p>If we want a model of Nat that contains an infinite decreasing sequence of elements that's necessarily nonstandard</p>",
        "id": 564085501,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765902748
    },
    {
        "content": "<p>I guess your phrasing makes it sound like you're somehow getting a <em>specific</em> non-standard model, rather than a theory whose models are all non-standard.</p>",
        "id": 564086716,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765903051
    },
    {
        "content": "<p>I'm describing (envisioning) a model construction procedure, maybe something like a Henkin model</p>",
        "id": 564086893,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765903105
    },
    {
        "content": "<p>where you start from some particular elements you've been told exist and then build all the things you can build from that</p>",
        "id": 564087031,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765903145
    },
    {
        "content": "<p>The axioms you can extract here from <code>native_decide</code> are effectively the usual axioms for nonstandard PA: Nat is a type with an induction principle, also <code>big</code> is a nat and <code>big &gt; 0, 1, 2, ...</code></p>",
        "id": 564087354,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765903231
    },
    {
        "content": "<p>It seems to me that it would be good to be very clear about the assumptions here to say what \"the\" model being exposed is.</p>\n<ul>\n<li>First of all there's the runtime model itself. If we ignore pointer equality and only look at observable behavior, the elements are the standard natural numbers, plus <code>nonstandard</code>, plus nontermination. We can observe nontermination by proving properties of the runtime itself <em>outside</em> of Lean.</li>\n<li>Second, there's the runtime model itself with pointer equality. With this, the elements generated by <code>nonstandard</code> are the <code>int n</code> elements. It's possible to make programs that can distinguish between them.</li>\n<li>Third, there's this second runtime model, pulled back into Lean using <code>native_decide</code>, and then you take the logical consequence of these elements from within Lean. This takes a step from <em>outside</em> the theory though, where we use the observation that <code>nonstandard</code> doesn't equal any of the standard <code>Nat</code>s to conclude it isn't any of them. It also takes the assumption that since <code>LazyNat</code> models the naturals, it must then be a nonstandard model. (However, only <em>some</em> of the nonstandard elements are obviously realized in the runtime model. The rest don't seem to be present, just posited. Maybe you can get the rest syntactically from within Lean using logic I don't know though.)</li>\n</ul>",
        "id": 564087966,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1765903382
    },
    {
        "content": "<p>The runtime model does <em>not</em> have a nontermination element</p>",
        "id": 564088172,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765903435
    },
    {
        "content": "<p>Says you Mario <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span>. I can observe nontermination, and I can open up a debugger, see what's going on, and then prove it on paper.</p>",
        "id": 564088311,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1765903472
    },
    {
        "content": "<p>What is 'the runtime model'?</p>",
        "id": 564088349,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765903481
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> Please prove it on paper</p>",
        "id": 564088447,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765903501
    },
    {
        "content": "<p>I assert that there are no computations you can perform which give you an axiom out of native_decide saying a nontermination element exists</p>",
        "id": 564088578,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765903535
    },
    {
        "content": "<p>that could be wrong but I want to see the counterexample if so</p>",
        "id": 564088640,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765903550
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"904624\">@James E Hanson</span> It's the objects that the Lean runtime manipulates when evaluating something like <code>nonstandard</code>. It's not manipulating Lean expressions, but other sorts of objects.</p>",
        "id": 564088734,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1765903577
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> That's sort of my point — I didn't agree to the condition that observational behavior means I can import an axiom into Lean using <code>native_decide</code>. I think that's obscuring things. Hence my separating this into three different components. The third one doesn't admit nonterminating elements.</p>",
        "id": 564089033,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1765903664
    },
    {
        "content": "<blockquote>\n<ul>\n<li>First of all there's the runtime model itself. If we ignore pointer equality and only look at observable behavior, the elements are the standard natural numbers, plus <code>nonstandard</code>, plus nontermination. We can observe nontermination by proving properties of the runtime itself <em>outside</em> of Lean.</li>\n</ul>\n</blockquote>\n<p>What's missing here is that there is no bisimulation principle, so there can well be many elements which are all distinct and are all an infinite chain of succs</p>",
        "id": 564089049,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765903668
    },
    {
        "content": "<p>just because two elements are observably equivalent doesn't mean they are the same in the runtime model or in the lean model</p>",
        "id": 564089226,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765903711
    },
    {
        "content": "<p>Yeah, I was going to say, it should be fairly easy to build other terms like <code>nonstandard</code> that aren't provably or observably equal to <code>nonstandard</code>.</p>",
        "id": 564089243,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765903715
    },
    {
        "content": "<p>the lean axioms are actually inconsistent with them being the same, and by mostly luck the runtime model also doesn't make them the same because of the allocation semantics</p>",
        "id": 564089394,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765903751
    },
    {
        "content": "<p>This is probably a minor point, but the runtime model isn't really a 'model' in the sense we were discussing a moment ago, right?</p>",
        "id": 564089666,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765903830
    },
    {
        "content": "<p>It is a partial model?</p>",
        "id": 564089767,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765903860
    },
    {
        "content": "<p>It is kind of a \"ground truth\" we can use to obtain lots of axioms by evaluation</p>",
        "id": 564089841,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765903880
    },
    {
        "content": "<p><code>native_decide</code> effectively says anything observably true in the runtime model is admitted as an axiom</p>",
        "id": 564089971,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765903919
    },
    {
        "content": "<p>So you're conceptualizing it as a model in the sense that we can query it in order to determine facts without actually proving them, right?</p>",
        "id": 564090075,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765903947
    },
    {
        "content": "<p>yes basically</p>",
        "id": 564090151,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765903964
    },
    {
        "content": "<p>I think it walks and talks like a model though</p>",
        "id": 564090201,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765903980
    },
    {
        "content": "<p>maybe universal sentences are dicey on it</p>",
        "id": 564090281,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765904006
    },
    {
        "content": "<p>it is a model in the sense that it has a domain of objects and an interpretation of functions</p>",
        "id": 564090413,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765904049
    },
    {
        "content": "<p>the objects are all of the things you could construct via computation of lean expressions</p>",
        "id": 564090570,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765904091
    },
    {
        "content": "<p>but I'm not sure it has a well formed notion of equality on it or a general interpretation of the <code>=</code> function</p>",
        "id": 564090884,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765904187
    },
    {
        "content": "<p>Sure, I understand the fact that the word 'model' is often used in a more general sense.</p>\n<p>I just think it's maybe a little bit important to highlight the fact that this is something akin to the notion of a(n intuitionistic) term model in type theory. It isn't going to be a model of Lean with classical choice (and therefore LEM).</p>",
        "id": 564091012,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765904227
    },
    {
        "content": "<p>unclear?</p>",
        "id": 564091115,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765904255
    },
    {
        "content": "<p>Well you certainly don't have an implementation of, say, a halting oracle in the Lean runtime model.</p>",
        "id": 564091235,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765904289
    },
    {
        "content": "<p>There are lots of things that diverge, so sometimes instead of \"yes or no\" you get \"yes or diverge\"</p>",
        "id": 564091258,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765904297
    },
    {
        "content": "<p>so the interpretation of functions is partial</p>",
        "id": 564091334,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765904318
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>, if you want to stick to <code>native_decide</code> being the arbiter here, then tell me why I should be convinced that <code>nonstandard</code> isn't one of the standard natural numbers?</p>",
        "id": 564091355,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1765904323
    },
    {
        "content": "<p>I thought that Mario had said that given the recursion limit in practice, you could think of <code>nonstandard</code> as being a large standard natural number?</p>",
        "id": 564091528,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765904375
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Does the runtime model make explicit decisions about equality of types? Or is that related to your earlier comment about <code>=</code>?</p>",
        "id": 564091826,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765904447
    },
    {
        "content": "<p>Even without that recursion limit, it seems inconsistent to me to say that <code>nonstandard</code> is nonstandard, if the only admissible interpretation of terms is via <code>native_decide</code>.</p>",
        "id": 564091854,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1765904454
    },
    {
        "content": "<p>As I mentioned above, you very well can. The issue is that if you decide <code>nonstandard</code> is 37 then later you might have a computation that invalidates this interpretation. If you want a single interpretation that is stable under future axioms you could get from a hypothetical future <code>native_decide</code> evaluation, and the computer on which is runs is abstracted and has no implementation limits, then you get the axiom system <code>big &gt; 0, 1, ...</code> which is nonstandard PA</p>",
        "id": 564091858,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765904454
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"904624\">@James E Hanson</span> No it does not, there are no type equalities you can resolve one way or another using <code>native_decide</code></p>",
        "id": 564092042,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765904500
    },
    {
        "content": "<p>You're doing reasoning outside of Lean there though, right? Why can you do that, but I can't say \"<code>native_decide</code> diverges here\"</p>",
        "id": 564092055,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1765904504
    },
    {
        "content": "<p>I'm meta-reasoning about the axiom system specified by a hypothetical lean typechecker with unbounded memory</p>",
        "id": 564092206,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765904546
    },
    {
        "content": "<p>If <code>native_decide</code> diverges, then you don't get an axiom</p>",
        "id": 564092284,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765904568
    },
    {
        "content": "<p>the definition of the <code>native_decide</code> axiom schema is that you run the program, observe it returns <code>true</code>, then accept the boolean is equal to true as an axiom</p>",
        "id": 564092418,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765904602
    },
    {
        "content": "<p>so if you define <code>partial def loop : Bool := loop</code> then you get no <code>native_decide</code> axiom proving it is equal to either true or false because if you try to work with it the computation diverges so you get nothing</p>",
        "id": 564092658,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765904671
    },
    {
        "content": "<p>by contrast, the <code>nonstandard : LazyNat</code> because of laziness can be unfolded and so you can observe it has at least <code>n</code> succs for each <code>n</code></p>",
        "id": 564092900,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765904742
    },
    {
        "content": "<p>By the way, when I was playing around with <code>native_decide</code>, I never saw an instance of it using <code>Lean.ofReduceNat</code>. When does this happen?</p>",
        "id": 564092963,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765904762
    },
    {
        "content": "<p>and so the theoretical extent of all axioms you can extract from this object is the set of all such big &gt; n axioms</p>",
        "id": 564093017,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765904780
    },
    {
        "content": "<p>unless you can find another way to use <code>native_decide</code> to find more things about the object</p>",
        "id": 564093083,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765904801
    },
    {
        "content": "<p><code>ofReduceNat</code> is never used by lean, I think it can be deleted</p>",
        "id": 564093141,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765904820
    },
    {
        "content": "<p>you can use it manually or in a tactic if you want but there isn't much need for it</p>",
        "id": 564093196,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765904839
    },
    {
        "content": "<p>What is the point of having both <code>Lean.trustCompiler</code> and <code>Lean.ofReduceBool</code>?</p>",
        "id": 564093293,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765904863
    },
    {
        "content": "<p>this is a workaround for the fact that you can prove extra things already just using <code>reduceBool</code> without <code>ofReduceBool</code></p>",
        "id": 564093414,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765904899
    },
    {
        "content": "<p>Ah, what's an example of that?</p>",
        "id": 564093531,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765904933
    },
    {
        "content": "<p>if you put a nondeterministic function in there you can prove false</p>",
        "id": 564093699,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765904975
    },
    {
        "content": "<p>Is it possible for something to only use <code>Lean.ofReduceBool</code>? I'm guessing not because even this doesn't work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">ofReduceBoolTest</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">ofReduceBool</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">ofReduceBool</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">axioms</span><span class=\"w\"> </span><span class=\"n\">ofReduceBoolTest</span>\n<span class=\"c1\">-- 'ofReduceBoolTest' depends on axioms: [Lean.ofReduceBool, Lean.trustCompiler]</span>\n</code></pre></div>",
        "id": 564093905,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765905027
    },
    {
        "content": "<p><a class=\"message-link\" href=\"/#narrow/channel/270676-lean4/topic/soundness.20bug.3A.20native_decide.20leakage/near/395967589\">#lean4 &gt; soundness bug: native_decide leakage @ 💬</a></p>",
        "id": 564093962,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765905043
    },
    {
        "content": "<p>As long as you define axiom tracking such that it looks at the types of axioms, no it's not possible because <code>ofReduceBool</code> has a type which uses <code>reduceBool</code> which uses <code>trustCompiler</code></p>",
        "id": 564094298,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765905132
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/564093962\">said</a>:</p>\n<blockquote>\n<p><a class=\"message-link\" href=\"/#narrow/channel/270676-lean4/topic/soundness.20bug.3A.20native_decide.20leakage/near/395967589\">#lean4 &gt; soundness bug: native_decide leakage @ 💬</a></p>\n</blockquote>\n<p>I assume this isn't still possible because the way IO works changed?</p>",
        "id": 564094492,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765905184
    },
    {
        "content": "<p>it doesn't matter, you can use <code>extern</code> for the same effect</p>",
        "id": 564094582,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765905205
    },
    {
        "content": "<p>it's just defined as not a problem now</p>",
        "id": 564094696,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765905235
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/564094582\">said</a>:</p>\n<blockquote>\n<p>it doesn't matter, you can use export for the same effect</p>\n</blockquote>\n<p>As in using <code>implemented_by</code>?</p>",
        "id": 564094783,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765905257
    },
    {
        "content": "<p>I guess you could use that as well, with some unsafePerformIO or whatever it's called</p>",
        "id": 564094985,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765905305
    },
    {
        "content": "<p><code>extern</code> lets you write C code which obviously can be impure</p>",
        "id": 564095070,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765905327
    },
    {
        "content": "<p>What is 'export' in this context then?</p>",
        "id": 564095224,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765905369
    },
    {
        "content": "<p>sorry, I meant <code>extern</code></p>",
        "id": 564095302,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765905385
    },
    {
        "content": "<p><code>@[extern my_c_function] opaque myLeanFunction : Nat -&gt; Nat</code></p>",
        "id": 564095375,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765905406
    },
    {
        "content": "<p><code>lean_object* my_c_function(lean_object* x) { return ... }</code></p>",
        "id": 564095473,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765905441
    },
    {
        "content": "<p>something like that</p>",
        "id": 564095514,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765905460
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek Olšák</span> <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/562830687\">said</a>:</p>\n<blockquote>\n<p>Well, once we have a nonstandard natural number <code>big : Nat</code>, then this should be at least an eval-consistent interpretation of <code>partial def</code> , right?</p>\n</blockquote>\n<p>You might be interested in the approach that popped up in my head after reading your ideas: <a class=\"message-link\" href=\"/#narrow/channel/270676-lean4/topic/Extrinsic.20termination.20proofs.20for.20well-founded.20recursion/near/564822906\">#lean4 &gt; Extrinsic termination proofs for well-founded recursion @ 💬</a> In short, the idea is to use a partial function returning a subtype. If chosen wisely, the subtypes contain enough information for proving fixpoint equations for it after the fact, even in <code>def f x := ... f (f (x/2)) ...</code> situations. We get a computable fixpoint (that might run forever) and don't need to use any unsafe language features.</p>\n<p>It looks like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Pred</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\"> omitted -/</span>\n\n<span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">fixAttach</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Subtype</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Pred</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">⟨</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">fixAttach</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">val</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\"> omitted here -/</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">fix</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">fixAttach</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f91</span><span class=\"bp\">.</span><span class=\"n\">functional</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">recurse</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">100</span>\n<span class=\"w\">    </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">10</span>\n<span class=\"w\">    </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">recurse</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">recurse</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">11</span><span class=\"o\">))</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f91</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">fix</span><span class=\"w\"> </span><span class=\"n\">f91</span><span class=\"bp\">.</span><span class=\"n\">functional</span><span class=\"w\"> </span><span class=\"n\">n</span>\n</code></pre></div>",
        "id": 564823745,
        "sender_full_name": "Paul Reichert",
        "timestamp": 1766232338
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"904624\">James E Hanson</span> <a href=\"#narrow/channel/113488-general/topic/possible.20semantics.20for.20partial.20functions/near/563969806\">said</a>:</p>\n<blockquote>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ω</mi></mrow><annotation encoding=\"application/x-tex\">\\omega</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span></span></span></span>-inconsistency is the same thing as not having an arithmetically standard model.</p>\n</blockquote>\n<p>Existence of an arithmetically standard model, i.e. an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ω</mi></mrow><annotation encoding=\"application/x-tex\">\\omega</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span></span></span></span>-model, is slightly stronger. If M is a minimal <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ω</mi></mrow><annotation encoding=\"application/x-tex\">\\omega</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span></span></span></span>-model of ZFC, then M satisfies that ZFC is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ω</mi></mrow><annotation encoding=\"application/x-tex\">\\omega</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span></span></span></span>-consistent but has no  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ω</mi></mrow><annotation encoding=\"application/x-tex\">\\omega</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span></span></span></span>-model. <a href=\"https://mathoverflow.net/a/267837\">There are</a> also incompatible <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ω</mi></mrow><annotation encoding=\"application/x-tex\">\\omega</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span></span></span></span>-consistent extensions of PA.</p>",
        "id": 570241765,
        "sender_full_name": "Elliot Glazer",
        "timestamp": 1769494720
    }
]