[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"776090\">@GasStationManager</span> do you have any suggestions as to how <code>native_decide</code> could get to the point where we could rigorously trust it? It seems to me that this would require formally verifying the Lean compiler, a task which might require tens of millions of dollars of labor. It seems like such a task would be harder than the compcert project in Coq/Rocq. But maybe there's a cheaper way that I haven't thought of?</p>",
        "id": 517391334,
        "sender_full_name": "Niels Voss",
        "timestamp": 1746993271
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"521331\">@Niels Voss</span> I think that is an important question. I believe it is a very worthwhile goal to aim for. I do appreciate that it would be very technically challenging, but perhaps Lean is closer to it than most other general purpose programming languages. As for whether there is a cheaper way,  here's my hot take as an non-expert: I think in the near future AIs will become good enough in Lean to take on a lot of the labor; the key question is whether we will be able to verify their work in a trusted way.</p>",
        "id": 517396409,
        "sender_full_name": "GasStationManager",
        "timestamp": 1746997497
    },
    {
        "content": "<p>Kind-of relevant: my work-in-progress to get LLMs to produce (correct) Lean code and proof sketch of correctness: <a href=\"https://gasstationmanager.github.io/ai/2025/03/28/alphabeta.html\">https://gasstationmanager.github.io/ai/2025/03/28/alphabeta.html</a></p>",
        "id": 517397201,
        "sender_full_name": "GasStationManager",
        "timestamp": 1746998226
    },
    {
        "content": "<p>I think there are better approaches to making a trustworthy native_decide than to formally verify Lean's whole compiler (whatever that means).  First, a huge trust factor could be increased by making a version without known exploits, where unsoundness would mean a real compiler bug.  Second, one could use native_decide (and other less trustworthy tools) as first approximations of truth, and later replace them with proofs using more trustworthy tactics.  Third, one could create a trustworthy tactic (like a super_norm_num) which covers a lot of common cases normally handled by <code>native_decide</code>.  It wouldn't have to cover everything at first, and could grow to cover more and more common cases.  Fourth, instead of formally verifying a compiler, one could formally verify in Lean4Lean speed improvements to the existing kernel (stealing ideas from other sources).  It is scary and dangerous to modify the kernel, but if one does it under the safety of formal verification, then one could make safe and practical improvements.  (I don't know if any of these are  feasible, of course, but I've seen <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> mention some of them in places.)</p>",
        "id": 517408211,
        "sender_full_name": "Jason Rute",
        "timestamp": 1747009277
    },
    {
        "content": "<p>Currently, lean4lean does not support <code>native_decide</code>, and I have idly considered what it would take to make it work; it amounts to formalizing the lean IR and enough of the compiler pipeline to prove that the IR that is run bears some resemblance to the lean kernel term. This is especially problematic because the kernel term and the IR are both separately lowered from the pre-definition, which is not stored at all, so there is actually some missing information if one wanted to verify .olean files directly (as I do)</p>",
        "id": 517408420,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747009497
    },
    {
        "content": "<p>By \"speed improvements to the kernel\" do you mean extensions to the kernel which let it typecheck a certain subset of proofs using custom algorithms? (Kind of like how we can typecheck stuff like <code>3+4=7</code> using GMP instead of reducing to Peano axioms)</p>",
        "id": 517408510,
        "sender_full_name": "Niels Voss",
        "timestamp": 1747009575
    },
    {
        "content": "<p>there are lots of ways that the kernel algorithm is just not good. It's not really optimized at all</p>",
        "id": 517408530,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747009608
    },
    {
        "content": "<p>A limited scope <code>super_norm_num</code> that focuses on just the pure computation parts and not implemented_by / extern shenanigans would be very useful for people who want to use <code>native_decide</code> as a decision procedure for computationally heavy proofs</p>",
        "id": 517408694,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747009760
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"521331\">Niels Voss</span> <a href=\"#narrow/channel/219941-Machine-Learning-for-Theorem-Proving/topic/A.20more.20robust.20RL.20pipeline.3F/near/517408510\">said</a>:</p>\n<blockquote>\n<p>By \"speed improvements to the kernel\" do you mean extensions to the kernel which let it typecheck a certain subset of proofs using custom algorithms? (Kind of like how we can typecheck stuff like <code>3+4=7</code> using GMP instead of reducing to Peano axioms)</p>\n</blockquote>\n<p>Do we really use GMP directly for working with natural numbers in the kernel?</p>",
        "id": 517408780,
        "sender_full_name": "Jason Rute",
        "timestamp": 1747009817
    },
    {
        "content": "<p>yes</p>",
        "id": 517408851,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747009894
    },
    {
        "content": "<p>not just that, the list of primitives has been steadily expanding and not one but two soundness bugs have been introduced because of this</p>",
        "id": 517408915,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747009934
    },
    {
        "content": "<p>So if I duplicated the <code>Nat</code> with a custom <code>MyNat</code> (same definition), it would be noticeably slower (in the kernel)?</p>",
        "id": 517408948,
        "sender_full_name": "Jason Rute",
        "timestamp": 1747009984
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"115715\">Jason Rute</span> <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/A.20more.20robust.20RL.20pipeline.3F/near/517408211\">said</a>:</p>\n<blockquote>\n<p>I think there are better approaches to making a trustworthy native_decide than to formally verify Lean's whole compiler (whatever that means).  First, a huge trust factor could be increased by making a version without known exploits, where unsoundness would mean a real compiler bug.  Second, one could use native_decide (and other less trustworthy tools) as first approximations of truth, and later replace them with proofs using more trustworthy tactics.  Third, one could create a trustworthy tactic (like a super_norm_num) which covers a lot of common cases normally handled by <code>native_decide</code>.  It wouldn't have to cover everything at first, and could grow to cover more and more common cases.  Fourth, instead of formally verifying a compiler, one could formally verify in Lean4Lean speed improvements to the existing kernel (stealing ideas from other sources).  It is scary and dangerous to modify the kernel, but if one does it under the safety of formal verification, then one could make safe and practical improvements.  (I don't know if any of these are  feasible, of course, but I've seen <span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> mention some of them in places.)</p>\n</blockquote>\n<p>It sounds to me like your second through fourth points here are more about reducing the need for <code>native_decide</code> than actually making native decide more trustworthy. Which is still worth it, but it's not really the same thing. Unless you're were thinking that your <code>super_norm_num</code> is some intermediate trusted state</p>",
        "id": 517409036,
        "sender_full_name": "Niels Voss",
        "timestamp": 1747010051
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/blob/33aaabaed7adf810adcc35e2535cc7eff991d7b8/src/kernel/type_checker.cpp#L634-L647\">here</a> is the current list of kernel primitives</p>",
        "id": 517409053,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747010082
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"115715\">Jason Rute</span> <a href=\"#narrow/channel/219941-Machine-Learning-for-Theorem-Proving/topic/A.20more.20robust.20RL.20pipeline.3F/near/517408948\">said</a>:</p>\n<blockquote>\n<p>So if I duplicated the <code>Nat</code> with a custom <code>MyNat</code> (same definition), it would be noticeably slower (in the kernel)?</p>\n</blockquote>\n<p>Yes, it would be extremely slow because it would work in unary</p>",
        "id": 517409075,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747010107
    },
    {
        "content": "<p>Plus, GasStationManager said he cared about verifying programs, not just proofs with <code>native_decide</code></p>",
        "id": 517409083,
        "sender_full_name": "Niels Voss",
        "timestamp": 1747010127
    },
    {
        "content": "<p>you don't need native_decide to write programs</p>",
        "id": 517409104,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747010158
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/219941-Machine-Learning-for-Theorem-Proving/topic/A.20more.20robust.20RL.20pipeline.3F/near/517409053\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://github.com/leanprover/lean4/blob/33aaabaed7adf810adcc35e2535cc7eff991d7b8/src/kernel/type_checker.cpp#L634-L647\">here</a> is the current list of kernel primitives</p>\n</blockquote>\n<p>That's so many more than I thought there would be</p>",
        "id": 517409105,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1747010158
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"521331\">@Niels Voss</span>  It is the end goal that is important, not the road to getting there, right?  I think <code>native_decide</code> is more of a crutch than a desired tool.  Native decide isn't for verifying code any more than other tactics, no?</p>",
        "id": 517409107,
        "sender_full_name": "Jason Rute",
        "timestamp": 1747010160
    },
    {
        "content": "<p>Yes, I definitely agree with you. If we can remove the need for <code>native_decide</code> that will be just as good as getting to the point where we can trust it. I'm just saying that this wouldn't be sufficient to do what GasStationManager wants, which is to trust executable programs.</p>",
        "id": 517409216,
        "sender_full_name": "Niels Voss",
        "timestamp": 1747010267
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"776090\">GasStationManager</span> <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/A.20more.20robust.20RL.20pipeline.3F/near/517382093\">said</a>:</p>\n<blockquote>\n<p>What if (like me) someone wants to have provable guarantees on the behavior of executable code, and therefore need to be able to trust the compiler in addition to the kernel?</p>\n</blockquote>\n<p>This was the quote I was thinking of</p>",
        "id": 517409288,
        "sender_full_name": "Niels Voss",
        "timestamp": 1747010328
    },
    {
        "content": "<p>you need something like cakeml, compcert or MM0 for foundational trust of executables. That's not in lean's future</p>",
        "id": 517409294,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747010339
    },
    {
        "content": "<p>but you can still verify things modulo the compiler. The problem is that the current compiler is unsound by design and we need some reasonable bounds on that before we can make progress on provable anything</p>",
        "id": 517409331,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747010392
    },
    {
        "content": "<p>Lean 5? <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 517409380,
        "sender_full_name": "Jason Rute",
        "timestamp": 1747010418
    },
    {
        "content": "<p>it could be as simple as just banning or whitelisting implemented_by and extern and tracking the axioms used in <code>@[csimp]</code> proofs</p>",
        "id": 517409423,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747010468
    },
    {
        "content": "<p>this largely can't be done post-hoc, because the .olean file just has the compiled result and does not describe the path it took to get there</p>",
        "id": 517409444,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747010511
    },
    {
        "content": "<p>How confident are you that the current set of implemented_by and extern in Lean core is consistent?</p>",
        "id": 517409520,
        "sender_full_name": "Niels Voss",
        "timestamp": 1747010566
    },
    {
        "content": "<p>it's definitely not</p>",
        "id": 517409526,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747010576
    },
    {
        "content": "<p>people fool with IO functions all the time</p>",
        "id": 517409546,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747010602
    },
    {
        "content": "<p><a href=\"#narrow/channel/113488-general/topic/Using.20.60native_decide.60.20to.20prove.20False.3F\">#general &gt; Using &#96;native_decide&#96; to prove False?</a> See the last examples.</p>",
        "id": 517409552,
        "sender_full_name": "Jason Rute",
        "timestamp": 1747010613
    },
    {
        "content": "<p>but that's again by design. The list of axioms in lean is also inconsistent by design because <code>sorryAx</code> is in there</p>",
        "id": 517409607,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747010642
    },
    {
        "content": "<p>Well if we make IO.RealWorld opaque, that would at least prevent some of the obvious exploits, right?</p>",
        "id": 517409614,
        "sender_full_name": "Niels Voss",
        "timestamp": 1747010643
    },
    {
        "content": "<p>so the answer is just to have a way to track what subset of axiomatically strong things you are touching</p>",
        "id": 517409640,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747010670
    },
    {
        "content": "<p>i.e. <code>#print axioms</code> for native_decide</p>",
        "id": 517409680,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747010712
    },
    {
        "content": "<p>That sounds like it might be worth having</p>",
        "id": 517409727,
        "sender_full_name": "Niels Voss",
        "timestamp": 1747010750
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"521331\">Niels Voss</span> <a href=\"#narrow/channel/219941-Machine-Learning-for-Theorem-Proving/topic/A.20more.20robust.20RL.20pipeline.3F/near/517409614\">said</a>:</p>\n<blockquote>\n<p>Well if we make IO.RealWorld opaque, that would at least prevent some of the obvious exploits, right?</p>\n</blockquote>\n<p>No, IO has to not be a function type. Even if IO.RealWorld is an opaque type you can still use the function type to \"rewind time\" in ways that don't accord with the real implementation and observe invalid behavior that way</p>",
        "id": 517409807,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747010810
    },
    {
        "content": "<p>Yeah, I remember that being discussed here <a href=\"#narrow/stream/270676-lean4/topic/Semantics.20of.20IO.20don't.20match.20provable.20properties.3F\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Semantics.20of.20IO.20don't.20match.20provable.20properties.3F</a></p>",
        "id": 517409959,
        "sender_full_name": "Niels Voss",
        "timestamp": 1747010967
    },
    {
        "content": "<p>But I'm not sure how that lets you prove <code>False</code> (I could see how it might let you prove <code>BaseIO False</code>)</p>",
        "id": 517410094,
        "sender_full_name": "Niels Voss",
        "timestamp": 1747011077
    },
    {
        "content": "<p>that's for a slightly different thing, about ST not having a good axioms. Here the issue is that you can cache old <code>IO.RealWorld</code> values and reuse them, and the lean model will think that this means you rewound the state of the world but the implementation ignores the token so it will not be rewound</p>",
        "id": 517410114,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747011111
    },
    {
        "content": "<p>I think I understand now</p>",
        "id": 517410232,
        "sender_full_name": "Niels Voss",
        "timestamp": 1747011209
    },
    {
        "content": "<p>Maybe we can cut this conversation at <span class=\"user-mention\" data-user-id=\"521331\">@Niels Voss</span> first message and below and move it to its own thread.  I think others (with no interest in ML) would find this interesting?</p>",
        "id": 517410240,
        "sender_full_name": "Jason Rute",
        "timestamp": 1747011222
    },
    {
        "content": "<p>(I don't have such permissions.  Do you <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>?)</p>",
        "id": 517410324,
        "sender_full_name": "Jason Rute",
        "timestamp": 1747011278
    },
    {
        "content": "<p>42 messages were moved here from <a class=\"stream-topic\" data-stream-id=\"219941\" href=\"/#narrow/channel/219941-Machine-Learning-for-Theorem-Proving/topic/A.20more.20robust.20RL.20pipeline.3F/with/517280593\">#Machine Learning for Theorem Proving &gt; A more robust RL pipeline?</a> by <span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span>.</p>",
        "id": 517410370,
        "sender_full_name": "Notification Bot",
        "timestamp": 1747011332
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  In the spirit of this thread, I was curious: while the current compiler is unsound, could a subset of the language be verified? E.g. pure functions without IO?</p>",
        "id": 517614216,
        "sender_full_name": "GasStationManager",
        "timestamp": 1747070615
    },
    {
        "content": "<p>Depends on what you mean by verified, but in the most basic sense, yes, or more precisely there are no known obvious counterexamples to the claim which is quite different from having a strategy to actually accomplish the task</p>",
        "id": 517614560,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747070699
    },
    {
        "content": "<p>well, no known counterexamples other than the ones that have already been mentioned <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 517614716,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747070739
    }
]