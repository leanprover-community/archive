[
    {
        "content": "<p>I must admit that I don't completely understand the difference between definitional equality and equality. That's probably why the following statement in <a href=\"https://leanprover-community.github.io/mathematics_in_lean/C09_Groups_and_Rings.html#quotient-groups\">Mathematics in Lean</a> about quotient groups gives me a hard time:</p>\n<blockquote>\n<p>the type <code>G ‚ß∏ N</code> really depends on <code>N</code> (up to definitional equality), so having a proof that two normal subgroups <code>N</code> and <code>M</code> are equal is not enough to make the corresponding quotients equal.</p>\n</blockquote>\n<p>What's the issue here? I would expect that if <code>f : Type ‚Üí Type</code> and <code>N = M</code>, then <code>f N = f M</code>. Is that true, and if so, doesn't it resolve the above problem?  </p>\n<p>Further, in ordinary math, N = M implies G/N = G/M. Is it at all problematic that math-equality and Lean-equality diverge here?</p>",
        "id": 560954168,
        "sender_full_name": "Axel Boldt",
        "timestamp": 1764460240
    },
    {
        "content": "<p>The sentence does not seem to be accurate as it is. If <code>N</code> is definitionally equal to <code>N'</code>, then <code>G ‚ß∏ N</code> is definitionally equal to <code>G ‚ß∏ N'</code>, and also if <code>N = N'</code> then <code>G ‚ß∏ N = G ‚ß∏ N'</code>.</p>\n<p>The thing about mere propositional equality of types though is that it's got lots of bad properties. Basically you only ever want definitional equalities. The suggestion after that paragraph that if <code>N = N'</code> you get an isomorphism <code>G ‚ß∏ N =* G ‚ß∏ N'</code> is an important part of the picture, since this is how you can avoid propositional equalities of types.</p>\n<p>My guess is that the quoted sentence means to say \"is not enough to make the corresponding quotients <em>definitionally</em> equal\". The slip might be because definitional equal types is the only kind of equality you'd seriously consider (most of the time).</p>\n<p>Am I misunderstanding this, <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span>?</p>",
        "id": 560955612,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1764461731
    },
    {
        "content": "<p>That looks confusing to me too. I would expect <code>G / N = G / M</code> should be easily provable too, and this is just a warning about using such quotients in practice.</p>\n<p>Let me explain my view on definitional equality: Two expressions are definitionally equal if they are \"obviously enough\" equal to the kernel. There is a specific definition of what that means (expanding definitions, other reductions...) but that is a bit secondary. The most important moment if something is equal is when doing type checking. If we have an element <code>x : Fin (2+2)</code>, and we give it as an argument to a function that expects <code>Fin 4</code>, Lean will accept it with it because they are definitionally equal. On the other hand, if we have an element <code>x : Fin (a + b)</code>, and we try to plug it into a function expecting <code>Fin (b+a)</code>, Lean will complain, and it must be converted.</p>\n<p>To my knowledge this conversion should be always possible in principle to keep up with the standard mathematical expectations but can become so annoying in practice, that it is usually worth it to design things definitionally equal, so Lean accepts the retyping automatically.</p>",
        "id": 560955665,
        "sender_full_name": "Mirek Ol≈°√°k",
        "timestamp": 1764461792
    },
    {
        "content": "<p><a href=\"https://b-mehta.github.io/formalising-mathematics-notes/Part_1/equality.html\">Here</a> is what we teach the undergraduate (maths) students at Imperial about this.</p>",
        "id": 560955811,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1764461953
    },
    {
        "content": "<p>Re: </p>\n<blockquote>\n<p>Is it at all problematic that math-equality and Lean-equality diverge here?</p>\n</blockquote>\n<p>I would say \"no\". What is going on is that sometimes to prove that things are equal you can take a short cut and use <code>rfl</code> instead of giving the \"normal\" proof. So in fact the concept of definitional equality accelerates formalization of mathematics, rather than hindering it.</p>",
        "id": 560956054,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1764462262
    },
    {
        "content": "<p>Isn't the answer \"they don't diverge (here, at least)\"? Because indeed if N = M then G/N = G/M.</p>",
        "id": 560956283,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1764462469
    },
    {
        "content": "<p>That is true, but I would say that in Lean's type theory this would be an unwise way of thinking about things.</p>",
        "id": 560956350,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1764462537
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Subgroup.quotientEquivOfEq#doc\">docs#Subgroup.quotientEquivOfEq</a> (or even better <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=QuotientGroup.quotientMulEquivOfEq#doc\">docs#QuotientGroup.quotientMulEquivOfEq</a> ) is the function which gives the isomorphism <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mi mathvariant=\"normal\">/</mi><mi>M</mi><mo>‚âÖ</mo><mi>G</mi><mi mathvariant=\"normal\">/</mi><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">G/M\\cong G/N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚âÖ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> given a proof of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>=</mo><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">M=N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> and this is a much more robust approach because it avoids dependent type hell if the proof that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>=</mo><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">M=N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> is not <code>rfl</code>.</p>",
        "id": 560956494,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1764462688
    },
    {
        "content": "<p>(<span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> That second one is the function that's mentioned right after the quoted paragraph in MIL.)</p>",
        "id": 560956662,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1764462894
    },
    {
        "content": "<p>You can think about it this way: if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>‚äÜ</mo><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">M\\subseteq N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚äÜ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> are normal subgroups then it's certainly the case that there's a natural map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mi mathvariant=\"normal\">/</mi><mi>M</mi><mo>‚Üí</mo><mi>G</mi><mi mathvariant=\"normal\">/</mi><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">G/M\\to G/N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚Üí</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> and it's not \"the identity\", so you would not attempt to identify <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mi mathvariant=\"normal\">/</mi><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">G/M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mi mathvariant=\"normal\">/</mi><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">G/N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> in that case. In the case where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>‚äÜ</mo><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">M\\subseteq N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚äÜ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> happen to be equal you're still \"changing groups\" so you should still use a function to change groups rather than rely on equality of types, which is a slippery concept in type theory. Remember that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi><mo>=</mo><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\N=\\Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span> is undecidable in Lean!</p>",
        "id": 560956909,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1764463173
    },
    {
        "content": "<p>Coincidentally, I am just thinking about a lecture about definitional / provable equality, and I am always hitting weird edge cases. Like \"is <code>(fun a : ‚Ñï ‚Ü¶ a)</code> syntactically equal to <code>(fun b : ‚Ñï ‚Ü¶ b)</code>? Well no but almost yes because they are Bool-equal in metaprogramming... Or \"Is <code>Rat.add 1 1</code> definitionally equal to <code>(2 : ‚Ñö)</code>?\" well according to kernel they are,  but it doesn't feel that way because <code>Rat.add</code> has a nonreducible flag...</p>",
        "id": 560957042,
        "sender_full_name": "Mirek Ol≈°√°k",
        "timestamp": 1764463323
    },
    {
        "content": "<p>I tried to build the <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=QuotientGroup.quotientMulEquivOfEq#doc\">docs#QuotientGroup.quotientMulEquivOfEq</a> on my own, and it was not that bad</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">iso</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Subgroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">Normal</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">N</span><span class=\"bp\">.</span><span class=\"n\">Normal</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">‚ß∏</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">‚âÉ*</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">‚ß∏</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw!</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">eq</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">MulEquiv</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n</code></pre></div>\n<p>so it should be often possible to avoid these isomorphisms, and hope <code>rw!</code> would help with the DTT hell.</p>",
        "id": 560958184,
        "sender_full_name": "Mirek Ol≈°√°k",
        "timestamp": 1764464716
    },
    {
        "content": "<p>You don't get good defeqs</p>",
        "id": 560959478,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764466430
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=QuotientGroup.quotientMulEquivOfEq_mk#doc\">docs#QuotientGroup.quotientMulEquivOfEq_mk</a> is no longer a definitional equality</p>",
        "id": 560959526,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764466473
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek Ol≈°√°k</span> <a href=\"#narrow/channel/113488-general/topic/Equality.20vs.2E.20definitional.20equality.20when.20taking.20quotients/near/560958184\">said</a>:</p>\n<blockquote>\n<p>it was not that bad</p>\n</blockquote>\n<p>That's expected; for all of these definitions, there's a default implementation you can use that comes from substituting equalities and then using reflexivity of some sort. The key is that once you define such a function, you can add simp lemmas for equational reasoning. It's putting the rewrite behind an abstraction barrier, so to speak. There's little algebraic meaning to an \"unconstrained\" rewrite. The DTT design pattern we have is to write cast functions when we need to rewrite types, rather than rewriting the types directly.</p>\n<p>Aaron's point though is that sometimes there are better choices for these functions than a rewrite. <code>Fin.cast</code> comes to mind.</p>",
        "id": 560960097,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1764467121
    },
    {
        "content": "<p>I am not saying this should be the definition of <code>quotientMulEquivOfEq</code>. I was rather pondering if the function is really needed when we can do the rewrites in a proof.</p>",
        "id": 560988127,
        "sender_full_name": "Mirek Ol≈°√°k",
        "timestamp": 1764498798
    },
    {
        "content": "<p>Perhaps it is useful in defitions, I suppose...</p>",
        "id": 560989147,
        "sender_full_name": "Mirek Ol≈°√°k",
        "timestamp": 1764499988
    },
    {
        "content": "<p>You've used tactics (and in particular <code>rw</code>) to fill in a definition and this is a recipe for disaster.</p>",
        "id": 560989192,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1764500048
    },
    {
        "content": "<p>Another problem you've caused here is this: Lean's typeclass inference only want to see one <code>Mul</code> on a type, up to reducible defeq. But the <code>Mul</code>s on <code>G / M</code> and <code>G / N</code> probably won't be equal in this way if you identify the types using <code>=</code>.</p>",
        "id": 560989324,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1764500197
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113488-general/topic/Equality.20vs.2E.20definitional.20equality.20when.20taking.20quotients/near/560989192\">said</a>:</p>\n<blockquote>\n<p>You've used tactics (and in particular <code>rw</code>) to fill in a definition and this is a recipe for disaster.</p>\n</blockquote>\n<p>I understand that, it was rather an example that in proofs, I could usually  rewrite directly, without having to go through isomorphisms.</p>",
        "id": 560989385,
        "sender_full_name": "Mirek Ol≈°√°k",
        "timestamp": 1764500236
    },
    {
        "content": "<p>I am not convinced that you can: you might screw up typeclass inference because you now have two (equal but perhaps not equal enough) multiplications on one type: \"multiplication coming from M\" and \"multiplication coming from N\" and I am worried if <code>M = N</code> isn't <code>rfl</code>.</p>",
        "id": 560989434,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1764500266
    },
    {
        "content": "<p>But maybe I'm just being paranoid here; I always use the isomorphism and the ideas that Kyle described above.</p>",
        "id": 560989475,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1764500298
    },
    {
        "content": "<p>Axel asked if this situation is problematic, and I argued \"actually in some cases it makes life easier because you can use <code>rfl</code> instead of supplying more information\" but here is a situation where I am extremely nervous about not supplying the extra information. (but this might just be because I know how to do it my \"safe\" way and don't know enough about type theory to be happy with the \"easy\" way)</p>",
        "id": 560989625,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1764500440
    },
    {
        "content": "<p>My experience is that at beginning <code>rw</code> is fine, but at some point it gets very painful, and it's usually even more painful to go back and change everything, so one usually prefers to use isomorphisms from the beginning. Of course it really depends on your particular situation, but in practice equality of type is very difficult to use.</p>",
        "id": 560989958,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1764500776
    },
    {
        "content": "<p>So this does work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Subgroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">Normal</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">N</span><span class=\"bp\">.</span><span class=\"n\">Normal</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsSimpleGroup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">‚ß∏</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsSimpleGroup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">‚ß∏</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw!</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">eq</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h</span>\n</code></pre></div>\n<p>so maybe my fears are unfounded? I was expecting an obscure error of the form \"there are two different multiplications here\"</p>",
        "id": 560990208,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1764501017
    },
    {
        "content": "<p>To me it was extremely painful before I discovered <code>rw!</code>, then it was usually manageable. But I am talking about being in a proof state, I agree putting <code>rw</code> into definitions messes things up.</p>",
        "id": 560990237,
        "sender_full_name": "Mirek Ol≈°√°k",
        "timestamp": 1764501059
    },
    {
        "content": "<p>Note that <code>rw</code> not <code>rw!</code> does indeed give you obscure errors (by which I mean \"motive is not type correct\", which is confusing for new users)</p>",
        "id": 560990259,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1764501087
    },
    {
        "content": "<p>I wonder if there is a fundamental reason why <code>simp</code> doesn't solve this</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">‚ñ∏</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">‚ñ∏</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n</code></pre></div>\n<p>(<code>grind</code>, or <code>rw! [h]</code> does, and if I use <code>cast</code> instead of <code>‚ñ∏</code>, simp works)</p>",
        "id": 560990706,
        "sender_full_name": "Mirek Ol≈°√°k",
        "timestamp": 1764501496
    },
    {
        "content": "<p>By the way, mathematically it is still all equal. I can prove that the <code>iso</code> I defined is equal to <code>QuotientGroup.quotientMulEquivOfEq</code>. So it is indeed just about the convenience of usage.</p>",
        "id": 560992840,
        "sender_full_name": "Mirek Ol≈°√°k",
        "timestamp": 1764503626
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek Ol≈°√°k</span> <a href=\"#narrow/channel/113488-general/topic/Equality.20vs.2E.20definitional.20equality.20when.20taking.20quotients/near/560988127\">said</a>:</p>\n<blockquote>\n<p>I am not saying this should be the definition of <code>quotientMulEquivOfEq</code>. I was rather pondering if the function is really needed when we can do the rewrites in a proof.</p>\n</blockquote>\n<p>To clarify: I understood that, and I was explaining part of the reason why not use type rewrites in proofs.</p>\n<p>Kevin mentions another important reason, which is typeclass inference. If you replace a type with something that's not definitionally equal, then the corresponding instances are liable to no longer apply. Tactics like <code>simp</code> assume that all of the instances in your terms can be resynthesized from the inferred type. Rewriting types breaks that assumption.</p>",
        "id": 560995136,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1764505873
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek Ol≈°√°k</span> <a href=\"#narrow/channel/113488-general/topic/Equality.20vs.2E.20definitional.20equality.20when.20taking.20quotients/near/560990706\">said</a>:</p>\n<blockquote>\n<p>I wonder if there is a fundamental reason why <code>simp</code> doesn't solve this</p>\n</blockquote>\n<p>It could be possible to get <code>simp</code> to collapse <code>Eq.rec</code>-based casts, but these unconstrained rewrites don't generally compose well. It makes sense that <code>cast</code> could help, since there's a <code>cast_cast</code> algebraic lemma for it that <code>simp</code> can easily apply.</p>\n<p>It makes sense that <code>grind</code> works for this since it's comfortable working with HEq (so it can eliminate these casts while it's processing the goal, right at the beginning), but it's for closing goals, unlike <code>simp</code> whose main purpose is rewriting in the middle of proofs.</p>\n<p>However, I think right answer here is to use <code>Fin.cast</code>, which avoids type equalities altogether, and preserves the equality on <code>n</code> in <code>Fin n</code>. There are simp lemmas for <code>Fin.cast</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n</code></pre></div>\n<p>While for <code>Fin</code> you can obtain <code>m = n</code> from <code>Fin m = Fin n</code> by a cardinality argument, it's not true in general that if you have an inductive type <code>T</code> that <code>T x y z = T x' y' z'</code> implies <code>x = x'</code>, <code>y = y'</code>, and <code>z = z'</code>. Type formers need not be injective. This is a strong reason for having these custom cast operations per type, to preserve exactly how the type is being rewritten.</p>",
        "id": 560996171,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1764506790
    },
    {
        "content": "<p>That sentence in MIL is indeed a bit too dramatic, I should improve it. But the conclusion is still that one should use the isomorphism instead.</p>",
        "id": 561008756,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1764517026
    },
    {
        "content": "<p>Can you give a specific example of a setup in a proof where a <code>rw!</code> solution doesn't work, and you need the isomorphism?</p>",
        "id": 561009574,
        "sender_full_name": "Mirek Ol≈°√°k",
        "timestamp": 1764517643
    },
    {
        "content": "<p>My suspicion is that using an isomorphism can be annoying too, I would like to rather make things actually equal than convert there and back with an isomorphism.</p>",
        "id": 561009763,
        "sender_full_name": "Mirek Ol≈°√°k",
        "timestamp": 1764517796
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133339\">@Mirek Ol≈°√°k</span> To be clear, the situation isn't that nobody has thought to use <code>Eq.rec</code>/rewrites instead of isomorphisms, it's that people started with rewrites and discovered that isomorphisms solve numerous problems. This thread has a number of reasons why they are better behaved.</p>\n<p>You're not going to see examples where <code>rw!</code> (or at least a hand-written <code>Eq.rec</code>/<code>cast</code> term) can't work, since like I said the isomorphisms are wrapping a rewrite. I think I'd rather see examples where <code>rw!</code> solves things ‚Äî without doing anything that would break assumptions in other tactics ‚Äî that can't be made cleaner using isomorphisms. (I'm sure they exist sometimes, especially with complicated dependent types; I'd like to collect realistic examples.)</p>",
        "id": 561040876,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1764544434
    },
    {
        "content": "<p>I am not sure if the style I am proposing is understood, that is one of the reasons I was asking for an example. In my view, the ideal case is when I have no weird conversions in my proof state, no casts, no isomorphisms, because I could just align all the relevant elements into equal (typically syntactically equal except proofs) types. If <code>rw!</code> can help me achieve such state, I am happy, and I see no reason I shouldn't be.</p>\n<p>If that cannot happen (and I was similarly curious about practical examples when this cannot happen). I get that having explicit isomorphisms is more transparent than casts. On the other hand, you get only somewhat far with isomorphisms because it is only an isomorphism. Whenever you want the isomorphism to be preserving a little more, you need to dig inside the casts again.</p>",
        "id": 561043667,
        "sender_full_name": "Mirek Ol≈°√°k",
        "timestamp": 1764547106
    },
    {
        "content": "<p>I could imagine something evil happening in the typeclasses, but it doesn't seem to be the case here, because the cast is inserted into <code>M.Normal = N.Normal</code>, which is a proposition.</p>",
        "id": 561044924,
        "sender_full_name": "Mirek Ol≈°√°k",
        "timestamp": 1764548122
    },
    {
        "content": "<p>Here's a random example from algebraic geometry. I don't think there is a sane way to avoid the <code>eqToHom</code> and start the proof with <code>rw! (castMode := .all) [‚Üê basicOpen_one]</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">AlgebraicGeometry</span><span class=\"w\"> </span><span class=\"n\">LocallyRingedSpace</span><span class=\"w\"> </span><span class=\"n\">Opposite</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"w\"> </span><span class=\"n\">StructureSheaf</span><span class=\"w\"> </span><span class=\"n\">PrimeSpectrum</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LocallyRingedSpace</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">toSpecŒì</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œì</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">toŒìSpec</span><span class=\"bp\">.</span><span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"bp\">‚ä§</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">ùüô</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">toSpecŒì</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">toOpen_res</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">basicOpen</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"bp\">‚ä§</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">eqToHom</span><span class=\"w\"> </span><span class=\"n\">basicOpen_one</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">),</span>\n<span class=\"w\">    </span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"n\">assoc</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">NatTrans</span><span class=\"bp\">.</span><span class=\"n\">naturality</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">toŒìSpecSheafedSpace_app_spec_assoc</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n<span class=\"w\">  </span><span class=\"n\">dsimp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">toŒìSpec</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">map_comp</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">presheaf</span><span class=\"bp\">.</span><span class=\"n\">map_id</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 561045156,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1764548327
    },
    {
        "content": "<p>Okay you could do something like this but I feel this proof is a lot less predictable and much more brittle.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">AlgebraicGeometry</span><span class=\"w\"> </span><span class=\"n\">LocallyRingedSpace</span><span class=\"w\"> </span><span class=\"n\">Opposite</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"w\"> </span><span class=\"n\">StructureSheaf</span><span class=\"w\"> </span><span class=\"n\">PrimeSpectrum</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LocallyRingedSpace</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">toSpecŒì</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œì</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">toŒìSpec</span><span class=\"bp\">.</span><span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"bp\">‚ä§</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">ùüô</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw!</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">castMode</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">all</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">basicOpen_one</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">toSpecŒì</span>\n<span class=\"w\">  </span><span class=\"n\">convert</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">toŒìSpecSheafedSpace_app_spec</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"bp\">¬∑</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">basicOpen_one</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">¬∑</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"bp\">¬∑</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"bp\">¬∑</span><span class=\"w\"> </span><span class=\"n\">dsimp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">toToŒìSpecMapBasicOpen</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">toŒìSpecMapBasicOpen</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">convert</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">presheaf</span><span class=\"bp\">.</span><span class=\"n\">map_id</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n<span class=\"w\">    </span><span class=\"bp\">¬∑</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">basicOpen_one</span><span class=\"o\">]</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">    </span><span class=\"bp\">¬∑</span><span class=\"w\"> </span><span class=\"n\">dsimp</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">    </span><span class=\"bp\">¬∑</span><span class=\"w\"> </span><span class=\"n\">dsimp</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">    </span><span class=\"bp\">¬∑</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">basicOpen_one</span><span class=\"o\">]</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 561045840,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1764549001
    },
    {
        "content": "<p>Thanks, I still need to understand a bit what it is about but I believe you that using a homomorphism works best here.</p>",
        "id": 561046015,
        "sender_full_name": "Mirek Ol≈°√°k",
        "timestamp": 1764549173
    }
]