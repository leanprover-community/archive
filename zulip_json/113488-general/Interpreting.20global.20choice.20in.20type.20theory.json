[
    {
        "content": "<p>latest in the thread:<br>\n<a href=\"https://twitter.com/EgbertRijke/status/1564362100566380559?s=20&amp;t=7Hzf2_CD1lnoO39YrtXjxg\">https://twitter.com/EgbertRijke/status/1564362100566380559?s=20&amp;t=7Hzf2_CD1lnoO39YrtXjxg</a></p>\n<div class=\"inline-preview-twitter\"><div class=\"twitter-tweet\"><a href=\"https://twitter.com/EgbertRijke/status/1564362100566380559?s=20&amp;t=7Hzf2_CD1lnoO39YrtXjxg\"><img class=\"twitter-avatar\" src=\"https://uploads.zulipusercontent.net/1e908a1fcae3baa19a3a26c5d4866efe5948a638/68747470733a2f2f7062732e7477696d672e636f6d2f70726f66696c655f696d616765732f313233353930373234363832353039353136382f6d58355346427a725f6e6f726d616c2e6a7067\"></a><p><a href=\"https://twitter.com/jonmsterling\">@jonmsterling</a> <a href=\"https://twitter.com/andrejbauer\">@andrejbauer</a> <a href=\"https://twitter.com/EscardoMartin\">@EscardoMartin</a> <a href=\"https://twitter.com/yforster_cs\">@yforster_cs</a> <a href=\"https://twitter.com/XenaProject\">@XenaProject</a> The more I think about it, the less I believe Mario really constructed a model of Lean in ZFC. Also in ZFC the AC only gives you mere existence of a choice function. The way AC is applied gives mere existence of a global choice function, but he pretends he got his hands on one.</p><span>- Egbert Rijke (@EgbertRijke)</span></div></div>",
        "id": 296063974,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1661851136
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"253568\">@Egbert Rijke</span> I'm happy to respond here, but I don't do twitter. But it seems like the main points are already on the table so I don't have much to add.</p>",
        "id": 296064509,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661851394
    },
    {
        "content": "<p>Ok, now you just have to formalize your thesis. <span aria-label=\"smiling devil\" class=\"emoji emoji-1f608\" role=\"img\" title=\"smiling devil\">:smiling_devil:</span></p>",
        "id": 296073262,
        "sender_full_name": "Jason Rute",
        "timestamp": 1661855034
    },
    {
        "content": "<p>If this is going to be a long discussion, maybe it could be its own thread.</p>",
        "id": 296074221,
        "sender_full_name": "Jason Rute",
        "timestamp": 1661855475
    },
    {
        "content": "<p>I have to admit I’m confused a bit by some of the points.  Is the main idea that Lean’s choice operator is what is called “global choice”, or  Hilbert’s epsilon operator?  And that this choice is stronger than what you get in ZFC?  The ZFC version is closer to AC used in HoTT?  Then realizing that AC and replacement are compatible with Univalence but global choice isn’t, this casts doubt on Mario’s argument in his thesis which seems to prove that one can get global choice in ZFC plus countably many large cardinals?  If this is the case, then Mario’s thesis only shows Lean is equiconsistent with ZFC plus large cardinals plus global choice? (I could be totally misunderstanding.)</p>",
        "id": 296076177,
        "sender_full_name": "Jason Rute",
        "timestamp": 1661856417
    },
    {
        "content": "<p>Hi! Sorry, I barely open zulip anymore these days.</p>\n<p>I can summarize the main points of the discussion here. In your thesis it is clear: You assume large enough cardinals to obtain universes <code>V_0,...,V_omega</code>, so that every type in the i-th universe is in <code>Vi</code>. By the axiom of choice, there exists a choice function that selects an element of every inhabited set in <code>V_ω</code>. Then I put my type-theory hat on again, to see if I could understand the argument from the type theoretic point of view. </p>\n<p>Since we're here on the Lean zulip, let's assume that every type is a set. The axiom of choice asserts that <code>(∀(x:X), ∥Y(x)∥) → ∥Π(x:X), Y(x)∥</code>for every type <code>X</code> and every family of types <code>Y</code> over <code>X</code>. Applying this to <code>V_ω</code> we get that <code>(Π (X:V_ω), ∥X∥ → ∥X∥) → ∥Π(X:V_ω), ∥X∥ → X∥</code>. This is also how you apply it in your thesis. The thing I thought was a problem was that you only seem to get ∥Π(X:V_ω), ∥X∥ → X∥, but to interpret Lean's global choice you want <code>Π(X:V_ω), ∥X∥ → X</code>. Then Andrej pointed out that actually you're not _constructing_ a model, but you're proving that a model exists. This cleared up the discussion to me, but do you also see it this way?</p>",
        "id": 296089327,
        "sender_full_name": "Egbert Rijke",
        "timestamp": 1661862095
    },
    {
        "content": "<p>In other parts of the discussion I was wondering what would be needed in type theory to get an implication <code>AC → Global-Choice</code>. </p>\n<p>Andrej was very confused about what I wanted and suggested erroneously that this is possible in CIC. It is not. The argument here is as follows: The axiom of choice is consistent with the univalence axiom, but the global choice principle is not consistent with the univalence axiom. This implies that if we could simply prove global choice from AC, then in combination with univalence we would be able to reach a contradiction. Furthermore, any axiom that is compatible with the univalence axiom also won't help you prove global choice from AC. This leads to the question, what extra assumptions do we need to make about type theory in order for your argument to go through in type theory. I still don't know the answer. The suggestions by Andrej in that thread were not helpful. </p>\n<p>So that is a summary of the other part of the discussion.</p>",
        "id": 296091561,
        "sender_full_name": "Egbert Rijke",
        "timestamp": 1661862880
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"253568\">@Egbert Rijke</span> <a href=\"#narrow/stream/113488-general/topic/Interpreting.20global.20choice.20in.20type.20theory/near/296089327\">said</a>:</p>\n<blockquote>\n<p>Since we're here on the Lean zulip, let's assume that every type is a set. The axiom of choice asserts that <code>(∀(x:X), ∥Y(x)∥) → ∥Π(x:X), Y(x)∥</code>for every type <code>X</code> and every family of types <code>Y</code> over <code>X</code>. Applying this to <code>V_ω</code> we get that <code>(Π (X:V_ω), ∥X∥ → ∥X∥) → ∥Π(X:V_ω), ∥X∥ → X∥</code>. This is also how you apply it in your thesis. The thing I thought was a problem was that you only seem to get ∥Π(X:V_ω), ∥X∥ → X∥, but to interpret Lean's global choice you want <code>Π(X:V_ω), ∥X∥ → X</code>. Then Andrej pointed out that actually you're not _constructing_ a model, but you're proving that a model exists. This cleared up the discussion to me, but do you also see it this way?</p>\n</blockquote>\n<p>You could either see it like that, or you could understand the construction as giving a parameterized family of models, indexed by possible choice functions of <code>V_ω</code>. Of course, for the main goal of proving relative consistency, it suffices to have the mere existence of a choice function since any one of those models leads to a proof of false if we assume lean is inconsistent.</p>",
        "id": 296255325,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661921232
    },
    {
        "content": "<p>The key difference between GC and AC is whether the choice function has a domain which is a proper class. When embedding Lean in ZFC + omega universes, the totality of all lean types makes up a set, so we can use plain AC. Andrej mentions that in MLTT we don't have a universe hierarchy and so we would interpret the type theoretic universe as all of V in an embedding, and in that case you would need GC. But you could also still do an embedding where the types are mapped only to some set in ZFC, and in that case AC would suffice.</p>",
        "id": 296255575,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661921462
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"253568\">Egbert Rijke</span> <a href=\"#narrow/stream/113488-general/topic/Interpreting.20global.20choice.20in.20type.20theory/near/296091561\">said</a>:</p>\n<blockquote>\n<p>In other parts of the discussion I was wondering what would be needed in type theory to get an implication <code>AC → Global-Choice</code>. </p>\n</blockquote>\n<p>I would expect there is nothing short of <code>Global-Choice</code> itself that will give you this. It should be possible to take any proof using global choice (in lean, for concreteness) and rewrite it so that it only uses <code>AC</code>, but this is not the same thing: <code>AC</code> does not have the requisite \"symmetry-breaking\" properties you need to prove <code>Global-Choice</code>.</p>",
        "id": 296255819,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661921643
    },
    {
        "content": "<p>Here's how you can eliminate uses of a lean style <code>classical.choice</code> in favor of <code>axiom_of_choice</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">axiom_of_choice</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">β</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">choicy</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">choice</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">nonempty</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">choicy.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">choicy.choice</span> <span class=\"n\">α</span>\n\n<span class=\"c1\">-- do math, using `choicy.choice` in place of `classical.choice`</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">choicy.elim</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">[</span><span class=\"n\">choicy.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}],</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">nonempty</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">axiom_of_choice</span> <span class=\"o\">(</span><span class=\"n\">nonempty</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">id</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">nonempty</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">axiom_of_choice</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">F</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">this</span> <span class=\"k\">in</span> <span class=\"bp\">@</span><span class=\"n\">H</span> <span class=\"o\">⟨</span><span class=\"n\">F</span><span class=\"o\">⟩</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 296256544,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661922314
    },
    {
        "content": "<p>This works because one consequence of lean's universe hierarchy is that you can never truly use global choice in lean, you have to pick some universe at which to apply it and then the totality of all choices you have made is still contained in a type in the next universe</p>",
        "id": 296256806,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661922569
    },
    {
        "content": "<p>so you don't even need to use metatheoretic reasoning to argue that it is eliminable</p>",
        "id": 296256890,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661922610
    },
    {
        "content": "<p>And I would say that this is also the essence of the argument in my thesis translated to type theory. All \"constructions\" are done relative to some large-enough choice function, and then at \"the end\" you can eliminate the choice function as long as the final result is a proposition (with <code>false</code> being a particular proposition of interest for the case of consistency)</p>",
        "id": 296257295,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661922997
    },
    {
        "content": "<p>So global choice is really seen to only be a convenience to avoid having to carry around this useless <code>[choicy]</code> typeclass everywhere</p>",
        "id": 296257313,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661923027
    }
]