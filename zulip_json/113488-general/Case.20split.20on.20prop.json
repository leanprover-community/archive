[
    {
        "content": "<p>Here's something that doesn't work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Batteries.Data.Nat.Basic</span>\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">position_of</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">elt</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List.Mem</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">4</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">6</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">elt</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>The <code>head</code> block does not type check - of course it can't! - and this prevents compilation. How can I access the fact that <code>List.Mem</code> knows where the <code>3</code> is?</p>\n<p>The XY of this is that I want to convert this function so that it outputs data rather than a Prop: I want to know <em>which</em> <code>k</code> it found, along with a proof that the <code>k</code> has the property. (Changing the \"exists\" to a <code>Sum</code> fails because the equality proof is a Prop.) I think it should be possible to do this without any need to decide equality, because <code>Mem</code> already knows where the element is.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Batteries.Data.Nat.Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Batteries.Data.List.Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.Tactic.Use</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">hits'</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">pr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">elt</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List.Mem</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List.ofFn.go</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">pr</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">r</span>\n<span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">exfalso</span>\n<span class=\"w\">    </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">List.ofFn.go</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"n\">elt</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List.mem_nil_iff</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">elt</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">  </span><span class=\"n\">rcases</span><span class=\"w\"> </span><span class=\"n\">elt</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">isMem</span><span class=\"o\">⟩</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">omega</span><span class=\"o\">⟩</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">hits'</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">omega</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">isMem</span>\n</code></pre></div>",
        "id": 459896917,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1723388996
    },
    {
        "content": "<p>List.Mem does not actually know where 3 is. Lean erases propositions at compile time so you cannot create any data (i.e. anything that is not a proposition) from a proposition. You can encode Membership in a way that lives in <code>Type</code> and explicitly tracks the index at which the element is but that is not possible with the built in <code>List.Mem</code>.</p>",
        "id": 459899072,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1723389924
    },
    {
        "content": "<p>Ah right - is the reason <code>List.Mem</code> was defined as a Prop simply runtime efficiency, or does Prop have any other benefits to outweigh the fact that it's harder to compute with?</p>",
        "id": 459901295,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1723390697
    },
    {
        "content": "<p>Proof irrelvance also helps doing other proofs, e.g. when proving equality of subtypes etc. There is just, not much of a reason to define it not as <code>Prop</code> I think.</p>",
        "id": 459901781,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1723390856
    },
    {
        "content": "<p>You can make a function that, using <code>DecidableEq</code> and a membership proof, gives you the first index.</p>",
        "id": 459902567,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1723391116
    },
    {
        "content": "<p>This sort of fits the bill: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.indexOf_lt_length#doc\">docs#List.indexOf_lt_length</a></p>",
        "id": 459903053,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1723391253
    },
    {
        "content": "<p>The annoying part of that is I'm doing this so as to prove that <code>Mathlib.ModelTheory.Syntax</code>'s <code>Term</code> has decidable equality; this is the recursive case, <code>Term.func f (vars : Fin n -&gt; Term)</code>, and I don't trivially have access to the proof of decidability yet</p>",
        "id": 459903346,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1723391338
    },
    {
        "content": "<p>Somewhere in my proof I <em>have</em> implicitly computed the index, I just need to thread it through a bunch of functions (and I was hoping it could be derived from the <code>Mem</code> instead)</p>",
        "id": 459903435,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1723391389
    },
    {
        "content": "<p>Maybe you could use the type <code>{n : Nat // lst.get? n = v}</code> instead, or something like it?</p>",
        "id": 459904920,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1723391858
    },
    {
        "content": "<p>Thanks, that's working out well I think and is a very simple change!</p>",
        "id": 459913358,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1723395856
    }
]