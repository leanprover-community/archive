[
    {
        "content": "<p>We currently have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/tsum\">docs#tsum</a> for infinite sums, and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.tprod\">docs#list.tprod</a> for type products. If we wanted to have infinite products, what should we do?</p>",
        "id": 325972730,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1675609736
    },
    {
        "content": "<p>(polls have to be in their own message)</p>",
        "id": 325972774,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1675609764
    },
    {
        "content": "<p>/poll Infinite products<br>\nUse infinite products in terms of <code>additive</code> and <code>multiplicative</code> of <code>tsum</code><br>\nUse infinite products in terms of <code>tendsto</code> like we have for a lemma about <code>sin x</code> (Thanks <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> )<br>\nRename <code>tprod</code> to <code>typrod</code> or <code>tproduct</code>or something else<br>\nDefine infinite product as <code>topprod</code>, <code>toprod</code>, <code>topoprod</code>, and extend <code>to_additive</code></p>",
        "id": 325972777,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1675609767
    },
    {
        "content": "<p><code>tprod</code> doesn't seem to exist.</p>",
        "id": 325972919,
        "sender_full_name": "Reid Barton",
        "timestamp": 1675609848
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.tprod\">docs#list.tprod</a>?</p>",
        "id": 325972982,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1675609868
    },
    {
        "content": "<p>But that doesn't conflict, so perhaps the only question here is \"should we to_additivize a bunch of things\"</p>",
        "id": 325973108,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1675609901
    },
    {
        "content": "<p>Weird that the <code>find/</code> results didn't consider that worthy of a mention.</p>",
        "id": 325973402,
        "sender_full_name": "Reid Barton",
        "timestamp": 1675609999
    },
    {
        "content": "<p>Sorry, which <code>find/</code> results do you mean? Please feel free to add an option</p>",
        "id": 325973478,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1675610037
    },
    {
        "content": "<p>Try clicking the second link in your original message.</p>",
        "id": 325973590,
        "sender_full_name": "Reid Barton",
        "timestamp": 1675610066
    },
    {
        "content": "<p>Uh, the unedited version.</p>",
        "id": 325973602,
        "sender_full_name": "Reid Barton",
        "timestamp": 1675610076
    },
    {
        "content": "<p>The result of clicking <a href=\"https://leanprover-community.github.io/mathlib_docs/find/tprod\">docs#tprod</a> is what Reid means</p>",
        "id": 325973632,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1675610087
    },
    {
        "content": "<p>Right. I mistyped, thanks for that. Right, there are also a variety of definitions and lemmas related to tensor products, like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pi_tensor_product.tprod_coeff\">docs#pi_tensor_product.tprod_coeff</a></p>",
        "id": 325973778,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1675610147
    },
    {
        "content": "<p>They're all namespaced though so I don't think there's any clash to worry about</p>",
        "id": 325973957,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1675610201
    },
    {
        "content": "<p>I think a bigger concern is that a bunch of tsum  lemmas talk about continuous linear maps which don't have a multiplicative analogy</p>",
        "id": 325973997,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1675610224
    },
    {
        "content": "<p>I think we should have <code>tprod</code> and we should to_additivize as much as possible. Of course that will exclude things involving linearity, but that's not weird.</p>",
        "id": 326012597,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1675631766
    },
    {
        "content": "<p>Can I just as for a clarification on what's meant by the following option in the poll? </p>\n<blockquote>\n<p>Use infinite products in terms of <code>tendsto</code> like we have for a lemma about <code>sin x</code> (Thanks Eric Wieser)</p>\n</blockquote>\n<p>If this is a reference to the discussion a few days ago (edit: <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/series.20expansion.20for.20cot.20pi*z/near/325378276\">here</a>) where Eric mentioned <a href=\"https://leanprover-community.github.io/mathlib_docs/find/complex.tendsto_euler_sin_prod\">docs#complex.tendsto_euler_sin_prod</a> , then I want to point out that this is a bit misleading, because the notion of convergence used in that proof is <em>not mathematically equivalent</em> to the multiplicative analogue of <code>tsum</code>.  What's used in <code>euler_sin_prod</code> is taking the limit as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi><mo>→</mo><mi mathvariant=\"normal\">∞</mi></mrow><annotation encoding=\"application/x-tex\">N \\to \\infty</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord\">∞</span></span></span></span> of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>N</mi></msubsup><mi>f</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\prod_{i = 0}^N f(i)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.2809em;vertical-align:-0.2997em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∏</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9812em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">0</span></span></span></span><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">N</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2997em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span></span></span></span>. However, the \"morally right\" notion of convergence, which we don't have an API or a name for yet, is taking the limit of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mo>∏</mo><mrow><mi>i</mi><mo>∈</mo><mi>I</mi></mrow></msub><mi>f</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\prod_{i \\in I} f(i)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0771em;vertical-align:-0.3271em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∏</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1786em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">∈</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">I</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3271em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span></span></span></span>, where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">I</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span> is a finite subset of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span>, wrt the cofinite filter. So <code>euler_sin_prod</code> isn't a model to follow here.</p>",
        "id": 326028832,
        "sender_full_name": "David Loeffler",
        "timestamp": 1675645684
    },
    {
        "content": "<p>Does this model of convergence match <a href=\"https://leanprover-community.github.io/mathlib_docs/find/has_sum\">docs#has_sum</a>?</p>",
        "id": 326030634,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1675647365
    },
    {
        "content": "<p>Yes</p>",
        "id": 326031064,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1675647764
    },
    {
        "content": "<p>Yes -- what I called \"the morally right notion\" for products is the one matching the existing definition of <code>has_sum</code>.</p>",
        "id": 326031798,
        "sender_full_name": "David Loeffler",
        "timestamp": 1675648494
    },
    {
        "content": "<p>After the porting is done, I'm going to refactor pi measures so that we no longer need <code>list.tprod</code> (unless someone wants to use them for another purpose). Also, <code>list.tprod</code> is in a namespace, so there is no actual name clash.</p>",
        "id": 326032091,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1675648800
    },
    {
        "content": "<p>So: are we agreed that the poll is rendered moot by the fact that <code>list.tprod</code> isn't in the root namespace, and Yakov has the green light to define <code>tprod</code> in the root namespace as the infinite-product version of <code>tsum</code>?</p>",
        "id": 326033983,
        "sender_full_name": "David Loeffler",
        "timestamp": 1675650641
    },
    {
        "content": "<p>It would be nice to get it in before the port hits it.</p>",
        "id": 326038364,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1675654600
    },
    {
        "content": "<p>Just to confirm, something like this is what you're okay with (morally):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">topology.algebra.infinite_sum</span>\n\n<span class=\"kd\">noncomputable theory</span>\n<span class=\"kn\">open</span> <span class=\"n\">finset</span> <span class=\"n\">filter</span> <span class=\"n\">function</span> <span class=\"n\">classical</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">topology</span> <span class=\"n\">classical</span> <span class=\"n\">big_operators</span> <span class=\"n\">nnreal</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">δ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">has_prod</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">comm_monoid</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">has_prod</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">tendsto</span> <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">finset</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"bp\">∏</span> <span class=\"n\">b</span> <span class=\"k\">in</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">at_top</span> <span class=\"o\">(</span><span class=\"bp\">𝓝</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- `proddable f` means that `f` has some (infinite) product. Use `tprod` to get the value. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">proddable</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">∃</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">has_prod</span> <span class=\"n\">f</span> <span class=\"n\">a</span>\n\n<span class=\"sd\">/-- `∏' i, f i` is the product of `f` it exists, or 1 otherwise -/</span>\n<span class=\"kd\">@[irreducible]</span> <span class=\"kd\">def</span> <span class=\"n\">tprod</span> <span class=\"o\">{</span><span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">proddable</span> <span class=\"n\">f</span> <span class=\"k\">then</span> <span class=\"n\">classical.some</span> <span class=\"n\">h</span> <span class=\"k\">else</span> <span class=\"mi\">1</span>\n\n<span class=\"kd\">notation</span> <span class=\"bp\">`∏'`</span> <span class=\"n\">binders</span> <span class=\"bp\">`</span><span class=\"o\">,</span> <span class=\"bp\">`</span> <span class=\"n\">r</span><span class=\"o\">:(</span><span class=\"n\">scoped</span><span class=\"o\">:</span><span class=\"mi\">67</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">tprod</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">r</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">has_sum_of_mul_iff_has_prod</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">has_sum</span> <span class=\"o\">(</span><span class=\"n\">additive.of_mul</span> <span class=\"bp\">∘</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">additive.of_mul</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">has_prod</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">iff.rfl</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">summable_of_mul_iff_proddable</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">summable</span> <span class=\"o\">(</span><span class=\"n\">additive.of_mul</span> <span class=\"bp\">∘</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">proddable</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">iff.rfl</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">tsum_of_mul_eq_of_mul_tprod</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∑'</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">additive.of_mul</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">additive.of_mul</span> <span class=\"o\">(</span><span class=\"bp\">∏'</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">tprod</span><span class=\"o\">,</span> <span class=\"n\">tsum</span><span class=\"o\">],</span>\n  <span class=\"n\">by_cases</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">proddable</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">dif_pos</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">dif_pos</span><span class=\"o\">],</span>\n    <span class=\"n\">refl</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">dif_neg</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">dif_neg</span><span class=\"o\">],</span>\n    <span class=\"o\">{</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">rwa</span> <span class=\"n\">summable_of_mul_iff_proddable</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">to_mul_tsum_of_mul_eq_tprod</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">additive.to_mul</span> <span class=\"o\">(</span><span class=\"bp\">∑'</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">additive.of_mul</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"bp\">∏'</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"n\">tsum_of_mul_eq_of_mul_tprod</span> <span class=\"n\">f</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">proddable_of_zero</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">proddable</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">hb</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hf</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">has_prod</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">tendsto_at_top_nhds</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span> <span class=\"n\">U</span> <span class=\"n\">hU</span> <span class=\"n\">hU'</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨{</span><span class=\"n\">b</span><span class=\"o\">},</span> <span class=\"bp\">λ</span> <span class=\"n\">V</span> <span class=\"n\">hV</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n  <span class=\"k\">have</span> <span class=\"n\">hb'</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"n\">singleton_subset_iff.mp</span> <span class=\"n\">hV</span><span class=\"o\">,</span>\n  <span class=\"n\">rwa</span> <span class=\"n\">prod_eq_zero</span> <span class=\"n\">hb'</span> <span class=\"n\">hb</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">has_prod</span>\n</code></pre></div>",
        "id": 326040162,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1675656381
    },
    {
        "content": "<p>With example usage like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">taoziegler.tomathlib.infinite_prod</span>\n<span class=\"kn\">import</span> <span class=\"n\">analysis.special_functions.log.basic</span>\n\n<span class=\"kd\">noncomputable theory</span>\n<span class=\"kn\">open</span> <span class=\"n\">finset</span> <span class=\"n\">filter</span> <span class=\"n\">function</span> <span class=\"n\">classical</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">topology</span> <span class=\"n\">classical</span> <span class=\"n\">big_operators</span> <span class=\"n\">nnreal</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">δ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">proddable_of_summable_log</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">summable</span> <span class=\"o\">(</span><span class=\"n\">real.log</span> <span class=\"bp\">∘</span> <span class=\"n\">f</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">proddable</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">real.exp</span> <span class=\"bp\">∘</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">β</span><span class=\"o\">),</span> <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">real.log</span> <span class=\"bp\">∘</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"bp\">=</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">β</span><span class=\"o\">),</span> <span class=\"bp\">∏</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">comp_app</span><span class=\"o\">],</span>\n    <span class=\"n\">rw</span> <span class=\"n\">real.exp_sum</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">prod_congr</span> <span class=\"n\">rfl</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">b</span> <span class=\"n\">hb</span><span class=\"o\">,</span> <span class=\"n\">real.exp_log</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"n\">_</span><span class=\"o\">))</span> <span class=\"o\">},</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">real.exp</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">tendsto_congr</span> <span class=\"n\">this</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"o\">((</span><span class=\"n\">real.continuous_exp.tendsto</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">summable_log_one_add_of_summable</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">s</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">summable</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">summable</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">real.log</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">s</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"n\">summable_of_nonneg_of_le</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">real.log_nonneg</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">real.log_le_sub_one_of_pos</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">h</span><span class=\"bp\">;</span>\n  <span class=\"n\">specialize</span> <span class=\"n\">hs</span> <span class=\"n\">b</span><span class=\"bp\">;</span>\n  <span class=\"n\">linarith</span>\n<span class=\"kd\">end</span>\n\n\n<span class=\"kd\">lemma</span> <span class=\"n\">proddable_one_add_of_summable</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">s</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">summable</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">proddable</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">s</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"n\">proddable_of_summable_log</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">summable_log_one_add_of_summable</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">;</span>\n  <span class=\"n\">specialize</span> <span class=\"n\">hs</span> <span class=\"n\">b</span><span class=\"bp\">;</span>\n  <span class=\"n\">linarith</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 326040196,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1675656430
    },
    {
        "content": "<p>Correct?</p>",
        "id": 326040203,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1675656443
    },
    {
        "content": "<p>Unfotunately, as Bhavik pointed out,  the usage of <code>proddable</code> is less stable than <code>summable</code>, since finite values can make a previously un-<code>proddable</code> (not converging) function become <code>proddable</code> by adding at least one 0; non-<code>summable</code> functions cannot be made <code>summable</code> so easily.</p>",
        "id": 326040306,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1675656562
    },
    {
        "content": "<p>I think we need to handle zeroes and non-invertible elements a little differently.</p>\n<p>If G is a (multiplicative) topological abelian <strong><em>group</em></strong> then the definition of convergence of a G-valued group should be exactly what you wrote. But if R is a topological ring, then I think we should define \"convergence\" of a product valued in R to mean that every term of the product is a unit in R, and the convergence holds be w.r.t. the morally-correct topology on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>R</mi><mo>×</mo></msup></mrow><annotation encoding=\"application/x-tex\">R^\\times</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7713em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">×</span></span></span></span></span></span></span></span></span></span></span>, which is the one induced by its embedding into <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo>×</mo><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R \\times R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> via <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi><mo>↦</mo><mo stretchy=\"false\">(</mo><mi>t</mi><mo separator=\"true\">,</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>t</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">t \\mapsto (t, 1/t)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6261em;vertical-align:-0.011em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">t</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1/</span><span class=\"mord mathnormal\">t</span><span class=\"mclose\">)</span></span></span></span> -- this is not the same, in general, as the subspace topology from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>R</mi><mo>×</mo></msup><mo>⊂</mo><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R^\\times \\subset R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8104em;vertical-align:-0.0391em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">×</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊂</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>.</p>",
        "id": 326049106,
        "sender_full_name": "David Loeffler",
        "timestamp": 1675664116
    },
    {
        "content": "<p>Yael had said something similar to me today on a call, regarding handling units properly.</p>",
        "id": 326049592,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1675664486
    },
    {
        "content": "<p>Would the embedding <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mo>×</mo><mi>G</mi></mrow><annotation encoding=\"application/x-tex\"> G \\times G </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> via <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi><mo>↦</mo><mo stretchy=\"false\">(</mo><mi>g</mi><mo separator=\"true\">,</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>g</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\"> g \\mapsto (g, 1/g) </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7054em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1/</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mclose\">)</span></span></span></span> work also?</p>",
        "id": 326049734,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1675664567
    },
    {
        "content": "<p>This way, we could have one case handle both, through<code>[comm_monoid G]</code>.</p>",
        "id": 326049829,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1675664632
    },
    {
        "content": "<p>Requiring every term to be a unit would mean that <code>(∏' n : ℕ, if n = 0 then (2 : ℤ) else 1) = 1</code> though, wouldn't it?</p>",
        "id": 326051369,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1675665613
    },
    {
        "content": "<p>Or is there not enough structure on ℤ to make that legal anyway?</p>",
        "id": 326051459,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1675665685
    },
    {
        "content": "<p>A better definition is probably to require that, for any finite set <code>s</code>, then the product on finsets in the complement of <code>s</code> converges as these finsets grow to cover <code>univ \\ s</code>. But this would mean also changing our definition of summability, so this would be a pretty thorough refactor...</p>",
        "id": 326054526,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1675667272
    },
    {
        "content": "<p>I started multiplicativising <code>topology.algebra.infinite_sum</code> while on a call with Yakov yesterday. My thought is that even if we want to change the definition of <code>prodable</code>, we first want to make sure we have feature parity between the additive and multiplicative worlds.</p>",
        "id": 326061985,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1675670742
    },
    {
        "content": "<p>Then if we change the definition of <code>summable</code> in a way that only differs from the current for non-cancellative monoids, it shouldn't be <em>too</em> hard to refactor, as hopefully most uses of <code>summable</code> are in groups, or at the very least in cancellative monoids (looking at you, <code>ennreal</code>).</p>",
        "id": 326062537,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1675670966
    },
    {
        "content": "<p>There aren't really uses of <code>summable</code> in <code>ennreal</code>, fortunately, because everything is summable there. Cancellative monoids won't be enough most of the time, though, because one would need \"continuity of subtraction\", which we don't have a typeclass for (the definition would probably be: if <code>u n + a</code> tends to <code>b + a</code>, then <code>u n</code> tends to <code>b</code>). That's why results for <code>nnreal</code> are typically proved separately from the general results, because that's the only interesting example we use a lot which is not a group.</p>",
        "id": 326067397,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1675672729
    },
    {
        "content": "<p>Reid posted a while ago a nice example of a cancellative topological monoid for which subtraction wasn't continuous (in case anyone was hoping it was always true). Consider the nonnegative reals with all usual sets open and also every subset of the interval [0,1] open. Then 1.5-1/n tends to 1.5 but 0.5-1/n doesn't tend to 0.5 because {0.5} is open.</p>",
        "id": 326072527,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1675674575
    },
    {
        "content": "<p>This example also shows that cancellative topological monoids might be far from \"homogeneous\" (the topology near every point looks the same), whereas topological groups must be homogeneous.</p>",
        "id": 326072903,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1675674718
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/infinite.20product.20clash.20with.20type.20product/near/326072527\">said</a>:</p>\n<blockquote>\n<p>Reid posted a while ago a nice example of a cancellative topological monoid for which subtraction wasn't continuous (in case anyone was hoping it was always true). Consider the nonnegative reals with all usual sets open and also every subset of the interval [0,1] open. Then 1.5-1/n tends to 1.5 but 0.5-1/n doesn't tend to 0.5 because {0.5} is open.</p>\n</blockquote>\n<p>Is it even true that a group with continuous addition necessarily has continuous subtraction? If it is we should update the definition of topological group in mathlib.</p>",
        "id": 326155156,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1675696724
    },
    {
        "content": "<p>What would need changing in <a href=\"https://leanprover-community.github.io/mathlib_docs/find/topological_group\">docs#topological_group</a>?</p>",
        "id": 326156693,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1675697098
    },
    {
        "content": "<p>No, it's fine as is. Continuity of addition and negation imply continuity of subtraction trivially.</p>",
        "id": 326158166,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1675697451
    },
    {
        "content": "<p>Surely <a href=\"https://leanprover-community.github.io/mathlib_docs/find/topological_group.to_has_continuous_div\">docs#topological_group.to_has_continuous_div</a> is a thing</p>",
        "id": 326158295,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1675697488
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/infinite.20product.20clash.20with.20type.20product/near/326156693\">said</a>:</p>\n<blockquote>\n<p>What would need changing in <a href=\"https://leanprover-community.github.io/mathlib_docs/find/topological_group\">docs#topological_group</a>?</p>\n</blockquote>\n<p>You wouldn't need the <code>continuous_inv</code> axiom. I don't think it is true though.</p>",
        "id": 326158703,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1675697605
    },
    {
        "content": "<p>But I don't know a counter example</p>",
        "id": 326158809,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1675697637
    },
    {
        "content": "<p>Sorry, I misread/misinterpreted what you were saying</p>",
        "id": 326161449,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1675698311
    },
    {
        "content": "<p>Probably the real line with the lower limit topology is a counterexample.</p>",
        "id": 326161760,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1675698390
    },
    {
        "content": "<p>BTW, should we move it from <code>counterexamples</code> to <code>topology.instances</code>?</p>",
        "id": 326280924,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1675743953
    },
    {
        "content": "<p>Now I see that <span class=\"user-mention\" data-user-id=\"373192\">@Christopher Hoskin</span> duplicated some of my work in <a href=\"https://leanprover-community.github.io/mathlib_docs/find/with_lower_topology\">docs#with_lower_topology</a></p>",
        "id": 326281049,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1675744073
    },
    {
        "content": "<p>(though this file uses a more generic definition that works for preorders)</p>",
        "id": 326281102,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1675744097
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/113488-general/topic/infinite.20product.20clash.20with.20type.20product/near/326067397\">said</a>:</p>\n<blockquote>\n<p>There aren't really uses of <code>summable</code> in <code>ennreal</code>, fortunately, because everything is summable there. Cancellative monoids won't be enough most of the time, though, because one would need \"continuity of subtraction\", which we don't have a typeclass for (the definition would probably be: if <code>u n + a</code> tends to <code>b + a</code>, then <code>u n</code> tends to <code>b</code>). That's why results for <code>nnreal</code> are typically proved separately from the general results, because that's the only interesting example we use a lot which is not a group.</p>\n</blockquote>\n<p>We have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/has_continuous_sub\">docs#has_continuous_sub</a> but this is something else. <del><code>∀ a b, map ((+) a) (nhds b) = nhds (a + b)</code>?</del> no</p>",
        "id": 326281824,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1675744820
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"373192\">@Christopher Hoskin</span> Sorry, your file is about the <a href=\"https://en.wikipedia.org/wiki/Upper_topology\">lower topology</a> while mine is about the <a href=\"https://en.wikipedia.org/wiki/Lower_limit_topology\">lower limit topology</a>. I should be more careful before making claims about work duplication.</p>",
        "id": 326531630,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1675845966
    },
    {
        "content": "<p>I'm trying to prove something useful with the definition that I copied from <code>summable</code>. What's the better way to resolve the <code>tendsto</code> goal, instead of falling into working with opens? The proof ends up juggling through subtypes. Additionally, how should the <code>proddable/has_prod</code> definition look like, if this theorem <code>proddable_of_summable_log</code> example is a thing we'd like to prove?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis.special_functions.log.basic</span>\n\n<span class=\"kd\">noncomputable theory</span>\n<span class=\"kn\">open</span> <span class=\"n\">finset</span> <span class=\"n\">filter</span> <span class=\"n\">function</span> <span class=\"n\">classical</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">topology</span> <span class=\"n\">classical</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">δ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">has_prod</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">comm_monoid</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">has_prod</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">tendsto</span> <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">finset</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"bp\">∏</span> <span class=\"n\">b</span> <span class=\"k\">in</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">at_top</span> <span class=\"o\">(</span><span class=\"bp\">𝓝</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">proddable</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">∃</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">has_prod</span> <span class=\"n\">f</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">proddable_of_zero</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">proddable</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">hb</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hf</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">has_prod</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">tendsto_at_top_nhds</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span> <span class=\"n\">U</span> <span class=\"n\">hU</span> <span class=\"n\">hU'</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨{</span><span class=\"n\">b</span><span class=\"o\">},</span> <span class=\"bp\">λ</span> <span class=\"n\">V</span> <span class=\"n\">hV</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n  <span class=\"k\">have</span> <span class=\"n\">hb'</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"n\">singleton_subset_iff.mp</span> <span class=\"n\">hV</span><span class=\"o\">,</span>\n  <span class=\"n\">rwa</span> <span class=\"n\">prod_eq_zero</span> <span class=\"n\">hb'</span> <span class=\"n\">hb</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">has_prod</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">finset</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">comm_monoid</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable_pred</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">map_subtype</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"n\">subtype</span> <span class=\"n\">p</span><span class=\"o\">)}</span> <span class=\"o\">:</span>\n  <span class=\"n\">finset.subtype</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">embedding.subtype</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"o\">(</span><span class=\"n\">map_injective</span> <span class=\"o\">(</span><span class=\"n\">embedding.subtype</span> <span class=\"n\">p</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">eq_iff</span><span class=\"o\">,</span> <span class=\"n\">subtype_map_of_mem</span><span class=\"o\">],</span>\n  <span class=\"n\">simp</span> <span class=\"o\">{</span> <span class=\"n\">contextual</span> <span class=\"o\">:=</span> <span class=\"n\">tt</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">@[to_additive]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">prod_subtype'</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∏</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"o\">(</span><span class=\"n\">s.subtype</span> <span class=\"n\">p</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"bp\">∏</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">s.filter</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"n\">prod_bij'</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">mem_filter.mpr</span> <span class=\"o\">⟨</span><span class=\"n\">mem_subtype.mp</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">a.prop</span><span class=\"o\">⟩)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">mem_filter.mp</span> <span class=\"n\">ha</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">right</span><span class=\"o\">⟩)</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"bp\">;</span>\n  <span class=\"n\">simp</span> <span class=\"o\">{</span> <span class=\"n\">contextual</span> <span class=\"o\">:=</span> <span class=\"n\">tt</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">@[to_additive]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">prod_subtype_mem</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable_pred</span> <span class=\"o\">(</span><span class=\"bp\">∈</span> <span class=\"n\">p</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∏</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"o\">(</span><span class=\"n\">s.subtype</span> <span class=\"o\">(</span><span class=\"bp\">∈</span> <span class=\"n\">p</span><span class=\"o\">)),</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"bp\">∏</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">s.filter</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"o\">:=</span>\n<span class=\"n\">prod_subtype'</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">finset</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">proddable_of_summable_log</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"bp\">∀ᶠ</span> <span class=\"n\">b</span> <span class=\"k\">in</span> <span class=\"n\">cofinite</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">summable</span> <span class=\"o\">(</span><span class=\"n\">real.log</span> <span class=\"bp\">∘</span> <span class=\"n\">f</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">proddable</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">by_cases</span> <span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"n\">proddable_of_zero</span> <span class=\"n\">_</span> <span class=\"n\">H</span> <span class=\"o\">},</span>\n  <span class=\"n\">push_neg</span> <span class=\"n\">at</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n  <span class=\"n\">set</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"bp\">|</span> <span class=\"n\">f</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"k\">with</span> <span class=\"n\">hs</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">hsf</span> <span class=\"o\">:</span> <span class=\"n\">s.finite</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">convert</span> <span class=\"n\">hf</span><span class=\"o\">,</span>\n    <span class=\"n\">ext</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">},</span>\n  <span class=\"k\">have</span> <span class=\"n\">hsp</span> <span class=\"o\">:</span> <span class=\"n\">hsf.to_finset.prod</span> <span class=\"n\">f</span> <span class=\"bp\">=</span>\n    <span class=\"o\">(</span><span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">hsf.to_finset.card</span> <span class=\"bp\">*</span> <span class=\"n\">real.exp</span> <span class=\"o\">(</span><span class=\"n\">hsf.to_finset.sum</span> <span class=\"o\">(</span><span class=\"n\">real.log</span> <span class=\"bp\">∘</span> <span class=\"n\">f</span><span class=\"o\">)),</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">real.exp_sum</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">prod_const</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">prod_mul_distrib</span><span class=\"o\">],</span>\n    <span class=\"n\">rw</span> <span class=\"n\">prod_congr</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">real.exp_log_of_neg</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">contextual</span> <span class=\"o\">:=</span> <span class=\"n\">tt</span><span class=\"o\">}</span> <span class=\"o\">},</span>\n  <span class=\"k\">have</span> <span class=\"n\">hpos</span> <span class=\"o\">:=</span> <span class=\"n\">h.subtype</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">},</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hpos</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hpos</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">hsf.to_finset.prod</span> <span class=\"n\">f</span> <span class=\"bp\">*</span> <span class=\"n\">real.exp</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n  <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"n\">tendsto</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">β</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">∏</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"n\">s.filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">0</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">*</span>\n    <span class=\"bp\">∏</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"n\">s.filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">at_top</span> <span class=\"o\">(</span><span class=\"bp\">𝓝</span> <span class=\"o\">(</span><span class=\"n\">hsf.to_finset.prod</span> <span class=\"n\">f</span> <span class=\"bp\">*</span> <span class=\"n\">real.exp</span> <span class=\"n\">x</span><span class=\"o\">)),</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">has_prod</span><span class=\"o\">,</span>\n    <span class=\"n\">convert</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n    <span class=\"n\">ext</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">prod_filter</span><span class=\"o\">,</span> <span class=\"n\">prod_filter</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">prod_mul_distrib</span><span class=\"o\">,</span> <span class=\"n\">prod_congr</span> <span class=\"n\">rfl</span><span class=\"o\">],</span>\n    <span class=\"n\">intros</span> <span class=\"n\">b</span> <span class=\"n\">hs</span><span class=\"o\">,</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">lt_trichotomy</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"mi\">0</span> <span class=\"k\">with</span> <span class=\"n\">hb</span><span class=\"bp\">|</span><span class=\"n\">hb</span><span class=\"bp\">|</span><span class=\"n\">hb</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hb</span><span class=\"o\">,</span> <span class=\"n\">hb.not_lt</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">absurd</span> <span class=\"n\">hb</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hb</span><span class=\"o\">,</span> <span class=\"n\">hb.not_lt</span><span class=\"o\">]</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n  <span class=\"n\">refine</span> <span class=\"n\">tendsto.mul</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">tendsto_nhds</span><span class=\"o\">,</span>\n    <span class=\"c1\">-- how to use tendsto relating to a finite set?</span>\n    <span class=\"n\">intros</span> <span class=\"n\">t</span> <span class=\"n\">ht</span> <span class=\"n\">hmt</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mem_at_top_sets</span><span class=\"o\">,</span> <span class=\"n\">ge_iff_le</span><span class=\"o\">,</span> <span class=\"n\">le_eq_subset</span><span class=\"o\">,</span> <span class=\"n\">set.mem_preimage</span><span class=\"o\">],</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">hsf.to_finset</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">s'</span> <span class=\"n\">hs'</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">rw</span> <span class=\"bp\">←</span><span class=\"n\">prod_subset</span> <span class=\"o\">(</span><span class=\"n\">monotone_filter_left</span> <span class=\"n\">_</span> <span class=\"n\">hs'</span><span class=\"o\">),</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hmt</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">not_le_of_lt</span><span class=\"o\">]</span> <span class=\"o\">{</span> <span class=\"n\">contextual</span> <span class=\"o\">:=</span> <span class=\"n\">tt</span> <span class=\"o\">}</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">real.continuous_exp.tendsto</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"n\">hpos</span><span class=\"o\">,</span>\n    <span class=\"c1\">-- how to use tendsto relating to (co)mapping with `finset.image coe`?</span>\n    <span class=\"n\">rw</span> <span class=\"n\">tendsto_nhds</span> <span class=\"n\">at</span> <span class=\"n\">this</span> <span class=\"bp\">⊢</span><span class=\"o\">,</span>\n    <span class=\"n\">intros</span> <span class=\"n\">t</span> <span class=\"n\">ht</span> <span class=\"n\">hmt</span><span class=\"o\">,</span>\n    <span class=\"n\">specialize</span> <span class=\"n\">this</span> <span class=\"n\">t</span> <span class=\"n\">ht</span> <span class=\"n\">hmt</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mem_at_top_sets</span><span class=\"o\">,</span> <span class=\"n\">ge_iff_le</span><span class=\"o\">,</span> <span class=\"n\">le_eq_subset</span><span class=\"o\">,</span> <span class=\"n\">set.mem_preimage</span><span class=\"o\">,</span> <span class=\"n\">comp_app</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span> <span class=\"bp\">⊢</span><span class=\"o\">,</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">hu</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">u.map</span> <span class=\"o\">(</span><span class=\"n\">embedding.subtype</span> <span class=\"n\">_</span><span class=\"o\">),</span> <span class=\"bp\">λ</span> <span class=\"n\">v</span> <span class=\"n\">hv</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">convert</span> <span class=\"n\">hu</span> <span class=\"o\">(</span><span class=\"n\">v.subtype</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">real.exp_sum</span><span class=\"o\">,</span>\n      <span class=\"n\">convert</span> <span class=\"o\">(</span><span class=\"n\">finset.prod_subtype_mem</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">}</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span>\n      <span class=\"n\">ext</span> <span class=\"o\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">posb</span><span class=\"o\">⟩,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">real.exp_log</span> <span class=\"n\">posb</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">convert</span> <span class=\"n\">subtype_mono</span> <span class=\"n\">hv</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">finset.map_subtype</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 326638113,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1675875463
    },
    {
        "content": "<p>The \"other direction\" is much simpler:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">proddable_exp_of_summable</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">summable</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">proddable</span> <span class=\"o\">(</span><span class=\"n\">real.exp</span> <span class=\"bp\">∘</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">real.exp</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">((</span><span class=\"n\">real.continuous_exp.tendsto</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">congr</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">real.exp_sum</span><span class=\"o\">]</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 326640931,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1675876210
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113488-general/topic/infinite.20product.20clash.20with.20type.20product/near/326061985\">said</a>:</p>\n<blockquote>\n<p>I started multiplicativising <code>topology.algebra.infinite_sum</code> while on a call with Yakov yesterday. My thought is that even if we want to change the definition of <code>prodable</code>, we first want to make sure we have feature parity between the additive and multiplicative worlds.</p>\n</blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib/pull/18405\">#18405</a> (beware, huge)</p>",
        "id": 326704986,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1675898710
    },
    {
        "content": "<p>Build seems to have died with a timeout error (not sure if this is related to the PR or just random)</p>",
        "id": 326706038,
        "sender_full_name": "David Loeffler",
        "timestamp": 1675899281
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"481963\">@David Loeffler</span>  Is this more what you were thinking of?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">topology.algebra.infinite_sum</span>\n\n<span class=\"kd\">noncomputable theory</span>\n<span class=\"kn\">open</span> <span class=\"n\">finset</span> <span class=\"n\">filter</span> <span class=\"n\">function</span> <span class=\"n\">classical</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">topology</span> <span class=\"n\">classical</span> <span class=\"n\">big_operators</span> <span class=\"n\">nnreal</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">δ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">comm_monoid</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">has_prod</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">finite_not_unit</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"bp\">|</span> <span class=\"bp\">¬</span> <span class=\"n\">is_unit</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">)}</span><span class=\"bp\">.</span><span class=\"n\">finite</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">tendsto_units</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"bp\">ˣ</span><span class=\"o\">,</span> <span class=\"n\">tendsto</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"bp\">∏</span> <span class=\"n\">b</span> <span class=\"k\">in</span> <span class=\"o\">(</span><span class=\"n\">s.filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">is_unit</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">))),</span> <span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">at_top</span> <span class=\"o\">(</span><span class=\"bp\">𝓝</span> <span class=\"n\">x</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">prod_eq</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">tendsto_units.some</span> <span class=\"bp\">*</span> <span class=\"bp\">∏</span> <span class=\"n\">b</span> <span class=\"k\">in</span> <span class=\"n\">finite_not_unit.to_finset</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n</code></pre></div>\n<p><a href=\"/user_uploads/3121/WSL0Uj1z_AGasae6Uw3v646X/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/WSL0Uj1z_AGasae6Uw3v646X/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/WSL0Uj1z_AGasae6Uw3v646X/image.png\"></a></div>",
        "id": 327432337,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1676233587
    },
    {
        "content": "<p>Here are two lemmas proved about that definition (and an auxiliary one):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">converges_prod</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">has_prod</span> <span class=\"n\">f</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">has_prod_zero_iff_converges_prod_and_exists_zero</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">has_prod</span> <span class=\"n\">f</span> <span class=\"mi\">0</span> <span class=\"bp\">↔</span> <span class=\"n\">converges_prod</span> <span class=\"n\">f</span> <span class=\"bp\">∧</span> <span class=\"bp\">∃</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">h.prod_eq</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">zero_eq_mul</span><span class=\"o\">,</span> <span class=\"n\">false_or</span><span class=\"o\">,</span> <span class=\"n\">prod_eq_zero_iff</span><span class=\"o\">,</span> <span class=\"n\">units.ne_zero</span><span class=\"o\">,</span> <span class=\"n\">set.finite.mem_to_finset</span><span class=\"o\">,</span>\n               <span class=\"n\">set.mem_set_of_eq</span><span class=\"o\">,</span> <span class=\"n\">exists_prop</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩,</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">hf</span><span class=\"o\">⟩,</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">hf.finite_not_unit</span><span class=\"o\">,</span> <span class=\"n\">hf.tendsto_units</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">prod_eq_zero_iff</span><span class=\"o\">,</span> <span class=\"n\">zero_eq_mul</span><span class=\"o\">,</span> <span class=\"n\">units.ne_zero</span><span class=\"o\">,</span> <span class=\"n\">set.finite.mem_to_finset</span><span class=\"o\">,</span>\n               <span class=\"n\">set.mem_set_of_eq</span><span class=\"o\">,</span> <span class=\"n\">exists_prop</span><span class=\"o\">,</span> <span class=\"n\">false_or</span><span class=\"o\">],</span>\n    <span class=\"n\">use</span> <span class=\"n\">i</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">has_prod_ratio</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">has_prod</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">tendsto</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">sb</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">β</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"o\">(</span>\n      <span class=\"bp\">∏</span> <span class=\"n\">b</span> <span class=\"k\">in</span> <span class=\"o\">((</span><span class=\"n\">insert</span> <span class=\"n\">sb.2</span> <span class=\"n\">sb.1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">is_unit</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">))),</span> <span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">/</span>\n      <span class=\"bp\">∏</span> <span class=\"n\">b</span> <span class=\"k\">in</span> <span class=\"o\">(</span><span class=\"n\">sb.1.filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">is_unit</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">))),</span> <span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">at_top.comap</span> <span class=\"n\">prod.fst</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">𝓝</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hf.tendsto_units</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span><span class=\"n\">div_self</span> <span class=\"n\">x.ne_zero</span><span class=\"o\">,</span>\n  <span class=\"n\">simp_rw</span> <span class=\"n\">div_eq_mul_inv</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">tendsto.mul</span> <span class=\"n\">_</span> <span class=\"o\">((</span><span class=\"n\">real.tendsto_inv</span> <span class=\"n\">x.ne_zero</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">U</span> <span class=\"n\">hU</span><span class=\"o\">,</span>\n    <span class=\"n\">specialize</span> <span class=\"n\">hx</span> <span class=\"n\">hU</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">filter.mem_map</span><span class=\"o\">,</span> <span class=\"n\">mem_comap</span><span class=\"o\">,</span> <span class=\"n\">mem_at_top_sets</span><span class=\"o\">,</span> <span class=\"n\">ge_iff_le</span><span class=\"o\">,</span> <span class=\"n\">le_eq_subset</span><span class=\"o\">,</span>\n               <span class=\"n\">exists_prop</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hx</span> <span class=\"bp\">⊢</span><span class=\"o\">,</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">hs</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">set.mem_preimage</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hs</span><span class=\"o\">,</span>\n    <span class=\"n\">set</span> <span class=\"n\">s'</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">finset</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"bp\">∪</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">''</span> <span class=\"n\">set.univ</span> <span class=\"k\">with</span> <span class=\"n\">hs'</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">s'</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">hs'</span><span class=\"o\">,</span> <span class=\"n\">set.image_univ</span><span class=\"o\">,</span> <span class=\"n\">set.mem_range</span><span class=\"o\">],</span>\n      <span class=\"n\">intros</span> <span class=\"n\">t</span> <span class=\"n\">ht</span><span class=\"o\">,</span>\n      <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">t</span> <span class=\"bp\">\\</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">ht</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">hs'</span><span class=\"o\">,</span> <span class=\"n\">set.image_univ</span><span class=\"o\">],</span>\n    <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">set.mem_preimage</span><span class=\"o\">,</span> <span class=\"n\">set.mem_range</span><span class=\"o\">,</span> <span class=\"n\">forall_exists_index</span><span class=\"o\">],</span>\n    <span class=\"n\">rintro</span> <span class=\"n\">x</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"n\">hs</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">subset_union_left</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">(</span><span class=\"n\">subset_insert</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">hx.comp</span> <span class=\"n\">tendsto_comap</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">congr</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 327432408,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1676233654
    },
    {
        "content": "<p>I apologize if I am not using the right filter -- I'm still trying to figure out the best way to express \"textbook limits\" as filters in this situation.<br>\n<a href=\"/user_uploads/3121/cELeIr3nKTXRlsJjcxQCesPD/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/cELeIr3nKTXRlsJjcxQCesPD/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/cELeIr3nKTXRlsJjcxQCesPD/image.png\"></a></div>",
        "id": 327432511,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1676233715
    },
    {
        "content": "<p>This fails for products over <code>multiplicative nnreal</code> on functions with infinite support that converged additively</p>",
        "id": 327434224,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1676235072
    },
    {
        "content": "<p>(because there is only one <code>unit (multiplicative nnreal)</code>, 1)</p>",
        "id": 327434346,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1676235153
    },
    {
        "content": "<p>To give more context, Yakov's proposed definition can be additivised, and we should check the additivisation is not bogus.</p>",
        "id": 327434675,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1676235411
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>, can you say more? Why would one do infinite products over <code>multiplicative nnreal</code> as opposed to just <code>nnreal</code>?</p>",
        "id": 327434895,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1676235601
    },
    {
        "content": "<p>Infinite products over <code>multiplicative nnreal</code> should be analogous to infinite sums over <code>nnreal</code>, shouldn't they?</p>",
        "id": 327434967,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1676235631
    },
    {
        "content": "<p>Meaning that one should converge iff the other does</p>",
        "id": 327434986,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1676235644
    },
    {
        "content": "<p>I think the literature I have found so far says that one should treat infinite products differently than infinite sums.</p>",
        "id": 327435006,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1676235661
    },
    {
        "content": "<p>In particular, the additivised statement is:<br>\n<a href=\"/user_uploads/3121/ChRohV5RBiYpngm3dQ9jUJ_T/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/ChRohV5RBiYpngm3dQ9jUJ_T/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/ChRohV5RBiYpngm3dQ9jUJ_T/image.png\"></a></div>",
        "id": 327435036,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1676235687
    },
    {
        "content": "<p>I think one can't just expect an <code>add-mul</code> correspondence because, at least in the literature I've read so far, infinite products are considered in the context of rings, where <code>0</code> plays a spoiler role.</p>",
        "id": 327435165,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1676235760
    },
    {
        "content": "<p>Why is the spoiler role of 0 any different to the spoiler role of <code>\\top</code> in the additive case?</p>",
        "id": 327435203,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1676235794
    },
    {
        "content": "<p>If one wants a <code>tsum</code>-like product for some group, they can do it over <code>additive G</code>, perhaps</p>",
        "id": 327435251,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1676235827
    },
    {
        "content": "<p>Because with <code>0</code>, one can \"converge\" to 0 or diverge to 0; while with <code>\\top</code> in something that isn't extended, one can only diverge to <code>\\top</code>.</p>",
        "id": 327435376,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1676235886
    },
    {
        "content": "<p>That's my understanding so far</p>",
        "id": 327435397,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1676235899
    },
    {
        "content": "<p>Is extending a additive monoid with top any different to extending a multiplicative group with zero?</p>",
        "id": 327435441,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1676235930
    },
    {
        "content": "<p>It sounds like part of the problem is that the literature doesn't care about monoids and only rings.</p>",
        "id": 327435531,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1676235972
    },
    {
        "content": "<p>Consider the theorem in the screenshot, relating the convergence of <code>\\prod n, 1 + f_n</code> to <code>\\sum n, f_n</code> -- how would you interpret this outside of a ring's context?</p>",
        "id": 327435570,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1676236007
    },
    {
        "content": "<p>Oh, I'm sure you can't;  the question is whether having that theorem hold in rings is incompatible with having the <code>multiplicative</code> theorem I'm thinking of (<code>has_sum f a \\iff has_prod (of_add \\comp f) (of_add f)</code>) hold in monoids.</p>",
        "id": 327435871,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1676236220
    },
    {
        "content": "<p>I see -- so in the context of a monoid where nothing is <code>is_unit</code> except <code>1</code>, how does it work, right? And we can't phrase it in terms of \"non zero divisors\" if there isn't a 0 in the type.</p>",
        "id": 327436110,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1676236430
    },
    {
        "content": "<p>At the hacky end of ideas, you can case the definition on whether a zero-like element exists</p>",
        "id": 327436322,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1676236581
    },
    {
        "content": "<p>Before going hackier, I'd like to confirm from experts whether this definition is even on the way to \"morally correct\" =)</p>",
        "id": 327436499,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1676236758
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/113488-general/topic/infinite.20product.20clash.20with.20type.20product/near/326067397\">said</a>:</p>\n<blockquote>\n<p>Cancellative monoids won't be enough most of the time, though, because one would need \"continuity of subtraction\", which we don't have a typeclass for</p>\n</blockquote>\n<p>Would I be right in saying that it's continuity of <code>tsub</code> / <code>monus</code> that we don't have?</p>",
        "id": 327436527,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1676236780
    },
    {
        "content": "<p>I think the important point is that the main property is not <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_unit\">docs#is_unit</a> but <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_regular\">docs#is_regular</a>. Almost all elements of <code>nnreal</code> are not  units, but they are all regular.</p>",
        "id": 327436704,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1676236883
    },
    {
        "content": "<p>Yes and no. <code>tsub</code> looks like the best way to phrase it, but that implies having it defined in the first place. An intrinsic definition would be better, but I'm not sure how yet.</p>",
        "id": 327436987,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1676237084
    },
    {
        "content": "<blockquote>\n<p>Oh, I'm sure you can't; the question is whether having that theorem hold in rings is incompatible with having the multiplicative theorem I'm thinking of (has_sum f a \\iff has_prod (of_add \\comp f) (of_add f)) hold in monoids.</p>\n</blockquote>\n<p>I'm afraid that the way that mathematicians conventionally use infinite products in topological rings seems to be genuinely incompatible with the naive \"multiplicativization\" of infinite sums: there is no single definition of \"infinite operation on a topological monoid\" which specialises to both.</p>\n<p>(To see this, consider the product in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">Z</mi><mi>p</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}_p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.975em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span> of <code>\\lambda i : ℕ, p</code>. All terms are regular, and even \"topologically regular\" (multiplication by p is a homomorphism onto its image); but the partial sums do not converge to anything in the unit group, so this product should definitely be considered divergent. However, if you take the additivization of the topological monoid of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">Z</mi><mi>p</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}_p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.975em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span> and quotient out by the units, you get <code>with_top  ℕ</code>; and our existing treatment of sums in monoids would have <em>everything</em> converging! So I don't think these can be reconciled.)</p>\n<p><span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> In your candidate definition, what topology are you putting on <code>αˣ</code> ? Is it the subspace topology from <code>α</code>, or the subspace topology from <code>α ^ 2</code> via <code>(x, 1/x)</code>?</p>",
        "id": 327449012,
        "sender_full_name": "David Loeffler",
        "timestamp": 1676247771
    },
    {
        "content": "<p>I think in the definition as it is, it's the subspace topology from <code>α</code> because it is just evaluating the partial products in <code>α</code>, with the terms limited \"propositionally\" to the subspace of <code>is_unit</code>.<br>\nHowever, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/units.topological_space\">docs#units.topological_space</a> is the one that is <code>α × αᵐᵒᵖ</code> </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- The units of a monoid are equipped with a topology, via the embedding into `M × M`. -/</span>\n<span class=\"kd\">@[to_additive \"The additive units of a monoid are equipped with a topology, via the embedding into</span>\n<span class=\"kd\">`M × M`.\"]</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">M</span><span class=\"bp\">ˣ</span> <span class=\"o\">:=</span> <span class=\"n\">prod.topological_space.induced</span> <span class=\"o\">(</span><span class=\"n\">embed_product</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 327449448,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1676248119
    },
    {
        "content": "<p>Do you suggest to switch that topology, by using a different <code>at_top</code> filter?</p>",
        "id": 327449460,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1676248134
    },
    {
        "content": "<p>Just to check, since I've been called out by a reviewer on it being ambiguous; is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">Z</mi><mi>p</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}_p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.975em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span> the same as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi><mi mathvariant=\"normal\">/</mi><mi>p</mi><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}/p\\mathbb{Z}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mord\">/</span><span class=\"mord mathnormal\">p</span><span class=\"mord mathbb\">Z</span></span></span></span> aka <code>zmod p</code>, or something else?</p>",
        "id": 327449610,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1676248246
    },
    {
        "content": "<p>I think we're missing this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">units.uniform_space</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">uniform_space</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">uniform_space</span> <span class=\"n\">γ</span><span class=\"bp\">ˣ</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">prod.uniform_space</span> <span class=\"o\">:</span> <span class=\"n\">uniform_space</span> <span class=\"o\">(</span><span class=\"n\">γ</span> <span class=\"bp\">×</span> <span class=\"n\">γ</span><span class=\"bp\">ᵐᵒᵖ</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">comap</span> <span class=\"o\">(</span><span class=\"n\">units.embed_product</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 327450363,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1676248838
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/infinite.20product.20clash.20with.20type.20product/near/327449610\">said</a>:</p>\n<blockquote>\n<p>Just to check, since I've been called out by a reviewer on it being ambiguous; is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">Z</mi><mi>p</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}_p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.975em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span> the same as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi><mi mathvariant=\"normal\">/</mi><mi>p</mi><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}/p\\mathbb{Z}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mord\">/</span><span class=\"mord mathnormal\">p</span><span class=\"mord mathbb\">Z</span></span></span></span> aka <code>zmod p</code>, or something else?</p>\n</blockquote>\n<p>Depends on your conventions, but it would usually refer to the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span>-adic numbers, namely the inverse limit of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Z</mi><mi mathvariant=\"normal\">/</mi><msup><mi>p</mi><mi>k</mi></msup><mi mathvariant=\"normal\">Z</mi></mrow><annotation encoding=\"application/x-tex\">ℤ/p^kℤ</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0991em;vertical-align:-0.25em;\"></span><span class=\"mord amsrm\">Z</span><span class=\"mord\">/</span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span></span></span></span><span class=\"mord amsrm\">Z</span></span></span></span> over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo>=</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo separator=\"true\">,</mo><mo>…</mo></mrow><annotation encoding=\"application/x-tex\">k = 0, 1, \\dots</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8389em;vertical-align:-0.1944em;\"></span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">…</span></span></span></span>.</p>",
        "id": 327451470,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1676249757
    },
    {
        "content": "<p>In that case, David clearly means the p-adics, as else you get a boring product of zeroes.</p>",
        "id": 327451575,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1676249855
    },
    {
        "content": "<p>Number theorists invariably use <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">Z</mi><mi>p</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}_p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.975em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span> for p-adics, and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">F</mi><mi>p</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{F}_p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.975em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">F</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span> or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi><mi mathvariant=\"normal\">/</mi><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z} / p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mord\">/</span><span class=\"mord mathnormal\">p</span></span></span></span> for integers mod p. I've only encountered the other usage in algebraic topology texts, although this seems to be shifting in recent years since algebraic topologists have belatedly discovered that p-adic arithmetic is useful!</p>",
        "id": 327456450,
        "sender_full_name": "David Loeffler",
        "timestamp": 1676254963
    },
    {
        "content": "<p>Finite group theorists seem to call the cyclic group of order p <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">Z</mi><mi>p</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\Z_p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.975em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span>.</p>",
        "id": 327468715,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1676266535
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/113488-general/topic/infinite.20product.20clash.20with.20type.20product/near/326054526\">said</a>:</p>\n<blockquote>\n<p>A better definition is probably to require that, for any finite set <code>s</code>, then the product on finsets in the complement of <code>s</code> converges as these finsets grow to cover <code>univ \\ s</code>. But this would mean also changing our definition of summability, so this would be a pretty thorough refactor...</p>\n</blockquote>\n<p>As I said above, I think this is the right definition for infinite products, that takes care of the problems created by zero and still ensures that changing a proddable sequence at finitely many places still gives a proddable sequence. And its additivisation is equivalent to the usual summability definition in \"good\" monoids (i.e., those for which <code>u_n + b</code> tends to <code>a + b</code> iff <code>u_n</code> tends to <code>a</code>). In the long run, this is probably the definition we should use. But given that this will be a painful refactor, I strongly advise that we don't embark on this now and wait for after the port.</p>",
        "id": 327479289,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1676272344
    },
    {
        "content": "<p>I guess what's going on is that additively most (but not all) monoids that come up in practice are good (because they don't contain +infinity) but multiplicatively many are not (because they do contain 0). In analytic number theory you see infinite products in things like the definition of the Riemann zeta function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mo>∏</mo><mi>p</mi></msub><mo stretchy=\"false\">(</mo><mn>1</mn><mo>−</mo><msup><mi>p</mi><mrow><mo>−</mo><mi>s</mi></mrow></msup><msup><mo stretchy=\"false\">)</mo><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding=\"application/x-tex\">\\prod_p(1-p^{-s})^{-1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1858em;vertical-align:-0.4358em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∏</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.0017em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4358em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mathnormal mtight\">s</span></span></span></span></span></span></span></span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span></span></span></span> and more generally of the L-function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mo>∏</mo><mi>p</mi></msub><mi>F</mi><mo stretchy=\"false\">(</mo><msup><mi>p</mi><mrow><mo>−</mo><mi>s</mi></mrow></msup><msup><mo stretchy=\"false\">)</mo><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding=\"application/x-tex\">\\prod_p F(p^{-s})^{-1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.2499em;vertical-align:-0.4358em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∏</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.0017em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4358em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mathnormal mtight\">s</span></span></span></span></span></span></span></span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span></span></span></span> associated to an elliptic curve, modular form, Galois representation, motive etc etc. But these products only converge when the complex parameter <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">s</span></span></span></span> lies in some half plane and in this region none of the factors can be zero, yet we think of it as a product in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span> rather than the arguably more correct <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"double-struck\">C</mi><mo>×</mo></msup><mi mathvariant=\"normal\">.</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}^\\times.</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7713em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">×</span></span></span></span></span></span></span></span><span class=\"mord\">.</span></span></span></span></p>",
        "id": 327518309,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1676285770
    },
    {
        "content": "<p>It would be unnatural to exclude zero in the <a href=\"https://en.wikipedia.org/wiki/Weierstrass_factorization_theorem\">Weierstrass factorization theorem</a> and <a href=\"https://en.wikipedia.org/wiki/Blaschke_product\">Blaschke products</a> / <a href=\"https://en.wikipedia.org/wiki/Hardy_space#Factorization_into_inner_and_outer_functions_(Beurling)\">factorization of inner functions</a>, and I think proving the Weierstrass theorem would be a nice test of the API around infinite products.</p>",
        "id": 327592698,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1676306050
    }
]