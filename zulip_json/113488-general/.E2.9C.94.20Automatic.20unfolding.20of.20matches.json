[
    {
        "content": "<p>Hi all. Is there a general-purpose way to directly unfold a <code>match</code> to the underlying <code>casesOn</code>/<code>rec</code>? For example, in the following proof, I'd like to replace <code>unfold foo.match_1</code> with a more general-purpose tactic that doesn't need to name <code>foo.match_1</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">foo</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">P</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"bp\">.</span><span class=\"n\">match_1</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>I know you often use <code>split</code> to prove something like this, but in the context of a larger proof I'm writing I'd really like to just directly rewrite the match. Is there a general purpose tactic for this use-case?</p>",
        "id": 494419912,
        "sender_full_name": "Harry Goldstein",
        "timestamp": 1737139834
    },
    {
        "content": "<p>I would have expected <code>with_unfolding_all rfl</code> to work, but it doesn't <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span>.</p>",
        "id": 494427044,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1737142559
    },
    {
        "content": "<p><code>cases o &lt;;&gt; rfl</code> works</p>",
        "id": 494427429,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1737142699
    },
    {
        "content": "<p>Yes, but using cases gives a fundamentally different proof. I don’t want the proof to case on anything, I just want it to rewrite equivalent definitions.</p>",
        "id": 494427622,
        "sender_full_name": "Harry Goldstein",
        "timestamp": 1737142800
    },
    {
        "content": "<p>Usually it's smart unfolding that gets in the way <span class=\"user-mention\" data-user-id=\"372804\">@Marcus Rossel</span>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">foo</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">P</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">smartUnfolding</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 494432908,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737145143
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"686704\">@Harry Goldstein</span> I don't believe there's any tactic that does what you want.</p>",
        "id": 494433279,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737145284
    },
    {
        "content": "<p>The \"spec\" for <code>match</code> is that it's an expression that reduces only in the given patterns.</p>\n<p>Is there any way to back up and design things in a way where you're not getting into this situation where you need to show that <code>match</code> expressions are equal to recursors?</p>",
        "id": 494433501,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737145389
    },
    {
        "content": "<p>Ah, interesting. OK, it makes sense that I keep running into trouble then.</p>\n<p>The main reason I ended up down this path is because I found myself wanting to apply lemmas with a <code>match</code> in the conclusion, but since the matches didn't come from the same place they wouldn't unify. Working with recursors fixes that issue, since unification with functions is fine. That was all OK in the details of my proofs, but now I'm trying to provide a nice interface for users, and so I'm stuck trying to connect the two worlds again.</p>\n<p>If I could have avoided working with recursors in the first place, that'd help. Otherwise I'm not sure there's a way to avoid needing to turn matches into recursors.</p>",
        "id": 494435803,
        "sender_full_name": "Harry Goldstein",
        "timestamp": 1737146338
    },
    {
        "content": "<p>Instead of a <code>match</code> in the conclusion, are there any functions you can define that are specific to your situation, and then use those?</p>",
        "id": 494441761,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737148678
    },
    {
        "content": "<p>For example, <code>Option.rec P Q o</code> can be written as <code>(o.map Q).getD P</code> I think. Maybe there's another library function that is more immediate than that.</p>",
        "id": 494441929,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737148756
    },
    {
        "content": "<p>There tend to be theorems about specific functions, not general recursors, which is one reason to suggest this. It's nice being able to lean on the library.</p>",
        "id": 494441981,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737148788
    },
    {
        "content": "<p>I'm trying to keep things as generic as possible because I want the proof automation to work for user-defined data types / data types I haven't explicitly designed for. The hope was that working very generically in terms of matches / recursors would mean that my automation doesn't need to be rewritten for every data type that someone wants to work with</p>",
        "id": 494442433,
        "sender_full_name": "Harry Goldstein",
        "timestamp": 1737148983
    },
    {
        "content": "<p>In that case, if you want to try pursuing this direction, there are three options I see:</p>\n<ol>\n<li>Be sure to use recursors rather than <code>match</code> expressions.</li>\n<li>Create a version of <code>match</code> that unfolds itself to a recursor immediately.</li>\n<li>Write a tactic that unfolds <code>match</code> functions.</li>\n</ol>\n<p>These are all doable.</p>",
        "id": 494442960,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737149179
    },
    {
        "content": "<p>That makes sense. Do you have any reason to think (3) is a bad idea? I'm a little worried it could run into trouble if <code>match</code> really is designed to not be unfolded. If it seems safe enough, I'll do that in the long-term. In the short-term, (2) is probably good enough.</p>",
        "id": 494443198,
        "sender_full_name": "Harry Goldstein",
        "timestamp": 1737149284
    },
    {
        "content": "<p>I think having a tactic whose spec is \"transform <code>match</code> into recursor expressions\" is perfectly ok</p>",
        "id": 494444414,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737149816
    },
    {
        "content": "<p>OK great. Thank you!</p>",
        "id": 494444517,
        "sender_full_name": "Harry Goldstein",
        "timestamp": 1737149875
    },
    {
        "content": "<p>It's a little more questionable if <code>match</code> is making use of the internal details of how <code>match</code> is represented, but for a prototype that seems fine</p>",
        "id": 494444520,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737149876
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"686704\">Harry Goldstein</span> has marked this topic as resolved.</p>",
        "id": 494444521,
        "sender_full_name": "Notification Bot",
        "timestamp": 1737149877
    }
]