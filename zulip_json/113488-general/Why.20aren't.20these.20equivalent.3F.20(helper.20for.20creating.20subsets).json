[
    {
        "content": "<p>I'm trying to create a helper function to create subsets for dsl purposes. </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"c1\">-- approach 1</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- approach 2</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">}</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- I want this notation to work</span>\n<span class=\"c1\">-- error `S` not supported by code generator;</span>\n<span class=\"c1\">-- consider marking definition as `noncomputable`</span>\n</code></pre></div>\n<p>I assumed that the two approaches would be equivalent; the type inference would see that the lambda <code>(· &gt; 0)</code> is a <code>Nat -&gt; Prop</code>, in which case it should then conclude that <code>{x : X | p x}</code> is <code>{x : Nat | p x}</code>, which is identical to approach 1. Yet it fails.</p>\n<p>I want it to be true that <code>a = b</code></p>",
        "id": 573448268,
        "sender_full_name": "Marvin",
        "timestamp": 1770880193
    },
    {
        "content": "<p>ah, it looks like I just need to use <code>abbrev</code> and not <code>axiom</code>. Curious why that is?</p>",
        "id": 573449389,
        "sender_full_name": "Marvin",
        "timestamp": 1770880754
    },
    {
        "content": "<p>It's because <code>abbrev</code> adds a reducible definition, and <code>axiom</code> adds... an axiom.</p>",
        "id": 573451568,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1770881741
    },
    {
        "content": "<p>You're also confusing <code>:</code> with <code>:=</code> there</p>",
        "id": 573453582,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1770882646
    }
]