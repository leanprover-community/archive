[
    {
        "content": "<p>Hi everyone, I've been working for the last few weeks on a Lean-Macaulay2 interface. The idea is to be able to get all the powerful computational abilities of M2 while also building proof certificates/witnesses that allow for these computational results to be used in real Lean proofs.</p>\n<p>Towards this, I have made a prototype (<a href=\"https://github.com/riyazahuja/lean-m2\">github</a>) that extends <code>polyrith</code>. Namely, it is a tactic that can solve ideal membership questions using Grobner bases, but instead of being restricted to only polynomials in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Q</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Q}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8556em;vertical-align:-0.1667em;\"></span><span class=\"mord mathbb\">Q</span></span></span></span>, it can work over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span>,<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Q</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Q}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8556em;vertical-align:-0.1667em;\"></span><span class=\"mord mathbb\">Q</span></span></span></span>,<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span>,<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span> mod p, polynomial rings over the aforementioned, and quotient rings over the aforementioned. Moreover, these are all just special cases to show a more general Lean-M2 lifting system.</p>\n<p>This is still an early prototype, and I intend to keep developing this to adopt more and more of M2's types and functions into Lean. However, towards this, I wanted to first survey the general community to first see what kinds of use cases people would like to see of M2/CAS tools in Lean, and what you all might find the most useful. Let me know where you think this might be useful!</p>",
        "id": 522908388,
        "sender_full_name": "Riyaz Ahuja",
        "timestamp": 1749317426
    },
    {
        "content": "<p>Can Macaulay2 compute group cohomology for finite groups and finite modules and provide a witness concrete enough for lean to be able to reproduce the proof?</p>",
        "id": 522912621,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1749322752
    },
    {
        "content": "<p>Computing integral bases for rings of integers in number fields (and stuff that follows, such as computing ideal norms) would be cool. Great work in any case!</p>",
        "id": 522912805,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1749322953
    },
    {
        "content": "<p>The problem with these suggestions is that lean won't be able to work with just the answer that M2 gives, there needs to be a certificate too so that lean's kernel can verify the proofs</p>",
        "id": 522921989,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1749335112
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113488-general/topic/LeanM2/near/522912621\">said</a>:</p>\n<blockquote>\n<p>Can Macaulay2 compute group cohomology for finite groups and finite modules and provide a witness concrete enough for lean to be able to reproduce the proof?</p>\n</blockquote>\n<p>It seems that M2 supports cohomology of modules and sheaves (see: <a href=\"https://macaulay2.com/doc/Macaulay2/share/doc/Macaulay2/Macaulay2Doc/html/___H__H%5E__Z__Z_sp__Module.html\">modules</a>, <a href=\"https://macaulay2.com/doc/Macaulay2/share/doc/Macaulay2/Varieties/html/___H__H%5E__Z__Z_lp__Projective__Variety_cm__Coherent__Sheaf_rp.html\">sheaves</a>, <a href=\"https://macaulay2.com/doc/Macaulay2/share/doc/Macaulay2/BGG/html/_cohomology__Table.html?utm_source=chatgpt.com\">table</a>), but I'm not too sure on groups (probably possible in an ad-hoc way using the <a href=\"https://macaulay2.com/doc/Macaulay2/share/doc/Macaulay2/AssociativeAlgebras/html/index.html\">AssociativeAlgebras</a> package to get the group algebra?). I think that <a href=\"https://gap-packages.github.io/hap/\">GAP(HAP)</a> is a better CAS for this kind of group cohomology stuff -- as it is explicitly designed for that application. The core trick behind LeanM2 though is the type bridge, which basically just binds the types of Macaulay2 to their Mathlib counterparts, and is rather easily extended to other languages and their syntax, such as that of GAP. </p>\n<p>So in either case, as you said, getting a sufficiently explicit witness for the proof is the key question to answer if this is something that LeanM2 could feasibly add. What kind of witness does Mathlib expect for these cohomology questions?</p>",
        "id": 522936548,
        "sender_full_name": "Riyaz Ahuja",
        "timestamp": 1749358735
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466290\">Luigi Massacci</span> <a href=\"#narrow/channel/113488-general/topic/LeanM2/near/522912805\">said</a>:</p>\n<blockquote>\n<p>Computing integral bases for rings of integers in number fields (and stuff that follows, such as computing ideal norms) would be cool. Great work in any case!</p>\n</blockquote>\n<p>It seems that the <a href=\"https://macaulay2.com/doc/Macaulay2/share/doc/Macaulay2/RationalPoints2/html/index.html\">RationalPoints2</a> package has a lot of tools for exactly this (calculate integral basis, get discriminant, get Hermite NF of (fractional) ideals, and use that to get ideal norms). </p>\n<p>Also, since M2 provides the minimal polynomial, proving the basis is valid in Lean should just come down to showing integrality of elements, linear independence, and span which should be able to be automatically proven using the min poly, matrix rank, and discriminant? I don't do much algebraic number theory, so I'm not too sure how hard it would be to build this certificate, but it doesn't seem impossible.</p>",
        "id": 522937218,
        "sender_full_name": "Riyaz Ahuja",
        "timestamp": 1749359326
    },
    {
        "content": "<p>Of course these (+ all other ideas of applications) are still in the future, but I do believe that if the core type bridge is robust enough, the challenge of porting over functions from M2 (or GAP, Sage, or any other CAS) will just come down to convincing Lean that the CAS is correct with well constructed certificates. Of course, there are large classes of problems where that convincing is rather unfeasible, but I think that there are equally large classes where the computation of some object is both useful and very diffcult, but once you have a value, the confirmation of correctness is far simpler than the actual computation. It is the latter type that LeanM2 hopes to help solve.</p>",
        "id": 522937425,
        "sender_full_name": "Riyaz Ahuja",
        "timestamp": 1749359598
    },
    {
        "content": "<p>Oh if group cohomology is not there then just replace my question with module or sheaf cohomology. I was just basically trying to think of something fancy which both systems have because if one day we can say \"mathlib has formally verified sheaf cohomology calculations backed up by M2\" then it's just a random cool thing which would be completely new. </p>\n<p>As for integers of number fields, you haven't said enough to convince me yet. Proving that the basis is integral should be fine but how does one prove that the discriminant of the number field is what M2 says it is? IIRC there was some talk a while ago about getting Lean glued together with LMFDB and I could imagine that M2 could play a role here. Was it Andrew Sutherland who posted about this a few months ago? On mobile so search is crippled for me rn</p>",
        "id": 522940264,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1749364175
    },
    {
        "content": "<p>Yeah getting module/sheaf cohomology would be cool for sure, it just really depends on if we can convert some M2 output into a valid Mathlib construction of a cohomology. Building that witness will definitely be the hardest part there.</p>\n<p>With the number field stuff, maybe just use the fact that the discriminant is the determinant of the trace matrix? M2 can compute the trace matrix, and having lean prove that it is indeed a trace matrix shouldn't be impossible. Then we just have lean compute the determinant of this/confirm that M2 can correctly calculate determinant perhaps? It'd be a little annoying to implement, but it would also have the added benefit of confirming that M2 can compute determinants and discriminants explicitly, which would also probably be nice to have as a tactic.</p>",
        "id": 522979009,
        "sender_full_name": "Riyaz Ahuja",
        "timestamp": 1749391233
    },
    {
        "content": "<p>^ Not sure how difficult the mathlib api would be for these computation confirmations, but it might be a way forward? Will have to experiment more.</p>",
        "id": 522979067,
        "sender_full_name": "Riyaz Ahuja",
        "timestamp": 1749391287
    },
    {
        "content": "<p>Computing ring of integers: isn't this circular? You're saying \"you can prove the ring of integers is what we say by using the discriminant and you can prove the discriminant is what we say by using the ring of integers\"?</p>",
        "id": 523002538,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1749419864
    },
    {
        "content": "<p>Do you know about <a href=\"https://dl.acm.org/doi/10.1145/3703595.3705874\">https://dl.acm.org/doi/10.1145/3703595.3705874</a> ?</p>",
        "id": 523003376,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1749421369
    },
    {
        "content": "<p>No I did not! (or I did but forgot). Yes this is (round 2 or 4 algorithms) is the correct thing to do. Excellent!</p>",
        "id": 523020359,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1749440766
    },
    {
        "content": "<p>Since lean-m2 is already using Python, there may be interest in <a href=\"https://pypi.org/project/passagemath-macaulay2/\">https://pypi.org/project/passagemath-macaulay2/</a> -- a pip-installable Python interface to M2 which brings a prebuilt M2 in its binary wheels</p>",
        "id": 523993718,
        "sender_full_name": "Matthias Köppe",
        "timestamp": 1749838564
    },
    {
        "content": "<p>This looks like a really cool project <span class=\"user-mention\" data-user-id=\"642696\">@Riyaz Ahuja</span> !</p>\n<p>Regarding integral basis verification, in our paper (with <span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span> and <span class=\"user-mention\" data-user-id=\"133635\">@Sander Dahmen</span>), which <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> kindly linked, our approach was to define a local certificate of maximality based on the Pohst-Zassenhaus theorem, which underlies the Round 2 algorithm. We can actually avoid discriminant computations entirely in Lean (which would require either computing the trace matrix or the matrix of embeddings and its determinant, or, alternatively, the discriminant of the defining polynomial <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span>) by instead just proving to Lean the equality <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>∗</mo><mi>f</mi><mo>+</mo><mi>b</mi><mo>∗</mo><mi>f</mi><mtext>’</mtext><mo>=</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">a*f + b*f’ = n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4653em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord\">’</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> for some polynomials <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span> and non-zero integer <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>, and showing <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span>-maximality for the primes <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span> dividing <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> (if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span> does not divide <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>, then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi><mo stretchy=\"false\">[</mo><mi>α</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}[\\alpha]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"mclose\">]</span></span></span></span> is automatically <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span>-maximal by Dedekind criterion). </p>\n<p>Nonetheless, we were still interested in computing discriminants of number fields, so we ended up defining resultants and discriminants of polynomials in Lean and are currently working on computing those efficiently. </p>\n<p>Regarding CAS-Lean integration, I think having standard linear algebra tools over fields and, more generally, PIDs would be really useful. For instance: efficiently verifying the rank of a matrix or the Hermite normal form, determinant, characteristic polynomial etc.</p>",
        "id": 524737704,
        "sender_full_name": "Alain Chavarri Villarello",
        "timestamp": 1750261827
    }
]