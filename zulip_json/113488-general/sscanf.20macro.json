[
    {
        "content": "<p>Is it be possible to write a macro  like <code>sscanf!\"{String}: {Nat} - {Nat}\"</code> that would return an <code>Option (String x Nat x Nat)</code> the tuple type being the same as whatever was in the format string? Rust has a crate for this which I use a lot and I would like to have it in lean.</p>",
        "id": 407769093,
        "sender_full_name": "Conor Bergin",
        "timestamp": 1702485841
    },
    {
        "content": "<p><a href=\"https://docs.rs/sscanf/latest/sscanf/\">https://docs.rs/sscanf/latest/sscanf/</a></p>",
        "id": 407769336,
        "sender_full_name": "Conor Bergin",
        "timestamp": 1702485923
    },
    {
        "content": "<p>Yeah, you should be able to write such a macro without too much work. You could use <code>interpStr</code> to parse these curly brace strings in a general way, but you'd have to figure out how to encode parsing options somehow.</p>",
        "id": 407782981,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702490559
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"674262\">@Conor Bergin</span> Here's a prototype:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>code</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Elab</span>\n\n<span class=\"n\">declare_syntax_cat</span> <span class=\"n\">parsecTerm</span>\n<span class=\"n\">declare_syntax_cat</span> <span class=\"n\">parsecSpec</span>\n\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">term</span><span class=\"o\">)</span><span class=\"bp\">?</span> <span class=\"o\">(</span><span class=\"s2\">\" : \"</span> <span class=\"n\">parsecSpec</span><span class=\"o\">)</span><span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"n\">parsecTerm</span>\n\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">parsecStr</span><span class=\"o\">)</span> <span class=\"s2\">\"parsec!\"</span> <span class=\"n\">interpolatedStr</span><span class=\"o\">(</span><span class=\"n\">parsecTerm</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n\n<span class=\"n\">syntax</span> <span class=\"s2\">\"r16\"</span> <span class=\"o\">:</span> <span class=\"n\">parsecSpec</span>\n\n<span class=\"sd\">/-- Represents the data after the `:` in a `parsec!` string,</span>\n<span class=\"sd\">along with other incidental configuration. -/</span>\n<span class=\"kd\">structure</span> <span class=\"n\">ParsecSpec</span> <span class=\"n\">where</span>\n  <span class=\"sd\">/-- If not `none`, parse without including this character.</span>\n<span class=\"sd\">  This comes from the character immediately after the `}`. -/</span>\n  <span class=\"n\">untilChar</span><span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">Char</span>\n  <span class=\"n\">radix</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">10</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Quote</span> <span class=\"n\">Char</span> <span class=\"n\">where</span>\n  <span class=\"n\">quote</span> <span class=\"n\">c</span> <span class=\"o\">:=</span>\n    <span class=\"k\">let</span> <span class=\"n\">digs</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.toDigits</span> <span class=\"mi\">16</span> <span class=\"n\">c.toNat</span>\n    <span class=\"k\">let</span> <span class=\"n\">digs</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">List.replicate</span> <span class=\"o\">(</span><span class=\"mi\">4</span> <span class=\"bp\">-</span> <span class=\"n\">digs.length</span><span class=\"o\">)</span> <span class=\"sc\">'0'</span><span class=\"o\">)</span> <span class=\"bp\">++</span> <span class=\"n\">digs</span>\n    <span class=\"k\">let</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">String.mk</span> <span class=\"n\">digs</span>\n    <span class=\"n\">Syntax.mkLit</span> <span class=\"n\">charLitKind</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"'</span><span class=\"se\">\\\\</span><span class=\"s2\">u{n}'\"</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Quote</span> <span class=\"n\">ParsecSpec</span> <span class=\"n\">where</span>\n  <span class=\"n\">quote</span> <span class=\"n\">spec</span> <span class=\"o\">:=</span> <span class=\"n\">Unhygienic.run</span>\n    <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">ParsecSpec.mk</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">quote</span> <span class=\"n\">spec.untilChar</span><span class=\"bp\">?</span><span class=\"o\">)</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">quote</span> <span class=\"n\">spec.radix</span><span class=\"o\">))</span>\n\n<span class=\"sd\">/-- Predicate for the character not being the one in `untilChar?`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">ParsecSpec.notUntilChar</span> <span class=\"o\">(</span><span class=\"n\">spec</span> <span class=\"o\">:</span> <span class=\"n\">ParsecSpec</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Char</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span>\n  <span class=\"n\">spec.untilChar</span><span class=\"bp\">?</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">!=</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">getD</span> <span class=\"n\">true</span>\n\n<span class=\"sd\">/-- Class for associating parsers to types. -/</span>\n<span class=\"kd\">class</span> <span class=\"n\">ParsecParse</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">parse</span> <span class=\"o\">:</span> <span class=\"n\">ParsecSpec</span> <span class=\"bp\">→</span> <span class=\"n\">Lean.Parsec</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">ParsecParse</span> <span class=\"n\">Nat</span> <span class=\"n\">where</span>\n  <span class=\"n\">parse</span> <span class=\"n\">spec</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n    <span class=\"c1\">-- TODO: Should handle `spec.radix` in here.</span>\n    <span class=\"k\">let</span> <span class=\"n\">chars</span> <span class=\"bp\">←</span> <span class=\"n\">Parsec.many1Chars</span> <span class=\"o\">(</span><span class=\"n\">Parsec.satisfy</span> <span class=\"k\">fun</span> <span class=\"n\">c</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">c.isDigit</span> <span class=\"bp\">&amp;&amp;</span> <span class=\"n\">spec.notUntilChar</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n    <span class=\"n\">return</span> <span class=\"n\">chars.toNat</span><span class=\"bp\">!</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">ParsecParse</span> <span class=\"n\">String</span> <span class=\"n\">where</span>\n  <span class=\"n\">parse</span> <span class=\"n\">spec</span> <span class=\"o\">:=</span> <span class=\"n\">Parsec.manyChars</span> <span class=\"o\">(</span><span class=\"n\">Parsec.satisfy</span> <span class=\"n\">spec.notUntilChar</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- Modify the `spec` given the contents of `specStx?`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">processParsecSpec</span> <span class=\"o\">(</span><span class=\"n\">specStx</span><span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">TSyntax</span> <span class=\"bp\">`</span><span class=\"n\">parsecSpec</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">spec</span> <span class=\"o\">:</span> <span class=\"n\">ParsecSpec</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">MacroM</span> <span class=\"n\">ParsecSpec</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">specStx</span><span class=\"bp\">?</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">specStx</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">match</span> <span class=\"n\">specStx</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">parsecSpec</span><span class=\"bp\">|</span> <span class=\"n\">r16</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"o\">{</span><span class=\"n\">spec</span> <span class=\"k\">with</span> <span class=\"n\">radix</span> <span class=\"o\">:=</span> <span class=\"mi\">16</span><span class=\"o\">}</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Macro.throwUnsupported</span>\n  <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"n\">spec</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">processParsecTerm</span> <span class=\"o\">(</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">TSyntax</span> <span class=\"bp\">`</span><span class=\"n\">parsecTerm</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">untilChar</span><span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">Char</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">MacroM</span> <span class=\"o\">(</span><span class=\"n\">Term</span> <span class=\"bp\">×</span> <span class=\"n\">ParsecSpec</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">match</span> <span class=\"n\">term</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">parsecTerm</span><span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"bp\">?</span><span class=\"o\">]</span><span class=\"bp\">?</span> <span class=\"bp\">$</span><span class=\"o\">[:</span> <span class=\"bp\">$</span><span class=\"n\">spec</span><span class=\"bp\">?</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"n\">spec</span> <span class=\"bp\">←</span> <span class=\"n\">processParsecSpec</span> <span class=\"n\">spec</span><span class=\"bp\">?</span> <span class=\"o\">{</span><span class=\"n\">untilChar</span><span class=\"bp\">?</span><span class=\"o\">}</span>\n    <span class=\"k\">let</span> <span class=\"n\">ty</span> <span class=\"bp\">←</span> <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">ty</span> <span class=\"o\">:=</span> <span class=\"n\">ty</span><span class=\"bp\">?</span> <span class=\"k\">then</span> <span class=\"n\">pure</span> <span class=\"n\">ty</span> <span class=\"k\">else</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">)</span>\n    <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"n\">ty</span><span class=\"o\">,</span> <span class=\"n\">spec</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Macro.throwUnsupported</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mkTuple</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Term</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MacroM</span> <span class=\"n\">Term</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">xs</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">#</span><span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(())</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"n\">x</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">((</span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">!</span><span class=\"o\">),</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">:]),</span><span class=\"bp\">*</span><span class=\"o\">))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">expandChunks</span> <span class=\"o\">(</span><span class=\"n\">chunks</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Syntax</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MacroM</span> <span class=\"n\">Term</span> <span class=\"o\">:=</span> <span class=\"n\">withFreshMacroScope</span> <span class=\"k\">do</span>\n  <span class=\"c1\">-- Array of binder/parser pairs</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">parsers</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">Option</span> <span class=\"n\">Term</span> <span class=\"bp\">×</span> <span class=\"n\">Term</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">[]</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">res</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Term</span> <span class=\"o\">:=</span> <span class=\"o\">[]</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">untilChar</span><span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">Char</span> <span class=\"o\">:=</span> <span class=\"n\">none</span>\n  <span class=\"n\">for</span> <span class=\"n\">j</span> <span class=\"k\">in</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">:</span><span class=\"n\">chunks.size</span><span class=\"o\">]</span> <span class=\"k\">do</span>\n    <span class=\"c1\">-- Reverse order for `untilChar?` handling</span>\n    <span class=\"k\">let</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"n\">chunks.size</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">j</span>\n    <span class=\"k\">let</span> <span class=\"n\">elem</span> <span class=\"o\">:=</span> <span class=\"n\">chunks</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"bp\">!</span>\n    <span class=\"k\">match</span> <span class=\"n\">elem.isInterpolatedStrLit</span><span class=\"bp\">?</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"k\">let</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">mkIdentFrom</span> <span class=\"n\">elem</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">MonadQuotation.addMacroScope</span> <span class=\"o\">(</span><span class=\"n\">Name.appendIndexAfter</span> <span class=\"bp\">`</span><span class=\"n\">n</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n        <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">ty</span><span class=\"o\">,</span> <span class=\"n\">spec</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">processParsecTerm</span> <span class=\"o\">⟨</span><span class=\"n\">elem</span><span class=\"o\">⟩</span> <span class=\"n\">untilChar</span><span class=\"bp\">?</span>\n        <span class=\"n\">parsers</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">((</span><span class=\"n\">ParsecParse.parse</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">quote</span> <span class=\"n\">spec</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Parsec</span> <span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"o\">)))</span> <span class=\"o\">::</span> <span class=\"n\">parsers</span>\n        <span class=\"n\">res</span> <span class=\"o\">:=</span> <span class=\"n\">n</span> <span class=\"o\">::</span> <span class=\"n\">res</span>\n        <span class=\"n\">untilChar</span><span class=\"bp\">?</span> <span class=\"o\">:=</span> <span class=\"n\">none</span>\n      <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">str</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"k\">if</span> <span class=\"n\">str.utf8ByteSize</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span> <span class=\"k\">then</span>\n          <span class=\"n\">parsers</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">none</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">Parsec.skipString</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">quote</span> <span class=\"n\">str</span><span class=\"o\">)))</span> <span class=\"o\">::</span> <span class=\"n\">parsers</span>\n        <span class=\"n\">untilChar</span><span class=\"bp\">?</span> <span class=\"o\">:=</span> <span class=\"n\">str.get</span><span class=\"bp\">?</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">⟩</span>\n  <span class=\"k\">let</span> <span class=\"n\">res'</span> <span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">pure</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">mkTuple</span> <span class=\"n\">res.toArray</span><span class=\"o\">))</span>\n  <span class=\"n\">parsers.foldrM</span> <span class=\"o\">(</span><span class=\"n\">init</span> <span class=\"o\">:=</span> <span class=\"n\">res'</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">binder</span><span class=\"bp\">?</span><span class=\"o\">,</span> <span class=\"n\">parser</span><span class=\"o\">)</span> <span class=\"n\">t</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">binder</span> <span class=\"o\">:=</span> <span class=\"n\">binder</span><span class=\"bp\">?</span> <span class=\"k\">then</span>\n      <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">parser</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">binder</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">$</span><span class=\"n\">t</span><span class=\"o\">)</span>\n    <span class=\"k\">else</span>\n      <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">parser</span> <span class=\"bp\">*&gt;</span> <span class=\"bp\">$</span><span class=\"n\">t</span><span class=\"o\">)</span>\n\n<span class=\"n\">macro_rules</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">parsec</span><span class=\"bp\">!</span> <span class=\"bp\">$</span><span class=\"n\">str</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">t</span> <span class=\"bp\">←</span> <span class=\"n\">expandChunks</span> <span class=\"n\">str.raw.getArgs</span>\n    <span class=\"n\">return</span> <span class=\"n\">t</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">parsec</span><span class=\"bp\">!</span><span class=\"s2\">\"{String}: {Nat} - {Nat}\"</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">do</span>\n<span class=\"cm\">  let n_1 ← ParsecParse.parse { untilChar? := some (Char.ofNat 58) }</span>\n<span class=\"cm\">  SeqRight.seqRight (Parsec.skipString \": \") fun x ↦ do</span>\n<span class=\"cm\">      let n_3 ← ParsecParse.parse { untilChar? := some (Char.ofNat 32) }</span>\n<span class=\"cm\">      SeqRight.seqRight (Parsec.skipString \" - \") fun x ↦ do</span>\n<span class=\"cm\">          let n_5 ← ParsecParse.parse { untilChar? := none }</span>\n<span class=\"cm\">          pure (n_1, n_3, n_5) : Parsec (String × Nat × Nat)</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"n\">parsec</span><span class=\"bp\">!</span><span class=\"s2\">\"{String}: {Nat} - {Nat}\"</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">run</span> <span class=\"s2\">\"entry1: 1 - 2\"</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">Except.ok (\"entry1\", 1, 2)</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"c1\">-- This works too:</span>\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"n\">parsec</span><span class=\"bp\">!</span><span class=\"s2\">\"{}: {} - {}\"</span> <span class=\"o\">:</span> <span class=\"n\">Parsec</span> <span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"bp\">×</span> <span class=\"n\">Nat</span> <span class=\"bp\">×</span> <span class=\"n\">Nat</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">run</span> <span class=\"s2\">\"entry1: 1 - 2\"</span>\n</code></pre></div>\n</div></div>",
        "id": 407793564,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702494646
    },
    {
        "content": "<p>A couple examples:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"n\">parsec</span><span class=\"bp\">!</span><span class=\"s2\">\"{String}: {Nat} - {Nat}\"</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">run</span> <span class=\"s2\">\"entry1: 1 - 2\"</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">Except.ok (\"entry1\", 1, 2)</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"c1\">-- This works too:</span>\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"n\">parsec</span><span class=\"bp\">!</span><span class=\"s2\">\"{}: {} - {}\"</span> <span class=\"o\">:</span> <span class=\"n\">Parsec</span> <span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"bp\">×</span> <span class=\"n\">Nat</span> <span class=\"bp\">×</span> <span class=\"n\">Nat</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">run</span> <span class=\"s2\">\"entry1: 1 - 2\"</span>\n</code></pre></div>",
        "id": 407793623,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702494676
    },
    {
        "content": "<p>This theoretically supports radix specifiers like <code>{Nat : r16}</code> but I didn't implement this part.</p>",
        "id": 407793846,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702494765
    },
    {
        "content": "<p>Here's an example of extensibility:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Color</span> <span class=\"n\">where</span>\n  <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"n\">g</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">ParsecParse</span> <span class=\"n\">Color</span> <span class=\"n\">where</span>\n  <span class=\"n\">parse</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">parsec</span><span class=\"bp\">!</span><span class=\"s2\">\"({},{},{})\"</span>\n    <span class=\"n\">return</span> <span class=\"o\">{</span><span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">}</span>\n\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"n\">parsec</span><span class=\"bp\">!</span><span class=\"s2\">\"color = {Color}\"</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">run</span> <span class=\"s2\">\"color = (1,2,3)\"</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">Except.ok { r := 1, g := 2, b := 3 }</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 407795159,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702495430
    },
    {
        "content": "<p>This looks great, I wasn't expecting a working prototype within an hour! I am still working through the macro docs so it'll take me a bit to understand all of this.</p>",
        "id": 407795991,
        "sender_full_name": "Conor Bergin",
        "timestamp": 1702495808
    }
]