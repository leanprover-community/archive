[
    {
        "content": "<p>Can someone point me to any formalization work done in physics.<br>\nFor example, proving \"when a force of 1N is applied to an object of mass 1kg, it travels 2m in 2 seconds\" using Newton's laws (and required math) as axioms.</p>\n<p>Not hoping to find an actual working system, but any theoretical work, i.e. book chapters, papers dealing with rigorous proof will also be quite helpful.</p>",
        "id": 228088841,
        "sender_full_name": "Abhishek Chugh",
        "timestamp": 1614466852
    },
    {
        "content": "<p>I haven't studied this, but I think it might be asking the lines of what you're looking for<br>\n<a href=\"https://groups.csail.mit.edu/mac/users/gjs/6946/sicm-html/\">https://groups.csail.mit.edu/mac/users/gjs/6946/sicm-html/</a></p>",
        "id": 228090187,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1614468586
    },
    {
        "content": "<p>Thanks Jalex. The formal treatment is very helpful.</p>",
        "id": 228096998,
        "sender_full_name": "Abhishek Chugh",
        "timestamp": 1614477126
    },
    {
        "content": "<p>For future reference, here is another paper that discusses formalization of physics in detail</p>",
        "id": 228097120,
        "sender_full_name": "Abhishek Chugh",
        "timestamp": 1614477299
    },
    {
        "content": "<p><a href=\"https://nyuscholars.nyu.edu/en/publications/proof-verification-technology-and-elementary-physics\">https://nyuscholars.nyu.edu/en/publications/proof-verification-technology-and-elementary-physics</a></p>",
        "id": 228097121,
        "sender_full_name": "Abhishek Chugh",
        "timestamp": 1614477302
    },
    {
        "content": "<p>I'm interested in figuring out how Lean can be applied to mathematical derivations in Physics.</p>",
        "id": 367267497,
        "sender_full_name": "Ben",
        "timestamp": 1687046646
    },
    {
        "content": "<p>Can you give an example of the kinds of things you're interested in? For example, one simple example, and one thing you hope can be done eventually.</p>",
        "id": 367269982,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1687048139
    },
    {
        "content": "<p>On formalization of Hamiltonian mechancs: <a href=\"#narrow/stream/113489-new-members/topic/Bulhwi.20Cha.20.26.20Seongwoo.20Shim.3A.20Introductions/near/293911504\">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/Bulhwi.20Cha.20.26.20Seongwoo.20Shim.3A.20Introductions/near/293911504</a></p>",
        "id": 367270603,
        "sender_full_name": "Bulhwi Cha",
        "timestamp": 1687048458
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/113488-general/topic/Formal.20treatment.20for.20physics/near/367269982\">said</a>:</p>\n<blockquote>\n<p>Can you give an example of the kinds of things you're interested in? For example, one simple example, and one thing you hope can be done eventually.</p>\n</blockquote>\n<p>Hello Jireh,</p>\n<p>I've been working on a project to write down mathematical Physics -- <a href=\"https://derivationmap.net/\">https://derivationmap.net/</a><br>\nThat project is primarily focused on documenting the relations between the equations used in Physics. <br>\nI've been using a Computer Algebra System called SymPy to validate steps in derivations. <br>\nIt may be possible to use Lean to validate derivations.</p>\n<p>As very simple example, start with the equation</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>T</mi><mo>=</mo><mfrac><mn>1</mn><mi>f</mi></mfrac></mrow><annotation encoding=\"application/x-tex\">T =\\frac{1}{f}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.2019em;vertical-align:-0.8804em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3214em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8804em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></p>\n<p>where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span> is period of oscillation and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> is frequency of oscillation.<br>\nA transformation would be to multiply both sides by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> to get</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>f</mi><mi>T</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">f  T = 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></span></p>\n<p>and then divide both sides by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span> to get</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>f</mi><mo>=</mo><mfrac><mn>1</mn><mi>T</mi></mfrac></mrow><annotation encoding=\"application/x-tex\">f = \\frac{1}{T}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.0074em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3214em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></p>\n<p>That's not too exciting, but has 2 steps and is easier to understand than a 12 step derivation like<br>\n<a href=\"https://derivationmap.net/review_derivation/000004/?referrer=zulip_2023-06-17\">https://derivationmap.net/review_derivation/000004/?referrer=zulip_2023-06-17</a></p>\n<p>I'm not clear yet how to map steps in a derivation to aspects of a proof in Lean. </p>\n<p>My current understanding is that the initial expression (here <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo>=</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">T=1/f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1/</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span>) is a predicate, and the output (here <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>=</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">f=1/T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1/</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span>) is a goal? The transformations between expressions might be tactics in Lean. Alternatively, each step in a derivation might constitute a theorem. <br>\nAt this point I don't know enough about the mapping to be sure about how to proceed.</p>\n<p>I'm relatively confident that the above derivation (involving simple algebra) can be done in Lean now. I'm not clear where the boundaries are for what cannot be done in Lean. For example, Dirac notion for quantum, or Einstein notation for electrodynamics.</p>\n<p>I found <a href=\"#narrow/stream/113489-new-members/topic/Maxwell.20relation\">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/Maxwell.20relation</a> and that's aligned with what I'm interested in.</p>",
        "id": 367275406,
        "sender_full_name": "Ben",
        "timestamp": 1687050776
    },
    {
        "content": "<p>I'm interested in physics related stuff too, more on the computational side rather than formally proving everything but there is a big overlap.</p>\n<p>Looking at the derivation of the wave equation from Maxwell's equations, it looks totally doable in Lean, you could even write a widget that would extract info from the proof and display the graph.</p>\n<p>Figuring out how much information to display and how to do it in a human readable way will be the tricky part. Some tactics can do too much and some do too obvious steps.</p>\n<p>Regarding notation, by \"Dirac notion\" do you mean bra-ket notation? That should be straightforward, it might clash a bit with notation for nameless constructors, but that has to be tested. <br>\nI'm not so sure if Einstein's summation convention is a good idea, it would have to go through syntax to find repeated indentifiers and plug in a binder somewhere. Having this globally is definitely a bad idea, maybe you could define a special syntax category for physics expressions. Alternatively you just write the binders yourself i.e. instead of writing <code>T i i</code> you would write <code>\\Sigma i, T i i</code></p>",
        "id": 367316121,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1687074809
    },
    {
        "content": "<p>I assume you mean \\sum not \\Sigma</p>",
        "id": 367320782,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1687076405
    },
    {
        "content": "<p>One problem you'll have with something like <a href=\"https://derivationmap.net/review_derivation/000004/?referrer=zulip_2023-06-17\">https://derivationmap.net/review_derivation/000004/?referrer=zulip_2023-06-17</a> is that, as far as I know, mathlib doesn't have any of div/grad/curl (they can be built without too much work from <a href=\"https://leanprover-community.github.io/mathlib_docs/find/fderiv\">docs#fderiv</a>; but we don't have any proofs about them)</p>",
        "id": 367321812,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1687076762
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"346070\">Tomas Skrivan</span> <a href=\"#narrow/stream/113488-general/topic/Formal.20treatment.20for.20physics/near/367316121\">said</a>:</p>\n<blockquote>\n<p>Looking at the derivation of the wave equation from Maxwell's equations, it looks totally doable in Lean, you could even write a widget that would extract info from the proof and display the graph.</p>\n</blockquote>\n<p>Yes, after thinking about the mapping between the Physics Derivation Graph and Lean I've come up with the following. </p>\n<p>Deriving <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>=</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">f = 1/T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1/</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span> from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo>=</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">T=1/f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1/</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> is expressed in Lean as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"n\">T</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Breaking a derivation into steps is simply a sequence of related proofs:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"n\">and</span> <span class=\"k\">then</span>\n<span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"n\">T</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I think this generalizes to more complicated derivation graphs. My sketch of that observation is here: <a href=\"https://physicsderivationgraph.blogspot.com/2023/06/relation-between-inference-rules-in.html\">https://physicsderivationgraph.blogspot.com/2023/06/relation-between-inference-rules-in.html</a></p>\n<blockquote>\n<p>Figuring out how much information to display and how to do it in a human readable way will be the tricky part. Some tactics can do too much and some do too obvious steps.</p>\n</blockquote>\n<p>Agreed. My hacky approach is to make the granularity of derivation (i.e., how many steps in the derivation, aka how big are the leaps in logic) tunable. A somewhat related web demo of tunable granularity: <a href=\"https://derivationmap.net/clickable_layers?referrer=zulip_2023-06-18\">https://derivationmap.net/clickable_layers?referrer=zulip_2023-06-18</a></p>\n<blockquote>\n<p>Regarding notation, by \"Dirac notion\" do you mean bra-ket notation? That should be straightforward, it might clash a bit with notation for nameless constructors, but that has to be tested. <br>\nI'm not so sure if Einstein's summation convention is a good idea, it would have to go through syntax to find repeated indentifiers and plug in a binder somewhere. Having this globally is definitely a bad idea, maybe you could define a special syntax category for physics expressions. Alternatively you just write the binders yourself i.e. instead of writing <code>T i i</code> you would write <code>\\Sigma i, T i i</code></p>\n</blockquote>\n<p>I'll start with derivations that just rely on algebra before getting to more advanced notation, but my intent in mentioning Dirac/bra-ket notation and Einstein notation was to point to the more complicated notations that I'm hoping to include. Thank you for explaining potential paths forward.</p>",
        "id": 367390403,
        "sender_full_name": "Ben",
        "timestamp": 1687096685
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span>’s SciLean project is worth checking out!</p>\n<p><a href=\"https://github.com/lecopivo/SciLean\">https://github.com/lecopivo/SciLean</a></p>",
        "id": 367497328,
        "sender_full_name": "Tyler Josephson ⚛️",
        "timestamp": 1687146831
    }
]