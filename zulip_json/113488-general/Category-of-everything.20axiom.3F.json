[
    {
        "content": "<p>I'm curious if anyone's ever heard of or investigated the following axiom: \"Given any category C, there is a full and faithful functor from C to the category of types.\" Such an axiom might make it easier to prove things about some categories... although I admit I haven't thought it through at all.</p>",
        "id": 385743608,
        "sender_full_name": "Tanner Swett",
        "timestamp": 1692303081
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.ConcreteCategory#doc\">docs#CategoryTheory.ConcreteCategory</a> might interest you</p>",
        "id": 385744102,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1692303264
    },
    {
        "content": "<p>Fullness is a pretty big ask though</p>",
        "id": 385744134,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1692303275
    },
    {
        "content": "<p>It might even be provable in Lean if you are willing to go up a universe. Does <code>(C ⥤ Type)</code> embed into <code>Type 1</code> by sending <code>F</code> to <code>Hom (Terminal Object) F</code> work? And then you compose this with Yoneda. I haven't thought hard about this, and I'm probably missing something, but it's a suggestion.</p>",
        "id": 385744825,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1692303537
    },
    {
        "content": "<p>I would be pretty surprised if it were provable in Lean. There is a category (in fact, exactly two categories) that has exactly one object, which has exactly two endomorphisms, so this axiom would assert that there is some type <code>a</code> such that there are exactly two functions <code>a -&gt; a</code>. On the other hand, I think Lean is consistent with ordinary set theory, which asserts that there is no type <code>a</code> with exactly two functions <code>a -&gt; a</code>.</p>",
        "id": 385745746,
        "sender_full_name": "Tanner Swett",
        "timestamp": 1692303930
    },
    {
        "content": "<p>Yes, that is also provable in Lean (using choice):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.SetTheory.Cardinal.Basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Cardinal</span> <span class=\"n\">Order</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">),</span> <span class=\"bp\">#</span><span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">push_neg</span>\n  <span class=\"n\">intros</span> <span class=\"n\">α</span> <span class=\"n\">hα</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">hα</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">eq_zero_or_pos</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"bp\">#</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"n\">h</span><span class=\"bp\">|</span><span class=\"n\">h</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hα</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">succ_le_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">h.eq_or_lt</span> <span class=\"k\">with</span> <span class=\"n\">h2</span><span class=\"bp\">|</span><span class=\"n\">h2</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">h2</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hα</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">≤</span> <span class=\"bp\">#</span><span class=\"n\">α</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">succ_le_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h2</span>\n    <span class=\"n\">norm_cast</span> <span class=\"n\">at</span> <span class=\"n\">h2</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">this.eq_or_lt</span> <span class=\"k\">with</span> <span class=\"n\">h2</span><span class=\"bp\">|</span><span class=\"n\">h2</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">h2</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hα</span>\n    <span class=\"n\">norm_cast</span> <span class=\"n\">at</span> <span class=\"n\">hα</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">self_le_power</span> <span class=\"bp\">#</span><span class=\"n\">α</span> <span class=\"n\">h</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">hα</span><span class=\"o\">,</span> <span class=\"n\">h2.not_le</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n</code></pre></div>",
        "id": 385956735,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1692378403
    },
    {
        "content": "<p>You don't need choice to prove it, for this statement at least. Only <code>Quot.sound</code> is used here, so you need a pretty weak type theory for a Category of everything axiom to be consistent.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">card_not_two</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">hfg</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">≠</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">h</span> <span class=\"bp\">∨</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intro</span> <span class=\"n\">hab</span>\n    <span class=\"n\">apply</span> <span class=\"n\">hfg</span>\n    <span class=\"n\">ext</span> <span class=\"n\">x</span>\n    <span class=\"n\">exact</span> <span class=\"n\">hab</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n  <span class=\"k\">have</span> <span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intro</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"n\">rfl</span> <span class=\"bp\">|</span> <span class=\"n\">rfl</span>\n    <span class=\"bp\">·</span> <span class=\"n\">rcases</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"n\">h</span> <span class=\"bp\">|</span> <span class=\"n\">rfl</span>\n      <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">congr_fun</span> <span class=\"n\">h</span> <span class=\"n\">a</span>\n      <span class=\"bp\">·</span> <span class=\"n\">rcases</span> <span class=\"n\">h</span> <span class=\"n\">id</span> <span class=\"k\">with</span> <span class=\"n\">h</span> <span class=\"bp\">|</span> <span class=\"n\">h</span>\n        <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">congr_fun</span> <span class=\"n\">h</span> <span class=\"n\">b</span>\n        <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">congr_fun</span> <span class=\"n\">h</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n    <span class=\"bp\">·</span> <span class=\"n\">rcases</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"n\">rfl</span> <span class=\"bp\">|</span> <span class=\"n\">h</span>\n      <span class=\"bp\">·</span> <span class=\"n\">rcases</span> <span class=\"n\">h</span> <span class=\"n\">id</span> <span class=\"k\">with</span> <span class=\"n\">h</span> <span class=\"bp\">|</span> <span class=\"n\">h</span>\n        <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">congr_fun</span> <span class=\"n\">h</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n        <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">congr_fun</span> <span class=\"n\">h</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n      <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">congr_fun</span> <span class=\"n\">h</span> <span class=\"n\">a</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span>\n\n<span class=\"k\">#print</span> <span class=\"kd\">axioms</span> <span class=\"n\">card_not_two</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">card_is_two</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">hfg</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">≠</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">h</span> <span class=\"bp\">∨</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Cardinal.mk</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">letI</span> <span class=\"o\">:</span> <span class=\"n\">Fintype</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"o\">⟨⟨[</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">g</span><span class=\"o\">],</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hfg</span><span class=\"o\">]⟩,</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp_all</span><span class=\"o\">⟩</span>\n  <span class=\"n\">simp</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 385963769,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1692381602
    },
    {
        "content": "<p>No, this is because Lean implicitly assumes axiom K. In HoTT (consistent with LEM and AC) the delooping of Z/2Z has exactly two endomorphisms. (Caveat: the type of endomorphisms is not isomorphic to <code>Bool</code>, it just has cardinality 2.) However it's still impossible to get the other two-morphism-single-object category though, because there's always the constant map on inhabited objects, which is invertible iff the type is a singleton.</p>",
        "id": 386045586,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1692421489
    }
]