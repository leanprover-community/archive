[
    {
        "content": "<p>Hello!<br>\nI've worked on some combinatorial and positional game theory at : <a href=\"https://github.com/Happyves/Lean_Games\">https://github.com/Happyves/Lean_Games</a><br>\nI've formalized Zermelo's theorem, the notions of strategy stealing, of positional games and of pairing strategies,  and I've applied them to the games of Pick-up-bricks, Chomp, and Tic-tac-toe.<br>\nI'm still working on some aspects, though the versions in the folder \"gameLib\" and \"games\" are compiling and documented (but the API needs major cleaning and refactoring).</p>\n<p>It is quite unfortunate, but these topics are closely related to the recently announced formalization of Gale Stewart games:<br>\n<a class=\"stream-topic\" data-stream-id=\"113486\" href=\"/#narrow/channel/113486-announce/topic/Borel.20determinacy\">#announce &gt; Borel determinacy</a> <br>\nPerhaps we can unite the formalisms ?<br>\n<span class=\"user-mention\" data-user-id=\"651332\">@Sven Manthe</span></p>",
        "id": 479063139,
        "sender_full_name": "Yves Jäckle",
        "timestamp": 1729960850
    },
    {
        "content": "<p>I just had a very short look at your project. If I didn't misunderstand something, you are just formalizing finite time games. I don't think these results could be used to simplify anything in my project. The other way around, you could of course try to map your games to Gale-Stewart games to</p>\n<ol>\n<li>derive Zermelo's theorem from Borel (or even just closed) determinacy instead of your direct proof, and/or</li>\n<li>provide formalizations of your specific games, e.g. Chomp, as Gale-Stewart games.</li>\n</ol>\n<p>Let me also mention that most of my code really is dedicated to proving Borel determinacy itself and not to provide a nice API for games. Thus, it may be interesting to</p>\n<ol start=\"3\">\n<li>add such API (e.g., reducing games with more than two possible outcomes to my notion of games, the most powerful formalism known to me being Blackwell games).</li>\n</ol>\n<p>However, this would probably be orthogonal to the applications in descriptive set theory that are most interesting to me personally.<br>\nIf there are further connections between our projects, or you have specific plans to unite something, I'd be happy to discuss them.</p>",
        "id": 479158848,
        "sender_full_name": "Sven Manthe",
        "timestamp": 1730057574
    },
    {
        "content": "<p>I added an article to help read through the project : <a href=\"https://github.com/Happyves/Lean_Games/blob/master/GTarticle.pdf\">https://github.com/Happyves/Lean_Games/blob/master/GTarticle.pdf</a></p>\n<p><span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span>  (tagging you here as the most frequently appearing author in <code>SetTheory/Game</code>)<br>\nI wanted to ask about the option of including the work of Sven and mine in Mathlib. Of course, the inclusion may come under a set of conditions and refactors. My work is in desperate need of cleaning, for example.<br>\nThe work in <code>SetTheory/Game</code> perfectly formalizes combinatorial games in the sense that Conway defined them. I come from a background in which very concrete games are studied, such as <a href=\"https://en.wikipedia.org/wiki/Shannon_switching_game\">Shannon's switching game</a> and more generally <a href=\"https://link.springer.com/book/10.1007/978-3-0348-0825-5\">positional games</a>, or <a href=\"https://bookstore.ams.org/view?ProductCode=STML/61\">cops and robbers on graphs</a>. I found it difficult to express these games in Conway's formalism, as well as key proof arguments such as strategy stealing and pairing strategies.<br>\nI therefore wanted to ask whether mathlib would be open to a new additional formalism for this kind of game theory. Sven seems interested in game theory from the set theoretical perspective, and I am interested from the combinatorics perspective. Game theory naturally comes in many flavors, which is why I don't believe it to be problematic to have different notions of games in the library. In fact, it is probably a very interesting topic to figure out whether the formalisms in <code>SetTheory/Game</code>, those of Sven and mine, are related and how. And even with these formalisms, we have still more topics to cover, such as <a href=\"https://en.wikipedia.org/wiki/Alpha%E2%80%93beta_pruning\">alpha-beta-pruning</a>.</p>\n<p>I understand you (Kim) are a person with many duties and I - and I assume Sven as well - will do my best to contribute in such a project. <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> is aware of my project and would be interested in reviewing PRs for a possible mathlib integration.</p>",
        "id": 481003960,
        "sender_full_name": "Yves Jäckle",
        "timestamp": 1730928590
    },
    {
        "content": "<p>Let me just add that Gale-Stewart games, which I formalized, are not a particular case of Conway's games (and part of the usual graduate textbooks on descriptive set theory, so probably should become part of mathlib at some point)</p>",
        "id": 481010130,
        "sender_full_name": "Sven Manthe",
        "timestamp": 1730931491
    },
    {
        "content": "<p>I'm not at all an expert in this stuff: most of what I formalized in Mathlib about Conway's games I learnt as I was formalizing...</p>\n<p>But yes, I absolutely agree that there is more to game theory than Conway's formalism, that this is appropriate material for Mathlib, and that someone should work out how to add other formalisms. The usual caveat: it's incredibly hard to come up with good definitions!</p>",
        "id": 481012513,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1730932776
    },
    {
        "content": "<p>Wonderful <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span>  !<br>\nI'll start by PRing my lemmata about Lists. In parallel, I'll try to conclude my experiments with conditioning strategies on histories being neutral, and I'll try to find connections between the formalism of <code>PGame</code>, those of Sven and mine.</p>",
        "id": 481076389,
        "sender_full_name": "Yves Jäckle",
        "timestamp": 1730971443
    },
    {
        "content": "<p>Please write here when you make these PRs, I'm interested in that</p>",
        "id": 481166609,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1731000022
    },
    {
        "content": "<p>Certainly adding different notions of games to mathlib makes sense (along with various well-known individual games) - the idea of \"game\" is probably too general to expect that any one notion can usefully cover everything.</p>\n<p>I've thought quite a bit about what uniform conventions for consistently formalizing competition problem statements, for use as challenges for AIs (challenging AIs to solve the problems, or to autoformalize informal proofs), should look like. For problems involving games my conclusion is that ad hoc definitions for each specific problem are more appropriate than trying to fit things into a very general formalism - even if an occasional problem does fit in such a formalism, it would be better (in the context of challenging AIs on problems originally set for humans) for it to be formalized consistently with others that don't fit in such a formalism (and also consistently with those competition problems involving a sequence of choices of operations to be made with perfect information, which can be thought of as single-player games).</p>\n<p>Of course an AI would be free to use more general theory from mathlib in its solution if it so wishes. And because games allow expressions of the same problem that look so different in Lean, there might be scope for an AI challenge of the form \"prove these two very different expressions of this problem are in fact equivalent\". (An AI that could do that kind of thing would be of obvious practical use, considering how often in formalization you find you need to write a translation between different ways of expressing the same mathematical idea.)</p>\n<p>Concrete problems that do fit in very general formalisms for the notion of \"game\" may also serve as useful challenges for humans to show that a general formalism is actually usable for concrete results on such problems.</p>",
        "id": 481202916,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1731014947
    },
    {
        "content": "<p>I disagree that this is something separate from Conway's formalism. Chomp, Tic-tac-toe, and really any finite time game should perfectly fit within our <code>PGame</code> definition.</p>",
        "id": 486197931,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1733355634
    },
    {
        "content": "<p>If the issue is the layer of abstraction, then perhaps we just need better API.</p>",
        "id": 486198026,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1733355671
    },
    {
        "content": "<p>Here's a sketch for formalizing Tic-tac-toe as a <code>PGame</code>. First, you can define an auxiliary type for Tic-tac-toe game states. Then you can define the subsequency relation for both players, determining which game states can be immediately attained by the next player in a single move, given another game state. Then prove this relation is well-founded (which should be easy since each move decreases the number of available squares). Finally, the definition for Tic-tac-toe will look something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ticTacToe</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">state</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TicTacToe</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PGame</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"bp\">.</span><span class=\"n\">leftSubsequent</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"bp\">.</span><span class=\"n\">rightSubsequent</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">ticTacToe</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">ticTacToe</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"n\">termination_by</span><span class=\"w\"> </span><span class=\"n\">state</span>\n</code></pre></div>",
        "id": 486198547,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1733355968
    },
    {
        "content": "<p>In fact I was planning on doing this for the poset game (a generalization of chomp) but got stuck due to a lack of a <code>PartiallyWellOrdered</code> predicate on types (this condition is necessary to prove termination in finite time).</p>",
        "id": 486198654,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1733356053
    },
    {
        "content": "<p>Something I think would be a good idea to implement within Mathlib is an auxiliary type like <code>Game_World</code> which minimizes the boilerplate in turning a \"concrete\" game into a <code>PGame</code>. I think we can boil the definition down to the following: a type of states, and two well-founded relations which determine how both players can change states.</p>",
        "id": 486199005,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1733356257
    },
    {
        "content": "<p>We at some point had definitions like <code>PGame.Winning</code>, <code>PGame.Losing</code>, etc. which determined whether a game could be won or lost by a given player. I refactored them out since they were nothing more than <code>x &gt; 0</code>, <code>x &lt; 0</code>, etc. But if they're helpful in removing a layer of abstraction we could bring them back as abbrevs or something.</p>",
        "id": 486199215,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1733356380
    },
    {
        "content": "<p>Game theory is fragmentary enough as it is and I don't think it helps Mathlib's purpose of unifying mathematics to fragment it any further.</p>",
        "id": 486199517,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1733356562
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/113488-general/topic/Combinatorial.20and.20positional.20game.20theory.20in.20Lean/near/486199005\">said</a>:</p>\n<blockquote>\n<p>Something I think would be a good idea to implement within Mathlib is an auxiliary type like <code>Game_World</code> which minimizes the boilerplate in turning a \"concrete\" game into a <code>PGame</code>. I think we can boil the definition down to the following: a type of states, and two well-founded relations which determine how both players can change states.</p>\n</blockquote>\n<p>Here's a proof of concept of my idea: <a href=\"https://github.com/leanprover-community/mathlib4/compare/master...vi.concreteGame\">https://github.com/leanprover-community/mathlib4/compare/master...vi.concreteGame</a></p>",
        "id": 486206731,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1733361114
    },
    {
        "content": "<p>In my implementation of <code>ConcreteGame</code> I don't enforce any condition that turns be alternating. If we wanted, we could implement another layer of abstraction on top, e.g. <code>AlternatingTurnGame α β</code>, which describes the game states <code>α</code> and <code>β</code> for both players. Then an <code>AlternatingTurnGame α β</code> could be turned into a <code>ConcreteGame (α ⊕ β)</code>.</p>",
        "id": 486207531,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1733361680
    },
    {
        "content": "<p>What do you think about all this?</p>",
        "id": 486207546,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1733361693
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/AmiglLEFo5g_TJG72EOgxyw5/PGame3.lean\">PGame3.lean</a><br>\nI'm currently working on connecting the Conway formalism and mine.<br>\nHere's my progress</p>",
        "id": 486262238,
        "sender_full_name": "Yves Jäckle",
        "timestamp": 1733391682
    },
    {
        "content": "<p>What I find difficult in the Conway formalism is that the notion of a strategy is quite implicit.<br>\nThe game theory I'm interested in has many results of the form: \"for some special cases of parameters determining the game, the game does have a winning/drawing strategy for player x\". For example, for d-dimensional tic tac toe on a cube of length n, we can show that if n &gt; 3^d - 1, the players have drawing strategies.<br>\nBuilding these strategies requires being able to define them quite directly.  For example, for d-dimensional tic tac toe on a cube of length n, the trick is that for  n &gt; 3^d - 1, each combinatorial line (the set a player has to fill out to win) will contain a pair of points, so that all points considered are distinct. Then, the drawing strategy consist in selecting the opposite point of a pair whenever the opponent has selected one in the previous turn. (This is easly said, but not so easy to express in a formal context)<br>\nI'm not claiming the example above can't be expressed in Conway's formalism. I believe it makes proofs easier to have strategies be functions mapping lists of prior moves to moves to play. I'm in no way saying that the Conway formalism is pointless: it is required to derive the surreal numbers ! As I posted above, I believe it would be possible to connect the two formalisms.</p>",
        "id": 486267040,
        "sender_full_name": "Yves Jäckle",
        "timestamp": 1733393166
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/113488-general/topic/Combinatorial.20and.20positional.20game.20theory.20in.20Lean/near/486206731\">said</a>:</p>\n<blockquote>\n<p>Here's a proof of concept of my idea: <a href=\"https://github.com/leanprover-community/mathlib4/compare/master...vi.concreteGame\">https://github.com/leanprover-community/mathlib4/compare/master...vi.concreteGame</a></p>\n</blockquote>\n<p>I'm happy to see you're working on the subject too !</p>",
        "id": 486267595,
        "sender_full_name": "Yves Jäckle",
        "timestamp": 1733393377
    },
    {
        "content": "<p>In Conway's formalism, </p>\n<p><span class=\"user-mention silent\" data-user-id=\"665760\">Yves Jäckle</span> <a href=\"#narrow/channel/113488-general/topic/Combinatorial.20and.20positional.20game.20theory.20in.20Lean/near/486267040\">said</a>:</p>\n<blockquote>\n<p>Building these strategies requires being able to define them quite directly.  For example, for d-dimensional tic tac toe on a cube of length n, the trick is that for  n &gt; 3^d - 1, each combinatorial line (the set a player has to fill out to win) will contain a pair of points, so that all points considered are distinct. Then, the drawing strategy consist in selecting the opposite point of a pair whenever the opponent has selected one in the previous turn. (This is easly said, but not so easy to express in a formal context)</p>\n</blockquote>\n<p>The usual way to envision a strategy is \"if a player always replies to a game state with a given move, they will preserve some invariant, which implies they will never run out of moves, which implies they win\". I think that in order to work with Conway's formalism, it's convenient to envision a strategy in a logically equivalent but conceptually distinct way: you prove through (Conway) induction that a certain set of positions is winning for a given player, by showing that they can play so that the next player is forced to move to one of the positions you've already proved is winning.</p>\n<p>In your tic-tac-toe example, you could prove that \"every position which consists of pairs of reflected pieces, plus an extra piece, is drawing for the player in turn, by moving to the position which adds the reflection of the extra piece\". This sidesteps having to define a strategy at all!</p>",
        "id": 486269703,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1733394045
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"665760\">Yves Jäckle</span> <a href=\"#narrow/channel/113488-general/topic/Combinatorial.20and.20positional.20game.20theory.20in.20Lean/near/486267595\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/113488-general/topic/Combinatorial.20and.20positional.20game.20theory.20in.20Lean/near/486206731\">said</a>:</p>\n<blockquote>\n<p>Here's a proof of concept of my idea: <a href=\"https://github.com/leanprover-community/mathlib4/compare/master...vi.concreteGame\">https://github.com/leanprover-community/mathlib4/compare/master...vi.concreteGame</a></p>\n</blockquote>\n<p>I'm happy to see you're working on the subject too !</p>\n</blockquote>\n<p>I'm pretty much the maintainer of the <code>SetTheory</code> folder, feel free to ask anything <span aria-label=\"stuck out tongue\" class=\"emoji emoji-1f61b\" role=\"img\" title=\"stuck out tongue\">:stuck_out_tongue:</span></p>",
        "id": 486269881,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1733394108
    },
    {
        "content": "<p>I have a workshop at 12 today, so I have to get going, but I'll get back to this <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 486271311,
        "sender_full_name": "Yves Jäckle",
        "timestamp": 1733394488
    },
    {
        "content": "<p><a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Basics.20of.20game.20theory.3F\">Related thread</a></p>",
        "id": 486323592,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1733410379
    },
    {
        "content": "<p>Some thoughts:</p>\n<ul>\n<li><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/113488-general/topic/Combinatorial.20and.20positional.20game.20theory.20in.20Lean/near/486206731\">said</a>:</li>\n</ul>\n<blockquote>\n<p>Here's a proof of concept of my idea: <a href=\"https://github.com/leanprover-community/mathlib4/compare/master...vi.concreteGame\">https://github.com/leanprover-community/mathlib4/compare/master...vi.concreteGame</a></p>\n</blockquote>\n<p>I really like this formalism. I suppose one can express tic-tac-toe in it by letting alpha be <code>Fin D -&gt; Fin n -&gt; Fin 3</code> (gridpoints of the d-dimensional cube of length n, in a state of being either unclaimed, or claimed by the first or second player). Then The \"subsequent\" relation would be that there exists a point that has changed from being unclaimed to claimed, in the case that there are unclaimed points left, and no combinatorial line was fully colored. </p>\n<ul>\n<li>How would you fit the notion of a draw into Conway's formalism ? From what I understand the game is win-lose only, where a player loses if their type is empty. A speaking of this, wrt:<br>\n<span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/113488-general/topic/Combinatorial.20and.20positional.20game.20theory.20in.20Lean/near/486199215\">said</a>:</li>\n</ul>\n<blockquote>\n<p>We at some point had definitions like <code>PGame.Winning</code>, <code>PGame.Losing</code>, etc. which determined whether a game could be won or lost by a given player. I refactored them out since they were nothing more than <code>x &gt; 0</code>, <code>x &lt; 0</code>, etc. But if they're helpful in removing a layer of abstraction we could bring them back as abbrevs or something.</p>\n</blockquote>\n<p>Is my above understanding even correct ?</p>\n<ul>\n<li>Wrt:<br>\n<span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/113488-general/topic/Combinatorial.20and.20positional.20game.20theory.20in.20Lean/near/486269703\">said</a>:</li>\n</ul>\n<blockquote>\n<p>The usual way to envision a strategy is \"if a player always replies to a game state with a given move, they will preserve some invariant, which implies they will never run out of moves, which implies they win\". I think that in order to work with Conway's formalism, it's convenient to envision a strategy in a logically equivalent but conceptually distinct way: you prove through (Conway) induction that a certain set of positions is winning for a given player, by showing that they can play so that the next player is forced to move to one of the positions you've already proved is winning.</p>\n<p>In your tic-tac-toe example, you could prove that \"every position which consists of pairs of reflected pieces, plus an extra piece, is drawing for the player in turn, by moving to the position which adds the reflection of the extra piece\". This sidesteps having to define a strategy at all!</p>\n</blockquote>\n<p>This sounds like a good approach. The invariant for tic-tac-toe would be that \"for all pairs, if  one point of the pair is claimed, then the other is claimed by the other player or isn't claimed\".</p>\n<ul>\n<li>Have you thought about strategy stealing for Chomp in Conway's formalism ?</li>\n</ul>",
        "id": 486396457,
        "sender_full_name": "Yves Jäckle",
        "timestamp": 1733434177
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"690858\">Daniel Weber</span> <a href=\"#narrow/channel/113488-general/topic/Combinatorial.20and.20positional.20game.20theory.20in.20Lean/near/486323592\">said</a>:</p>\n<blockquote>\n<p><a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Basics.20of.20game.20theory.3F\">Related thread</a></p>\n</blockquote>\n<p>This is very interesting ! Though the fact that in your <code>GeneralGame</code> and in the Nash-equlibria-game-theory, players act simultaneously changes almost everything when compared to the turn-based context. I'm not aware of formal connections between these two types of game theories.</p>",
        "id": 486397220,
        "sender_full_name": "Yves Jäckle",
        "timestamp": 1733434520
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/113488-general/topic/Combinatorial.20and.20positional.20game.20theory.20in.20Lean/near/486269881\">said</a>:</p>\n<blockquote>\n<p>I'm pretty much the maintainer of the <code>SetTheory</code> folder, feel free to ask anything :P</p>\n</blockquote>\n<p>Maybe its a good idea to have one big online meeting with all people interested ?</p>",
        "id": 486397549,
        "sender_full_name": "Yves Jäckle",
        "timestamp": 1733434679
    },
    {
        "content": "<p>One by-stander comment: if I were programming, I'd make a custom enum (i.e., <code>inductive</code> in Lean with constructors <code>claimedA</code>, <code>claimedB</code>, <code>unclaimed</code> or similar). That type is finite (and in bijection to <code>Fin 3</code>), so your proofs work the same - right?</p>",
        "id": 486399202,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1733435401
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"459227\">@Violeta Hernández</span>  The ideas you stated above and in your branch may allow to make the connection between formalisms. I was thinking of:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.SetTheory.Game.Basic</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">SetTheory</span>\n\n<span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">PGame_Preds</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hist</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">win</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidablePred</span><span class=\"w\"> </span><span class=\"n\">win</span><span class=\"bp\">?</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">legal</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PGame</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">win</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"n\">hist</span>\n<span class=\"w\">  </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PGame</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">PGame.mk</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">act</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">legal</span><span class=\"w\"> </span><span class=\"n\">hist</span><span class=\"w\"> </span><span class=\"n\">act</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">act</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">legal</span><span class=\"w\"> </span><span class=\"n\">hist</span><span class=\"w\"> </span><span class=\"n\">act</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">act</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">PGame_Preds</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">act.val</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"n\">hist</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">win</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"n\">legal</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">act</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">PGame_Preds</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">act.val</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"n\">hist</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">win</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"n\">legal</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>termination may require well foundedness of the relation of a history extending another by one action, where the extention is legal and neutral (doesn't satisfy the winning predicate). We would have to assume this, and that seems similar to what's going on in my \"ConwayInduction.lean\" file.<br>\nAnyway, off to bed.</p>",
        "id": 486407516,
        "sender_full_name": "Yves Jäckle",
        "timestamp": 1733439172
    },
    {
        "content": "<p>Various <span class=\"user-mention\" data-user-id=\"665760\">@Yves Jäckle</span> replies:</p>\n<p>Yeah, <code>TicTacToe = Fin D → Fin n → Fin 3</code> (or something equivalent) would suffice to represent tic tac toe. Though this would also include some illegal states like, two X and zero O, but maybe we don't care about that. Left and right subsequency can be defined exactly as you say. To prove subsequency is well-founded, simply notice that any move by any player decreases the number of empty spaces.</p>\n<p>Draws don't really exist within Conway's formalism. At the end of each game, exactly one of the two players will win. You'd instead have to work with draws indirectly. For instance, to prove the left player always has a drawing strategy, you can add a special \"draw\" game state and declare that it's subsequent for the left player to any drawing state, but that nothing is subsequent to it. So in this modified game, what you want to prove is that the first player has a winning strategy - if they can guarantee to either win or draw in tic tac toe, then either they win in this modified game, or they first draw in tic tac toe, which gives them a move in modified tic tac toe to the \"draw\" state, which is a losing state.</p>\n<p>To prove strategy stealing in the poset game within Conway's formalism, suppose that the game is won by the second player. Then <code>{⊤}ᶜ</code> must be a winning position, and there exists some next move <code>s</code> which is losing. Show that in fact, it was possible to move to <code>s</code> from the initial position, giving a winning strategy to the first player. This is a contradiction, so actually the game is won by the first player.</p>",
        "id": 486595890,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1733519779
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"665760\">Yves Jäckle</span> <a href=\"#narrow/channel/113488-general/topic/Combinatorial.20and.20positional.20game.20theory.20in.20Lean/near/486407516\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span>  The ideas you stated above and in your branch may allow to make the connection between formalisms. </p>\n</blockquote>\n<p>I don't quite understand your code snippet. What do <code>hist</code>, <code>win?</code>, etc. represent here?</p>",
        "id": 486628259,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1733542127
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/113488-general/topic/Combinatorial.20and.20positional.20game.20theory.20in.20Lean/near/486628259\">said</a>:</p>\n<blockquote>\n<p>I don't quite understand your code snippet. What do <code>hist</code>, <code>win?</code>, etc. represent here?</p>\n</blockquote>\n<p>So the way I modeled games is by considering a list of the actions played by the players so far, <code>List β</code>,  and using predicates to decide if the game is won by a player or is a draw, and to decide if a next action is legal wrt. the previously played once (hence, the state of the game so far). Strategies end up being functions mapping <code>hist</code>ories of previous moves to the next move to play.<br>\nI think that above code snippet, or something more elaborate but in the same direction, could be the equivalent PGame representing this game.</p>",
        "id": 486652965,
        "sender_full_name": "Yves Jäckle",
        "timestamp": 1733564222
    },
    {
        "content": "<p>Well, it looks like the Conway formalism is quite capable after all !<br>\nI'll withdraw from trying to get my stuff into mathlib <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 486653405,
        "sender_full_name": "Yves Jäckle",
        "timestamp": 1733564605
    },
    {
        "content": "<blockquote>\n<p>Yeah, <code>TicTacToe = Fin D → Fin n → Fin 3</code> (or something equivalent) would suffice to represent tic tac toe. Though this would also include some illegal states like, two X and zero O, but maybe we don't care about that. Left and right subsequency can be defined exactly as you say. To prove subsequency is well-founded, simply notice that any move by any player decreases the number of empty spaces.</p>\n</blockquote>\n<p>I was going to suggest looking at Chapter 22 of Volume 3 of <em>Winning Ways for Your Mathematical Plays</em>, where Tic-Tac-Toe was analyzed, but it seems to just be a brute-force analysis and doesn't really take advantage of the Conway formulation.</p>\n<p>I haven't had time to read it, but fortunately, it does seem to analyze some generalizations of Tic-Tac-Toe that might be of interest.</p>",
        "id": 486697830,
        "sender_full_name": "Niels Voss",
        "timestamp": 1733599906
    },
    {
        "content": "<p>I looked at both Sven Manthe and Yves Jäckle's formulations some time ago, and my impression was that they both used a data structure that looked somewhat similar to <a href=\"https://en.wikipedia.org/wiki/Tree_(descriptive_set_theory)\">https://en.wikipedia.org/wiki/Tree_(descriptive_set_theory)</a></p>\n<p>Maybe it might be worth trying to get a theory of DSTTrees into Mathlib first? Just a suggestion though</p>",
        "id": 486702279,
        "sender_full_name": "Niels Voss",
        "timestamp": 1733603697
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/18763\">#18763</a> defines DSTTrees and is waiting for review. I heard much more theory has been developed in a <a href=\"https://github.com/sven-manthe/A-formalization-of-Borel-determinacy-in-Lean\">separate repository</a>.</p>",
        "id": 486703475,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1733604821
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"665760\">Yves Jäckle</span> <a href=\"#narrow/stream/113488-general/topic/Combinatorial.20and.20positional.20game.20theory.20in.20Lean/near/486652965\">said</a>:</p>\n<blockquote>\n<p>So the way I modeled games is by considering a list of the actions played by the players so far, <code>List β</code>,  and using predicates to decide if the game is won by a player or is a draw, and to decide if a next action is legal wrt. the previously played once (hence, the state of the game so far). </p>\n</blockquote>\n<p>Encoding the state of a game as its entire history is redundant for most games. For games where the history of plays is relevant, you can simply make said history the game state. In any case, you don't need to work directly with <code>List B</code>.</p>",
        "id": 486712274,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1733612207
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"521331\">Niels Voss</span> <a href=\"#narrow/stream/113488-general/topic/Combinatorial.20and.20positional.20game.20theory.20in.20Lean/near/486702279\">said</a>:</p>\n<blockquote>\n<p>I looked at both Sven Manthe and Yves Jäckle's formulations some time ago, and my impression was that they both used a data structure that looked somewhat similar to <a href=\"https://en.wikipedia.org/wiki/Tree_(descriptive_set_theory)\">https://en.wikipedia.org/wiki/Tree_(descriptive_set_theory)</a></p>\n<p>Maybe it might be worth trying to get a theory of DSTTrees into Mathlib first? Just a suggestion though</p>\n</blockquote>\n<p><code>PGame</code> already serves essentially that same purpose.</p>",
        "id": 486712378,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1733612292
    },
    {
        "content": "<p>One can think of a <code>PGame</code> as a tree with two-colored branches (representing which player can perform which move) and no infinite paths</p>",
        "id": 486712430,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1733612381
    },
    {
        "content": "<p>Borel determinacy requires a different data structure because it talks about a different type of game, with infinite length</p>",
        "id": 486712567,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1733612497
    },
    {
        "content": "<p>My impression was that <code>PGame</code> was that it was kind of like <code>PSet</code> except instead of defining sets, you defined \"double sets\". Are there tools to make defining <code>PGame</code>s easier, like being able to convert a pair of well-founded relations into a <code>PGame</code>?</p>",
        "id": 486719400,
        "sender_full_name": "Niels Voss",
        "timestamp": 1733618835
    },
    {
        "content": "<p>We have little API for constructing explicit PGames. There's <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SetTheory.PGame.ofLists#doc\">docs#SetTheory.PGame.ofLists</a> and I think that's it</p>",
        "id": 486719513,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1733618949
    },
    {
        "content": "<p>And of course, we really should have done something like <code>ofSets</code> instead.</p>",
        "id": 486719529,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1733618975
    },
    {
        "content": "<p>The thing about well founded relations you mention is basically my <code>ConcreteGame</code> idea from earlier. Note that you actually need a slightly stronger condition: the \"either of\" relation of both relations is well-founded</p>",
        "id": 486719672,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1733619079
    },
    {
        "content": "<p>To make sure I understand properly, the advantage of using <code>PGame</code> over <code>ConcreteGame</code> is that you can add games and treat them as a homogeneous class, right (kind of like the advantage of using <code>ZFSet</code> over <code>Type</code>)?</p>",
        "id": 486720270,
        "sender_full_name": "Niels Voss",
        "timestamp": 1733619619
    },
    {
        "content": "<p>What do you mean by homogeneous class?</p>\n<p><code>ConcreteGame</code> isn't meant to be a replacement for <code>PGame</code>, but rather a convenient tool for constructing them</p>",
        "id": 486720354,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1733619690
    },
    {
        "content": "<p>If we were to formulate only a single type of game, like Chess, it would make more sense to define the type <code>ChessPos</code> of chess positions and just use well founded relations on it, instead of constructing a term in <code>PGame</code>. But if you wanted to add different types of games together, then <code>PGame</code> might make more sense.</p>",
        "id": 486720894,
        "sender_full_name": "Niels Voss",
        "timestamp": 1733620195
    },
    {
        "content": "<p>Or that's my current understanding at least</p>",
        "id": 486720972,
        "sender_full_name": "Niels Voss",
        "timestamp": 1733620245
    },
    {
        "content": "<p>My <code>ConcreteGame</code> class allows you to take a term in <code>ChessPos</code> and turn it into a <code>PGame</code>, which then allows you to talk about winners, losers, and all that good stuff</p>",
        "id": 486725099,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1733624315
    },
    {
        "content": "<p>Of course you're still doing most of the logic within <code>ChessPos</code>, the <code>PGame</code> conversion is mostly just there to state the results</p>",
        "id": 486725125,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1733624375
    }
]