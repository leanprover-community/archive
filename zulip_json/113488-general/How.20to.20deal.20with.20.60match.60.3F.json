[
    {
        "content": "<p>I was trying to prove some basic facts about the following concept, namely, a partition induced by a finite set on a dense linear order without endpoints.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">StrictMono</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span>\n<span class=\"sd\">/--</span>\n<span class=\"sd\">Given `n` points `f 0, f 1, ..., f (n-1)`, this function generates a partition of `α`</span>\n<span class=\"sd\">into `2n + 1` sets. The points are assumed to be sorted.</span>\n<span class=\"sd\">The partition is `(-∞, f 0), {f 0}, (f 0, f 1), {f 1}, ..., {f (n-1)}, (f (n-1), ∞)`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">points_to_partition</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">univ</span><span class=\"o\">}</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">singletons</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⋃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)),</span><span class=\"w\"> </span><span class=\"o\">{{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">}}</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">intervals_between</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⋃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Ioo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">castSucc</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">))}</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">first_interval</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Iio</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)}</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">last_interval</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Ioi</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">last</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">))}</span>\n<span class=\"w\">  </span><span class=\"n\">singletons</span><span class=\"w\"> </span><span class=\"bp\">∪</span><span class=\"w\"> </span><span class=\"n\">intervals_between</span><span class=\"w\"> </span><span class=\"bp\">∪</span><span class=\"w\"> </span><span class=\"n\">first_interval</span><span class=\"w\"> </span><span class=\"bp\">∪</span><span class=\"w\"> </span><span class=\"n\">last_interval</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">Given a finite set of points `F`, this function induces a partition of `α` into</span>\n<span class=\"sd\">open intervals and singletons determined by the points in `F`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">finset_to_partition</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">orderEmbOfFin</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rfl</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">points_to_partition</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">OrderEmbedding</span><span class=\"bp\">.</span><span class=\"n\">strictMono</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>It works actually qutie well. I've successfully proved that these functions do generate partitions, where the \"partition\" is implemented by <code>IsPartition</code> from <code>Mathlib.Data.Setoid.Partition</code> as a predicate for <code>Set (Set α)</code></p>\n<p>But then the problem arises when I try to prove the following lemma:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- If a finite set `A` is a subset of `B`, then the partition induced by `B`</span>\n<span class=\"sd\">    is a refinement of the partition induced by `A`. -/</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">finset_to_partition_is_refinement_of_subset</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hAB</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">finset_to_partition</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">finset_to_partition</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n</code></pre></div>\n<p>The proof is quite direct. Just find some suitable set in <code>finset_to_partition A</code> for all four forms of <code>d</code> by analyzing the relationship between endpoints of <code>d</code> and <code>A</code>.</p>\n<p>At first I tried to use <code>cases h : B.card</code> and hoped that the match expression in context would collapse automatically but it didn't happen. So I had to use <code>split</code>. But then several inaccessible variables were created, and included some heterogeneous equation like <code>⇑(B.orderEmbOfFin ⋯) ≍ f✝</code>. Now I have no idea about what to do next.</p>\n<p>The problem may be raised by the <code>rfl</code> tactic in the definition of <code>finset_to_partition</code> but I don't know how to fix it.</p>",
        "id": 555714842,
        "sender_full_name": "Zikang 'Axi' Yu",
        "timestamp": 1763183821
    },
    {
        "content": "<p>Now I've found a way to completely bypass this issue by simply adding some auxiliary lemmas, but I'm still confused about the heterogeneous equation and why it appears.</p>",
        "id": 555734052,
        "sender_full_name": "Zikang 'Axi' Yu",
        "timestamp": 1763202652
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"984271\">Zikang Yu</span> <a href=\"#narrow/channel/113488-general/topic/How.20to.20deal.20with.20.60match.60.3F/near/555714842\">said</a>:</p>\n<blockquote>\n<p>At first I tried to use <code>cases h : B.card</code> and hoped that the match expression in context would collapse automatically but it didn't happen. So I had to use <code>split</code>. But then several inaccessible variables were created, and included some heterogeneous equation like <code>⇑(B.orderEmbOfFin ⋯) ≍ f✝</code>. Now I have no idea about what to do next.</p>\n</blockquote>\n<p>I don't understand. Just continue the proof? It sounds like you had a proof in mind and gave up for since reason after <code>split</code>ting the <code>match</code>.</p>",
        "id": 555736339,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763204869
    },
    {
        "content": "<p>The <code>split</code> tactic made the context quite complicated with the following inaccessible variables:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">x</span><span class=\"bp\">✝</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">StrictMono</span><span class=\"w\"> </span><span class=\"bp\">⇑</span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"bp\">.</span><span class=\"n\">orderEmbOfFin</span><span class=\"w\"> </span><span class=\"bp\">⋯</span><span class=\"o\">)</span>\n<span class=\"n\">n</span><span class=\"bp\">✝¹</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n<span class=\"n\">f</span><span class=\"bp\">✝¹</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">✝¹</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"n\">hf</span><span class=\"bp\">✝¹</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">StrictMono</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">✝¹</span>\n<span class=\"n\">n</span><span class=\"bp\">✝</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n<span class=\"n\">f</span><span class=\"bp\">✝</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">✝</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"n\">hf</span><span class=\"bp\">✝</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">StrictMono</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">✝</span>\n<span class=\"n\">heq</span><span class=\"bp\">✝²</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">✝.</span><span class=\"n\">succ</span>\n<span class=\"n\">heq</span><span class=\"bp\">✝¹</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">⇑</span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"bp\">.</span><span class=\"n\">orderEmbOfFin</span><span class=\"w\"> </span><span class=\"bp\">⋯</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≍</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">✝</span>\n<span class=\"n\">heq</span><span class=\"bp\">✝</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">✝</span><span class=\"w\"> </span><span class=\"bp\">≍</span><span class=\"w\"> </span><span class=\"n\">hf</span><span class=\"bp\">✝</span>\n<span class=\"n\">hd</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"bp\">∈</span>\n<span class=\"w\">  </span><span class=\"n\">insert</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Ioi</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">✝</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">last</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">✝</span><span class=\"o\">)))</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">insert</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Iio</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">✝</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"bp\">✝</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"bp\">∪</span><span class=\"w\"> </span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">Ioo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">✝</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">castSucc</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">✝</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">)))</span>\n</code></pre></div>\n<p>And you can see that the actual function I need to access is <code>f✝</code>, which is heterogeneously equal to <code>B.orderEmbOfFin</code>. Even I exposed <code>f✝</code> as <code>f</code>, I don't know how to prove that <code>range f = B</code>, which it should be.</p>",
        "id": 555737256,
        "sender_full_name": "Zikang 'Axi' Yu",
        "timestamp": 1763205756
    },
    {
        "content": "<p>Well we can start be using <code>rename_i</code> to name all the variables</p>",
        "id": 555738610,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763207222
    },
    {
        "content": "<p>Oh <code>Finset.orderEmbOfFin</code> takes an equality argument</p>",
        "id": 555738714,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763207346
    },
    {
        "content": "<p>This should be a lot easier if we use that instead</p>",
        "id": 555738729,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763207359
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"984271\">Zikang Yu</span> <a href=\"#narrow/channel/113488-general/topic/How.20to.20deal.20with.20.60match.60.3F/near/555737256\">said</a>:</p>\n<blockquote>\n<p>And you can see that the actual function I need to access is <code>f✝</code>, which is heterogeneously equal to <code>B.orderEmbOfFin</code>. Even I exposed <code>f✝</code> as <code>f</code>, I don't know how to prove that <code>range f = B</code>, which it should be.</p>\n</blockquote>\n<p>My guess is that you can prove that <code>range (B.orderEmbOfFin rfl) = B</code> and then just <code>grind</code> will solve it (<code>grind</code> has been pretty good at solving my intractable casting goals)</p>",
        "id": 555738896,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763207553
    },
    {
        "content": "<p><code>range (B.orderEmbOfFin rfl) = B</code> is actually trivial. The real problem is that the function in <code>hd</code> is not <code>B.orderEmbOfFin</code> but <code>f✝</code>. In summary, the very first thing to do is to connect <code>d</code> with <code>B</code>, i.e. , to handle heterogeneous equality.</p>",
        "id": 555740231,
        "sender_full_name": "Zikang 'Axi' Yu",
        "timestamp": 1763208756
    },
    {
        "content": "<p>What I mean is, first you should name <code>f✝</code> something accessible, then prove that <code>range (B.orderEmbOfFin rfl) = B</code>, and if you <code>have</code> the proof in the context then <code>grind</code> will be able to do <code>range f✝ = B</code>.</p>",
        "id": 555740527,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763209120
    },
    {
        "content": "<p>Oh, I got it, and it works! Thanks for your advice. I have totally no idea about how <code>grind</code> tactic works well on such coercion. Nevertheless, it will still be too complicated to have so many variables in context, since there's still another <code>finset_to_partition</code> in goal to unfold.</p>",
        "id": 556602064,
        "sender_full_name": "Zikang 'Axi' Yu",
        "timestamp": 1763209635
    },
    {
        "content": "<p>Try to post complete code, it makes it easier to help you. In this case you should've included:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Set</span>\n</code></pre></div>\n<p>You should've also included the partial proof that leads to the problematic context with match.</p>\n<p>Does this help you?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Set</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">Given `n` points `f 0, f 1, ..., f (n-1)`, this function generates a partition of `α`</span>\n<span class=\"sd\">into `2n + 1` sets. The points are assumed to be sorted.</span>\n<span class=\"sd\">The partition is `(-∞, f 0), {f 0}, (f 0, f 1), {f 1}, ..., {f (n-1)}, (f (n-1), ∞)`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">points_to_partition</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">StrictMono</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">univ</span><span class=\"o\">}</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">singletons</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⋃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)),</span><span class=\"w\"> </span><span class=\"o\">{{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">}}</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">intervals_between</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⋃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Ioo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">castSucc</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">))}</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">first_interval</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Iio</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)}</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">last_interval</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Ioi</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">last</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">))}</span>\n<span class=\"w\">  </span><span class=\"n\">singletons</span><span class=\"w\"> </span><span class=\"bp\">∪</span><span class=\"w\"> </span><span class=\"n\">intervals_between</span><span class=\"w\"> </span><span class=\"bp\">∪</span><span class=\"w\"> </span><span class=\"n\">first_interval</span><span class=\"w\"> </span><span class=\"bp\">∪</span><span class=\"w\"> </span><span class=\"n\">last_interval</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">Given a finite set of points `F`, this function induces a partition of `α` into</span>\n<span class=\"sd\">open intervals and singletons determined by the points in `F`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">finset_to_partition</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">orderEmbOfFin</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rfl</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">points_to_partition</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">OrderEmbedding</span><span class=\"bp\">.</span><span class=\"n\">strictMono</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- If a finite set `A` is a subset of `B`, then the partition induced by `B`</span>\n<span class=\"sd\">    is a refinement of the partition induced by `A`. -/</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">finset_to_partition_is_refinement_of_subset</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hAB</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">finset_to_partition</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">finset_to_partition</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"n\">hd</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">finset_to_partition</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hd</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">points_to_partition</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hd</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">rw!</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hd</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hd</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">rw!</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hd</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hd</span>\n<span class=\"w\">    </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"n\">hd</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">hd</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hd</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hd</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hd</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p><del>If you're using <code>cases</code> with an expression, not a variable, Lean won't replace occurrences of that expression in context, so you have to use e.g. <code>rw</code>. In this case I had to use <code>rw!</code> instead.</del><br>\nAh, sorry, <code>cases</code> actually does replaces expression. At least it tries. But it failed in this case, so you have to use <code>rw!</code> manually.<br>\nI'm not sure why</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">    </span><span class=\"n\">rw!</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hd</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hd</span>\n</code></pre></div>\n<p>worked, but <code>simp [*] at hd</code> didn't. I'm guessing it has some problems with dependant types.</p>",
        "id": 556749116,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1763357429
    }
]