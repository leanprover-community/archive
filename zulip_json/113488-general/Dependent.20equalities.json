[
    {
        "content": "<p>Consider this type</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">DEq</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">β</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n  <span class=\"bp\">|</span> <span class=\"n\">rfl</span> <span class=\"o\">:</span> <span class=\"n\">DEq</span> <span class=\"n\">x</span> <span class=\"n\">x</span> <span class=\"n\">u</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">DEq.to_HEq</span> <span class=\"o\">:</span> <span class=\"n\">DEq</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"bp\">→</span> <span class=\"n\">HEq</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">rfl</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">HEq.rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">HEq.to_DEq</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">HEq</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"bp\">→</span> <span class=\"n\">DEq</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"n\">id</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">rfl</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">DEq.rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">DEq.fst</span> <span class=\"o\">:</span> <span class=\"n\">DEq</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">rfl</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Eq.refl</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">DEq.snd</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">DEq</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">p.fst.subst</span> <span class=\"n\">u</span> <span class=\"bp\">=</span> <span class=\"n\">v</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">rfl</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Eq.refl</span> <span class=\"n\">_</span>\n</code></pre></div>\n<p>This can be regarded as a compromise between <code>Eq</code> and <code>HEq</code>, potentially having the benefits of both. Is this tried out anywhere in mathlib?</p>",
        "id": 323474184,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1674650096
    },
    {
        "content": "<p>This shows up in an indirect way in things like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/simple_graph.walk.copy\">docs#simple_graph.walk.copy</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/quiver.hom.cast\">docs#quiver.hom.cast</a> where rather than having a separate inductive type, there's some syntactic way of writing down the concept with explicit equalities on indices. (These are both with two indices rather than your <code>DEq</code>'s one index on <code>β</code>.)</p>",
        "id": 323476097,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1674650700
    },
    {
        "content": "<p>The <code>DEq</code> type can also be written in another form using just existentials and <code>Eq</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">DEq_iff</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">DEq</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">),</span> <span class=\"n\">h.subst</span> <span class=\"n\">u</span> <span class=\"bp\">=</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">h</span>\n    <span class=\"n\">cases</span> <span class=\"n\">h</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">h</span>\n    <span class=\"n\">cases</span> <span class=\"n\">h</span>\n    <span class=\"n\">subst_vars</span>\n    <span class=\"n\">constructor</span>\n</code></pre></div>",
        "id": 323476231,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1674650739
    },
    {
        "content": "<p>The nice thing about <code>DEq</code>-like relations (and this <code>cast</code> pattern for homs/walks) is that they preserve the equality on the index. This is much more powerful than just working with <code>HEq</code>, which only remembers equality on the whole type. You can't recover index equalities from type equalities in general.</p>",
        "id": 323476586,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1674650833
    },
    {
        "content": "<p>A design question then is whether you have a <code>DEq</code> type (well, one for every number of indices you might have) or instead work with the <code>∃ (h : x = y), h.subst u = v</code> form more directly (and define a special <code>subst</code> for your type so that simp lemmas don't put things into an inconvenient form involving subst of an entire type rather than just the indices). The second way seems to be convenient to work with, but I have no idea if it would be better to pursue the first way.</p>",
        "id": 323478762,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1674651450
    },
    {
        "content": "<p>One point against developing <code>DEq</code> is that <code>HEq</code> is sufficient if you have index equalities hanging around:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">DEq_iff'</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">DEq</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"bp\">↔</span> <span class=\"n\">HEq</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">h</span>\n    <span class=\"n\">cases</span> <span class=\"n\">h</span>\n    <span class=\"n\">rfl</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">h</span>\n    <span class=\"n\">cases</span> <span class=\"n\">h</span>\n    <span class=\"n\">constructor</span>\n</code></pre></div>",
        "id": 323479185,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1674651571
    },
    {
        "content": "<p>I explored this a little in <a href=\"https://github.com/leanprover-community/mathlib/pull/10712\">#10712</a></p>",
        "id": 323493054,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1674655589
    },
    {
        "content": "<p>I have an experiment in <a href=\"https://github.com/leanprover-community/mathlib/blob/simple_graphs2/src/combinatorics/simple_graph/walks.lean\">this branch</a> from a couple years ago for this but for two-index types (walks in graphs). Rather than a new inductive type, <code>heqi</code> ( \"heterogeneous equality that equates indices\") is defined as a plain <code>Prop</code>.</p>",
        "id": 323494807,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1674655964
    }
]