[
    {
        "content": "<p>Is the dependency resolution algorithm of <code>lake update</code> specified anywhere? I'd like to know how it handles transitive dependencies, e.g. package A depends on package B at version 1 and package C, and package C depends on package B at version 2. From digging around the CLI output and the <code>.lake</code> file, my understanding is that <code>lake update</code> must choose one version of package B to install, either version 1 or version 2.</p>\n<p>(If so, one common solution adopted by other package managers is to choose the more recent version, but I noticed when reading the <a href=\"https://github.com/leanprover/lean4/tree/master/src/lake#toml-require\">docs for how versions are specified</a> that git dependencies are specified by \"<code>rev</code>\" which is a git commit hash or a git tag (and maybe some other options? It's not documented), but neither are linearly ordered in general. Reservoir dependencies are specified by <code>version</code> which is more promising, but the version format is also not documented)</p>\n<p>(Another question is that in situations like this, packages ought to be able to declare range dependencies, e.g. this package is compatible with mathlib v4.5-v4.10, e.g. <a href=\"https://pip.pypa.io/en/stable/reference/requirement-specifiers/\">like so</a> in python, but I couldn't find the syntax for range dependencies in the docs)</p>\n<p>(For context, I was debugging a situation where B=mathlib, C=<a href=\"https://github.com/kmill/LeanTeX-mathlib\">LeanTeX-Mathlib</a>)</p>",
        "id": 518887328,
        "sender_full_name": "Li Xuanji",
        "timestamp": 1747544998
    },
    {
        "content": "<p>This is not supported as far as I'm aware</p>",
        "id": 518891332,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1747548790
    },
    {
        "content": "<p>From memory it is just a depth-first search. Lake looks at the first dependency, and pulls in all its dependencies, then moves on, ignoring repeats even if the <code>rev</code> field differs. Obviously this is not not good enough, and Mac is working on it! :-)</p>",
        "id": 518896411,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1747553505
    },
    {
        "content": "<blockquote>\n<p>Lake looks at the first dependency, and pulls in all its dependencies, then moves on, ignoring repeats even if the <code>rev</code> field differs.</p>\n</blockquote>\n<p>Thanks! Is this true even if all the dependencies are reservoir dependencies?</p>",
        "id": 518936649,
        "sender_full_name": "Li Xuanji",
        "timestamp": 1747586125
    },
    {
        "content": "<p>To elaborate a bit, Lake does not exactly use a depth-first search. It resolves all dependencies of the same package at once then does progresses depth-first. That is, the dependencies of the top-level package take precedence over any nested dependencies. This is explained in a <a href=\"https://github.com/leanprover/lean4/blob/c8290bd94221f41ae49899f0f7de71b52724ad7e/src/lake/Lake/Load/Resolve.lean#L307\">comment</a> in the code.</p>\n<p>This is not documented more publicly because this  is expected to change (as Kim said), and we would prefer users avoid relying on a particular ordering at this time.</p>",
        "id": 518940230,
        "sender_full_name": "Mac Malone",
        "timestamp": 1747589075
    },
    {
        "content": "<p>Thanks! That's a helpful comment.</p>\n<p>Understood about not exposing this implementation detail, but perhaps the following could be documented, since these sound like they will be around forever?</p>\n<ol>\n<li><code>lake</code> will choose exactly one version for each dependency in the transitive closure of the dependency graph (i.e. it won't do something like <code>npm</code> where version 1 and version 2 can coexist in the resolved dependency tree)</li>\n<li>If you want to \"override\" a dependency's transitive dependency, include it in your own <code>lakefile.toml</code></li>\n</ol>",
        "id": 519257914,
        "sender_full_name": "Li Xuanji",
        "timestamp": 1747701820
    },
    {
        "content": "<p>I agree it would be great to have this documented, but it's certainly not the plan for this to be around forever.</p>",
        "id": 519526533,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1747806113
    },
    {
        "content": "<p>Well in 'worse is better', my documentation on this for an AI agent is just linking this zulip issue.</p>",
        "id": 519703618,
        "sender_full_name": "Alok Singh",
        "timestamp": 1747862449
    },
    {
        "content": "<blockquote>\n<p>not the plan for this to be around forever.</p>\n</blockquote>\n<p>Oh? I was under the impression that the \"npm strategy\" isn't feasible for dependently-typed languages if you're writing proofs.</p>",
        "id": 519706278,
        "sender_full_name": "Li Xuanji",
        "timestamp": 1747863731
    }
]