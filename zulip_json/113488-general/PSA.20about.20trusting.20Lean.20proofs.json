[
    {
        "content": "<p>I showed the following example to <span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> yesterday and he was surprised, so maybe this is not widely known: you can very easily trick Lean into accepting a proof of <code>False</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span>\n\n<span class=\"n\">elab</span> <span class=\"s2\">\"add_false\"</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"n\">modifyEnv</span> <span class=\"bp\">λ</span> <span class=\"n\">env</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"kd\">constants</span> <span class=\"o\">:=</span> <span class=\"n\">env.constants.insert</span> <span class=\"bp\">`</span><span class=\"n\">falso</span> <span class=\"bp\">$</span> <span class=\"n\">ConstantInfo.thmInfo</span>\n      <span class=\"o\">{</span> <span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"n\">falso</span>\n        <span class=\"n\">levelParams</span> <span class=\"o\">:=</span> <span class=\"o\">[]</span>\n        <span class=\"n\">type</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">``</span><span class=\"n\">False</span> <span class=\"o\">[]</span>\n        <span class=\"n\">value</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">``</span><span class=\"n\">False</span> <span class=\"o\">[]</span>\n      <span class=\"o\">}</span>\n    <span class=\"o\">{</span> <span class=\"n\">env</span> <span class=\"k\">with</span> <span class=\"kd\">constants</span> <span class=\"o\">}</span>\n\n<span class=\"n\">add_false</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span>\n   <span class=\"n\">falso</span>\n</code></pre></div>\n<p>What happens here?</p>\n<ul>\n<li>Using the metaprogramming APIs, we add a \"proof\" of <code>False</code> to the environment. The proof is bogus, of course, but we never send it to the kernel for checking, so nobody complains.</li>\n<li>Lean assumes that things in the environment have been checked by the kernel and doesn't re-check them when we use the bogus proof.</li>\n</ul>\n<p>In practice, this means that if someone you don't trust hands you a proof and Lean says the proof is okay, this assurance doesn't mean much. Even <code>--trust=0</code> doesn't help. You can, however, use an external checker, which will detect nonsense like this. (I'm not sure whether we currently have an external checker than can check mathlib.)</p>\n<p>Of course, we don't usually use Lean proofs in adversarial situations, so this is probably not a big issue. The most realistic exploit I could come up with is academic fraud: a scientist with more ambition than scruples could hide this trick in a superficially convincing 'automate all the things' tactic and use it to publish very impressive proofs. However, if anyone else tries to use the tactic, they may find that it proves false statements.</p>",
        "id": 392684837,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1695468614
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span>\n   <span class=\"n\">falso</span>\n\n<span class=\"k\">#print</span> <span class=\"kd\">axioms</span> <span class=\"n\">foo</span> <span class=\"c1\">-- 'foo' does not depend on any axioms</span>\n</code></pre></div>\n<p>Yeah that is not ideal as far as I'm concerned. What if I finish my proof of Fermat's Last Theorem and someone accuses me of cheating like that?</p>",
        "id": 392685570,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1695469260
    },
    {
        "content": "<p>I guess without some silliness like cryptographic signing there has to be trust somewhere (in this case that the actors mutating the environment are honest).</p>\n<p><del>Removing comment that was too vague</del></p>",
        "id": 392689234,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1695470828
    },
    {
        "content": "<p>Was this possible in Lean 3 too?</p>",
        "id": 392691619,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1695471662
    },
    {
        "content": "<p>This seem pretty troublesome even for benevolent actors; things like <code>@[mk_iff]</code> or derive handlers if written incorrectly could be adding things to the environment without sending them to the kernel</p>",
        "id": 392691855,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1695471750
    },
    {
        "content": "<p>I hope there is a way to detect that the environment was changed to a new environment where not all declarations were sent to the kernel, without affecting performance too much. Hopefully we can get the kernel to check the added declaration, either the moment you change the environment, or maybe when you use it / try to write a olean file.</p>",
        "id": 392691955,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1695471788
    },
    {
        "content": "<p>In the meantime, can we add a command (e.g. to mathlib) that verifies that all declarations in the current env have been checked by the kernel? At least that way Kevin can run the <code>im_not_evil</code> command after his proof of FLT to be more convincing?</p>",
        "id": 392694029,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1695472696
    },
    {
        "content": "<p>Isn't there a way to run the kernel on the generated olean file, which would hopefully <em>not</em> work? I agree that's not ideal, but at least that's a check.</p>",
        "id": 392694255,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1695472909
    },
    {
        "content": "<p>This bypasses kernel-checking on the <code>falso</code>declaration entirely, and directly adds the declaration to the environment without verifying it's well-formed. The fact that such low-level environment manipulation is exposed to the user is worrying IMO.</p>",
        "id": 392694694,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1695473251
    },
    {
        "content": "<p>Ideally, the only \"exposed\" interface to generate/modify <code>Environment</code>s should be <code>Lean.Environment.addDecl</code>, I don't believe any user should need/be allowed to remove/add declarations on the fly with no checks whatsoever. In a similar manner to the `falso trick, someone could easily remove some core constants from the environment, making most other declarations already present in the environment not well-formed anymore.</p>",
        "id": 392695400,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1695473874
    },
    {
        "content": "<p>I don't agree with this. One thing that's so nice about lean4 is that you as a user have control over everything.</p>",
        "id": 392695584,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1695474033
    },
    {
        "content": "<p>The one thing a user shouldn't have control over is adding a proof of false to the environment.</p>",
        "id": 392695662,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1695474062
    },
    {
        "content": "<p>The environment is critical to soundness, and theoretically meaningful. For the same reason that users aren't allowed to make ill-typed terms, users shouldn't be allowed to make ill-typed contexts for other terms to be type-checked in.</p>",
        "id": 392695748,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1695474101
    },
    {
        "content": "<p>I wonder what <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> 's opinion is on this.</p>",
        "id": 392696022,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1695474196
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/113488-general/topic/PSA.20about.20trusting.20Lean.20proofs/near/392695662\">said</a>:</p>\n<blockquote>\n<p>The one thing a user shouldn't have control over is adding a proof of false to the environment.</p>\n</blockquote>\n<p>The solution to that is exactly what I'm proposing: You should only be allowed to add declarations using <code>Lean.Environment.addDecl</code>, which makes the kernel type-check the declaration before adding it.</p>",
        "id": 392696289,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1695474284
    },
    {
        "content": "<p>Having metaprograms run in the same process as the system is inherently problematic for absolute soundness. As Jannis already mentioned, external checkers are the best defense in depth against such concerns. We are certainly interested in cultivating the same variety of checkers that we had in Lean 3. In fact, with the API Lean 4 provides, it should be quite easy to write a small Lean program that loads the .olean closure of a module and (re)sends all declarations through the kernel without ever running any metaprograms. Using the file format of <a href=\"https://github.com/Kha/lean4export\">https://github.com/Kha/lean4export</a> would be the next step after that.</p>",
        "id": 392696569,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1695474379
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/113488-general/topic/PSA.20about.20trusting.20Lean.20proofs/near/392695662\">said</a>:</p>\n<blockquote>\n<p>The one thing a user shouldn't have control over is adding a proof of false to the environment.</p>\n</blockquote>\n<p>I think the argument for allowing this is that it permits the user to serialize and reload an environment without having to re-check all the declarations that were serialized</p>",
        "id": 392698895,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1695475538
    },
    {
        "content": "<p>How long would you expect a minimal independent Rust checker to be?  Is there one of those for Lean 3 to compare against?</p>",
        "id": 392700390,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1695476300
    },
    {
        "content": "<p><a href=\"https://github.com/ammkrn/nanoda_lib\">https://github.com/ammkrn/nanoda_lib</a></p>",
        "id": 392701220,
        "sender_full_name": "David Renshaw",
        "timestamp": 1695476753
    },
    {
        "content": "<p><a href=\"#narrow/stream/270676-lean4/topic/Export.20format/near/351096525\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Export.20format/near/351096525</a></p>",
        "id": 392701304,
        "sender_full_name": "David Renshaw",
        "timestamp": 1695476786
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/PSA.20about.20trusting.20Lean.20proofs/near/392685570\">said</a>:</p>\n<blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span>\n   <span class=\"n\">falso</span>\n\n<span class=\"k\">#print</span> <span class=\"kd\">axioms</span> <span class=\"n\">foo</span> <span class=\"c1\">-- 'foo' does not depend on any axioms</span>\n</code></pre></div>\n<p>Yeah that is not ideal as far as I'm concerned. What if I finish my proof of Fermat's Last Theorem and someone accuses me of cheating like that?</p>\n</blockquote>\n<p>Could a <code>#print axioms</code> like command simply print all the terms of type <code>False</code> in the environment? Could it then filter down to those terms used in a proof?</p>",
        "id": 392701759,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1695477015
    },
    {
        "content": "<p>No because I can just prove false statements instead, rather than <code>False</code> itself.</p>",
        "id": 392702133,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1695477219
    },
    {
        "content": "<p>They don't even need to be false, just results that you can't be bothered to prove</p>",
        "id": 392703403,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1695478088
    },
    {
        "content": "<p>Sounds like we're going to have <code>h : FLT</code> in Lean much sooner than expected!</p>",
        "id": 392703435,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1695478113
    },
    {
        "content": "<p>What are the barriers to converting nanoda or the other external checkers to Lean 4.  The logic should be almost the same, right?  Is it just no export format for Lean 4?</p>",
        "id": 392704545,
        "sender_full_name": "Jason Rute",
        "timestamp": 1695478884
    },
    {
        "content": "<p>My understanding is that it will not be much more difficult to write a Lean 4 typechecker than a Lean 3 one, and several Lean 3 ones got written. I think it's just on nobody's priority list right now?</p>",
        "id": 392704657,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1695478984
    },
    {
        "content": "<p>I think the only real new requirement is the existence of a trusted bignum library in the language you want to implement your typechecker in.</p>",
        "id": 392705336,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1695479537
    },
    {
        "content": "<p>Hi everyone,</p>\n<p>I'd like to echo Sebastian's message and provide a clearer outline of our plans regarding external checkers at the Lean FRO (<a href=\"http://lean-fro.org\">http://lean-fro.org</a>)</p>\n<ul>\n<li>\n<p><strong>Short Term</strong>: We plan to introduce a new executable to serve as an .olean checker. This will be a compact Lean program designed to import .olean files and carry out type checks on its declarations. Given its simplicity, this checker doesn't have to be anchored in the core. Moreover, Lean users are free to craft their own versions as per their requirements. Note this kind of checker is sufficient for the issue raised in this thread.</p>\n</li>\n<li>\n<p><strong>Mid Term</strong>: We're working on developing a reader tailored for the Lean 4 export format in Lean described in Sebastian's message. The plan is to extend the checker mentioned in the previous step to support this format.</p>\n</li>\n<li>\n<p><strong>Long Term</strong>: We're committed to ensuring that Chris Bailey's Rust checker is seamlessly ported to Lean 4. Conversations with him are already underway to ascertain that this transition materializes. We hope many other checkers will be available in the future.</p>\n</li>\n</ul>\n<p>Thank you for your understanding and support as we work through these stages.</p>",
        "id": 392705540,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1695479742
    },
    {
        "content": "<p>Anatole, I don't think this is requirement if you are ready to see your external checker to be much slower than the Lean kernel.</p>",
        "id": 392705635,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1695479810
    },
    {
        "content": "<p>Well if external type checkers go back to unary representation of natural numbers, wouldn't it mean that we can't really use the \"better nat reduction\" feature of the mainstream kernel?</p>",
        "id": 392706176,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1695480270
    },
    {
        "content": "<p>Thank you <span class=\"user-mention\" data-user-id=\"256311\">@Jannis Limperg</span> very much for announcing this issue publicly!<br>\nI can't stress enough how important it is for us all to be informed about Lean's soundness issues.</p>",
        "id": 392707386,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1695481423
    },
    {
        "content": "<p>I wouldn't call that a Lean soundness issue.</p>",
        "id": 392707699,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1695481669
    },
    {
        "content": "<p>Is there any way to tell (via something like <code>#print axioms</code>) that this \"exploit\" hasn't been secretly performed?</p>",
        "id": 392717388,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1695486232
    },
    {
        "content": "<p>For example, could we force Lean to recompile all of mathlib to check that all definitions are correct (i.e. not trusting oleans)?</p>",
        "id": 392717469,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1695486293
    },
    {
        "content": "<p>(not sure if this is really the correct phrasing of what I want to ask but hopefully it makes enough sense)</p>",
        "id": 392717527,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1695486350
    },
    {
        "content": "<p>You need to read this thread more carefully, all these questions have been answered already.</p>",
        "id": 392717601,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1695486401
    },
    {
        "content": "<p>I'm not sure I understand - we don't yet have an external typechecker for Lean 4, right?</p>",
        "id": 392717734,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1695486491
    },
    {
        "content": "<p>and currently, people can add untrusted definitions to the Lean environment.</p>",
        "id": 392718171,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1695486685
    },
    {
        "content": "<p>Read in particular <a href=\"#narrow/stream/113488-general/topic/PSA.20about.20trusting.20Lean.20proofs/near/392705540\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/PSA.20about.20trusting.20Lean.20proofs/near/392705540</a></p>",
        "id": 392719348,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1695487127
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"492774\">@Sky Wilshaw</span> In the message above (<a href=\"#narrow/stream/113488-general/topic/PSA.20about.20trusting.20Lean.20proofs/near/392705540\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/PSA.20about.20trusting.20Lean.20proofs/near/392705540</a>), we outline our plans for external checkers at the Lean FRO. The first checker is straightforward and can also be implemented by users. It simply uses our public APIs to load .olean files and then employs the APIs for type-checking definitions. This program, written in Lean, is self-contained. While any user can create it, we'll be adding it to our release suite for added convenience.</p>",
        "id": 392719436,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1695487160
    },
    {
        "content": "<p>Thanks for the clarification, this makes sense now.</p>",
        "id": 392719502,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1695487191
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"492774\">Sky Wilshaw</span> <a href=\"#narrow/stream/113488-general/topic/PSA.20about.20trusting.20Lean.20proofs/near/392717388\">said</a>:</p>\n<blockquote>\n<p>Is there any way to tell (via something like <code>#print axioms</code>) that this \"exploit\" hasn't been secretly performed?</p>\n</blockquote>\n<p>The implied short answer is NOT TODAY.<br>\nI'll keep it here as TLDR.</p>",
        "id": 392721774,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1695488073
    },
    {
        "content": "<p>This is almost certainly not robust, but here's proof that can you detect this today despite Martin's claim:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">elab</span> <span class=\"s2\">\"check_decl\"</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">getConstInfo</span> <span class=\"o\">(</span><span class=\"n\">Elab.Tactic.getNameOfIdent'</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"n\">e.value</span><span class=\"bp\">?</span> <span class=\"bp\">|</span> <span class=\"n\">return</span>\n  <span class=\"n\">Elab.Command.liftTermElabM</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">m</span> <span class=\"bp\">←</span> <span class=\"n\">Meta.mkFreshExprMVar</span> <span class=\"n\">e.type</span>\n    <span class=\"k\">let</span> <span class=\"bp\">.</span><span class=\"n\">true</span> <span class=\"bp\">←</span> <span class=\"n\">Meta.isDefEq</span> <span class=\"n\">m</span> <span class=\"n\">v</span> <span class=\"bp\">|</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"incorrect type\"</span>\n\n<span class=\"n\">check_decl</span> <span class=\"n\">falso</span>  <span class=\"c1\">-- fails</span>\n</code></pre></div>",
        "id": 392727633,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1695493318
    },
    {
        "content": "<p>Would this check whether the decl uses false?</p>",
        "id": 392728506,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1695494129
    },
    {
        "content": "<p>No, but it would be straightforward to adapt it to just check every decl in the environment or be recursive</p>",
        "id": 392728540,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1695494160
    },
    {
        "content": "<p>But I suspect my usage of <code>isDefeq</code> is incorrect in some way anyway, so it's probably better to wait for an officially sanctioned checker!</p>",
        "id": 392728598,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1695494194
    },
    {
        "content": "<p>You can do other tricks like delete some structure from the env and introduce a bad one in place with the same name, in which case the expr ends up being the same</p>",
        "id": 392728644,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1695494259
    },
    {
        "content": "<p>Within a system where arbitrary code can do arbitrary IO (including, in theory, swapping out the proof kernel with a tampered one), protection against malicious proofs seems simply impossible.</p>",
        "id": 392729351,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1695494960
    },
    {
        "content": "<p>Trying to build a theorem prover that really prevents cheating may lead you to something like <a href=\"http://www.proof-technologies.com/holzero/\">HOL Zero</a> (I'm not 100% sure even that attempts to protect against that, the focus seems to be shenenigans with pretty-printing.)</p>",
        "id": 392729714,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1695495311
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> I believe you need to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.check#doc\">docs#Lean.Meta.check</a> on the type and value first, since isDefEq assumes the terms are type correct. You can also avoid metavariables by doing isDefEq between the type and <code>inferType</code> of the value directly.</p>",
        "id": 392732510,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1695497570
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/stream/113488-general/topic/PSA.20about.20trusting.20Lean.20proofs/near/392729351\">said</a>:</p>\n<blockquote>\n<p>Within a system where arbitrary code can do arbitrary IO (including, in theory, swapping out the proof kernel with a tampered one), protection against malicious proofs seems simply impossible.</p>\n</blockquote>\n<p>This is why we promote external checkers in Lean. See our plan at <a href=\"#narrow/stream/113488-general/topic/PSA.20about.20trusting.20Lean.20proofs/near/392705540\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/PSA.20about.20trusting.20Lean.20proofs/near/392705540</a></p>",
        "id": 392733387,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1695498320
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/stream/113488-general/topic/PSA.20about.20trusting.20Lean.20proofs/near/392729714\">said</a>:</p>\n<blockquote>\n<p>Trying to build a theorem prover that really prevents cheating may lead you to something like <a href=\"http://www.proof-technologies.com/holzero/\">HOL Zero</a> (I'm not 100% sure even that attempts to protect against that, the focus seems to be shenenigans with pretty-printing.)</p>\n</blockquote>\n<p>We can achieve the same level of trustworthiness with external checkers, if not more. Especially since users have the option to implement their own checkers.</p>",
        "id": 392733498,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1695498401
    },
    {
        "content": "<p>Absolutely, external checkers are the way to go here! </p>\n<p>(Although one still has theaw issue with notation abuse. I assume that an external checkers sees only fully elaborated terms, is that right? So there is still a little gap between what the user believes the lean surface syntax type means, and what is checked by the external checker.)</p>",
        "id": 392734811,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1695499395
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/stream/113488-general/topic/PSA.20about.20trusting.20Lean.20proofs/near/392734811\">said</a>:</p>\n<blockquote>\n<p>Absolutely, external checkers are the way to go here! </p>\n<p>(Although one still has theaw issue with notation abuse. I assume that an external checkers sees only fully elaborated terms, is that right? So there is still a little gap between what the user believes the lean surface syntax type means, and what is checked by the external checker.)</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span>'s external checker for Lean 3 had its own pretty printer <a href=\"https://github.com/gebner/trepplein/blob/master/src/main/scala/trepplein/pretty.scala\">https://github.com/gebner/trepplein/blob/master/src/main/scala/trepplein/pretty.scala</a></p>",
        "id": 392735686,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1695500120
    },
    {
        "content": "<p>I've emphasized this point about external checkers and pretty printers in several talks I've given about Lean, including my most recent ones at the Topos Institute and on the Type Theory Forall podcast.</p>",
        "id": 392735888,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1695500300
    },
    {
        "content": "<p>I've never been too worried about notation abuse, this is much easier to check for; imagine a million lines of code claiming to prove FLT; the statement is short and it's very easy to check there is no notation nonsense in the statement -- and you don't need to check the proof. But checking for the issue which is the topic of this thread involves looking through a million lines of code (which of course a checker can do)</p>",
        "id": 392736444,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1695500767
    },
    {
        "content": "<p>Kevin, unfortunately the problem is not just notation but instances; I can prove <code>2 + 2 = 5</code> if I add <code>instance : Add Nat where add _ _ := 5</code> somewhere hidden within the other million lines</p>",
        "id": 392737472,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1695501688
    },
    {
        "content": "<p>And while you can easily inspect the instances for your statement, when the instance trace is thousands of lines (as it frequently is!) it's rather harder</p>",
        "id": 392737572,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1695501788
    },
    {
        "content": "<p>FLT is a particular easy case: you can make one file that builds up Nat, add, pow from first principles, using only the kernel, state FLT, and have the checker prove that the long version produces the same type.</p>",
        "id": 392740157,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1695503611
    },
    {
        "content": "<p>If you build up <code>Nat</code> from first principles then the type check would fail, as types are nominal not structural and thus <code>your.Nat = Nat</code> is undecidable (and at any rate, certainly not definitionally true, which would be needed for it to type check)</p>",
        "id": 392742420,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1695505571
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> I wrote the version of your code that does <code>Lean.Meta.check</code>, but it's still not robust -- you can circumvent the check still if the environment's constants don't form a DAG. Maybe this is useful as a test case for an external checker.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span>\n\n<span class=\"n\">elab</span> <span class=\"s2\">\"check_decl\"</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">c</span> <span class=\"bp\">←</span> <span class=\"n\">getConstInfo</span> <span class=\"o\">(</span><span class=\"n\">Elab.Tactic.getNameOfIdent'</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"n\">value</span> <span class=\"o\">:=</span> <span class=\"n\">c.value</span><span class=\"bp\">?</span> <span class=\"bp\">|</span> <span class=\"n\">return</span>\n  <span class=\"n\">Elab.Command.liftTermElabM</span> <span class=\"k\">do</span>\n    <span class=\"n\">Meta.check</span> <span class=\"n\">c.type</span>\n    <span class=\"n\">Meta.check</span> <span class=\"n\">value</span>\n    <span class=\"k\">let</span> <span class=\"bp\">.</span><span class=\"n\">true</span> <span class=\"bp\">←</span> <span class=\"n\">Meta.isDefEq</span> <span class=\"n\">c.type</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">Meta.inferType</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"bp\">|</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"incorrect type\"</span>\n\n<span class=\"n\">elab</span> <span class=\"s2\">\"add_false\"</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"n\">modifyEnv</span> <span class=\"bp\">λ</span> <span class=\"n\">env</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"kd\">constants</span> <span class=\"o\">:=</span> <span class=\"n\">env.constants.insert</span> <span class=\"bp\">`</span><span class=\"n\">falso</span> <span class=\"bp\">$</span> <span class=\"n\">ConstantInfo.thmInfo</span>\n      <span class=\"o\">{</span> <span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"n\">falso</span>\n        <span class=\"n\">levelParams</span> <span class=\"o\">:=</span> <span class=\"o\">[]</span>\n        <span class=\"n\">type</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">``</span><span class=\"n\">False</span> <span class=\"o\">[]</span>\n        <span class=\"n\">value</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">``</span><span class=\"n\">False</span> <span class=\"o\">[]</span>\n      <span class=\"o\">}</span>\n    <span class=\"o\">{</span> <span class=\"n\">env</span> <span class=\"k\">with</span> <span class=\"kd\">constants</span> <span class=\"o\">}</span>\n\n<span class=\"n\">add_false</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"n\">falso</span>\n\n<span class=\"n\">check_decl</span> <span class=\"n\">falso</span>  <span class=\"c1\">-- \"incorrect type\"</span>\n\n<span class=\"n\">elab</span> <span class=\"s2\">\"add_super_false\"</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"n\">modifyEnv</span> <span class=\"bp\">λ</span> <span class=\"n\">env</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"kd\">constants</span> <span class=\"o\">:=</span> <span class=\"n\">env.constants.insert</span> <span class=\"bp\">`</span><span class=\"n\">super_false</span> <span class=\"bp\">$</span> <span class=\"n\">ConstantInfo.thmInfo</span>\n      <span class=\"o\">{</span> <span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"n\">super_false</span>\n        <span class=\"n\">levelParams</span> <span class=\"o\">:=</span> <span class=\"o\">[]</span>\n        <span class=\"n\">type</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">``</span><span class=\"n\">False</span> <span class=\"o\">[]</span>\n        <span class=\"n\">value</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">`</span><span class=\"n\">super_false</span> <span class=\"o\">[]</span>\n      <span class=\"o\">}</span>\n    <span class=\"o\">{</span> <span class=\"n\">env</span> <span class=\"k\">with</span> <span class=\"kd\">constants</span> <span class=\"o\">}</span>\n\n<span class=\"n\">add_super_false</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"n\">super_false</span>\n\n<span class=\"n\">check_decl</span> <span class=\"n\">super_false</span> <span class=\"c1\">-- ok!</span>\n</code></pre></div>\n</div></div>",
        "id": 392743713,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1695506612
    },
    {
        "content": "<p>In case you want to see how to circumvent <code>isDefEq</code> by itself without environment loops:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span>\n\n<span class=\"n\">elab</span> <span class=\"s2\">\"check_decl\"</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">getConstInfo</span> <span class=\"o\">(</span><span class=\"n\">Elab.Tactic.getNameOfIdent'</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"n\">e.value</span><span class=\"bp\">?</span> <span class=\"bp\">|</span> <span class=\"n\">return</span>\n  <span class=\"n\">Elab.Command.liftTermElabM</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">m</span> <span class=\"bp\">←</span> <span class=\"n\">Meta.mkFreshExprMVar</span> <span class=\"n\">e.type</span>\n    <span class=\"k\">let</span> <span class=\"bp\">.</span><span class=\"n\">true</span> <span class=\"bp\">←</span> <span class=\"n\">Meta.isDefEq</span> <span class=\"n\">m</span> <span class=\"n\">v</span> <span class=\"bp\">|</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"incorrect type\"</span>\n\n<span class=\"n\">elab</span> <span class=\"s2\">\"add_false\"</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"n\">modifyEnv</span> <span class=\"bp\">λ</span> <span class=\"n\">env</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"kd\">constants</span> <span class=\"o\">:=</span> <span class=\"n\">env.constants.insert</span> <span class=\"bp\">`</span><span class=\"n\">falso</span> <span class=\"bp\">$</span> <span class=\"n\">ConstantInfo.thmInfo</span>\n      <span class=\"o\">{</span> <span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"n\">falso</span>\n        <span class=\"n\">levelParams</span> <span class=\"o\">:=</span> <span class=\"o\">[]</span>\n        <span class=\"n\">type</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">``</span><span class=\"n\">False</span> <span class=\"o\">[]</span>\n        <span class=\"n\">value</span> <span class=\"o\">:=</span> <span class=\"n\">mkAppN</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">``</span><span class=\"n\">id</span> <span class=\"o\">[</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"o\">])</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">``</span><span class=\"n\">False</span> <span class=\"o\">[],</span> <span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">``</span><span class=\"n\">False</span> <span class=\"o\">[]]</span>\n      <span class=\"o\">}</span>\n    <span class=\"o\">{</span> <span class=\"n\">env</span> <span class=\"k\">with</span> <span class=\"kd\">constants</span> <span class=\"o\">}</span>\n\n<span class=\"n\">add_false</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"n\">falso</span>\n\n<span class=\"n\">check_decl</span> <span class=\"n\">falso</span>  <span class=\"c1\">-- ok!</span>\n</code></pre></div>\n</div></div>",
        "id": 392743865,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1695506761
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> It is not difficult to show that two versions of Nat are isomorphic.  The long proof would include that isomorphism.</p>",
        "id": 392745409,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1695508044
    },
    {
        "content": "<p>Yeah. I would do something like the following reässurence:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.Linarith</span>\n\n<span class=\"c1\">-- FLT imported from a suspicious source:</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">FLT</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hb</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hc</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">a</span> <span class=\"bp\">^</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">^</span> <span class=\"n\">n</span> <span class=\"bp\">≠</span> <span class=\"n\">c</span> <span class=\"bp\">^</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n\n<span class=\"c1\">-- From now only trusted code follows:</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">MyNat</span>\n<span class=\"bp\">|</span> <span class=\"n\">zer</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span>\n<span class=\"bp\">|</span> <span class=\"n\">suc</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span> <span class=\"bp\">→</span> <span class=\"n\">MyNat</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">MyAdd</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span> <span class=\"bp\">→</span> <span class=\"n\">MyNat</span>\n<span class=\"bp\">|</span> <span class=\"n\">MyNat.zer</span>   <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"n\">MyNat.suc</span> <span class=\"n\">m</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">MyNat.suc</span> <span class=\"o\">(</span><span class=\"n\">MyAdd</span> <span class=\"n\">n</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">MyMul</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span> <span class=\"bp\">→</span> <span class=\"n\">MyNat</span>\n<span class=\"bp\">|</span> <span class=\"n\">MyNat.zer</span>   <span class=\"bp\">=&gt;</span> <span class=\"n\">MyNat.zer</span>\n<span class=\"bp\">|</span> <span class=\"n\">MyNat.suc</span> <span class=\"n\">m</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">MyAdd</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">MyMul</span> <span class=\"n\">n</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">MyPow</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span> <span class=\"bp\">→</span> <span class=\"n\">MyNat</span>\n<span class=\"bp\">|</span> <span class=\"n\">MyNat.zer</span>   <span class=\"bp\">=&gt;</span> <span class=\"n\">MyNat.suc</span> <span class=\"n\">MyNat.zer</span>\n<span class=\"bp\">|</span> <span class=\"n\">MyNat.suc</span> <span class=\"n\">m</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">MyMul</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">MyPow</span> <span class=\"n\">n</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">MyNat.toNat</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n<span class=\"bp\">|</span> <span class=\"n\">MyNat.zer</span>   <span class=\"bp\">=&gt;</span> <span class=\"n\">Nat.zero</span>\n<span class=\"bp\">|</span> <span class=\"n\">MyNat.suc</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Nat.succ</span> <span class=\"n\">n.toNat</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">myAdd_toNat</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hyp</span> <span class=\"o\">:</span> <span class=\"n\">MyAdd</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">a.toNat</span> <span class=\"bp\">+</span> <span class=\"n\">b.toNat</span> <span class=\"bp\">=</span> <span class=\"n\">c.toNat</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">myMul_toNat</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hyp</span> <span class=\"o\">:</span> <span class=\"n\">MyMul</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">a.toNat</span> <span class=\"bp\">*</span> <span class=\"n\">b.toNat</span> <span class=\"bp\">=</span> <span class=\"n\">c.toNat</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">myPow_toNat</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hyp</span> <span class=\"o\">:</span> <span class=\"n\">MyPow</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">a.toNat</span> <span class=\"bp\">^</span> <span class=\"n\">b.toNat</span> <span class=\"bp\">=</span> <span class=\"n\">c.toNat</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">MyFLT</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">MyAdd</span>\n    <span class=\"o\">(</span><span class=\"n\">MyPow</span> <span class=\"n\">a.suc</span> <span class=\"n\">n.suc.suc.suc</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">MyPow</span> <span class=\"n\">b.suc</span> <span class=\"n\">n.suc.suc.suc</span><span class=\"o\">)</span>\n  <span class=\"bp\">≠</span> <span class=\"o\">(</span><span class=\"n\">MyPow</span> <span class=\"n\">c.suc</span> <span class=\"n\">n.suc.suc.suc</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a.suc.toNat</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">MyNat.toNat</span><span class=\"o\">]</span>\n  <span class=\"k\">have</span> <span class=\"n\">hb</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b.suc.toNat</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">MyNat.toNat</span><span class=\"o\">]</span>\n  <span class=\"k\">have</span> <span class=\"n\">hc</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c.suc.toNat</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">MyNat.toNat</span><span class=\"o\">]</span>\n  <span class=\"k\">have</span> <span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n.suc.suc.suc.toNat</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">MyNat.toNat</span><span class=\"o\">]</span>\n    <span class=\"n\">linarith</span>\n  <span class=\"n\">by_contra</span> <span class=\"n\">hyp</span>\n  <span class=\"n\">apply</span> <span class=\"n\">FLT</span> <span class=\"n\">ha</span> <span class=\"n\">hb</span> <span class=\"n\">hc</span> <span class=\"n\">hn</span>\n  <span class=\"n\">convert</span> <span class=\"n\">myAdd_toNat</span> <span class=\"n\">hyp</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">apply</span> <span class=\"n\">myPow_toNat</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 392747236,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1695509388
    },
    {
        "content": "<p>Yes, I think that captures the gist; though I worry we're now further derailing this thread.</p>",
        "id": 392747685,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1695509851
    },
    {
        "content": "<p>In the same line of thought of \"external checkers\", it would be possible to write a Lean 4 typechecker in a language that can produce SNARKs. These can be expensive to be generated, but can be verified cheaply. Such artifacts would be virtually impossible to forge without having proper proofs for the theorems</p>",
        "id": 392761979,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1695519444
    },
    {
        "content": "<p>Okay, I have a prototype verifier that \"replays\" all declarations into the environment.</p>\n<p>It detects both of today's hacks:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">%</span> <span class=\"n\">lake</span> <span class=\"n\">exe</span> <span class=\"n\">verify</span> <span class=\"n\">Examples.False</span>\n<span class=\"n\">Kernel</span> <span class=\"n\">exception</span> <span class=\"n\">while</span> <span class=\"n\">processing</span><span class=\"o\">:</span>\n<span class=\"c1\">---</span>\n<span class=\"n\">add_false</span>\n\n\n<span class=\"c1\">---</span>\n<span class=\"n\">Could</span> <span class=\"n\">not</span> <span class=\"n\">add</span> <span class=\"n\">declarations</span><span class=\"o\">:</span>\n<span class=\"n\">falso</span>\n<span class=\"o\">(</span><span class=\"n\">kernel</span><span class=\"o\">)</span> <span class=\"n\">declaration</span> <span class=\"n\">type</span> <span class=\"n\">mismatch</span><span class=\"o\">,</span> <span class=\"bp\">'</span><span class=\"n\">falso'</span> <span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"kt\">Prop</span>\n<span class=\"n\">but</span> <span class=\"n\">it</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">False</span>\n</code></pre></div>\n<p>and </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">%</span> <span class=\"n\">lake</span> <span class=\"n\">exe</span> <span class=\"n\">verify</span> <span class=\"n\">Examples.False2</span>\n<span class=\"n\">Kernel</span> <span class=\"n\">exception</span> <span class=\"n\">while</span> <span class=\"n\">processing</span><span class=\"o\">:</span>\n<span class=\"c1\">---</span>\n<span class=\"n\">add_super_false</span>\n\n\n<span class=\"c1\">---</span>\n<span class=\"n\">Could</span> <span class=\"n\">not</span> <span class=\"n\">add</span> <span class=\"n\">declarations</span><span class=\"o\">:</span>\n<span class=\"n\">super_false</span>\n<span class=\"o\">(</span><span class=\"n\">kernel</span><span class=\"o\">)</span> <span class=\"n\">unknown</span> <span class=\"kd\">constant</span> <span class=\"bp\">'</span><span class=\"n\">super_false'</span>\n</code></pre></div>\n<p>Not quite ready for widespread use, but hopefully soon.</p>",
        "id": 392776212,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1695530137
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"432410\">Arthur Adjedj</span> <a href=\"#narrow/stream/113488-general/topic/PSA.20about.20trusting.20Lean.20proofs/near/392696022\">said</a>:</p>\n<blockquote>\n<p>I wonder what <span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> 's opinion is on this.</p>\n</blockquote>\n<p>I've been aware of this exploit for some time, and kind of didn't want to make a big deal about it because it is somewhat inherent to the lean 4 architecture - there is nothing really preventing you from constructing <code>Environment</code> objects with whatever you want in them as they are a pure lean construction. This was not possible in lean 3, because <code>Environment</code> was an opaque object (defined in C++) which you could only interact with using the API. As Sebastian and Leo say, the main fix for this is to use an external checker. Lean 4 already makes it really easy to just override what <code>def</code> or <code>#print axioms</code> means, so you can't really trust anything you see in regular use in an adversarial scenario.</p>",
        "id": 392795047,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695542086
    },
    {
        "content": "<p>I have long been of the opinion that we should view ITPs and proof assistants as \"proof compilers\": that is, they take as input high level code in some language (i.e. lean) and output proofs in a low level language (i.e. the export format). They are not responsible for checking the correctness of the output, although it is a quality of implementation issue that they should try to produce correct proofs. Actual proof checking is vested in a completely separate tool (a proof checker) which is small and not running in the same process as the prover. (You could maybe make an exception if the language is typesafe and has no escape hatch for UB, but it is in my mind extremely risky to put a large untrusted program and a small trusted program in the same address space. Neither C++, nor Lean, nor OCaml meet the bar I am describing here. Some flavors of ML may be able to meet this requirement, but usually not the ones used in practice.)</p>",
        "id": 392796066,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695542656
    },
    {
        "content": "<p>And just to be clear, I do not consider this a soundness bug in lean. The logical system is not affected here, it is just sidestepping checking entirely. (BTW, <code>--trust=0</code> does absolutely nothing in lean 4. In Lean 3 it did some stuff with unfolding macros but in lean 4 the <code>trustLevel</code> argument seems to be entirely vestigial.)</p>",
        "id": 392797274,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695543154
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/PSA.20about.20trusting.20Lean.20proofs/near/392796066\">said</a>:</p>\n<blockquote>\n<p>Actual proof checking is vested in a completely separate tool (a proof checker) which is small and not running in the same process as the prover. (You could maybe make an exception if the language is typesafe and has no escape hatch for UB, but it is in my mind extremely risky to put a large untrusted program and a small trusted program in the same address space. </p>\n</blockquote>\n<p>I don't understand. Are you suggesting that the typechecker should run in a separate process and act like a server? What is the obstacle to make ITPs work like this?</p>",
        "id": 392802132,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1695545239
    },
    {
        "content": "<p>More specifically, why can't lean's kernel run in a separate process as a \"verify\" server and communicate with the rest of the system through some serialization of Expr.</p>",
        "id": 392802452,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1695545353
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/113488-general/topic/PSA.20about.20trusting.20Lean.20proofs/near/392802452\">said</a>:</p>\n<blockquote>\n<p>More specifically, why can't lean's kernel run in a separate process as a \"verify\" server and communicate with the rest of the system through some serialization of Expr.</p>\n</blockquote>\n<p>I dont see how this is different from \" the typechecker should run in a separate process and act like a server\"</p>",
        "id": 392804262,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1695545972
    },
    {
        "content": "<p>What this thread has taught me is that lean 4 is so flexible that the idea that \"you can just trust the program\" is simply out of date. This does not bother me at all. In CS people are always forced to think about malicious actors but when building mathematics like we're doing there is absolutely no motivation to cheat especially as we now know that you can be found out very easily (just not by lean itself). I think the scenario of a malicious maths actor claiming to prove RH (a) doesn't really exist and (b) can be protected against anyway, with an external checker. I do think that this is evidence that we'd better get an external checker sooner rather than later but Leo's post makes it clear that this is a priority that the FRO well aware of. </p>\n<p>It will be interesting when the LLMs manage to discover that they can do this and start getting gold medals on IMOs because of it, but as I say it's clear that this can be mitigated against.</p>",
        "id": 392805730,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1695546343
    },
    {
        "content": "<p>I think that the observation that opening lean code can wipe your hard drive is in some sense far more concerning but this has been known for years and again it's never been an issue for me in practice -- I mark students' work in a virtual machine but this is not difficult to set up.</p>",
        "id": 392807065,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1695547211
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/113488-general/topic/PSA.20about.20trusting.20Lean.20proofs/near/392804262\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/113488-general/topic/PSA.20about.20trusting.20Lean.20proofs/near/392802452\">said</a>:</p>\n<blockquote>\n<p>More specifically, why can't lean's kernel run in a separate process as a \"verify\" server and communicate with the rest of the system through some serialization of Expr.</p>\n</blockquote>\n<p>I dont see how this is different from \" the typechecker should run in a separate process and act like a server\"</p>\n</blockquote>\n<p>I am asking why it isn't done like that currently. My best guess is latency. But, at least, it could be added as an option.</p>",
        "id": 392807578,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1695547623
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> : This could affect more than just research math. For example without extra checkers, how could an instructor be sure that their students submit correct proofs of textbook results. Especially if the instructor is not lean-savvy enough to catch it without the compiler telling them.</p>",
        "id": 392808991,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1695548462
    },
    {
        "content": "<p>I think the people teaching using Lean so far are quite savvy enough. :-) And they are well aware of \"hacking\" possibilities like this.</p>",
        "id": 392810388,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1695549349
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span>, would your autograder be tricked by Jannis' <code>add_false</code>? I believe not, but I haven't tried.</p>",
        "id": 392810516,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1695549387
    },
    {
        "content": "<p>Alongside an ecosystem if checkers, it would be cool if there was</p>\n<ol>\n<li>A standard “lake check” command or similar that runs the check, or nice integration between lake and the checkers. </li>\n<li>An idiomatic way to have no-library Lean code to express theorems.  Possibly this already exists, but for example <span class=\"user-mention\" data-user-id=\"417654\">@Martin Dvořák</span>’s approach above is unsound as written: it starts by importing an untrusted file, and all is lost if you do this.</li>\n</ol>",
        "id": 392811205,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1695549647
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"466334\">@Shreyas Srinivas</span> I don't use any auto-grading in my course, the students write individual lean projects on topics of their choice.</p>",
        "id": 392812111,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1695550147
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113488-general/topic/PSA.20about.20trusting.20Lean.20proofs/near/392810516\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span>, would your autograder be tricked by Jannis' <code>add_false</code>? I believe not, but I haven't tried.</p>\n</blockquote>\n<p>I have already modified my auto-grader to do something similar to Kyle's command above, but as he mentioned there, there is still a workaround. But in any case, I can think of several ways for students to bypass this (or any other auto-grading idea I had), so I just started skimming through student code regardless.</p>",
        "id": 392821898,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1695554467
    },
    {
        "content": "<p>Once <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> releases the <code>verify</code> executable, I'll probably experiment with using this as part of the workflow.</p>",
        "id": 392821999,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1695554549
    },
    {
        "content": "<p>3 messages were moved from this topic to <a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/stream/113488-general/topic/Lean.20and.20the.20upcoming.20Cyber.20Resilience.20Act\">#general &gt; Lean and the upcoming Cyber Resilience Act</a> by <span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span>.</p>",
        "id": 392853837,
        "sender_full_name": "Notification Bot",
        "timestamp": 1695576900
    },
    {
        "content": "<p>We have just released <a href=\"https://github.com/leanprover/lean4checker\"><code>lean4checker</code></a>, which reverifies <code>.olean</code> files using the Lean kernel.</p>\n<p>(Thanks also to Mario for a significant performance improvement.)</p>\n<p>This tool detects and rejects the \"environment hacking\" tricks described above in this thread.</p>\n<p>It uses the Lean kernel, but none of the elaborator or other frontend. (Imports are just <code>Lean.CoreM</code> and <code>Lean.Util.FoldConsts</code>.)</p>\n<p>PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/7368\">#7368</a> proposes adding this as a regular CI step for Mathlib. It comes at a ~6 minute cost per CI run; perhaps we will switch to a cron job and/or only run <code>lean4checker</code> on modified files (and files downstream) if this feels too expensive. I would prefer that we merge it now as a regular job, however.</p>\n<p>There's more coming: the FRO has plans (weeks-to-months timeline) to provide independent verifiers written in languages other than Lean, which will provide an alternative to <code>lean4checker</code> with no overlap with the Lean codebase. Of course if anyone would like to write such a verifier that would be very welcome (and a cool project).</p>",
        "id": 393143906,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1695693130
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"121542\">@Alexandre Rademaker</span> <span aria-label=\"point up\" class=\"emoji emoji-1f446\" role=\"img\" title=\"point up\">:point_up:</span></p>",
        "id": 393153218,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1695698486
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/113488-general/topic/PSA.20about.20trusting.20Lean.20proofs/near/393143906\">said</a>:</p>\n<blockquote>\n<p>There's more coming: the FRO has plans (weeks-to-months timeline) to provide independent verifiers written in languages other than Lean, which will provide an alternative to <code>lean4checker</code> with no overlap with the Lean codebase. Of course if anyone would like to write such a verifier that would be very welcome (and a cool project).</p>\n</blockquote>\n<ol>\n<li>For people interested in external checkers, are there plans for the Olean files have an \"official\" specification?</li>\n<li>What background knowledge do you think is necessary to independently build such a verifier?</li>\n</ol>",
        "id": 393174685,
        "sender_full_name": "MohanadAhmed",
        "timestamp": 1695711992
    },
    {
        "content": "<p>Just a wild idea, <a href=\"https://github.com/leanprover/lean4checker/blob/master/Main.lean#L86\">https://github.com/leanprover/lean4checker/blob/master/Main.lean#L86</a> could you inject ctor's or rec's into an Environment yourself and get proofs that way without the kernel noticing? -&gt; is it okay to just leave these out?</p>",
        "id": 393177727,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1695713389
    },
    {
        "content": "<p>oh good point</p>",
        "id": 393178396,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695713660
    },
    {
        "content": "<p>Yes, I think there is a loophole here.</p>\n<p>The current tool only checks each file individually. Thus if you put in an evil constructor in one file, then <code>lean4checker</code> will just drop it. Any subsequent results <em>in the same file</em> which tries to use it will fail. But when we run <code>lean4checker</code> on a downstream file, we are not replaying the environment from that earlier file, so the use of the evil constructor will still be allowed.</p>\n<p>The same code as in <code>lean4checker</code> should (potential stack overflows notwithstanding?) be easy to adapt to rebuild the entire environment from scratch, rather than accepting the environment provided by imports.</p>",
        "id": 393178448,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1695713686
    },
    {
        "content": "<p>Of course you would only run this on one file (e.g. <code>Mathlib.lean</code>).</p>",
        "id": 393178518,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1695713718
    },
    {
        "content": "<p>I'm not sure what the longest path in the declaration dependency graph is. The current implementation may overflow, but it should be straightforward to rewrite iteratively.</p>",
        "id": 393178610,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1695713761
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"k\">in</span>\n<span class=\"n\">elab</span> <span class=\"s2\">\"add_false\"</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"n\">modifyEnv</span> <span class=\"k\">fun</span> <span class=\"n\">env</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"kd\">constants</span> <span class=\"o\">:=</span> <span class=\"n\">env.constants.insert</span> <span class=\"bp\">`</span><span class=\"n\">false</span> <span class=\"bp\">$</span> <span class=\"n\">ConstantInfo.ctorInfo</span>\n      <span class=\"o\">{</span> <span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"n\">false</span><span class=\"o\">,</span> <span class=\"n\">levelParams</span> <span class=\"o\">:=</span> <span class=\"o\">[],</span> <span class=\"n\">type</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">``</span><span class=\"n\">False</span> <span class=\"o\">[]</span>\n        <span class=\"n\">induct</span> <span class=\"o\">:=</span> <span class=\"bp\">``</span><span class=\"n\">False</span><span class=\"o\">,</span> <span class=\"n\">cidx</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">numParams</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">numFields</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">isUnsafe</span> <span class=\"o\">:=</span> <span class=\"n\">false</span> <span class=\"o\">}</span>\n    <span class=\"o\">{</span> <span class=\"n\">env</span> <span class=\"k\">with</span> <span class=\"kd\">constants</span> <span class=\"o\">}</span>\n\n<span class=\"n\">add_false</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span>\n   <span class=\"n\">false</span>\n</code></pre></div>",
        "id": 393178971,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695713907
    },
    {
        "content": "<p>passes the checker</p>",
        "id": 393178979,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695713916
    },
    {
        "content": "<p>oh but you can't use it for real, <code>theorem bla : False := false</code> fails because <code>false</code> isn't in the environment</p>",
        "id": 393179127,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695713989
    },
    {
        "content": "<p>I think there is a deeper issue here, which is that environments are not meant for replay</p>",
        "id": 393179321,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695714078
    },
    {
        "content": "<p>we should really be storing the list of environment <code>Declaration</code>s rather than reconstructing them</p>",
        "id": 393179435,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695714124
    },
    {
        "content": "<p>there are actually loads of similar exploits involving all the fields in <code>InductiveVal</code>: those have a bunch of assumed invariants and you have to make sure you exactly replicate it</p>",
        "id": 393179607,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695714221
    },
    {
        "content": "<p>In lean 3 there was this concept of \"environment modifications\" which compose the output format. Reconstructing this from the environment alone is a very lossy process</p>",
        "id": 393180189,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695714482
    },
    {
        "content": "<p><code>QuotVal</code> has a similar exploit, you can lie about the type of quotient decls</p>",
        "id": 393180556,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695714630
    },
    {
        "content": "<p>I've updated <code>lean4checker</code> so it can replay the entire environment, rather than just \"the environment since the imports\".</p>\n<p>It catches the <code>ctorInfo</code> example above (rather: it doesn't catch the use in <code>example</code>, but if you use the evil constructor in a theorem in either the same file or a downstream file it catches you).</p>\n<p>You don't get to take advantage of any parallelism however, so I'm not sure how long it will take. It is running on Mathlib now.</p>",
        "id": 393184989,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1695716527
    },
    {
        "content": "<p>I guess rather than just dropping <code>ctorInfo</code>s, a better approach would be to verify that they match identically with the <code>ctorInfo</code>s generated when we replay the inductive.</p>",
        "id": 393185433,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1695716704
    },
    {
        "content": "<p>Okay, I have updated <code>lean4checker</code> so that:</p>\n<ul>\n<li>You can no longer smuggle an evil constructor or recursor into one file, and be able to use it later. It is rejected in the file you try to create it. We do this by collecting all constructors and recursors and, after all the inductives have been built, verify that the constructors and recursors were identical to the generated ones.</li>\n<li>There is now a <code>lean4checker --fresh Mathlib</code> mode, which rebuilds the entire environment from scratch, rather than just replaying starting from the imports. Please brew coffee before attempting this!</li>\n</ul>\n<p>Any reviews of the PR at <a href=\"https://github.com/leanprover/lean4checker/pull/2\">https://github.com/leanprover/lean4checker/pull/2</a> much appreciated.</p>",
        "id": 393193318,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1695719500
    },
    {
        "content": "<p>I think it would be best to keep checking environments differentially as you were doing, but make sure that all the <code>ConstantInfo</code>s added match what the kernel says</p>",
        "id": 393195608,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695720412
    },
    {
        "content": "<p>That's exactly what I've done, I think.</p>",
        "id": 393195680,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1695720442
    },
    {
        "content": "<p>I still drop the <code>QuotVal</code>s.</p>",
        "id": 393195710,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1695720455
    },
    {
        "content": "<p>The <code>--fresh</code> mode is hidden behind a flag because it's not intended to be regularly used. It is really quite slow since we can't parallelise.</p>",
        "id": 393195824,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1695720494
    },
    {
        "content": "<p>we can, it's just more complicated to do so</p>",
        "id": 393195887,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695720518
    },
    {
        "content": "<p>I mean, that's just the same kind of parallelism that lake is already doing</p>",
        "id": 393195914,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695720530
    },
    {
        "content": "<p>I also have some partial work on a fix, I will try to merge it with <a href=\"https://github.com/leanprover/lean4checker/pull/2\">leanprover/lean4checker#2</a></p>",
        "id": 393196008,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695720569
    },
    {
        "content": "<p>I think I might leave that to <code>lake</code>. :-)</p>",
        "id": 393196030,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1695720578
    },
    {
        "content": "<p>Great. Please feel free to push to that branch.</p>",
        "id": 393196041,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1695720586
    },
    {
        "content": "<p>I think a crucial aspect has been overlooked, but I don't have the knowledge/experience compared to the others here. So if I am missing something or if it has already been addressed, feel free to point it out.</p>\n<p>The thing that concerns me is not an adversary, but rather that its non-trivial to use Lean to verify the correctness of a proof written in Lean. It <em>should</em> be as simple as <code>#print axioms foo</code> and compile. However, the comments in this thread and the source code of <a href=\"https://github.com/leanprover/lean4checker\">lean4checker</a> indicate otherwise.</p>\n<p>External checkers solve this problem but it misses the point. If one trusts Lean, then I think its reasonable that one should be able to trust a proof that Lean says is valid.</p>\n<p>I have not used Lean's internal APIs, so I don't know how easy/difficult it is to \"accidentally\" add a False statement into the environment. But I do know that in complex systems (e.g. mathlib) it is easy for small and seemingly innocent changes to have unintended effects.</p>",
        "id": 393398849,
        "sender_full_name": "Petur Vetle",
        "timestamp": 1695794383
    },
    {
        "content": "<p>For me, the issue of this is better shown in a program that actually computes things. The fact that the following can compile is concerning from a program verification point of view:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span>\n\n<span class=\"n\">elab</span> <span class=\"s2\">\"add_false\"</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"n\">modifyEnv</span> <span class=\"bp\">λ</span> <span class=\"n\">env</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"kd\">constants</span> <span class=\"o\">:=</span> <span class=\"n\">env.constants.insert</span> <span class=\"bp\">`</span><span class=\"n\">falso</span> <span class=\"bp\">$</span> <span class=\"n\">ConstantInfo.thmInfo</span>\n      <span class=\"o\">{</span> <span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"n\">falso</span>\n        <span class=\"n\">levelParams</span> <span class=\"o\">:=</span> <span class=\"o\">[]</span>\n        <span class=\"n\">type</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">``</span><span class=\"n\">False</span> <span class=\"o\">[]</span>\n        <span class=\"n\">value</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">``</span><span class=\"n\">False</span> <span class=\"o\">[]</span>\n      <span class=\"o\">}</span>\n    <span class=\"o\">{</span> <span class=\"n\">env</span> <span class=\"k\">with</span> <span class=\"kd\">constants</span> <span class=\"o\">}</span>\n\n<span class=\"n\">add_false</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">can_index_anywhere</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a.size</span> <span class=\"o\">:=</span>\n  <span class=\"n\">False.elim</span> <span class=\"n\">falso</span>\n\n<span class=\"c1\">-- the user has no way to determine that this is not true without using an external checker?</span>\n<span class=\"k\">#print</span> <span class=\"kd\">axioms</span> <span class=\"n\">can_index_anywhere</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">index_anywhere</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"bp\">'</span><span class=\"o\">(</span><span class=\"n\">can_index_anywhere</span> <span class=\"n\">a</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">index_anywhere</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">]</span> <span class=\"mi\">4</span>\n</code></pre></div>",
        "id": 393407300,
        "sender_full_name": "Petur Vetle",
        "timestamp": 1695797826
    },
    {
        "content": "<p>If you are not in an adversarial mindset, none of these issues are a problem. It is basically impossible to do this kind of thing by accident: you either have to use a very low level API which is not ever used in practice, or break the type system in some way in order to cause problems.</p>",
        "id": 393407361,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695797850
    },
    {
        "content": "<p>Note that you can already have issues with <code>sorry</code> or <code>unsafe</code> in <code>#eval</code></p>",
        "id": 393407531,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695797909
    },
    {
        "content": "<p>And you can always implement your own <code>#eval</code> that takes the guard rails off if you want</p>",
        "id": 393407825,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695798024
    },
    {
        "content": "<p><code>add_false</code> is basically similar: the metaprogramming API is very powerful and lets you direct lean to check or not check whatever you like</p>",
        "id": 393407942,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695798065
    },
    {
        "content": "<p>But we are designing here from the perspective that we are trying to build a proof <em>assistant</em>, which assists the user in writing a proof. That means giving errors when it is useful</p>",
        "id": 393408064,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695798119
    },
    {
        "content": "<p>A tactic that lies to the user and fails to give good error messages is not a good tactic</p>",
        "id": 393408201,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695798158
    },
    {
        "content": "<p>Perhaps it would be good to add a <code>#replay</code> command that can be used interactively.</p>",
        "id": 393409083,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1695798449
    },
    {
        "content": "<p>assuming it's not overridden...</p>",
        "id": 393409383,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695798557
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/PSA.20about.20trusting.20Lean.20proofs/near/393408064\">said</a>:</p>\n<blockquote>\n<p>But we are designing here from the perspective that we are trying to build a proof <em>assistant</em>, which assists the user in writing a proof. That means giving errors when it is useful</p>\n</blockquote>\n<p>I don't understand this perspective. If A relies on B (some tool) to check A's software, then the proof assistant assists B. So B could  end up using a tactic that (accidentally) got its environment manipulation incorrect. A should not be expected to trust B's wisdom any more than the A's own programming skills. And it should not be necessary for A or B to minutely examine the entire source they use. Petur is right. From a formal verification perspective, nobody would trust such a tool.</p>",
        "id": 393420152,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1695802378
    },
    {
        "content": "<p>I think what Mario is getting at is <em>accidental</em> vs <em>malicious</em> mistakes. Nobody would write <code>add_false</code> on purpose. And if the author <em>is</em> writing devious code on purpose, then you've already lost.</p>",
        "id": 393421991,
        "sender_full_name": "Chris Wong",
        "timestamp": 1695802955
    },
    {
        "content": "<blockquote>\n<p>nobody would trust such a tool</p>\n</blockquote>\n<p>I would trust that tool, because I know what I'm doing. I understand that Lean 4 is so flexible that you can now \"cheat\" and I understand that there is  (or soon will be) a tool which detects that cheating. Thus your claim is false.</p>",
        "id": 393422187,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1695803019
    },
    {
        "content": "<p>If you are concerned about these issues, you run <code>lean4checker</code>. If you're not, you either don't care, or are content that <code>lean4checker</code> (will soon) run in CI.</p>",
        "id": 393422390,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1695803074
    },
    {
        "content": "<p>This is similar to the <code>unsafe</code> guarantee in Rust. You can clobber arbitrary memory with no <code>unsafe</code> code by writing to <code>/proc/self/mem</code>. This is not considered a soundness hole.</p>",
        "id": 393422465,
        "sender_full_name": "Chris Wong",
        "timestamp": 1695803095
    },
    {
        "content": "<p>It's pretty straightforward. Of course the Lean frontend and VSCode extension are not meant to be \"trusted\" in this sense. They are tools for writing proofs. The kernel checks the proofs, and the kernel has no soundness issues. If you decide to not send your proofs to the kernel, then of course it has no opportunity to check them.</p>",
        "id": 393422883,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1695803201
    },
    {
        "content": "<p>the kernel has no soundness issues</p>\n<p>That we know of <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 393423067,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1695803255
    },
    {
        "content": "<p>Lean is a general purpose programming language, and it is <strong>intended</strong> to be capable of doing metaprogramming, including manipulating Lean <code>Environment</code> objects. If you want something that is just a verifier, use a verifier.</p>",
        "id": 393423267,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1695803313
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/113488-general/topic/PSA.20about.20trusting.20Lean.20proofs/near/393423067\">said</a>:</p>\n<blockquote>\n<p>That we know of <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>\n</blockquote>\n<p>Sure, of course! Lean's track record is very solid here.</p>",
        "id": 393423670,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1695803436
    },
    {
        "content": "<p>Even if you decide to trust the verifier output, beware that Lean files are totally capable of replacing <code>lean4checker</code> with a program that does the equivalent of <code>echo \"Looks good to me\"</code> :P</p>",
        "id": 393425243,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1695803936
    },
    {
        "content": "<p>This is getting a little silly, no? A lean program is capable of that in the same sense that a C program is capable of replacing your C compiler with a nefarious one. I mean, that is a valid \"adversary\" to think about in some contexts, but ...</p>",
        "id": 393428756,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1695805056
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/113488-general/topic/PSA.20about.20trusting.20Lean.20proofs/near/393428756\">said</a>:</p>\n<blockquote>\n<p>This is getting a little silly, no? A lean program is capable of that in the same sense that a C program is capable of replacing your C compiler with a nefarious one. I mean, that is a valid \"adversary\" to think about in some contexts, but ...</p>\n</blockquote>\n<p>I mean you could set it up such that once the lean compiler starts it priv drops into a user that cannot touch the leanchecker binary and such but that seems overkill</p>",
        "id": 393433426,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1695806311
    },
    {
        "content": "<p>TL DR: I'd say an external checker as mentioned by Leo is the best long term solution. </p>\n<p>Scott: It is a question of what the system guarantees are, and what assumptions are made. In principle one can also go to extremes and overwrite the lean kernel in-memory through some hardware side channel. Verification is always w.r.t a reasonable set of assumptions. The kernel has no soundness issues. But for use in formal verification, it is generally hoped that I don't have to worry about trivial side channels like skipping the checker through a bad tactic. Comparing lean to C is unfair. A C programmer knows (or at least ought to know), that they are getting very little by way of guarantees.</p>",
        "id": 393433504,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1695806330
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"294142\">Chris Wong</span> <a href=\"#narrow/stream/113488-general/topic/PSA.20about.20trusting.20Lean.20proofs/near/393421991\">said</a>:</p>\n<blockquote>\n<p>I think what Mario is getting at is <em>accidental</em> vs <em>malicious</em> mistakes. Nobody would write <code>add_false</code> on purpose. And if the author <em>is</em> writing devious code on purpose, then you've already lost.</p>\n</blockquote>\n<p>It is not merely about one malicious programmer. It is also about trusting libraries. Currently we have a few centrally managed libraries so this is not an issue at all. But in the future, we need to have a reasonably easy way of checking that a library is not buggy internally (sure someone could intercept the download and add the bug, but that's beyond lean).</p>",
        "id": 393437660,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1695807360
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"238446\">Anne Baanen</span> <a href=\"#narrow/stream/113488-general/topic/PSA.20about.20trusting.20Lean.20proofs/near/393425243\">said</a>:</p>\n<blockquote>\n<p>Even if you decide to trust the verifier output, beware that Lean files are totally capable of replacing <code>lean4checker</code> with a program that does the equivalent of <code>echo \"Looks good to me\"</code> :P</p>\n</blockquote>\n<p>I checked, there is no opportunity to run custom code during initialization to affect the relevant parts of the state of <code>lean4checker</code>. The only avenue for corruption is to cause UB and break lean that way.</p>",
        "id": 393441481,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695808017
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/113488-general/topic/PSA.20about.20trusting.20Lean.20proofs/near/393437660\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"294142\">Chris Wong</span> <a href=\"#narrow/stream/113488-general/topic/PSA.20about.20trusting.20Lean.20proofs/near/393421991\">said</a>:</p>\n<blockquote>\n<p>I think what Mario is getting at is <em>accidental</em> vs <em>malicious</em> mistakes. Nobody would write <code>add_false</code> on purpose. And if the author <em>is</em> writing devious code on purpose, then you've already lost.</p>\n</blockquote>\n<p>It is not merely about one malicious programmer. It is also about trusting libraries. Currently we have a few centrally managed libraries so this is not an issue at all. But in the future, we need to have a reasonably easy way of checking that a library is not buggy internally (sure someone could intercept the download and add the bug, but that's beyond lean).</p>\n</blockquote>\n<p>I don't see why this is necessary any more than the usual standards of correctness for a library. How is it that you come to trust any library at all, without reviewing carefully all the code? Lean is not a trusted component, so if there are bugs then it's not a big deal, you report/fix them and move on</p>",
        "id": 393442610,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695808198
    },
    {
        "content": "<p>I'm curious how you expect to satisfy this criterion for, say, libraries written in Javascript, Rust, Ruby, etc.</p>",
        "id": 393443244,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695808294
    },
    {
        "content": "<p>I don't expect them to satisfy this requirement. They are not proof checkers. Worst case, my application throws an exception and I have to use my debugger to isolate the cause.</p>",
        "id": 393443720,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1695808368
    },
    {
        "content": "<p>How do you debug a proof OTOH? It doesn't run. It doesn't get tested. It doesn't crash. And with a bug like this, it accepts incorrect theorems silently.</p>",
        "id": 393444054,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1695808424
    },
    {
        "content": "<p>Lean is not a proof checker, it is a proof assistant. There is a difference</p>",
        "id": 393444393,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695808504
    },
    {
        "content": "<p>It checks proofs as a convenience for proof authors, so it can give nice error messages and the like</p>",
        "id": 393444586,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695808562
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/113488-general/topic/PSA.20about.20trusting.20Lean.20proofs/near/393443720\">said</a>:</p>\n<blockquote>\n<p>I don't expect them to satisfy this requirement. They are not proof checkers. Worst case, my application throws an exception and I have to use my debugger to isolate the cause.</p>\n</blockquote>\n<p>the exact same thing applies to lean programs. Worst case, it throws an exception and you use a debugger</p>",
        "id": 393444768,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695808597
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/PSA.20about.20trusting.20Lean.20proofs/near/393441481\">said</a>:</p>\n<blockquote>\n<p>I checked, there is no opportunity to run custom code during initialization to affect the relevant parts of the state of <code>lean4checker</code>. The only avenue for corruption is to cause UB and break lean that way.</p>\n</blockquote>\n<p>I think Anne's point is that my lean code can contain the equivalent of <code>f = open('leanchecker', 'w'); f.write(\"echo ok\")</code>, and so by the time you run the checker its not the binary you thought it was any more. This is obviously easy to protect against by having leanchecker be in a  read-only filesystem</p>",
        "id": 393444842,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1695808611
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/PSA.20about.20trusting.20Lean.20proofs/near/393444768\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/113488-general/topic/PSA.20about.20trusting.20Lean.20proofs/near/393443720\">said</a>:</p>\n<blockquote>\n<p>I don't expect them to satisfy this requirement. They are not proof checkers. Worst case, my application throws an exception and I have to use my debugger to isolate the cause.</p>\n</blockquote>\n<p>the exact same thing applies to lean programs. Worst case, it throws an exception and you use a debugger</p>\n</blockquote>\n<p>Programs yes. Proofs?</p>",
        "id": 393444843,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1695808611
    },
    {
        "content": "<p>What about proofs? Lean is a tool to help you build proofs. If you break it by some exploit, you won't get a proof out, so you aren't really incentivized to do so</p>",
        "id": 393445270,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695808707
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/PSA.20about.20trusting.20Lean.20proofs/near/393445270\">said</a>:</p>\n<blockquote>\n<p>What about proofs? Lean is a tool to help you build proofs. If you break it by some exploit, you won't get a proof out, so you aren't really incentivized to do so</p>\n</blockquote>\n<p>And if all I am doing is using a library which happens to contain this exploit that I can't find in an automated way?</p>",
        "id": 393445481,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1695808757
    },
    {
        "content": "<p>then the library has a bug and you should report it</p>",
        "id": 393445564,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695808778
    },
    {
        "content": "<p>you will know because it's producing bad proofs</p>",
        "id": 393445627,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695808797
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/PSA.20about.20trusting.20Lean.20proofs/near/393444842\">said</a>:</p>\n<blockquote>\n<p>I think Anne's point is that my lean code can contain the equivalent of <code>f = open('leanchecker', 'w'); f.write(\"echo ok\")</code>, and so by the time you run the checker its not the binary you thought it was any more</p>\n</blockquote>\n<p>Or really more generally that silly attacks will always remain possible if your threat models are powerful and motivated enough.</p>",
        "id": 393445866,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1695808839
    },
    {
        "content": "<p>Mario: That's easy to say if one is doing simple proofs. What happens if there is a bug in some library and someone is doing a verification effort on the scale of some easycrypt project?</p>",
        "id": 393445922,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1695808848
    },
    {
        "content": "<p>bad proofs here as determined by a checker</p>",
        "id": 393446053,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695808876
    },
    {
        "content": "<p>this is what checkers are for</p>",
        "id": 393446167,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695808904
    },
    {
        "content": "<p>(also, I have to emphasize that this isn't just a bug, it's a deliberate exploit. There is really no reason you would run into this on accident)</p>",
        "id": 393446452,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695808960
    },
    {
        "content": "<p>if there are exploits in your library you have bigger problems</p>",
        "id": 393446550,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695808986
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/PSA.20about.20trusting.20Lean.20proofs/near/393446053\">said</a>:</p>\n<blockquote>\n<p>bad proofs here as determined by a checker</p>\n</blockquote>\n<p>Anne: What I mean is that it is very reasonable for a threat model for an ITP to exclude that kind of external malicious change. This exploit is happening within the system \"lean\" (assistant + kernel).</p>\n<p>Mario : External checkers are needed. We agree on this. As for this being an exploit, in a large dependency chain, an exploit at one level can become a bug downstream.</p>",
        "id": 393447210,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1695809161
    },
    {
        "content": "<p>an exploit at any level is broken trust, you should not associate with that software vendor if they are doing misconduct</p>",
        "id": 393447899,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695809327
    },
    {
        "content": "<p>it's like discovering malware in your dependencies, you can't just paper over it, get it out of the system posthaste</p>",
        "id": 393448075,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695809384
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/PSA.20about.20trusting.20Lean.20proofs/near/393447899\">said</a>:</p>\n<blockquote>\n<p>an exploit at any level is broken trust, you should not associate with that software vendor if they are doing misconduct</p>\n</blockquote>\n<p>This is nice, but doesn't scale as dependency graphs get bigger. Do people check all their hundreds of npm dependencies and worse still the next layer of indirect dependencies.</p>",
        "id": 393448291,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1695809441
    },
    {
        "content": "<p>what I described is reactionary, it scales well enough</p>",
        "id": 393448430,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695809474
    },
    {
        "content": "<p>catching things before they blow up is harder to scale</p>",
        "id": 393448493,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695809490
    },
    {
        "content": "<p>but having a proof checker that can tell you if anyone in your stack is lying is a very scalable solution :)</p>",
        "id": 393448684,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695809531
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/PSA.20about.20trusting.20Lean.20proofs/near/393448075\">said</a>:</p>\n<blockquote>\n<p>it's like discovering malware in your dependencies, you can't just paper over it, get it out of the system posthaste</p>\n</blockquote>\n<p>so suppose a third level indirect dependency is malicious and there are in total a few hundred of them. How would I go about finding the malicious dependency? Does lean have a proof debugger?</p>",
        "id": 393449058,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1695809628
    },
    {
        "content": "<p>If we're talking bad proofs, it's really easy: the bad proof will be located in some module, which is in some package</p>",
        "id": 393450175,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695809921
    },
    {
        "content": "<p>although perhaps you want to blame the tactic that generated the proof rather than the proof itself</p>",
        "id": 393450313,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695809950
    },
    {
        "content": "<p>This is basically a non-issue in practice, it's usually not that hard to minimize errors once they are detected</p>",
        "id": 393450571,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695810006
    },
    {
        "content": "<p>How do we detect it quicky? Suppose we consider a large project with hundreds or thousands of dependencies.</p>",
        "id": 393450894,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1695810096
    },
    {
        "content": "<p>you mean like mathlib?</p>",
        "id": 393450958,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695810116
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/PSA.20about.20trusting.20Lean.20proofs/near/393450958\">said</a>:</p>\n<blockquote>\n<p>you mean like mathlib?</p>\n</blockquote>\n<p>I am not sure mathlib is a representative example. It is maintained and built by a relatively small number of very good people.</p>",
        "id": 393451167,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1695810155
    },
    {
        "content": "<p>Evidence suggests that during minimization you can throw away huge quantities of code, I would estimate the work is logarithmic in the number and size of dependencies</p>",
        "id": 393451287,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695810186
    },
    {
        "content": "<p>I suspect you are just going to no-true-scotsman any example I give here</p>",
        "id": 393451410,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695810227
    },
    {
        "content": "<p>sure, minimization is some work, but it's not intractable, even on million line codebases</p>",
        "id": 393451580,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695810269
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/PSA.20about.20trusting.20Lean.20proofs/near/393451410\">said</a>:</p>\n<blockquote>\n<p>I suspect you are just going to no-true-scotsman any example I give here</p>\n</blockquote>\n<p>Well here is one more question: How should reviewers of a paper submission review the proofs that have been submitted to them by anonymous authors, in lean, which might be large and have multiple dependencies?</p>",
        "id": 393456367,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1695811433
    },
    {
        "content": "<p>Maybe they run the code in the appendix through an external checker that automatically also checks all dependencies? I don't understand the problem.</p>",
        "id": 393458294,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1695811968
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113488-general/topic/PSA.20about.20trusting.20Lean.20proofs/near/393458294\">said</a>:</p>\n<blockquote>\n<p>Maybe they run the code in the appendix through an external checker that automatically also checks all dependencies? I don't understand the problem.</p>\n</blockquote>\n<p>Agreed. If the external checker checks everything in one go, then that works very well. </p>\n<p>What Petur initially pointed out is that this doesn't happen yet(see quote below). Further,  the immediate response to Petur was that no reasonable person would do something that inserts a proof of False in the environment. So it is not a cause for worry. Unfortunately making such an assumption is a non-starter for trusting any non trivial formal verification effort for systems, because a malicious dependency at one level could trickle down into wrong proofs downstream, especially when powerful tactics are involved.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"621865\">Petur Vetle</span> <a href=\"#narrow/stream/113488-general/topic/PSA.20about.20trusting.20Lean.20proofs/near/393398849\">said</a>:</p>\n<blockquote>\n<p>The thing that concerns me is not an adversary, but rather that its non-trivial to use Lean to verify the correctness of a proof written in Lean. It <em>should</em> be as simple as <code>#print axioms foo</code> and compile. However, the comments in this thread and the source code of <a href=\"https://github.com/leanprover/lean4checker\">lean4checker</a> indicate otherwise.</p>\n</blockquote>",
        "id": 393463078,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1695813141
    },
    {
        "content": "<p>Of course we would like multiple redundant versions of <code>lean4checker</code>, written in any other languages, and at least one is coming soon.</p>\n<p>But to my knowledge <code>lean4checker</code> is perfectly capable of checking any current proof in Lean from top to bottom. And setting aside \"but what if I changed the lean4checker binary\" type objections, I don't know of any ways around it.</p>\n<p>That said, it is 48 hours old, so presumably we will still think of further problems with it --- the 24 hour old version of it did have some gaps using constructors/recursors for inductives. It is only 200 lines long (+60 easy lines in another file), so adversarial reviews are both welcome and warranted! :-)</p>",
        "id": 393467306,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1695814087
    },
    {
        "content": "<p>(Of course, here I mean 200 lines beyond the Lean kernel.)</p>",
        "id": 393467457,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1695814134
    },
    {
        "content": "<p>We could start a bounty program. Anyone who finds a way to trick the checker can get a PR of their choice fast-tracked  :-)</p>",
        "id": 393469811,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1695814882
    },
    {
        "content": "<p>A Manifold market would have a similar effect <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 393471995,
        "sender_full_name": "Chris Wong",
        "timestamp": 1695815715
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/113488-general/topic/PSA.20about.20trusting.20Lean.20proofs/near/393456367\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/PSA.20about.20trusting.20Lean.20proofs/near/393451410\">said</a>:</p>\n<blockquote>\n<p>I suspect you are just going to no-true-scotsman any example I give here</p>\n</blockquote>\n<p>Well here is one more question: How should reviewers of a paper submission review the proofs that have been submitted to them by anonymous authors, in lean, which might be large and have multiple dependencies?</p>\n</blockquote>\n<p>Sorry to be mentioning this so many times, but it's such a nice use case of SNARKs. People could run a SNARK verifier on their smartphones with a QR code and it would approve or reject proofs in milliseconds. This sounds like the \"Lean 4 seal of approval\" that I was looking for ~2 years ago when I joined this Zulip server</p>\n<p><a href=\"#narrow/stream/113488-general/topic/.E2.9C.94.20Remotely.20trusted.20proofs/near/258633430\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/.E2.9C.94.20Remotely.20trusted.20proofs/near/258633430</a></p>",
        "id": 393472311,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1695815835
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> : I am extremely grateful for the lean4checker. Naturally one can't expect it to be absolutely perfect in 48 hours. Of course an end to end external checker that checks everything including dependencies is going to be a good solution as Johann suggests.</p>\n<p>My argument is more against the principle that there is no cause for worry about a malicious person inserting a proof of False in the environment, from inside the lean system, because then the entire proof is wrong anyway. At scale such malicious attempts can become almost undetectable and painful to find bugs. Not every project will be a nicely constructed and carefully maintained library like mathlib. Further as a lean expert, you and Kevin might not be worried too much about such stray attempts at cheating because you can see the mistake from a mile away. But in the long run, a project should strive to be something non-expert users who don't know metaprogramming internals can trust. Ultimately, formal verification's promise is for a user to be able to believe a system that says \"trust me it is correct per your spec\". I think that is also what Petur is trying to say.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/113488-general/topic/PSA.20about.20trusting.20Lean.20proofs/near/393463078\">said</a>:</p>\n<blockquote>\n<p>Further,  the immediate response to Petur was that no reasonable person would do something that inserts a proof of False in the environment. So it is not a cause for worry. </p>\n</blockquote>",
        "id": 393476914,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1695817550
    },
    {
        "content": "<p>I think we're in furious agreement here. Formal verification is meant to verify your proofs. That's what the Lean kernel does.</p>\n<p>A programming language that allows metaprogramming and is highly capable as a proof assistant is of course much more complex than a verifier, and can do many things.</p>",
        "id": 393477966,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1695817932
    },
    {
        "content": "<p>I still don't see how you think people are able to insert proofs of False into the system here. The lean checker makes sure that the environment matches the environment that the kernel would expect to build. Sure you can start attacking the lean checker and what not if you really want but that is not a Lean issue that's an IT security issue. If you are scared about this type of stuff just copy the oleans of the project into a VM and run the checker there in isolation or something like that.</p>\n<p>So the only way remaining to inject a proof of false into the system would be via an axiom which you can also detect if you wish. In particular you could just limit the set of axioms that you allow to show up and integrate that check into the lean4checker</p>\n<p>So what is your attack scenario here? How will a third party that you are importing code from compromise the trust you can have in the correctness of your proof?</p>",
        "id": 393478040,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1695817960
    },
    {
        "content": "<p>Just to clarify, I think the leanchecker tool is awesome already and a great step forward. I am not at all arguing against it.</p>",
        "id": 393478185,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1695818007
    },
    {
        "content": "<p>I get that, I just dont understand what you want to have in addition</p>",
        "id": 393478250,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1695818032
    },
    {
        "content": "<p>I think it's also important to realize that no piece of software in isolation should ever give a \"non-expert user\" good reason to trust a proof.</p>",
        "id": 393478255,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1695818037
    },
    {
        "content": "<p>Even the smallest verifiers require expertise to understand and check yourself.</p>",
        "id": 393478370,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1695818064
    },
    {
        "content": "<p>For a non-expert, you are choosing to trust the combined system of software and expert users. If you're at the point you can dispense with trusting the experts, you're already an expert ... <span aria-label=\"woman shrugging\" class=\"emoji emoji-1f937-200d-2640\" role=\"img\" title=\"woman shrugging\">:woman_shrugging:</span></p>",
        "id": 393478787,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1695818228
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span>, I mean, obviously what we want in addition is a freshly implemented verifier.</p>",
        "id": 393478995,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1695818317
    },
    {
        "content": "<p>To be clear. There aren't any known holes in the Lean kernel, right?</p>",
        "id": 393479288,
        "sender_full_name": "Chris Wong",
        "timestamp": 1695818424
    },
    {
        "content": "<p>That is correct</p>",
        "id": 393480489,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1695818917
    },
    {
        "content": "<p>Can <code>lean4checker</code> be incorporated by Lake?</p>",
        "id": 393481243,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1695819219
    },
    {
        "content": "<p>One thing  that is implicit in this thread and others (and that should not be taken for granted) is the openness of the whole community to present and honestly discuss possible “exploits”.</p>",
        "id": 393481290,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1695819240
    },
    {
        "content": "<p>I think it makes sense for <code>lean4checker</code> to remain a separate repository.</p>",
        "id": 393481497,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1695819314
    },
    {
        "content": "<p>You can run it in any Lean project with <code>lake env path/to/lean4checker</code>.</p>",
        "id": 393481683,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1695819380
    },
    {
        "content": "<p>And if you add it as a dependency to your <code>lakefile</code> then you can just run <code>lake exe lean4checker</code>.</p>",
        "id": 393481807,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1695819429
    },
    {
        "content": "<p>If there's a case for further integration I'd be interested to hear the details.</p>",
        "id": 393481943,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1695819479
    },
    {
        "content": "<p>Both options make sense, but if it becomes a straightforward Lake config (e.g. <code>checkOleans := true</code>), then the Lean 4 ecosystem issue would have a native solution instead of requiring users to deal with an extra moving piece.</p>\n<p>Another advantage is dependency and toolchain version management. Does <code>lean4checker</code> compile on toolchain X? That's a problem that users can simply not have.</p>",
        "id": 393482135,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1695819545
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/113488-general/topic/PSA.20about.20trusting.20Lean.20proofs/near/393478250\">said</a>:</p>\n<blockquote>\n<p>I get that, I just dont understand what you want to have in addition</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> : What Scott says. Ultimately, </p>\n<ol>\n<li>I want to be able to use libraries of proofs without checking every single inherited dependency manually.</li>\n<li>I want to be able to submit lean proofs as artifacts to conferences which they can check and trust without too much effort. </li>\n<li>As an artifact reviewer I would like to be able to sign off on formalisation artifacts within reasonable time and confidence in its correctness (including dependencies).</li>\n</ol>",
        "id": 393489771,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1695822036
    },
    {
        "content": "<p>The <code>lean4checker</code> reads <code>.olean</code> files, which are directly memory-mapped, and not validated. So it might be attackable by “poisonous olean” files that contain invalid data structure or override parts of the memory space. That level of nefariousity will require going through an external file format (which is planned, of course, just stating this for the record.)</p>",
        "id": 393529164,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1695831887
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/113488-general/topic/PSA.20about.20trusting.20Lean.20proofs/near/393489771\">said</a>:</p>\n<blockquote>\n<ol>\n<li>I want to be able to use libraries of proofs without checking every single inherited dependency manually.</li>\n</ol>\n</blockquote>\n<p>In the abstract, this is impossible. A proof is dependent on all its priors. To verify its soundness, you must necessarily verify its dependencies. This is true in general logic as well, if ZF is one day shown be inconsistent then everything borne from it becomes unsound. In practice, there can be a set of dependencies that is already considered \"trusted\" by the venue / community (e.g., because they have already gone through rigorous external checking) and a checker could be configured to skip checking those parts, saving time during a review.</p>",
        "id": 393548137,
        "sender_full_name": "Mac Malone",
        "timestamp": 1695839104
    },
    {
        "content": "<p>I don't want to check them _manually_</p>",
        "id": 393548463,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1695839247
    },
    {
        "content": "<p>I do want them checked automatically by the external checker as Johann suggested</p>",
        "id": 393548544,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1695839280
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113488-general/topic/PSA.20about.20trusting.20Lean.20proofs/near/393458294\">said</a>:</p>\n<blockquote>\n<p>Maybe they run the code in the appendix through an external checker that automatically also checks all dependencies? I don't understand the problem.</p>\n</blockquote>\n<p>Specifically what Johann said here.</p>",
        "id": 393548660,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1695839309
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/113488-general/topic/PSA.20about.20trusting.20Lean.20proofs/near/393548463\">said</a>:</p>\n<blockquote>\n<p>I don't want to check them _manually_</p>\n</blockquote>\n<p>I wasn't suggesting that? The (ideally, external) checker would be a program run by the reviewer on the untrusted parts of the codebase.</p>",
        "id": 393548861,
        "sender_full_name": "Mac Malone",
        "timestamp": 1695839392
    },
    {
        "content": "<p>I am referring to what I meant in point 1 in my earlier message, which you quoted. What I meant there is that I don't want to carefully read every file of every dependency to check for malicious lines. If I can run the external checker on an entire project + dependencies then I don't have to scrutinize it like that.</p>",
        "id": 393549657,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1695839660
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"466334\">@Shreyas Srinivas</span>  let me offer a constructive suggestion: your desires and goals are laudible, and I think everyone probably agrees that having maximal trust in our system is essential. However, I think that, for now, the discussion in that direction has been mostly exhausted. What is needed now is action. There are two potential ways you could contribute here:</p>\n<ol>\n<li>implement your own external Lean 4 proof checker in a language of your choice. I think there is already an alternative export format that can be used (besides oleans) that Sebastian implemented. Then make it open to the community for use.</li>\n<li>give concrete examples (with code!) of exploits that demonstrate your concerns and show how the existing tools (currently only lean4checker) are insufficient for the task.</li>\n</ol>",
        "id": 393549770,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1695839704
    },
    {
        "content": "<p>Note that this is how Jannis started this thread a few days ago and within about 60 hours there was already a new tool implemented to address his concern. Of course, I can't promise a 60-hour turnaround time on everything, but if you make the case with explicit examples of the problem, I'm sure the community will be open to addressing the issues.</p>",
        "id": 393549794,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1695839714
    },
    {
        "content": "<p>To clarify again, </p>\n<ol>\n<li>I am not asking for anything new. I am just arguing against a specific idea that was suggested here. </li>\n<li>I am perfectly happy with leanchecker and the proposed plan for external checkers.</li>\n</ol>",
        "id": 393550059,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1695839816
    },
    {
        "content": "<p>I've taken the occasion to reread the entire thread. The issue is that you are arguing against a specific idea, but:</p>\n<ol>\n<li>This problem you are suggesting is, thus far, purely hypothetical and does not at this time exist in practice (e.g., there do not exists Lean projects with hundreds or thousands of dependencies, and we have no evidence of malicious actors trying to get us to accept proofs of <code>False</code>).</li>\n<li>You have not taken the opportunity to <em>explicitly</em> demonstrate the problem arising. For example, you have not said: \"I have project X I am working on which contains Y and Z as dependencies. I would like to verify that my project <em>and all its dependents</em> are valid. Can I do this in a way that avoids manual effort?\"</li>\n<li>You have not taken the opportunity to write the tool you want. If there's something that doesn't exist (a <code>lean4checker</code> that will check all dependencies also), and you think we should have it but no one else does, just write it yourself.</li>\n</ol>\n<p>Note that (3) is exactly the story of <code>mathlib-changelog</code>, and afterwards the community recognized the value (it's a shame it hasn't yet been ported to Lean 4, but I'm just as guilty as anyone here since I haven't taken the steps to make it happen; for me, I didn't use it that much, but I know others did).</p>",
        "id": 393552919,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1695841006
    },
    {
        "content": "<p>All true. I am happy to try writing such a checker, if only as a fun exercise. But it is not fair to say \"something hasn't happened in lean yet so it is pointless to argue that we should mitigate against it\", especially since lean4 is fairly new. If every new language/project has to relearn each lesson from scratch, when we know these lessons from previous projects/languages, then no new problems would ever get solved. Supply chain attacks are well known and explored as a concept in other languages.</p>",
        "id": 393553980,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1695841411
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/113488-general/topic/PSA.20about.20trusting.20Lean.20proofs/near/393549770\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span>  let me offer a constructive suggestion: your desires and goals are laudible, and I think everyone probably agrees that having maximal trust in our system is essential. However, I think that, for now, the discussion in that direction has been mostly exhausted. What is needed now is action. There are two potential ways you could contribute here:</p>\n<ol>\n<li>implement your own external Lean 4 proof checker in a language of your choice. I think there is already an alternative export format that can be used (besides oleans) that Sebastian implemented. Then make it open to the community for use.</li>\n<li>give concrete examples (with code!) of exploits that demonstrate your concerns and show how the existing tools (currently only lean4checker) are insufficient for the task.</li>\n</ol>\n</blockquote>\n<p>Since the one language I know reasonably well besides Lean is scala, I can try to port Trepplein unless <span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> is already doing this.</p>",
        "id": 393623748,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1695880815
    },
    {
        "content": "<p>I think it would be good to have one written in not-lean though, I wouldn't want everyone to jump on the lean version</p>",
        "id": 393624135,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695880963
    },
    {
        "content": "<p>so perhaps before porting it to lean you should update it to lean 4 while still in scala</p>",
        "id": 393624179,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695880983
    },
    {
        "content": "<p>(for people suspicious of lean and looking for an external verifier, there are advantages to having a verifier written in not-lean)</p>",
        "id": 393624364,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695881069
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/PSA.20about.20trusting.20Lean.20proofs/near/393624135\">said</a>:</p>\n<blockquote>\n<p>I think it would be good to have one written in not-lean though, I wouldn't want everyone to jump on the lean version</p>\n</blockquote>\n<p>By \"port\" I meant to Lean 4 export format, still written in scala.</p>",
        "id": 393624486,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1695881125
    },
    {
        "content": "<p>Shouldn't we be making more people aware of this exploit, the existence of <code>lean4checker</code> and plans for external checkers? </p>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/PSA.20about.20trusting.20Lean.20proofs/near/393444393\">said</a>:</p>\n<blockquote>\n<p>Lean is not a proof checker, it is a proof assistant. There is a difference</p>\n</blockquote>\n<p>I'm not sure many people realise this. I didn't until I read this thread.</p>\n<p>Maybe this caveat should be added on the websites. I think <span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> made a good point in that people have different expectations between Lean and languages like C and Rust. If the consensus here is that some of these expectations are incorrect, then we should change those expectations.</p>",
        "id": 393765296,
        "sender_full_name": "Peiran Wu",
        "timestamp": 1695919348
    },
    {
        "content": "<p>To expand a bit on this, since it is clear it is a new idea to some:</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/PSA.20about.20trusting.20Lean.20proofs/near/393444393\">said</a>:</p>\n<blockquote>\n<p>Lean is not a proof checker, it is a proof assistant. There is a difference. It checks proofs as a convenience for proof authors, so it can give nice error messages and the like</p>\n</blockquote>\n<p>This is a key concept to understand, which I've had the good fortune to learn by Mario explaining it to me patiently. When you interact with Lean in VS Code (or emacs or neovim, etc.), it is acting as a <em>proof assistant</em>; it is providing you feedback on the current state of your proofs, and helping you fill them in using tactics. In order to be an effective proof assistant, Lean does not need to provide absolute certainty that there are no problems (e.g., you can have <code>sorry</code> in other places and that's still useful), it just needs to have a reasonable approximation.</p>\n<p>After you complete the proof, you want the proof assistant to be able to generate a file in some export format (<code>olean</code>, or something else perhaps), which can then be <em>verified</em> by a <em>proof checker</em>. These tasks (assistant and checker) should be separated. Thus far in Lean 4, we have been using the assistant as the checker, which does a more than passable job, but it is vulnerable to malicious actors. This is not the fault of Lean, it's doing exactly what it's meant to: being a proof assistant and general purpose programming language. That's why Scott implemented <code>lean4checker</code> and why other external checkers are in progress currently.</p>",
        "id": 393766592,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1695919874
    },
    {
        "content": "<p>The big difference between a proof assistant and a proof checker is that the proof assistant offers you a ton of tools which are super-useful for humans who want to make their own proofs (tactics), and also a ton of meta-tools which are super-useful for humans who want to make it easier for other humans to make their own proofs (the ability to write tactics). It seems that Lean 4 has gone so overboard with the meta-tools that you can now write meta-tools which let you manipulate things in ways which are not allowed in proofs and then skip the part where Lean actually checks that the manipulations are valid.</p>",
        "id": 393766628,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1695919889
    },
    {
        "content": "<p>However this is just what any flexible programming language is like and this is the insight Leo had -- that Lean had to become a fully-fledged programming language.</p>",
        "id": 393766874,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1695919980
    },
    {
        "content": "<p>Peiran, I don't really think the expectations are wrong. 99% of the time (or actually much much more), Lean-as-proof-assistant suffices for Lean-as-proof-checker. It's really only in the edge cases where there is a potential malicious actor that you need the extra check (or if you want an outside check on Lean, e.g., if you are worried about bugs in the kernel). These exploits are not the kind of thing you are going to accidentally add to your codebase.</p>",
        "id": 393767061,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1695920056
    },
    {
        "content": "<p>I think once you say a proof checker is different from a proof assistant, the rest is easy to grasp. But some might not realise that they have to realise there is a difference. I understand this is an edge case. But since Lean is fully-fledged programming language now, people will be using it to do things where this edge case might be more important. And I think with the ambition of being fully-fledged  comes the responsibility of better security announcements.</p>",
        "id": 393767857,
        "sender_full_name": "Peiran Wu",
        "timestamp": 1695920383
    },
    {
        "content": "<p>Am I right in understanding that the <code>Olean</code> files where not designed for this purpose, i.e. of being a format for external checkers to verify proofs. The <code>olean</code> format is a memory \"dump\" of lean and will change between lean releases. ?</p>",
        "id": 393768982,
        "sender_full_name": "MohanadAhmed",
        "timestamp": 1695920723
    },
    {
        "content": "<p>I think I must have heard from someone that \"if it compiles, it's correct\". They might have only intended to simplify things slightly. But when I start the Lean study group at my university in a few weeks, I will remember to tell everyone that there is a difference between \"if your code compiles\" and \"if someone else's code you found on GitHub compiles\".</p>",
        "id": 393769288,
        "sender_full_name": "Peiran Wu",
        "timestamp": 1695920840
    },
    {
        "content": "<p>You could say \"if the checker says yes then it's correct\" and \"every PR to mathlib is checked by the checker\" (which is not yet true but was true for Lean 3 and will become true in time) and \"hence code that you write yourself which uses only mathlib and only does maths and not hackery and which compiles is correct\" and finally \"if you run arbitrary lean code which someone else has written then it can (a) delete all the files on your computer and (b) can try to trick the system; it is possible to trick the system because Lean is super-sophisticated now but it's not possible to trick the checker\"</p>",
        "id": 393771549,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1695921822
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"258845\">Peiran Wu</span> <a href=\"#narrow/stream/113488-general/topic/PSA.20about.20trusting.20Lean.20proofs/near/393769288\">said</a>:</p>\n<blockquote>\n<p>I will remember to tell everyone that there is a difference between \"if your code compiles\" and \"if someone else's code you found on GitHub compiles\".</p>\n</blockquote>\n<p>I'll quote Ken Thompson from 1984 in <a href=\"https://www.cs.cmu.edu/~rdriley/487/papers/Thompson_1984_ReflectionsonTrustingTrust.pdf\">Reflections on Trusting Trust</a>:</p>\n<blockquote>\n<p>The moral is obvious. You can't trust code that you did not totally create yourself. [...] No amount of source-level verification or strutiny will protect you from using untrusted code.</p>\n</blockquote>\n<p>(He demonstrated how you can make a C compiler that injects a backdoor into programs in a way that is self-perpetuating and undetectable from the source code -- the C compiler executable itself inserts the backdoor inserter into the C compiler it compiles.)</p>\n<p>I suppose this is a little bit orthogonal to Lean and proofs, since with Lean you might expect that the \"math part\" was more sandboxed from the \"systems part\" than it currently is -- you have access to the whole metaprogramming interface even in the middle of proofs. Maybe one day we'll find the need to have a mode that restricts a module to using <em>only</em> the \"math part.\" Until then, I think I trust mathlib reviewers to reject PRs that do sketchy environment manipulations or try to access the filesystem.</p>",
        "id": 393773382,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1695922508
    },
    {
        "content": "<p>(that piece is especially relevant given that lean 4 is <em>also</em> a bootstrapping compiler)</p>",
        "id": 393773669,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695922605
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113488-general/topic/PSA.20about.20trusting.20Lean.20proofs/near/393773382\">said</a>:</p>\n<blockquote>\n<p>Until then, I think I trust mathlib reviewers to reject PRs that do sketchy environment manipulations or try to access the filesystem.</p>\n</blockquote>\n<p>I do as well. (I'm generally paranoid about code security and use Docker containers extensively, but I do trust mathlib reviewers.)</p>\n<p>I just want to reiterate my point that I think more people should be made aware of the exploit and mitigations against it, in contexts outside of mathlib.</p>",
        "id": 393776560,
        "sender_full_name": "Peiran Wu",
        "timestamp": 1695923578
    }
]