[
    {
        "content": "<p>As per a previous conversation <a class=\"stream-topic\" data-stream-id=\"113489\" href=\"/#narrow/channel/113489-new-members/topic/MapM.20for.20List.2EVector/with/565263476\">#new members &gt; MapM for List.Vector</a> , I am building out a lot of the missing api for <code>List.Vector</code>. I plan to submit this as a PR, but I have a few questions about how best to approach this task.</p>\n<p>The main things i'm implementing so far are definitions like <code>mapM</code>, <code>mapIdx</code>, <code>mapFinIdx</code>, <code>mapFinIdxM</code>, <code>range'</code>, <code>range</code>, as well as lemmas about these utilities, for example <code>mapM_append</code>, <code>range_append</code>, <code>get_mapFinIdx</code>, etc.</p>\n<p><strong>Question 1: What to add</strong><br>\nFinding which <em>definitions</em> to add seems easy, but knowing which lemmas to add seems tricky. <code>List</code> and <code>Vector</code> both have <code>map</code> and <code>mapFinIdx</code>, but they don't have the same utility lemmas proved for them. Right now i'm just taking a guess at what seems the most useful to have, but are there any more structured approaches to this I should take?</p>\n<p><strong>Question 2: How best to define things</strong><br>\nLet's take <code>mapFinIdx</code> as an example. I could define this as essentially a lift of <code>List.mapFinIdx</code>, and then all of the associated lemmas would probably have the similar approach, relying on lemmas from about <code>List.mapFinIdx</code>. Alternatively, I could define <code>mapFinIdx</code> in terms of <code>List.Vector</code>s natively, and then prove this equivalent to a lifted version of <code>List.mapFinIdx</code>. The second approach is more fun, so it's what I'm doing first, but I wonder if the community has an opinion on which is better? Some example definitions below (in the <code>List.Vector</code> namespace):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- `mapFinIdx` defined specifically for Vectors.</span>\n<span class=\"kd\">@[</span><span class=\"n\">inline</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">expose</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">mapFinIdx</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"o\">[],</span><span class=\"w\"> </span><span class=\"bp\">_⟩</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">nil</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">omega</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">::ᵥ</span><span class=\"w\"> </span><span class=\"n\">mapFinIdx</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">l</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp_all</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">omega</span><span class=\"o\">))</span>\n\n<span class=\"c1\">-- `mapFinIdx` defined using `List.mapFinIdx`</span>\n<span class=\"kd\">@[</span><span class=\"n\">inline</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">expose</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">mapFinIdx'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">l</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">mapFinIdx</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">omega</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">])</span><span class=\"bp\">⟩</span>\n</code></pre></div>\n<p><strong>Question 3: How to annotate things</strong><br>\nI have read through the mathlib style guidelines and i'm trying to stick to them. I have intuition about what should be added to <code>simp</code> and what shouldn't, but some documentation about this would also be helpful, if somebody could point me in the right direction. The same goes for things like <code>grind</code>, <code>inline</code>, etc.<br>\nAlternatively, should I just write it all up on my own and then sort these details out as part of the PR approval process?</p>\n<p><strong>A note on <code>List.Vector</code></strong><br>\nI know a few people will say that this is not useful work, as <code>List.Vector</code> may be deprecated, but it's a bit of fun for me to do this, and i'll still be happy to get a PR approved even if the work is later deleted.</p>\n<p><strong>A note on casting</strong><br>\nThere are some lemmas that seem obvious / important to have implemented for <code>List.Vector</code>. For example <code>append_assoc</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">cast_length</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h_eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">⟨</span><span class=\"n\">as</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">length_val</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h_eq</span><span class=\"o\">]</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">append_assoc</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bs</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">cs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">bs</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">cs</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">cast_length</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">omega</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>This is a useful lemma, but can't really exist without some kind of casting. For now i'm using my own abbreviation <code>cast_length</code> that casts only the lengths of Vectors, it's a system that's working pretty well, but I'd definitely want to chat to somebody about it before including them in a PR.</p>\n<p>Sorry for the long message, and thanks in advance for any advice :)</p>",
        "id": 567361498,
        "sender_full_name": "Scott Buckley",
        "timestamp": 1768100032
    },
    {
        "content": "<p>I really thought there would be an already existing cast function for <code>List.Vector</code>, like how we have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fin.cast#doc\">docs#Fin.cast</a> for <code>Fin</code></p>",
        "id": 567361659,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1768100318
    },
    {
        "content": "<p>It exists for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Vector#doc\">docs#Vector</a></p>",
        "id": 567362357,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1768101374
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Vector.append_assoc#doc\">docs#Vector.append_assoc</a></p>",
        "id": 567362360,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1768101392
    },
    {
        "content": "<p>Note that we're indeed trying to decide whether to deprecate <code>List.Vector</code>.</p>",
        "id": 567362395,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1768101458
    },
    {
        "content": "<p>Where is <code>List.Vector</code> currently used? And how hard is it to replace it within those files?</p>",
        "id": 567388114,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1768135451
    },
    {
        "content": "<p>I think this is nice work to do even if I think it'll be useless and it should be deprecated: it's good for your soul if nothing else to do this kind of thing.</p>",
        "id": 568176383,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1768474033
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/channel/113488-general/topic/A.20few.20questions.20about.20contributing.20within.20.60List.2EVector.60/near/567362395\">said</a>:</p>\n<blockquote>\n<p>Note that we're indeed trying to decide whether to deprecate <code>List.Vector</code>.</p>\n</blockquote>\n<p>You mean internally, or is there a discussion on Zulip I missed? Apart from <a class=\"stream-topic\" data-stream-id=\"113489\" href=\"/#narrow/channel/113489-new-members/topic/MapM.20for.20List.2EVector/with/567396191\">#new members &gt; MapM for List.Vector</a> and <a href=\"#narrow/channel/287929-mathlib4/topic/Use.20.60Vector.60.20more.3F\">#mathlib4 &gt; Use &#96;Vector&#96; more?</a>, but neither topic is about depreciation.</p>",
        "id": 568180289,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768475295
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/113488-general/topic/A.20few.20questions.20about.20contributing.20within.20.60List.2EVector.60/near/567388114\">said</a>:</p>\n<blockquote>\n<p>Where is <code>List.Vector</code> currently used? And how hard is it to replace it within those files?</p>\n</blockquote>\n<p>It's not used much, just a few places. <code>Vector</code> is not used at all (I'm not counting implementations of tactics etc.)</p>",
        "id": 568180418,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768475342
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"115259\">Scott Buckley</span> <a href=\"#narrow/channel/113488-general/topic/A.20few.20questions.20about.20contributing.20within.20.60List.2EVector.60/near/567361498\">said</a>:</p>\n<blockquote>\n<p>This is a useful lemma, but can't really exist without some kind of casting. For now i'm using my own abbreviation <code>cast_length</code> that casts only the lengths of Vectors.</p>\n</blockquote>\n<p>There's <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Vector/Defs.html#List.Vector.congr\">List.Vector.congr</a>. We might want to rename it to <code>cast</code> to be in-line with <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Data/Vector/Basic.html#Vector.cast\">Vector.cast</a>.</p>",
        "id": 568181736,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768475765
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"870257\">Jakub Nowak</span> <a href=\"#narrow/channel/113488-general/topic/A.20few.20questions.20about.20contributing.20within.20.60List.2EVector.60/near/568180418\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/113488-general/topic/A.20few.20questions.20about.20contributing.20within.20.60List.2EVector.60/near/567388114\">said</a>:</p>\n<blockquote>\n<p>Where is <code>List.Vector</code> currently used? And how hard is it to replace it within those files?</p>\n</blockquote>\n<p>It's not used much, just a few places. <code>Vector</code> is not used at all (I'm not counting implementations of tactics etc.)</p>\n</blockquote>\n<p>Vector is used in the implementation of Batteries.BinaryHeap (specifically the implementations of heapifyDown and heapifyUp)</p>",
        "id": 568227038,
        "sender_full_name": "cmlsharp",
        "timestamp": 1768487150
    },
    {
        "content": "<p>Ah, sorry, I only checked mathlib and forgot batteries.<br>\nI should specify, we should absolutely not replace <code>Vector</code> with <code>List.Vector</code> in implementations, because of performance. But we should keep using <code>List.Vector</code> and not <code>Vector</code> in proofs.</p>",
        "id": 568236063,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768489040
    },
    {
        "content": "<p>In hindsight this might have made my verification PR of BinaryHeap somewhat easier. Because of the implementation of heapifyDown and heapifyUp, the wellformedness condition is specified in terms of <code>Vector</code> but it might have been easier if it had been specified in terms of <code>List.Vector</code> (were <code>List.Vector</code> available in Batteries of course)</p>",
        "id": 568237193,
        "sender_full_name": "cmlsharp",
        "timestamp": 1768489264
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/channel/113488-general/topic/A.20few.20questions.20about.20contributing.20within.20.60List.2EVector.60/near/568176383\">said</a>:</p>\n<blockquote>\n<p>it's good for your soul if nothing else to do this kind of thing.</p>\n</blockquote>\n<p>Yeah my thoughts exactly. It feels so good to write and prove all these simple (and occasionally slightly less simple) interconnected theorems.</p>",
        "id": 568379141,
        "sender_full_name": "Scott Buckley",
        "timestamp": 1768551751
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"870257\">Jakub Nowak</span> <a href=\"#narrow/channel/113488-general/topic/A.20few.20questions.20about.20contributing.20within.20.60List.2EVector.60/near/568181736\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"115259\">Scott Buckley</span> <a href=\"#narrow/channel/113488-general/topic/A.20few.20questions.20about.20contributing.20within.20.60List.2EVector.60/near/567361498\">said</a>:</p>\n<blockquote>\n<p>This is a useful lemma, but can't really exist without some kind of casting. For now i'm using my own abbreviation <code>cast_length</code> that casts only the lengths of Vectors.</p>\n</blockquote>\n<p>There's <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Vector/Defs.html#List.Vector.congr\">List.Vector.congr</a>. We might want to rename it to <code>cast</code> to be in-line with <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Data/Vector/Basic.html#Vector.cast\">Vector.cast</a>.</p>\n</blockquote>\n<p>Thanks for pointing out <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Vector/Defs.html#List.Vector.congr\">List.Vector.congr</a>, I hadn't seen that! I need to get better at searching for things like this.</p>\n<p>About renaming to <code>cast</code>, would it make sense to just write <code>cast</code> in my fork, adjust <code>congr</code> to be marked as deprecated, and include that in the PR? Or would something like that be discussed here first? There's a similar issue with <code>List.Vector.mmap</code> which I think should be named <code>mapM</code> (although somebody suggested it should actually be <code>mapA</code>).</p>",
        "id": 568379730,
        "sender_full_name": "Scott Buckley",
        "timestamp": 1768551962
    },
    {
        "content": "<p>That sounds fine to just make as a PR</p>",
        "id": 568405784,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1768560578
    },
    {
        "content": "<p>(perhaps a separate one for each)</p>",
        "id": 568405897,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1768560609
    },
    {
        "content": "<p>Please keep up your work on <code>List.Vector</code>. Recently, I work on a way to implement discrete probability. There, I exactly need <code>List.Vector</code>, since </p>\n<ul>\n<li>it is simple to do <code>induction</code> over <code>List.Vector</code> (not true for <code>Vector</code>, which should be avoided in proofs anyway, as far as I can tell); </li>\n<li><code>List.Vector α n</code> is a <code>Fintype</code>, if <code>α</code> is a Fintype (not true for <code>List</code>);</li>\n<li>it has a <code>Traversable</code> instance, allowing to use <code>sequence</code> for mapping over a <code>List.Vector</code>. (Here, it is particular beneficial that the result knows about its own dimension in comparison with <code>List</code>, which leads to annoying trivial cases.)</li>\n</ul>",
        "id": 571763265,
        "sender_full_name": "Peter Pfaffelhuber",
        "timestamp": 1770153024
    },
    {
        "content": "<p>It could be simple to do proofs over Vector, and I do actually do it a lot.</p>",
        "id": 571847131,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1770194673
    },
    {
        "content": "<p>List.Vector doesn't particularly have an advantage over it in that sense.</p>",
        "id": 571847205,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1770194693
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/channel/113488-general/topic/A.20few.20questions.20about.20contributing.20within.20.60List.2EVector.60/near/571847205\">said</a>:</p>\n<blockquote>\n<p>List.Vector doesn't particularly have an advantage over it in that sense.</p>\n</blockquote>\n<p>Yes, but exactly the same argument can be used to argument that one could use Array instead of List.</p>",
        "id": 572149337,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1770298454
    },
    {
        "content": "<p>Well, no, I think the fact that List is a relatively simple inductive type (which List.Vector is not!) does make it useful to work with.</p>",
        "id": 572368615,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1770382295
    },
    {
        "content": "<p>One could imagine a world in which List.Vector was defined as:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">List</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">List</span>\n</code></pre></div>",
        "id": 572369206,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1770382473
    },
    {
        "content": "<p>And actually... I would like this more honestly! That is the \"honest\"  inductive definition of <code>List.Vector</code>.</p>",
        "id": 572369393,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1770382525
    },
    {
        "content": "<p>Then you add:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Vector</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">toList</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">toList</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[],</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">▸</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">nil</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">▸</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">)</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">Vector</span>\n</code></pre></div>",
        "id": 572370622,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1770382883
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/channel/113488-general/topic/A.20few.20questions.20about.20contributing.20within.20.60List.2EVector.60/near/572369393\">said</a>:</p>\n<blockquote>\n<p>And actually... I would like this more honestly! That is the \"honest\"  inductive definition of <code>List.Vector</code>.</p>\n</blockquote>\n<p>This definition is not chosen on purpose because it wastes memory compared to the subtype definition. And requires you to rebuild massive amounts of proofs.</p>",
        "id": 572370972,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1770382978
    },
    {
        "content": "<p>Array is fundamentally not constructed in the same way that List is - even though on a logical level it's a wrapper for List, List.cons is \"fast\" on lists and not on Arrays, but Arrays are faster in general (especially for arbitrary accesses).</p>",
        "id": 572370977,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1770382979
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/channel/113488-general/topic/A.20few.20questions.20about.20contributing.20within.20.60List.2EVector.60/near/572370972\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/channel/113488-general/topic/A.20few.20questions.20about.20contributing.20within.20.60List.2EVector.60/near/572369393\">said</a>:</p>\n<blockquote>\n<p>And actually... I would like this more honestly! That is the \"honest\"  inductive definition of <code>List.Vector</code>.</p>\n</blockquote>\n<p>This definition is not chosen on purpose because it wastes memory compared to the subtype definition.</p>\n</blockquote>\n<p>Right - what I don't understand is why we care about performance for <code>List.Vector</code>.</p>",
        "id": 572371071,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1770383004
    },
    {
        "content": "<p>I mean to be clear I think the definition of <em>Vector</em> is clearly the right one.</p>",
        "id": 572371104,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1770383014
    },
    {
        "content": "<p>But if we want to keep List.Vector - and honestly as I've said before I am not really a strong advocate for that - I think an implementation that exhibits the inductive construction would be better than one that prioritises performance.</p>",
        "id": 572371268,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1770383060
    },
    {
        "content": "<p>Why would you not care about performance for such a simple type? It's also not very fun to rebuild all of the proof infrastructure that has been done for <code>List</code> from scratch. All of the lemmas from <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Data/List.html\">https://leanprover-community.github.io/mathlib4_docs/Init/Data/List.html</a> would have to be reproven from scratch.</p>",
        "id": 572371417,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1770383105
    },
    {
        "content": "<p>Ah, you see, I would find that extremely fun :)</p>",
        "id": 572371520,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1770383136
    },
    {
        "content": "<p>I would argue that List.Vector already rebuilds a lot of proof infrastructure (I don't like that it exists).</p>",
        "id": 572371711,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1770383187
    },
    {
        "content": "<p>Why does <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Vector/Basic.html#List.Vector.inductionOn\">List.Vector.inductionOn</a> exist, for instance, if we would rather people use the proof infrastructure of <code>List</code>?</p>",
        "id": 572371904,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1770383248
    },
    {
        "content": "<p>I think it makes sense that Array exists and Vector exists though I do wish they had inductive principles - I accept the reasons they don't though.</p>",
        "id": 572372277,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1770383357
    },
    {
        "content": "<p>If the goal in Mathlib of <code>List.Vector</code> is to be \"the Vector you do proofs on\", I would argue you should choose the definition for proof reasons (and I like the inductive definition better for that) and not for performance reasons.</p>",
        "id": 572372480,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1770383410
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/channel/113488-general/topic/A.20few.20questions.20about.20contributing.20within.20.60List.2EVector.60/near/572371904\">said</a>:</p>\n<blockquote>\n<p>Why does <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Vector/Basic.html#List.Vector.inductionOn\">List.Vector.inductionOn</a> exist, for instance, if we would rather people use the proof infrastructure of <code>List</code>?</p>\n</blockquote>\n<p>We want people to use the proof infrastructure for list to build a minimal layer that exposes the proof infrastructure of List + length assumptions instead of having to go through all of the list nonsense again. The end goal of List.Vector as a data type is of course not that people still rely on the List API most of the time, the question is how the Vector API is built and that is simply easier with all that we have for lists already. There is about 16k LoC in <code>Init.Data.List</code>, nobody should have to replicate this for an invariant as trivial as \"the list has a certain length\"</p>",
        "id": 572373827,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1770383844
    },
    {
        "content": "<p>Mmm - honestly I was not really clear on the purpose of List.Vector (as opposed to Vector).</p>",
        "id": 572374315,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1770383994
    },
    {
        "content": "<p>Given the file that defines it suggests it could be deprecated I wouldn't say that Mathlib defines it very strongly currently. But I agree - nobody should have to replicate that.</p>",
        "id": 572374432,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1770384028
    },
    {
        "content": "<p>(You mention the Vector API but to be clear I am not talking about Vector but List.Vector - I think this is what you meant, though the List.Vector API is sorely in need of updates.)</p>",
        "id": 572374572,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1770384068
    },
    {
        "content": "<p>Why is it ok to replicate List API for Array and Vector, but not for List.Vector? Is it just because the former two are more commonly used, so it's worth the effort?</p>",
        "id": 572385964,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1770386950
    },
    {
        "content": "<p>Neither <code>Array</code> or <code>Vector</code> rebuild the List API. <code>Array</code> functions behave usually quite differently from their respective <code>List</code> friends so it is not possible to just reuse the lemmas that we have proven about say <code>List.foldl</code> to do proofs about <code>Array.foldl</code>. On the other hand doing proofs about <code>Vector</code> by just using the <code>Array</code> API is easy so the <code>Vector</code> API is built upon the <code>Array</code> API without doing massive amounts of proofs on their own again. You do of course want to replicate the available API surface, the thing you do not want to replicate is the proofs which are almost all trivial in the respective <code>Vector</code> versions. When you go from a subtype to an inductive encoding of <code>List.Vector</code> you suddenly do have to do all proofs from scratch though</p>",
        "id": 572389300,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1770387789
    },
    {
        "content": "<p>I don't think you would have to do all proofs from scratch. You only need extensionality and proofs that the definitions coincide, so theorems like <code>List.Vector.foldl f x v = List.foldl f x v.toList</code> or <code>List.Vector.reverse v |&gt;.toList = List.reverse v.toList</code>. And you can than reuse proofs from List API by rewriting with these equalities.</p>",
        "id": 572392416,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1770388544
    },
    {
        "content": "<p>Currently, and as I said above, I am working with <code>List.Vector</code> since I find most tools that I need. (It is a <code>Traversable</code>, has an induction principle, is a <code>Fintype</code>,  etc.) I wonder why <code>List.Vector.count {n : ℕ} (a : α) : (l : List.Vector α n) → Fin (n + 1)</code> does not exist. (Also <code>Vector.count</code> maps to <code>ℕ</code>, which I do not understand. Wouldn't it be better to e.g. know that <code>count</code> maps to a <code>Fintype</code>?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"bp\">.</span><span class=\"n\">count</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">↦</span>\n<span class=\"w\">  </span><span class=\"bp\">⟨</span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"bp\">.</span><span class=\"n\">count</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">lt_of_le_of_lt</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"bp\">.</span><span class=\"n\">count_le_length</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">lt_of_le_of_lt</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">prop</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">lt_add_one</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">))</span><span class=\"bp\">⟩</span>\n</code></pre></div>",
        "id": 572394428,
        "sender_full_name": "Peter Pfaffelhuber",
        "timestamp": 1770389079
    },
    {
        "content": "<p>For symmetry with <code>Vector</code> we probably want <code>List.Vector.count</code> map to <code>Nat</code>. But we can consider adding <code>Vector.countFin</code> and <code>List.Vector.countFin</code>.</p>",
        "id": 572418636,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1770395392
    }
]