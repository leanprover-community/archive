[
    {
        "content": "<p>Over the past month and a half, I've been experimenting a bit with possible approaches to verified program synthesis in Lean (using the new <code>Std.Do</code> library). I've discovered some interesting possibilities here, and wanted to share what I've done so far for anyone who may be interested in this topic.</p>\n<p>The main idea I've been working with is to use Lean's unification algorithm to synthesize parts of Lean programs. For instance, in the following example, we can manually synthesize a \"hole\" in the definition of <code>f</code>, by proving the existence of a value to fill the hole to allow us to satisfy the spec. A metavar representing the hole is assigned through  unification when we use the <code>rfl</code> tactic:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Do</span>\n\n<span class=\"c1\">-- `x` is a \"hole\" in the definition of the function `f`</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Id</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">f_spec</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span>\n<span class=\"w\">   </span><span class=\"o\">⦃</span><span class=\"bp\">⌜</span><span class=\"n\">True</span><span class=\"bp\">⌝</span><span class=\"o\">⦄</span>\n<span class=\"w\">   </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">   </span><span class=\"o\">⦃</span><span class=\"bp\">⇓</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">⌜</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"bp\">⌝</span><span class=\"o\">⦄</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Given an existential goal `∃ x : T, P x`, `exists? mvar` will create</span>\n<span class=\"w\">  </span><span class=\"c1\">-- a new metavariable `?mvar : T` which is provided as the existential</span>\n<span class=\"w\">  </span><span class=\"c1\">-- witness, leaving us with the goal `P ?mvar`. `?mvar` can then be</span>\n<span class=\"w\">  </span><span class=\"c1\">-- assigned via unification during the proof.</span>\n<span class=\"w\">  </span><span class=\"n\">exists?</span><span class=\"w\"> </span><span class=\"n\">mvar1</span>\n<span class=\"w\">  </span><span class=\"c1\">-- ⊢ ⦃⌜True⌝⦄ f ?mvar1 ⦃⇓r =&gt; ⌜r = 0⌝⦄</span>\n<span class=\"w\">  </span><span class=\"n\">mintro</span><span class=\"w\"> </span><span class=\"bp\">-</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"c1\">-- ⊢ ?mvar1 = 0</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"c1\">-- assigns `?mvar1 = 0`</span>\n</code></pre></div>\n<p>I had to write the custom tactic <code>exists?</code> to get this to work, as well as a few more custom tactics that can be found <a href=\"https://github.com/rish987/qsort/blob/f90e73ec4ed903f57ccdd66352b72a5fbe3ad2e0/Qsort/Monadic/Aux.lean\">in this file</a>. These tactics allowed me to extend this experiment to a larger proof of the <code>qpartition</code> subroutine of the standard library's <code>qsort</code> quicksort function. I have incrementally eaten away at <a href=\"https://github.com/rish987/qsort/blob/f90e73ec4ed903f57ccdd66352b72a5fbe3ad2e0/Qsort/Monadic/Qpartition.lean#L13\">the original definition of the <code>qpartition</code> function</a> by introducing holes to arrive at <a href=\"https://github.com/rish987/qsort/blob/f90e73ec4ed903f57ccdd66352b72a5fbe3ad2e0/Qsort/Monadic/QpartitionHoles.lean#L13\">this program sketch</a>, and I was able to <a href=\"https://github.com/rish987/qsort/blob/f90e73ec4ed903f57ccdd66352b72a5fbe3ad2e0/Qsort/Monadic/QpartitionHoles.lean#L37\">write a proof of correctness</a> that \"synthesizes\" the holes via unification. I was also able to synthesize <a href=\"https://github.com/rish987/qsort/blob/f90e73ec4ed903f57ccdd66352b72a5fbe3ad2e0/Qsort/Monadic/QpartitionHoles.lean#L78\">parts of the loop invariant</a> used in the proof.</p>\n<p>As you can see, given the overall structure of the program, as well as some lemmas from a \"specification theory\" <a href=\"https://github.com/rish987/qsort/blob/f90e73ec4ed903f57ccdd66352b72a5fbe3ad2e0/Qsort/Monadic/Theory.lean\">that can be found here</a>, I was able to use just a few different tactics to synthesize a good number of the <code>Nat</code>s from the original implementation (there's a few more in there that I haven't gotten around to trying yet; ignore the FIXMEs for now, that's where I noticed that some desired automation is currently lacking). This would seem to point to a particular strategy for program synthesis in Lean, in which we rely entirely on Lean's unification algorithm to fill in missing holes from programs during a proof of the existence of values filling the holes that allow the spec to be satisfied. The fact that I was able to do this with such a limited set of tactics suggests that it may be possible to arrive at such a proof via near-exhaustive search within a reasonable amount of time using a tool like Pantograph -- well, at least at this small scale. I imagine that scaling this form of synthesis up to larger programs with larger specification theories is where ML techniques may become relevant (reinforcement learning, in particular) to achieve more efficient search.</p>\n<p>One technical issue here: due to small elimination, we can't extract the actual existential witnesses from the proof -- we need these to instantiate the holes to finally construct the verified program. This may be fairly trivial to solve, however, by having the tactic proof keep track of the metavar assignments to generate an auxiliary definition from.</p>\n<p>The major question here is how we could possibly extend this approach to synthesize actual monadic program fragments. I was quite successful here synthesizing argument subexpressions of certain monadic function calls, but how do we synthesize the calls themselves? I don't think this can (or should) be achieved by unification -- however, given a \"monadic hole\" with unknown preconditions and postconditions, we can use unification to constrain what \"overall shape\" these pre- and postconditions should have, such that we narrow down which possible calls can fill these holes such that they \"fit the mold\" of the specification shape imposed by the subsequent proof. We'll also likely have to account for the interactions with <code>mvcgen</code>, since the verification conditions will change as we progressively flesh out a monadic hole's pre- and postconditions.</p>\n<p>It seems like this might be a new approach to program synthesis, at least as far as I have read in <a href=\"https://people.csail.mit.edu/asolar/SynthesisCourse/index.htm\">Armando Solar-Lezama's lecture notes</a> on the topic. What I've done so far seems most similar to Solar-Lezama's \"Sketch\" tool, which similarly allows the user to leave holes in programs that are synthesized. The difference is that it does so by using the holes to produce constraints that are passed to an SAT solver. The benefit of this approach could be that since we only rely on unification for synthesis, we aren't constrained by the capabilities of a SAT solver, but rather by the richness of our tactic DSL (which, once we have run through sufficiently many examples, should approach something that is fairly \"fixed\") and the user-provided specification theory.</p>\n<p>I'll be burying my nose into writing my thesis over the next month or so, but in the meantime I just wanted to see what our initial thoughts are on this possible approach.</p>",
        "id": 532700419,
        "sender_full_name": "Rish Vaishnav",
        "timestamp": 1754304413
    },
    {
        "content": "<p>(I should probably mention that this approach is not to be confused with \"Synthesis through Unification\" (STUN) which is another approach to program synthesis that uses the word \"unification\" in quite a different sense)</p>",
        "id": 532723247,
        "sender_full_name": "Rish Vaishnav",
        "timestamp": 1754312517
    }
]