[
    {
        "content": "<p>Roughly speaking, how often is equality of types actually used in Mathlib? I'm thinking about analyzing the use of universes in Mathlib (specifically trying to automatically optimize the consistency strength used by proofs) and I feel like this is going to be important for the approach I'm envisioning.</p>\n<p>I know that it's possible to write a script in Lean that searches for this kind of thing, but I'm finding the documentation of the relevant libraries a little sparse.</p>",
        "id": 563074481,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765406764
    },
    {
        "content": "<p>Should be (almost?) never</p>",
        "id": 563074637,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1765406850
    },
    {
        "content": "<p>That would be my guess, but is it actually never used even by tactics?</p>",
        "id": 563074931,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765406998
    },
    {
        "content": "<p>What do you mean by \"used\"? Sometimes, casting is necessary.</p>",
        "id": 563074985,
        "sender_full_name": "Mirek OlÅ¡Ã¡k",
        "timestamp": 1765407023
    },
    {
        "content": "<p>for example <code>rw</code> uses <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Eq.mpr#doc\">docs#Eq.mpr</a></p>",
        "id": 563075023,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765407041
    },
    {
        "content": "<p>I wouldn't be surprised if <code>congr</code>/<code>convert</code> are responsible for a good number of type equalities.</p>",
        "id": 563075063,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1765407069
    },
    {
        "content": "<p>Of course, there are a lot of undecidable questions regarding type equalities, and I would expect mathlib definitions not depending on these undecidable questions.</p>",
        "id": 563075101,
        "sender_full_name": "Mirek OlÅ¡Ã¡k",
        "timestamp": 1765407098
    },
    {
        "content": "<p>equality of types is not evil when it's an equality of indices</p>",
        "id": 563075289,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765407239
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek OlÅ¡Ã¡k</span> <a href=\"#narrow/channel/113488-general/topic/How.20often.20is.20equality.20of.20types.20used.20in.20Mathlib.3F/near/563074985\">said</a>:</p>\n<blockquote>\n<p>What do you mean by \"used\"? Sometimes, casting is necessary.</p>\n</blockquote>\n<p>I mean it in the broad sense of proof terms containing subterms of the form <code>A = B : Prop</code> or <code>p : A = B</code>.</p>",
        "id": 563075319,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765407258
    },
    {
        "content": "<p>Then yes, casting can happen, and be important in dealing with dependent types. Why is it a problem? By the way, I was also thinking of analyzing the universes, <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  did a preliminary analysis of counting that there are at most 5 universes used, and than we were discussing how the analysis could be more careful.</p>",
        "id": 563076293,
        "sender_full_name": "Mirek OlÅ¡Ã¡k",
        "timestamp": 1765407738
    },
    {
        "content": "<p>Mirek do you want to remind us of the reason that some reasonable-looking statement about counting ended up using 5 universes? You gave us an explanation at LLL once right?</p>\n<p>The reason I mention this is that it demonstrates how controlling universes in lean proofs might be a harder problem than one might initially think (well at least that was my take-home message from your presentation).</p>",
        "id": 563076950,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1765408094
    },
    {
        "content": "<p>It had a reasonable core of why like 1 extra universe pops up mathematically, and the remaining 4 were some technical (hard to explain) details.</p>",
        "id": 563077105,
        "sender_full_name": "Mirek OlÅ¡Ã¡k",
        "timestamp": 1765408176
    },
    {
        "content": "<p>Right but it might be the case that James would be interested in hearing this. I am very conscious of the fact that you worked out a bunch of stuff, told a room full of people in London and then this information didn't ever get written down (so it's only people like you and Mario that understand these subtleties).</p>",
        "id": 563077258,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1765408265
    },
    {
        "content": "<p>I remember saying to Mario in about 2019 \"presumably it's easy to take a Lean proof that ostensibly uses universes and run some analysis on it to verify that it could be translated into a ZFC proof\" and Mario's response was something like \"this is actually harder than you think\" and I never really understood why at the time, but your LLL demo gave me a much clearer idea of how Lean just throws universes around.</p>",
        "id": 563077486,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1765408379
    },
    {
        "content": "<p>Sure, let me write here the \"reasonable core\"</p>",
        "id": 563077573,
        "sender_full_name": "Mirek OlÅ¡Ã¡k",
        "timestamp": 1765408418
    },
    {
        "content": "<p>old thread here <a class=\"message-link\" href=\"/#narrow/channel/236446-Type-theory/topic/Theory.20of.20Lean.20with.20n.20universes/near/422239958\">#Type theory &gt; Theory of Lean with n universes @ ðŸ’¬</a>  ,  older thread here <a class=\"message-link\" href=\"/#narrow/channel/113488-general/topic/Highest.20universe.20in.20mathlib/near/265998823\">#general &gt; Highest universe in mathlib @ ðŸ’¬</a></p>",
        "id": 563078020,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1765408646
    },
    {
        "content": "<ul>\n<li><code>Nat.card</code> is a function that takes a <code>Î± : Type</code>, and returns a <code>Nat</code> which is the number of the elements in case the given type is finite, or zero if it is infinite. Looks tame, right?</li>\n<li>However, it is defined as a function which first converts <code>Î±</code> to a <code>Cardinal.{0}</code>, and then compares this with <code>â„µâ‚€</code>. This already raises eyebrows a little, when you want to think of a <code>Cardinal</code> as an equivalence class on all sets. On the other hand, for analysis purposes, it would be also possible to just think of a <code>Cardinal</code> as a lightweight wrapper around <code>Type</code>, only with redefined <code>=</code> meaning <code>â‰ƒ</code>. So basic reasoning about cardinals can be translated into reasoning about types.</li>\n<li>However, when proving some basic facts about <code>Nat.card</code>, it is useful to know <code>Cardinal.nat_lt_aleph0</code>: that when we take a natural number, and convert to a cardinal, the resulting cardinal is smaller than <code>aleph0</code>. In the proof of this obvious fact, we change the goal <code>â†‘n &lt; â„µâ‚€</code> to <code>succ â†‘n â‰¤ â„µâ‚€</code>, where the <code>succ</code> is a cardinal successor.</li>\n<li>Why is a cardinal successor well defined? Standard set theory builds it through taking as all the ordinal types inside but that is not the most straightforward way in Lean. In Lean, we know that cardinals form a well-order, so we can take the class of all strictly bigger cardinals, and take the smallest one.</li>\n<li>How do we prove that every class of cardinals has a minimal element? Remember, Lean's cardinals are just types ordered with injective mappings, they are not by definition ordinals like in ZFC. But no problem, you might know a proof why every two sets are comparable: use Zorn's lemma to find a maximal matching between the two sets, and the smaller set is the one that ran out of elements. The same idea can be done as well on a class of cardinals, you take a maximal class-ary matching, and find the set which ran out of elements.</li>\n<li>This math is still inside Type 1, but quite nontrivially outside ZFC.</li>\n</ul>",
        "id": 563080471,
        "sender_full_name": "Mirek OlÅ¡Ã¡k",
        "timestamp": 1765410068
    },
    {
        "content": "<p>And then the other universe jumps:</p>\n<ul>\n<li><code>Lean.Data.AC.Variable</code> which is used for some low-level automation in proofs (<code>AC</code> stands for associativity, commutativity) raises the universe level for no essential reason. It stores a datapoint of universe <code>Sort u</code> but itself it is of universe <code>Type u = Sort (u+1)</code>. The technical reason is that it cannot be <code>Sort 0</code> if the input is <code>Sort 0</code>, and the universe level <code>max</code> is not sufficiently flexible.</li>\n<li>Standard recursion uses more universe levels than one would expect. Consider for example a function defined by</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n</code></pre></div>\n<p>it is a little wild but looks definable in ZFC. The analysis would claim it uses up to <code>Type 2</code> because if you <code>#print f</code>, you see it uses <code>Nat.brecOn</code>, and its first hidden argument is a <code>motive := (fun x â†¦ Type)</code> which is of type <code>â„• â†’ Type 1</code> which is of type <code>Type 2</code>.</p>",
        "id": 563082030,
        "sender_full_name": "Mirek OlÅ¡Ã¡k",
        "timestamp": 1765410978
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek OlÅ¡Ã¡k</span> <a href=\"#narrow/channel/113488-general/topic/How.20often.20is.20equality.20of.20types.20used.20in.20Mathlib.3F/near/563080471\">said</a>:</p>\n<blockquote>\n<ul>\n<li>This math is still inside Type 1, but quite nontrivially outside ZFC.</li>\n</ul>\n</blockquote>\n<p>Sure, but nothing in this argument as written needs the cardinality bound of Type and Type 1 to actually be inaccessible cardinals. The same proof would work verbatim if Type happened to be types of cardinality less than <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"normal\">â„¶</mi><mi>Ï‰</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\beth_{\\omega}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8389em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord amsrm\">â„¶</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">Ï‰</span></span></span></span></span><span class=\"vlist-s\">â€‹</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> and Type 1 happened to be types of cardinality less than <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"normal\">â„¶</mi><mrow><mi>Ï‰</mi><mo>+</mo><mi>Ï‰</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">\\beth_{\\omega+\\omega}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8972em;vertical-align:-0.2083em;\"></span><span class=\"mord\"><span class=\"mord amsrm\">â„¶</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2583em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">Ï‰</span><span class=\"mbin mtight\">+</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">Ï‰</span></span></span></span></span><span class=\"vlist-s\">â€‹</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2083em;\"><span></span></span></span></span></span></span></span></span></span>, say.</p>",
        "id": 563093461,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765419304
    },
    {
        "content": "<ul>\n<li>Say that a 'small cardinal' is an equinumerosity class of elements of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>V</mi><mrow><mi>Ï‰</mi><mo>+</mo><mi>Ï‰</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">V_{\\omega+\\omega}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8917em;vertical-align:-0.2083em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2583em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">Ï‰</span><span class=\"mbin mtight\">+</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">Ï‰</span></span></span></span></span><span class=\"vlist-s\">â€‹</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2083em;\"><span></span></span></span></span></span></span></span></span></span>.</li>\n<li>Cantor-SchrÃ¶der-Bernstein shows that the injection pre-order lifts to a partial order on the small cardinals.</li>\n<li>Cantor's theorem regarding power sets shows that for any small cardinal there is a strictly larger small cardinal.</li>\n<li>You can similarly show that the set of small cardinals is well-ordered by the lift of the injection order, which together with the previous point shows that any small cardinal has a small cardinal successor.</li>\n</ul>",
        "id": 563093789,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765419632
    },
    {
        "content": "<p>So I guess like I find 'nontrivially outside ZFC' a little bit debatable. It's only outside of ZFC if you're bad at set theory.</p>",
        "id": 563095107,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765420610
    },
    {
        "content": "<p>I think the real question is not whether the theorem is provable (obviously it is), but rather whether the proof itself can be made to fit in ZFC</p>",
        "id": 563095130,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765420654
    },
    {
        "content": "<p>so you need to be good at set theory for it to work</p>",
        "id": 563095144,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765420661
    },
    {
        "content": "<p>I think that's nontrivial</p>",
        "id": 563095148,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765420664
    },
    {
        "content": "<p>It's all well and good talking about kappa-small whatever, but unless you have a strategy for uniformly and automatically putting that in all the right places in the proof I don't see how you make it work</p>",
        "id": 563095221,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765420738
    },
    {
        "content": "<p>and doing that is roughly what Mirek and I discussed</p>",
        "id": 563095285,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765420786
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/113488-general/topic/How.20often.20is.20equality.20of.20types.20used.20in.20Mathlib.3F/near/563095130\">said</a>:</p>\n<blockquote>\n<p>I think the real question is not whether the theorem is provable (obviously it is), but rather whether the proof itself can be made to fit in ZFC</p>\n</blockquote>\n<p>I don't understand. I just sketched how to make that proof fit in ZFC.</p>",
        "id": 563095379,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765420875
    },
    {
        "content": "<p>Or do you mean 'how to make it automatically fit in ZFC'?</p>",
        "id": 563095398,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765420900
    },
    {
        "content": "<p>if you had to elaborate the proof again with different adjectives then it's a different proof, no?</p>",
        "id": 563095440,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765420938
    },
    {
        "content": "<p>unless you actually mean the first sentence \"The same proof would work verbatim if Type happened to be types of cardinality less than <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"normal\">â„¶</mi><mi>Ï‰</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\beth_{\\omega}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8389em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord amsrm\">â„¶</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">Ï‰</span></span></span></span></span><span class=\"vlist-s\">â€‹</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> and Type 1 happened to be types of cardinality less than <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"normal\">â„¶</mi><mrow><mi>Ï‰</mi><mo>+</mo><mi>Ï‰</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">\\beth_{\\omega+\\omega}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8972em;vertical-align:-0.2083em;\"></span><span class=\"mord\"><span class=\"mord amsrm\">â„¶</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2583em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">Ï‰</span><span class=\"mbin mtight\">+</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">Ï‰</span></span></span></span></span><span class=\"vlist-s\">â€‹</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2083em;\"><span></span></span></span></span></span></span></span></span></span>, say.\" in which case I'm not sure what you mean by the bullets</p>",
        "id": 563095492,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765420992
    },
    {
        "content": "<p>Okay so the actual automatic strategy I'm envisioning is this:</p>\n<ul>\n<li>Examine the relevant types to determine the most fine-grained assignment of universe levels that is compatible with the type checking. (In particular, you also give new universe level variables to types that are normally a fixed level (like <code>Nat</code>).)</li>\n<li>Look at what type formation operations are actually being used for each of those level variables.</li>\n<li>Ideally you'd then find that many of these universes only really need to be closed under some fairly small fragment of the standard type forming operations. (This is the most questionable part.)</li>\n<li>Then use this to convert the proof (in whatever specific language) to one that uses fewer full universes.</li>\n</ul>",
        "id": 563095767,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765421290
    },
    {
        "content": "<p>why do you need the first bullet?</p>",
        "id": 563095815,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765421340
    },
    {
        "content": "<p>otherwise yes I more or less agree on the strategy, and in this case I think you would want an answer which says that the proof ultimately only uses that Type 1 is closed under powerset. Unfortunately I think it will also need to have several dependent pi types in it so you will have to be careful to detect this if you don't want it to be required to be a regular cardinal</p>",
        "id": 563095931,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765421448
    },
    {
        "content": "<p>Well so set-theoretically, there's kind of two varieties of 'reasonably closed' cardinals. There's regular cardinals and there's strong limit cardinals. Strongly inaccessible cardinals are cardinals that are closed in both senses, but ZFC alone gives you plenty of cardinals that are one or the other.</p>\n<p>The idea is that maybe in many specific places you only really need one or the other kind of closure and tying everything to the same <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span>-indexed hierarchy of universes makes those different kinds of requirements interact in a way that artificially requires inaccessible cardinals.</p>",
        "id": 563095995,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765421509
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/113488-general/topic/How.20often.20is.20equality.20of.20types.20used.20in.20Mathlib.3F/near/563095931\">said</a>:</p>\n<blockquote>\n<p>otherwise yes I more or less agree on the strategy, and in this case I think you would want an answer which says that the proof ultimately only uses that Type 1 is closed under powerset. Unfortunately I think it will also need to have several dependent pi types in it so you will have to be careful to detect this if you don't want it to be required to be a regular cardinal</p>\n</blockquote>\n<p>What would be an example of one of the dependent pi types that shows up in this proof?</p>",
        "id": 563096026,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765421536
    },
    {
        "content": "<p>the part that Mirek sketched is the main content of the proof, but there is a bunch of bureaucratic nonsense done to get to that point</p>",
        "id": 563096106,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765421595
    },
    {
        "content": "<p>and when it comes to universe level counting the bureaucracy is as impactful if not more so than the \"real content\"</p>",
        "id": 563096169,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765421647
    },
    {
        "content": "<p>Right, that makes sense.</p>\n<p>What would you say is a minimally complicated proof in Mathlib in which this starts to happen noticeably? I would be interested in trying to look at it in detail.</p>",
        "id": 563096204,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765421702
    },
    {
        "content": "<p>well Mirek's example uses not 1 universe but 5</p>",
        "id": 563096242,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765421739
    },
    {
        "content": "<p>at most one has an interesting origin story</p>",
        "id": 563096262,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765421761
    },
    {
        "content": "<p>the other are facepalm moments</p>",
        "id": 563096291,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765421779
    },
    {
        "content": "<p>So would you already see this bureaucracy in action in, say, the proof that addition on the natural numbers is commutative?</p>",
        "id": 563096325,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765421816
    },
    {
        "content": "<p>yes, I believe so</p>",
        "id": 563096337,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765421828
    },
    {
        "content": "<p>you could try running the tool on Nat.add_comm</p>",
        "id": 563096357,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765421842
    },
    {
        "content": "<p>I did. I saw something involving <code>brecOn</code>, which I think was mentioned in one of the previous threads.</p>",
        "id": 563096412,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765421891
    },
    {
        "content": "<p>One thing I was confused about though before was that in some places you were saying that Mathlib only uses 3 universes and in others 5. I assume these are in different senses of 'use'?</p>",
        "id": 563096576,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765422040
    },
    {
        "content": "<p>mathlib has changed between lean 3 and lean 4</p>",
        "id": 563096702,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765422138
    },
    {
        "content": "<p>the discussion has spanned multiple years</p>",
        "id": 563096711,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765422153
    },
    {
        "content": "<p>Ah I see.</p>",
        "id": 563096717,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765422163
    },
    {
        "content": "<p>Is there a better way to look at proof terms in detail than to try to step through something like this?<br>\n<a href=\"/user_uploads/3121/Royii1IPknhMMdY4ZYXWL8Fo/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/Royii1IPknhMMdY4ZYXWL8Fo/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1170x882\" src=\"/user_uploads/thumbnail/3121/Royii1IPknhMMdY4ZYXWL8Fo/image.png/840x560.webp\"></a></div>",
        "id": 563097032,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765422458
    },
    {
        "content": "<p>Specifically, this is the result of</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">pp</span><span class=\"bp\">.</span><span class=\"n\">all</span><span class=\"w\"> </span><span class=\"n\">true</span>\n\n<span class=\"bp\">#</span><span class=\"n\">reduce</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">proofs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">types</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">add_comm</span>\n</code></pre></div>",
        "id": 563097207,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765422616
    },
    {
        "content": "<p>well you shouldn't reduce it in the first place, just look at the individual declarations</p>",
        "id": 563097309,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765422682
    },
    {
        "content": "<p>What do you mean by that specifically?</p>",
        "id": 563097379,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765422728
    },
    {
        "content": "<p><code>#print Nat.add_comm</code>,  <code>#print Nat.below</code> etc</p>",
        "id": 563097456,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765422778
    },
    {
        "content": "<p>but without a tool telling you where to look you'll probably get lost anyway</p>",
        "id": 563097505,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765422808
    },
    {
        "content": "<p>By the way, theoretically, I was also asking this question which could help making this \"you are not using too large cardinalities\" more rigorous. Unfortunatelly, I still don't know the answer, building a model out of somehow bounded functions is still trickier than I thought... <a class=\"message-link\" href=\"/#narrow/channel/236446-Type-theory/topic/Can.20ZFC.20model.20restricted.20Lean.3F/near/561261993\">#Type theory &gt; Can ZFC model restricted Lean? @ ðŸ’¬</a></p>",
        "id": 563170415,
        "sender_full_name": "Mirek OlÅ¡Ã¡k",
        "timestamp": 1765454797
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"904624\">James E Hanson</span> <a href=\"#narrow/channel/113488-general/topic/How.20often.20is.20equality.20of.20types.20used.20in.20Mathlib.3F/near/563093461\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek OlÅ¡Ã¡k</span> <a href=\"#narrow/channel/113488-general/topic/How.20often.20is.20equality.20of.20types.20used.20in.20Mathlib.3F/near/563080471\">said</a>:</p>\n<blockquote>\n<ul>\n<li>This math is still inside Type 1, but quite nontrivially outside ZFC.</li>\n</ul>\n</blockquote>\n<p>Sure, but nothing in this argument as written needs the cardinality bound of Type and Type 1 to actually be inaccessible cardinals. The same proof would work verbatim if Type happened to be types of cardinality less than <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"normal\">â„¶</mi><mi>Ï‰</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\beth_{\\omega}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8389em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord amsrm\">â„¶</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">Ï‰</span></span></span></span></span><span class=\"vlist-s\">â€‹</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> and Type 1 happened to be types of cardinality less than <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"normal\">â„¶</mi><mrow><mi>Ï‰</mi><mo>+</mo><mi>Ï‰</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">\\beth_{\\omega+\\omega}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8972em;vertical-align:-0.2083em;\"></span><span class=\"mord\"><span class=\"mord amsrm\">â„¶</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2583em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">Ï‰</span><span class=\"mbin mtight\">+</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">Ï‰</span></span></span></span></span><span class=\"vlist-s\">â€‹</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2083em;\"><span></span></span></span></span></span></span></span></span></span>, say.</p>\n</blockquote>\n<p>This is a little tricky statement what you mean by \"needs the cardinality bound\". You got the successor function on cardinals from some magic in <code>Type 1</code> (or above due to the bureaucracy I mentioned next). If you then take a small set of Cardinal's in <code>Type</code>, and take a successor of each. As long as you don't have a control over how quickly the successor function grows, you have no guarantee that this image stays in <code>Type</code>.</p>",
        "id": 563172206,
        "sender_full_name": "Mirek OlÅ¡Ã¡k",
        "timestamp": 1765455464
    },
    {
        "content": "<p>My plan would be to for start:</p>\n<ul>\n<li>give up on issues like the Zorn's lemma on class-ary matchings</li>\n<li>try to implement the straightforward interpreting <code>Type</code> as the class of all sets</li>\n<li>track which <code>Type 1</code> objects are still representable with a ZFC (first order definable) class (<code>Cardinal.{0}</code>, <code>Ordinal.{0}</code>, bundled structures) -- ZFC can handle classes a little, you can quantify over them, separation &amp; replacement uses class functions</li>\n<li>try to reduce terms when we would be getting higher. Often the reason for it is just infrastructure, for example typeclass inference, and ultimately doesn't need higher universes after reduction</li>\n<li>find the first moments where this jumps out of ZFC (my example of Zorn's lemma over class-ary matchings would be one of them)</li>\n</ul>",
        "id": 563175053,
        "sender_full_name": "Mirek OlÅ¡Ã¡k",
        "timestamp": 1765456162
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek OlÅ¡Ã¡k</span> <a href=\"#narrow/channel/113488-general/topic/How.20often.20is.20equality.20of.20types.20used.20in.20Mathlib.3F/near/563172206\">said</a>:</p>\n<blockquote>\n<p>As long as you don't have a control over how quickly the successor function grows,</p>\n</blockquote>\n<p>Successor is bounded by power set. It's very easy to ensure that a set of cardinals is closed under successors.</p>",
        "id": 563225163,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765468728
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek OlÅ¡Ã¡k</span> <a href=\"#narrow/channel/113488-general/topic/How.20often.20is.20equality.20of.20types.20used.20in.20Mathlib.3F/near/563175053\">said</a>:</p>\n<blockquote>\n<ul>\n<li>for example typeclass inference,</li>\n</ul>\n</blockquote>\n<p>Is it easy to explain why typeclass inference introduces universes?</p>",
        "id": 563228317,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765469364
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"904624\">James E Hanson</span> <a href=\"#narrow/channel/113488-general/topic/How.20often.20is.20equality.20of.20types.20used.20in.20Mathlib.3F/near/563225163\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek OlÅ¡Ã¡k</span> <a href=\"#narrow/channel/113488-general/topic/How.20often.20is.20equality.20of.20types.20used.20in.20Mathlib.3F/near/563172206\">said</a>:</p>\n<blockquote>\n<p>As long as you don't have a control over how quickly the successor function grows,</p>\n</blockquote>\n<p>Successor is bounded by power set. It's very easy to ensure that a set of cardinals is closed under successors.</p>\n</blockquote>\n<p>You know this. An analysis tool that just looked over some magic with Zorn's lemma over class-ary matchings will not make this deduction.</p>",
        "id": 563298582,
        "sender_full_name": "Mirek OlÅ¡Ã¡k",
        "timestamp": 1765494881
    },
    {
        "content": "<p>Just to be clear, I am not arguing that math in Lean cannot be done with ZFC, I think almost all of it can (maybe except some niches, for example if someone formalized the consistency in ZFC...) I was trying to explain why checking this automatically is hard.</p>",
        "id": 563299767,
        "sender_full_name": "Mirek OlÅ¡Ã¡k",
        "timestamp": 1765495743
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"904624\">James E Hanson</span> <a href=\"#narrow/channel/113488-general/topic/How.20often.20is.20equality.20of.20types.20used.20in.20Mathlib.3F/near/563228317\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek OlÅ¡Ã¡k</span> <a href=\"#narrow/channel/113488-general/topic/How.20often.20is.20equality.20of.20types.20used.20in.20Mathlib.3F/near/563175053\">said</a>:</p>\n<blockquote>\n<ul>\n<li>for example typeclass inference,</li>\n</ul>\n</blockquote>\n<p>Is it easy to explain why typeclass inference introduces universes?</p>\n</blockquote>\n<p>First, I need to emphasise that \"introduces universes\" is not a well defined concept, only a vague idea of \"we are somehow using more than ZFC allows\". Type theory doesn't match with set theory exactly, in particular has these infinitely many axioms which mimic some second-order functions but not others, so no matter what I write, you could object a bit.</p>\n<p>But let me try. Let's say we understand how to model <code>Ordinal.{0}</code> in ZFC. Ordinals are partially ordered, which is realized with the typeclass instance</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Ordinal</span><span class=\"bp\">.</span><span class=\"n\">partialOrder</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PartialOrder</span><span class=\"w\"> </span><span class=\"n\">Ordinal</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>A partial order is a structure containing among others</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">PartialOrder</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"w\">  </span><span class=\"n\">lt</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"w\">  </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>So we first use <code>PartialOrder.mk.{1} : (Î± â†’ Î± â†’ Prop) â†’  (Î± â†’ Î± â†’ Prop) â†’ ...</code> to build such instance,<br>\nand then look inside it again with <code>LE.le</code> to interpret what it means when we write <code>o1 &lt; o2</code> for two ordinals <code>o1</code>, <code>o2</code>. For example the <code>PartialOrder.mk.{1}</code> is not even a class function, it takes class functions as arguments, and wraps them into one object. Mario was suggesting that maybe we could have a type system above ZFC to take care of these but I am not exactly sure what it should be, and it might be easier to just try to reduce (so we can see what happens in practice).</p>",
        "id": 563300788,
        "sender_full_name": "Mirek OlÅ¡Ã¡k",
        "timestamp": 1765496482
    },
    {
        "content": "<p>I think James is suggesting to take Ordinal.{0} to be the set of ordinals in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"normal\">â„¶</mi><mi>Ï‰</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\beth_\\omega</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8389em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord amsrm\">â„¶</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">Ï‰</span></span></span></span><span class=\"vlist-s\">â€‹</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></p>",
        "id": 563300869,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765496560
    },
    {
        "content": "<p>I don't know exactly which constructions in mathlib escape the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>V</mi><mrow><mi>Ï‰</mi><mo>+</mo><mi>Ï‰</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">V_{\\omega+\\omega}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8917em;vertical-align:-0.2083em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2583em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">Ï‰</span><span class=\"mbin mtight\">+</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">Ï‰</span></span></span></span></span><span class=\"vlist-s\">â€‹</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2083em;\"><span></span></span></span></span></span></span></span></span></span> model, certainly <code>Cardinal.beth</code>.</p>",
        "id": 563301171,
        "sender_full_name": "Mirek OlÅ¡Ã¡k",
        "timestamp": 1765496789
    },
    {
        "content": "<p>the important one is <code>Cardinal.ord</code></p>",
        "id": 563301231,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765496837
    },
    {
        "content": "<p>inductive types?</p>",
        "id": 563301307,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765496917
    },
    {
        "content": "<p>Also, when I say I believe Lean's math can be done within ZFC, it implies that it can be also done within some <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>V</mi><mi>Î±</mi></msub></mrow><annotation encoding=\"application/x-tex\">V_{\\alpha}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">Î±</span></span></span></span></span><span class=\"vlist-s\">â€‹</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> because then it is done only using finitely many axioms, and finitely many axioms of ZFC fit inside some <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>V</mi><mi>Î±</mi></msub></mrow><annotation encoding=\"application/x-tex\">V_{\\alpha}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">Î±</span></span></span></span></span><span class=\"vlist-s\">â€‹</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>. The difficulty is to ensure automatically it is the case.</p>",
        "id": 563301416,
        "sender_full_name": "Mirek OlÅ¡Ã¡k",
        "timestamp": 1765497004
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/113488-general/topic/How.20often.20is.20equality.20of.20types.20used.20in.20Mathlib.3F/near/563301307\">said</a>:</p>\n<blockquote>\n<p>inductive types?</p>\n</blockquote>\n<p>Sure, forall type too. But I meant the specific examples.</p>",
        "id": 563301526,
        "sender_full_name": "Mirek OlÅ¡Ã¡k",
        "timestamp": 1765497088
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek OlÅ¡Ã¡k</span> <a href=\"#narrow/channel/113488-general/topic/How.20often.20is.20equality.20of.20types.20used.20in.20Mathlib.3F/near/563301171\">said</a>:</p>\n<blockquote>\n<p>I don't know exactly which constructions in mathlib escape the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>V</mi><mrow><mi>Ï‰</mi><mo>+</mo><mi>Ï‰</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">V_{\\omega+\\omega}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8917em;vertical-align:-0.2083em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2583em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">Ï‰</span><span class=\"mbin mtight\">+</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">Ï‰</span></span></span></span></span><span class=\"vlist-s\">â€‹</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2083em;\"><span></span></span></span></span></span></span></span></span></span> model, certainly <code>Cardinal.beth</code>.</p>\n</blockquote>\n<p>In general I'm imagining something a little bit more dynamic than picking cardinal bounds manually, something analogous to how you prove the reflection theorem.</p>",
        "id": 563301767,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765497291
    },
    {
        "content": "<p>Yes, then the only issue is when the function is coming from a higher universe, like the cardinal successor function constructed via Zorn's lemma in <code>Type 1</code>.</p>",
        "id": 563301985,
        "sender_full_name": "Mirek OlÅ¡Ã¡k",
        "timestamp": 1765497460
    },
    {
        "content": "<p>Sure but that could live in something like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>V</mi><msub><mi>Ï‰</mi><mn>1</mn></msub></msub></mrow><annotation encoding=\"application/x-tex\">V_{\\omega_1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9334em;vertical-align:-0.2501em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">Ï‰</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3173em;\"><span style=\"top:-2.357em;margin-left:-0.0359em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">â€‹</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">â€‹</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2501em;\"><span></span></span></span></span></span></span></span></span></span>.</p>",
        "id": 563302073,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765497521
    },
    {
        "content": "<p>In theory, you could do wild things in the higher universe, for example you could take a natural number <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>, and return the smallest <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Î±</mi></mrow><annotation encoding=\"application/x-tex\">\\alpha</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">Î±</span></span></span></span> such that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>V</mi><mi>Î±</mi></msub></mrow><annotation encoding=\"application/x-tex\">V_{\\alpha}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">Î±</span></span></span></span></span><span class=\"vlist-s\">â€‹</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> is a partial model of ZFC satisfying the first <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> instances of replacement... You could even construct a wordly cardinal in <code>Type 0</code>.</p>",
        "id": 563302366,
        "sender_full_name": "Mirek OlÅ¡Ã¡k",
        "timestamp": 1765497708
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Do you have a script that can list the definitions of inductive types that are actually used in a theorem? I think I saw something like that in <code>ZFCWithoutInductives.lean</code>.</p>",
        "id": 563302438,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765497732
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek OlÅ¡Ã¡k</span> <a href=\"#narrow/channel/113488-general/topic/How.20often.20is.20equality.20of.20types.20used.20in.20Mathlib.3F/near/563302366\">said</a>:</p>\n<blockquote>\n<p>In theory, you could do wild things in the higher universe, for example you could take a natural number <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>, and return the smallest <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Î±</mi></mrow><annotation encoding=\"application/x-tex\">\\alpha</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">Î±</span></span></span></span> such that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>V</mi><mi>Î±</mi></msub></mrow><annotation encoding=\"application/x-tex\">V_{\\alpha}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">Î±</span></span></span></span></span><span class=\"vlist-s\">â€‹</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> is a partial model of ZFC satisfying the first <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> instances of replacement... You could even construct a wordly cardinal in <code>Type 0</code>.</p>\n</blockquote>\n<p>Sure, I understand that <code>Type 0</code> is comparable to the category of sets smaller than an inaccessible cardinal and that you can reflect things down from higher <code>Type n</code>'s into <code>Type 0</code>, but the question is whether you can tell by inspection that certain proofs really aren't using that much power.</p>",
        "id": 563302722,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765497904
    },
    {
        "content": "<p>Then, the inspection would have to get some understanding of what the Zorn's lemma trick defining successor is doing, otherwise it cannot distinguish it from the \"evil\" functions such as this one.</p>",
        "id": 563302932,
        "sender_full_name": "Mirek OlÅ¡Ã¡k",
        "timestamp": 1765498042
    },
    {
        "content": "<p>Why do you think the Zorn's lemma thing is so difficult specifically?</p>",
        "id": 563302954,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765498065
    },
    {
        "content": "<p>Also, to be honest, I really wouldn't use the word 'evil' to describe those things.</p>",
        "id": 563302984,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765498090
    },
    {
        "content": "<p>Ok, sorry <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span> , I should write non-ZFC.</p>",
        "id": 563303073,
        "sender_full_name": "Mirek OlÅ¡Ã¡k",
        "timestamp": 1765498153
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek OlÅ¡Ã¡k</span> <a href=\"#narrow/channel/113488-general/topic/How.20often.20is.20equality.20of.20types.20used.20in.20Mathlib.3F/near/563302366\">said</a>:</p>\n<blockquote>\n<p>for example you could take a natural number <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>, and return the smallest <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Î±</mi></mrow><annotation encoding=\"application/x-tex\">\\alpha</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">Î±</span></span></span></span> such that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>V</mi><mi>Î±</mi></msub></mrow><annotation encoding=\"application/x-tex\">V_{\\alpha}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">Î±</span></span></span></span></span><span class=\"vlist-s\">â€‹</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> is a partial model of ZFC satisfying the first <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> instances of replacement...</p>\n</blockquote>\n<p>But this is a definable function in ZFC. It's just not provably total.</p>",
        "id": 563303232,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765498257
    },
    {
        "content": "<p>My guess is that seeing what the Zorn lemma constructed is a ZFC-definable, or at least ZFC-bounded function is nontrivial unless we actually understand deeply that it is building a successor. But at the same time, I would say it is not a priority for start.</p>",
        "id": 563303302,
        "sender_full_name": "Mirek OlÅ¡Ã¡k",
        "timestamp": 1765498293
    },
    {
        "content": "<p>For example, I was asking in the other thread if we could guarantee that functions are limited if we rectrict recursion, and disallow unique choice (I would still like to have a definite answer). But that Zorn's lemma thing uses choice to build the outcome...</p>",
        "id": 563303774,
        "sender_full_name": "Mirek OlÅ¡Ã¡k",
        "timestamp": 1765498507
    },
    {
        "content": "<p>Global choice is conservative over ZFC though.</p>",
        "id": 563303932,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765498574
    },
    {
        "content": "<p>(Depending on how you formalize it precisely.)</p>",
        "id": 563303969,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765498589
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"904624\">James E Hanson</span> <a href=\"#narrow/channel/113488-general/topic/How.20often.20is.20equality.20of.20types.20used.20in.20Mathlib.3F/near/563302438\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> Do you have a script that can list the definitions of inductive types that are actually used in a theorem? I think I saw something like that in <code>ZFCWithoutInductives.lean</code>.</p>\n</blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/blob/945082d8fc6abb2fb927bc80cce35c44902d442c/Counterexamples/ZFCWithoutInductives.lean#L1192-L1222\">https://github.com/leanprover-community/mathlib4/blob/945082d8fc6abb2fb927bc80cce35c44902d442c/Counterexamples/ZFCWithoutInductives.lean#L1192-L1222</a></p>",
        "id": 563304127,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765498652
    },
    {
        "content": "<p>I mean unique choice, which is a concept that ZFC is not very familiar with -- that any function-like relation can be turned into a function (that can be then used for replacement). ZFC uses function-like relations for replacement directly, but Lean distinguishes functions and function-like relations.</p>",
        "id": 563304473,
        "sender_full_name": "Mirek OlÅ¡Ã¡k",
        "timestamp": 1765498819
    },
    {
        "content": "<p>I know what unique choice is.</p>",
        "id": 563304490,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765498827
    },
    {
        "content": "<p>I'm saying that the class Zorn argument can maybe be done with global choice.</p>",
        "id": 563304541,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765498851
    },
    {
        "content": "<p>Ah, you are answering a different question then, sorry.</p>",
        "id": 563304588,
        "sender_full_name": "Mirek OlÅ¡Ã¡k",
        "timestamp": 1765498875
    },
    {
        "content": "<p>That might be true actually that the Zorn lemma argument doesn't need unique choice...</p>",
        "id": 563304707,
        "sender_full_name": "Mirek OlÅ¡Ã¡k",
        "timestamp": 1765498943
    },
    {
        "content": "<p>I think it is not obvious from the argument itself that it is choosing something limited</p>",
        "id": 563304900,
        "sender_full_name": "Mirek OlÅ¡Ã¡k",
        "timestamp": 1765499046
    },
    {
        "content": "<p>Of course it is obvious in retrospect because the constructions shows that anything with a strictly larger size is bigger or equal than the successor. But it doesn't start with taking something limited, and building the successor below.</p>",
        "id": 563305130,
        "sender_full_name": "Mirek OlÅ¡Ã¡k",
        "timestamp": 1765499179
    },
    {
        "content": "<p>I just found out that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=cast#doc\">docs#cast</a> exists, and is used for equality of types, e.g.<br>\n<a href=\"https://github.com/leanprover-community/mathlib4/blob/9739946deb29b3252628071c8ed4072b1ddbfbfb/Mathlib/Topology/MetricSpace/Gluing.lean#L311-L312\">https://github.com/leanprover-community/mathlib4/blob/9739946deb29b3252628071c8ed4072b1ddbfbfb/Mathlib/Topology/MetricSpace/Gluing.lean#L311-L312</a></p>",
        "id": 563550359,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1765568963
    },
    {
        "content": "<p>I've realized that I should have asked a more specific question, which is 'how often is equality of types used where the two types in question aren't part of a single indexed family of types?'</p>\n<p>Casting in this kind of context sometimes seems unavoidable, but on the other extreme, the type <code>Nat = Rat</code> certainly never occurs in Mathlib.</p>",
        "id": 563632012,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765643343
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"904624\">James E Hanson</span> <a href=\"#narrow/channel/113488-general/topic/How.20often.20is.20equality.20of.20types.20used.20in.20Mathlib.3F/near/563632012\">said</a>:</p>\n<blockquote>\n<p>I've realized that I should have asked a more specific question, which is 'how often is equality of types used where the two types in question aren't part of a single indexed family of types?'</p>\n</blockquote>\n<p>I would hope something like \"only when both are <code>Prop</code>s or one is a free variable or...\", since otherwise you can't really do anything with it.</p>",
        "id": 563632791,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765644131
    }
]