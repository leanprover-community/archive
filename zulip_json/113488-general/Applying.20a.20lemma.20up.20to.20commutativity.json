[
    {
        "content": "<p>Hi all, I'm working on some proof automation, and I'd like a straightforward way to apply a lemma up to some commutativity laws. For example, in the example below I'd like to prove something about a proposition containing <code>3 = x</code> but I have a hypothesis talking about <code>x = 3</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"c1\">-- Fails</span>\n</code></pre></div>\n<p>If I was doing the proof manually, I'd use <code>conv</code> to drill into the goal and rewrite the equation with <code>Eq.comm</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">conv</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">comm</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">h1</span>\n</code></pre></div>\n<p>Is there a way to do this with automation? I'd like to have a tactic like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">apply_up_to</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">comm</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">h1</span>\n</code></pre></div>\n<p>that just tries to apply <code>Eq.comm</code> during unification.</p>",
        "id": 490893960,
        "sender_full_name": "Harry Goldstein",
        "timestamp": 1735230147
    },
    {
        "content": "<p>For you example, you can use <code>convert</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">example</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">convert</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">eq_comm</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 490897675,
        "sender_full_name": "Zhang Qinchuan",
        "timestamp": 1735232945
    },
    {
        "content": "<p>Or maybe <code>simpa [eq_comm]</code>, or <code>aesop</code>. But I'm not sure how any of these would work with your use case</p>",
        "id": 490901456,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1735235747
    },
    {
        "content": "<p>Oh interesting! I need to play around with <code>convert</code> a bit. The <code>using 2</code> is telling it to select the righthand side of the <code>∧</code> right? Ideally I don't want to have to specify what to rewrite at that level of granularity.</p>\n<p>I guess I oversimplified my example a bit, because as you mentioned <code>simpa [eq_comm]</code> does work for the toy example but not the more realistic version:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">conv</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">eq_comm</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">h</span>\n</code></pre></div>\n<p>I'm happy to use <code>aesop</code>, I just don't know how to tell it to do the rewriting under all of the constructors.</p>",
        "id": 490902636,
        "sender_full_name": "Harry Goldstein",
        "timestamp": 1735236531
    },
    {
        "content": "<p>In this example you are constructing data so you probably should not be using a tactic in the first place</p>",
        "id": 490907235,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1735239879
    },
    {
        "content": "<p>Hmm. I realize that I'm bending this automation a bit beyond what it's usually used for, but as far as I can tell there's no reason this couldn't work in principle. In a dependent type theory there isn't a huge gap between proofs and data, after all.</p>\n<p>I'm sure there's a way to formulate my question fully within <code>Prop</code> — plenty of proofs rely on applying lemmas up to some administrative rewriting, and it's natural to ask how to automate that kind of reasoning.</p>",
        "id": 490907919,
        "sender_full_name": "Harry Goldstein",
        "timestamp": 1735240401
    },
    {
        "content": "<p>Unless you're suggesting that there are better tools within Lean to automatically build up data alongside a proof about that data?</p>",
        "id": 490907995,
        "sender_full_name": "Harry Goldstein",
        "timestamp": 1735240448
    },
    {
        "content": "<p>It works fine in principle; but in practice, you never care what proof you found, but you almost always care about what data you produced. So using tactics makes it much easier to generate the \"wrong\" data by accident.</p>",
        "id": 490923200,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1735253047
    },
    {
        "content": "<p>Here you could use <code>:= Subtype.map id (by sorry) (h 2)</code>, where you can restrict your tactic use to where the sorry is</p>",
        "id": 490923263,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1735253109
    },
    {
        "content": "<p>In my use case, I really am just looking for any program that satisfies the specification. I’d be happy to share more details with you privately if you want (this is active research, so I don’t feel comfortable talking about all of the details publicly yet), but those details aren’t necessarily relevant to the original question</p>",
        "id": 490923991,
        "sender_full_name": "Harry Goldstein",
        "timestamp": 1735253767
    },
    {
        "content": "<p>If that's the case then indeed tactics are ok for you to use; but it's not the typical use case, so things will be less polished than usual</p>",
        "id": 490925195,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1735254888
    },
    {
        "content": "<p>Yes, totally understood. And I’m happy to write my own tactics if necessary. I was just asking to see if things are already implemented</p>",
        "id": 490927711,
        "sender_full_name": "Harry Goldstein",
        "timestamp": 1735257140
    },
    {
        "content": "<p>Using Mathlib you can use <code>simp_rw</code> if you don't care about what data you produce (<code>simp_rw [eq_comm]; apply h</code>). You can also use convert, like <code>convert h _ using 4; rw [eq_comm]</code></p>",
        "id": 490959666,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1735284626
    },
    {
        "content": "<p>Oh that seems useful too! Ok, I bet I can cook something up with a combination of <code>simp_rw</code> and <code>convert</code>. I still really want something that explicitly tries to use the rewrite lemma while applying the target hypothesis, but it seems like that might just not exist yet</p>",
        "id": 491007758,
        "sender_full_name": "Harry Goldstein",
        "timestamp": 1735316714
    }
]