[
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/113488-general/topic/Discussion.3A.20Formal.20Conjectures/near/521197987\">said</a>:</p>\n<blockquote>\n<p>If someone could write an automated tool to convert all these benchmarks into your proposed format, then perhaps we could agree as a community to shift all of them over to that style</p>\n</blockquote>\n<p>Here is a possible first step:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">TryThis</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Batteries</span><span class=\"bp\">.</span><span class=\"n\">Util</span><span class=\"bp\">.</span><span class=\"n\">ProofWanted</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">ToProofWanted</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Command</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">TryThis</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">appendToDecl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Syntax</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">orig</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Syntax</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">replaceM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Id</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">isIdent</span><span class=\"w\"> </span><span class=\"bp\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">orig</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">getId</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">parts</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">orig</span><span class=\"bp\">.</span><span class=\"n\">components</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">last</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">parts</span><span class=\"bp\">.</span><span class=\"n\">getLast?</span><span class=\"bp\">.</span><span class=\"n\">getD</span><span class=\"w\"> </span><span class=\"n\">default</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">newLast</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">str</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">anonymous</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">last</span><span class=\"bp\">.</span><span class=\"n\">toString</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">tail</span><span class=\"o\">)</span>\n\n<span class=\"w\">      </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mkIdentFrom</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">parts</span><span class=\"bp\">.</span><span class=\"n\">dropLast</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">foldr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">¬∑</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"bp\">¬∑</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">newLast</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">none</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">`#to_proof_wanted theorem thm ... := by sorry` converts a theorem to</span>\n<span class=\"sd\">* a definition `thm_statement` with the signature of `thm` as its type,</span>\n<span class=\"sd\">* a `proof_wanted thm : thm_statement` command.</span>\n\n<span class=\"sd\">It tries to make an effort at reproducing the local variables needed and at preserving</span>\n<span class=\"sd\">attributes of the original theorem.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"n\">tk</span><span class=\"o\">:</span><span class=\"s2\">\"#to_proof_wanted\"</span><span class=\"w\"> </span><span class=\"n\">ppLine</span><span class=\"w\"> </span><span class=\"n\">cmd</span><span class=\"o\">:</span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">elabCommand</span><span class=\"w\"> </span><span class=\"n\">cmd</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">cmd</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">decl</span><span class=\"o\">:</span><span class=\"n\">declModifiers</span><span class=\"w\"> </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">declId</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">s</span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">sVars</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TSyntaxArray</span><span class=\"w\"> </span><span class=\"ss\">``Parser.Term.bracketedBinder</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">raw</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">‚ü®¬∑‚ü©</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">defId</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"n\">appendToDecl</span><span class=\"w\"> </span><span class=\"n\">declId</span><span class=\"w\"> </span><span class=\"n\">declId</span><span class=\"bp\">.</span><span class=\"n\">raw</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">getId</span><span class=\"w\"> </span><span class=\"s2\">\"_statement\"</span><span class=\"bp\">‚ü©</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">toDef</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">defId</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">sVars</span><span class=\"bp\">*</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">t</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">toProofWanted</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span>\n<span class=\"w\">      </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">command</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">decl</span><span class=\"o\">:</span><span class=\"n\">declModifiers</span><span class=\"w\"> </span><span class=\"n\">proof_wanted</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">declId</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"bp\">‚ü®</span><span class=\"n\">defId</span><span class=\"bp\">.</span><span class=\"n\">raw</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">‚ü©</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">fmtDef</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Syntax</span><span class=\"bp\">.</span><span class=\"n\">prettyPrint</span><span class=\"w\"> </span><span class=\"n\">toDef</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">proofWanted</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Syntax</span><span class=\"bp\">.</span><span class=\"n\">prettyPrint</span><span class=\"w\"> </span><span class=\"n\">toProofWanted</span>\n<span class=\"w\">    </span><span class=\"n\">liftTermElabM</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"n\">addSuggestion</span><span class=\"w\"> </span><span class=\"n\">tk</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span>\n<span class=\"w\">      </span><span class=\"n\">s!</span><span class=\"s2\">\"{fmtDef.pretty.trim}</span><span class=\"se\">\\n\\n</span><span class=\"s2\">{proofWanted.pretty.trim}</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span><span class=\"bp\">.</span><span class=\"n\">replace</span><span class=\"w\"> </span><span class=\"s2\">\"  \"</span><span class=\"w\"> </span><span class=\"s2\">\" \"</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">logWarning</span><span class=\"w\"> </span><span class=\"s2\">\"Not found!\"</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">ToProofWanted</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">info: Try this: def A.B.C.D_statement : Prop := ‚àÄ {k : Nat} (hk : 1 ‚â§ k) , True</span>\n\n<span class=\"sd\">@[simp]</span>\n<span class=\"sd\"> proof_wanted A.B.C.D : A.B.C.D_statement</span>\n<span class=\"sd\">---</span>\n<span class=\"sd\">warning: declaration uses 'sorry'</span>\n<span class=\"sd\">-/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"bp\">#</span><span class=\"n\">to_proof_wanted</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">B</span><span class=\"bp\">.</span><span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hk</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 521294900,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1748610791
    },
    {
        "content": "<p>If you want to test <code>#to_proof_wanted</code> on a few declarations and seeing how it performs and what it does wrong, it can certainly be improved.  Once you think that it works well, the replacement can be automated.</p>",
        "id": 521295075,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1748610846
    },
    {
        "content": "<p>(By the way, I know that the formatting is not ideal, but it is what the pretty-printer gives.  Rather than optimising the formatting right now, I would like to get the syntax to at least parse correctly, before fixing line breaks and whitespace.)</p>",
        "id": 521295623,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1748611056
    },
    {
        "content": "<p>Arguably that should produce <code>def A.B.C.D_statement : Prop := ‚àÄ {k : Nat} (hk : 1 ‚â§ k), True</code></p>",
        "id": 521295764,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1748611102
    },
    {
        "content": "<p>Eric, I edited the command above: is this what you had in mind?</p>",
        "id": 521298477,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1748612011
    },
    {
        "content": "<p>5 messages were moved here from <a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/channel/113488-general/topic/Discussion.3A.20Formal.20Conjectures/with/520936310\">#general &gt; Discussion: Formal Conjectures</a> by <span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span>.</p>",
        "id": 521299126,
        "sender_full_name": "Notification Bot",
        "timestamp": 1748612193
    },
    {
        "content": "<p>The <code>variable</code> line is now unused, right?</p>",
        "id": 521299187,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1748612207
    },
    {
        "content": "<p>Ah, right!  Let me exclude it!</p>\n<p>EDIT: The version above now does not include <code>variable</code>s.</p>",
        "id": 521299261,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1748612224
    },
    {
        "content": "<p>As for the formatting, it was quicker to outsource to the pretty-printed syntax, but a better solution would likely be to recycle as much as possible the original syntax, by extracting the relevant substrings.  I can deal with that later, once everything else is fixed.</p>",
        "id": 521299994,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1748612475
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/channel/113488-general/topic/Benchmark.20formats/near/521295623\">schrieb</a>:</p>\n<blockquote>\n<p>(By the way, I know that the formatting is not ideal, but it is what the pretty-printer gives.  Rather than optimising the formatting right now, I would like to get the syntax to at least parse correctly, before fixing line breaks and whitespace.)</p>\n</blockquote>\n<p>You should almost certainly use <code>PrettyPrinter.ppCommand toDef</code> instead. <code>Syntax.prettyPrint</code> doesn't \"pretty-print\" in the usual sense but rather basically copy the source text.</p>",
        "id": 521336556,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1748624188
    },
    {
        "content": "<p>None of the pretty-printers work as well as recycling the user-typed syntax, to be honest, this is why I did not try hard to make it work.  I'll play around with substrings, once all the actual bugs have been ironed out!</p>",
        "id": 521336853,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1748624310
    },
    {
        "content": "<p><code>proof_wanted</code> currently doesn't play well with <code>variable</code> and the <code>unusedSectionVars</code> linter. For example</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">FieldTheory</span><span class=\"bp\">.</span><span class=\"n\">IsAlgClosed</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">F'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">F'</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">F'</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">IsAlgebraic</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsAlgClosed</span><span class=\"w\"> </span><span class=\"n\">F'</span><span class=\"o\">]</span>\n\n<span class=\"n\">proof_wanted</span><span class=\"w\"> </span><span class=\"n\">nonempty_algEquiv_or_of_finrank_algClosure_eq_two</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">finrank</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">F'</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">‚âÉ‚Çê</span><span class=\"o\">[</span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚à®</span><span class=\"w\"> </span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">‚âÉ‚Çê</span><span class=\"o\">[</span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">F'</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Should we <code>set_option linter.unusedSectionVars false</code> automatically for <code>proof_wanted</code>?</p>",
        "id": 521448936,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1748703054
    },
    {
        "content": "<p>In comparison, <code>sorry</code> works well and I don't know what mechanism prevents triggering the linter in the following (<code>[Algebra.IsAlgebraic F E] [IsAlgClosed F']</code> are unused but still included in the signature of the sorried theorem):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">FieldTheory</span><span class=\"bp\">.</span><span class=\"n\">IsAlgClosed</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">F'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">F'</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">F'</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">IsAlgebraic</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsAlgClosed</span><span class=\"w\"> </span><span class=\"n\">F'</span><span class=\"o\">]</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">nonempty_algEquiv_or_of_finrank_algClosure_eq_two</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">finrank</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">F'</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">‚âÉ‚Çê</span><span class=\"o\">[</span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚à®</span><span class=\"w\"> </span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">‚âÉ‚Çê</span><span class=\"o\">[</span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">F'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 521449103,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1748703181
    },
    {
        "content": "<p>One thing I care a lot about with AI benchmarks (but it is also important for other things like blueprints, homework, and proofs-for-hire) is being able to:</p>\n<ul>\n<li>clearly state a theorem to be proved</li>\n<li>check that the theorem is really proved</li>\n</ul>",
        "id": 521456891,
        "sender_full_name": "Jason Rute",
        "timestamp": 1748709137
    },
    {
        "content": "<p>Surprisingly, this is much harder to get right in Lean than one realizes.  While Lean has good tools to check a theorem and proof that make it into the environment, it doesn't have good ways to check that:</p>\n<ul>\n<li>a theorem/proof made it to the environment</li>\n<li>it is the same statement as in the original benchmark (or blueprint, homework assignment, etc)</li>\n</ul>",
        "id": 521456896,
        "sender_full_name": "Jason Rute",
        "timestamp": 1748709144
    },
    {
        "content": "<p>It is well known that Lean can drop theorems due to bugs, and sometimes it does this silently.  Also, it isn't hard to change the (term level) statement of a theorem with things like local type class instances, or turn off kernel proof checking with a user option.  If we are serious about AI generating (possible many files worth) of Lean proofs, we need to be able to check for correctness well.</p>",
        "id": 521456900,
        "sender_full_name": "Jason Rute",
        "timestamp": 1748709150
    },
    {
        "content": "<p>I've talked about this in a few places already, notably <a class=\"stream-topic\" data-stream-id=\"270676\" href=\"/#narrow/channel/270676-lean4/topic/A.20better.20Lean.20checker/with/516560099\">#lean4 &gt; A better Lean checker</a>. In short, <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> made a good point that we need to come up with a standard workflow, and after that, we can make checking tools (and add them to standard tools like Lean4Lean or lean4checker).  There already is a pretty good existing tool in <span class=\"user-mention\" data-user-id=\"776090\">@GasStationManager</span>'s <a href=\"https://github.com/GasStationManager/SafeVerify\">https://github.com/GasStationManager/SafeVerify</a>. (<span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> looked over the code and thought it was pretty robust since it uses environment replay similar to Lean4Checker.) Currently, SafeVerify works with <code>sorry</code>s if I recall.  A relevant question for this thread is if it could be extended to <code>proof_wanted</code>.</p>",
        "id": 521456916,
        "sender_full_name": "Jason Rute",
        "timestamp": 1748709164
    },
    {
        "content": "<p>Some related questions are if the SorryDB project (by <span class=\"user-mention\" data-user-id=\"479731\">@Lenny Taelman</span>) can work with <code>proof_wanted</code>, and if Lean blueprint's can work with <code>proof_wanted</code>.  Overall, it would be great to have a standard here.  I think the defacto standard is using <code>sorry</code>, but it has rough edges as this thread motivates.</p>",
        "id": 521456921,
        "sender_full_name": "Jason Rute",
        "timestamp": 1748709167
    },
    {
        "content": "<p>I'd be happy to look into extending SafeVerify to <code>proof_wanted</code>, if there is community effort in maintaining <code>proof_wanted</code> based benchmarks... or if someone wants to get the ball rolling by contributing to the <a href=\"https://github.com/GasStationManager/SafeVerify\">repo</a>, I'm happy to collaborate :)</p>",
        "id": 521485337,
        "sender_full_name": "GasStationManager",
        "timestamp": 1748734967
    },
    {
        "content": "<p>On the topic of benchmark formats, if we move towards <code>proof_wanted</code>, I would really like to see a variant of it for function implementations, call it <code>def_wanted</code> or <code>impl_wanted</code>, where the problem solver needs to provide the body of a <code>def</code>, satisfying type requirements. (The proof obligation can be packaged into the type requirement, eg. as subtype). This will also be suitable for mathematical problem-solving benchmarks like PutnamBench where an answer needs to be provided together with the proof.</p>",
        "id": 521592241,
        "sender_full_name": "GasStationManager",
        "timestamp": 1748806299
    },
    {
        "content": "<p>As a silly example, suppose we want a function <code>f (x:Nat) : Nat</code>, with precondition <code>Odd x</code>, and postcondition <code>Even (f x)</code>. One way to formalize this would be<br>\n<code>def f' (x:Nat) (precond: Odd x) : {y:Nat // Even y} :=sorry</code> <br>\nIf we don't want the sorry, could we have <br>\n<code>impl_wanted f' (x:Nat) (precond: Odd x) : {y:Nat // Even y}</code></p>",
        "id": 521592872,
        "sender_full_name": "GasStationManager",
        "timestamp": 1748806676
    },
    {
        "content": "<p>I don't know whether to post this comment here or <a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/channel/113488-general/topic/Discussion.3A.20Formal.20Conjectures/with/520936310\">#general &gt; Discussion: Formal Conjectures</a>, but what I imagine with benchmarks like the formal conjecture one (and honestly with poorly formalized benchmarks like most of the ones out there <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span> ) it would also be usefully to easily prove other results about target \"theorems\":</p>\n<ol>\n<li>A conjecture is false</li>\n<li>A conjecture follows from another conjecture (or implies another conjecture)</li>\n<li>A hypothesis are not vacuous (often a helpful check that something is formalized correctly)</li>\n</ol>\n<p>(1) and (2) could be easily accomplished by <span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span>'s proposal to use <code>def MyConjecture_statement := ...</code> or using <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>'s trick <code>typeof% MyConjecture</code>. Also, many of the conjectures in of Formal Conjectures project are of the form <code>... &lt;-&gt; answer(sorry)</code>, which I think is supposed to make it easy to do (1), but I'm less certain if that is as useful as it seems.  And, of course, one could manipulate the conjecture expression itself, at either the text level (by hand, by code, or using an LLM) or at the metaprogramming/expression level.  Are there already good automated tools for this last approach?</p>",
        "id": 521601546,
        "sender_full_name": "Jason Rute",
        "timestamp": 1748812201
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"115715\">Jason Rute</span> <a href=\"#narrow/channel/113488-general/topic/Benchmark.20formats/near/521456921\">said</a>:</p>\n<blockquote>\n<p>Some related questions are if the SorryDB project (by <span class=\"user-mention silent\" data-user-id=\"479731\">Lenny Taelman</span>) can work with <code>proof_wanted</code>, and if Lean blueprint's can work with <code>proof_wanted</code>.  Overall, it would be great to have a standard here.  I think the defacto standard is using <code>sorry</code>, but it has rough edges as this thread motivates.</p>\n</blockquote>\n<p>Since we don't write our own benchmark, but just index statements (small or large) whose proof has been postponed (for a brief or longer time), the SorryDB project is completely dependent on what practitioners use in their formalisation projects. It also means that it will never be 100% fail-proof. However, we design this to be a centrally run competition, so that <em>we</em> can control the narrative and if necessary we can retroactively invalidate proofs.</p>",
        "id": 521676581,
        "sender_full_name": "Lenny Taelman",
        "timestamp": 1748851838
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"479731\">@Lenny Taelman</span> does your benchmark already index proof_wanted statements?</p>",
        "id": 521713674,
        "sender_full_name": "Jason Rute",
        "timestamp": 1748861983
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"115715\">Jason Rute</span> <a href=\"#narrow/channel/113488-general/topic/Benchmark.20formats/near/521713674\">said</a>:</p>\n<blockquote>\n<p>@Lenny Taelman¬†does your benchmark already index proof_wanted statements?</p>\n</blockquote>\n<p>At the moment it does not. I did a small experiment a while back and noted that the number of hits was essentially zero. It could certainly be added, and it would in some sense be easier since if I understand things correctly Lean already verifies that the type of a proof_wanted declaration is already Prop-valued (whereas with sorries we need to do some work to infer the type and index only the ones that are Prop-valued).</p>",
        "id": 521747303,
        "sender_full_name": "Lenny Taelman",
        "timestamp": 1748870959
    },
    {
        "content": "<p>I am tiring of the ever-growing output of compiling FLT just being pages and pages of warnings about sorries, and I don't see any appetite from the FRO to add a \"ignore sorries when compiling\" switch to lake, so I am currently strongly considering moving away from <code>sorry</code> and was thinking about switching to <code>proof_wanted</code> but I've not done anything about this yet because I have Big Proof to worry about next week.</p>",
        "id": 522066659,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1748941859
    },
    {
        "content": "<p>you can always use <code>axiom mySorry {p} : p</code> instead</p>",
        "id": 522066771,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1748941899
    },
    {
        "content": "<p>proof_wanted is not an adequate replacement most likely; it doesn't actually add the theorem to the environment so you can't refer to it in subsequent theorems and definitions</p>",
        "id": 522067056,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1748941971
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/113488-general/topic/Benchmark.20formats/near/522066771\">said</a>:</p>\n<blockquote>\n<p>you can always use <code>axiom mySorry {p} : p</code> instead</p>\n</blockquote>\n<p>Yes. The reason I mention it here is that it will break Lenny's system whatever I use if I switch from <code>sorry</code>, but the pages of output from lake are pushing me that way.</p>",
        "id": 522069342,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1748942584
    },
    {
        "content": "<p>Actually <span class=\"user-mention\" data-user-id=\"479731\">@Lenny Taelman</span> does <a href=\"#narrow/channel/270676-lean4/topic/Silent.20sorry/near/503539681\">this suggestion</a> break your SorryDB?</p>",
        "id": 522072772,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1748943495
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113488-general/topic/Benchmark.20formats/near/522072772\">said</a>:</p>\n<blockquote>\n<p>Actually <span class=\"user-mention silent\" data-user-id=\"479731\">Lenny Taelman</span> does <a href=\"#narrow/channel/270676-lean4/topic/Silent.20sorry/near/503539681\">this suggestion</a> break your SorryDB?</p>\n</blockquote>\n<p>Yes using a custom sorry axiom would break SorryDB, so I'd hope for some way to suppress sorry warnings instead!</p>\n<p>More generally this is a weakness of the SorryDB idea: we rely on  formalization projects tagging their \"postponed\" proofs in a constant way (both in time and between projects). So far this has been largely the case, but this may of course break down at some point...</p>",
        "id": 522088282,
        "sender_full_name": "Lenny Taelman",
        "timestamp": 1748947972
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113488-general/topic/Benchmark.20formats/near/522066659\">said</a>:</p>\n<blockquote>\n<p>don't see any appetite from the FRO to add a \"ignore sorries when compiling\" switch to lake</p>\n</blockquote>\n<p>Now I'm curious: Is this a statement about appetite to <em>implementing</em> such a thing, or appetite to accepting a third-party PR which implements it?</p>",
        "id": 522088572,
        "sender_full_name": "Lenny Taelman",
        "timestamp": 1748948061
    },
    {
        "content": "<p>see <a class=\"message-link\" href=\"/#narrow/channel/270676-lean4/topic/Silent.20sorry/near/522088264\">#lean4 &gt; Silent sorry @ üí¨</a> :)</p>",
        "id": 522088636,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1748948089
    },
    {
        "content": "<p>I specifically mentioned in <a href=\"https://github.com/leanprover/lean4/pull/8611\">lean4#8611</a> that it would be good if the community had a standard for saying \"I'm not going to prove this theorem\" (as opposed to the obvious potential proliferation with the multiple solutions suggested in the linked thread)</p>",
        "id": 522150761,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1748963353
    },
    {
        "content": "<p>IIRC formal abstracts had a more refined characterization of unproved claims. I can think of at least the following categories:</p>\n<ul>\n<li>I plan to get around to this later</li>\n<li>I'm not planning on proving this but I think it's true and I welcome someone else doing it for me</li>\n<li>This is technically false but assumed for pragmatic reasons</li>\n<li>This is in the literature somewhere</li>\n<li>This is in the literature here -&gt; [...]</li>\n<li>This is an open problem</li>\n</ul>",
        "id": 522151543,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1748963551
    },
    {
        "content": "<p>FLT has all of these and they're all <code>sorry -- FLT#xyz</code></p>",
        "id": 522214096,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1748984358
    },
    {
        "content": "<p>To add to Mario‚Äôs list, two more common types of sorries are:</p>\n<ul>\n<li>this is an exercise (e.g. in a tutorial or homework assignment)</li>\n<li>this is an AI benchmark theorem</li>\n<li>this is a definition value that needs to be filled in to complete a theorem as part of a benchmark (or homework)</li>\n</ul>",
        "id": 522246590,
        "sender_full_name": "Jason Rute",
        "timestamp": 1749001394
    }
]