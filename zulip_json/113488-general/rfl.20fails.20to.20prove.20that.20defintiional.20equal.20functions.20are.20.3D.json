[
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Qq</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Tactic</span><span class=\"w\"> </span><span class=\"n\">Qq</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">const_equivalent</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xn</span><span class=\"w\"> </span><span class=\"n\">yn</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">isDefEq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getConstInfo</span><span class=\"w\"> </span><span class=\"n\">xn</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">value!</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getConstInfo</span><span class=\"w\"> </span><span class=\"n\">yn</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">value!</span>\n\n<span class=\"c1\">-- Example usage</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Nat1</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat1</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Nat1</span><span class=\"bp\">.</span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat1</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat1</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat1</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">y</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Nat1</span><span class=\"bp\">.</span><span class=\"n\">add'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat1</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat1</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat1</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">y</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">add'</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat1</span><span class=\"bp\">.</span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Nat1</span><span class=\"bp\">.</span><span class=\"n\">add'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">run_tac</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mvarId</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getMainGoal</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">womp</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mvarId</span><span class=\"bp\">.</span><span class=\"n\">getType</span>\n\n<span class=\"w\">    </span><span class=\"c1\">-- -- Cast to Q(Prop) instead of Sort u</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getMainGoal</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">getType</span>\n\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">~</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Eq</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"s2\">\"{← isDefEq x y}\"</span>\n<span class=\"w\">      </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">constName?</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">constName?</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">xn</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">yn</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">        </span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"s2\">\"Found equality {xn} {yn}\"</span>\n<span class=\"w\">        </span><span class=\"n\">evalTactic</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">))</span>\n<span class=\"w\">        </span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"s2\">\"{(← getConstInfo xn).value!}</span><span class=\"se\">\\n\\n</span><span class=\"s2\">{(← getConstInfo yn).value!}\"</span>\n<span class=\"w\">        </span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"s2\">\"are strucutrually identitical: {← const_equivalent xn yn}\"</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"s2\">\"not equality between function symbols\"</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"s2\">\"Not an equality\"</span>\n<span class=\"w\">  </span><span class=\"c1\">-- are strucutrually identitical: true</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"c1\">-- however rfl fails</span>\n</code></pre></div>",
        "id": 568292240,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1768504125
    },
    {
        "content": "<p>You can use <code>rfl'</code> (with a \"prime\" tick) which is more aggressive in reduction. I think this is a consequence of the \"smart unfolding\" used by <code>rfl</code> but not <code>rfl'</code>.</p>",
        "id": 568299251,
        "sender_full_name": "Chris Bailey",
        "timestamp": 1768506658
    },
    {
        "content": "<p>I would do a proof by induction:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat1</span><span class=\"bp\">.</span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Nat1</span><span class=\"bp\">.</span><span class=\"n\">add'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">ext</span>\n<span class=\"w\">  </span><span class=\"n\">fun_induction</span><span class=\"w\"> </span><span class=\"n\">Nat1</span><span class=\"bp\">.</span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nat1</span><span class=\"bp\">.</span><span class=\"n\">add'</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 568329590,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1768519726
    },
    {
        "content": "<p>When you define a function using pattern matching, the elaborator does a lot under the hood (I'm not sure about the details). You shouldn't assume that 2 pattern-matching definitions that look the same are <code>rfl</code>.</p>",
        "id": 568338350,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1768524784
    },
    {
        "content": "<p>they're definitionally equal under<code>isDefEq</code>tho</p>",
        "id": 568342151,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1768527857
    },
    {
        "content": "<p><code>isDefEq</code> printed <code>false</code>.</p>",
        "id": 568344835,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768529304
    },
    {
        "content": "<p>This works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Nat1</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat1</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Nat1</span><span class=\"bp\">.</span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat1</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat1</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat1</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">y</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Nat1</span><span class=\"bp\">.</span><span class=\"n\">add'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat1</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat1</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat1</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">y</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">add'</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat1</span><span class=\"bp\">.</span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Nat1</span><span class=\"bp\">.</span><span class=\"n\">add'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">delta</span><span class=\"w\"> </span><span class=\"n\">Nat1</span><span class=\"bp\">.</span><span class=\"n\">add</span>\n<span class=\"w\">  </span><span class=\"n\">delta</span><span class=\"w\"> </span><span class=\"n\">Nat1</span><span class=\"bp\">.</span><span class=\"n\">add'</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 568344963,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768529379
    },
    {
        "content": "<p>Basically, <code>rfl</code> can't really prove equality of recursive definitions. You would have to do induction for this.<br>\n<code>delta</code> (which is equivalent to <code>(← getConstInfo xn).value!</code> you did), makes the definition non-recursive, by using Nat1.brenOn directly. Unlike unfolding which \"unfolds\" one level of recursion. I don't know, but suspect, that <code>rfl</code> uses this smart unfolding instead of direct delta-expansion. And <code>rfl'</code> works, because it uses delta-expansion directly.</p>",
        "id": 568345507,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768529853
    },
    {
        "content": "<p>I suspect if you turn off smart unfolding then <code>rfl</code> works</p>",
        "id": 568408899,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1768561612
    },
    {
        "content": "<p>Indeed, this works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">smartUnfolding</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat1</span><span class=\"bp\">.</span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Nat1</span><span class=\"bp\">.</span><span class=\"n\">add'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>But I think this case is one of the reason why <code>rfl'</code> exists. It disables smart unfolding.</p>",
        "id": 568409069,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768561662
    },
    {
        "content": "<p>what is smart unfolding? does it guard against certain definitional expansions?</p>",
        "id": 568535776,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1768603297
    },
    {
        "content": "<p>When Lean tests 2 expressions for defeq, it has to unfold some definitions. There are 2 algorithms, the newer one is called \"smart\".</p>",
        "id": 568537120,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1768604309
    },
    {
        "content": "<p>(AFAIK)</p>",
        "id": 568537126,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1768604314
    },
    {
        "content": "<p>The difference between normal unfolding and smart unfolding is that smart unfolding will unfold the definition and the match in one go. So it will unfold <code>Nat1.add</code> if it is applied to either <code>0</code> or <code>Nat1.succ _</code>. It couldn't do this in your example, hency why it didn't work.</p>",
        "id": 568537274,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1768604428
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/channel/113488-general/topic/rfl.20fails.20to.20prove.20that.20defintiional.20equal.20functions.20are.20.3D/near/568537274\">said</a>:</p>\n<blockquote>\n<p>So it will unfold <code>Nat1.add</code> if it is applied to either <code>0</code> or <code>Nat1.succ _</code>. It couldn't do this in your example, hency why it didn't work.</p>\n</blockquote>\n<p>I don't think you're right. This works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Nat1</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat1</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Nat1</span><span class=\"bp\">.</span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat1</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat1</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat1</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">y</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"n\">y</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Nat1</span><span class=\"bp\">.</span><span class=\"n\">add'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat1</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat1</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat1</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">y</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat1</span><span class=\"bp\">.</span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Nat1</span><span class=\"bp\">.</span><span class=\"n\">add'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 568562620,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768629224
    },
    {
        "content": "<p>Description for option <code>smartUnfolding</code> says \"when computing weak head normal form, use auxiliary definition created for functions defined by structural recursion\". So I think the main point of smart unfolding is the way recursive definitions are handled.</p>",
        "id": 568562729,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768629353
    },
    {
        "content": "<p>Ah, no, I think you're right. \"smart unfolding\" is about reducing match expressions.</p>",
        "id": 568563641,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768630081
    },
    {
        "content": "<p>Hm, reading the code it looks like turning off smartUnfolding makes <code>rfl</code> use <code>deltaBetaDefinition</code> which I suspect is similar to what <code>delta</code> tactic does. And with smartUnfolding on it rewrites definition to <code>Nat1.add._sunfold</code>, which is similar to what <code>unfold</code> does plus the behaviour of \"shortcutting\" match expressions.</p>\n<p>Because of this I think that turning smartUnfolding off does more than it should? It not only turns off smartUnfolding but also turns off the unfolding behaviour.</p>\n<p>Should we report this as a bug? I'm not sure if it's a bug, because I'm not sure whether smartUnfolding refers only to the behaviour of \"shortcutting\" match expressions, or more generally to unfolding via <code>.eq_def</code>?</p>",
        "id": 568564676,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768631090
    },
    {
        "content": "<p>As Jovan says, smart unfolding will unfold the definition and matches in one step, if it can, and not at all otherwise. The point is that if it could unfold the definition, but not that match, for a structurally recursive function, you'd end up seeing some gory mess involving <code>.brecOn</code>, which as a user you usually don't want to.</p>\n<p>In your case it seems that by exposing the <code>.brecOn</code> implementation on both sides, the equality can be shown.</p>\n<p>Note that for structurally recursive functions, the <code>.eq_def</code> is <em>not</em> a definitional equality, but the rewrites that then also reduce the matche are.</p>",
        "id": 568570218,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1768637350
    },
    {
        "content": "<p>Maybe I don't understand what smart unfolding is supposed to do exactly? My understanding is that rewriting <code>Nat1.add .zero y</code> with <code>(match .zero, y with | Nat1.zero, y =&gt; y | x.succ, y =&gt; (x.add y).succ)</code> is normal unfolding.<br>\nAnd smart unfolding is rewriting <code>Nat1.add .zero y</code> with <code>y</code>.</p>",
        "id": 568573304,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768641156
    },
    {
        "content": "<p>Right, but the former equality is not an definitional equality, so not usable by <code>rfl</code></p>",
        "id": 568586228,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1768655512
    },
    {
        "content": "<p>You can <code>delta Nat1</code> to see what it would really unfold to without smart unfolding</p>",
        "id": 568586240,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1768655523
    }
]