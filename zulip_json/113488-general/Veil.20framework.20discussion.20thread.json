[
    {
        "content": "<p>Discussion thread for <a href=\"https://github.com/verse-lab/veil\">Veil</a>. See the announcement at <a class=\"stream-topic\" data-stream-id=\"113486\" href=\"/#narrow/channel/113486-announce/topic/Veil.3A.20A.20Framework.20for.20Automated.20and.20Interactive.20Verification/with/512112796\">#announce &gt; Veil: A Framework for Automated and Interactive Verification</a></p>",
        "id": 512113011,
        "sender_full_name": "George Pîrlea",
        "timestamp": 1744645179
    },
    {
        "content": "<p>Why is proof reconstruction turned off by default?</p>",
        "id": 512117661,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1744646485
    },
    {
        "content": "<p>More specifically, how is the SMT's output checked when there is no proof reconstruction?</p>",
        "id": 512118750,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1744646754
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"466334\">@Shreyas Srinivas</span> When proof reconstruction is off, the SMT solver's output is simply trusted rather than checked. This is similar to existing non-foundational verifiers. We keep it off by default since it's quite slow (&gt;5x slowdown) and currently a bit brittle for the goals we generate (we'll report this upstream to <code>lean-smt</code>). We're hoping to be able to change this default in the future, though.</p>",
        "id": 512120135,
        "sender_full_name": "George Pîrlea",
        "timestamp": 1744647087
    },
    {
        "content": "<p>okay, so the TCB is Lean's kernel  + SMT solver (z3/cvc5?)</p>",
        "id": 512120559,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1744647190
    },
    {
        "content": "<p>Yes. We use CVC5 by default and fall back to Z3 when the former times out. (This is configurable using <a href=\"https://github.com/verse-lab/veil/blob/main/Veil/Base.lean#L98\"><code>set_option veil.smt.solver</code></a> and <a href=\"https://github.com/verse-lab/veil/blob/main/Veil/Base.lean#L108\"><code>veil.smt.retryOnUnknown</code></a>)</p>",
        "id": 512121467,
        "sender_full_name": "George Pîrlea",
        "timestamp": 1744647438
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"756459\">@Sasha Rubin</span>  and <span class=\"user-mention\" data-user-id=\"250372\">@Ashvni Narayanan</span>   you might be interested in this</p>",
        "id": 512121736,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1744647506
    },
    {
        "content": "<p>Related question : how well can SMT discharged goals (for want of a better word) mix with manually proved goals? I am asking this because being able to take SMT proofs at face value means that you don’t necessarily have a sorry free theorem for it from lean’s perspective.</p>",
        "id": 512135091,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1744651103
    },
    {
        "content": "<p>Turning on proof reconstruction should let you add theorem declarations with proofs to the environment and let you freely mix autoproved theorems with manually proved theorems.</p>",
        "id": 512135351,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1744651185
    },
    {
        "content": "<p>It's very easy to mix goals proven interactively and those proven with SMT. All goals that Veil generates are just standard Lean theorems that we add to the environment. For example, instead of using the <code>#check_invariants</code> command,  you can do <code>#check_invariants?</code> and see exactly what's being proven behind the scenes.</p>\n<p>If you really care about not trusting SMT solvers, you really should use Veil with proof reconstruction at all times, yes. But, again, as proof reconstruction improves in upstream projects, we're hoping to change the default.</p>",
        "id": 512183860,
        "sender_full_name": "George Pîrlea",
        "timestamp": 1744669183
    },
    {
        "content": "<p>I'd be curious to hear if you have specific projects you'd want to try Veil on where this is a major concern.</p>",
        "id": 512184158,
        "sender_full_name": "George Pîrlea",
        "timestamp": 1744669332
    },
    {
        "content": "<p>This isn’t about trust. If you generated a lean theorem but no proof, what are you actually assigning to this declaration?</p>",
        "id": 512184194,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1744669357
    },
    {
        "content": "<p>Is it an assumption that is added to the environment?</p>",
        "id": 512184243,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1744669391
    },
    {
        "content": "<p>Like adding a variable statement in a section?</p>",
        "id": 512184288,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1744669417
    },
    {
        "content": "<p>It's a <code>theorem</code> whose body is <code>by sorry</code>.</p>",
        "id": 512184383,
        "sender_full_name": "George Pîrlea",
        "timestamp": 1744669449
    },
    {
        "content": "<p>Ah, so a lean project using Veil won’t be sorry free</p>",
        "id": 512184447,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1744669483
    },
    {
        "content": "<p>The problem with this approach is that a large project would have a number of theorems, many auto generated by lean and some handwritten. When reviewing such a project it won’t be sufficient to look for occurrences of sorry by using #print_axioms or checking the output of lake build. One would have to manually check that the only <code>sorry</code>s are coming from the SMT generated proofs</p>",
        "id": 512184746,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1744669629
    },
    {
        "content": "<p>Also I think #print axioms will show sorryAx as one of the axioms but won’t be able to tell you whether the sorry is one of the <code>by sorry</code>s generated by Veil or a <code>sorry</code> inserted manually during the proof development and forgotten</p>",
        "id": 512185213,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1744669850
    },
    {
        "content": "<p>Ah, that's a good point. Thank you! We should introduce our own version of <code>sorry</code> such that it's easier to distinguish in <code>#print axioms</code>. (I think <code>lean-auto</code> does something like this.)</p>\n<p>But just to point it out, it's difficult to miss that Veil without proof reconstruction uses <code>sorry</code> — there are warnings printed during compilation similar to how Lean <code>sorry</code> works. For instance, <code>#check_invariants</code> in the <a href=\"https://github.com/verse-lab/veil/blob/main/Examples/Tutorial/Ring.lean\">tutorial</a> prints \"Trusting the SMT solver for 12 theorems.\"</p>",
        "id": 512185743,
        "sender_full_name": "George Pîrlea",
        "timestamp": 1744670139
    },
    {
        "content": "<p>Okay that’s a good sign. Nevertheless from a UX perspective sorry comes with some bells and whistles (for example yellow squiggly lines) and some output lines in the output of lake build. This makes no distinction between user inserted and automatically inserted sorries. As someone writing proofs, this will be a nightmare for me to make sure I haven’t left any forgotten sorries lying around</p>",
        "id": 512186064,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1744670335
    },
    {
        "content": "<p>A slightly better idea might be to replicate the axiom command, let’s call it <code>smt_assumption</code> and replicate <code>#print_axioms</code> for this, calling it <code>#print SMT assumptions</code></p>",
        "id": 512186616,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1744670656
    },
    {
        "content": "<p>The latter takes a theorem and prints out the smt_assumptions it uses</p>",
        "id": 512186670,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1744670687
    },
    {
        "content": "<p>Maybe I'm misunderstanding, but you still get all of this (the squiggly lines, etc.) with Veil. You always have to issue a command (e.g. <code>#check_invariants</code>) to generate and prove theorems — it doesn't do it \"behind your back\".  Here's what it looks like:</p>\n<p><a href=\"/user_uploads/3121/q5lu8eZK9B02Ml2BDhkDr-b2/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/q5lu8eZK9B02Ml2BDhkDr-b2/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"2430x862\" src=\"/user_uploads/thumbnail/3121/q5lu8eZK9B02Ml2BDhkDr-b2/image.png/840x560.webp\"></a></div>",
        "id": 512186672,
        "sender_full_name": "George Pîrlea",
        "timestamp": 1744670688
    },
    {
        "content": "<p>In a large proof development I don’t see how it will be easy to separate the use of smt theorems from user theorems containing sorries. I am thinking about this from a debugging perspective.</p>",
        "id": 512186920,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1744670842
    },
    {
        "content": "<p>In my suggestion about SMT_assumption, you could also just define an SMT_assumption attribute, tag all the generated theorems with this attribute. The <code>#print SMT assumptions &lt;theorem&gt;</code> command simply prints all uses of theorems with this attribute, in a manner similar to #print axioms</p>",
        "id": 512188696,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1744671911
    },
    {
        "content": "<p>That way, even if someone turns on proof reconstruction, one can track the uses of SMT proven theorems. only the <code>by sorry</code> part needs to be replaced by the proof as is happening now (I guess)</p>",
        "id": 512188893,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1744671992
    }
]