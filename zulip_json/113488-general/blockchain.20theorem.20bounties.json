[
    {
        "content": "<p>I’ve been working on a smart contract for theorem bounties. That is, if you want a theorem proven, you can stake money that someone could claim if they submit a correct proof. A very raw first version is starting to look ready. </p>\n<p>No worries if you haven’t messed around with blockchain much - I made a repo with instructions on how to interact with said smart contract without the pain of interacting with blockchain: <a href=\"https://github.com/wadimiusz/lean-contract-interact\">https://github.com/wadimiusz/lean-contract-interact</a> </p>\n<p>You need to be comfortable with Python, though.</p>\n<p>It’s play money for now; you don’t need to spend any real money, and there are no regulations / tax implications. </p>\n<p>(Getting the play money is an annoying part in the instructions; if none of the faucets work for you, ping me and i’ll help you.)</p>\n<p>Why am I doing this? Partly it’s just a cool thing to do, but also, I’m really curious if having theorem bounties could somehow improve the life of a Lean enthusiast (that is, when we switch from play money to real money). </p>\n<p>I don’t understand your workflow well enough, so I wanted to throw an early, naive version out as soon as possible, to hear if something like this could make your life easier in any way, and how it could be integrated into your workflow. Only then will I work on a nice interface - I need to understand what that would look like to be convenient for you.</p>\n<p>I expect that, if it does prove useful, the initial use case will be something like “frustrated Lean user doesn’t know how to prove this basic lemma; on the other end, a starving grad student is grateful to have the ten dollars”. In general, the hope is not just to incentivize Lean research, or align incentives, but to create better connectivity of knowledge  - to make a place where different researcher’s pieces of knowledge meet.</p>\n<p>How can you help? </p>\n<p>For one thing, please just mess around with it, try depositing theorem bounties, claiming bounties, submitting correct proofs, incorrect proofs, proofs with sorries, and then tell me if you could see any uses for it, and what they would be like.</p>\n<p>For another thing, we really need a better oracle. (Oracle is the offchain thing that checks if a proof is valid.) I’m a complete baby at Lean; I just wrote a very basic oracle that creates a file with </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">simple_theorem</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"kn\">theorem</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n\n<span class=\"o\">{</span><span class=\"n\">proof</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>and runs <code>lean theorem.lean</code> to check the exit code (and check for sorries). This probably has vulnerabilities, and only supports very simple proofs. One would want to pass more complex theorems, proofs, and entire projects. If we make something more complex, and we can make an API out of it, I can turn it into an oracle and integrate it into a smart contract.</p>\n<p>PS I deposited some bounties for the following theorems, just to get you started:</p>\n<p><code>(n : Nat) : n * 1 = n</code></p>\n<p><code>(P Q R : Prop) (h1 : P -&gt; Q) (h2 : Q -&gt; R) : P -&gt; R</code></p>\n<p><code>{α : Type} (l : List α) : l.reverse.reverse = l</code></p>\n<p><code>{α : Type} : (id ∘ id : α → α) = id\"}</code></p>\n<p><code>{α β : Type} {f g : α → β} : (∀ x, f x = g x) → f = g</code></p>",
        "id": 482741350,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1731736972
    },
    {
        "content": "<p>Please post a bounty for <code>False</code>, so that people can start pointing out the vulnerabilities in your checker. :-)</p>",
        "id": 482743541,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1731739274
    },
    {
        "content": "<p>If you check the recent \"Code with Proofs: the Arena\" thread you'll see some initial hints for doing this properly.</p>",
        "id": 482743664,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1731739419
    },
    {
        "content": "<p>bounty for <code>False</code> done :)</p>",
        "id": 482744674,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1731740434
    },
    {
        "content": "<p>I like the idea! So for now we have to trust a single machine/entity that runs the Lean oracle, right?</p>",
        "id": 482762858,
        "sender_full_name": "Jineon Baek",
        "timestamp": 1731757276
    },
    {
        "content": "<p>Yes. I really dislike this, since the whole point of blockchain is minimizing trust.</p>\n<p>The problem of trusting offchain data is not new. There are solutions for stuff like prices (like if your contract needs USD / ETH prices or whatever) - there is this thing called chainlink; it runs many nodes, and outputs and aggregated value, so that even if some nodes are malicious or unavailable, the aggregated value is still valid.<br>\nSo one idea would be for many Lean enthusiasts to run Lean nodes for checking proofs (for compensation), and the oracle would aggregate the nodes' outputs in a trustless way. But then the price of using the oracle increases because we need to compensate the node operators :(</p>\n<p>Or here's a completely unrealistic decision: we could try to port Lean into the Ethereum blockchain itself somehow. Languages like Solidity are just wrappers over low-level instructions; we could compile Lean for Ethereum Virtual Machine somehow; but this is a nightmare to get done and the cost would skyrocket.</p>\n<p>Maybe there is some way for me to verify for you all the code that runs in the oracle node?</p>",
        "id": 482763240,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1731757643
    },
    {
        "content": "<p>Alternatively we could build our own consensus mechanism built on Lean proofs :) There is an idea in the web3 community called \"proof of excellence\". For example, there is this \"primecoin\" which you mine by providing sequences of prime numbers. The idea is to make mining computation something useful, instead of useless thrashing like bitcoin. This idea is kind of abandoned, and primecoin is worth like two cents now. It would be cool to build our own blockchain where to mine it, you have to provide / validate lean proofs :D</p>",
        "id": 482763969,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1731758283
    },
    {
        "content": "<p>One possible approach is to compile a lean verifier in a SNARK system, so that you have an external verifier of the submitted lean code that generates a succint ZKP, and a (much lighter) verifier for that succint proof in the blockchain level.</p>",
        "id": 482766734,
        "sender_full_name": "Miguel Marco",
        "timestamp": 1731760761
    },
    {
        "content": "<p>Yeah, that sounds like a good idea!</p>",
        "id": 482766942,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1731760928
    },
    {
        "content": "<p>But is it realistic to compile a lean verifier in a SNARK system? is that something you folks have been up to?</p>",
        "id": 482767756,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1731761649
    },
    {
        "content": "<p>A verifier that checks a proof of bounded size, requiring a bounded number of steps, in principle should be doable in any universal SNARK system (another question is how big those bounds can be).</p>\n<p>The unbounded case, that's another story. My impression(without having thought much about it) is that it could be a fit for a composable SNARK system, where you can create proofs for each small step, and combine them recursively into a final proof.</p>",
        "id": 482768666,
        "sender_full_name": "Miguel Marco",
        "timestamp": 1731762454
    },
    {
        "content": "<p>It would be an interesting research project in any case.</p>",
        "id": 482768733,
        "sender_full_name": "Miguel Marco",
        "timestamp": 1731762497
    },
    {
        "content": "<p>I don't know anything about these things, but I believe there is some progress in these directions at <a href=\"https://github.com/argumentcomputer/yatima\">https://github.com/argumentcomputer/yatima</a></p>",
        "id": 482768789,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1731762576
    },
    {
        "content": "<p>Other prior work is zkPi <a href=\"https://eprint.iacr.org/2024/267\">https://eprint.iacr.org/2024/267</a></p>",
        "id": 482786654,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1731777117
    },
    {
        "content": "<p>Don't we have a wasm version of Lean? That could run on some of the wasm-based blockchains out there.</p>",
        "id": 482789368,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1731779512
    },
    {
        "content": "<p>Success!<br>\n<a href=\"https://sepolia.etherscan.io/tx/0x846b6b223e4809c4caf28b076f05b5621da212c95209bc2df97dd323efbeca66\">https://sepolia.etherscan.io/tx/0x846b6b223e4809c4caf28b076f05b5621da212c95209bc2df97dd323efbeca66</a></p>",
        "id": 482790545,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1731780557
    },
    {
        "content": "<p>A bit weird that etherscan says that the state of my balance didn't change <a href=\"https://sepolia.etherscan.io/tx/0x846b6b223e4809c4caf28b076f05b5621da212c95209bc2df97dd323efbeca66#statechange\">here</a>,  but you can definitely see I have 0.2 more testnet ETH than I had at the start of the transaction if you look <a href=\"https://sepolia.etherscan.io/address/0x78f0c4160f307c460c6a2f3d029e1a2b7cfdd392\">here</a>.</p>",
        "id": 482790771,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1731780747
    },
    {
        "content": "<p>(I did the <code>(P Q R : Prop) (h1 : P -&gt; Q) (h2 : Q -&gt; R) : P -&gt; R</code> bounty)</p>",
        "id": 482790791,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1731780775
    },
    {
        "content": "<p>Yay! I can see your proof. Thank you for testing the system!!</p>",
        "id": 482790941,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1731780936
    },
    {
        "content": "<p>The transaction you're looking at is the one where you called my contract's method, right? It's not the transaction that brings you the money. First you trigger the method, then it sends a request to the oracle, then the oracle triggers a <code>fulfill</code> function in the smart contract, and only then does the contract send you your play money :)</p>",
        "id": 482791038,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1731781000
    },
    {
        "content": "<p>The transaction that brought you money is <a href=\"https://sepolia.etherscan.io/tx/0x2e7a970100183a93fe3857d7704f24ac97dc66cb6a2ab471dd760f412b524d4d#statechange\">this</a></p>",
        "id": 482791079,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1731781044
    },
    {
        "content": "<p>Ah ok. I would still expect that transaction to show up somewhere on my page though.</p>",
        "id": 482791100,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1731781072
    },
    {
        "content": "<p>It's because it's listed in the \"internal transactions\" which is a separate tab. I'm not sure what it means anyway.</p>",
        "id": 482791159,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1731781100
    },
    {
        "content": "<p>If I were doing this for real, would I have to trust a sequencer not to front-run my transaction by replacing my account with theirs?</p>",
        "id": 482791267,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1731781202
    },
    {
        "content": "<p>Hmm, there probably is some way to steal your bounty requests... Like when you broadcast the transaction, someone could send the same transaction at the same time but with much more gas... Maybe when we graduate the system into mainnet, we would have to introduce some encryption somehow?</p>",
        "id": 482791622,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1731781524
    },
    {
        "content": "<p>Ok I have made a new bounty for <code>(n : Nat) : ∃ a b c d : Nat, a * a + b * b + c * c + d * d = n</code> <a href=\"https://sepolia.etherscan.io/tx/0xc60f76036e629b791e8a697242c393ded4b886253f6aca255859028ae547b8c0\">here</a></p>",
        "id": 482792031,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1731781904
    },
    {
        "content": "<p>Thank you for playing around with this!!<br>\nOne thing that's terribly missing now is a capacity for checking which theorems have bounties attached to them, so that anyone could see that <code>(n : Nat) : ∃ a b c d : Nat, a * a + b * b + c * c + d * d = n</code> has a price on its head. I'll get it done, but this should be part of the interface, not of the smart contract itself, I think (or people would have to pay gas fees for memory / storage). So I'll do this once I understand what interface lean folks prefer / how people would generally use this.</p>",
        "id": 482792382,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1731782232
    },
    {
        "content": "<p>The god-tier move would be to integrate it with the \"<a href=\"http://5.78.72.236:8000/\">Arena</a>\" project that was mentioned above (<a href=\"https://github.com/GasStationManager/CodeProofTheArena\">github</a>, <a href=\"#narrow/channel/113488-general/topic/Code.20with.20Proofs.3A.20the.20Arena\">thread</a>) so you can see bounties and claim them, all from a web interface.</p>",
        "id": 482793405,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1731783135
    },
    {
        "content": "<p>Not sure how hard that would be, I've never really heard of a framework for integrating python with a webpage.</p>",
        "id": 482793484,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1731783222
    },
    {
        "content": "<p>I already reached out to Arena's author <span class=\"user-mention\" data-user-id=\"776090\">@GasStationManager</span>  and we chatted about collaboration :) Hopefully we will at least collaborate on the verification part - that piece of technical challenge is straight-up identical in our projects - but it does feel like our projects have potential for interaction, at least, or maybe even unification. The visions between the projects are somewhat different (in the long run, Arena is intended for AI proving correctness of output code as an alignment thing, if I understood correctly; my fondest hope is to create better connectivity for knowledge in general), but we do play in the same sandbox, so to say.</p>",
        "id": 482793785,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1731783481
    },
    {
        "content": "<p>I don't think there would be any technical challenge with setting up a web page at all. If Metamask's integration is easy (so that people don't have to bother with prividing private keys etc. and they know that the private key is not sent anywhere), I could throw it together pretty quickly. I didn't do it to begin with because I wanted to understand how people want to interact with it, if there are any expectations, any points where this project would help with their work routine etc.</p>",
        "id": 482793890,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1731783578
    },
    {
        "content": "<p>(what does an octopus reaction mean)</p>",
        "id": 482794101,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1731783728
    },
    {
        "content": "<p>Octopus is for celebration</p>",
        "id": 482794131,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1731783778
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/fNik_weFr1Q_liXpoMzvnDyS/Screenshot-2024-11-16-at-11.03.07AM.png\">Screenshot 2024-11-16 at 11.03.07 AM.png</a><br>\nSee how happy it looks!</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/fNik_weFr1Q_liXpoMzvnDyS/Screenshot-2024-11-16-at-11.03.07AM.png\" title=\"Screenshot 2024-11-16 at 11.03.07 AM.png\"><img data-original-dimensions=\"136x64\" src=\"/user_uploads/thumbnail/3121/fNik_weFr1Q_liXpoMzvnDyS/Screenshot-2024-11-16-at-11.03.07AM.png/840x560.webp\"></a></div>",
        "id": 482794159,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1731783802
    },
    {
        "content": "<p>Anyways, this is totally sick, and if it had existed in May 2024 I would definitely have deployed it on mainnet and put some ETH on a bounty for Fermat's last theorem so that I could have resolved <a href=\"https://manifold.markets/BoltonBailey/will-there-be-smart-contract-bounti#8k1a6rpg5qj\">this</a> YES.</p>",
        "id": 482794437,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1731784060
    },
    {
        "content": "<p>Thanks man! I totally plan to make this a real, convenient, helpful service, and if you continue to be interested in messing around with it, your feedback will be invaluable; that's how I will know what is useful and how to make something people want. Needless to say, if you would have fun co-developing any of this, this would also be most welcome.</p>",
        "id": 482794712,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1731784270
    },
    {
        "content": "<p>I guess the plan for now is to:</p>\n<ul>\n<li>figure out a better oracle (probably with using withImportModules and checking that the proof has the right type),</li>\n<li>throw together a <del>crappy</del> minimalistic interface and make the interaction slightly less annoying, so that a bit more people join in with their use cases.</li>\n</ul>",
        "id": 482794860,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1731784416
    },
    {
        "content": "<p>Ok, I'm looking into the arena more and I see that much of the code is actually in Python! Let me look into it more and see if there is a straightforward way to integrate this into the web interface that that project has for submitting and claiming bounties.</p>",
        "id": 482795417,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1731784922
    },
    {
        "content": "<p>I think the pain point would be to integrate infura, metamask etc.<br>\nOn the other hand, if we host an interface, we can just use our own infura, it should be well within the free tier.<br>\nSo it's just about authorization (and helping people get play money)</p>",
        "id": 482795516,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1731785006
    },
    {
        "content": "<p>Asking people \"please enter your API keys and your private key to your blockchain account\" would look much more suspicious from a web page than inside a script - at least you can (and are encouraged to) read the script and make sure it doesn't go anywhere... <br>\nIf we use something like MetaMask or WalletConnect, people will at least know we're not trying to steal their account</p>",
        "id": 482796101,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1731785515
    },
    {
        "content": "<p>Actually, do we even need to integrate blockchain authentication into the interface on the first steps? Maybe I could start with a UI where I trigger the <code>requestBounty</code> function from my own account; all people would have to do is press a button on the site and specify the address to which the bounty would be sent. It woudn't work for depositing bounties, only requesting; and it doesn't scale (definitely it's not good enough for mainnet) - if nothing else, I would have to pay the gas fees for everyone; but it would be a nice start to give people something they would play around with without all the setup hustle.</p>",
        "id": 482888155,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1731870587
    },
    {
        "content": "<p>(Regarding the octopus, someone in the early days of Zulip discovered that if you put the octopus emoji underneath another emoji, it looks like the octopus is excitedly holding it. We haven't used it that way on this particular Zulip instance, but that's apparently why it's in the \"popular\" section for emojis.)</p>\n<p><img alt=\":lean:\" class=\"emoji\" src=\"https://avatars.zulip.com/3121/emoji/images/1e2b1061.png\" title=\"lean\"><br>\n<span aria-label=\"octopus\" class=\"emoji emoji-1f419\" role=\"img\" title=\"octopus\">:octopus:</span></p>",
        "id": 482896294,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1731877533
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"568200\">Vadim Fomin</span> <a href=\"#narrow/channel/113488-general/topic/blockchain.20theorem.20bounties/near/482888155\">said</a>:</p>\n<blockquote>\n<p>where I trigger the <code>requestBounty</code> function from my own account</p>\n</blockquote>\n<p>Yes, this seems simpler. This gets around the address substitution issue. If you are worried about people making lots of bounties and running out of testnet eth, you can have people making the bounties pay for their own gas out of the funds they put in the bounty.</p>",
        "id": 482909644,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1731890052
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/stream/113488-general/topic/blockchain.20theorem.20bounties/near/482743541\">said</a>:</p>\n<blockquote>\n<p>Please post a bounty for <code>False</code>, so that people can start pointing out the vulnerabilities in your checker. :-)</p>\n</blockquote>\n<p>Aren’t all the bounties for False?</p>",
        "id": 483299456,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1732032480
    },
    {
        "content": "<p>No, what makes you say that?</p>",
        "id": 483299611,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1732032517
    },
    {
        "content": "<p>Once you prove False, you get all the bounties.</p>",
        "id": 483299655,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1732032535
    },
    {
        "content": "<p>Yeah, I misunderstood your initial phrasing:) that’s pretty much the point — allowing an attacker to drain funds.</p>",
        "id": 483299971,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1732032619
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/113488-general/topic/blockchain.20theorem.20bounties/near/482896294\">said</a>:</p>\n<blockquote>\n<p>(Regarding the octopus, someone in the early days of Zulip discovered that if you put the octopus emoji underneath another emoji, it looks like the octopus is excitedly holding it. We haven't used it that way on this particular Zulip instance, but that's apparently why it's in the \"popular\" section for emojis.)</p>\n<p><img alt=\":lean:\" class=\"emoji\" src=\"https://avatars.zulip.com/3121/emoji/images/1e2b1061.png\" title=\"lean\"><br>\n<span aria-label=\"octopus\" class=\"emoji emoji-1f419\" role=\"img\" title=\"octopus\">:octopus:</span></p>\n</blockquote>\n<p>aww</p>",
        "id": 483810541,
        "sender_full_name": "Alok Singh",
        "timestamp": 1732233283
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"776090\">@GasStationManager</span> has been working on this really cool project called SafeVerify (github <a href=\"https://github.com/GasStationManager/SafeVerify\">here</a>). It will be useful to check submissions both in their <a href=\"https://github.com/GasStationManager/CodeProofTheArena\">Arena</a> project and in my TheoremMarketplace thing.</p>\n<p>So I changed the oracle and deployed another smart contract that uses SafeVerify to check submissions. The contract is deployed at <code>0xc671A4a18DA81D6Df1A9C3619045D10FaCFB3936</code>. The ways to interact with the contract are the same, but the format of the submissions has changed.</p>\n<p>Now, both the theorem and the proof should be valid lean files. Example:<br>\ntheorem:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">zero_add</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">zero_add</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">add_succ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>That is, the submission should define the same things as the bounty file, but without placeholders etc.</p>",
        "id": 484129475,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1732431852
    },
    {
        "content": "<p>I realize this is not straightforward for people to play around with. I intend to make a site with MetaMask integration which will take away the pain of interacting with blockchain, so you will just submit the proofs right on the site and earn your honest play money :)<br>\n(And real money in the future)</p>",
        "id": 484129515,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1732431930
    },
    {
        "content": "<p>I've been teaching myself Lean4 with the goal of proving properties about software and engineering standards, and I wanted to say that this is an interesting idea, because it strikes me as a next-level sort of bug bounty program (given a high enough bound on steps and size, which is at least problematic for anything worthwhile).</p>\n<p>Instead of today's \"here's my code, I'll pay you if you find problematic inputs\" it becomes \"here's my code and its goal, I'll pay you if you can prove (or disprove?) that there are no problematic inputs\". I'll note that there's probably a cheaper way to do that than a blockchain, but not one that guarantees the rules of the bounty(?).</p>\n<p>Thinking along those lines, you'll definitely want to prevent submissions from declaring their own axioms (esp <code>axiom unlimitedMoney := False</code> -- I couldn't find your oracle code quickly, so I didn't see if you already covered that), and you'll probably want a system for the submitter to define their allowed axioms (is this a Euclidean- or Spherical- Geometry Proof?).</p>",
        "id": 484432752,
        "sender_full_name": "John Wargo",
        "timestamp": 1732594827
    },
    {
        "content": "<p>(You definitely don't want to allow any extra axioms in the Lean sense --- no one \"adds axioms\" to do euclidean or spherical geometry. :-)</p>",
        "id": 484436474,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1732597647
    },
    {
        "content": "<p>(other than Euclid, Hilbert and Tarski)</p>",
        "id": 484445803,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1732604584
    },
    {
        "content": "<p>Euclid, yes. But Hilbert and Tarski were both probably thinking of <code>structure</code> or <code>class</code> as opposed to <code>axiom</code>.</p>",
        "id": 484448585,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1732606043
    },
    {
        "content": "<p>The reason why I'm going for blockchain is to minimize trust issues. The submitters deserve to be sure that they will not be cheated out of their money, and it's in the bounty depositors' best interest, too, since otherwise there will be less submissions.<br>\nAnd it's cheap anyway. The gas fees are minimal. The costs of running the oracle and the virtual machine are all currently on my side, I doubt that it will change <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 484448997,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1732606270
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"783028\">@John Wargo</span> we do check the axioms used by the submission (see <a href=\"https://github.com/GasStationManager/SafeVerify/blob/main/Main.lean\">code</a>). Only the three standard axioms are allowed: <code>propext</code>, <code>Quot.sound</code>, <code>Classical.choice</code>.</p>",
        "id": 484462214,
        "sender_full_name": "GasStationManager",
        "timestamp": 1732611552
    },
    {
        "content": "<blockquote>\n<p>The reason why I'm going for blockchain is to minimize trust issues</p>\n</blockquote>\n<p>Going for blockchain is a good way to maximize trust issues</p>",
        "id": 484476084,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1732615758
    },
    {
        "content": "<p>Why?</p>",
        "id": 484476163,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1732615784
    },
    {
        "content": "<p>because the stakes couldn't be higher, you bring out the worst parts of people when every piece of code is its own bug bounty</p>",
        "id": 484476378,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1732615844
    },
    {
        "content": "<p>it's generally not a serious worry in the FLT project that someone will commit a <code>axiom unlimitedMoney : False</code>. Not so on blockchain</p>",
        "id": 484476664,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1732615927
    },
    {
        "content": "<p>I see what you mean. Yeah, when this thing takes off we really need a security audit for both the oracle and the smart contract. That's why I'm starting small with play money and inviting you all to participate. Right now you are <em>extremely</em> welcome to find <em>any way at all</em> to drain funds. Both the contract and the checker are open-sourced.</p>",
        "id": 484476858,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1732615989
    },
    {
        "content": "<p>and once you start looking at lean with an eye for making it an airtight sandbox, you will come out disappointed because that's not the model it was built on</p>",
        "id": 484476890,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1732615999
    },
    {
        "content": "<p>The submission is slightly inconvenient because you have to interact with blockchain, but I'm working on a web interface that will hopefully start bringing out the internal saboteurs in Lean enthusiasts :)</p>",
        "id": 484477014,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1732616038
    },
    {
        "content": "<p>you have to design for security and lean is not designed for security</p>",
        "id": 484477078,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1732616047
    },
    {
        "content": "<blockquote>\n<p>and once you start looking at lean with an eye for making it an airtight sandbox, you will come out disappointed because that's not the model it was built on</p>\n</blockquote>\n<p>Yeah, I can already sense it, even though I'm a complete baby in Lean. But this has to be done anyway. No way Lean should have no way to safely check a proof's validity.</p>",
        "id": 484477191,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1732616087
    },
    {
        "content": "<p>Check out my contract here: <a href=\"https://github.com/wadimiusz/lean-contract-interact/blob/main/TheoremMarketplace.sol\">https://github.com/wadimiusz/lean-contract-interact/blob/main/TheoremMarketplace.sol</a><br>\nAnd <span class=\"user-mention\" data-user-id=\"776090\">@GasStationManager</span> 's checker here: <a href=\"https://github.com/GasStationManager/SafeVerify\">https://github.com/GasStationManager/SafeVerify</a></p>",
        "id": 484477303,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1732616123
    },
    {
        "content": "<p>are you familiar with the story of the coq theorem bounty program that was taken down because people broke the system too often?</p>",
        "id": 484477340,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1732616137
    },
    {
        "content": "<p>I'm afraid not. I'd like to hear it :)</p>",
        "id": 484477374,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1732616150
    },
    {
        "content": "<p><a href=\"#narrow/channel/113488-general/topic/Is.20there.20a.20bounty.20system.3F/near/454351937\">previous discussion</a></p>",
        "id": 484477644,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1732616249
    },
    {
        "content": "<p>It seems silly to take down the program because of that, though. You just need to get the thing done. People offer bounties on Lean's zulip, the last time it happened was only a couple day's ago, if memory serves. It's within the mathemarical tradition. It's feels very natural to me to make it decentralized.</p>",
        "id": 484477791,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1732616286
    },
    {
        "content": "<p>I don't know what you are referring to, monetary bounties are not something we see on this zulip</p>",
        "id": 484478040,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1732616376
    },
    {
        "content": "<p><a href=\"#narrow/channel/113488-general/topic/Want.20to.20put.20a.20bounty.20on.20a.20proof/near/484044275\">Here</a></p>",
        "id": 484478190,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1732616418
    },
    {
        "content": "<p>But I didn't express myself right, this was more of an isolated case that I saw, rather than a thing that happens frequently. Rather, I should have said that bounties on theorems have been a topic of discussion previously.</p>",
        "id": 484478414,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1732616507
    },
    {
        "content": "<p>it is amusing that one of the first exchanges there is about a kind of \"cheating\" which lean would have accepted</p>",
        "id": 484478425,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1732616512
    },
    {
        "content": "<p>so making the process fully automatic would have been a bad move</p>",
        "id": 484478505,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1732616527
    },
    {
        "content": "<p>Indeed. Your point about cheating is absolutely right; don't think I don't appreciate it.</p>",
        "id": 484478571,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1732616557
    },
    {
        "content": "<p>the thing is, this is the rule, not the exception. If you put money on a thing the <em>first thing</em> people are going to think about is how to cheat or otherwise circumvent the restrictions</p>",
        "id": 484478735,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1732616612
    },
    {
        "content": "<p>I agree.</p>",
        "id": 484478778,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1732616627
    },
    {
        "content": "<p>meaning that if you have a mathematical question and want a reasonable answer, money can actually hurt your chances of getting a satisfactory answer</p>",
        "id": 484478999,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1732616687
    },
    {
        "content": "<p>Unless I manage to set up a system in such a way as to align the incentives just right.</p>",
        "id": 484479112,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1732616724
    },
    {
        "content": "<p>The vast majority of questions asked on this zulip are answered by volunteers (like me!)</p>",
        "id": 484479169,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1732616743
    },
    {
        "content": "<p>I am not sure how successful the attempt will be, but I would like to try just to see what happens.</p>",
        "id": 484479180,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1732616745
    },
    {
        "content": "<p>I was actually thinking that a use case like \"a frustrated Lean enthusiast doesn't know how to prove a basic lemma\" may be a nice starting use case, and throw some meager money at starving grad students.</p>",
        "id": 484479418,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1732616808
    },
    {
        "content": "<p>there are incentive structures of course, I'm not doing this purely altruistically and my career would not be what it is without the support of the people who I have helped on this zulip</p>",
        "id": 484479486,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1732616830
    },
    {
        "content": "<p>Open source has its own way of supporting the people who get involved, it's just not as direct as a salary</p>",
        "id": 484479840,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1732616942
    },
    {
        "content": "<p>Anyway, what I'm saying is that if you make a bounty program you should not put much of value on it because it will be cleaned out several times</p>",
        "id": 484480162,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1732617043
    },
    {
        "content": "<p>especially if you build on a system that was not designed for security like lean</p>",
        "id": 484480286,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1732617083
    },
    {
        "content": "<p>I'm definitely planning for it. Like i said, that's why I'm starting with play money, and later I will use tiny funds.</p>",
        "id": 484480316,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1732617096
    },
    {
        "content": "<p>And I will invite people to seek vulnerabilities :)</p>",
        "id": 484480512,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1732617152
    },
    {
        "content": "<p>As a sort of red teaming.</p>",
        "id": 484480532,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1732617158
    },
    {
        "content": "<p>If this project ever becomes anything serious, it will need a security audit.</p>",
        "id": 484480575,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1732617171
    },
    {
        "content": "<p>I'm not sure anyone will ever care about this project, although I hope so very much.</p>",
        "id": 484480635,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1732617187
    },
    {
        "content": "<p>But if something becomes of it, a security audit will definitely be necessary...</p>",
        "id": 484480692,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1732617205
    },
    {
        "content": "<p>If the total amount of money remains small enough that getting it swept out by a proof of False every so often isn't a big deal, then regularly discovering exploits in Lean might not be the worst fate of a project, in that it's useful to know what kind of exploits Lean is susceptible to. If anything, I'm curious to see how this will go. I wouldn't however put too much faith in the idea that after an initial burst of flaws is discovered, Lean will be secure enough to not have proofs of <code>False</code> for years.</p>\n<p>I would also think that using an external checker is probably necessary, because in the past there was a way to trick Lean's kernel with metaprogramming. Also keep in mind that Lean files can run arbitrary IO code when compiling, so be cautious about RCE exploits.</p>",
        "id": 484546342,
        "sender_full_name": "Niels Voss",
        "timestamp": 1732636688
    },
    {
        "content": "<p>As Mario tried to explain, we are not discussing flaws in Lean here. We are talking about non-goals of Lean.</p>",
        "id": 484551615,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1732638271
    },
    {
        "content": "<p>Whether it's a goal \"of Lean\" or not, it certainly seems like it's a goal that some people in this thread have <em>for</em> Lean. I'd be interested to hear if there are other examples or formal languages that people think are more designed for security.</p>",
        "id": 484552490,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1732638552
    },
    {
        "content": "<p>As for why I personally am interested in Lean being used for this purpose, the answer is simply that Lean is the system I am most familiar with. Whatever people are saying in this thread about Lean not being designed for security, my feeling is that there is a level of effort that could be put in to make it sufficiently secure - it's just a question of what that level of effort is, and whether it will be attained, and whether (as is a legitimate worry) the bad situation will obtain where users think it has been attained and rely on it having been attained when it actually hasn't been. </p>\n<p>Practically speaking, I imagine the SNARK links above are relevant to the question of how to make an adversarially robust formal system. This line of research already deals with an adversarial model. Moreover, putting a formal system inside a SNARK requires having a very simple environment for checking proofs, and I would think this process gets rid of many avenues for proving False. And clearly it has synergy with the \"blockchain\" aspect.</p>",
        "id": 484559373,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1732640746
    },
    {
        "content": "<p>I think the main concern is that with the amount of metaprogramming Lean supports, making it adversarilly robust will be fairly difficult, especially if it requires frequent PRs to core Lean, and it might just be low priority (or even a non-goal, as Patrick Massot said).</p>\n<p>Maybe it will be more realistic to make one of the external proof checkers adversarilly secure?</p>",
        "id": 484565777,
        "sender_full_name": "Niels Voss",
        "timestamp": 1732642967
    },
    {
        "content": "<p>I want to have a theorem bounty system on blockchain, I'm flexible as to which checker to use. I just thought Lean was a good idea since it's all the rage and I hoped it would improve a mathematician's routine, but I can switch.</p>",
        "id": 484566060,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1732643066
    },
    {
        "content": "<p>No, that's not right. It doesn't make sense to just use any checker. I want to make something useful, something that can be integrated into a routine. Lean already has a routine, that's the nice thing, lean already has mathematics going on about it.</p>",
        "id": 484566475,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1732643233
    },
    {
        "content": "<p>By \"external checker\", I didn't mean another system that isn't Lean, I meant an external kernel for Lean</p>",
        "id": 484566756,
        "sender_full_name": "Niels Voss",
        "timestamp": 1732643333
    },
    {
        "content": "<p>Like <a href=\"https://github.com/digama0/lean4lean\">https://github.com/digama0/lean4lean</a> or <a href=\"https://github.com/ammkrn/nanoda_lib\">https://github.com/ammkrn/nanoda_lib</a></p>",
        "id": 484567713,
        "sender_full_name": "Niels Voss",
        "timestamp": 1732643677
    },
    {
        "content": "<p>That would be neat - an external type checker should be good enough to verify bounties, right?</p>",
        "id": 484567901,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1732643753
    },
    {
        "content": "<p>I don't know about \"good enough\", but it's certainly better than not having one. You still might have to check for things like people adding extra axioms and making sure the theorem statement (and the terms that theorem statement depends on) have not been changed beyond what was requested</p>",
        "id": 484570468,
        "sender_full_name": "Niels Voss",
        "timestamp": 1732644667
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"282271\">Bolton Bailey</span> <a href=\"#narrow/channel/113488-general/topic/blockchain.20theorem.20bounties/near/484552490\">said</a>:</p>\n<blockquote>\n<p>Whether it's a goal \"of Lean\" or not, it certainly seems like it's a goal that some people in this thread have <em>for</em> Lean. I'd be interested to hear if there are other examples or formal languages that people think are more designed for security.</p>\n</blockquote>\n<p>Shameless plug, <a href=\"https://digama0.github.io/mm0/thesis.pdf\">Metamath Zero</a> is designed for security (or rather, provable correctness)</p>",
        "id": 484586283,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1732650943
    },
    {
        "content": "<p>I have used the theorem bounty situation as an example in my talks because I think it helps put people in the right mindset to understand what it means for a proof assistant to be provably correct</p>",
        "id": 484586639,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1732651104
    },
    {
        "content": "<p>If you are going to put a proof checker on the blockchain, use one like Metamath or HOL light or MM0, that is, one where \"simplicity\" is listed in the \"pro\" column. Don't use lean, it's just asking to get owned.</p>",
        "id": 484587438,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1732651443
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/113488-general/topic/blockchain.20theorem.20bounties/near/484587438\">said</a>:</p>\n<blockquote>\n<p>If you are going to put a proof checker on the blockchain, use one like Metamath or HOL light or MM0, that is, one where \"simplicity\" is listed in the \"pro\" column. Don't use lean, it's just asking to get owned.</p>\n</blockquote>\n<p>Indeed, shameless counter plug for <a href=\"https://github.com/Pi-Squared-Inc/zk-benchmark\">the work Pi squared (who I work for) is doing</a> to but proofs in metamath on the blockchain.</p>",
        "id": 484610253,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1732661939
    },
    {
        "content": "<p>There's also the annoying problem, already well in evidence above, that people will (ignorantly or wilfully!) mistake \"this blockchain proof checker based on Lean accepted a proof of False\" for \"Lean/lean4checker accepted a proof of False\".</p>\n<p>Please don't exacerbate it?</p>",
        "id": 484617065,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1732666265
    },
    {
        "content": "<p>I'll try my best not to frame anything like that. Anything like bounties for False will be bug hunt on our side. Of course, it's technically possible that a bug in Lean could be found, but a bug in the checker implementation is overwhelmingly more likely, especially in an adversarial setting. I won't make it Lean's problem, don't worry.</p>",
        "id": 484653481,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1732691616
    },
    {
        "content": "<p>You won't, but the media might</p>",
        "id": 484661297,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1732695298
    },
    {
        "content": "<p>Is that a thing that's happened to the Lean community, ever?</p>",
        "id": 484662725,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1732695856
    },
    {
        "content": "<p>A friend participated today in a hackathon in Berlin organised by people behind this:</p>\n<p><a href=\"https://www.cairo-lang.org/\">https://www.cairo-lang.org/</a><br>\n<a href=\"https://github.com/zksecurity/stone-cli\">https://github.com/zksecurity/stone-cli</a></p>\n<p>It seems on-topic <span class=\"user-mention\" data-user-id=\"568200\">@Vadim Fomin</span> , but I don't know much about it, and I didn't attend the hackathon.</p>\n<p>From a cursory look, it seems like the purported innovation is running long programs off-chain for efficiency, but with semantics of on-chain execution (and with some level of formal guarantees).</p>",
        "id": 484982380,
        "sender_full_name": "Adam Kurkiewicz",
        "timestamp": 1732825473
    },
    {
        "content": "<p>That seems very relevant indeed, thank you!</p>",
        "id": 485023000,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1732857039
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"568200\">@Vadim Fomin</span> how would you prevent the front-running that <span class=\"user-mention\" data-user-id=\"282271\">@Bolton Bailey</span> mentioned earlier in the thread?</p>\n<p>I think the solution would have to involve committing a hash of the proof (or some other evidence of priority) on-chain, and then a settlement period when anybody can claim priority by referencing the hash, and the proof with the earliest hash wins. Although maybe a smarter scheme can be invented.</p>",
        "id": 485144779,
        "sender_full_name": "Adam Kurkiewicz",
        "timestamp": 1732904617
    },
    {
        "content": "<p>I mean if you are going to involve zk-SNARKs you can do things in one round by signing the proof and then making a zk-SNARK proof you signed it (but people will probably then complain that not revealing the proof is something you want to <em>prevent</em>)</p>",
        "id": 485145099,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1732904821
    },
    {
        "content": "<p>I'm not sure yet. I'm really trying to do baby steps here, doing some minimal thing that works and then iterating it. I haven't even published a website interface of the smart contract yet (sorry folks, I was sick; but i'm getting there). Can't we just, like, encrypt submissions so that someone seing your submitted transaction can't ape it in their own name, and indeed see what you submitted, and then we just trust the ordering of blocks?</p>",
        "id": 485145760,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1732905224
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"282271\">@Bolton Bailey</span> could you elaborate? I don't understand those ZK-SNARKs. I tried to read a bit, but I still don't really get it. Who verifies that the proof exists and is correct? There is a computation to run to verify the formal proof, so that needs to run somewhere somehow. If the computation runs without the program getting revealed then that's homomorphic encryption? And then there is a question of authorship. Why wouldn't somebody just take the proof and front-run it with their own signature? I don't really understand how this all fits together.</p>",
        "id": 485148516,
        "sender_full_name": "Adam Kurkiewicz",
        "timestamp": 1732906879
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"568200\">@Vadim Fomin</span> committing one hash to a blockchain is cheaper than committing the entire (encrypted) proof, and it's just as good a proof of authorship as an encrypted proof. So I think using a hash is a better idea than using encryption. Bolton's idea is probably better yet, I just don't understand it.</p>",
        "id": 485149708,
        "sender_full_name": "Adam Kurkiewicz",
        "timestamp": 1732907551
    },
    {
        "content": "<p>That makes sense. Probably the thing that actually matters is not the purity of the concept but the convenience to the users, so, in practice, how cheap it will be to submit, how reliable the web interface will be, and how secure against attacks. That is, if I want it to actually help anyone with their Lean lives.</p>",
        "id": 485152407,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1732909126
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111040\">Adam Kurkiewicz</span> <a href=\"#narrow/channel/113488-general/topic/blockchain.20theorem.20bounties/near/485148516\">said</a>:</p>\n<blockquote>\n<p>Who verifies that the proof exists and is correct? There is a computation to run to verify the formal proof, so that needs to run somewhere somehow.</p>\n</blockquote>\n<p>The verification procedure is run by the person who creates the Lean proof. To vastly oversimplify, they run the Lean verification procedure on a virtual machine and write out the entire trace of the state of that virtual machine and then apply fancy error-correcting codes to that data, and then create a cryptographic summary of all of that that guarantees that the final state of the virtual machine was e.g. \"x^n + y^n + z^n /= 0 was successfully proved in Lean\". The cryptographic summary then guarantees that this was the final state without anyone having to re-run the computation.<br>\n<span class=\"user-mention silent\" data-user-id=\"111040\">Adam Kurkiewicz</span> <a href=\"#narrow/channel/113488-general/topic/blockchain.20theorem.20bounties/near/485148516\">said</a>:</p>\n<blockquote>\n<p>If the computation runs without the program getting revealed then that's homomorphic encryption?</p>\n</blockquote>\n<p>FHE is related but not the same. EDIT Perhaps a good explanation would be that in FHE, the details of the proof are kept secret from even the computer running the verification procedure, which doesn't have to happen here, since we assume the cryptographically protected verification procedure is being run by the one who made the Lean proof.<br>\n<span class=\"user-mention silent\" data-user-id=\"111040\">Adam Kurkiewicz</span> <a href=\"#narrow/channel/113488-general/topic/blockchain.20theorem.20bounties/near/485148516\">said</a>:</p>\n<blockquote>\n<p>And then there is a question of authorship. Why wouldn't somebody just take the proof and front-run it with their own signature?</p>\n</blockquote>\n<p>What I am suggesting is that instead of running just a program that checks the Lean proof, we run a program which checks the Lean proof, and then also receives as input a public key and directly outputs that same public key. The \"ARK\" stands for \"argument of knowledge\", it basically means that whoever created the SNARK had to know a set of inputs that made the program output the way it did. Someone wanting to substitute their public key with the prover's will not know the proof and will not be able to construct a new SNARK that corresponds to the output simultaneously containing their public key and outputting \"x^n + y^n + z^n /= 0 was successfully proved\". (as long as the SNARK is not malleable, yada yada ...)</p>\n<p>But I agree that all of this is much more advanced than a minimal prototype would look like.</p>",
        "id": 485152708,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1732909336
    },
    {
        "content": "<p>Oh wow, I didn't realise that this was already technologically possible?</p>\n<blockquote>\n<p>The \"ARK\" stands for \"argument of knowledge\", it basically means that whoever created the SNARK had to know a set of inputs that made the program output the way it did.</p>\n</blockquote>\n<p>And those inputs can, in principle, be virtual machine opcodes? So that the smart contract contains (publicly visible), statement of the theorem and the public key claiming \"ownership\" of the formalisation, and the \"inputs\" is the actual formalisation of the proof of the theorem, which are then cryptographically proven to lead to a (non-malleable) virtual machine state that certifies the existence of the proof.</p>\n<p>Am I understanding this right?</p>",
        "id": 485156257,
        "sender_full_name": "Adam Kurkiewicz",
        "timestamp": 1732911616
    },
    {
        "content": "<p>Yes, that is all correct</p>",
        "id": 485156343,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1732911693
    },
    {
        "content": "<p>I think we would like to know the theorem though (in the traditional sense of e.g. Erdos bounties), so that's still a two-phase protocol</p>",
        "id": 485156448,
        "sender_full_name": "Adam Kurkiewicz",
        "timestamp": 1732911748
    },
    {
        "content": "<p>Unless you've got more cryptographic cleverness I didn't know existed :)</p>",
        "id": 485156509,
        "sender_full_name": "Adam Kurkiewicz",
        "timestamp": 1732911798
    },
    {
        "content": "<p>Time delay encryption would be the obvious candidate</p>",
        "id": 485156544,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1732911829
    },
    {
        "content": "<p>OK, but from an engineering point of view probably having 2 or even 3 phase protocol is probably fine. It will work. If I were to build something like this for real, I would probably like to keep it as simple as possible</p>",
        "id": 485156800,
        "sender_full_name": "Adam Kurkiewicz",
        "timestamp": 1732911970
    },
    {
        "content": "<p>At the risk of hijacking discussion even further (sorry <span class=\"user-mention\" data-user-id=\"568200\">@Vadim Fomin</span> ) there is a continuation to the arms race where the prover can avoid revealing the proof by obfuscating it (i.e. making the proof convoluted in a cryptographically undecipherable way). I think there is an interesting mechanism design question on how to incentivize prosocial theorem proving. For example, if someone creates de novo an interesting lemma, that no one anticipates, but goes on to be critical in the proof of several bountied theorems, how can we ensure that the creator gets a share of the reward.</p>",
        "id": 485157191,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1732912285
    },
    {
        "content": "<p>As a further thought about practical failsafes: If we are worried about it being possible to prove False with whatever checker we have, one possibility is to delay all payouts on all bounties for a week or so and have smart contract return control of funds to a multisig if a proof of False is ever discovered. The idea being that if someone does prove False and uses that proof to prove other falsehoods, white hats can potentially protect the account from being drained by understanding the faulty proof and triggering the failsafe.</p>",
        "id": 485157326,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1732912381
    },
    {
        "content": "<blockquote>\n<p>For example, if someone creates de novo an interesting lemma, that no one anticipates, but goes on to be critical in the proof of several bountied theorems, how can we ensure that the creator gets a share of the reward.</p>\n</blockquote>\n<p>I've been thinking about this a lot. I don't have great solutions here. This feels like it should be a feature of the market eventually. Maybe this will at least partially be solved with market dynamics, not technology. For example, imagine that there is a huge bounty placed on proving A -&gt; B, and C -&gt; B is trivially shown, so an almost equal bounty is placed on A -&gt; C; and when A -&gt; C is submitted, the requester of the proof A -&gt; C submits proof for A -&gt; B. But this doesn't work for the lemmas that no one anticipated, like you said.</p>",
        "id": 485157715,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1732912680
    },
    {
        "content": "<p>Oh these are interesting considerations, you clearly thought about this quite deeply! A quick question about ZK-SNARKs, how scalable is on-chain verification of those? Is there some log(n) penalty that the chain has to pay, where n is the number of steps in the formal proof, or is 100% of the computational cost on the off-chain verifier who produces the ZK proof of running the SNARK?</p>",
        "id": 485158006,
        "sender_full_name": "Adam Kurkiewicz",
        "timestamp": 1732912862
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111040\">Adam Kurkiewicz</span> <a href=\"#narrow/channel/113488-general/topic/blockchain.20theorem.20bounties/near/485158006\">said</a>:</p>\n<blockquote>\n<p>Oh these are interesting considerations, you clearly thought about this quite deeply! A quick question about ZK-SNARKs, how scalable is on-chain verification of those? Is there some log(n) penalty that the chain has to pay, where n is the number of steps in the formal proof, or is 100% of the computational cost on the off-chain verifier who produces the ZK proof of running the SNARK?</p>\n</blockquote>\n<p>I'm glad you asked! The answer is that some zk-SNARKs have cryptographic-proof-verification-procedures with O(log(n)) cost with a large constant, but efficient cryptographic-proof-generators, and some SNARKs have inefficient cryptographic-proof-generators but very fast cryptographic-proof-verification-procedures . In practical terms, if you have a zkSNARK that is expensive to verify you just ... <em>Make a latter ZK-SNARK of the former ZK-SNARK's cryptographic-proof-verification-procedures</em>. This is not a joke, it's literally what the state-of the art systems all do.</p>",
        "id": 485158226,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1732913015
    },
    {
        "content": "<p>Unfortunately I am not an academic anymore, otherwise I would give a rump session talk about the infinite binary tree in which the left-child of any node is \"apply a SNARK to it\" and the right child is \"formally verify it\". Every node in the first two levels of this tree has a realization in code.</p>",
        "id": 485158572,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1732913227
    },
    {
        "content": "<p>Just to make sure I'm following: verifier is the on-chain program that checks the ZK-proof, and the \"prover\" is what happens locally e.g. how the formalisation gets checked on the VM.</p>",
        "id": 485159138,
        "sender_full_name": "Adam Kurkiewicz",
        "timestamp": 1732913585
    },
    {
        "content": "<p>Yes, sorry, obviously terminology here is confusing, will edit</p>",
        "id": 485159320,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1732913696
    },
    {
        "content": "<p>As for practicality, google tells me 200,000 to 500,000 gas to verify a SNARK on ethereum. At current prices, seems like thats about $18. Of course there are proposals and debates to make it cheaper <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 485159375,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1732913729
    },
    {
        "content": "<p>Nah, all good, it's just not my field at all, so I'm learning the terminology.</p>",
        "id": 485159407,
        "sender_full_name": "Adam Kurkiewicz",
        "timestamp": 1732913750
    },
    {
        "content": "<p>I'm still struggling to understand this:</p>\n<blockquote>\n<p>Make a latter ZK-SNARK of the former ZK-SNARK's verification procedure</p>\n</blockquote>\n<p>Can you elaborate?</p>",
        "id": 485159482,
        "sender_full_name": "Adam Kurkiewicz",
        "timestamp": 1732913783
    },
    {
        "content": "<p>Well, it's specifically confusing because there are two notions of \"proof\" - formal proof, and cryptographic proof.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"111040\">Adam Kurkiewicz</span> <a href=\"#narrow/channel/113488-general/topic/blockchain.20theorem.20bounties/near/485159482\">said</a>:</p>\n<blockquote>\n<p>Can you elaborate?</p>\n</blockquote>\n<p>Just as we can make a zk-SNARK that runs the program which is lean's kernel and outputs \"someone knows of the existence of a proof of this mathematical statement which was valid according to lean's kernel\", we can make a zk-SNARK that runs the program which is \"another SNARKS cryptographic-verification-procedure\" and outputs \"someone knows of the existence of string of data which is a valid cryptographic certificate of as checked by this SNARKs cryptographic-verification-procedure, and which, according to that procedure, says \"someone knows of the existence of a proof of this mathematical statement which was valid according to lean's kernel\"\".</p>",
        "id": 485160012,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1732914120
    },
    {
        "content": "<p>We are now at the third level of the tree I was describing above.</p>",
        "id": 485160063,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1732914140
    },
    {
        "content": "<p>Ah I see, so the idea is that basically at this stage with the nested ZK-proofs, you are paying O(log(log(n) + C) + C), where C is the large constant. The inner large constant would need to to be paid by whoever wants to verify the inner ZK-proof, but nobody really needs to verify it as verifying the outer ZK-proof is sufficient, so effectively the chain will pay only approximately log(log(n)) + C of the outer proof</p>",
        "id": 485161039,
        "sender_full_name": "Adam Kurkiewicz",
        "timestamp": 1732914723
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111040\">Adam Kurkiewicz</span> <a href=\"#narrow/channel/113488-general/topic/blockchain.20theorem.20bounties/near/485161039\">said</a>:</p>\n<blockquote>\n<p>Ah I see, so the idea is that basically at this stage with the nested ZK-proofs, you are paying O(log(log(n) + C) + C), where C is the large constant. The inner large constant would need to to be paid by whoever wants to verify the inner ZK-proof, but nobody really needs to verify it as verifying the outer ZK-proof is sufficient, so effectively the chain will pay only approximately log(log(n)) + C of the outer proof</p>\n</blockquote>\n<p>This explanation makes it sound like the inner C and the outer C are the same. It's not quite true that no one needs to verify the inner snark, the prover has to verify it in the process of constructing it. Here is a numerical explanation (All of these numbers are too small, but this gives the idea)</p>\n<p>There is one SNARK \"CAIRO\" which takes </p>\n<ul>\n<li><code>1024 t log t</code>  time to prove the result of a program that took t time to run on its own, </li>\n<li>and the proof verification procedure takes <code>4096 log t</code> time to run. </li>\n</ul>\n<p>There is another SNARK \"GROTH16\"  which takes </p>\n<ul>\n<li><code>65536 t log t</code> time to prove the result of a program that took t time to run on its own, </li>\n<li>and the proof verification procedure takes a constant <code>128</code> time to run, no matter the program execution length.</li>\n</ul>\n<p>What we do is run the CAIRO SNARK, and then run the GROTH16 SNARK on the proof verification procedure of CAIRO. We get a new SNARK, which we might call GROTH16(CAIRO):</p>\n<ul>\n<li>Proof time = Time to prove initial program using CAIRO + Time to prove resulting proof verification in Groth16 = <code>1024 t log t +  65536 (4096 log t ) log (4096 log t )</code> (note that the first term dominates for large enough <code>t</code>).</li>\n<li>Verification time = <code>128</code>, since, as you say, verifying the outer SNARK is sufficient.</li>\n</ul>",
        "id": 485162046,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1732915392
    },
    {
        "content": "<p>And <code>t</code> is the number of opcodes for the virtual machine?</p>",
        "id": 485162464,
        "sender_full_name": "Adam Kurkiewicz",
        "timestamp": 1732915672
    },
    {
        "content": "<p><code>t</code> is the number of times it executes an opcode, in other words the number of \"cycles\", yes.</p>",
        "id": 485162615,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1732915764
    },
    {
        "content": "<p>I see, very interesting technology. Thanks for explaining Bolton! It's a neat trick with nesting the SNARKs</p>",
        "id": 485162938,
        "sender_full_name": "Adam Kurkiewicz",
        "timestamp": 1732915948
    },
    {
        "content": "<p>And the soundness/correctness of these systems is generally quite high I assume? Something similar to Bitcoin/Ethereum? Or are they way more experimental than that?</p>",
        "id": 485163210,
        "sender_full_name": "Adam Kurkiewicz",
        "timestamp": 1732916102
    },
    {
        "content": "<p>That is itself an interesting question. While in principle you can scale up the security parameter, the security parameters in practice are not always chosen well, though I haven't heard of anything being broken because of this. There are a variety of cryptographic assumptions at play. In some cases the security relies on conjectures in coding theory.</p>",
        "id": 485163593,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1732916321
    },
    {
        "content": "<p>One idea to promote a system capable of providing these kind of bounties would be to offer \"Erdos bounties\" on all the unsolved Erdos problems . This seems timely given that the informal custodian of Erdos bounties passed away a few years ago (I don't know any more details of this than what's on the internet, but there are many mathematicians in this forum, so they might know more):</p>\n<p><a href=\"https://en.wikipedia.org/wiki/Paul_Erd%C5%91s\">https://en.wikipedia.org/wiki/Paul_Erd%C5%91s</a></p>\n<blockquote>\n<p>There are thought to be at least a thousand remaining unsolved problems, though there is no official or comprehensive list. The offers remained active despite Erdős's death; <a href=\"https://en.wikipedia.org/wiki/Ronald_Graham\">Ronald Graham</a> was the (informal) administrator of solutions, and a solver could receive either an original check signed by Erdős before his death (for memento only, cannot be cashed) or a cashable check from Graham.<a href=\"https://en.wikipedia.org/wiki/Paul_Erd%C5%91s#cite_note-49\">[49]</a>[<em><a href=\"https://en.wikipedia.org/wiki/Wikipedia:Manual_of_Style/Dates_and_numbers#Chronological_items\">needs update</a></em>] British mathematician <a href=\"https://en.wikipedia.org/wiki/Thomas_Bloom\">Thomas Bloom</a> started a website dedicated to Erdős's problems in 2024.<a href=\"https://en.wikipedia.org/wiki/Paul_Erd%C5%91s#cite_note-Erd%C5%91s_Problems_Thomas_Bloom-50\">[50]</a></p>\n</blockquote>\n<p>Details of a recently paid out bounty:</p>\n<p><a href=\"https://nautil.us/cash-for-math-the-erdos-prizes-live-on-236641/\">https://nautil.us/cash-for-math-the-erdos-prizes-live-on-236641/</a></p>\n<p>The list of problems Erdos offered cash for appears to be here (and the curator of the list <span class=\"user-mention\" data-user-id=\"458865\">@Thomas Bloom</span>  is on this Zulip chat) :</p>\n<p><a href=\"https://www.erdosproblems.com/prizes\">https://www.erdosproblems.com/prizes</a></p>\n<p>This would apparently require 33,817 USD worth of funds (in 2024 dollars). If we were to adjust for inflation from 1985 dollars, we would be talking about ~3x that money so about ~$100k USD.</p>\n<p>I can imagine that a crypto company or a crypto philanthropist might be willing to provide this level of funds if you could get the underlying technology working properly, even if just for publicity/marketing reasons (One of them recently bought <a href=\"https://www.theguardian.com/world/2024/nov/29/crypto-entrepreneur-justin-sun-eats-banana-art-he-bought-for-6m-dollars\">a banana</a> for $6.2m USD...). From the conversations so far it seems like using ZK-SNARKs and using Metamath Zero or similar (as opposed to lean) are all good ideas.</p>",
        "id": 485210378,
        "sender_full_name": "Adam Kurkiewicz",
        "timestamp": 1732958113
    },
    {
        "content": "<p>Erdos was specifically one of the sources of my inspiration :)</p>",
        "id": 485210467,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1732958172
    },
    {
        "content": "<p>Is there a linter for Lean that works online, so that I could reject theorem requests and submissions in bad Lean? natural numbers game had something like this, right?</p>",
        "id": 485225086,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1732970693
    },
    {
        "content": "<p>I mean, I can just reject them on the server side, but maybe it can be done in the browser already?</p>",
        "id": 485226780,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1732972122
    },
    {
        "content": "<p>Stick <code>#lint</code> at the bottom of your file. And no, I don't think NNG had anything to do with linters (indeed the author of NNG had no clue about what a linter was when that game was first written)</p>",
        "id": 485228655,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1732973710
    },
    {
        "content": "<p>I meant more like, do I have to send the file to the backend to check if it compiles or can I do something right in the webpage?</p>",
        "id": 485228804,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1732973817
    },
    {
        "content": "<p>Oh I see, you just want to know if the file compiles without errors?</p>",
        "id": 485230655,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1732975298
    },
    {
        "content": "<p>Yeah.</p>",
        "id": 485235654,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1732979265
    },
    {
        "content": "<p>Alright, so I made a website for playing around with that smart contract: <a href=\"https://theorem-marketplace.com\">https://theorem-marketplace.com</a></p>\n<p>You just need to install MetaMask (<a href=\"https://metamask.io\">here</a>, or click the button on the site), and some play money (\"Sepolia Ether\"; I can wire you some, that's the easiest way, or you can get it from online faucets)<br>\nFeel free to play around with it and break it in any way you can think of :)</p>\n<p>It supports Mathlib - just write \"import Mathlib\".</p>",
        "id": 489266190,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1734362763
    }
]