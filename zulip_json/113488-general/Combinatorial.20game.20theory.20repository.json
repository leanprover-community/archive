[
    {
        "content": "<p>Discussion thread for <a class=\"message-link\" href=\"/#narrow/channel/113486-announce/topic/Combinatorial.20game.20theory.20repository/near/504963255\">#announce &gt; Combinatorial game theory repository @ üí¨</a>.</p>",
        "id": 504963354,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1741729545
    },
    {
        "content": "<p>It's probably worth pointing out there's some quite major changes from the Mathlib repository. Most notably, we implemented the long-awaited <code>IGame</code> refactor, to the extent that the previous <code>PGame</code> now plays only the role of an auxiliary construction.</p>",
        "id": 504966797,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1741730647
    },
    {
        "content": "<p>Could you ever envisage an interface where people could actually play some of these games rather than just proving theorems about them? What would that entail? First step would be e.g. two players playing against each other, you might have to implement a way of visualising a position on a per-game basis. The reason I think this is a cool next step is that the moment you have something where people can play, you might get people organically thinking \"hey wouldn't it be cool if I could write an algorithm to play for me\"; my feeling is that this is more likely to happen if the GUI is already there though.</p>",
        "id": 504970019,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1741731796
    },
    {
        "content": "<p>Re the README: are you sure Tic-Tac-Toe and chess are combinatorial games? I thought neither of them were played under the \"normal play rule\" (\"you lose precisely when you can't move\") and furthermore chess can go on forever unless you invoke the 50 move rule which again is not part of the normal play rule (and means that it's not true that the moves are determined by the position alone). Or is there some hack to make this true?</p>",
        "id": 504973135,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1741732667
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113488-general/topic/Combinatorial.20game.20theory.20repository/near/504973135\">said</a>:</p>\n<blockquote>\n<p>Re the README: are you sure Tic-Tac-Toe and chess are combinatorial games? I thought neither of them were played under the \"normal play rule\" (\"you lose precisely when you can't move\") and furthermore chess can go on forever unless you invoke the 50 move rule which again is not part of the normal play rule (and means that it's not true that the moves are determined by the position alone). Or is there some hack to make this true?</p>\n</blockquote>\n<p>Hack for tic-tac-toe: if the other player has a three-in-a-row, you have no moves.</p>",
        "id": 504974625,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741733124
    },
    {
        "content": "<p>About chess - if we count the repetition of position as a draw then there are no infinite games.</p>",
        "id": 504975085,
        "sender_full_name": "IlmƒÅrs Cƒ´rulis",
        "timestamp": 1741733261
    },
    {
        "content": "<p>Ping <span class=\"user-mention\" data-user-id=\"673662\">@Owen Randall</span></p>",
        "id": 504975371,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1741733353
    },
    {
        "content": "<p>Yes I kind of realised the tic-tac-toe hack as I was writing. I can't really make it work for chess though. I think that in theory a game can go on forever? Don't the players actually have to agree on a draw after 50 moves, rather than it being forced on them?</p>",
        "id": 504975435,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1741733380
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"658873\">IlmƒÅrs Cƒ´rulis</span> <a href=\"#narrow/channel/113488-general/topic/Combinatorial.20game.20theory.20repository/near/504975085\">said</a>:</p>\n<blockquote>\n<p>About chess - if we count the repetition of position as a draw then there are no infinite games.</p>\n</blockquote>\n<p>What is a \"draw\"?</p>",
        "id": 504975451,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741733387
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113488-general/topic/Combinatorial.20game.20theory.20repository/near/504975435\">said</a>:</p>\n<blockquote>\n<p>Yes I kind of realised the tic-tac-toe hack as I was writing. I can't really make it work for chess though. I think that in theory a game can go on forever? Don't the players actually have to agree on a draw after 50 moves, rather than it being forced on them?</p>\n</blockquote>\n<p>According to my hazy memory, after 75 moves the proctor declares a draw, with no input from the players.</p>",
        "id": 504975580,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741733434
    },
    {
        "content": "<blockquote>\n<p>What is a \"draw\"?</p>\n</blockquote>\n<p>Aah good point, that's not really a thing in CGT right? (unless you're asking a UK/US English question, in which case the answer is \"a tie\" :-))</p>",
        "id": 504975585,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1741733436
    },
    {
        "content": "<p><a href=\"https://en.wikipedia.org/wiki/Fifty-move_rule#Seventy-five-move_rule\">https://en.wikipedia.org/wiki/Fifty-move_rule#Seventy-five-move_rule</a> - yup</p>",
        "id": 504975636,
        "sender_full_name": "IlmƒÅrs Cƒ´rulis",
        "timestamp": 1741733461
    },
    {
        "content": "<p><a href=\"http://www.chess-server.net\">Lechenicher SchachServer</a> enforces 50 move automatically. It also stops game when 7-piece position is reached and adjudicates automatically by consulting endgame tablebases. ICCF does the same, afaik. (I don't play on it.) </p>\n<p>FICGS, I believe, simply ignores 50 move rule.</p>",
        "id": 504977713,
        "sender_full_name": "IlmƒÅrs Cƒ´rulis",
        "timestamp": 1741734223
    },
    {
        "content": "<p>So, there are many \"different\" chess types around here. <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 504977991,
        "sender_full_name": "IlmƒÅrs Cƒ´rulis",
        "timestamp": 1741734317
    },
    {
        "content": "<p>Yeah I don‚Äôt think you could consider Tic Tac Toe or chess as normal play games due to drawing and stalemates, even with the no moves on loss hack. You would have to declare  one player a winner of the tie (i.e. Go uses non-integer Komi values for tie breaking) but at that point it‚Äôs a different game with new properties. As they aren‚Äôt normal play I doubt you could apply much CGT theory to these games.</p>",
        "id": 504978307,
        "sender_full_name": "Owen Randall",
        "timestamp": 1741734439
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113488-general/topic/Combinatorial.20game.20theory.20repository/near/504970019\">said</a>:</p>\n<blockquote>\n<p>Could you ever envisage an interface where people could actually play some of these games rather than just proving theorems about them? What would that entail?</p>\n</blockquote>\n<p>I don't see why something like this couldn't be implemented. \"Concrete\" games like e.g. domineering are first implemented as the type of all their states, and turning them into our game structure <code>IGame</code> requires providing the well-founded relations for allowed moves in the form of a separate <code>ConcreteGame</code> structure. To play the game, we could just build something on top of the type of states directly, if that makes sense.</p>",
        "id": 504978903,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1741734643
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113488-general/topic/Combinatorial.20game.20theory.20repository/near/504973135\">said</a>:</p>\n<blockquote>\n<p>Re the README: are you sure Tic-Tac-Toe and chess are combinatorial games? I thought neither of them were played under the \"normal play rule\" (\"you lose precisely when you can't move\") and furthermore chess can go on forever unless you invoke the 50 move rule which again is not part of the normal play rule (and means that it's not true that the moves are determined by the position alone). Or is there some hack to make this true?</p>\n</blockquote>\n<p>That's a fair point! You can turn any terminating game with ties into a combinatorial game by simply giving all ties to some specific player, though arguably that turns them into different games. I'll update the README with some better examples.</p>\n<p>The case of tic-tac-toe is interesting because you can prove by a strategy stealing argument that a <a href=\"https://en.wikipedia.org/wiki/M,n,k-game\">(m, n, k)-game</a> can never be won by the second player. Which means, you can perform roughly the same analysis if you consider a variant of tic-tac-toe where ties are turned into second-player wins, even though that is a bit of a hack.</p>",
        "id": 504979782,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1741734984
    },
    {
        "content": "<p>CGT works only with finite/terminating games, right?</p>",
        "id": 504980084,
        "sender_full_name": "IlmƒÅrs Cƒ´rulis",
        "timestamp": 1741735094
    },
    {
        "content": "<p>Also, this repository might be of interest:<br>\n<a href=\"https://github.com/davidowe/MATH681CourseProject\">https://github.com/davidowe/MATH681CourseProject</a><br>\nIt was a course project of mine which implements Chomp, Linear Clobber, and Hex based on the existing mathlib CGT framework</p>",
        "id": 504980132,
        "sender_full_name": "Owen Randall",
        "timestamp": 1741735118
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"658873\">IlmƒÅrs Cƒ´rulis</span> <a href=\"#narrow/channel/113488-general/topic/Combinatorial.20game.20theory.20repository/near/504980084\">said</a>:</p>\n<blockquote>\n<p>CGT works only with finite/terminating games, right?</p>\n</blockquote>\n<p>Not necessarily. You need infinite games to construct the reals for example. What analysis you can do on infinite games I'm not exactly sure, but I'm pretty sure games need to be without cycles for CGT to apply.</p>",
        "id": 504980740,
        "sender_full_name": "Owen Randall",
        "timestamp": 1741735385
    },
    {
        "content": "<p>CGT only applies to terminating games, where terminating means that any sequence of moves (ignoring normal turn order) will halt.</p>",
        "id": 504980823,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741735426
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"673662\">Owen Randall</span> <a href=\"#narrow/stream/113488-general/topic/Combinatorial.20game.20theory.20repository/near/504980132\">said</a>:</p>\n<blockquote>\n<p>Also, this repository might be of interest:<br>\n<a href=\"https://github.com/davidowe/MATH681CourseProject\">https://github.com/davidowe/MATH681CourseProject</a><br>\nIt was a course project of mine which implements Chomp, Linear Clobber, and Hex based on the existing mathlib CGT framework</p>\n</blockquote>\n<p>This is very useful! We can already implement Chomp as a specific case of a poset game, but Hex and Clobber would be great to have!</p>",
        "id": 504982057,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1741735888
    },
    {
        "content": "<p>If you're interested in porting this material over, I can walk you through what's changed from the Mathlib implementation of games.</p>",
        "id": 504984095,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1741736717
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113488-general/topic/Combinatorial.20game.20theory.20repository/near/504973135\">said</a>:</p>\n<blockquote>\n<p>Re the README: are you sure Tic-Tac-Toe and chess are combinatorial games? I thought neither of them were played under the \"normal play rule\" (\"you lose precisely when you can't move\") and furthermore chess can go on forever unless you invoke the 50 move rule which again is not part of the normal play rule (and means that it's not true that the moves are determined by the position alone). Or is there some hack to make this true?</p>\n</blockquote>\n<p>There is a hack: you can use loopy games which do consider draws. For games that halt on a draw, you can change them to play infinitely.</p>",
        "id": 504988073,
        "sender_full_name": "Tristan Figueroa-Reid",
        "timestamp": 1741738317
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hern√°ndez</span> <a href=\"#narrow/channel/113488-general/topic/Combinatorial.20game.20theory.20repository/near/504979782\">said</a>:</p>\n<blockquote>\n<p>That's a fair point! You can turn any terminating game with ties into a combinatorial game by simply giving all ties to some specific player, though arguably that turns them into different games.</p>\n</blockquote>\n<p>Not necessarily; for many game theory questions like \"is there a winning strategy for player 1\" you don't get 3 options anyway so the definition will naturally make draws act equivalently to a win for one of the players</p>",
        "id": 505004624,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1741745132
    },
    {
        "content": "<p>I think that also suggests a fairly straightforward definition for a game-with-ties, namely a pair of CGT games representing the game from each player's perspective (making ties go to the opponent), possibly together with a requirement that you can't win both games (a win for one player can't also be a win for the other)</p>",
        "id": 505005321,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1741745416
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/113488-general/topic/Combinatorial.20game.20theory.20repository/near/505005321\">said</a>:</p>\n<blockquote>\n<p>I think that also suggests a fairly straightforward definition for a game-with-ties, namely a pair of CGT games representing the game from each player's perspective (making ties go to the opponent), possibly together with a requirement that you can't win both games (a win for one player can't also be a win for the other)</p>\n</blockquote>\n<p>This seems very similar to the setup for analyzing loopy games, maybe ties could be implemented as an infinite loop?</p>",
        "id": 505006389,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741745875
    },
    {
        "content": "<p>Ties as infinite loop? In chess, for example, stalemates count as ties too, but I don't get how they can be interpreted as loops - as there is no more moves for stalemated player.</p>",
        "id": 505009780,
        "sender_full_name": "IlmƒÅrs Cƒ´rulis",
        "timestamp": 1741746788
    },
    {
        "content": "<p>Does making endgame databases count as part of CGT, too? (Using Mario Carneiro's approach, if necessary, with two games to take care of ties.) I'm kinda interested into some general form/definition of these, maybe I could contribute something. <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 505010632,
        "sender_full_name": "IlmƒÅrs Cƒ´rulis",
        "timestamp": 1741747132
    },
    {
        "content": "<p>Going to read the literature to learn more.</p>",
        "id": 505011163,
        "sender_full_name": "IlmƒÅrs Cƒ´rulis",
        "timestamp": 1741747327
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/Combinatorial.20game.20theory.20repository/near/504975435\">said</a>:</p>\n<blockquote>\n<p>Yes I kind of realised the tic-tac-toe hack as I was writing. I can't really make it work for chess though. I think that in theory a game can go on forever? Don't the players actually have to agree on a draw after 50 moves, rather than it being forced on them?</p>\n</blockquote>\n<p>I dont know what the state of the art is in this area these days, but I had learnt that if it can be proven  that optimal play, by <a href=\"https://en.m.wikipedia.org/wiki/Von_Neumann%E2%80%93Morgenstern_utility_theorem\">perfectly rational actors</a>,  leads to a provably infinite game of chess, then that game is a draw. E.g if the state of the board somehow has only got two kings each on the diagonally opposite corners of the board</p>",
        "id": 505034566,
        "sender_full_name": "Somo S.",
        "timestamp": 1741758083
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"658873\">IlmƒÅrs Cƒ´rulis</span> <a href=\"#narrow/channel/113488-general/topic/Combinatorial.20game.20theory.20repository/near/505009780\">said</a>:</p>\n<blockquote>\n<p>Ties as infinite loop? In chess, for example, stalemates count as ties too, but I don't get how they can be interpreted as loops - as there is no more moves for stalemated player.</p>\n</blockquote>\n<p>I think the point is that you can modify the move set such that once you enter a tie state, a magic extra move option becomes available. So if player 1 puts player 2 in stalemate, then player 2 has exactly one response which is to move to the \"stalemate state\", and both player 1 and player 2 have only one move in this state which does nothing. So termination becomes impossible once you enter the state</p>",
        "id": 505088415,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1741775239
    },
    {
        "content": "<p>By the way, you can do similar things to chess to accommodate rules like the 3 move rule or the 50 move rule, you just add additional state to keep track of how far you are in the game</p>",
        "id": 505090714,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1741775782
    },
    {
        "content": "<p>although I guess said extra state can't itself be used by the 3 move rule :)</p>",
        "id": 505091156,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1741775915
    },
    {
        "content": "<p>You can make the \"state\" the entire history of the game.</p>",
        "id": 505095714,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741777098
    },
    {
        "content": "<p>yeah and then I think the relationship to CGT has become really tenuous: you are just saying \"here's a regular game, it's actually a gigantic poset, now play the game on the poset\" and none of the theory of CGT is going to be any use in practice (not that it's of much use in chess anyway!)</p>\n<p>I once wrote a paper about how the applications of CGT to Dots and Boxes explained in WW were very tenuous in practice (in expert play on a 5x5 board). The point is that Dots and Boxes is also not played under the normal play rule; in WW they say \"you may as well assume that it is\" but this statement has not aged at all well.</p>",
        "id": 505112522,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1741781488
    },
    {
        "content": "<p>I hope someone will just implement chess without any regard for the CGT setup. I started once long ago on <a href=\"https://github.com/leanprover-community/mathlib4/tree/chess\">branch#chess</a>, trying to prove that two complete ranks of pawns could not pass each other. It has some mostly-proved theorems like \"<code>/-- If a pawn moves without taking, it does not change file. -/</code>\", and that after a move the number of pieces has changed by 0 or -1, etc.</p>",
        "id": 505131583,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1741785906
    },
    {
        "content": "<p>We could expand the scope of the repo to analyze games like chess, but since there's already a lot of things to prove as is this would not be a top priority.</p>",
        "id": 505145089,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1741788763
    },
    {
        "content": "<p>I ran across <a href=\"https://github.com/dwrensha/Chess.lean\">https://github.com/dwrensha/Chess.lean</a> for chess a while ago but haven't really looked at it much. I think there are a couple of cool things that could be done for chess: building a theory that is useful for proving things about game play would require an algorithm for move generation which would allow proving things about chess algorithms, e.g. that an optimized bitboard move generator is correct by equivalence</p>",
        "id": 505147783,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1741789363
    },
    {
        "content": "<p>I think one thing that seems to be creeping on this topic is the distinction between analyzing/solving specific games (Chess, Tic-Tac-Toe) and the general theorems in CGT that apply to entire classes of games/games created specifically for easy analysis by CGT. It would make sense for there to be utilities for those positional games like Chess and Tic-Tac-Toe where the utilities we have can provably determine the winning outcome of those games, but, as aforementioned, CGT is not remotely equipped as a field to analyze any specific game that people normally play without extensive extra theory on top.</p>\n<p>The current list of implemented games in the CGT Lean repository includes games that arose from the need for simple-to-analyze games.</p>",
        "id": 505309604,
        "sender_full_name": "Tristan Figueroa-Reid",
        "timestamp": 1741837281
    },
    {
        "content": "<p>I have a bunch of stuff from <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/.E2.9C.94.20.60Surreal.2Emk.60.20lemmas\">#Is there code for X? &gt; ‚úî &#96;Surreal.mk&#96; lemmas</a> that I am ready to push, how should I contribute?</p>",
        "id": 505544877,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741908450
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/113488-general/topic/Combinatorial.20game.20theory.20repository/near/505544877\">said</a>:</p>\n<blockquote>\n<p>I have a bunch of stuff from <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/.E2.9C.94.20.60Surreal.2Emk.60.20lemmas\">#Is there code for X? &gt; ‚úî &#96;Surreal.mk&#96; lemmas</a> that I am ready to push, how should I contribute?</p>\n</blockquote>\n<p>You can make a PR to the repository!</p>",
        "id": 505584038,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1741927959
    },
    {
        "content": "<p>Do note that most of the theorems you list (if not all?) already exist on the new repo.</p>",
        "id": 505584099,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1741928000
    },
    {
        "content": "<p>Oh, actually <code>Surreal.mk_natCast</code> was missing, but it's a very short proof so I just went ahead and PR'd it myself<br>\n<a href=\"https://github.com/vihdzp/combinatorial-games/pull/75\">https://github.com/vihdzp/combinatorial-games/pull/75</a></p>",
        "id": 505585872,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1741928793
    },
    {
        "content": "<p>I'm wondering, should we absorb <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=NatOrdinal#doc\">docs#NatOrdinal</a> into the CGT repository?</p>",
        "id": 505738575,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1741975506
    },
    {
        "content": "<p>What is the motivation for natural addition and multiplication? Is it CGT? Definitely ordinals should be staying in mathlib (I think we're all agreed on that) but I've never heard of this variant. Hmm, judging by the docstring CGT looks like the application so I'd be happy with the move, and indeed it's only imported by stuff in <code>Mathlib.SetTheory.Game</code></p>",
        "id": 505739192,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1741975713
    },
    {
        "content": "<p>Off-topic: why make both the type synonym <em>and</em> the funky notation? Is that the notation used in the literature or something?</p>",
        "id": 505739375,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1741975777
    },
    {
        "content": "<p>Natural addition and multiplication arise chiefly in CGT as the addition and multiplication of ordinals as games, but they have some connection to well-ordered sets. For instance, the ordinal sum <code>a + b</code> is the order type of the lexicographic sum of <code>a</code> and <code>b</code>, while <code>a # b</code> is the greatest order type of any well-order <code>c</code> to which <code>a</code> and <code>b</code> have order embeddings covering the entire set.</p>\n<p>There's also nice connections to the Cantor Normal Form: natural addition and multiplication correspond to adding and multiplying CNFs as if they were polynomials in omega. I've got a series of PRs proving this which have stalled for months...</p>",
        "id": 505740291,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1741976081
    },
    {
        "content": "<p>The notation is in use within the literature. My original idea was to have the operations defined on <code>Ordinal</code> for convenience, and just use the type alias <code>NatOrdinal</code> to transfer results resulting from the ordered semiring structure over. But in hindsight it would probably be nicer to just define the type alias, and make the notation <code>a # b</code> stand for <code>toOrdinal (toNatOrdinal a + toNatOrdinal b)</code>.</p>",
        "id": 505740720,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1741976251
    },
    {
        "content": "<p>I guess the move to the CGT repo would make it easier to do this refactor.</p>",
        "id": 505741474,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1741976524
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hern√°ndez</span> <a href=\"#narrow/channel/113488-general/topic/Combinatorial.20game.20theory.20repository/near/505740291\">said</a>:</p>\n<blockquote>\n<p>For instance, the ordinal sum <code>a + b</code> is the order type of the lexicographic sum of <code>a</code> and <code>b</code>, while <code>a # b</code> is the greatest order type of any well-order <code>c</code> to which <code>a</code> and <code>b</code> have order embeddings covering the entire set.</p>\n</blockquote>\n<p>Why can't I find this anywhere in mathlib? We should have</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Maximal</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"bp\">‚àÉ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Iio</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚äï</span><span class=\"w\"> </span><span class=\"n\">Iio</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"n\">Iio</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">Surjective</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚ôØ</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Maximal</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"bp\">‚àÉ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Iio</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">√ó</span><span class=\"w\"> </span><span class=\"n\">Iio</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"n\">Iio</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">Surjective</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚®≥</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Also, why does <code>‚®≥</code> not have any abbreviation?</p>",
        "id": 505747728,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741978828
    },
    {
        "content": "<p>You can't find it in Mathlib because I haven't proven it yet! But it would be a welcome addition to the CGT repo.</p>\n<p>I recently learned that it's possible to define per-repo VSCode abbreviations, so we could have something like <code>\\nmul</code> or simply <code>\\*#</code> for <code>‚®≥</code>.</p>",
        "id": 505748299,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1741979009
    },
    {
        "content": "<p>you could also contribute those to the global list, maintenance is generally quite happy to add symbols if they get use in any domain</p>",
        "id": 505748633,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1741979128
    },
    {
        "content": "<p>That's nice to hear. I remember getting some pushback from Ya√´l when I added <code>\\lf</code> for <code>‚ßè</code>.</p>",
        "id": 505748787,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1741979171
    },
    {
        "content": "<p>that was probably for using the symbol, not for registering it in abbreviations.json</p>",
        "id": 505748909,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1741979215
    },
    {
        "content": "<p>the only reason I would want to avoid putting something like that in abbreviations.json is if it's squatting a name that wants to be used for something else, or if it's a prefix of something else which is common</p>",
        "id": 505749054,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1741979274
    },
    {
        "content": "<p>It was for breaking the nice <code>\\lf</code>, <code>\\rf</code>, <code>\\lc</code>, <code>\\rc</code> series. Btw I still think we should revert it!</p>",
        "id": 505749075,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1741979281
    },
    {
        "content": "<p>ah, so both of the above then</p>",
        "id": 505749177,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1741979305
    },
    {
        "content": "<p>I'm not opposed to having that notation be exclusive to the CGT repo</p>",
        "id": 505749643,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1741979478
    },
    {
        "content": "<p>I saw this paper show up today: <a href=\"https://arxiv.org/abs/2503.16781\">https://arxiv.org/abs/2503.16781</a><br>\nIt's a fun idea, and the math is quite self-contained. I think trying to see how easily this can be directly dropped into the existing definitions would a cool test. It would be pretty neat if someone could say that they formalized a new paper within a few days of it coming out. :)</p>",
        "id": 507797177,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1742829417
    },
    {
        "content": "<p>Actually, that does seem like a relatively short paper! I should be able to at the very least get some of the first few lemmas in today.</p>",
        "id": 507894376,
        "sender_full_name": "Tristan Figueroa-Reid",
        "timestamp": 1742858814
    },
    {
        "content": "<p>Stuck in a little bit of ConcreteGame problems, but I should mention that the base game is formalized (decidability for moves was a little annoying)</p>",
        "id": 507900829,
        "sender_full_name": "Tristan Figueroa-Reid",
        "timestamp": 1742862350
    }
]