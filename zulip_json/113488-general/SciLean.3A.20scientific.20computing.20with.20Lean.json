[
    {
        "content": "<p>For quite some time I have been working on a library that would allow writing scientific computing code in Lean. As Lean can formalize mathematics, I think it is an ideal programming language for math heavy code such as physics simulation or machine learning. Either as a way more powerful glue code, like Python, or leverage its meta programming capabilities, like Julia, or why not to turn Lean into computer algebra system, like Mathematica, if it already understands lots of mathematics.</p>\n<p>I have finally arrived to a point where it makes sense to <a href=\"https://github.com/lecopivo/SciLean\">share my code</a>.</p>\n<p>Currently, I have only one working example worth mentioning and it is a simulation of wave equation, <a href=\"https://github.com/lecopivo/SciLean/blob/master/examples/WaveEquation.lean\">full code</a>:</p>\n<p>Wave equation can be defined through its Hamiltonian</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">H</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñù</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñù</span><span class=\"bp\">^</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"bp\">Œî</span><span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"bp\">/</span><span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñù</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"bp\">Œî</span><span class=\"n\">x</span><span class=\"bp\">/</span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">m</span><span class=\"o\">))</span> <span class=\"bp\">*</span> <span class=\"bp\">‚à•</span><span class=\"n\">p</span><span class=\"bp\">‚à•¬≤</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"bp\">Œî</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">k</span><span class=\"bp\">/</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"bp\">‚àë</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"bp\">‚à•</span><span class=\"n\">x</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"bp\">-</span> <span class=\"n\">x</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"bp\">‚à•¬≤</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>(it is already discretized in space)</p>\n<p>The simulation of such Hamiltonian system with Runge-Kutta 4 can be implemented with the following code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">solver</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñù</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">steps</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Impl</span> <span class=\"o\">(</span><span class=\"n\">ode_solve</span> <span class=\"o\">(</span><span class=\"n\">HamiltonianSystem</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"n\">k</span><span class=\"o\">)))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span>\n  <span class=\"c1\">-- Unfold Hamiltonian definition and compute gradients</span>\n  <span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">HamiltonianSystem</span><span class=\"o\">,</span> <span class=\"n\">H</span><span class=\"o\">]</span>\n  <span class=\"n\">autograd</span>\n  <span class=\"n\">autograd</span>\n\n  <span class=\"c1\">-- Apply RK4 method</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">ode_solve_fixed_dt</span> <span class=\"n\">runge_kutta4_step</span><span class=\"o\">]</span>\n  <span class=\"n\">lift_limit</span> <span class=\"n\">steps</span> <span class=\"s2\">\"Number of ODE solver steps.\"</span><span class=\"bp\">;</span> <span class=\"gr\">admit</span><span class=\"bp\">;</span> <span class=\"n\">simp</span>\n\n  <span class=\"n\">finish_impl</span>\n</code></pre></div>\n<p>Roughly speaking:</p>\n<ol>\n<li><code>simp[HamiltonianSystem, H]; autograd; autograd</code> expands definitions and preform symbolic differentiation</li>\n<li><code>rw [ode_solve_fixed_dt runge_kutta4_step]</code> replaces <code>noncomputable</code> function <code>ode_solve</code> with Runge-Kutta 4 integration scheme</li>\n<li><code>lift_limit steps \"Number of ODE solver steps.\"; admit; simp</code> says we are computing the specification only in an approximate sense and we choose <code>steps</code> integration steps</li>\n</ol>\n<p>This then produces this animation<br>\n<a href=\"/user_uploads/3121/ts63y6cQx0HCjRuOCZJMOze_/wave.gif\">wave.gif</a> </p>\n<p>See the <a href=\"https://github.com/lecopivo/SciLean#example-simulation-of-harmonic-oscillator\">readme</a> file for more detailed explanation. (It assumes you do not know Lean, so something might sound silly)</p>\n<hr>\n<p>The current state of the library is that I have a solid base which is capable automatically prove that function is smooth, linear or has adjoint and it can also automatically compute differentials, adjoints and gradients. To a very limited degree it can also automatically invert functions, but that is currently only used in computing adjoints of expressions involving sums, as you sometimes need to reindex sums.</p>\n<p>There is tons of directions I would like to explore: </p>\n<ol>\n<li>\n<p>Variational calculus <br>\n   The above example shows wave equation that has already been discretized in space. I want to start with the continuous version of Hamiltonian and choose the space discretization in similar fashion as I picked the time discretization with RK4.<br>\n   I have some rudimentary <a href=\"https://github.com/lecopivo/SciLean/blob/master/test/variational_calculus.lean#L21\">results with functional derivative</a>. For this purpose I have smooth/linear lambda abstraction, i.e. you can write <code>Œª (x : X) (r : ‚Ñù) ‚ä∏ r*x</code> the <code>‚ä∏</code> indicate it is a linear function in every argument. Writing <code>Œª (r : ‚Ñù) ‚ä∏ r*r</code> produces error as the function is not linear.  <a href=\"https://github.com/lecopivo/SciLean/blob/db8acbe19286ea211677d20060f511193f037090/SciLean/Categories/Lin/Hom.lean#L135\">example code</a></p>\n</li>\n<li>\n<p>Numerical Algebra<br>\n   I have already shared some of the results <a href=\"#narrow/stream/270676-lean4/topic/Interface.20for.20containers\">here</a>, it mainly provides high level interface for array/tensor like objects.<br>\n  Together with <span class=\"user-mention\" data-user-id=\"451983\">@Arthur Paulino</span>  we are working on a <a href=\"https://github.com/lecopivo/lean4-karray\">library</a> that would allow somewhat automatically generating C code for unboxed arrays like FloatArray. Hopefully this will also extends to GPUs.<br>\n  Wrapping existing linear solvers is also highly desirable.</p>\n</li>\n<li>\n<p>Symbolic manipulation with polynomials <br>\n   I want to do some computations with polynomials, differential forms and tensor products.<br>\n   One big result I want is computational isomorphism between polynomials of <code>n+1</code> variables and polynomials in one variable but values in polynomials with <code>n</code> variables  i.e. <code>ùìü[‚Ñù‚Åø‚Å∫¬π, ‚Ñù] ‚âÖ ùìü[‚Ñù, ùìü[‚Ñù‚Åø, ‚Ñù]]</code>. This way, I can easily get Horner form of a polynomial(crucial for fast evaluation) in several variables just from Horner form of polynomial in one variable.<br>\n  Some incoherent experimentation in this direction is <a href=\"https://github.com/lecopivo/SciLean/tree/master/SciLean/Math/Symbolic\">here</a></p>\n</li>\n<li>\n<p>(semi)Prismatic sets<br>\n   In physics simulation, meshes are everywhere. Most commonly triangular or simplicial meshes. I want to have unified treatment of these and want to include meshes with quads, hexes, prisms and pyramids. I call these <code>prisms</code> and they can be generated by a <code>point</code> and two operations: <code>cone</code> and <code>prod</code>. I have inductive definition <a href=\"https://github.com/lecopivo/SciLean/blob/db8acbe19286ea211677d20060f511193f037090/SciLean/Data/Mesh/Prism.lean#L6\">here</a>, for example line segment is <code>cone point</code>, square is product of two segments <code>prod (cone points) (cone point)</code>. The inclusion map of one Prism to another is represented by the inductive type <code>Prism.Face</code> and composition is <code>Face.ofFace</code>. This forms direct analog of simplex category(containing only inclusions). So I would like to define (semi)prismatic sets as presheaf over Prism category. This should be the core tool for dealing with meshes on top of which I can start building finite element/difference/volume code.</p>\n</li>\n<li>\n<p>Machine learning<br>\n   I have defined the code for <a href=\"https://github.com/lecopivo/SciLean/blob/db8acbe19286ea211677d20060f511193f037090/SciLean/Operators/Calculus/Basic.lean#L47\">forward</a> and <a href=\"https://github.com/lecopivo/SciLean/blob/db8acbe19286ea211677d20060f511193f037090/SciLean/Operators/Calculus/Basic.lean#L56\">reverse</a> mode differential operators and their core simplification identities, <a href=\"https://github.com/lecopivo/SciLean/blob/db8acbe19286ea211677d20060f511193f037090/SciLean/Operators/Calculus/ForwardDiff.lean#L27\">forward</a> and <a href=\"https://github.com/lecopivo/SciLean/blob/db8acbe19286ea211677d20060f511193f037090/SciLean/Operators/Calculus/ReverseDiff.lean#L21\">reverse</a>.  These identities are expressing nothing more then functionality of (co)tangent map between manifolds. The task is to generalize the <a href=\"https://github.com/lecopivo/SciLean/blob/master/SciLean/Operators/Calculus/Differential.lean\">identities</a> I have for normal differential to these two differential operators. Then we can hopefully unleash it on my <a href=\"https://github.com/lecopivo/SciLean/blob/master/examples/VGG.lean\">mockup of VGG</a> and hopefully get back-propagation.</p>\n</li>\n</ol>\n<hr>\n<p>I'm happy to hear any comments, suggestions. Or if anyone is interested in any of these topics I'm happy for any helping hand :) </p>\n<p>However, the current thing I should focus on is probably optimizing order/priority of all simp lemmas and type class instances. As timeouts are sometimes really bad and I'm constantly running into infinite loops.</p>",
        "id": 268135865,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1642266601
    },
    {
        "content": "<p>Wow, that's great! This is part of my Cambridge computing project, so I'll refrain to look at the code <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 268136159,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1642266945
    },
    {
        "content": "<p>Is this the first \"real\" project depending on Mathlib4?</p>",
        "id": 268136902,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1642267823
    },
    {
        "content": "<p>That's some decent amount of work <span aria-label=\"open mouth\" class=\"emoji emoji-1f62e\" role=\"img\" title=\"open mouth\">:open_mouth:</span> <br>\nThe usability of a machine learning lib is highly dependent on the existence of model deployment tools or at least a nice interactive REPL environment, so I think it would be a lower priority target at the moment</p>",
        "id": 268137687,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1642268799
    },
    {
        "content": "<p>Another big direction I want to take is to use diffeological spaces to work with manifolds. Currently, I'm working only with convenient vector spaces and smooth maps between them. Therefore, I can't for example say what is a smooth map between spaces of all invertible functions. At some point I want to formulate fluid simulation as a geodesic path on the space of all volume preserving maps.</p>\n<p>(I'm not actually fully formalizing all the math, not even providing full definitions, but I'm just peeking in to books and making sure it can be fully formalized at some point. Right now, I'm focusing on the computational aspect of it.)</p>\n<p>I have very limited understanding of diffeology, so having someone who understands it would be nice. My current idea is to maybe to work only with diffeological spaces that are quotients of vector spaces and smooth map would be defined as a quotient of a smooth map. Not sure sure if this is a completely valid but should preserve reasonably well the computational aspect. It also naturally reflects how we usually work computationally with manifolds. For example, a point on a sphere is modeled as (x,y,z) with a condition |(x,y,z)| = 1. From time to time you have to project the point back on the sphere. This projection exactly defines the relation with which you take the quotient. Computationally, this is way way better then covering sphere with some maps and working with those. </p>\n<p>Also I know there are some problems with tangent spaces of a general diffeological spaces that I do not fully understand. This probably gives some condition on the relation with which I would do the quotient. Maybe defining the relation based on a function satisfying implicit function theorem?</p>",
        "id": 268145725,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1642278845
    },
    {
        "content": "<p>I think it's really great that someone tries to do numerical analysis in Lean! I had no idea that diffeological spaces could be useful in numerical maths. I only very vaguely know them as an esoteric corner of differential geometry. I wasn't aware of any link with anything else than diffeological spaces applied to diffeological spaces.</p>",
        "id": 268148954,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1642283429
    },
    {
        "content": "<p>For example this paper on differentiable programming: <a href=\"https://dl.acm.org/doi/10.1145/3434284\">ùúÜ‚Çõ: computable semantics for differentiable programming with higher-order functions and datatypes</a> uses diffeological spaces as a tool for soundness of their method.</p>\n<p>I'm mostly following the first chapter of <a href=\"https://www.mat.univie.ac.at/~michor/apbookh-ams.pdf\">The Convenient Setting of Global Analysis</a>. I especially like the part of the introduction:</p>\n<blockquote>\n<p>An eminent mathematician once said that for infinite dimensional calculus each<br>\nserious application needs its own foundation. By a serious application one obviously<br>\nmeans some application of a hard inverse function theorem. These theorems can<br>\nbe proved, if by assuming enough a priori estimates one creates enough Banach<br>\nspace situation for some modified iteration procedure to converge. Many authors<br>\ntry to build their platonic idea of an a priori estimate into their differential calculus.<br>\nWe think that this makes the calculus inapplicable and hides the origin of the a<br>\npriori estimates. We believe that the calculus itself should be as easy to use as<br>\npossible, and that all further assumptions (which most often come from ellipticity<br>\nof some nonlinear partial differential equation of geometric origin) should be treated<br>\nseparately, in a setting depending on the specific problem</p>\n</blockquote>\n<p>This totally aligns with my experience from my studies, mostly analysis and PDEs, and the total disconnect on how mathematicians and physicist treat similar problems.</p>\n<p>All transformations in SciLean can be(hopefully will be one day) formally argued by using convenient calculus (or diffeological spaces). To actually prove any kind of convergence of the generated algorithms you then have to go and manually provide some apriory estimates, choose correct Banach/Sobolev space etc. However, this is not a task I'm particularly interested in and it is super hard(yes looking at you Navier-Stokes).</p>",
        "id": 268149656,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1642284415
    },
    {
        "content": "<p>My hope is to automatically prove consistency i.e. if the algorithm converges then it actually solves the specified problem.</p>\n<p>However, the overruling principle is to minimize the human time it takes to go from formal specification of the problem to the actually executable code.</p>",
        "id": 268149835,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1642284656
    },
    {
        "content": "<p>This is really surprising to me. It would be really super nice if this were actually useful. But I fear you'll have a very hard time finding experts here. Maybe you should email the authors of this paper and try to get them interested?</p>",
        "id": 268178397,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1642331013
    },
    {
        "content": "<p>I will try that, but maybe I should read that paper properly first :)</p>",
        "id": 268179936,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1642333642
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span> I'll mention that Ben Sherman (the first author of the paper) knows Lean -- he was an intern at Galois when we were working on formalizing a distributed protocol.</p>",
        "id": 268195086,
        "sender_full_name": "Joe Hendrix",
        "timestamp": 1642352096
    },
    {
        "content": "<p>Cool! Thanks a lot.</p>",
        "id": 268195119,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1642352145
    },
    {
        "content": "<p>ASCII art is cool but fully raytraced animations are cooler. I wrote a plugin for Houdini, software for visual effects similar to Blender,  and now I can use Lean a scripting language in it. Visualization of the wave simulation: <a href=\"/user_uploads/3121/Z0lCO-Jjyo_Y8n_HOinDitGW/wave.mp4\">wave.mp4</a></p>",
        "id": 268601196,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1642625398
    },
    {
        "content": "<p>I have cool new example to show. </p>\n<p>The task it to shoot a target with a cannon i.e. find initial velocity for ballistic motion such that it hits specified target.</p>\n<p>I wrote a widget that aims at your mouse :)<br>\n<a href=\"/user_uploads/3121/oSYLEMLqJGQSVMnTSgcizSiA/Peek-2023-05-08-17-59.gif\">Peek-2023-05-08-17-59.gif</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/oSYLEMLqJGQSVMnTSgcizSiA/Peek-2023-05-08-17-59.gif\" title=\"Peek-2023-05-08-17-59.gif\"><img src=\"/user_uploads/3121/oSYLEMLqJGQSVMnTSgcizSiA/Peek-2023-05-08-17-59.gif\"></a></div><hr>\n<p>Here a description how is it done:</p>\n<p>Ballistic motion is a solution to these differential equations:</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mtable rowspacing=\"0.25em\" columnalign=\"right left\" columnspacing=\"0em\"><mtr><mtd class =\"mtr-glue\"></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mover accent=\"true\"><mi>x</mi><mo>Àô</mo></mover></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mrow></mrow><mo>=</mo><mi>v</mi></mrow></mstyle></mtd><mtd class =\"mtr-glue\"></mtd><mtd class =\"mml-eqn-num\"></mtd></mtr><mtr><mtd class =\"mtr-glue\"></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mover accent=\"true\"><mi>v</mi><mo>Àô</mo></mover></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mrow></mrow><mo>=</mo><mi>g</mi><mo>‚àí</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>v</mi><mo stretchy=\"false\">)</mo></mrow></mstyle></mtd><mtd class =\"mtr-glue\"></mtd><mtd class =\"mml-eqn-num\"></mtd></mtr></mtable><annotation encoding=\"application/x-tex\">\\begin{align}\n\\dot x &amp;= v \\\\\n\\dot v &amp;= g - f(v)\n\\end{align}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:3em;vertical-align:-1.25em;\"></span><span class=\"mtable\"><span class=\"col-align-r\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.75em;\"><span style=\"top:-3.91em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6679em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\">x</span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.1111em;\"><span class=\"mord\">Àô</span></span></span></span></span></span></span></span></span><span style=\"top:-2.41em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6679em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.1111em;\"><span class=\"mord\">Àô</span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.25em;\"><span></span></span></span></span></span><span class=\"col-align-l\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.75em;\"><span style=\"top:-3.91em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span><span style=\"top:-2.41em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">‚àí</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mclose\">)</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.25em;\"><span></span></span></span></span></span></span></span><span class=\"tag\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.75em;\"><span style=\"top:-3.75em;\"><span class=\"pstrut\" style=\"height:2.84em;\"></span><span class=\"eqn-num\"></span></span><span style=\"top:-2.25em;\"><span class=\"pstrut\" style=\"height:2.84em;\"></span><span class=\"eqn-num\"></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.25em;\"><span></span></span></span></span></span></span></span></span></p>\n<p>where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> is some function describing air drag. In Lean this system is defined with the function <code>ballisticMotion</code> (with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>v</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mo stretchy=\"false\">(</mo><mn>5</mn><mo>+</mo><mi mathvariant=\"normal\">‚à•</mi><mi>v</mi><mi mathvariant=\"normal\">‚à•</mi><mo stretchy=\"false\">)</mo><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">f(v) = (5+\\|v\\|)v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">5</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">‚à•</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord\">‚à•</span><span class=\"mclose\">)</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">balisticMotion</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñù</span><span class=\"bp\">√ó</span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">g</span>  <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"mi\">5</span> <span class=\"bp\">+</span> <span class=\"bp\">‚Äñ</span><span class=\"n\">v</span><span class=\"bp\">‚Äñ</span><span class=\"o\">)</span> <span class=\"bp\">‚Ä¢</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>The function<code>aimToTarget</code> finds approximately the initial velocity to hit <code>target</code> at time <code>T</code>. The specification of this function is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">approx</span> <span class=\"n\">aimToTarget</span> <span class=\"o\">(</span><span class=\"n\">v‚ÇÄ</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñù</span><span class=\"bp\">√ó</span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">optimizationRate</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñù</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">Œª</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñù</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">target</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñù</span><span class=\"bp\">√ó</span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"k\">let</span> <span class=\"n\">shoot</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñù</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñù</span><span class=\"bp\">√ó</span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n                 <span class=\"n\">odeSolve</span> <span class=\"o\">(</span><span class=\"n\">t‚ÇÄ</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x‚ÇÄ</span> <span class=\"o\">:=</span> <span class=\"o\">((</span><span class=\"mi\">0</span><span class=\"o\">:</span><span class=\"n\">‚Ñù</span><span class=\"bp\">√ó</span><span class=\"n\">‚Ñù</span><span class=\"o\">),</span><span class=\"n\">v</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"n\">t</span><span class=\"o\">)</span>\n                   <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñù</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">balisticMotion</span> <span class=\"n\">x</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">v</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">shoot</span> <span class=\"n\">T</span> <span class=\"n\">v</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">‚Åª¬π</span> <span class=\"n\">target</span>\n</code></pre></div>\n<p>Where we define a local function <code>shoot</code> that returns a position an velocity of projectile at time <code>t</code> shot with initial velocity <code>v</code>.  So if we want to hit the <code>target</code> at time <code>T</code> we are interested in inverting the function <code>shoot</code>, i.e. <code>(Œª v =&gt; (shoot T v).1)‚Åª¬π target</code>.</p>\n<p>The arguments <code>v‚ÇÄ</code> and <code>optimizationRate</code> are later used as initial parameters for gradient descent.</p>\n<p>This specification is then turned into executable code using tactics. The steps are roughly follows</p>\n<ol>\n<li>Reformulate inverse as minimization and apply gradient descent</li>\n<li>Run automatic differentiation - this will formulate the adjoint problem because we are differentiating through solution of ODEs</li>\n<li>choose ODEs discretization for the forward and backward pass of the adjoint formulation</li>\n</ol>\n<p>Unfortunately, my automatic differentiation is still not working completely smoothly, so there is no neat tactic called <code>autodiff</code> but bunch of calls to <code>fun_trans</code> which is a generic tactic doing function transformations.</p>\n<p>If you want to see more details, <a href=\"https://github.com/lecopivo/SciLean/blob/3dc46361361327d6dbe21e71d0df01cfde43c8c2/examples/Ballistic.lean\">here is the code</a>.</p>",
        "id": 356825199,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1683585033
    },
    {
        "content": "<p>Does this mean that we can now apply for <a href=\"https://www.darpa.mil/\">DARPA</a> grants for widgets?</p>",
        "id": 356978922,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1683637801
    },
    {
        "content": "<p>I have a cool new picture to show <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span> I can solve Laplace equation using Lean. Here is the solution of Laplace equation in a disk with boundary condition <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi><mo stretchy=\"false\">(</mo><mi>Œ∏</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>s</mi><mi>i</mi><mi>n</mi><mo stretchy=\"false\">(</mo><mn>6</mn><mi>Œ∏</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">u(\\theta) = sin (6\\theta)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">u</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">Œ∏</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">in</span><span class=\"mopen\">(</span><span class=\"mord\">6</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">Œ∏</span><span class=\"mclose\">)</span></span></span></span>. <br>\n<a href=\"/user_uploads/3121/qFUe0MGNF5qVIOnyCHkCRTuy/harmonic.png\">harmonic.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/qFUe0MGNF5qVIOnyCHkCRTuy/harmonic.png\" title=\"harmonic.png\"><img src=\"/user_uploads/3121/qFUe0MGNF5qVIOnyCHkCRTuy/harmonic.png\"></a></div><p>You might be wondering why it is so bumpy, the thing is that I'm using a probabilistic algorithm. Let me explain how it works.</p>\n<p>The starting point is the <a href=\"https://en.wikipedia.org/wiki/Harmonic_function#The_mean_value_property\">mean value property</a> of harmonic functions(functions that satisfy Laplace equation).  It is saying that the value at the point <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span> is the average of all the values on the sphere <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>r</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">S(x,r)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose\">)</span></span></span></span></p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>u</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mfrac><mn>1</mn><mrow><mn>4</mn><mi>œÄ</mi><msup><mi>r</mi><mn>2</mn></msup></mrow></mfrac><msub><mo>‚à´</mo><mrow><mi>S</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>r</mi><mo stretchy=\"false\">)</mo></mrow></msub><mi>u</mi><mo stretchy=\"false\">(</mo><mi>y</mi><mo stretchy=\"false\">)</mo><mi>d</mi><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">u(x) = \\frac{1}{4\\pi r^2} \\int_{S(x,r)} u(y) dy</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">u</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.447em;vertical-align:-1.0869em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3214em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">4</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">œÄ</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7401em;\"><span style=\"top:-2.989em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">1</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mop\"><span class=\"mop op-symbol large-op\" style=\"margin-right:0.44445em;position:relative;top:-0.0011em;\">‚à´</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:-0.3869em;\"><span style=\"top:-1.7881em;margin-left:-0.4445em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05764em;\">S</span><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">x</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.0869em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">u</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span></span></span></span></span></p>\n<p>Inspired by this property I define this recursive function</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">harmonicRec</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">œÜ</span> <span class=\"o\">:</span> <span class=\"n\">Vec3</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Float</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Vec3</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Vec3</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">g</span> <span class=\"n\">x</span>\n  <span class=\"bp\">|</span> <span class=\"n\">m</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"mi\">4</span><span class=\"bp\">*</span><span class=\"n\">œÄ</span><span class=\"o\">)</span><span class=\"bp\">‚Åª¬π</span> <span class=\"bp\">‚Ä¢</span> <span class=\"bp\">‚à´</span> <span class=\"o\">(</span><span class=\"n\">x'</span> <span class=\"o\">:</span> <span class=\"n\">sphere</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"n\">harmonicRec</span> <span class=\"n\">m</span> <span class=\"n\">œÜ</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">œÜ</span> <span class=\"n\">x</span> <span class=\"bp\">‚Ä¢</span> <span class=\"n\">x'.1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Which recursively computes averages over the sphere at the point <code>x</code> with the radius <code>œÜ x</code>. Where <code>œÜ</code> is the distance function to the boundary and <code>g</code> defines the boundary conditions.</p>\n<p>The hope is that <code>harminicRec n œÜ g</code> converges(as <code>n ‚Üí ‚àû</code>) to the solution <code>u</code> of Laplace equation on <code>{x : œÜ | 0 &lt; œÜ x}</code> and <code>u x = g x</code> for <code>œÜ x = 0</code>.</p>\n<p>As you have noticed <code>harmonicRec</code> is a noncomputable function so let's apply Monte Carlo method to evaluate all those integrals. The resulting algorithm is called <a href=\"https://en.wikipedia.org/wiki/Walk-on-spheres_method\">walk on spheres</a>. Here is the code turning <code>harminicRec</code> into a probabilistic program:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">walkOnSpheres</span> <span class=\"o\">(</span><span class=\"n\">œÜ</span> <span class=\"o\">:</span> <span class=\"n\">Vec3</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Float</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Vec3</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Vec3</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Rand</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Rand</span> <span class=\"o\">(</span><span class=\"n\">Vec3</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"n\">derive_random_approx</span>\n      <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">harmonicRec</span> <span class=\"n\">n</span> <span class=\"n\">œÜ</span> <span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n    <span class=\"kd\">by</span>\n      <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"n\">n'</span> <span class=\"n\">prev</span> <span class=\"n\">h</span>\n        <span class=\"bp\">.</span> <span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">harmonicRec</span><span class=\"o\">]</span>\n        <span class=\"bp\">.</span> <span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">harmonicRec</span><span class=\"o\">,</span><span class=\"n\">h</span><span class=\"o\">]</span>\n          <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">smul_push</span><span class=\"o\">,</span><span class=\"n\">cintegral.arg_f.push_lambda</span><span class=\"o\">]</span>\n          <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">integral_as_uniform_E</span> <span class=\"n\">Float</span><span class=\"o\">]</span>\n      <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">pull_E_nat_recOn</span> <span class=\"o\">(</span><span class=\"n\">x‚ÇÄ</span><span class=\"o\">:=</span><span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span><span class=\"o\">:=</span><span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"o\">:=</span><span class=\"kd\">by</span> <span class=\"n\">fun_prop</span><span class=\"o\">)]</span>\n      <span class=\"n\">simp</span> <span class=\"o\">(</span><span class=\"n\">config</span><span class=\"o\">:={</span><span class=\"n\">zeta</span><span class=\"o\">:=</span><span class=\"n\">false</span><span class=\"o\">})</span>\n  <span class=\"k\">let</span> <span class=\"n\">f'</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">f</span>\n  <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">f'</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>The idea is that the <code>rw[integral_as_uniform_E Float]</code> rewrites those integrals into expectation over a uniform random variable on a sphere. Then <code>rw[pull_E_nat_recOn ...]</code> pulls all those expectations out of the recursor and you end up with an expectation of some recursively defined random variable.</p>\n<p>The resulting probabilistic program is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Nat.rec</span>\n   <span class=\"o\">(</span><span class=\"n\">pure</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Vec3</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n   <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">Rand</span> <span class=\"o\">(</span><span class=\"n\">Vec3</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Y</span><span class=\"o\">))</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n        <span class=\"k\">let</span> <span class=\"n\">u'</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">u</span>\n        <span class=\"k\">let</span> <span class=\"n\">y'</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">uniform</span> <span class=\"bp\">‚Üë</span><span class=\"o\">(</span><span class=\"n\">sphere</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">0</span><span class=\"o\">)</span>\n        <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Vec3</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>  <span class=\"n\">u'</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">œÜ</span> <span class=\"n\">x</span> <span class=\"bp\">‚Ä¢</span> <span class=\"bp\">‚Üë</span><span class=\"n\">y'</span><span class=\"o\">)))</span>\n      <span class=\"n\">n</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>which recursively defines a random function <code>u : Rand (Vec3 ‚Üí Y)</code>. At each step it samples this function <code>u'</code> and samples a random point on a sphere <code>y'</code> then returns  <code>fun x =&gt;  u' (x + œÜ x ‚Ä¢ y')</code>.</p>",
        "id": 424252633,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1709304027
    },
    {
        "content": "<p>Or here is a piggy with very cold nose but very hot ears. We can check the heat distribution in his head :)<br>\n<a href=\"/user_uploads/3121/m2hx677R6iqd2wvQiYjjqgLp/harmonicPig.png\">harmonicPig.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/m2hx677R6iqd2wvQiYjjqgLp/harmonicPig.png\" title=\"harmonicPig.png\"><img src=\"/user_uploads/3121/m2hx677R6iqd2wvQiYjjqgLp/harmonicPig.png\"></a></div>",
        "id": 424254733,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1709304624
    },
    {
        "content": "<p>After a long time and lots of mostly invisible work(making sure things scale) I have a new exciting results. Sam Estep at CMU is working on tool, <a href=\"https://github.com/gradbench/gradbench\">Gradbench</a>, to compare different automatic differentiation tools so I have preliminary results for SciLean.</p>\n<p>The benchmark I implemented is Gaussian Mixture Model(i.e. fitting data with a collection of Gaussians).</p>\n<p>Evaluation times for primal value i.e. evaluation of the loss function:</p>\n<p><a href=\"/user_uploads/3121/fulGOdX8wN7RXPkClBNWZxgn/visualization.png\">visualization.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/fulGOdX8wN7RXPkClBNWZxgn/visualization.png\" title=\"visualization.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"649x351\" src=\"/user_uploads/thumbnail/3121/fulGOdX8wN7RXPkClBNWZxgn/visualization.png/840x560.webp\"></a></div><p>Not very encouraging, SciLean is dead last here.</p>\n<p>(The plot is a bit crowded, you can go <a href=\"https://gradben.ch/\">here</a> and click on <code>gmm</code> on top left to see an interactive version of the plot)</p>\n<p>Evaluation times of the derivative:</p>\n<p><a href=\"/user_uploads/3121/dQPiWJ3qZk9vvJblyDNjsa5U/visualization-1.png\">visualization (1).png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/dQPiWJ3qZk9vvJblyDNjsa5U/visualization-1.png\" title=\"visualization (1).png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"643x351\" src=\"/user_uploads/thumbnail/3121/dQPiWJ3qZk9vvJblyDNjsa5U/visualization-1.png/840x560.webp\"></a></div><p>Encouraging, not last anymore.</p>\n<p>However, what measures the quality of automatic differentiation is the overhead introduced by computing the derivative. If we look at the ratio derivative/primal then SciLean is fairly well. For example beating Enzyme here.</p>\n<p><a href=\"/user_uploads/3121/KnJboUabAD-5zwZog4i0z1oD/visualization-2.png\">visualization (2).png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/KnJboUabAD-5zwZog4i0z1oD/visualization-2.png\" title=\"visualization (2).png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"649x351\" src=\"/user_uploads/thumbnail/3121/KnJboUabAD-5zwZog4i0z1oD/visualization-2.png/840x560.webp\"></a></div><p>One of the next step I should probably focus on is to learn how to use profiler and investigate why the evaluation of the primal value is so slow. I'm suspecting that adding few @[inline] and fixing places where I make accidental copies might take me quite far.</p>",
        "id": 503278194,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1741097639
    },
    {
        "content": "<p>I have done some profiling and implemented a new benchmark.</p>\n<p>The benchmark is k-mean clustering, which groups set of points into k groups such that this function is minimized:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">objective</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">points</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">d</span><span class=\"o\">]</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">centroids</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">d</span><span class=\"o\">]</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">‚àë·¥µ</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">min</span><span class=\"bp\">·¥µ</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">‚àë·¥µ</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">points</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"n\">l</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">centroids</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">,</span><span class=\"n\">l</span><span class=\"o\">])</span><span class=\"bp\">^</span><span class=\"mi\">2</span>\n</code></pre></div>\n<p>After some optimizations, this function compiles down to equivalent program in C and is as fast as such C program! Which is really nice assurance that it is in fact possible to set up all the abstraction such that it gets compiled away.</p>\n<p>The computation of derivative is not as fast as direct implementation in C but it is getting closer. Here is comparison to other tools:</p>\n<p><a href=\"/user_uploads/3121/HzoGXoNzjBzrwZmaLiCEPKFl/visualization-3.png\">visualization (3).png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/HzoGXoNzjBzrwZmaLiCEPKFl/visualization-3.png\" title=\"visualization (3).png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"643x383\" src=\"/user_uploads/thumbnail/3121/HzoGXoNzjBzrwZmaLiCEPKFl/visualization-3.png/840x560.webp\"></a></div>",
        "id": 506164713,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1742220944
    },
    {
        "content": "<p>I would be very curious to know what kind of optimizations those are! :) Maybe even just dropping that in a blogpost or something, I'm sure it would be a useful guide for others too... as someone who has very little sense about when Lean is slow or fast, it would be super nice to learn about a real \"in-practice\" example like this!</p>",
        "id": 506168949,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1742221830
    },
    {
        "content": "<p>Most of the magic is hidden in <code>‚àë·¥µ</code> vs mathlib's <code>‚àë</code>. To get to C level I had to do the following things:</p>\n<ul>\n<li><strong>custom Fintype</strong>: Mathlib's <code>Fintype</code> or <code>FinEnum</code> are really bad performance wise. SciLean has <code>IndexType</code> which is similar to <code>FinEnum</code> but with careful implementation. Operations with superscript <code>·¥µ</code> like <code>‚àë·¥µ</code>  are over <code>IndexType</code> rather than <code>Fintype</code>.</li>\n<li><strong>Nat</strong> vs <strong>USize</strong>: When writing raw for loops, like suming all numbers of an array, there is a noticeable performance hit for using <code>Nat</code> compared fixed size numbers like <code>USize</code>. Thus I have <code>Idx n</code> instead of <code>Fin n</code> which is based on <code>USize</code> and <code>IndexType I n</code> provides equivalence<code>I ‚âÉ Idx n</code>. I'm likely inconsistent as I probably somewhere assume that <code>Idx m √ó Idx n ‚âÉ Idx (m*n)</code>. This can be solved by making <code>Idx n</code> opaque and stating that its semantics is of <code>Fin n</code>. Lean is doing something similar already, try running <code>Array.mkArray USize.size 0</code> :)</li>\n<li><strong>external</strong> vs <strong>internal</strong> iterators: <code>IndexType</code> used to have internal iterators i.e. extended <code>Stream</code> for writing loops over finite types. This is slow. Now I have external iterators i.e. class <code>IndexType.Fold I</code> providing <code>fold/forIn</code> function over <code>I</code>.</li>\n<li><strong>inline \"everything\"</strong>: I had to inline lots of functions. An example, for <code>x : Float^[m,n]</code> the expression <code>x[i,j]</code> which is syntax sugar for <code>getElem x (i,j) (...)</code> and this should translate to <code>x.toByteArray.ugetFloat (i*n+j) (...)</code>. Also lots of the high order function,  like <code>sum : (I ‚Üí X) ‚Üí X</code> should be marked with <code>@[specialize]</code>. I still to not know when exactly should I use <code>@[inline]</code> or <code>@[specialize]</code> so I end up adding both.</li>\n</ul>\n<p>I still need to do more profiling and optimization on the derivative computation, my best Lean implementation is still 75% slower than the identical C implementation. There will be some overhead due to the fact that Lean has to do reference counter check before each mutation, but I'm not getting any substantial speed up even if I used unsafe mutation function that does not do that check. There is something I still do not understand.</p>",
        "id": 506191766,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1742226445
    },
    {
        "content": "<p>I think I have also encountered a performance bug. I have these structures</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">DataArray</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">pd</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PlainDataType</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">data</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ByteArray</span>\n<span class=\"w\">  </span><span class=\"n\">h_size</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"n\">pd</span><span class=\"bp\">.</span><span class=\"n\">bytes</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">DataArrayN</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PlainDataType</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IndexType</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">data</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DataArray</span><span class=\"w\"> </span><span class=\"n\">X</span>\n<span class=\"w\">  </span><span class=\"n\">h_size</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\">  </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Float64Array</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">data</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ByteArray</span>\n<span class=\"w\">  </span><span class=\"n\">h_size</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n</code></pre></div>\n<p>and functions to convert from <code>DataArrayN</code> to <code>Float64Array</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">toDataArrayN</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Float64Array</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DataArrayN</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Idx</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">‚ü®‚ü®</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">...‚ü©</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">...‚ü©</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">toFloat64Array</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DataArrayN</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Float64Array</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">...‚ü©</span>\n</code></pre></div>\n<p>these should compile to identity but don't seem to. I didn't check the IR but if I implement them with <code>cast sorry x</code> I get faster code.</p>",
        "id": 506197974,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1742227646
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 506215428,
        "sender_full_name": "Henrik B√∂ving",
        "timestamp": 1742231843
    },
    {
        "content": "<p>This is so cool <span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span> ! Will you also be releasing with scilean like some of these profiling benchmark tools  or is it just using gradbench?</p>",
        "id": 506379924,
        "sender_full_name": "Robert Joseph",
        "timestamp": 1742277543
    },
    {
        "content": "<p>You can find implementation of the GradBench benchmarks in  <a href=\"https://github.com/lecopivo/SciLean/tree/blas/Test/GradBench\">Test/GradBench</a> directory. Those tests are only to ensure that I still compute the same derivative. You can't easily really run those but you can have a look at the generated code for the derivative.</p>\n<p>In this <a href=\"https://github.com/lecopivo/SciLean/tree/blas/examples/Profile\">directory</a> I have tests comparing different implementations of parts of those benchmarks. They produce output like this </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">k</span><span class=\"bp\">-</span><span class=\"n\">means</span><span class=\"w\"> </span><span class=\"n\">profile</span><span class=\"w\"> </span><span class=\"n\">test</span>\n<span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1000</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">10000</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">16</span>\n\n<span class=\"n\">reference</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">impl</span><span class=\"w\">       </span><span class=\"n\">time</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mf\">40.716340</span><span class=\"n\">ms</span><span class=\"w\">  </span><span class=\"n\">loss</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mf\">7202.578688</span>\n<span class=\"n\">best</span><span class=\"w\"> </span><span class=\"n\">lean</span><span class=\"w\"> </span><span class=\"n\">impl</span><span class=\"w\">         </span><span class=\"n\">time</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mf\">44.375879</span><span class=\"n\">ms</span><span class=\"w\">  </span><span class=\"n\">loss</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mf\">7202.578688</span>\n<span class=\"n\">scilean</span><span class=\"w\"> </span><span class=\"n\">no</span><span class=\"w\"> </span><span class=\"n\">BLAS</span><span class=\"w\">        </span><span class=\"n\">time</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mf\">79.685435</span><span class=\"n\">ms</span><span class=\"w\">  </span><span class=\"n\">loss</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mf\">7202.578688</span>\n<span class=\"n\">target</span><span class=\"w\"> </span><span class=\"n\">scilean</span><span class=\"w\"> </span><span class=\"n\">impl</span><span class=\"w\">    </span><span class=\"n\">time</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mf\">1280.020544</span><span class=\"n\">ms</span><span class=\"w\">    </span><span class=\"n\">loss</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mf\">7202.578688</span>\n</code></pre></div>",
        "id": 506414196,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1742286499
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 506414654,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1742286650
    },
    {
        "content": "<p>Is there a chance it's behind because of garbage collection?</p>",
        "id": 506448705,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1742295993
    },
    {
        "content": "<p>I don't think so as I would see something like <code>lean_free_object</code> with <code>perf</code>.</p>",
        "id": 506463145,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1742300000
    }
]