[
    {
        "content": "<p>Can someone explain me why we have the <code>Fintype</code> / <code>Finite</code> distinction? I would find it nice to have a typeclass with explicit canonical enumeration of the elements (without needing choice for it) but none of it is <code>Fintype</code> / <code>Finite</code> -- <code>Finite</code> is just a <code>Prop</code>, and <code>Fintype</code> hides the order in a <code>Multiset</code>.  It can become annoying how they support different features.</p>\n<p><code>Fintype</code> often needs <code>DecidableEq</code>, such as <code>Pi.instFintype</code>. So when working with abstract finite types, it can become lengthy to add this assumption everywhere. Ok, I read the description of <code>Finite</code> saying</p>\n<blockquote>\n<p>Definitions should prefer <code>Finite</code>, unless it is important that the definitions<br>\nare meant to be computable in the reduction or <code>#eval</code> sense.</p>\n</blockquote>\n<p>so I switch to using <code>Finite</code> everywhere and hoping to not having to care... but</p>\n<ul>\n<li><code>Finite</code> doesn't have a cardinality measure like <code>Fintype.card</code>. Ok maybe I should use <code>Nat.card</code></li>\n<li>Then I cannot straightforwardly compare</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">exact?</span><span class=\"w\"> </span><span class=\"c1\">-- `exact?` could not close the goal</span>\n</code></pre></div>\n<p>(I can after some massaging of translating into <code>Set.ncard</code> or to <code>Fintype</code> but it is more steps then should be)</p>\n<ul>\n<li><code>Fintype</code> has its bundled version <code>FintypeCat</code>, not <code>Finite</code>... maybe I should just use <code>CategoryTheory.Bundled Finite</code> to work with <code>Finite</code> then?</li>\n</ul>",
        "id": 560050277,
        "sender_full_name": "Mirek Ol≈°√°k",
        "timestamp": 1764033179
    },
    {
        "content": "<p>Yes <code>Nat.card</code> is exactly what you should use. Is there a reason why you need to work with <code>Finset</code> and not <code>Set.Finite</code>?</p>",
        "id": 560051439,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1764033968
    },
    {
        "content": "<p><code>Finset</code> is to <code>Set.Finite</code> kinda like <code>Fintype</code> is to <code>Finite</code>. Although <code>Finset</code> additionally had bundled data. Mixing <code>Finite</code> and <code>Finset</code> is probably not a good idea and you might prefer to use <code>Set.Finite</code>.</p>",
        "id": 560052707,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1764034913
    },
    {
        "content": "<p>Or use <code>Fintype</code> and <code>Finset</code>. You can use e.g. <code>variable {Œ± : Type*} [Fintype Œ±] [DecidableEq Œ±]</code> to not have to repeat <code>DecidableEq</code> in every definition.</p>",
        "id": 560052874,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1764035037
    },
    {
        "content": "<p>Doesn't the doc string for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finite#doc\">docs#Finite</a> explain the benefit of <code>Finite</code>? It's a <code>Prop</code>, so you avoid the defeq issues <code>Fintype</code> and <code>DecidableEq</code> have.</p>\n<p>Something else the docstring explains is that if you need to work with <code>Fintype</code> API then you can add</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">ofFinite</span><span class=\"w\"> </span><span class=\"n\">Œ±</span>\n</code></pre></div>\n<p>For example</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">ofFinite</span><span class=\"w\"> </span><span class=\"n\">Œ±</span>\n<span class=\"w\">  </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">card_le_univ</span><span class=\"w\"> </span><span class=\"n\">s</span>\n</code></pre></div>\n<p><code>Finite</code> was added after <code>Fintype</code>, and there's been inertia switching over.</p>\n<blockquote>\n<p>I would find it nice to have a typeclass with explicit canonical enumeration of the elements</p>\n</blockquote>\n<p>An important part of <code>Fintype</code> is that up to equality there's at most one <code>Fintype</code> instance; having an explicit enumeration would be a different type. That class does exist though: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FinEnum#doc\">docs#FinEnum</a></p>",
        "id": 560053583,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1764035587
    },
    {
        "content": "<p>Thanks, I will look into <code>FinEnum</code> too.</p>",
        "id": 560053776,
        "sender_full_name": "Mirek Ol≈°√°k",
        "timestamp": 1764035711
    },
    {
        "content": "<p>What about the <code>FintypeCat</code>? Is there an intention to turn it into <code>FiniteCat</code>?</p>",
        "id": 560053824,
        "sender_full_name": "Mirek Ol≈°√°k",
        "timestamp": 1764035745
    },
    {
        "content": "<p>Sometimes bundled things are better... For example I want a mapping from X to finite types, and otherwise, I would need an universally quantified predicate... (also why I can see <code>Finset</code> useful)</p>",
        "id": 560054037,
        "sender_full_name": "Mirek Ol≈°√°k",
        "timestamp": 1764035897
    },
    {
        "content": "<p>I vaguely remember in Lean 3 trying to change <code>FintypeCat</code> to use <code>Finite</code> (well, probably <code>finite_cat</code> and <code>finite</code> back then), but the task was bigger than expected and I backed out. I'm curious if there's anyone using <code>FintypeCat</code> to do an actual computation.</p>\n<p>I think it would be good to have a <code>FiniteSet</code> type that bundles a <code>Set</code> with a <code>Set.Finite</code> proof, a benefit being that you can use standard set operations on the <code>FiniteSet</code> without needing to construct a <code>Set.Finite</code> proof in parallel.</p>",
        "id": 560055905,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1764037303
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> Can you explain why people want to switch over to <code>Finite</code>? Tbh, I feel like we don't need <code>Finite</code>. We can just use <code>Fintype</code> and when you're working with type for which you can't create instance of <code>Fintype</code>, only <code>Finite</code>, then you can use <code>open Classical</code> and mark definitions as <code>noncomputable</code> to be able to use <code>Fintype</code>.</p>",
        "id": 560056351,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1764037711
    },
    {
        "content": "<p>I believe it has something to do with the fact that <code>Fintype</code> instances are data and therefore not automatically equal to each other... this can lead to some annoying instance conflicts</p>",
        "id": 560057884,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1764038723
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"870257\">@Jakub Nowak</span> That often leads to typeclass inference picking up the wrong instances and you getting stuck in frustrating ways.</p>\n<p>Let me flip the question: why not Finite everywhere, and leave Fintype for programming or applications of proof by reflection? If we started with Finite, do you think you would be able to convince mathematical users that \"open Classical\" is a necessary evil?</p>\n<p>Consider also that instance search is lighter weight for Finite and more likely to succeed. It doesn't need to look for DecidableEq instances nor do any defeq checks, since it's just a Prop.</p>",
        "id": 560058106,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1764038806
    },
    {
        "content": "<p>I would have another <code>Fintype</code> suggestion -- what if <code>Fintype</code> required <code>DecidableEq</code> inside? Are there examples where it is useful to have <code>Fintype</code> without decidable equality?</p>",
        "id": 560059852,
        "sender_full_name": "Mirek Ol≈°√°k",
        "timestamp": 1764040027
    },
    {
        "content": "<p>well when you do <code>fin_cases</code> of course</p>",
        "id": 560059895,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764040067
    },
    {
        "content": "<p>I mean an example of a type with <code>Fintype</code> instance which doesn't have decidable equality.</p>",
        "id": 560059967,
        "sender_full_name": "Mirek Ol≈°√°k",
        "timestamp": 1764040117
    },
    {
        "content": "<p>that would be <code>Prop</code></p>",
        "id": 560059976,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764040127
    },
    {
        "content": "<p>Oh, I see...</p>",
        "id": 560060013,
        "sender_full_name": "Mirek Ol≈°√°k",
        "timestamp": 1764040164
    },
    {
        "content": "<p>As a very quick summary, <code>Fintype</code> is data (it contains an explicit enumeration of all elements of the type), whereas <code>Finite</code> is just a mathematical proposition.</p>",
        "id": 560150640,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1764076438
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hern√°ndez</span> <a href=\"#narrow/channel/113488-general/topic/Fintype.20vs.2E.20Finite/near/560150640\">said</a>:</p>\n<blockquote>\n<p>As a very quick summary, <code>Fintype</code> is data (it contains an explicit enumeration of all elements of the type), whereas <code>Finite</code> is just a mathematical proposition.</p>\n</blockquote>\n<p>I find this exact explanation confusing for the reason I was writing in the original post -- it does not contain an <em>explicit</em> enumeration, as discussed the difference between <code>Fintype</code> and <code>FinEnum</code></p>",
        "id": 560206610,
        "sender_full_name": "Mirek Ol≈°√°k",
        "timestamp": 1764089806
    },
    {
        "content": "<p>it does contain an explicit enumeration but you're not allowed to use it unless the result is independent of which enumeration you have</p>",
        "id": 560207401,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764090003
    },
    {
        "content": "<p>That is actually a sensible explanation. Although, you could also say that <code>Finite</code> contains an explicit enumeration but you're not allowed to use it unless the result is a proof...</p>",
        "id": 560209205,
        "sender_full_name": "Mirek Ol≈°√°k",
        "timestamp": 1764090506
    },
    {
        "content": "<p>Yes, but that is different.</p>",
        "id": 560377631,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1764160029
    },
    {
        "content": "<p><code>FinEnum</code> is like, \"my type is finite and I've picked an ordering for it - this is the ordering\".<br>\n<code>Fintype</code> is \"my type is finite and I've got a representation of it as a finite set - it isn't ordered though\"<br>\n<code>Finite</code> is \"my type is finite, it has some size - I'm not going to tell you what though\".</p>",
        "id": 560377851,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1764160104
    },
    {
        "content": "<p>If in pen and paper mathematics you would say \"let <code>x_i = x_0, x_1, .., x_{n-1}</code> be a finite sequence\", then that is <code>FinEnum</code>.<br>\nIf in pen and paper mathematics you would say \"let x_i be elements indexed by this finite set S\", then that is <code>FinSet</code>.<br>\nIf in pen and paper mathematics you would say \"Let the set S be finite\" then that is <code>Finite</code>. </p>\n<p>This isn't perfect but I think it has the right form.</p>",
        "id": 560378405,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1764160268
    },
    {
        "content": "<p>Thanks, I think I understand it now. Although, I would say that pen &amp; paper cannot distinguish <code>Finite</code> &amp; <code>Fintype</code> because in standard mathematics, you get unique choice by default (there might be an official name I don't remember). If you say \"there exists unique x\", you just take it without hesitation (without any worry about axiom of choice). <code>Finite</code> says \"There exists unique representation of the type as a finite set\", and <code>Fintype</code> is the order-less finite set.</p>\n<p>As far as I understand, Lean doesn't really care about choice / unique choice distinction but it distinguishes \"having something\" and \"knowing it uniquely exists\" for calculation purposes.</p>",
        "id": 560410166,
        "sender_full_name": "Mirek Ol≈°√°k",
        "timestamp": 1764168835
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/channel/113488-general/topic/Fintype.20vs.2E.20Finite/near/560378405\">said</a>:</p>\n<blockquote>\n<p>If in pen and paper mathematics you would say \"let <code>x_i = x_0, x_1, .., x_{n-1}</code> be a finite sequence\", then that is <code>FinEnum</code>.<br>\nIf in pen and paper mathematics you would say \"let x_i be elements indexed by this finite set S\", then that is <code>FinSet</code>.<br>\nIf in pen and paper mathematics you would say \"Let the set S be finite\" then that is <code>Finite</code>. </p>\n<p>This isn't perfect but I think it has the right form.</p>\n</blockquote>\n<p>Though I think I've quite often seen the first phrasing where the order was completely irrelevant.</p>",
        "id": 560428409,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1764173362
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/channel/113488-general/topic/Fintype.20vs.2E.20Finite/near/560378405\">said</a>:</p>\n<blockquote>\n<p>If in pen and paper mathematics you would say \"let <code>x_i = x_0, x_1, .., x_{n-1}</code> be a finite sequence\", then that is <code>FinEnum</code>.<br>\nIf in pen and paper mathematics you would say \"let x_i be elements indexed by this finite set S\", then that is <code>FinSet</code>.<br>\nIf in pen and paper mathematics you would say \"Let the set S be finite\" then that is <code>Finite</code>. </p>\n<p>This isn't perfect but I think it has the right form.</p>\n</blockquote>\n<p>I think this just makes things more confusing. For me, when looking from the mathematics perspective, all three are equivalent. I think, the differentiation of <del><code>FinEnum</code></del> /<code>Fintype</code>/<code>Finite</code> just doesn't exists in mathematics.<br>\nEDIT: Well, nvm about <code>FinEnum</code>, if you have an ordering, you can make a statement about this particular ordering, that would depend on the ordering chosen. Although, I can't find a difference between <code>Fintype</code> and <code>Finite</code> from mathematics perspective. In some sense, there's no difference in Lean either, because one can convert between the two noncomputably. So I guess the problem is that there's no \"computable\" in mathematics?</p>",
        "id": 560436924,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1764175755
    },
    {
        "content": "<p>Yeah <span class=\"user-mention\" data-user-id=\"133339\">@Mirek Ol≈°√°k</span>, standard mathematics doesn't distinguish between constructions and unique existence. In ZF foundations, there's no computational content to it. It's easy to forget that whenever you write an expression with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> in it, since functions aren't primitive, implicitly you are introducing a universal quantifier (that's to say, if you have an expression <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">P(f(x))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">))</span></span></span></span>, it stands for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">‚àÄ</mi><mi>y</mi><mo>‚àà</mo><mi>Y</mi><mo separator=\"true\">,</mo><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo stretchy=\"false\">)</mo><mo>‚àà</mo><mi>f</mi><mo>‚Üí</mo><mi>P</mi><mo stretchy=\"false\">(</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\forall y\\in Y, (x,y)\\in f\\to P(y)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\">‚àÄ</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚àà</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚àà</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚Üí</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span></span></span></span>). It's not evaluating the function exactly ‚Äî you don't have \"the\" element.</p>\n<p>So, I'd push back a bit on standard mathematics letting you \"just take [the element] without hesitation\". Certainly there's no hesitation in doing the above sort of transformation, but it does make you wonder what it means to <em>just</em> take the element. Similarly, when you suggested that <code>Finite</code> contains an explicit enumeration <span class=\"user-mention\" data-user-id=\"133339\">@Mirek Ol≈°√°k</span>, I would counter that it only stands for the mere evidence that if you do the above sort of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">‚àÄ</mi></mrow><annotation encoding=\"application/x-tex\">\\forall</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">‚àÄ</span></span></span></span> transformation then the quantification will find an explicit enumeration, rather than <code>Finite</code> <em>containing</em> the enumeration itself.</p>\n<p>In Lean, constructions are a native concept, and that's a big enough difference that (in my opinion) it's hard to truly compare what \"axiom of (unique) choice\" means between each system. As you said, with constructions you can actually \"have something\" instead of only knowing it exists. I'd also counter that standard mathematics does (or at least could) distinguish between <code>Finite</code> and <code>Fintype</code>, but there's usually not much point to;  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Fintype</mi><mo>‚Å°</mo><mo stretchy=\"false\">(</mo><mi>S</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\operatorname{Fintype}(S)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">Fintype</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mclose\">)</span></span></span></span> would be the set of pairs <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>e</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(n,e)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mclose\">)</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>‚àà</mo><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">n\\in\\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚àà</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>e</mi></mrow><annotation encoding=\"application/x-tex\">e</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">e</span></span></span></span> is an element of the quotient of the set of bijections <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mn>0</mn><mo separator=\"true\">,</mo><mo>‚Ä¶</mo><mo separator=\"true\">,</mo><mi>n</mi><mo>‚àí</mo><mn>1</mn><mo stretchy=\"false\">}</mo><mo>‚Üí</mo><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">\\{0,\\dots,n-1\\}\\to S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">‚Ä¶</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">‚àí</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">}</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚Üí</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> by the action of the symmetric group on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mn>0</mn><mo separator=\"true\">,</mo><mo>‚Ä¶</mo><mo separator=\"true\">,</mo><mi>n</mi><mo>‚àí</mo><mn>1</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{0,\\dots,n-1\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">‚Ä¶</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">‚àí</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">}</span></span></span></span>. If you define a function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Fintype</mi><mo>‚Å°</mo><mo stretchy=\"false\">(</mo><mi>S</mi><mo stretchy=\"false\">)</mo><mo>‚Üí</mo><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">\\operatorname{Fintype}(S)\\to T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">Fintype</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚Üí</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span> you'll need to make use of the universal property of the quotient if you want access to a specific bijection in your definition, or otherwise choose a fixed representative from the equivalence class by some means.</p>\n<p>In standard mathematics, you don't need to invoke the axiom of choice to get a witness from an existential. That's because of the above sort of transformation: the rule of inference involved when you \"take\" a witness is that to prove <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">‚àÉ</mi><mi>x</mi><mo separator=\"true\">,</mo><mi>P</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo>‚Üí</mo><mi>Q</mi></mrow><annotation encoding=\"application/x-tex\">(\\exists x, P(x))\\to Q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">‚àÉ</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">))</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚Üí</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">Q</span></span></span></span> it suffices to prove <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">‚àÄ</mi><mi>x</mi><mo separator=\"true\">,</mo><mi>P</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>‚Üí</mo><mi>Q</mi></mrow><annotation encoding=\"application/x-tex\">\\forall x, P(x) \\to Q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">‚àÄ</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚Üí</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">Q</span></span></span></span>. The same goes for Lean.</p>\n<p>The axiom of choice in Lean only applies when you want to use witnesses to existentials as if they are actual constructions (granted, that's a lot of power, and it's strong enough to prove the ZFC-style axiom of choice; basically that if you have a forall-exists, you can deduce exists-forall by assembling all the witnesses using a function). In simpler cases, <code>Classical.choice</code> is sort of a way to say \"let's apply a ZF-style function\", one that was defined by proving existence of an output value, rather than actually invoking ZFC choice. I wouldn't be surprised if a lot of <code>noncomputable</code> functions in Lean are using <code>Classical.choice</code> this way, in the sense that from within proofs <code>Classical.choice</code> could be eliminated if you expanded all the definitions.</p>\n<p>I think my point here (not directed to you Mirek, I'm writing primarily to make sense of all this) is that, first, just because a Lean function uses <code>Classical.choice</code> doesn't mean you would need to invoke ZFC choice in standard mathematics, and, second, you can in principle avoid constructions and native Lean functions and use ZF-style functions (subsets of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>√ó</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A\\times B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">√ó</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span>) instead ‚Äî it would be horrible without some elaborator to do it, but in any case I think it's worth recognizing that the Lean type <code>A -&gt; B</code> is <em>conventionally</em> used to model the set of all ZF functions (which is justifiable using <code>Classical.choice</code>), especially when you're thinking about the role of choice in each logical system.</p>",
        "id": 560448190,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1764179605
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/113488-general/topic/Fintype.20vs.2E.20Finite/near/560448190\">said</a>:</p>\n<blockquote>\n<p>if you have an expression <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">P(f(x))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">))</span></span></span></span>, it stands for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">‚àÄ</mi><mi>y</mi><mo>‚àà</mo><mi>Y</mi><mo separator=\"true\">,</mo><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo stretchy=\"false\">)</mo><mo>‚àà</mo><mi>f</mi><mo>‚Üí</mo><mi>P</mi><mo stretchy=\"false\">(</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\forall y\\in Y, (x,y)\\in f\\to P(y)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\">‚àÄ</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚àà</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚àà</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚Üí</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span></span></span></span></p>\n</blockquote>\n<p>It seems you just made me realize something about set theory that I never realized before! Given that ZF is defined as a theory in FOL, I simply assumed that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">P(f(x))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">))</span></span></span></span> was a call of a function symbol inside a call of a relation symbol (in the first-order sense). I was wrong! What really goes on is that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> are just members of the universe (because they both are sets) and you cannot \"call\" any functions in set theory!</p>\n<p>Please let me know if I got it wrong again.</p>",
        "id": 560450281,
        "sender_full_name": "Martin Dvo≈ô√°k",
        "timestamp": 1764180424
    },
    {
        "content": "<p>yeah ZF in the presentation I usually see it has no function symbols</p>",
        "id": 560450582,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764180553
    },
    {
        "content": "<p>you can convert the axioms of union, pairing, replacement, etc. into function symbols</p>",
        "id": 560450697,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764180603
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"417654\">@Martin Dvo≈ô√°k</span> I thought I'd mention that another valid translation to eliminate the definition of function application is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">‚àÉ</mi><mi>y</mi><mo>‚àà</mo><mi>Y</mi><mo separator=\"true\">,</mo><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo stretchy=\"false\">)</mo><mo>‚àà</mo><mi>f</mi><mo>‚àß</mo><mi>P</mi><mo stretchy=\"false\">(</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\exists y\\in Y, (x,y)\\in f\\land P(y)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\">‚àÉ</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚àà</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚àà</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">‚àß</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span></span></span></span>. (The forall version is to skolemization as this one is to herbrandization.)</p>",
        "id": 560451341,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1764180864
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"870257\">Jakub Nowak</span> <a href=\"#narrow/channel/113488-general/topic/Fintype.20vs.2E.20Finite/near/560436924\">said</a>:</p>\n<blockquote>\n<p>In some sense, there's no difference in Lean either, because one can convert between the two noncomputably. So I guess the problem is that there's no \"computable\" in mathematics?</p>\n</blockquote>\n<p>Yes, that's the underlying issue... except that there is no actual _problem_ ! There is just a distinction and, as is typical, this distinction is useful to some but not to others.</p>",
        "id": 560522155,
        "sender_full_name": "Fran√ßois G. Dorais",
        "timestamp": 1764224160
    },
    {
        "content": "<p>The problem is that whenever there is a distinction of two almost identical concepts, an annoyance arises from each of these concepts supporting a bit different features, and conversion is annoying.</p>",
        "id": 560541635,
        "sender_full_name": "Mirek Ol≈°√°k",
        "timestamp": 1764233191
    },
    {
        "content": "<p>On the other hand, the distinction between unique choice, and choice is a bit awkwardly missing. I would find it sometimes more philosophically satisfying to know I am using only unique choice in definitions, so that the values will not depend on particular values of the choice function.</p>",
        "id": 560542383,
        "sender_full_name": "Mirek Ol≈°√°k",
        "timestamp": 1764233446
    },
    {
        "content": "<p>And to all the ZFC discussion, I would add that ZFC models functions by uniqueness.</p>\n<ul>\n<li>small functions are defined as binary relations with unique <code>y</code> for each <code>x</code></li>\n<li>the axiom of replacement conditions the class function used the same way -- for each <code>x</code> there must be at most one <code>y</code></li>\n</ul>",
        "id": 560544012,
        "sender_full_name": "Mirek Ol≈°√°k",
        "timestamp": 1764233982
    },
    {
        "content": "<p>Maybe, instead of having to make this distinction manually it would make sense to have this distinction be part of the language? Isn't <code>Finite</code> just noncomputable instance of <code>Fintype</code>? And it could work like, in computable function argument <code>[Fintype s]</code> will refer to computable instance, but in noncomputable function, it would refer to noncomputable instance. And we would need syntax like e.g. <code>[noncomputable Fintype s]</code> to refer to noncomputable instance in computable function.</p>",
        "id": 560644238,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1764263823
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"870257\">Jakub Nowak</span> <a href=\"#narrow/channel/113488-general/topic/Fintype.20vs.2E.20Finite/near/560644238\">said</a>:</p>\n<blockquote>\n<p>Isn't <code>Finite</code> just noncomputable instance of <code>Fintype</code>?</p>\n</blockquote>\n<p>No it's not ‚Äî <code>Finite</code> is a proposition, so instances of it are definitionally equal. <a class=\"message-link\" href=\"/#narrow/channel/113488-general/topic/Fintype.20vs.2E.20Finite/near/560057884\">#general &gt; Fintype vs. Finite @ üí¨</a></p>",
        "id": 560644399,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1764263893
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/113488-general/topic/Fintype.20vs.2E.20Finite/near/560058106\">said</a>:</p>\n<blockquote>\n<p>That often leads to typeclass inference picking up the wrong instances and you getting stuck in frustrating ways.</p>\n</blockquote>\n<p><code>Fintype</code> has unique instance up to quotient, so I don't thing there are better or worse instances in this case?</p>\n<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/113488-general/topic/Fintype.20vs.2E.20Finite/near/560058106\">said</a>:</p>\n<blockquote>\n<p>Let me flip the question: why not Finite everywhere, and leave Fintype for programming or applications of proof by reflection? If we started with Finite, do you think you would be able to convince mathematical users that \"open Classical\" is a necessary evil?</p>\n</blockquote>\n<p>Not sure what's your point? What's evil in \"open Classical\"? If we switch to <code>Finite</code> everywhere, then you would need to use classical logic whenever you want to get the elements.</p>",
        "id": 560645581,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1764264404
    },
    {
        "content": "<p>Yes, I am saying what I'm saying while aware that <code>Fintype</code> is a subsingleton type. Even though <code>Fintype</code> is a subsingleton, two instances of <code>Fintype T</code> might not be <em>definitionally</em> equal. This means that expressions fail to unify. This problem is painfully well-known to people who use <code>Fintype</code> frequently, and it's why we have tactics like <code>convert</code> to try to get around it. This tactic inserts rewrites to unify two terms that are only propositionally equal.</p>\n<p>If Lean were an \"extensional\" system ‚Äî where if terms are propositionally equal then they're definitionally equal ‚Äî then theoretically the problem goes away, but that comes with its own problems.</p>",
        "id": 560646011,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1764264577
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"870257\">Jakub Nowak</span> <a href=\"#narrow/channel/113488-general/topic/Fintype.20vs.2E.20Finite/near/560645581\">said</a>:</p>\n<blockquote>\n<p>If we switch to <code>Finite</code> everywhere, then you would need to use classical logic whenever you want to get the elements.</p>\n</blockquote>\n<p>That's partly true (in proofs you can use <code>obtain</code> to get a particular enumeration without classical logic), but even if it took classical logic, would that be something mathematicians would care about? Mathlib is largely focused on formalizing (classical) mathematics. (Classical's in parentheses because mathematicians think \"classical\" means math from the Greeks, or sometimes even from just a few decades ago.)</p>",
        "id": 560646474,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1764264688
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek Ol≈°√°k</span> <a href=\"#narrow/channel/113488-general/topic/Fintype.20vs.2E.20Finite/near/560542383\">said</a>:</p>\n<blockquote>\n<p>On the other hand, the distinction between unique choice, and choice is a bit awkwardly missing.</p>\n</blockquote>\n<p>I've thought about that too. It would be possible to create a linter that determines whether or not a defined Lean function is \"mathematical\", by which I mean something like your suggestion, though I'm struggling to define it concisely.</p>\n<p>Recall that what <code>noncomputable</code> means is that the Lean compiler failed to find a way to create some C code that computes the same thing, in some sense. It fails if any <code>noncomputable</code> functions are used in computationally relevant way. (In mathematics, values and types are relevant, but proofs are not. Possibly propositions aren't relevant either.)</p>\n<p>I'm imagining <code>@[nonmathematical]</code> would mean that the \"mathematics\" compiler wasn't able to construct a defining equation that makes use of only \"mathematical\" functions; it would fail if <code>nonmathematical</code> functions are used in a mathematically relevant way.</p>\n<p>So, for example, <code>Classical.choice</code> would be marked <code>nonmathematical</code>. There could be a unique choice function that the linter recognizes as mathematical:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Subsingleton</span><span class=\"bp\">.</span><span class=\"n\">choice</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Subsingleton</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">choice</span><span class=\"w\"> </span><span class=\"bp\">‚Äπ</span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"bp\">‚Ä∫</span>\n</code></pre></div>\n<p>The \"mathematical compiler\" could have a rule where it attempts to upgrade <code>Classical.choice</code> to <code>Subsingleton.choice</code> by synthesizing a <code>Subsingleton</code> instance, rather than outright fail.</p>\n<p>I think the basic algorithm would be to check that every constant in the definition is not marked <code>nonmathematical</code>, ignoring those constants that appear inside of proofs.</p>\n<p>Possibly there are some transformations you'd want it to do to avoid some false negatives. Here's a contrived example, but there are real cases of this out there:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">choose</span>\n<span class=\"w\">  </span><span class=\"bp\">‚ü®</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">...</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">proof</span><span class=\"w\"> </span><span class=\"n\">that</span><span class=\"w\"> </span><span class=\"n\">uses</span><span class=\"w\"> </span><span class=\"ss\">`inst</span><span class=\"bp\">`</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">reason</span><span class=\"w\"> </span><span class=\"bp\">...‚ü©</span>\n</code></pre></div>\n<p>You could avoid flagging it <code>nonmathematical</code> by realizing <code>inst</code> is only used in proofs. A simple way to deal with this is to zeta and beta reduce everything before doing the check.</p>",
        "id": 560651207,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1764266625
    },
    {
        "content": "<p>Speaking of unique choice, I am working in a project where I want to avoid choice but I added unique choice, and so far even tactics like <code>ring</code> usually don't create problems</p>",
        "id": 560652354,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1764266993
    },
    {
        "content": "<p>but what about <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Setoid.piQuotientEquiv#doc\">docs#Setoid.piQuotientEquiv</a></p>",
        "id": 560652397,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764267006
    },
    {
        "content": "<p>Yes, some <code>nonmathematical</code> like this makes sense. Regarding the example of building an instance outside of a proof but only using it in a proof, it could be dealt with by  also tracing parts of the local context as <code>nonmathematical</code></p>",
        "id": 560656234,
        "sender_full_name": "Mirek Ol≈°√°k",
        "timestamp": 1764269004
    },
    {
        "content": "<p>Perhaps it could be called <code>ambiguous</code> instead</p>",
        "id": 560659309,
        "sender_full_name": "Mirek Ol≈°√°k",
        "timestamp": 1764270713
    },
    {
        "content": "<p>I do find the definitions of these things and the distinctions useful from my perspective, a semi-mathematical one</p>",
        "id": 560664546,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1764273513
    },
    {
        "content": "<p>It's just good moral hygiene to make sure you aren't e.g. arbitrarily assuming an order for no reason</p>",
        "id": 560664568,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1764273535
    },
    {
        "content": "<p>I think that learning to use Lean to formalise maths has made me a better mathematician</p>",
        "id": 560664685,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1764273614
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek Ol≈°√°k</span> <a href=\"#narrow/channel/113488-general/topic/Fintype.20vs.2E.20Finite/near/560659309\">said</a>:</p>\n<blockquote>\n<p>Perhaps it could be called <code>ambiguous</code> instead</p>\n</blockquote>\n<p>Or <code>@[arbitrary]</code> to signify an arbitrary choice is made.</p>\n<p>I'd actually like to see this exist. There are some arbitrary functions in mathlib, like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Subspace.dualLift#doc\">docs#Subspace.dualLift</a>, where it would be nice to know that it's arbitrary and that anything using it in a relevant way is also arbitrary. Right now it's arbitrariness is recorded only in the docstring.</p>",
        "id": 560666497,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1764274755
    },
    {
        "content": "<p>What is an example of a noncomputable function that does not arise from an arbitrary choice, out of interest?</p>",
        "id": 560737356,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1764321115
    },
    {
        "content": "<p>the lean annotation <code>noncomputable</code> or the computer science idea of noncomputable?</p>",
        "id": 560737616,
        "sender_full_name": "Henrik B√∂ving",
        "timestamp": 1764321186
    },
    {
        "content": "<p>Does either of:</p>\n<p>halts : TuringMachine -&gt; bool<br>\nnot_halts: TuringMachine -&gt; bool</p>\n<p>satisfy the requirement via proof of the Halting problem ?</p>\n<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/channel/113488-general/topic/Fintype.20vs.2E.20Finite/near/560737356\">said</a>:</p>\n<blockquote>\n<p>What is an example of a noncomputable function that does not arise from an arbitrary choice, out of interest?</p>\n</blockquote>",
        "id": 560738378,
        "sender_full_name": "TongKe Xue",
        "timestamp": 1764321416
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/channel/113488-general/topic/Fintype.20vs.2E.20Finite/near/560737356\">said</a>:</p>\n<blockquote>\n<p>What is an example of a noncomputable function that does not arise from an arbitrary choice, out of interest?</p>\n</blockquote>\n<p>For example <code>Nat.card</code>, <code>deriv</code>, or <code>tsum</code> (although analysis is a bit tricky, sometimes the dummy values are taken by choice). In general any function which splits on a non-computable proposition would satisfy the criteria, so one of the most fundamental non-computable non-arbitrary functions is <code>Classical.propDecidable</code>.</p>",
        "id": 560741486,
        "sender_full_name": "Mirek Ol≈°√°k",
        "timestamp": 1764322395
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik B√∂ving</span> <a href=\"#narrow/channel/113488-general/topic/Fintype.20vs.2E.20Finite/near/560737616\">said</a>:</p>\n<blockquote>\n<p>the lean annotation <code>noncomputable</code> or the computer science idea of noncomputable?</p>\n</blockquote>\n<p>The former!</p>",
        "id": 560742101,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1764322577
    },
    {
        "content": "<p>And besides splitting on a Prop value, also functions that extract the unique data from a propositions, such as the <code>Fintype.ofFinite</code> discussed here, or <code>Equiv.ofBijective</code></p>",
        "id": 560742722,
        "sender_full_name": "Mirek Ol≈°√°k",
        "timestamp": 1764322796
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/channel/113488-general/topic/Fintype.20vs.2E.20Finite/near/560742101\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik B√∂ving</span> <a href=\"#narrow/channel/113488-general/topic/Fintype.20vs.2E.20Finite/near/560737616\">said</a>:</p>\n<blockquote>\n<p>the lean annotation <code>noncomputable</code> or the computer science idea of noncomputable?</p>\n</blockquote>\n<p>The former!</p>\n</blockquote>\n<p>Any function that calls a recursor that is not <code>False.rec</code>,  any function that makes the compiler error for various reasons etc. <code>noncomputable</code> has no meaning in the theory world.</p>",
        "id": 560752131,
        "sender_full_name": "Henrik B√∂ving",
        "timestamp": 1764325848
    },
    {
        "content": "<p>I think tensor products are still noncomputable because they used to take too long to compile</p>",
        "id": 560758659,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764327751
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/113488-general/topic/Fintype.20vs.2E.20Finite/near/560644399\">said</a>:</p>\n<blockquote>\n<p>No it's not ‚Äî <code>Finite</code> is a proposition, so instances of it are definitionally equal. <a class=\"message-link\" href=\"/#narrow/channel/113488-general/topic/Fintype.20vs.2E.20Finite/near/560057884\">#general &gt; Fintype vs. Finite @ üí¨</a></p>\n</blockquote>\n<p>Can't we have all noncomputable Subsingletons (instances of) be definitionally equal?</p>",
        "id": 560835503,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1764352382
    },
    {
        "content": "<p>not if you can get data out</p>",
        "id": 560835678,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764352475
    },
    {
        "content": "<p>How can you get data out of noncomputable definition?</p>",
        "id": 560835723,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1764352502
    },
    {
        "content": "<p><code>noncomputable</code> is for the compiler, and it does not have meaning for the elaborator or the kernel.</p>",
        "id": 560835784,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1764352526
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n\n<span class=\"c1\">-- k : Nat</span>\n<span class=\"c1\">-- this is data</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">k</span>\n</code></pre></div>",
        "id": 560835880,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764352576
    },
    {
        "content": "<p>In fact, <code>#reduce k</code> shows <code>1</code></p>",
        "id": 560835929,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1764352601
    },
    {
        "content": "<p>Ah, I see. I thought that noncomputable vs computable is like a difference between exists and sigma pair.</p>",
        "id": 560835935,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1764352603
    },
    {
        "content": "<p>Even if it were <span class=\"user-mention\" data-user-id=\"870257\">@Jakub Nowak</span>, it's still problematic. Using a <code>Type</code> instance like <code>Fintype</code> along with the <code>Classical</code> instance leads to \"diamonds\" very easily. Imagine on one hand having the Classical instance for the Cartesian product, and on the other having the instance that combines the Classical instances for each factor. These are not definitionally equal.</p>",
        "id": 560836190,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1764352726
    },
    {
        "content": "<p>(Incidentally <span class=\"user-mention\" data-user-id=\"133339\">@Mirek Ol≈°√°k</span>, this diamond issue is a reason having <code>Fintype</code> carry a <code>DecidableEq</code> instance can be problematic, at least if <code>Fintype</code> can provide <code>DecidableEq</code> instances. You have to make sure both the <code>DecidableEq</code> and <code>Fintype</code> hierarchies agree on the <code>DecidableEq</code> instances. For what it's worth, people have pointed out before that <code>Fintype</code> is in a strange spot constructively, since it's not sufficient on its own for getting an element of <code>Trunc ((n : Nat) √ó (Œ± ‚âÉ Fin n))</code>, without the additional decidable equality. All it can do is give you <code>Trunc ((n : Nat) √ó {f : Fin n ‚Üí Œ± // Function.Bijective f})</code>. I suppose <code>Fintype</code> just captures the least you need to represent the universe as a <code>List</code>, and it's reasonable for definitions to require <code>DecidableEq</code> separately if they need it to be the \"real\" <code>Fintype</code>. As far as I'm aware, <code>Fintype</code> is not designed specifically to make a <code>Fintype Prop</code> instance ‚Äî it's just convenient that it works out.)</p>",
        "id": 560837454,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1764353342
    },
    {
        "content": "<p>If <code>Fintype</code> was simply extending <code>DecidableEq</code>, it should work out fine, no? I thought such class extensions are reasonably immune to diamonds...</p>",
        "id": 560838134,
        "sender_full_name": "Mirek Ol≈°√°k",
        "timestamp": 1764353685
    },
    {
        "content": "<p>It doesn't make it immune, but it helps. (That said, <code>DecidableEq</code> isn't a structure, it's a pi type, and Lean doesn't allow extending non-structures.)</p>",
        "id": 560838402,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1764353812
    },
    {
        "content": "<p>By the way, I didn't know about <code>Trunc</code> but it made me realize that the standard choice axiom could be split into the unique and mathematical part as</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">uniqueChoice</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Trunc</span><span class=\"w\"> </span><span class=\"n\">Œ±</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">mathChoice</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Trunc</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Œ±</span>\n</code></pre></div>",
        "id": 560839098,
        "sender_full_name": "Mirek Ol≈°√°k",
        "timestamp": 1764354182
    },
    {
        "content": "<p>And with extending non-structures, you also reminded me how I was pondering about the difference between <code>WellFounded</code> and <code>IsWellFounded</code>. What I could detect</p>\n<ol>\n<li><code>WellFounded</code> has the argument <code>Œ±</code> implicit, <code>IsWellFounded</code> explicit.</li>\n<li><code>WellFounded</code> supports any <code>Sort</code>, <code>IsWellFounded</code> only <code>Type</code>.</li>\n<li><code>WellFounded</code> is not a structure, so it cannot be extended (it is \"only\" an inductive type with a single constructor), <code>IsWellFounded</code> is a class.</li>\n</ol>\n<p>If it is enough differences to have it separated is still not clear to me...</p>",
        "id": 560843227,
        "sender_full_name": "Mirek Ol≈°√°k",
        "timestamp": 1764356626
    }
]