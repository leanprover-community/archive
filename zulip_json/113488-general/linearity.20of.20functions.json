[
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/naming.20challenge/near/273659071\">said</a>:</p>\n<blockquote>\n<p>Sometimes I wonder if we're shooting ourselves in the foot with this heavy point-free approach, and would do better to just write <code>\\lam a f x, L a (f x)</code> and use some <code>linearity</code> tactic to find the linearity proof automatically.</p>\n</blockquote>\n<p>I worked on this a little bit recently. If you use every bound variable exactly once then the map will be linear. I have some very untidy code taking lambda terms and turning them into terms using linear composition and swap.</p>",
        "id": 283319064,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1653312762
    },
    {
        "content": "<p><del>You can replace \"exactly once\", by \"at most once\", right?</del> not for linearity, but for affine maps yes</p>",
        "id": 283319634,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1653313010
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110044\">Chris Hughes</span> <a href=\"#narrow/stream/113488-general/topic/naming.20challenge/near/283319064\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/naming.20challenge/near/273659071\">said</a>:</p>\n<blockquote>\n<p>Sometimes I wonder if we're shooting ourselves in the foot with this heavy point-free approach, and would do better to just write <code>\\lam a f x, L a (f x)</code> and use some <code>linearity</code> tactic to find the linearity proof automatically.</p>\n</blockquote>\n<p>I worked on this a little bit recently. If you use every bound variable exactly once then the map will be linear. I have some very untidy code taking lambda terms and turning them into terms using linear composition and swap.</p>\n</blockquote>\n<p>I wonder how much Lean 4 will help us with this. I also want to be able to write down functors with lambda calculus, but making sure I end up with a term I can actually use.</p>",
        "id": 283320357,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1653313340
    },
    {
        "content": "<p>I would have thought we could just copy the design of <code>continuity</code></p>",
        "id": 283337336,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1653320496
    },
    {
        "content": "<p>Which would mean using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_linear_map\">docs#is_linear_map</a> a lot more</p>",
        "id": 283337386,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1653320518
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/naming.20challenge/near/283337336\">said</a>:</p>\n<blockquote>\n<p>I would have thought we could just copy the design of <code>continuity</code></p>\n</blockquote>\n<p>I'm not at all sure that this is the same problem. You don't need to have a library of tagged lemmas, the condition is that every bound variable is used exactly once; this never changes. The linearity of the functions is part of the type, there's no need for a search for lemmas. And I don't think it can be solved just by applying lemmas. I'm not sure what lemma you would apply first to prove linearity of something like <code>\\la f g x y, g y (f x)</code>.</p>",
        "id": 283341678,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1653322424
    },
    {
        "content": "<p>I'm thinking of a more general case like showing <code>\\la p, matrix.trace (f p.1 + g p.2)</code> is linear</p>",
        "id": 283341888,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1653322525
    },
    {
        "content": "<p>Okay. I think that you need a combination of both. The method I had in mind would prove that <code>\\la p1 p2, trace (add (f p1) (g p2)) </code> is linear if trace, add, f and g were all bundled linear maps. But you need something else to figure out addition is bilinear and to case split on p.</p>",
        "id": 283343834,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1653323412
    },
    {
        "content": "<p>So I guess you need something like continuity, but because the category of modules is monoidal closed you can add more things that continuity won't do currently like proving linearity of <code>\\la f g x y g y (f x)</code></p>",
        "id": 283344130,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1653323531
    },
    {
        "content": "<p>Not really a case split on p, just noting that <code>prod.fst</code> is a linear map</p>",
        "id": 283345153,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1653323997
    },
    {
        "content": "<p>It's a bit more complicated than that because <code>p</code> appears twice in the term which usually means the map isn't linear but somehow this one works and to be honest I'm not sure exactly what the general rule is that this is a special case of that means it's linear despite <code>p</code> appearing twice.</p>",
        "id": 283702870,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1653374323
    },
    {
        "content": "<p>Isn't it just the rule that <code>f x + g x</code> is linear in x if both f and g are?</p>",
        "id": 283708371,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1653378625
    },
    {
        "content": "<p>Isn't the rule \"appears exactly once per summand\"?</p>",
        "id": 283710820,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1653380155
    },
    {
        "content": "<p>My thinking was that the above would be found in the same way that <a href=\"https://leanprover-community.github.io/mathlib_docs/find/continuous.add\">docs#continuous.add</a> is found today</p>",
        "id": 283711157,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1653380331
    },
    {
        "content": "<p>There's no need for a notion of summands</p>",
        "id": 283711189,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1653380351
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113488-general/topic/naming.20challenge/near/283710820\">said</a>:</p>\n<blockquote>\n<p>Isn't the rule \"appears exactly once per summand\"?</p>\n</blockquote>\n<p>It works I guess because addition is actually linear rather than bilinear. There's a map of type <code>(A →ₗ[R] B) → (A →ₗ[R] C) → (A →ₗ[R] B × C)</code>, called <code>linear_map.prod</code>. So if there was a version of <code>add</code> with type <code>A × A →ₗ[R] A</code>, you could rewrite <code>\\la p, trace (f p.1 + g p.2)</code> as <code>\\la p, trace (add (linear_map.prod (f.comp prod.fst) (g.comp prod.snd) p))</code> and that can be proven linear using the rule about using every bound variable exactly once.</p>",
        "id": 283720316,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1653385491
    },
    {
        "content": "<p>So I would prefer to use a rewrite rule instead of something similar to <code>continuous_add</code> to rewrite addition in terms of bundled linear maps, because this allows the more powerful automation to be used afterwards. The earlier example of <code>\\lam a f x, L a (f x)</code> probably can't be proven linear using the same approach as the continuity tactic, linearity is really a harder problem than continuity because the space of linear maps is a vector space and composition and swapping arguments are linear.</p>",
        "id": 283721177,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1653386045
    },
    {
        "content": "<p>Can't you prove <code>\\lam a f x, L a (f x)</code> is tri-linear by proving it's separately linear in each argument?</p>\n<ul>\n<li>Linear in <code>a</code>; use <code>apply_linear</code>, <code>L.is_linear</code></li>\n<li>Linear in <code>f</code>; use <code>L.is_linear2</code>, <code>apply_linear</code></li>\n<li>Linear in <code>x</code>; use <code>L.is_linear2</code>, <code>f.is_linear</code></li>\n</ul>",
        "id": 283724596,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1653388192
    },
    {
        "content": "<p>(I moved this to a new thread, feel free to rename it)</p>",
        "id": 283724756,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1653388275
    },
    {
        "content": "<p>I Lean 4  you can abuse type class system to automatically prove linearity/continuity of lambda functions. Here are the core instances that tear each lambda into its atomic function: <a href=\"https://github.com/lecopivo/SciLean/blob/master/SciLean/Core/Mor/IsLin/Core.lean\">https://github.com/lecopivo/SciLean/blob/master/SciLean/Core/Mor/IsLin/Core.lean</a><br>\nThose instances vaguely correspond to SKI combinators.</p>\n<p>To deal with addition and alike I use the fact that uncurried add is linear:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">diag_parm.arg_x.isLin</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Y₁</span> <span class=\"bp\">→</span> <span class=\"n\">Y₂</span> <span class=\"bp\">→</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">yy</span> <span class=\"o\">:</span> <span class=\"n\">Y₁</span> <span class=\"bp\">×</span> <span class=\"n\">Y₂</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">yy.1</span> <span class=\"n\">yy.2</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">g₁</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Y₁</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"n\">g₁</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">g₂</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Y₂</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"n\">g₂</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">IsLin</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g₁</span> <span class=\"n\">x</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g₂</span> <span class=\"n\">x</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>However, there are some issues with higher order unification so you need to add certain class instances manually, when <code>f</code> has additional trailing argument, example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">priority</span> <span class=\"o\">:=</span> <span class=\"n\">mid</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">subst.arg_x.parm_a.isSmooth</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">a</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">a</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">try</span> <span class=\"n\">infer_instance</span> <span class=\"n\">apply</span> <span class=\"n\">subst.arg_x.isSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">done</span>\n</code></pre></div>\n<p>It is trivialy solvable by direct application of a previous instance, but Lean is unable to do it automatically. I'm still unsure what is the general pattern of these \"additional instances\"</p>",
        "id": 283726430,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1653389277
    },
    {
        "content": "<p>A quick test for something like <code>\\la p, matrix.trace (f p.1 + g p.2)</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span> <span class=\"n\">W</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Vec</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Vec</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Vec</span> <span class=\"n\">Z</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Vec</span> <span class=\"n\">W</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"n\">f</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"n\">g</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Z</span> <span class=\"bp\">→</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"n\">h</span><span class=\"o\">]</span>\n  <span class=\"o\">:</span> <span class=\"n\">IsLin</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">×</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">p.1</span> <span class=\"bp\">+</span> <span class=\"n\">g</span> <span class=\"n\">p.2</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n</code></pre></div>\n<p>A part of the trace that shows the sequence of reasoning:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">Meta.synthInstance</span><span class=\"o\">]</span> <span class=\"n\">main</span> <span class=\"n\">goal</span> <span class=\"n\">IsLin</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">p.fst</span> <span class=\"bp\">+</span> <span class=\"n\">g</span> <span class=\"n\">p.snd</span><span class=\"o\">)</span>\n<span class=\"o\">[</span><span class=\"n\">Meta.synthInstance.newAnswer</span><span class=\"o\">]</span> <span class=\"n\">size</span><span class=\"o\">:</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">IsLin</span> <span class=\"k\">fun</span> <span class=\"n\">yy</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">yy.fst</span> <span class=\"bp\">+</span> <span class=\"n\">yy.snd</span>\n<span class=\"o\">[</span><span class=\"n\">Meta.synthInstance.newAnswer</span><span class=\"o\">]</span> <span class=\"n\">size</span><span class=\"o\">:</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">IsLin</span> <span class=\"n\">f</span>\n<span class=\"o\">[</span><span class=\"n\">Meta.synthInstance.newAnswer</span><span class=\"o\">]</span> <span class=\"n\">size</span><span class=\"o\">:</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">IsLin</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">p.fst</span>\n<span class=\"o\">[</span><span class=\"n\">Meta.synthInstance.newAnswer</span><span class=\"o\">]</span> <span class=\"n\">size</span><span class=\"o\">:</span> <span class=\"mi\">7</span><span class=\"o\">,</span> <span class=\"n\">IsLin</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">p.fst</span>\n<span class=\"o\">[</span><span class=\"n\">Meta.synthInstance.newAnswer</span><span class=\"o\">]</span> <span class=\"n\">size</span><span class=\"o\">:</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">IsLin</span> <span class=\"n\">g</span>\n<span class=\"o\">[</span><span class=\"n\">Meta.synthInstance.newAnswer</span><span class=\"o\">]</span> <span class=\"n\">size</span><span class=\"o\">:</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">IsLin</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">p.snd</span>\n<span class=\"o\">[</span><span class=\"n\">Meta.synthInstance.newAnswer</span><span class=\"o\">]</span> <span class=\"n\">size</span><span class=\"o\">:</span> <span class=\"mi\">7</span><span class=\"o\">,</span> <span class=\"n\">IsLin</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">g</span> <span class=\"n\">p.snd</span>\n<span class=\"o\">[</span><span class=\"n\">Meta.synthInstance.newAnswer</span><span class=\"o\">]</span> <span class=\"n\">size</span><span class=\"o\">:</span> <span class=\"mi\">22</span><span class=\"o\">,</span> <span class=\"n\">IsLin</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">p.fst</span> <span class=\"bp\">+</span> <span class=\"n\">g</span> <span class=\"n\">p.snd</span>\n<span class=\"o\">[</span><span class=\"n\">Meta.synthInstance.newAnswer</span><span class=\"o\">]</span> <span class=\"n\">size</span><span class=\"o\">:</span> <span class=\"mi\">27</span><span class=\"o\">,</span> <span class=\"n\">IsLin</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">p.fst</span> <span class=\"bp\">+</span> <span class=\"n\">g</span> <span class=\"n\">p.snd</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 283727703,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1653390038
    },
    {
        "content": "<p>The requirement that a variable appears only once is too harsh, for example this is also a linear function:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Vec</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Vec</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Vec</span> <span class=\"n\">Z</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"n\">g</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"n\">h</span><span class=\"o\">]</span>\n  <span class=\"o\">:</span> <span class=\"n\">IsLin</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">×</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">p.1</span> <span class=\"bp\">+</span> <span class=\"n\">g</span> <span class=\"n\">p.1</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n</code></pre></div>",
        "id": 283728006,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1653390240
    },
    {
        "content": "<p>Note that we actually used to have such a typeclass system in lean3 (<a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_add_monoid_hom\">docs#is_add_monoid_hom</a> etc), but it didn't behave well with the simplifier or composition</p>",
        "id": 283728154,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1653390328
    },
    {
        "content": "<p>Do you have an example of problematic cases? It works quite well for me in Lean 4, and and main use case is exactly to steer simplifier when applying theorems.</p>",
        "id": 283728813,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1653390757
    },
    {
        "content": "<p>I remember reading <a href=\"https://arxiv.org/abs/2202.01629\">Use and abuse of instance parameters in the Lean mathematical library</a> which states that the unbundled approach for morphisms was problematic for mathlib3.</p>",
        "id": 283729063,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1653390917
    },
    {
        "content": "<p>I don't know what the canonical reference is for that problem,  it was discovered quite a while ago. It's entirely possible that the problem is not as bad in Lean 4.</p>",
        "id": 283729096,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1653390938
    },
    {
        "content": "<p>I know that my approach is impossible in lean3 as it is heavily relaying on the new type class system's ability handling cycles.</p>",
        "id": 283729207,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1653391006
    },
    {
        "content": "<p>I can also do the tri-linearity of <code>\\lam a f x, L a (f x)</code>. The only catch if that for linearity in <code>x</code> you need to set <code>f</code> type to bundled linear map, in my notation <code>W ⊸ Y</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">W</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Vec</span> <span class=\"n\">W</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Vec</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Vec</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Vec</span> <span class=\"n\">Z</span><span class=\"o\">]</span>\n  <span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">IsLin</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"n\">x</span><span class=\"o\">)]</span>\n\n  <span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">IsLin</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">W</span> <span class=\"bp\">⊸</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">L</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n  <span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">IsLin</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">W</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">L</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n  <span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">IsLin</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">W</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">L</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n</code></pre></div>",
        "id": 283729944,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1653391449
    },
    {
        "content": "<p>Yes I thought the whole point of hanging on to the deprecated lean 3 version of this was that people were aware that it might come back into play in lean 4</p>",
        "id": 283756368,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653403821
    }
]