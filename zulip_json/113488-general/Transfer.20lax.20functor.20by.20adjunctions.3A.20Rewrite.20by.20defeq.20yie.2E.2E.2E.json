[
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">category_theory.functor_category</span>\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"n\">D</span> <span class=\"n\">E</span> <span class=\"n\">F</span> <span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">⥤</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"bp\">⥤</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">J₁</span> <span class=\"n\">J₂</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">⥤</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">J₁</span> <span class=\"bp\">⟶</span> <span class=\"n\">J₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"bp\">⥤</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">K.obj</span> <span class=\"o\">(</span><span class=\"n\">J₂.obj</span> <span class=\"o\">(</span><span class=\"n\">I.obj</span> <span class=\"o\">(</span><span class=\"n\">H.obj</span> <span class=\"n\">c</span><span class=\"o\">)))</span> <span class=\"bp\">⟶</span> <span class=\"n\">g</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">α.app</span> <span class=\"o\">(</span><span class=\"n\">I.obj</span> <span class=\"o\">(</span><span class=\"n\">H.obj</span> <span class=\"n\">c</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">α.app</span> <span class=\"o\">((</span><span class=\"n\">H</span> <span class=\"bp\">⋙</span> <span class=\"n\">I</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">H.comp_obj</span> <span class=\"o\">}</span> <span class=\"c\">/-</span><span class=\"cm\"> motive not type correct -/</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">α.app</span> <span class=\"o\">(</span><span class=\"n\">I.obj</span> <span class=\"o\">(</span><span class=\"n\">H.obj</span> <span class=\"n\">c</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">α.app</span> <span class=\"o\">((</span><span class=\"n\">H</span> <span class=\"bp\">⋙</span> <span class=\"n\">I</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">erw</span> <span class=\"n\">H.comp_obj</span> <span class=\"o\">}</span> <span class=\"c\">/-</span><span class=\"cm\"> goals accomplished -/</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">K.map</span> <span class=\"o\">(</span><span class=\"n\">α.app</span> <span class=\"o\">(</span><span class=\"n\">I.obj</span> <span class=\"o\">(</span><span class=\"n\">H.obj</span> <span class=\"n\">c</span><span class=\"o\">)))</span> <span class=\"bp\">=</span> <span class=\"n\">K.map</span> <span class=\"o\">(</span><span class=\"n\">α.app</span> <span class=\"o\">((</span><span class=\"n\">H</span> <span class=\"bp\">⋙</span> <span class=\"n\">I</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">c</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">erw</span> <span class=\"n\">H.comp_obj</span> <span class=\"o\">}</span> <span class=\"c\">/-</span><span class=\"cm\"> goals accomplished -/</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">K.map</span> <span class=\"o\">(</span><span class=\"n\">α.app</span> <span class=\"o\">(</span><span class=\"n\">I.obj</span> <span class=\"o\">(</span><span class=\"n\">H.obj</span> <span class=\"n\">c</span><span class=\"o\">)))</span> <span class=\"bp\">≫</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">K.map</span> <span class=\"o\">(</span><span class=\"n\">α.app</span> <span class=\"o\">((</span><span class=\"n\">H</span> <span class=\"bp\">⋙</span> <span class=\"n\">I</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">c</span><span class=\"o\">))</span> <span class=\"bp\">≫</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">erw</span> <span class=\"n\">H.comp_obj</span> <span class=\"o\">}</span> <span class=\"c\">/-</span><span class=\"cm\"> motive not type correct !! -/</span>\n</code></pre></div>\n<p>All goals can actually be solved by <code>rfl</code>, but not being able to use <code>rw</code> means I have to write down the whole equality. Is there any way to improve <code>rw</code> to work in these circumstances? Or maybe another <code>eerw</code> tactic? The last example naturally arises in my attempt to show that a family of adjunctions (e.g. presheaf pullback-pushforward adjunction for each morphism in <code>Top</code>) transfers a pseudofunctor to a pseudofunctor, using results in <code>adjunction/mates</code>.</p>",
        "id": 261926841,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1637242252
    },
    {
        "content": "<p>just tried <code>dsimp only [H.comp_obj]</code> and it fails to simplify ...</p>",
        "id": 261927591,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1637242661
    },
    {
        "content": "<p><code>dsimp</code> works alone or with <code>only [category_theory.functor.comp_obj]</code>, not sure why it doesn't work with <code>only [H.comp_obj]</code>. Also not sure why <code>erw</code> ever <em>would</em> work.</p>",
        "id": 261934514,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637245966
    },
    {
        "content": "<p>Maybe we should have some kind of <code>drw</code> or <code>dsimp_rw</code></p>",
        "id": 261934793,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637246073
    },
    {
        "content": "<p>This also doesn't work</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">nat.add_zero</span> <span class=\"n\">n</span><span class=\"o\">],</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>Maybe passing arguments to lemmas for <code>dsimp</code> messes up its <code>rfl</code>-lemma thing?</p>",
        "id": 261935043,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637246184
    },
    {
        "content": "<p>My strategy for this kind of reasoning was normally to get into a state where something like <code>simp, dsimp, simp</code> would work (= close the goal)</p>",
        "id": 261935201,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637246264
    },
    {
        "content": "<p>another style that would work is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">K.map</span> <span class=\"o\">(</span><span class=\"n\">α.app</span> <span class=\"o\">(</span><span class=\"n\">I.obj</span> <span class=\"o\">(</span><span class=\"n\">H.obj</span> <span class=\"n\">c</span><span class=\"o\">)))</span> <span class=\"bp\">≫</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">K.map</span> <span class=\"o\">(</span><span class=\"n\">α.app</span> <span class=\"o\">((</span><span class=\"n\">H</span> <span class=\"bp\">⋙</span> <span class=\"n\">I</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">c</span><span class=\"o\">))</span> <span class=\"bp\">≫</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">change</span> <span class=\"n\">I.obj</span> <span class=\"o\">(</span><span class=\"n\">H.obj</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"bp\">⋙</span> <span class=\"n\">I</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"gr\">sorry</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 261935795,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637246514
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">dsimp</span> <span class=\"n\">works</span> <span class=\"k\">with</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">category_theory.functor.comp_obj</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Thank you! <del>This is gonna be a life saver.</del> I didn't even know <code>change</code> can be used with <code>with</code> to specify where to change; I <a href=\"https://github.com/leanprover-community/mathlib/blob/c920a07a2d01ff34619afa523954076853311310/src/category_theory/adjunction/mates.lean#L344\">tried <code>change</code> once</a> but it didn't work. Here I actually need to rewrite in the reverse direction then apply naturality (can't rw or erw naturality directly) in the reverse direction, and after that still need to rewrite by map_comp, assoc, and a triangle identity, and those can be done by simp (if it doesn't undo the rw &lt;- naturality). Unfortuantley I don't have time to complete the proofs until ~7 hours later.</p>",
        "id": 261946194,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1637250867
    },
    {
        "content": "<p>The relevant part of the goal at this step is</p>\n<p>((adj f').unit.app ((Rmap f').obj ((Rmap (𝟙 X)).obj x)) ≫ <br>\n(Rmap f').map ((L.map_id X).app (<strong>(<a href=\"http://L.map\">L.map</a> f').obj ((Rmap f').obj</strong> ((Rmap (𝟙 X)).obj x))) ≫ <br>\n(<a href=\"http://L.map\">L.map</a> (𝟙 X)).map ((adj f').counit.app ((Rmap (𝟙 X)).obj x)) ≫ <br>\n(adj (𝟙 X)).counit.app x))</p>\n<p>The middle two lines are gonna be rewritten by naturality, and then cancel with the first line by triangle identity. The <code>(Rmap f').obj ((Rmap (𝟙 X)).obj</code> came from <code>Rmap (𝟙 X) ⋙ Rmap f'</code> via dsimp.</p>",
        "id": 261947117,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1637251197
    },
    {
        "content": "<p>I guess it would go smoothly with simps after rewriting the right hand side with triangle identity ...</p>",
        "id": 261951553,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1637252836
    },
    {
        "content": "<p>Last night I was able to prove the <code>comp_id</code> and <code>id_comp</code> compatibility conditions for the transferred lax functor, but it took one more night for me to <a href=\"https://github.com/leanprover-community/mathlib/blob/52cb146de5f30e2be8077f32f19498e257ea1a0a/src/category_theory/adjunction/mates.lean#L344-L358\">figure out the associative compatibility and code it</a>: when you expand the condition you get a composition of eight morphisms at each side of the identity, and there seems to be a lot of choices where to apply naturality, but it turns out applying them “maximally” is enough. I haven’t seen a proof before or even a reference for this transfer construction+theorem, so I am glad that my intuition worked out right. (The docstring in <code>adjunction/mates</code> which mentions six operations is maybe hinting at it?) Does anyone know a more conceptual proof?</p>\n<p>The technical issue at the top of this thread about inability to rewrite no longer bothers me since last night, though <code>dsimp only</code> wasn’t actually useful because we can’t specify an argument so it ends up rewriting too much. And I didn’t end up using <code>change</code>; rewriting by right triangle first indeed worked well.</p>\n<p>Now the task is to make the proofs faster and shorter; currently the three proofs take 5.5s, 6.5s and 16s on my machine. And also to provide a simplified version in the case where <code>map_id</code> and <code>map_comp</code> are isomorphisms (pseudofunctor), where we can shave off an <code>op</code> (I think I don't need to repeat the proofs here); maybe I could also do the nLab version, as the proofs will be similar and won't add much effort.</p>\n<p>This has been an unexpectedly long digression:<br>\ntry to prove adjunction between overcategories Top/Y and PresheafedSpace/Y -&gt; <br>\nneed the <code>map_comp</code> natural isomorphism for presheaf pullback -&gt; try to define it in a canonical way -&gt; <br>\nfind <code>adjunction/mates</code> that suites my need -&gt; <br>\ntry to prove pseudofunctor compatibility conditions -&gt; <br>\ntry to do it in \"appropriate\" generality of lax functors (but falls short of defining 2-categories ...)<br>\nThat's how I get here. And I'm not even sure the first goal (the adjunction) is necessary for the main project (existence of limits in PresheafedSpace and eventually in LocallyRingedSpace)! I should really get back to that ...</p>",
        "id": 262171522,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1637397397
    }
]