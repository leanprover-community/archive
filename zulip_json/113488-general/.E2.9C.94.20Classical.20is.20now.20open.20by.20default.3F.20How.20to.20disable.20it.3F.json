[
    {
        "content": "<p>I noticed that the double negation law can be proved directly by a <code>simp</code>. Don't I need to open the <code>Classical</code> namespace?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">dn</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"bp\">Â¬</span><span class=\"o\">(</span><span class=\"bp\">Â¬</span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n</code></pre></div>\n<p>Then, why <code>em</code> is put inside the namespace <code>Classical</code>? See this <a href=\"https://live.lean-lang.org/#project=lean-nightly&amp;codez=C4Cwpg9gTmC2AEATAdvAFAYQFzwApQgAcBKHAGrTI2PgFoA+eDeLAXngCMBPAKHngDOAS1iEe4xGABmSZHHTY8BEuQrNAFETwyTGm3hSArqgDGEZMCgBDeK3p94p81fgASeAHkoAOiHIor/SN4AAkbRkcLazdPH2QAGxDxHlBIGAR5NEIWJSJdeCzNMiy9bntLQkI4rlkyiqrZOB4gA\">online playground</a>.</p>\n<p>Is there any way to disable this? I still prefer intuitionistic logic over classical logic.</p>",
        "id": 505552828,
        "sender_full_name": "xiao",
        "timestamp": 1741912461
    },
    {
        "content": "<p>You can use <code>simp?</code>, and them remove the classical theorems one by one</p>",
        "id": 505553541,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1741912886
    },
    {
        "content": "<p>But it is not correct to say that <code>open Classical</code> or the weaker <code>open scoped Classical</code> is enabled by default; rather just that various components rely internally on <code>Classical.choice</code>.</p>",
        "id": 505553683,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1741912948
    },
    {
        "content": "<p>For me, this is too dangerous. People may unintentionally use some classical axioms.</p>",
        "id": 505554368,
        "sender_full_name": "xiao",
        "timestamp": 1741913257
    },
    {
        "content": "<p>You can check what axioms a theorem uses with <code>#print axioms dn</code>.</p>",
        "id": 505554595,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741913408
    },
    {
        "content": "<p>And note you only need to do it on your final theorem, <code>#print axioms</code> shows the transitive closure through all lemmas used.</p>",
        "id": 505554729,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1741913511
    },
    {
        "content": "<p>I think someone created detectClassical linter.<br>\nYou might want to use this.</p>",
        "id": 505566992,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1741919851
    },
    {
        "content": "<p>Lean is unapologetically classical. You may have to work quite hard to avoid using classical logic. It is baked in to a variety of tactics in Lean core.</p>",
        "id": 505567209,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1741919971
    },
    {
        "content": "<p>Thank you. I think it's better for me to accept this in lean. But, I still feel that using classical logic without an explicit declaration is a bit peculiar in a proof assistant without the control operator.</p>",
        "id": 505580479,
        "sender_full_name": "xiao",
        "timestamp": 1741926191
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"717159\">xiao</span> has marked this topic as resolved.</p>",
        "id": 505580485,
        "sender_full_name": "Notification Bot",
        "timestamp": 1741926193
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> has marked this topic as resolved.</p>",
        "id": 505581109,
        "sender_full_name": "Notification Bot",
        "timestamp": 1741926514
    },
    {
        "content": "<p>Do you mean control operators as in delimited continuations?</p>\n<p>Context you should keep in mind: Lean is aiming to support the kinds of reasoning that appear in math and CS broadly. A paper about the correctness of an algorithm won't make the point of saying that the proofs used only intuitionistic logic â€” this is a foreign concept to the greater part of these disciplines. The continuation view of classical logic is even more foreign.</p>\n<p>You use the word 'dangerous' to express the fact that <code>simp</code> can use classical logic. Could you speak a bit more about what application you have that needs to avoid classical logic?</p>",
        "id": 505583115,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741927436
    },
    {
        "content": "<p>I want to study the free Heyting algebra generated by two variables in lean.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Formula</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Top</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Bot</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">And</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Formula</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Formula</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Formula</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Or</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Formula</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Formula</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Formula</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Imply</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Formula</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Formula</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Formula</span>\n\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Formula</span><span class=\"bp\">.</span><span class=\"n\">Not</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Formula</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">Imply</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Bot</span>\n</code></pre></div>\n<p>I want to make use of the lean's proof system instead of redefining the deduction system.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Formula</span><span class=\"bp\">.</span><span class=\"n\">interp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">Formula</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">p</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">q</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Top</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">True</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Bot</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">False</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">And</span><span class=\"w\"> </span><span class=\"n\">f1</span><span class=\"w\"> </span><span class=\"n\">f2</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f1</span><span class=\"bp\">.</span><span class=\"n\">interp</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">âˆ§</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f2</span><span class=\"bp\">.</span><span class=\"n\">interp</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Or</span><span class=\"w\"> </span><span class=\"n\">f1</span><span class=\"w\"> </span><span class=\"n\">f2</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">f1</span><span class=\"bp\">.</span><span class=\"n\">interp</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">âˆ¨</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f2</span><span class=\"bp\">.</span><span class=\"n\">interp</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Imply</span><span class=\"w\"> </span><span class=\"n\">f1</span><span class=\"w\"> </span><span class=\"n\">f2</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">f1</span><span class=\"bp\">.</span><span class=\"n\">interp</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f2</span><span class=\"bp\">.</span><span class=\"n\">interp</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>To verify the order between formulas, I could prove the formula directly, e.g., <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>â‰¤</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A \\le B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">â‰¤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> iff <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>â†’</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A \\to B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">â†’</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> is provable. Then, the double negation elimination is certainly unwanted.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">dn_p_p</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Formula</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Formula</span><span class=\"bp\">.</span><span class=\"n\">P</span><span class=\"bp\">.</span><span class=\"n\">Not</span><span class=\"bp\">.</span><span class=\"n\">Not</span><span class=\"bp\">.</span><span class=\"n\">Imply</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">P</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">dn_p_p_true_heyting</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">dn_em_p</span><span class=\"bp\">.</span><span class=\"n\">interp</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n</code></pre></div>\n<p>And it is more weird that the excluded middle is not admitted directly.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">em_p</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Formula</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Formula</span><span class=\"bp\">.</span><span class=\"n\">P</span><span class=\"bp\">.</span><span class=\"n\">Or</span><span class=\"w\"> </span><span class=\"n\">Formula</span><span class=\"bp\">.</span><span class=\"n\">P</span><span class=\"bp\">.</span><span class=\"n\">Not</span>\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">dn_em_p</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Formula</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">em_p</span><span class=\"bp\">.</span><span class=\"n\">Not</span><span class=\"bp\">.</span><span class=\"n\">Not</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">dn_em_p_true_heyting</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">dn_em_p</span><span class=\"bp\">.</span><span class=\"n\">interp</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">em_p_true_heyting</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">em_p</span><span class=\"bp\">.</span><span class=\"n\">interp</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"gr\">admit</span>\n</code></pre></div>\n<p>I noticed this because I was explaining to others how proof assistant works (Curry-Howard). Think about the following.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">H1</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">H2</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"bp\">Â¬</span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">âˆ§</span><span class=\"n\">q</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"gr\">admit</span>\n</code></pre></div>\n<p>After the <code>simp</code>, the target became <code>(p â†’ Â¬q) â†’ r</code>. I want the other apparent proof by first making the conjunction and applying modus pones and ex falso quodlibet.</p>",
        "id": 505772304,
        "sender_full_name": "xiao",
        "timestamp": 1741988956
    },
    {
        "content": "<p>In <a href=\"https://github.com/forked-from-1kasper/ground_zero\">Ground Zero</a>, there's large eliminator checker which checks that large elimination of singletons is not allowed (it's incompatible with HoTT). So it seems like we need a classical reasoning checker as well.</p>\n<p>Quite unfortunate.</p>",
        "id": 505773394,
        "sender_full_name": "suhr",
        "timestamp": 1741989557
    },
    {
        "content": "<p>Any reason you wouldn't be able to use <code>Type</code> instead of <code>Prop</code>?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Formula</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Top</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Bot</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">And</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Formula</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Formula</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Formula</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Or</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Formula</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Formula</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Formula</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Imply</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Formula</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Formula</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Formula</span>\n\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Formula</span><span class=\"bp\">.</span><span class=\"n\">Not</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Formula</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">Imply</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Bot</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Formula</span><span class=\"bp\">.</span><span class=\"n\">interp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">Formula</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">p</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">q</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Top</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Unit</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Bot</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Empty</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">And</span><span class=\"w\"> </span><span class=\"n\">f1</span><span class=\"w\"> </span><span class=\"n\">f2</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f1</span><span class=\"bp\">.</span><span class=\"n\">interp</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">Ã—</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f2</span><span class=\"bp\">.</span><span class=\"n\">interp</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Or</span><span class=\"w\"> </span><span class=\"n\">f1</span><span class=\"w\"> </span><span class=\"n\">f2</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">f1</span><span class=\"bp\">.</span><span class=\"n\">interp</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">âŠ•</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f2</span><span class=\"bp\">.</span><span class=\"n\">interp</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Imply</span><span class=\"w\"> </span><span class=\"n\">f1</span><span class=\"w\"> </span><span class=\"n\">f2</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">f1</span><span class=\"bp\">.</span><span class=\"n\">interp</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f2</span><span class=\"bp\">.</span><span class=\"n\">interp</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 505773611,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741989644
    },
    {
        "content": "<p>If you're explaining Curry-Howard, how does <code>simp</code> play a role? That's a very complicated tactic â€”Â do you explain the Eq type too and how it is used for rewriting?</p>\n<p>I'm just wondering if it would be better to demonstrate an intuitionistic proof using simpler tactics, rather than expect <code>simp</code>, which is designed to help people prove things quickly, to help illustrate finer points of logic in some simple pedagogical examples.</p>",
        "id": 505774161,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741989911
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"394485\">@suhr</span> What's so unfortunate? Large elimination checking actually has something to it, but detecting classical reasoning is just looking at the output of <code>#print axioms</code></p>\n<p>You can even make a linter for it without any trouble. <a class=\"message-link\" href=\"/#narrow/channel/270676-lean4/topic/restricting.20axioms/near/501743343\">#lean4 &gt; restricting axioms @ ðŸ’¬</a></p>",
        "id": 505776757,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741991349
    },
    {
        "content": "<p>It just used to be as simple as \"you proved a theorem without <code>open Classical</code> â†’ you know that the proof is constructive\". Now you need a special lint for that.</p>\n<p>It's nice that making this lint is not too hard though.</p>",
        "id": 505777961,
        "sender_full_name": "suhr",
        "timestamp": 1741992026
    },
    {
        "content": "<p>That must have been a long time ago, then</p>",
        "id": 505779694,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1741992926
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> I think I can work with <code>Type</code>. Thank you. And the reason I need <code>simp</code> is that the target can be the interpretation of <code>Formula</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">H1</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">H2</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Formula</span><span class=\"bp\">.</span><span class=\"n\">P</span><span class=\"bp\">.</span><span class=\"n\">And</span><span class=\"w\"> </span><span class=\"n\">Formula</span><span class=\"bp\">.</span><span class=\"n\">Q</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">Not</span><span class=\"bp\">.</span><span class=\"n\">interp</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"gr\">admit</span>\n</code></pre></div>\n<p>For equalities, we can apply <code>Eq.rec</code> or <code>Eq.refl</code>. Their corresponding tactics could be <code>rewrite</code> and <code>eq_refl</code>. But also, <code>simp</code> will try applying an <code>eq_refl</code>. For pedagogical purpose, this is certainly unwanted, but it is easier to comfort the listeners for this situation.</p>",
        "id": 505783021,
        "sender_full_name": "xiao",
        "timestamp": 1741994757
    },
    {
        "content": "<p>Maybe I'm misunderstanding you but you don't need <code>simp</code> for that example... you can just do</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">H1</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">H2</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Formula</span><span class=\"bp\">.</span><span class=\"n\">P</span><span class=\"bp\">.</span><span class=\"n\">And</span><span class=\"w\"> </span><span class=\"n\">Formula</span><span class=\"bp\">.</span><span class=\"n\">Q</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">Not</span><span class=\"bp\">.</span><span class=\"n\">interp</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">âŸ¨</span><span class=\"n\">H1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">H2</span><span class=\"bp\">âŸ©</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span>\n</code></pre></div>",
        "id": 505794048,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1742002004
    },
    {
        "content": "<p>The thing is that if you want to use <code>simp</code> to simplify <code>(Formula.P.And Formula.Q).Not.interp p q</code>, it will apply some classical logic turning the target to <code>(p â†’ Â¬q) â†’ r</code>. I don't want this to happen.</p>",
        "id": 505798287,
        "sender_full_name": "xiao",
        "timestamp": 1742004845
    },
    {
        "content": "<p>Yes, that's why I was suggesting that you don't need <code>simp</code>.</p>",
        "id": 505803042,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1742008821
    },
    {
        "content": "<p>It's not about  <em><code>simp</code> uses classical logical so we don't use <code>simp</code></em>, but <code>simp</code> uses classical logical without any explicit declaration like <code>open Classical</code>. Now, we have known <code>simp</code> uses classical logical. what about other tactics? That means after my work done, I have to <code>#print axioms</code> to make sure my proof does not contain some classical tautologies.</p>\n<p>Besides, it is crucial for pedagogical purpose. Imagine that you are going to demonstrate proof tactics in lean, and you want to <code>simp</code> the target by evaluating <code>(Formula.P.And Formula.Q).Not.interp p q</code> to <code>Not (p /\\q)</code>. Then, lean turns it into <code>(p â†’ Â¬q) â†’ r</code>. I still need <code>simp</code> for most of my work but without the classical part.</p>",
        "id": 505805377,
        "sender_full_name": "xiao",
        "timestamp": 1742010846
    },
    {
        "content": "<p>Take a look at that link I posted <span class=\"user-mention\" data-user-id=\"717159\">@xiao</span>. Damiano wrote a linter that can automatically check for axioms</p>",
        "id": 505805672,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1742011086
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> Thank you. Indeed, I do not object to classical logic that much. I just think we have to hold in mind that we are using something more than just CIC itself.</p>",
        "id": 505806419,
        "sender_full_name": "xiao",
        "timestamp": 1742011605
    },
    {
        "content": "<p>It's possible to make a custom set of lemmas (a \"simp set\"), and make a <code>simp</code>-like tactic that only uses your custom simp set. If this is important to you, maybe it's worth doing.</p>\n<p>I'm not sure I follow your pedagogical example. Usually it's not good practice to use <code>simp</code> on its own and to expect a certain result.</p>\n<p>We avoid \"non-terminal simps\" in mathlib for example. If you expect a certain result, <code>simp only [...]</code> is all that's allowed.</p>",
        "id": 505806739,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1742011872
    },
    {
        "content": "<p>Yes, that seems to be the best solution.</p>",
        "id": 505807048,
        "sender_full_name": "xiao",
        "timestamp": 1742012155
    }
]