[
    {
        "content": "<p>I have been musing this puzzle:</p>\n<p>Given a higher order function (like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.map#doc\">docs#List.map</a>), and a congruence lemma like docs##List.map_congr that says <code>List.map f l = List.map g l</code> if <code>f </code> and <code>g</code> agree on (just) the members of <code>l</code>, can I construct a function that’s equal to <code>List.map</code>, but passes a proof that the element is in the list to its argument (like <code>xs.attach.map f</code> would do).</p>\n<p>More generally, can this function be defined:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">internalize_congruence'</span>\n  <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">}</span>\n  <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">C</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span>  <span class=\"kt\">Prop</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">cong</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">C</span> <span class=\"n\">x</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">F</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">F</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">{</span><span class=\"n\">F'</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">//</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">C</span> <span class=\"n\">x</span><span class=\"o\">),</span> <span class=\"n\">F</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">F'</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I so far managed to define it if I make some extra non-emptyness-assumptions and use classical choice:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">internalize_congruence'</span>\n  <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">}</span>\n  <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">ne</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">Nonempty</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"n\">x</span><span class=\"o\">)]</span>\n  <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">C</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span>  <span class=\"kt\">Prop</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">cong</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">C</span> <span class=\"n\">x</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">F</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">F</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">{</span><span class=\"n\">F'</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">//</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">C</span> <span class=\"n\">x</span><span class=\"o\">),</span> <span class=\"n\">F</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">F'</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">f</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"k\">then</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"n\">h</span> <span class=\"k\">else</span> <span class=\"n\">choice</span> <span class=\"o\">(</span><span class=\"n\">ne</span> <span class=\"n\">x</span><span class=\"o\">)),</span> <span class=\"bp\">?</span><span class=\"n\">x</span><span class=\"o\">⟩</span>\n  <span class=\"n\">intro</span> <span class=\"n\">f</span>\n  <span class=\"n\">apply</span> <span class=\"n\">cong</span>\n  <span class=\"n\">intro</span> <span class=\"n\">x</span> <span class=\"n\">hx</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hx</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Can I do away with that assumption and/or the use of extra axioms?</p>",
        "id": 398687030,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1698326204
    },
    {
        "content": "<p>You can lose the axioms with:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">internalize_congruence'</span>\n    <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">}</span>\n    <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">}</span>\n    <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">Inhabited</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"n\">x</span><span class=\"o\">)]</span>\n    <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">C</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">))</span>\n    <span class=\"o\">[</span><span class=\"n\">DecidablePred</span> <span class=\"n\">P</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">cong</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">C</span> <span class=\"n\">x</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">F</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">F</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">{</span><span class=\"n\">F'</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">//</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">C</span> <span class=\"n\">x</span><span class=\"o\">),</span> <span class=\"n\">F</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">F'</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">f</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"k\">then</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"n\">h</span> <span class=\"k\">else</span> <span class=\"n\">default</span><span class=\"o\">),</span> <span class=\"bp\">?</span><span class=\"n\">x</span><span class=\"o\">⟩</span>\n  <span class=\"n\">intro</span> <span class=\"n\">f</span>\n  <span class=\"n\">apply</span> <span class=\"n\">cong</span>\n  <span class=\"n\">intro</span> <span class=\"n\">x</span> <span class=\"n\">hx</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hx</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 398688003,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1698326520
    },
    {
        "content": "<p>Ah, of course. But can I drop the requirement that <code>P</code> needs to be decidable completely (maybe with a different approach than mine)?</p>",
        "id": 398689871,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1698327116
    },
    {
        "content": "<p>Can you clarify what you mean by \"passes a proof that the element is in the list to its argument\"? Can you formalise the <code>list.map</code> example?</p>",
        "id": 398691960,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1698327761
    },
    {
        "content": "<p>Specializing the problem to <code>List.map</code>, what I want is to take an API like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">List.map</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">β</span>\n<span class=\"n\">List.map_congr</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">List.map</span> <span class=\"n\">f</span> <span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"n\">List.map</span> <span class=\"n\">g</span> <span class=\"n\">l</span>\n</code></pre></div>\n<p>and get </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">List.map'</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">((</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span>  <span class=\"n\">x</span>  <span class=\"bp\">∈</span>  <span class=\"n\">l</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">→</span>  <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">β</span>\n</code></pre></div>\n<p>(without just defining it from scratch, of course).</p>\n<p>The motivating context is nested recursion: If you have a trie structure, where each node has a list of subtrees, then often your functions recurse through <code>List.map</code> (or similar functions), and for the termination checker to see that the termination is well-founded, it needs the <code>x  ∈  l</code> in the context, so using <code>map'</code> (or <code>l.attach.map</code>) is (as far as I understand) the way to go.</p>",
        "id": 398694086,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1698328418
    },
    {
        "content": "<p>The other way at looking at this is that we defined <code>map</code> wrongly, and it should provide <code>x ∈ l</code> always</p>",
        "id": 398694738,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1698328613
    },
    {
        "content": "<p>This is maybe a bit like the observation that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Submodule.span_induction#doc\">docs#Submodule.span_induction</a> was the wrong induction principle, and the helpful one is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Submodule.span_induction%27#doc\">docs#Submodule.span_induction'</a>, even though they're equivalent in some sense</p>",
        "id": 398695072,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1698328709
    },
    {
        "content": "<p>Definitely! But in this thread I am more curious about how equivalent these formulations are in Lean.</p>\n<p>In Isabelle, you <em>only</em> have the congruence lemma, but it can be used by the termination checker, so you don’t even have to write your functions in this somewhat strange style of having <code>fun x hx =&gt; </code> and seemingly not using the <code>hx</code>, and I wonder the same approach could work in Lean.</p>",
        "id": 398696261,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1698329004
    },
    {
        "content": "<p>What do you mean you \"only\" have the congruence lemma? I see the idea, but also don't see any way to do it straightforwardly without <code>P</code> being decidable; I feel like you need to apply choice \"somewhere\" to pick things to apply to your function, even though congruence means that those values are irrelevant.</p>",
        "id": 398699937,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1698330003
    },
    {
        "content": "<p>Yeah, that's probably the answer. Thanks!</p>",
        "id": 398706255,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1698331796
    },
    {
        "content": "<p>I'm still curious about the isabelle version :)</p>",
        "id": 398710453,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1698332928
    },
    {
        "content": "<p>I Isabelle you don't have dependent types, so you can't even write <code>map'</code>, but you also don't need it, because <code>map_congr</code> is sufficient to express ”List.map only calls it's argument on members on the list”, e.g. when proving recursive function definitions to be well-defined. It's all extrinsic (?), so no need to worry about converting between intrinsic and extrinsic :-)</p>",
        "id": 398712337,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1698333505
    },
    {
        "content": "<p>More concretely: When lean defines a function via well-founded recursion, it uses <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=WellFounded.fix#doc\">docs#WellFounded.fix</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">WellFounded.fix</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">hwf</span> <span class=\"o\">:</span> <span class=\"n\">WellFounded</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">((</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">r</span> <span class=\"n\">y</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>where <code>F</code> is the one step of the function you are trying to define; it can only recurse on smaller arguments (think <code>r</code> = <code>&lt;</code>).</p>\n<p>In Isabelle-style,  the lemma would probably look like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">WellFounded.fix_extr</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">hwf</span> <span class=\"o\">:</span> <span class=\"n\">WellFounded</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">((</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">congr</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">((</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">r</span> <span class=\"n\">y</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">F</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">F</span> <span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>Not that this means that your function definition <code>F</code> doesn’t have to deal with the recursion argument at all, and you can prove it later separately, by way of a congruence lemma</p>\n<p>Congruence lemmas are easy to prove compositionally, so many recursive functions, even if they recurse through other higher-order functions, are accepted without special attention in the definition and without explicit proof in Isabelle.</p>\n<p>Since WellFounded definitions in Lean already only give you propositional equalities, and not definitional ones, I wonder if the above  <code>fix_extr</code>-approach could work in Lean? Can we define <code>fix_extr</code>?</p>\n<p>(Note that it’s more general; it’s straightforward to prove <code>fix</code> from from <code>fix_extr</code>, if I am not mistaken.)</p>",
        "id": 398714762,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1698334157
    }
]