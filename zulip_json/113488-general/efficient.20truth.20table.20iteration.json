[
    {
        "content": "<p>I'm wondering what the most efficient way might be to iterate through all of the possible assignments of true and false to a list of strings, which allows stopping part way through if a condition is met. I have code that will generate all of the possible assignments, but it doesn't permit stopping, and I'm guessing it might not be all that efficient:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ValuationAsListOfPairs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Inhabited</span>\n\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">gen_all_valuations_as_list_of_list_of_pairs</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ValuationAsListOfPairs</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[[]]</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">hd</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">tl</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">left</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ValuationAsListOfPairs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hd</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">gen_all_valuations_as_list_of_list_of_pairs</span><span class=\"w\"> </span><span class=\"n\">tl</span><span class=\"o\">)</span>\n\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">right</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ValuationAsListOfPairs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hd</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">gen_all_valuations_as_list_of_list_of_pairs</span><span class=\"w\"> </span><span class=\"n\">tl</span><span class=\"o\">)</span>\n\n<span class=\"w\">  </span><span class=\"n\">left</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">right</span>\n\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">gen_all_valuations_as_list_of_list_of_pairs</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"s2\">\"P\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"Q\"</span><span class=\"o\">]</span>\n<span class=\"c1\">-- [[(\"P\", false), (\"Q\", false)], [(\"P\", false), (\"Q\", true)], [(\"P\", true), (\"Q\", false)], [(\"P\", true), (\"Q\", true)]]</span>\n</code></pre></div>\n<p>Honestly, I'm also generally not really sure about what kind of tricks there are to make Lean, or functional code in general, faster.</p>",
        "id": 514722050,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1745816728
    },
    {
        "content": "<p>generating large lists is generally a bad idea if it's not a mandatory part of the output. Can you write an inefficient function which does what you want? The current MWE does not have anything about a condition, and if you are returning a list of results then it's not clear what it means to stop early</p>",
        "id": 514867952,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1745861170
    },
    {
        "content": "<p>I can do something like this efficiently in haskell, because haskell is a lazy language. However, if I do this in Lean, which is a strict language, Lean will eagerly generate the entire list, even if it is not used.</p>",
        "id": 514868467,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745861354
    },
    {
        "content": "<p>You may want to consider using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MLList#doc\">docs#MLList</a> (monadic lazy list) and friends.</p>",
        "id": 514868668,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745861416
    },
    {
        "content": "<p>Here's a basic version which searches for the first valuation satisfying a condition:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ValuationAsListOfPairs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Inhabited</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">find_valuation</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ValuationAsListOfPairs</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ValuationAsListOfPairs</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">ValuationAsListOfPairs</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[],</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">hd</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">tl</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">  </span><span class=\"n\">find_valuation</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">tl</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">hd</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&lt;|&gt;</span>\n<span class=\"w\">  </span><span class=\"n\">find_valuation</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">tl</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">hd</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">find_valuation</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"s2\">\"P\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"s2\">\"Q\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"s2\">\"P\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"Q\"</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n</code></pre></div>",
        "id": 514868851,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1745861493
    },
    {
        "content": "<p>it's always possible to express haskell style lazy evaluation programs in a strict language, but you may have to \"turn the control flow inside out\". This is what haskell has to do in the end to generate code anyway. (It's easiest to explain with an example. The above program is the equivalent of the haskell program that generates a lazy list and then uses <code>head &lt;| filter</code> on it)</p>",
        "id": 514869321,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1745861649
    },
    {
        "content": "<p>Interesting, thank you. What does the memory usage look like? Does it store all of the previously generated valuations in memory, or discard each one after it has been checked?</p>",
        "id": 514943531,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1745896645
    },
    {
        "content": "<p>That is, does the memory usage grow to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">2^{n}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6644em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span></span> if it never satisfies the condition, or remain at <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>?</p>",
        "id": 514945624,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1745897930
    },
    {
        "content": "<p>(I'm not sure how to tell if it is tail recursive or not)</p>",
        "id": 514952788,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1745902035
    },
    {
        "content": "<p>I wonder if it would be more useful to Mathlib to generalize this to something like the lazy Cartesian product of an arbitrary list of lists, where this case would be passing n lists of [true, false] to that function. (ie, Python's <code>itertools.product</code>)</p>",
        "id": 514972129,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1745908693
    },
    {
        "content": "<p>(Unless the generalization makes the simpler case less efficient)</p>",
        "id": 514983748,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1745912055
    },
    {
        "content": "<p>That definition is not tail recursive, but the recursion has height n, not 2^n. And it does not buffer previous results, so the memory usage should be O(n) as well.</p>",
        "id": 514993164,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1745914862
    },
    {
        "content": "<p>How could I go about seeing that it is not tail recursive? Is there a way I can add in print statements to see what is on the call stack? Would that help me tell?<br>\nCan it be made tail recursive?</p>",
        "id": 515183292,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1745974771
    },
    {
        "content": "<p>I'm just thinking it would be fun to have the fastest possible brute force check for a propositional formula being satisfiable along with a proof that the check is correct.</p>",
        "id": 515214989,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1745993351
    },
    {
        "content": "<p>It isn't tail recursive because it calls itself twice.</p>",
        "id": 515227469,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1745998009
    },
    {
        "content": "<p>I see. I guess there isn't really any way around that.</p>",
        "id": 515233735,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1745999989
    },
    {
        "content": "<p>You could in principle manage recursive calls on a heap allocated structure like a <code>List</code> or <code>Array</code> instead and then write a tail recursive procedure that pushes and pops from that</p>",
        "id": 515240568,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1746001851
    },
    {
        "content": "<p>I see. Would that improve the speed?</p>",
        "id": 515445736,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1746074211
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/113488-general/topic/efficient.20truth.20table.20iteration/near/514869321\">said</a>:</p>\n<blockquote>\n<p>it's always possible to express haskell style lazy evaluation programs in a strict language, but you may have to \"turn the control flow inside out\". This is what haskell has to do in the end to generate code anyway. (It's easiest to explain with an example. The above program is the equivalent of the haskell program that generates a lazy list and then uses <code>head &lt;| filter</code> on it)</p>\n</blockquote>\n<p>Is there a way to do this generically? If I have an arbitrary function that generates a list, can I wrap it somehow, or pass it as an argument to another function that will make it evaluate lazily, without changing its code?</p>",
        "id": 515446783,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1746074966
    },
    {
        "content": "<p>No. A function which produces a lazy list in haskell can be converted once and for all to a strict function, but the conversion result is a stream generator with type <code>B x (B -&gt; Option (A x B))</code> instead of <code>List A</code>.</p>",
        "id": 515506751,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746106884
    },
    {
        "content": "<p>If you have a strict function which produces a <code>List A</code> then the damage is already done and it cannot be undone by applying more functions afterwards</p>",
        "id": 515506913,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746106944
    },
    {
        "content": "<p>Hmm. But a lazy function can be written in Lean from scratch? For example, I could write a Lean version of the Python <a href=\"https://docs.python.org/3/library/itertools.html#itertools.product\">iterools.product</a> function that evaluates lazily?</p>",
        "id": 515616379,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1746150117
    }
]