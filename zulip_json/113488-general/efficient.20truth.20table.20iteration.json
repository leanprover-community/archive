[
    {
        "content": "<p>I'm wondering what the most efficient way might be to iterate through all of the possible assignments of true and false to a list of strings, which allows stopping part way through if a condition is met. I have code that will generate all of the possible assignments, but it doesn't permit stopping, and I'm guessing it might not be all that efficient:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ValuationAsListOfPairs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Inhabited</span>\n\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">gen_all_valuations_as_list_of_list_of_pairs</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ValuationAsListOfPairs</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[[]]</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">hd</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">tl</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">left</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ValuationAsListOfPairs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hd</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">gen_all_valuations_as_list_of_list_of_pairs</span><span class=\"w\"> </span><span class=\"n\">tl</span><span class=\"o\">)</span>\n\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">right</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ValuationAsListOfPairs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hd</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">gen_all_valuations_as_list_of_list_of_pairs</span><span class=\"w\"> </span><span class=\"n\">tl</span><span class=\"o\">)</span>\n\n<span class=\"w\">  </span><span class=\"n\">left</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">right</span>\n\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">gen_all_valuations_as_list_of_list_of_pairs</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"s2\">\"P\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"Q\"</span><span class=\"o\">]</span>\n<span class=\"c1\">-- [[(\"P\", false), (\"Q\", false)], [(\"P\", false), (\"Q\", true)], [(\"P\", true), (\"Q\", false)], [(\"P\", true), (\"Q\", true)]]</span>\n</code></pre></div>\n<p>Honestly, I'm also generally not really sure about what kind of tricks there are to make Lean, or functional code in general, faster.</p>",
        "id": 514722050,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1745816728
    },
    {
        "content": "<p>generating large lists is generally a bad idea if it's not a mandatory part of the output. Can you write an inefficient function which does what you want? The current MWE does not have anything about a condition, and if you are returning a list of results then it's not clear what it means to stop early</p>",
        "id": 514867952,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1745861170
    },
    {
        "content": "<p>I can do something like this efficiently in haskell, because haskell is a lazy language. However, if I do this in Lean, which is a strict language, Lean will eagerly generate the entire list, even if it is not used.</p>",
        "id": 514868467,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745861354
    },
    {
        "content": "<p>You may want to consider using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MLList#doc\">docs#MLList</a> (monadic lazy list) and friends.</p>",
        "id": 514868668,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745861416
    },
    {
        "content": "<p>Here's a basic version which searches for the first valuation satisfying a condition:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ValuationAsListOfPairs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Inhabited</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">find_valuation</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ValuationAsListOfPairs</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ValuationAsListOfPairs</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">ValuationAsListOfPairs</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[],</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">hd</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">tl</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">  </span><span class=\"n\">find_valuation</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">tl</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">hd</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&lt;|&gt;</span>\n<span class=\"w\">  </span><span class=\"n\">find_valuation</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">tl</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">hd</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">find_valuation</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"s2\">\"P\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"s2\">\"Q\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"s2\">\"P\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"Q\"</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n</code></pre></div>",
        "id": 514868851,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1745861493
    },
    {
        "content": "<p>it's always possible to express haskell style lazy evaluation programs in a strict language, but you may have to \"turn the control flow inside out\". This is what haskell has to do in the end to generate code anyway. (It's easiest to explain with an example. The above program is the equivalent of the haskell program that generates a lazy list and then uses <code>head &lt;| filter</code> on it)</p>",
        "id": 514869321,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1745861649
    },
    {
        "content": "<p>Interesting, thank you. What does the memory usage look like? Does it store all of the previously generated valuations in memory, or discard each one after it has been checked?</p>",
        "id": 514943531,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1745896645
    },
    {
        "content": "<p>That is, does the memory usage grow to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">2^{n}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6644em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span></span> if it never satisfies the condition, or remain at <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>?</p>",
        "id": 514945624,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1745897930
    },
    {
        "content": "<p>(I'm not sure how to tell if it is tail recursive or not)</p>",
        "id": 514952788,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1745902035
    },
    {
        "content": "<p>I wonder if it would be more useful to Mathlib to generalize this to something like the lazy Cartesian product of an arbitrary list of lists, where this case would be passing n lists of [true, false] to that function. (ie, Python's <code>itertools.product</code>)</p>",
        "id": 514972129,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1745908693
    },
    {
        "content": "<p>(Unless the generalization makes the simpler case less efficient)</p>",
        "id": 514983748,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1745912055
    },
    {
        "content": "<p>That definition is not tail recursive, but the recursion has height n, not 2^n. And it does not buffer previous results, so the memory usage should be O(n) as well.</p>",
        "id": 514993164,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1745914862
    },
    {
        "content": "<p>How could I go about seeing that it is not tail recursive? Is there a way I can add in print statements to see what is on the call stack? Would that help me tell?<br>\nCan it be made tail recursive?</p>",
        "id": 515183292,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1745974771
    },
    {
        "content": "<p>I'm just thinking it would be fun to have the fastest possible brute force check for a propositional formula being satisfiable along with a proof that the check is correct.</p>",
        "id": 515214989,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1745993351
    },
    {
        "content": "<p>It isn't tail recursive because it calls itself twice.</p>",
        "id": 515227469,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1745998009
    },
    {
        "content": "<p>I see. I guess there isn't really any way around that.</p>",
        "id": 515233735,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1745999989
    },
    {
        "content": "<p>You could in principle manage recursive calls on a heap allocated structure like a <code>List</code> or <code>Array</code> instead and then write a tail recursive procedure that pushes and pops from that</p>",
        "id": 515240568,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1746001851
    },
    {
        "content": "<p>I see. Would that improve the speed?</p>",
        "id": 515445736,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1746074211
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/113488-general/topic/efficient.20truth.20table.20iteration/near/514869321\">said</a>:</p>\n<blockquote>\n<p>it's always possible to express haskell style lazy evaluation programs in a strict language, but you may have to \"turn the control flow inside out\". This is what haskell has to do in the end to generate code anyway. (It's easiest to explain with an example. The above program is the equivalent of the haskell program that generates a lazy list and then uses <code>head &lt;| filter</code> on it)</p>\n</blockquote>\n<p>Is there a way to do this generically? If I have an arbitrary function that generates a list, can I wrap it somehow, or pass it as an argument to another function that will make it evaluate lazily, without changing its code?</p>",
        "id": 515446783,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1746074966
    },
    {
        "content": "<p>No. A function which produces a lazy list in haskell can be converted once and for all to a strict function, but the conversion result is a stream generator with type <code>B x (B -&gt; Option (A x B))</code> instead of <code>List A</code>.</p>",
        "id": 515506751,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746106884
    },
    {
        "content": "<p>If you have a strict function which produces a <code>List A</code> then the damage is already done and it cannot be undone by applying more functions afterwards</p>",
        "id": 515506913,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746106944
    },
    {
        "content": "<p>Hmm. But a lazy function can be written in Lean from scratch? For example, I could write a Lean version of the Python <a href=\"https://docs.python.org/3/library/itertools.html#itertools.product\">iterools.product</a> function that evaluates lazily?</p>",
        "id": 515616379,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1746150117
    },
    {
        "content": "<p>Python is not a lazy language, so the implementation would be basically the same in that case</p>",
        "id": 515672946,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746177557
    },
    {
        "content": "<p>Oh. I thought I had read that the iterators were evaluated lazily?</p>",
        "id": 515742144,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1746200215
    },
    {
        "content": "<p>they are lazy, in the sense that an iterator is an object which has a next function, rather than a sequence of values ready to go</p>",
        "id": 515743583,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746200666
    },
    {
        "content": "<p>but you can do objects with a next function in lean too</p>",
        "id": 515743638,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746200682
    },
    {
        "content": "<p>Is that different than lazy evaluation?</p>",
        "id": 515744561,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1746200932
    },
    {
        "content": "<p>I guess I assumed that was required for lazy evaluation.</p>",
        "id": 515745066,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1746201087
    },
    {
        "content": "<p>This is the Lean function I have for it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">cartesian_product</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[[]]</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">xss</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">sub_products</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">cartesian_product</span><span class=\"w\"> </span><span class=\"n\">xss</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">sub_products</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">sub</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">sub</span><span class=\"o\">)))</span><span class=\"bp\">.</span><span class=\"n\">flatten</span>\n</code></pre></div>\n<p>but I'm not sure how to turn it into one with a next function.</p>",
        "id": 515746538,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1746201547
    },
    {
        "content": "<p>actually python is doing a bit of language magic here; you missed the use of the <code>yield</code> keyword and your version is not an iterator at all</p>",
        "id": 515751603,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746203179
    },
    {
        "content": "<p>in fact it looks nothing like the python implementation in the docs?</p>",
        "id": 515751763,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746203228
    },
    {
        "content": "<p>That was my attempt to just write any function in Lean that computes a cartesian product of n variables.</p>",
        "id": 515752139,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1746203345
    },
    {
        "content": "<p>I'm not sure how to replicate the Python version in Lean.</p>",
        "id": 515752230,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1746203372
    },
    {
        "content": "<p>actually the python docs version is not good either, it is essentially a strict version but the docs say \"imagine this but lazy\" <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 515752444,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746203428
    },
    {
        "content": "<p><span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 515752670,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1746203499
    },
    {
        "content": "<p>There's this: <a href=\"https://more-itertools.readthedocs.io/en/stable/_modules/more_itertools/more.html#partial_product\">https://more-itertools.readthedocs.io/en/stable/_modules/more_itertools/more.html#partial_product</a></p>",
        "id": 515765493,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1746207580
    },
    {
        "content": "<p>And also <code>outer_product</code> below that</p>",
        "id": 515765536,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1746207594
    },
    {
        "content": "<p>Cartesian product is one of the more complicated operations to iteratorify. Here's an implementation:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">CartesianProduct'</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">PUnit</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_::</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">CartesianProduct'</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">xs</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">CartesianProduct'</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">xss</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">CartesianProduct'</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">xss</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">([],</span><span class=\"w\"> </span><span class=\"bp\">⟨⟩</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">::</span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">::</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">CartesianProduct'</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">iter</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">::</span><span class=\"n\">l</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">iter</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"bp\">::_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">none</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">CartesianProduct'</span><span class=\"bp\">.</span><span class=\"n\">next?</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">xss</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">CartesianProduct'</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">xss</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">CartesianProduct'</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">xss</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[],</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_::</span><span class=\"n\">xss</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">iter</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">val</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">sub</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">iter</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">←</span>\n<span class=\"w\">      </span><span class=\"o\">((</span><span class=\"n\">val</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&lt;$&gt;</span><span class=\"w\"> </span><span class=\"n\">next?</span><span class=\"w\"> </span><span class=\"n\">xss</span><span class=\"w\"> </span><span class=\"n\">iter</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&lt;|&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">do</span>\n<span class=\"w\">        </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">val</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Stream</span><span class=\"bp\">.</span><span class=\"n\">next?</span><span class=\"w\"> </span><span class=\"n\">l</span>\n<span class=\"w\">        </span><span class=\"o\">(</span><span class=\"n\">val</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&lt;$&gt;</span><span class=\"w\"> </span><span class=\"n\">CartesianProduct'</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">xss</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">val</span><span class=\"bp\">::</span><span class=\"n\">sub</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">iter</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">CartesianProduct</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">Σ</span><span class=\"w\"> </span><span class=\"n\">xss</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">CartesianProduct'</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">xss</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">cartesian_product_lazy</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CartesianProduct</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">⟨</span><span class=\"n\">xs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">CartesianProduct'</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">cartesian_product_eager</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[[]]</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">xss</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">sub_products</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">cartesian_product_eager</span><span class=\"w\"> </span><span class=\"n\">xss</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">sub_products</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">sub</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">sub</span><span class=\"o\">)))</span><span class=\"bp\">.</span><span class=\"n\">flatten</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Stream</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">CartesianProduct</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">next?</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">⟨_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">xs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">iter</span><span class=\"o\">)</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">xs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">iter</span><span class=\"bp\">.</span><span class=\"n\">next?</span><span class=\"bp\">⟩</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">cartesian_product_eager</span><span class=\"w\"> </span><span class=\"o\">[[</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">],[</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">],[</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">]]</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[]</span>\n<span class=\"w\">  </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">cartesian_product_lazy</span><span class=\"w\"> </span><span class=\"o\">[[</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">],[</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">],[</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">]]</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">push</span><span class=\"w\"> </span><span class=\"n\">i</span>\n<span class=\"w\">  </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">l</span>\n</code></pre></div>",
        "id": 515767334,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746208236
    },
    {
        "content": "<p>Wow!</p>",
        "id": 515767769,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1746208399
    },
    {
        "content": "<p>How does this work?</p>",
        "id": 515768261,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1746208563
    },
    {
        "content": "<p><code>CartesianProduct'</code> is some kind of data type, a structure maybe?</p>",
        "id": 515769160,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1746208857
    },
    {
        "content": "<p>The basic idea of making an algorithm lazy is that every time you yield you need to remember exactly where you are in the algorithm so you can pick back up later. This is a pretty direct translation of your eager implementation, so the state you need to keep track of is the values of the <code>xs</code>, <code>val</code> local variables, as well as a nested iterator for the <code>sub_products</code> variable. You also need to keep around the original list of lists because every time you throw away one of the nested iterators you need to restore it from the beginning again; that's what <code>CartesianProduct'.mk</code> does. Note that the way this is written it assumes the lists are nonempty when inside the inner loops, so <code>CartesianProduct'.mk</code> returns an option for the case where one of the lists is empty.</p>",
        "id": 515769254,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746208882
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"139442\">Paige Thomas</span> <a href=\"#narrow/channel/113488-general/topic/efficient.20truth.20table.20iteration/near/515769160\">said</a>:</p>\n<blockquote>\n<p><code>CartesianProduct'</code> is some kind of data type, a structure maybe?</p>\n</blockquote>\n<p>Yes, in general an iterator is a custom type and a <code>Stream</code> implementation for it</p>",
        "id": 515769521,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746208945
    },
    {
        "content": "<p>Both <code>CartesianProduct'</code> and <code>CartesianProduct</code> are streams; the latter hides the dependent type for an easier API</p>",
        "id": 515769602,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746208978
    },
    {
        "content": "<p>Concretely, if we have yielded the elements up to and not including <code>[0,1,2]</code> in the <code>[[0,1],[0,1],[0,2]]</code> iteration example, then the state will be:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">([[</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">],[</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">],[</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">]],</span>\n<span class=\"w\"> </span><span class=\"o\">[([</span><span class=\"mi\">1</span><span class=\"o\">],</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">([],</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">([],</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)])</span>\n</code></pre></div>",
        "id": 515770802,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746209384
    },
    {
        "content": "<p>although the definition is written as a recursive type instead of <code>List (List α × α)</code> to ensure the two lists are the same length</p>",
        "id": 515771084,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746209488
    },
    {
        "content": "<p>I'm not sure I'm familiar with recursive types. Is that similar to an inductive type?</p>",
        "id": 515772281,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1746209939
    },
    {
        "content": "<p>or maybe I was, but forgot :(</p>",
        "id": 515775647,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1746211066
    },
    {
        "content": "<p>by recursive type I mean a function of type <code>Type</code> defined using <code>def</code> and recursion</p>",
        "id": 516095868,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746413555
    },
    {
        "content": "<p>See <code>CartesianProduct'</code> above for an example</p>",
        "id": 516095916,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746413577
    },
    {
        "content": "<p>Sorry, I mean, I'm not sure how to read that code, ie, translate it to English prose. What makes up a <code>CartesianProduct'</code>given that definition? What are some examples of instances of <code>CartesianProduct'</code> and why are they instances?</p>",
        "id": 516099257,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1746415206
    },
    {
        "content": "<p><code>CartesianProduct'</code> is a family of types, so the things in it depends on which element of the family you take. <code>CartesianProduct' A []</code> is the same as <code>PUnit</code> so it has <code>()</code> as its element, and <code>CartesianProduct' A [xs]</code> is the same as <code>List A x A x PUnit</code> so its elements are like <code>([a,b,c], a, ())</code>, etc</p>",
        "id": 516154312,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746439187
    },
    {
        "content": "<p>Interesting. It seems like the list it is recursing on isn't used other than as something that has a recursive structure? Like, for example, it could be replaced with recursion on a Nat or anything with a similar form?</p>",
        "id": 516329055,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1746495953
    },
    {
        "content": "<p>yes, specifically the type only depends on the length of the list</p>",
        "id": 516331684,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746497491
    },
    {
        "content": "<p>it's basically just a <code>List (List A x A)</code> with the same length as <code>xss</code></p>",
        "id": 516331779,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746497530
    },
    {
        "content": "<p>Is it a list of tuples, or a long combined tuple like <code>(List A x A) x ((List A x A) x ... x (List A x A))</code>?</p>",
        "id": 516332186,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1746497823
    },
    {
        "content": "<p>It's the long combined tuple, but with a <code>PUnit</code> at the end (and also associated a bit differently)</p>",
        "id": 516332239,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746497870
    },
    {
        "content": "<p>compare types like <code>Nat.below</code></p>",
        "id": 516332247,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746497879
    },
    {
        "content": "<p>I can't seem to find <code>Nat.below</code> in Mathlib?</p>",
        "id": 516332433,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1746498001
    },
    {
        "content": "<p>It's one of those secret autogenerated types</p>",
        "id": 516333228,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746498463
    },
    {
        "content": "<p>You get one for every recursive inductive type</p>",
        "id": 516333292,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746498487
    },
    {
        "content": "<p>They're used to compile recursive definitions</p>",
        "id": 516333318,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746498511
    },
    {
        "content": "<p>Oh. Thank you.</p>",
        "id": 516335700,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1746499959
    }
]