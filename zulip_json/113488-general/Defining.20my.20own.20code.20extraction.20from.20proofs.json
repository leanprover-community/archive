[
    {
        "content": "<p>Hey!</p>\n<p>I'm looking for a way to define my own code extraction method from <strong>proofs</strong> in Lean. I would like to traverse the proof term manually, extract the nodes that interest me and output a C++ function that \"corresponds\" to the proof. I wasn't able to find relevant functionality in the section about Metaprogramming in the Lean Reference. I also wasn't able to find anything relevant (such as code extraction) in the source code of Lean. I also worry that Proof irrelevance might be a trouble (but not when operating on the meta-level perhaps?). Could you point me to how one would normally approach such a thing? I.e. getting your hands on the actual proof created by the user, and extracting computational content out of it?</p>\n<p>The background: I'm currently formalizing the field of bounded arithmetic, and what's interesting about this field is that if you manage to prove a theorem (e.g. addition is associative, or for every x sqrt(x) exists) only from a specific set of axioms (like x &gt;= x) + induction, then it is true that for every such proof corresponds to a Turing machine operating in some well-known complexity. I have a working formalization of proofs in arithmetic and now need to extract computations from them</p>",
        "id": 538835948,
        "sender_full_name": "Paweł Balawender",
        "timestamp": 1757591098
    },
    {
        "content": "<p>Is there an equivalent of lean virtual machine in lean4?</p>",
        "id": 538837371,
        "sender_full_name": "Paweł Balawender",
        "timestamp": 1757591568
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"892220\">Paweł Balawender</span> <a href=\"#narrow/channel/113488-general/topic/Defining.20my.20own.20code.20extraction.20from.20proofs/near/538835948\">said</a>:</p>\n<blockquote>\n<p>Could you point me to how one would normally approach such a thing? I.e. getting your hands on the actual proof created by the user, and extracting computational content out of it?</p>\n</blockquote>\n<p>You can get the proof term from the constant name like this (using <code>Nat.pow_add</code> as an example):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"n\">run_meta</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"ss\">``Nat.pow_add</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">ci</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">getConstInfo</span><span class=\"w\"> </span><span class=\"n\">name</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ci</span><span class=\"bp\">.</span><span class=\"n\">value?</span><span class=\"w\"> </span><span class=\"bp\">|</span>\n<span class=\"w\">    </span><span class=\"n\">throwError</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"s2\">\"{Lean.MessageData.ofConstName name} has no value\"</span>\n<span class=\"w\">  </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"n\">val</span>\n</code></pre></div>",
        "id": 538841881,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757592742
    },
    {
        "content": "<p>Thank you! Following your hint, I was able to define a basic proof-term <code>Expr</code> traversal. What I'm trying to do is to, whenever I find an instance of <code>Exists.intro</code>, applied to some <code>x</code> and a proof <code>x : P x</code>,  find the definition of <code>x</code> and recursively process it (to, ultimately, get to some <code>exists</code> that is an axiom in my view and to which i know how to extract code from). However, I am struggling dealing with eliminators such as <code>Exists.rec</code>, which in a rather opaque way bind one of their arguments as, say, a variable in the other (in the continuation of the proof). </p>\n<p>Let's say we have a situation like:</p>\n<ul>\n<li>we know that in the currently processed node of <code>Expr</code> we have an occurrence of variable <code>Y</code> and we want to find its definition</li>\n<li>we know that <code>Y</code> is just a bound variable of a lambda, and that the lambda is an argument of an <code>Exists.rec</code> higher up in the proof tree</li>\n<li>we know the argument of <code>Exists.rec</code> that should bind to the <code>Y</code></li>\n</ul>\n<p>Since the definition of <code>Exists.rec</code> is opaque, I currently think I'd have to reinvent <code>Exists.rec</code> to manually bind the parameter. I tried to somehow unfold the <code>.rec</code> to a standard <code>Expr.lam</code> node and use <code>Lean.Meta.withLocalDecl</code>, as I do when encountering <code>Expr.lam</code> nodes: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">findExIntro</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Expr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">lam</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">body</span><span class=\"w\"> </span><span class=\"n\">binderInfo</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">withLocalDecl</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"n\">binderInfo</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">newBody</span><span class=\"w\"> </span><span class=\"bp\">&lt;-</span><span class=\"w\"> </span><span class=\"n\">findExIntro</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">body</span><span class=\"bp\">.</span><span class=\"n\">instantiate1</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">mkLambdaFVars</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">newBody</span>\n</code></pre></div>\n<p>but I wasn't able to unfold this definition. Do you have any concept how we should properly do it in Lean?</p>",
        "id": 539394294,
        "sender_full_name": "Paweł Balawender",
        "timestamp": 1757841800
    },
    {
        "content": "<p>what did you try?</p>",
        "id": 539395879,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757843942
    },
    {
        "content": "<p>Okay, just after writing this I found one way to do it - from an expression of <code>Exists.rec</code>, filter out the argument <code>arg[4]</code> (creating the <code>ex</code>) and the continuation (<code>intro: \\x, hx -&gt; rest of proof</code>), then recurse down <code>arg[4]</code> (which reduces to a pair of <code>x, hx</code>) to extract the definition of <code>x</code>. This looks like: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"bp\">@</span><span class=\"o\">(</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"c1\">-- TODO: ideally, this case shouldn't be here, really...</span>\n<span class=\"w\">    </span><span class=\"c1\">-- we should have something more general</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">isAppOfArity</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"ss\">``Exists.rec</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">args</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">getAppArgsN</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"mi\">5</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">witness_pair</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">args</span><span class=\"o\">[</span><span class=\"mi\">4</span><span class=\"o\">]</span><span class=\"bp\">!</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">witness</span><span class=\"w\"> </span><span class=\"bp\">&lt;-</span><span class=\"w\"> </span><span class=\"n\">findExIntro</span><span class=\"w\"> </span><span class=\"n\">witness_pair</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">raw_intro</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">args</span><span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">]</span><span class=\"bp\">!</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"bp\">&lt;-</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">instantiateLambda</span><span class=\"w\"> </span><span class=\"n\">raw_intro</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">witness</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">&lt;-</span><span class=\"w\"> </span><span class=\"n\">findExIntro</span><span class=\"w\"> </span><span class=\"n\">inst</span>\n</code></pre></div>\n<p>which  is not fully general, but rather works for now. Perhaps there is more standard way of achieving this? Or more general, to also deal with other eliminators than <code>Exists.rec</code>?</p>",
        "id": 539396178,
        "sender_full_name": "Paweł Balawender",
        "timestamp": 1757844227
    },
    {
        "content": "<p>Maybe you can use some sort of rewriting system instead</p>",
        "id": 539396444,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757844558
    },
    {
        "content": "<p>that would be more standard</p>",
        "id": 539396452,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757844568
    },
    {
        "content": "<p>If you are trying to extract a program, it is better to start with a program; so replace <code>Exists</code> with <code>Subtype</code>, <code>Or</code> with <code>Sum</code>, etc</p>",
        "id": 539411345,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1757859320
    }
]