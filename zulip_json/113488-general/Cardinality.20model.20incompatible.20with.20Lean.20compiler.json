[
    {
        "content": "<p>Something funny I figured out, the axiom <code>α ≃ β → α = β</code> is incompatible with <code>native_decide</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Setoid</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">equiv_of_eq</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">≃</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">β</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Nat'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Quotient</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Setoid</span><span class=\"bp\">.</span><span class=\"n\">ker</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">mk_zero</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⟦</span><span class=\"mi\">0</span><span class=\"bp\">⟧</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">⟦</span><span class=\"mi\">1</span><span class=\"bp\">⟧</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Quotient</span><span class=\"bp\">.</span><span class=\"n\">sound</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">equivNat</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat'</span><span class=\"w\"> </span><span class=\"bp\">≃</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">lift</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">id</span>\n<span class=\"w\">  </span><span class=\"n\">invFun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟦</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"bp\">⟧</span>\n<span class=\"w\">  </span><span class=\"n\">left_inv</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">inductionOn</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">recOn</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">right_inv</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">castNat</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat'</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">equiv_of_eq</span><span class=\"w\"> </span><span class=\"n\">equivNat</span><span class=\"o\">)</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">contradiction</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">castNat</span><span class=\"w\"> </span><span class=\"bp\">⟦</span><span class=\"mi\">0</span><span class=\"bp\">⟧</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">castNat</span><span class=\"w\"> </span><span class=\"bp\">⟦</span><span class=\"mi\">1</span><span class=\"bp\">⟧</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">native_decide</span>\n<span class=\"w\">  </span><span class=\"n\">simpa</span>\n\n<span class=\"c1\">-- 'contradiction' depends on axioms: [equiv_of_eq, propext, Lean.ofReduceBool, Quot.sound]</span>\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">axioms</span><span class=\"w\"> </span><span class=\"n\">contradiction</span>\n</code></pre></div>\n<p>This is pretty inconsequential all things considered; there's easier ways to prove <code>False</code> using <code>native_decide</code> (e.g. bad <code>implemented_by</code> tags). But I guess this one more pitfall with compiled Lean to be aware of.</p>",
        "id": 501673961,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1740439964
    },
    {
        "content": "<p>Relating to this: are we absolutely sure <code>cast</code> can't be used for evil in \"core\" Lean? Even if that's just crashing the VM through a bad <code>#eval</code>. Do we always know that equal types must have the exact same VM representation?</p>",
        "id": 501674428,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1740440120
    },
    {
        "content": "<p>we get that property from the other extremal model, where you tag all types so that different inductives are distinct</p>",
        "id": 501680681,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1740442792
    },
    {
        "content": "<p>in that model, equality of types implies that they have the same construction, although there are some fun exceptions to this rule involving the inductive types which are not injective by cantor's theorem</p>",
        "id": 501680873,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1740442893
    },
    {
        "content": "<p>But a full answer to this question involves proving the correctness of type erasure, a la <a href=\"https://inria.hal.science/hal-04077552v2/document\">this paper</a></p>",
        "id": 501681081,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1740442992
    }
]