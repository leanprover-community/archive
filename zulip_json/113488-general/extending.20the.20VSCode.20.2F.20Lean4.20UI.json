[
    {
        "content": "<p>I'm looking for advice on how to do the following (ideally some project that already does something similar that I can copy from).</p>\n<p>The standard VSCode/Lean4 UI looks something like this: <br>\n<a href=\"/user_uploads/3121/7q47E-fydjMdO1dlcJnTrA9p/e5.png\">e5.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/7q47E-fydjMdO1dlcJnTrA9p/e5.png\" title=\"e5.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"3815x2126\" src=\"/user_uploads/thumbnail/3121/7q47E-fydjMdO1dlcJnTrA9p/e5.png/840x560.webp\"></a></div><p>LHS = code; RHS = Lean4 server output</p>\n<p>I would like a layout of</p>\n<p>LHS = code, RHS Top = Lean4 server output; RHS Bot = output of other program</p>\n<p>I want this \"other program\" to:</p>\n<ol>\n<li>render output to RHS Bot</li>\n<li>from vscode: get updates any time cursor row/col, or buffer state (even if not written to filesystem)</li>\n<li>from Lean4: be able to query server state, eval exprs</li>\n</ol>\n<p>One can think of it as a \"poor man's lean4 copilot\"; I want this \"other program\" to have access to full program (via file system), what I'm currently looking at (via vscode updates), be able to run tests (vs lean4 server).</p>\n<p>Is there any open source project that already has this that I can copy code from? Ideally one where all communication is done over websockets/tcpsockets, thus enforcing no requirements on language used in \"other program\"</p>\n<p>Thanks!</p>",
        "id": 561195290,
        "sender_full_name": "TongKe Xue",
        "timestamp": 1764603306
    },
    {
        "content": "<p>See Paperproof as an example</p>",
        "id": 561210912,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764606469
    },
    {
        "content": "<p>Concretely you are lookin for the ProofWidgets  library</p>",
        "id": 561210995,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764606487
    },
    {
        "content": "<p>But it won't be as lively as the infoview. that's not as customisable right now</p>",
        "id": 561211143,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764606515
    },
    {
        "content": "<p>Note that PaperProof is implemented as a standalone VSCode extension rather than using ProofWidgets, so those are different approaches</p>",
        "id": 561219138,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1764608030
    },
    {
        "content": "<p>I apologize if I'm misunderstanding something fundamental. Is the following correct:</p>\n<ol>\n<li>ProofWidgets have two parts.</li>\n<li>One is written in Lean and runs inside the Lean server.</li>\n<li>One part is written in Typescript and runs inside the VSCode InfoView.</li>\n</ol>\n<p>I want something a bit different. That I can write in Elixir/Rust, have it run in a separate process (perhaps even over multiple machines), and talk to both Lean4 server &amp; VSCode via websockets/tcpsockets.</p>\n<p>I don't want to use the word \"Agent/Agentic\"; but I want this to \"have a mind of it's own\", to be able to do its own thing, to (1) look at what I'm looking at in vscode, and (2) try to prove stuff independently, and surface anything it finds useful in the infoview.</p>\n<p>Is the existing ProofWidgets/UserWidgets API the best starting place for this ? (One thing I really want, especially in using Exliir, is to \"update my agent code\" while the VSCode/Lean4 continues to run.)</p>",
        "id": 561279014,
        "sender_full_name": "TongKe Xue",
        "timestamp": 1764624689
    },
    {
        "content": "<p>you can structure that by writing a server in your program with a well defined API that takes requests. Separately you can write your own vscode extension that checks whether this server exists and talks to it.</p>",
        "id": 561282660,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764625933
    },
    {
        "content": "<p>The vscode extension can depend on the lean extension and call its methods</p>",
        "id": 561282789,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764625993
    },
    {
        "content": "<p>It's not clear to me. Is the advice here:</p>\n<ol>\n<li>do these two separate parts <strong>without</strong> ProofWidget/UserWidget or</li>\n<li>create a UserWidget that \"wraps external Elixir/Rust process\" by providing a basic API and routing everything to the UserWidget InfoView ?</li>\n</ol>",
        "id": 561290328,
        "sender_full_name": "TongKe Xue",
        "timestamp": 1764629248
    },
    {
        "content": "<p>I am responding to what you said â€œI want this to have a mind of its ownâ€</p>",
        "id": 561299889,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764634845
    },
    {
        "content": "<p>Essentially you can do stuff with proofwidgets or write your own extension. In the former case there are limitations and the proofwidgets repository has documentation and examples</p>",
        "id": 561299967,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764634896
    },
    {
        "content": "<p>In the latter case your only limitation is what the vscode extension API allows</p>",
        "id": 561299992,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764634913
    },
    {
        "content": "<p>Ah, this is my fault for not being clear. Let me try to rephrase this. Consider this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">...</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">...</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">h3</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">...</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>depending on where the cursor is, the infoview is very reactive in showing the proof state at the location of the cursor.</p>\n<p>I am looking for ways to build external tools that are \"more independent\"; I want my plugin to be notified of vscode cursor movement, but be a independent process that can do its own thing.</p>\n<p>For example, imagine a system where:<br>\nc-1 = record current hypothesis / goal state, have external process try to solve it in parallel<br>\nc-2 = list all \"external process search\", allowing us to see how long it's been running for / killing processes</p>\n<p>So to build something like this, I want some external elixir/rust process doing its own thing, talking to vscode/lean4 over websocket/tcpsocket.</p>\n<p>So my question here is: besides the vscode/lean4 extension, is there anything else worth looking into that might have the right \"architecture\" to support something like this?</p>\n<p>Thanks!</p>",
        "id": 561307249,
        "sender_full_name": "TongKe Xue",
        "timestamp": 1764638988
    },
    {
        "content": "<blockquote>\n<p>Is the following correct:</p>\n<ol>\n<li>ProofWidgets have two parts.</li>\n<li>One is written in Lean and runs inside the Lean server.</li>\n<li>One part is written in Typescript and runs inside the VSCode InfoView.</li>\n</ol>\n</blockquote>\n<p>This is essentially right; there are three programs involved: the Lean LSP server, VSCode, and the infoview (the infoview is launched by VSC but it's sandboxed, so for all intents and purposes a separate program). Whenever actions are carried out in VSC, e.g. you move your cursor to another line, VSC informs the infoview about those actions, and the infoview in turns requests the LSP server to provide new information. See also Fig. 9 in <a href=\"https://voidma.in/assets/papers/23nawrocki_extensible_user_interface_lean_4.pdf\">the paper</a>, and the explanation of widget APIs <a href=\"https://lean-lang.org/examples/1900-1-1-widgets/\">here</a>.</p>\n<blockquote>\n<p>you can structure that by writing a server in your program with a well defined API that takes requests. Separately you can write your own vscode extension that checks whether this server exists and talks to it.</p>\n</blockquote>\n<p>I would strongly advise against writing your own extension; everything suggested here should be implementable as a widget.</p>",
        "id": 561518724,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1764709570
    },
    {
        "content": "<blockquote>\n<p>I am looking for ways to build external tools that are \"more independent\"; I want my plugin to be notified of vscode cursor movement, but be a independent process that can do its own thing.</p>\n</blockquote>\n<p>I don't think it follows from your proposed architecture that your agent has to be a separate process; you may as well run it as a parallel <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Task#doc\">docs#Task</a> in the LSP server. But if you really want a separate server program, that should be possible as well.</p>",
        "id": 561519238,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1764709743
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"1001511\">@TongKe Xue</span> here is something to get you started (based on the <a href=\"https://github.com/leanprover-community/ProofWidgets4/blob/main/ProofWidgets/Demos/LazyComputation.lean\">LazyComputation</a> demo). Note that <code>/usr/bin/ps</code> won't run in the Lean playground, but it might run for you locally.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">module</span>\n\n<span class=\"n\">public</span><span class=\"w\"> </span><span class=\"n\">meta</span><span class=\"w\"> </span><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Widget</span>\n<span class=\"n\">public</span><span class=\"w\"> </span><span class=\"n\">meta</span><span class=\"w\"> </span><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">ProofWidgets</span><span class=\"bp\">.</span><span class=\"n\">Component</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"n\">public</span><span class=\"w\"> </span><span class=\"n\">meta</span><span class=\"w\"> </span><span class=\"kn\">section</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">ProofWidgets</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"w\"> </span><span class=\"n\">Server</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Tactic</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">EmptyArgs</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">FromJson</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ToJson</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">server_rpc_method</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">queryPsServer</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">EmptyArgs</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">RequestM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">RequestTask</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">RequestM</span><span class=\"bp\">.</span><span class=\"n\">asTask</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"w\"> </span><span class=\"bp\">â†</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">Process</span><span class=\"bp\">.</span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">cmd</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"/bin/ps\"</span><span class=\"w\"> </span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">res</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">widget_module</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">runnerWidget</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Component</span><span class=\"w\"> </span><span class=\"n\">EmptyArgs</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">javascript</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"</span>\n<span class=\"s2\">    import { RpcContext, mapRpcError } from '@leanprover/infoview'</span>\n<span class=\"s2\">    import * as React from 'react';</span>\n<span class=\"s2\">    const e = React.createElement;</span>\n\n<span class=\"s2\">    export default function(props) {</span>\n<span class=\"s2\">      const [contents, setContents] = React.useState('Run ps!')</span>\n<span class=\"s2\">      const rs = React.useContext(RpcContext)</span>\n<span class=\"s2\">      return e('button', { onClick: () =&gt; {</span>\n<span class=\"s2\">        setContents('Running..')</span>\n<span class=\"s2\">        rs.call('queryPsServer', props)</span>\n<span class=\"s2\">          .then(setContents)</span>\n<span class=\"s2\">          .catch(e =&gt; { setContents(mapRpcError(e).message) })</span>\n<span class=\"s2\">      }}, contents)</span>\n<span class=\"s2\">    }</span>\n<span class=\"s2\">  \"</span>\n\n<span class=\"c1\">-- Put your cursor here</span>\n<span class=\"bp\">#</span><span class=\"n\">widget</span><span class=\"w\"> </span><span class=\"n\">runnerWidget</span>\n</code></pre></div>",
        "id": 561520631,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1764710213
    },
    {
        "content": "<p>Am I right in thinking that <code>#widget</code> cannot respond to document changes below it?</p>",
        "id": 561538342,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1764717689
    },
    {
        "content": "<p>And conversely, can I widget preserve state across re-renders if the document is changed above?</p>",
        "id": 561538376,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1764717713
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/113488-general/topic/extending.20the.20VSCode.20.2F.20Lean4.20UI/near/561538342\">said</a>:</p>\n<blockquote>\n<p>Am I right in thinking that <code>#widget</code> cannot respond to document changes below it?</p>\n</blockquote>\n<p>What kind of changes are you thinking of? If you want to have a widget that sticks around at all times (e.g. like the goal display), you'd use the <code>show_panel_widgets</code> command.</p>",
        "id": 561539045,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1764718056
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/113488-general/topic/extending.20the.20VSCode.20.2F.20Lean4.20UI/near/561538376\">said</a>:</p>\n<blockquote>\n<p>And conversely, can I widget preserve state across re-renders if the document is changed above?</p>\n</blockquote>\n<p>Widgets preserve the UI state for as long as they are visible, and reset the state when they appear again; so <code>show_panel_widgets</code> would also be the thing to use if you want the state to stick around for longer. There is some discussion of this under <a href=\"https://github.com/leanprover-community/ProofWidgets4/pull/141\">ProofWidgets4#141</a>, but TLDR I'm not sure it'd be a good idea for widgets to preserve UI state across re-renders; it's clearer if the Lean file suffices to fully reconstruct the display.</p>",
        "id": 561539332,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1764718200
    },
    {
        "content": "<p>I'm thinking of the case where you want a widget to do work in the background while edits are ongoing in the lean file</p>",
        "id": 561543751,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1764721101
    },
    {
        "content": "<p>Yes, in case there is still ambiguity about that, panel widgets preserve their state while the file is being edited; but they will lose state on certain actions, e.g. if the infoview were reopened.</p>\n<p>Let's suppose we wish to provide an interface to control an army of prover agents that might be quite long-running. Here is how I would probably structure such a thing.</p>\n<ul>\n<li>A standalone server process that keeps track of the running proof jobs with API endpoints like <code>/job_status</code>, <code>/start_job</code>,  etc.</li>\n<li>A panel widget to be used with <code>show_panel_widgets</code> which connects to the server, displays the running jobs, provides some UI to launch a new proof attempt for the <code>sorry</code> under the cursor, and communicates successful job outcomes back to the editor (e.g. by replacing the <code>sorry</code> with the found proof).<ul>\n<li>The \"launch\" button could also be implemented as an LSP code action, but iirc these are not very well-suited for long-running tasks.</li>\n</ul>\n</li>\n</ul>\n<p>The reason I'm suggesting a standalone server as opposed to keeping track of the jobs solely inside the widget JS code is that, per the above discussion, widgets do not preserve state across re-renders. A panel widget displayed via <code>show_panel_widgets</code> is not re-rendered often, but it would be re-rendered if you e.g. reopen the whole infoview.</p>\n<p>One could maybe also store the state in the LSP file worker, but that only lasts as long as a given file worker, i.e., would be cleaned up if you close a Lean file and open another. Iirc there is no way to run custom code in the LSP watchdog (the only Lean server process which actually lives as long as the entire server).</p>\n<p>If the background work you have in mind is quicker (seconds to minutes?), then you may be able to get away without the server component and store all state in the widget.</p>",
        "id": 561779183,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1764811386
    }
]