[
    {
        "content": "<p>In the <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Finite/Defs.html#Finite\">documentation of <code>Finite</code></a> it says </p>\n<p>\"<code>Finite (x ∈ s → β x)</code> follows from the general instance for pi types, assuming <code>[∀ x,  Finite (β x)]</code>\".</p>\n<p>What are they saying here? Is <code>(x ∈ s → β x)</code> a dependent function type? I assume <code>s</code> is finite?</p>",
        "id": 560871198,
        "sender_full_name": "Axel Boldt",
        "timestamp": 1764379090
    },
    {
        "content": "<p>That doesn't quantity over <code>x</code>, only over all proofs about memberships of a particular <code>x</code> in <code>s</code></p>",
        "id": 560872454,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1764380525
    },
    {
        "content": "<p>since <code>Finite (x ∈ s)</code> and <code>∀ (_ : x ∈ s), Finite (β x)</code> therefore by <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Pi.finite#doc\">docs#Pi.finite</a> we have <code>Finite (x ∈ s → β x)</code></p>",
        "id": 560873208,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764381366
    },
    {
        "content": "<p>Sorry if I'm a bit dense. Are we thinking of <code>(x ∈ s → β x)</code> as a proposition that depends on <code>x</code>, <code>s</code> and <code>β</code>, and we are claiming that, under suitable assumptions, this proposition is a finite type? In other words, it has only finitely many proofs? But I thought we don't distinguish between proofs, which would lead me to believe that <em>any</em> proposition is a finite type: it either contains one proof or zero proofs.</p>\n<p>Why then would we every care to state that a certain proposition is finite? Why, for instance, is <code>x ∈ s</code> finite?</p>",
        "id": 560876232,
        "sender_full_name": "Axel Boldt",
        "timestamp": 1764384993
    },
    {
        "content": "<p>it's not a proposition</p>",
        "id": 560876267,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764385046
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"985380\">Axel Boldt</span> <a href=\"#narrow/channel/113488-general/topic/Question.20on.20documentation.20of.20Finite/near/560876232\">said</a>:</p>\n<blockquote>\n<p>But I thought we don't distinguish between proofs, which would lead me to believe that <em>any</em> proposition is a finite type: it either contains one proof or zero proofs.</p>\n</blockquote>\n<p>This is completely correct</p>",
        "id": 560876283,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764385066
    },
    {
        "content": "<p>but <code>β x</code> isn't a proposition so <code>x ∈ s → β x</code> also isn't a proposition</p>",
        "id": 560876356,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764385164
    },
    {
        "content": "<p>It's talking about <code>x ∈ s → β x</code> because it's the motivating case that happens relatively frequently, but the general principle is that <code>p → β</code> is finite if <code>p</code> is a proposition and <code>β</code> is finite, without any special casing for propositions (like you'd need for <code>Fintype</code>). That's because <code>p</code> is <code>Finite</code>, seeing as it has only zero or one elements (no proof, or a proof).</p>",
        "id": 560876358,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1764385170
    },
    {
        "content": "<p>the claim is that if we assume <code>Finite (β x)</code> (in particular, if we assume <code>∀ x, Finite (β x)</code>) then we get <code>Finite (x ∈ s → β x)</code></p>",
        "id": 560876408,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764385211
    },
    {
        "content": "<p>The documentation may be too specific in its audience, of people who are familiar with practical details of <code>Fintype</code>.</p>",
        "id": 560876410,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1764385216
    },
    {
        "content": "<p>I'm still struggling. Is <code>(x ∈ s → β x)</code> a dependent function type, whose elements are functions that assign to every element <code>x</code> of <code>s</code> an element of <code>β x</code>?</p>",
        "id": 560876844,
        "sender_full_name": "Axel Boldt",
        "timestamp": 1764385765
    },
    {
        "content": "<p>no</p>",
        "id": 560876848,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764385775
    },
    {
        "content": "<p>It's a plain old function type.</p>",
        "id": 560876850,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1764385781
    },
    {
        "content": "<p>That's why I changed it to <code>p → β</code> in my comment.</p>",
        "id": 560876874,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1764385807
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"985380\">Axel Boldt</span> <a href=\"#narrow/channel/113488-general/topic/Question.20on.20documentation.20of.20Finite/near/560876844\">said</a>:</p>\n<blockquote>\n<p>a dependent function type, whose elements are functions that assign to every element <code>x</code> of <code>s</code> an element of <code>β x</code>?</p>\n</blockquote>\n<p>that would be <code>(x : α) → x ∈ s → β x</code> or <code>∀ x ∈ s, β x</code> or <code>(x : s) → β x</code></p>",
        "id": 560876881,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764385823
    },
    {
        "content": "<p>(I wrote this docstring a year and a half ago in <a href=\"https://github.com/leanprover-community/mathlib4/pull/9667\">#9667</a>. I wouldn't mind if someone who understands <code>Finite</code> and <code>Fintype</code> could improve the docstring(s) to be less confusing, especially for people trying to make sense of finiteness in Mathlib... It would be good to include a motivating example of the somewhat obscure fact in the docstring that this thread is about.)</p>",
        "id": 560876930,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1764385897
    },
    {
        "content": "<p>I think I'm getting it now, thanks. </p>\n<p>And these function types <code>p → β</code>, where <code>p</code> is a proposition and <code>β</code> is not, do occur in practice?</p>",
        "id": 560877666,
        "sender_full_name": "Axel Boldt",
        "timestamp": 1764386833
    },
    {
        "content": "<p>well they sometimes occur as a subexpression of stuff like <code>(x : α) → x ∈ s → β x</code></p>",
        "id": 560878011,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764387322
    },
    {
        "content": "<p>An example that's close to what's in the docstring is the fact that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finite.Set.finite_iUnion#doc\">docs#Finite.Set.finite_iUnion</a> can handle <code>Finite (⋃ x ∈ s, t x)</code> if the type <code>ι</code> is finite on its own. (The instance <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finite.Set.finite_biUnion%27#doc\">docs#Finite.Set.finite_biUnion'</a> is only needed for the case where <code>s</code> is finite but <code>ι</code> isn't.)</p>\n<p>When <code>Finite.Set.finite_iUnion</code> handles <code>Finite (⋃ x ∈ s, t x)</code>, the function type <code>i ∈ s → Set α</code> appears inside the term.</p>\n<p>The general reason for this is that <code>⋃ x ∈ s, t x</code> is notation for <code>⋃ (x : ι), ⋃ (h : x ∈ s), t x</code>, and we can make sense of finiteness of <code>⋃ (h : x ∈ s), t x</code> on its own (it's <code>t x</code> if <code>x ∈ s</code> is true, and otherwise the empty set — but in any case it doesn't matter that <code>x ∈ s</code> is a proposition).</p>",
        "id": 560878956,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1764388589
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"985380\">Axel Boldt</span> <a href=\"#narrow/channel/113488-general/topic/Question.20on.20documentation.20of.20Finite/near/560877666\">said</a>:</p>\n<blockquote>\n<p>And these function types <code>p → β</code>, where <code>p</code> is a proposition and <code>β</code> is not, do occur in practice?</p>\n</blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Option.get#doc\">docs#Option.get</a> is an example, a function that requires a proposition to be true for the output to be valid.</p>",
        "id": 560879044,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1764388719
    }
]