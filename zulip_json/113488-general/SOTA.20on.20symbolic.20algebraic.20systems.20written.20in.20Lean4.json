[
    {
        "content": "<p>Hi,</p>\n<p>I wanted to know what is the SOTA symbolic algebra system written in Lean compatible with mathlib? </p>\n<p>Best,<br>\nVatsa</p>",
        "id": 492601497,
        "sender_full_name": "Srivatsa Srinivas",
        "timestamp": 1736379595
    },
    {
        "content": "<p>What is one ‚Äúsymbolic algebra system written in Lean compatible with mathlib‚Äù?</p>",
        "id": 492611429,
        "sender_full_name": "Jason Rute",
        "timestamp": 1736385428
    },
    {
        "content": "<p>There are tactics that do various degrees of manipulation, but is there anything like Mathematica, Maple, or Sage?  Also Mathlib isn‚Äôt really about computation.  (Like I thought I heard polynomials in Mathlib aren‚Äôt even something you can compute with?)</p>",
        "id": 492611859,
        "sender_full_name": "Jason Rute",
        "timestamp": 1736385717
    },
    {
        "content": "<p>I‚Äôm not an expert so feel free to tell me there is something out there that does fit this criteria.  It would be really cool if there was.  A long time ago I saw <a href=\"https://www.cs.ru.nl/~freek/pubs/holcas.pdf\">a paper</a> by Cezary Kaliszyk and <span class=\"user-mention\" data-user-id=\"217807\">@Freek Wiedijk</span> about creating a verified computer algebra system prototype in HOL Light.</p>",
        "id": 492612260,
        "sender_full_name": "Jason Rute",
        "timestamp": 1736385978
    },
    {
        "content": "<p>And <span class=\"user-mention\" data-user-id=\"110596\">@Rob Lewis</span> et al once made a <a href=\"https://arxiv.org/abs/2101.07758\">Lean-Mathematica interface</a></p>",
        "id": 492612381,
        "sender_full_name": "Jason Rute",
        "timestamp": 1736386070
    },
    {
        "content": "<p>I guess if one did make a CAS in Lean they would need to figure out what data types to use for symbolic expressions?  If they use <code>Expr</code> then you couldn‚Äôt prove things about the algorithm I think, but it would be compatible with tactics and you would enter the expressions as Lean code.  If they used custom symbolic expression datatypes, then they could use them for computing and interfacing with Mathlib, but you would enter them in a different way that you normally enter expressions in Lean.  (I haven‚Äôt really thought this through.  Maybe someone else has.)</p>",
        "id": 492612956,
        "sender_full_name": "Jason Rute",
        "timestamp": 1736386430
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"115715\">@Jason Rute</span>   Thank you for the comprehensive answer. It would be nice to have a CAS built in Lean4 because that would reduce the dependency on SageMath, Mathematica, Maple etc. I was just wondering if anyone had already started this project, because if not I will apply to the AI in Math grant with a proposal along the lines of writing a CAS in lean</p>",
        "id": 492756694,
        "sender_full_name": "Srivatsa Srinivas",
        "timestamp": 1736438329
    },
    {
        "content": "<p>I think the Agda style of programming bridges the gap between computation and proof more clearly, but is also not nearly as performant. Having read the codebase of SymPy it would be fun to try and see what a \"Lean-ish\" CAS would look like</p>",
        "id": 492757099,
        "sender_full_name": "Srivatsa Srinivas",
        "timestamp": 1736438423
    },
    {
        "content": "<p>Also see <a href=\"#narrow/channel/113488-general/topic/What.20should.20Sage.20look.20like.20in.20Lean.3F\">https://leanprover.zulipchat.com/#narrow/channel/113488-general/topic/What.20should.20Sage.20look.20like.20in.20Lean.3F</a></p>",
        "id": 492763954,
        "sender_full_name": "Jason Rute",
        "timestamp": 1736440220
    },
    {
        "content": "<p>What design plans do you have?  For example, would it be run inside a Lean file, or in a separate application?  If inside Lean, how would you implement something like Simplify(x^2 + (x+1)^2)?  Would Simplify be a lean function, a tactic, or a totally different thing?  And what would <code>x^2 + (x+1)^2</code> be?  It couldn‚Äôt be an object of type <code>Reals -&gt; Reals</code> since you can‚Äôt compute with those and because of functional extensionality it would just be the identity function).  It could be of type<code>Expr</code>.  You can compute with that, and that is how tactics work, but would you be returning an expression then?  Can one connect expressions like this to Mathlib types?  It might be possible (and maybe tactics like <code>ring_nf</code> already do this sort of thing).  Or you could have your own intermediate expression type.  I would certainly like to see something like a formally verified CAS, and it seems like once one works out the design it could share a lot of code with existing tactics and with Mathlib.</p>",
        "id": 492767028,
        "sender_full_name": "Jason Rute",
        "timestamp": 1736441045
    },
    {
        "content": "<p>I think that type isomorphisms would be the main benefit of writing a CAS in dependent type theory. For example, one could prove that K[x] is isomorphic via a function \\phi to elements of \\sigma_{n \\in \\mathbb{N}_{\\geq 0}} Vec n K \\times \\mathbb{N}_{\\geq 0} sorted by the second value in the pair. This isomorphism will commute with equality (as in x = y iff \\phi (x) = \\phi(y)). We would then perform all the computations on side of the type isomorphism and then pull back the equality to the other side. </p>\n<p>I guess the main benefit would be writing all the CAS algorithms in Lean4, with types that are isomorphic to standard objects in mathematics. This can give performance boosts as the Lean4 virtual machine gets better, reduce errors in implementations of algorithms and provide \"Batteries\" in order to rigorously perform calculations that appear in research</p>",
        "id": 492845119,
        "sender_full_name": "Srivatsa Srinivas",
        "timestamp": 1736467819
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 492845849,
        "sender_full_name": "Srivatsa Srinivas",
        "timestamp": 1736468153
    },
    {
        "content": "<p>I had some success in using typeclass inference to synthesize a computable representation for a term of type <code>Polynomial _</code> (constructed using possibly noncomputable operations) here: <a class=\"message-link\" href=\"/#narrow/channel/113489-new-members/topic/Compute.20roots.20of.20polynomials/near/420832934\">#new members &gt; Compute roots of polynomials @ üí¨</a> It's not clear whether it's a superior or inferior approach compared to tactics.</p>\n<p>You might also be interested in some relatively recent/ongoing work <a href=\"https://github.com/leanprover-community/mathlib4/pull/12611\">#12611</a> to improve the performance of certain <code>#eval</code> calls for symmetric groups.</p>",
        "id": 492863307,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1736476874
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"688984\">@Srivatsa Srinivas</span> by CAS do you just mean computing with mathematical objects?  Like a counterpart to Mathlib that focuses on computation?</p>",
        "id": 492867105,
        "sender_full_name": "Jason Rute",
        "timestamp": 1736478800
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"115715\">@Jason Rute</span> Originally, I thought that it would be nice to create a CAS where the outputs are \"refl\" objects, for example Simplify(x^2 + (x+1)^2) would return a term of type x^2 + (x+1)^2 = 2x^2 + 2x + 1, but after some deliberation, I think the Lean-ish way of creating a term of the type x^2 + (x+1)^2 = 2x^2 + 2x + 1  : Prop would be the goal. I understand that tactics already do this. </p>\n<p>But I would like to write the \"backend that does the calculation\" in Lean4 as opposed to whatever the implementation is in SageMath. I think that this would be productive as dependent type theory can basically express most every mathematical computation we care about and so the \"backend\" has potential to be much more rigorous. Eventually, the most pragmatic approach would be to convert every \"backend computation\" into a proposition, because even defining a data type for sorted vectors, which are equivalent to polynomials, seems awful</p>",
        "id": 492869121,
        "sender_full_name": "Srivatsa Srinivas",
        "timestamp": 1736479786
    },
    {
        "content": "<p>I guess I am just rediscovering what a tactic is. But it would be nice to have a package of standard CAS algorithms such as Berkelamp, Gosper etc. implemented in Lean4 that generate propositions</p>",
        "id": 492869813,
        "sender_full_name": "Srivatsa Srinivas",
        "timestamp": 1736480120
    },
    {
        "content": "<p>Note that it is not necessary to do everything in lean. One of mathlib‚Äôs most successful tactics is <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Tactic/Polyrith.html\">polyrith</a>, which calls on a Sage procedure. You only need to be able to reconstruct the <em>proof</em> in lean, and that can be done by modifying whatever software is already there so that it provides some intermediate steps instead of just the final result. You might find this approach to be more practical, instead of doing everything from scratch</p>",
        "id": 492916578,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1736503780
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"466290\">@Luigi Massacci</span> Great point. Do you think it would <strong>not</strong> be easier to construct proof certificates from CAS algorithms written in Lean4 as opposed to those written in XYZ language that SageMath calls? I have no clue as I'm starting to get my toes wet with lean after experience with Haskell</p>",
        "id": 492991274,
        "sender_full_name": "Srivatsa Srinivas",
        "timestamp": 1736528943
    },
    {
        "content": "<p>I'd imagine having access to terms of the type : Prop would make it easier, as opposed to creating an ad-hoc method per program in SageMath</p>",
        "id": 492991602,
        "sender_full_name": "Srivatsa Srinivas",
        "timestamp": 1736529061
    },
    {
        "content": "<p>Well, it depends on how much work it is to write the algorithm from scratch, and whether it is possible to verify the output of a computation without having to verify the computation itself.  For example you mentioned polynomial factorisation in finite fields: when using a tactic like that, you don‚Äôt care how the factors have been generated anyway, so you can use other (already existing) software to give you the polynomials, and then have lean verify only that they are actually factors, which is significantly easier!</p>",
        "id": 493014145,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1736537771
    },
    {
        "content": "<p>(polyrith does more or less this for a similar problem)</p>",
        "id": 493014397,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1736537895
    },
    {
        "content": "<p>Thanks for the explanation. I now see that why it might be futile to write a CAS in Lean in order to generate proof certificates for computations whose answer itself contains a proof certificate</p>",
        "id": 493024208,
        "sender_full_name": "Srivatsa Srinivas",
        "timestamp": 1736542534
    },
    {
        "content": "<p>In the long run, sure, let's have an entire new CAS written in Lean, integrated with the Mathlib in some form! But that's not the low-hanging fruit, as Luigi has explained.</p>\n<p>I do hope to see lots more \"interesting mathematical algorithms\" implemented in Lean, even without proofs, and even without solving the giant problem of \"how to represent polynomials for computation\". Can we have LLL or PSLQ implemented in Lean, please? :-)</p>",
        "id": 493044448,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1736554032
    },
    {
        "content": "<p>That sounds like a good goal!</p>\n<p>Luigi is definitely correct that a CAS in Lean will not be an improvement over current technology for the most frequent use cases, but it might be a good academic exercise to construct a CAS in a language with dependent types. </p>\n<p>Proofs of algorithms are also very important, as teaching an AI to create new algorithms rigorously would definitely be a good thing.</p>\n<p>Unrelated question, <span class=\"user-mention\" data-user-id=\"466290\">@Luigi Massacci</span> do you know if Lean has any strategies for parallel programming?</p>",
        "id": 493045820,
        "sender_full_name": "Srivatsa Srinivas",
        "timestamp": 1736555066
    },
    {
        "content": "<p>I don‚Äôt have the faintest idea, you should go ask in <a class=\"stream\" data-stream-id=\"270676\" href=\"/#narrow/channel/270676-lean4\">#lean4</a> or <a class=\"stream\" data-stream-id=\"239415\" href=\"/#narrow/channel/239415-metaprogramming-.2F-tactics\">#metaprogramming / tactics</a></p>",
        "id": 493077978,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1736584654
    },
    {
        "content": "<p>Lean has a Task which allows parallel computing. I have used this. But it's rather low level as far as I know</p>",
        "id": 493084763,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1736591125
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 493097396,
        "sender_full_name": "Srivatsa Srinivas",
        "timestamp": 1736602985
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"688984\">Srivatsa Srinivas</span> <a href=\"#narrow/channel/113488-general/topic/SOTA.20on.20symbolic.20algebraic.20systems.20written.20in.20Lean4/near/492869121\">said</a>:</p>\n<blockquote>\n<p>Originally, I thought that it would be nice to create a CAS where the outputs are \"refl\" objects, for example Simplify(x^2 + (x+1)^2) would return a term of type x^2 + (x+1)^2 = 2x^2 + 2x + 1, but after some deliberation, I think the Lean-ish way of creating a term of the type x^2 + (x+1)^2 = 2x^2 + 2x + 1  : Prop would be the goal. I understand that tactics already do this. </p>\n</blockquote>\n<p>I think CAS in Lean could be:</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>#cas simplify (x^2 + (x+1)^2)\n</code></pre></div>\n<p>Then it outputs:</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>Try this: have : x^2 + (x+1)^2 = 2*x^2 + 2*x + 1 := by ring\n</code></pre></div>\n<p>And</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>#cas simplify ((Real.sin x)^2 + (Real.cos y)^2)\n</code></pre></div>\n<p>Then it outputs:</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>Try this: have : (Real.sin x)^2 + (Real.cos y)^2 = 1 := Real.sin_sq_add_cos_sq x\n</code></pre></div>\n<p>(This two examples are a bit too easy, as they already covered by existing results/tactics in mathlib. But I couldn't think of a more complex example now.)</p>\n<p>Besides <code>simplify</code>, we could also have <code>factor</code>, etc. etc.</p>",
        "id": 493267562,
        "sender_full_name": "Jz Pan",
        "timestamp": 1736749244
    },
    {
        "content": "<p>It doesn't even need <code>#cas</code>. <code>#factor</code> could output a <code>Try this: have ...</code>. I guess one could even have a <code>#simp</code> that outputs a Try this.</p>",
        "id": 493322910,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1736766732
    },
    {
        "content": "<p>I'd attempted a basic experiment of this sort a while back using PARI-GP: <a href=\"#narrow/channel/270676-lean4/topic/Basic.20unverified.20symbolic.20calculations.20in.20Lean4.20using.20PARI/near/347676108\"><a class=\"message-link\" href=\"/#narrow/channel/270676-lean4/topic/Basic.20unverified.20symbolic.20calculations.20in.20Lean4.20using.20PARI/near/347676108\">#lean4 &gt; Basic unverified symbolic calculations in Lean4 using PARI @ üí¨</a></a>. My code was more of a toy experiment proof-of-concept than a serious attempt at integrating symbolic algebra with Lean, but I thought I'd share it anyway since it may be relevant to this thread.</p>",
        "id": 493387258,
        "sender_full_name": "Anand Rao Tadipatri",
        "timestamp": 1736784078
    },
    {
        "content": "<p>Suppose that instead of thinking of <code>x^2 + (x+1)^2</code> as an \"expression\", we were to simply think of it as a polynomial in <code>x</code> (writing it as <code>Polynomial.X ^ 2 + (Polynomial.X + 1) ^ 2</code>), and then have a computable function that factors a polynomial and returns the multiset of irreducible factors. Would this approach fall short of being a \"symbolic algebraic system\"?</p>\n<p>The reason I ask is that Mathematica's strange handling of expressions is often more of a hindrance than a help. (Though at the same time, I see why it might sometimes be useful to be able to write something like <code>(1 + x) ^ 1000000000</code> and not have the computer immediately try to evaluate it.)</p>",
        "id": 493800801,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1736927554
    },
    {
        "content": "<p>It's complicated, and we need some of both approaches:</p>\n<ul>\n<li>tactics like <code>ring</code> working on with untyped <code>Expr</code> (not so far from what Mathematica does, although with lots of clever tricks to avoid typeclass resolution when building new expressions)</li>\n<li>functions that commit to specific computational representations of mathematical objects (e.g. polynomials), and run algorithms on them (these then come with tactic frontends that can reflect <code>Expr</code> representations into the specific representations, i.e. equipped with <code>denote</code>/<code>eval</code> etc functions)</li>\n</ul>",
        "id": 493812067,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1736931734
    },
    {
        "content": "<p>Cross posting: <a href=\"#narrow/stream/113488-general/topic/Juniper.20-.20toy.20Rust.20CAS.20with.20Lean.20specifications\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Juniper.20-.20toy.20Rust.20CAS.20with.20Lean.20specifications</a></p>",
        "id": 493911993,
        "sender_full_name": "Jason Rute",
        "timestamp": 1736943276
    },
    {
        "content": "<p>I can think of a problem which does not have a trivial verification procedure given the answer, but a CAS can compute: The definite integral of a function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mo>‚à´</mo><mi>a</mi><mi>b</mi></msubsup><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mtext>‚Äâ</mtext><mi>d</mi><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">\\int_a^b f(x) \\, dx</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.3998em;vertical-align:-0.3558em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"margin-right:0.19445em;position:relative;top:-0.0006em;\">‚à´</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.044em;\"><span style=\"top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">a</span></span></span><span style=\"top:-3.2579em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">b</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3558em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">x</span></span></span></span>. The CAS would have to create a proof that the definite integral has the particular answer, basically creating a proof by applying the rule it used to transform the integral at each point. </p>\n<p>Obviously, symbolic differentiation being easy means that indefinite integrals can be proved using just the answer.</p>",
        "id": 494027348,
        "sender_full_name": "Srivatsa Srinivas",
        "timestamp": 1736979520
    },
    {
        "content": "<p>The difference between indefinite and definite integrals is \"just\" giving a proof of an evaluation of a function. This, I think, is the job of <code>norm_num</code> and its successors.</p>",
        "id": 494029906,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1736980791
    },
    {
        "content": "<p>There are computable definite integrals in cases where there is no closed form indefinite integral, though.</p>",
        "id": 494030017,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1736980837
    },
    {
        "content": "<p>I think it would be a good idea to have a stream for CAS in lean. There are a lot of ideas and implementations floating around and it would be good to coordinate more</p>",
        "id": 497456823,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1738594484
    },
    {
        "content": "<p><a class=\"stream\" data-stream-id=\"482893\" href=\"/#narrow/channel/482893-Computer-algebra\">#Computer algebra</a></p>",
        "id": 497553518,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1738626187
    }
]