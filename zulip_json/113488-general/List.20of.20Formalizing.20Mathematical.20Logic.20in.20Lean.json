[
    {
        "content": "<p>I noticed that there're other projects working on formalization of mathematical logic in Lean 4 besides our projects (FFL).  I'll note here those repositories similar aspiration to ours (still maintaining recently).</p>\n<ul>\n<li><a href=\"https://github.com/FormalizedFormalLogic/Foundation\">FormalizedFormalLogic/Foundation</a>: Maintained by <span class=\"user-mention\" data-user-id=\"414485\">@Palalansouk√Æ</span> and <span class=\"user-mention\" data-user-id=\"543250\">@SnO2WMaN</span> . <ul>\n<li>We've done G√∂del's 1st and 2nd Incompleteness for nice theory over resp. Cobham's weakest theory <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"sans-serif\">R</mi><mn mathvariant=\"sans-serif\">0</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\mathsf{R_0}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3089em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathsf mtight\">0</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mi mathvariant=\"sans-serif\">I</mi><mi mathvariant=\"sans-serif\">Œ£</mi></mrow><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\mathsf{I\\Sigma}_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathsf\">IŒ£</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, Moreover recently we formalized celebrating result about provability logic, Solovay's arithmetical completeness, that provability logic of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"sans-serif\">P</mi><mi mathvariant=\"sans-serif\">A</mi></mrow><annotation encoding=\"application/x-tex\">\\mathsf{PA}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">PA</span></span></span></span></span> is exactly modal logic <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"sans-serif\">G</mi><mi mathvariant=\"sans-serif\">L</mi></mrow><annotation encoding=\"application/x-tex\">\\mathsf{GL}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">GL</span></span></span></span></span>. Refer to README for more results (I omit about modal logic).</li>\n<li>We're planning / working on<ul>\n<li>Classification of provability logic</li>\n<li>Axiomatic set theory (ZF, ZFC): we contacts to some experts in set theory (not experts in Lean/formlization). </li>\n<li>2nd-order arithmetic</li>\n<li>Bounded arithmetic</li>\n<li>Functional Interpretation and related results (e.g. G√∂del's T)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/staroperator/mathematical-logic-in-lean\">staroperator/mathematical-logic-in-lean</a>: Maintained by <span class=\"user-mention\" data-user-id=\"734814\">@Dexin Zhang</span> <ul>\n<li>G√∂del's Completeness Theorem, Representation Theorem of Robinson's <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"sans-serif\">Q</mi></mrow><annotation encoding=\"application/x-tex\">\\mathsf{Q}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8194em;vertical-align:-0.125em;\"></span><span class=\"mord mathsf\">Q</span></span></span></span> </li>\n<li>2nd-order arithmetic and ZF. </li>\n</ul>\n</li>\n<li><a href=\"https://github.com/ruplet/formalization-of-bounded-arithmetic\">ruplet/formalization-of-bounded-arithmetic</a>: Maintained by <span class=\"user-mention\" data-user-id=\"892220\">@Pawe≈Ç Balawender</span><ul>\n<li>About bounded arithmetic. Refer: <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/channel/287929-mathlib4/topic/Formalization.20of.20arithmetic.3A.20Reviewer.20needed.21/with/540910499\">#mathlib4 &gt; Formalization of arithmetic: Reviewer needed!</a> </li>\n</ul>\n</li>\n</ul>\n<p>Since these repos might be similar goals. It'd be delighted if we could exchange ideas or integrate results in some way. Let me know if there're any other repositories related mathematical logic. I'm not sure about computational theory, categorical logic, or many various area, so I have temporary omitted them from this list.</p>",
        "id": 540911054,
        "sender_full_name": "SnO2WMaN",
        "timestamp": 1758586772
    },
    {
        "content": "<p>Thanks for mentioning my repo <span aria-label=\"smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"smile\">:smile:</span> I think FFL is pretty complete on collecting and formalizing results in mathematical logic, and I'm trying to make my repo as a playground of my personal ideas that FFL is not designed for, e.g. to formalize Hilbert's system or to write pure syntactic proofs. I'm definitely open to exchange ideas or integrate results anyway!</p>",
        "id": 540917991,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1758593699
    },
    {
        "content": "<p>By the way, I'm also working on formalizing some results about Presburger arithmetic, which are directly PRed to mathlib (see <a href=\"https://github.com/leanprover-community/mathlib4/pull/27342\">#27342</a> or <a href=\"https://github.com/leanprover-community/mathlib4/pull/27100\">#27100</a>), and I know <span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> has made some work on axiomatic ZFC in <a href=\"https://github.com/leanprover-community/mathlib4/pull/26644\">#26644</a>.</p>",
        "id": 540918747,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1758594343
    },
    {
        "content": "<p>Existential rules (<a href=\"https://github.com/monsterkrampe/Existential-Rules-in-Lean\">monsterkrampe/Existential-Rules-in-Lean</a>) would be vaguely related. At least they form a fragment of FOL. However, my current efforts are quite different from what you people are working on. Right now, I'm mostly concerned with proving things about their reasoning algorithm called the \"chase\". For the chase, one can almost ignore that it's really FOL. Still, I think in the future it would make sense to make a few more connections to FOL.<br>\nSo despite current efforts being sufficiently different, I just wanted to mention it here since I was not sure if the connection was obvious :)</p>",
        "id": 540939597,
        "sender_full_name": "Lukas Gerlach",
        "timestamp": 1758610196
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/cslib\">cslib</a> also has some preliminary results on logic ‚Äî </p>\n<ul>\n<li><span class=\"user-mention\" data-user-id=\"929508\">@Fabrizio Montesi</span> &amp; <span class=\"user-mention\" data-user-id=\"677310\">@Tanner Duve</span> have been working on classical linear logic (sequent calculus, phase semantics)</li>\n<li>I have a branch with the basics of intuitionistic natural deduction (syntax, soundness &amp; completeness of Heyting algebra semantics) ‚Äî I suspected this might be duplicating work from FFL but that doesn't seem to be the case?</li>\n</ul>",
        "id": 540940906,
        "sender_full_name": "Thomas Waring",
        "timestamp": 1758610748
    },
    {
        "content": "<p>Thanks for mentioning my repo and creating this thread! I love the work you‚Äôre doing in FFL - my work is replicating some of results you have, but in a faithful way; doing the proofs with B1-B9 axioms clearly displayed etc. </p>\n<p>This is a big FOL project in the Rocq community: <a href=\"https://github.com/uds-psl/coq-library-fol\">Rocq FOL Lib</a>. They create a deep embedding of the deduction system for FOL and enable you to both prove theorems inside the weak logic, and prove meta-theorems about it such as completeness. As a matter of fact, I am currently at INRIA visiting Yannick Forster to exchange our ideas on formalization. For now I will not be able to replicate my results in their library, as it lacks some functionality I need and documentation. Ultimately though, operating in a library such as theirs (and conducting proofs in the deep embedding) would make code extraction easier, and also susceptible for formalization. I am interested to learn how the deep embeddings in Lean linked above work.</p>\n<p><span class=\"user-mention\" data-user-id=\"543250\">@SnO2WMaN</span> are you interested in the style of formalization of a weaker logic that doesn‚Äôt use completeness theorem, but rather quantifies over every model and this way, enables you to transfer arithmetical proofs from paper to computer 1:1? If so, I will be glad to connect our work and, hopefully, get some of it to mathlib. My number 1 goal is to design this library in such a way that people who know logic / arithmetic, but <em>don‚Äôt</em> know Lean, will believe the formalization and, perhaps, will be able to write in it</p>",
        "id": 540945198,
        "sender_full_name": "Pawe≈Ç Balawender",
        "timestamp": 1758612469
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"931332\">Thomas Waring</span> <a href=\"#narrow/channel/113488-general/topic/List.20of.20Formalizing.20Mathematical.20Logic.20in.20Lean/near/540940906\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://github.com/leanprover/cslib\">cslib</a> also has some preliminary results on logic ‚Äî </p>\n<ul>\n<li><span class=\"user-mention silent\" data-user-id=\"929508\">Fabrizio Montesi</span> &amp; <span class=\"user-mention silent\" data-user-id=\"677310\">Tanner Duve</span> have been working on classical linear logic (sequent calculus, phase semantics)</li>\n<li>I have a branch with the basics of intuitionistic natural deduction (syntax, soundness &amp; completeness of Heyting algebra semantics) ‚Äî I suspected this might be duplicating work from FFL but that doesn't seem to be the case?</li>\n</ul>\n</blockquote>\n<p>Maybe it would be cool to create <code>Mathlib.ProofTheory</code> next to <code>Mathlib.ModelTheory</code>, where one could, in a uniform way, study all the different proof calculi we have invented over the years? Much of the machinery (such as convenient syntactical macros, substitution, variable binding) would transfer between:</p>\n<ul>\n<li>Hilbert systems (also called Frege proof systems) + results about combinatory calculus</li>\n<li>Gentzen's systems: PK, PJ, LK, LJ</li>\n<li>systems for first- and second-order logic / for typed lamda calculi / for propositional calculus, quantifier propositional calculus etc.</li>\n<li>proof systems such as cutting planes and resolution</li>\n</ul>\n<p>To be honest, even having the definitions and history of all of these in a single place would be a huge added value :)</p>",
        "id": 540987463,
        "sender_full_name": "Pawe≈Ç Balawender",
        "timestamp": 1758626595
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"931332\">Thomas Waring</span> <a href=\"#narrow/channel/113488-general/topic/List.20of.20Formalizing.20Mathematical.20Logic.20in.20Lean/near/540940906\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://github.com/leanprover/cslib\">cslib</a> also has some preliminary results on logic ‚Äî </p>\n<ul>\n<li><span class=\"user-mention silent\" data-user-id=\"929508\">Fabrizio Montesi</span> &amp; <span class=\"user-mention silent\" data-user-id=\"677310\">Tanner Duve</span> have been working on classical linear logic (sequent calculus, phase semantics)</li>\n<li>I have a branch with the basics of intuitionistic natural deduction (syntax, soundness &amp; completeness of Heyting algebra semantics) ‚Äî I suspected this might be duplicating work from FFL but that doesn't seem to be the case?</li>\n</ul>\n</blockquote>\n<p>In FFL, we also have formalizations of intuitionistic propositional logic as well as superintuitionistic propositional logics. Most of these are defined in the Hilbert style and studied via Kripke semantics, but it should also be possible to approach them through algebraic semantics. Please take a look at the following link. (In the latest branch, the work is still in progress and the code is quite messy!)</p>\n<p><a href=\"https://github.com/FormalizedFormalLogic/Foundation/tree/a8ac03ddfb54dd30c3f13b603a20088ba81535cd/Foundation/Propositional\">https://github.com/FormalizedFormalLogic/Foundation/tree/a8ac03ddfb54dd30c3f13b603a20088ba81535cd/Foundation/Propositional</a></p>",
        "id": 540993234,
        "sender_full_name": "SnO2WMaN",
        "timestamp": 1758628485
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"892220\">Pawe≈Ç Balawender</span> <a href=\"#narrow/channel/113488-general/topic/List.20of.20Formalizing.20Mathematical.20Logic.20in.20Lean/near/540987463\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"931332\">Thomas Waring</span> <a href=\"#narrow/channel/113488-general/topic/List.20of.20Formalizing.20Mathematical.20Logic.20in.20Lean/near/540940906\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://github.com/leanprover/cslib\">cslib</a> also has some preliminary results on logic ‚Äî </p>\n<ul>\n<li><span class=\"user-mention silent\" data-user-id=\"929508\">Fabrizio Montesi</span> &amp; <span class=\"user-mention silent\" data-user-id=\"677310\">Tanner Duve</span> have been working on classical linear logic (sequent calculus, phase semantics)</li>\n<li>I have a branch with the basics of intuitionistic natural deduction (syntax, soundness &amp; completeness of Heyting algebra semantics) ‚Äî I suspected this might be duplicating work from FFL but that doesn't seem to be the case?</li>\n</ul>\n</blockquote>\n<p>Maybe it would be cool to create <code>Mathlib.ProofTheory</code> next to <code>Mathlib.ModelTheory</code>, where one could, in a uniform way, study all the different proof calculi we have invented over the years? Much of the machinery (such as convenient syntactical macros, substitution, variable binding) would transfer between:</p>\n<ul>\n<li>Hilbert systems (also called Frege proof systems) + results about combinatory calculus</li>\n<li>Gentzen's systems: PK, PJ, LK, LJ</li>\n<li>systems for first- and second-order logic / for typed lamda calculi / for propositional calculus, quantifier propositional calculus etc.</li>\n<li>proof systems such as cutting planes and resolution</li>\n</ul>\n<p>To be honest, even having the definitions and history of all of these in a single place would be a huge added value :)</p>\n</blockquote>\n<p>Thanks for the mention, this is very interesting.</p>\n<p>There's a big <code>Logics</code> directory in cslib, where we aim at having these and more (well, lambda calculus lives in <code>Languages</code>), including also different kinds of modal logics.<br>\nI started from the sequent calculus of classical linear logic just because I know it by heart, but I'd like to work actively on finding common pattern, developing encodings between logics, applying these logics to various problems, etc.</p>\n<p>I'll have a look at the other pointers asap. If there's interest in discussing a joint effort (I have it!), I'd be happy to support it in cslib.</p>",
        "id": 540996061,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1758629291
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"892220\">Pawe≈Ç Balawender</span> <a href=\"#narrow/channel/113488-general/topic/List.20of.20Formalizing.20Mathematical.20Logic.20in.20Lean/near/540945198\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"543250\">SnO2WMaN</span> are you interested in the style of formalization of a weaker logic that doesn‚Äôt use completeness theorem, but rather quantifies over every model and this way, enables you to transfer arithmetical proofs from paper to computer 1:1? If so, I will be glad to connect our work and, hopefully, get some of it to mathlib. My number 1 goal is to design this library in such a way that people who know logic / arithmetic, but <em>don‚Äôt</em> know Lean, will believe the formalization and, perhaps, will be able to write in it</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"892220\">Pawe≈Ç Balawender</span> <a href=\"#narrow/channel/113488-general/topic/List.20of.20Formalizing.20Mathematical.20Logic.20in.20Lean/near/540987463\">said</a>:</p>\n<blockquote>\n<p>Maybe it would be cool to create <code>Mathlib.ProofTheory</code> next to <code>Mathlib.ModelTheory</code>, where one could, in a uniform way, study all the different proof calculi we have invented over the years? Much of the machinery (such as convenient syntactical macros, substitution, variable binding) would transfer between:</p>\n<ul>\n<li>Hilbert systems (also called Frege proof systems) + results about combinatory calculus</li>\n<li>Gentzen's systems: PK, PJ, LK, LJ</li>\n<li>systems for first- and second-order logic / for typed lamda calculi / for propositional calculus, quantifier propositional calculus etc.</li>\n<li>proof systems such as cutting planes and resolution</li>\n</ul>\n<p>To be honest, even having the definitions and history of all of these in a single place would be a huge added value :)</p>\n</blockquote>\n<p>My specialty is modal logic, so I‚Äôm not especially interested in the approach that converts pen-and-paper proofs from bounded arithmetic or arithmetic in general into Lean proofs ‚Äî sorry. I might be happy if someone could convert Lean proofs into the deep-embedded FOL-Formalized-in-Lean style, but that feels like a different goal.</p>\n<p>From our perspective, porting formal-logic results into mathlib as a general library is not very realistic or practical. Since logical systems tend to be adapted to concrete applications, small differences between a canonical library and a project‚Äôs custom implementation can cause large mismatches, and at that point providing a single library doesn‚Äôt make much sense. <br>\nThat said, IMO, the FOL part of FFL is well thought-out, and its notation is in many ways more polished than mathlib‚Äôs (I haven‚Äôt been involved in that work, the whole design is by <span class=\"user-mention\" data-user-id=\"414485\">@Palalansouk√Æ</span> ). You may compare <a href=\"https://github.com/leanprover-community/mathlib4/pull/26644\">ZFC PR in Mathlib #26644</a> and the current ZFC development in FFL (<a href=\"https://github.com/FormalizedFormalLogic/Foundation/blob/master/Foundation/FirstOrder/SetTheory/Axioms.lean\">defining axioms</a> and <a href=\"https://github.com/FormalizedFormalLogic/Foundation/blob/master/Foundation/FirstOrder/Z/Basic.lean\">model discussion</a>)<br>\nAt the very least, I would personally be inclined to keep something like <code>Mathlib.ProofTheory</code> self-contained inside FFL/Foundation rather than trying to force it into mathlib.</p>",
        "id": 540998320,
        "sender_full_name": "SnO2WMaN",
        "timestamp": 1758629919
    },
    {
        "content": "<p>To expand on what I want to do within FFL, my focus is on modal logic. <br>\nSpecifically, I want to formalize various sequent calculi for modal logic (for example, labeled sequent calculi, hypersequent calculi, display calculi, etc.), show their equivalences, and work on automating in modal logic. The latter seems feasible using labeled sequent calculi or tableau calculi. Achieving this would allow for a significant reduction in the size of modal-logic code. Currently, writing formal proof in modal logic is quite messy,  for example, something as basic as the duality of ‚ñ° and ‚óá becomes extremely cumbersome if one doesn‚Äôt appeal to Kripke semantics once things get slightly complex. Auto-proving would be very convenient, but I don‚Äôt have much prior experience with formalization in this area. I would greatly welcome collaboration from anyone who has expertise in this aspect.</p>",
        "id": 541000663,
        "sender_full_name": "SnO2WMaN",
        "timestamp": 1758630477
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"892220\">@Pawe≈Ç Balawender</span> . I was impressed by how you are formalizing difficult results.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"892220\">Pawe≈Ç Balawender</span> <a href=\"#narrow/channel/113488-general/topic/List.20of.20Formalizing.20Mathematical.20Logic.20in.20Lean/near/540945198\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"543250\">SnO2WMaN</span> are you interested in the style of formalization of a weaker logic that doesn‚Äôt use completeness theorem, but rather quantifies over every model and this way, enables you to transfer arithmetical proofs from paper to computer 1:1? If so, I will be glad to connect our work and, hopefully, get some of it to mathlib. My number 1 goal is to design this library in such a way that people who know logic / arithmetic, but <em>don‚Äôt</em> know Lean, will believe the formalization and, perhaps, will be able to write in it</p>\n</blockquote>\n<p>I might be misunderstanding something, but I think this is the same as our approach.</p>\n<p>For example, we formalized the well-known <a href=\"https://formalizedformallogic.github.io/Foundation/doc/Foundation/FirstOrder/ISigma0/Exponential/Exp.html#LO.ISigma0.Exponential.exponential_succ\">result</a> that the graph of an exponential function is definable by a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"normal\">Œî</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\Delta_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\">Œî</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>-formula and its inductive property is provable in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"sans-serif\">I</mi><msub><mi mathvariant=\"normal\">Œî</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\mathsf I\\Delta_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord mathsf\">I</span><span class=\"mord\"><span class=\"mord\">Œî</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> , showing that this holds for every quantified model <code>V</code> of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"sans-serif\">I</mi><msub><mi mathvariant=\"normal\">Œî</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\mathsf I\\Delta_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord mathsf\">I</span><span class=\"mord\"><span class=\"mord\">Œî</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> (<code>[ORingStruc V]</code> indicates that <code>V</code> has a interpretation of language of arithmetic, and <code>[V ‚äß‚Çò* ùóúùö∫‚ÇÄ]</code> indicates that <code>V</code> is a model of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"sans-serif\">I</mi><msub><mi mathvariant=\"normal\">Œî</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\mathsf I\\Delta_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord mathsf\">I</span><span class=\"mord\"><span class=\"mord\">Œî</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>). We do not use the completeness theorem in this proof itself; rather, we use it to obtain the existence of a formalized proof (LK, Hilbert-style, Tait-style, ... etc) from this fact.</p>",
        "id": 541012518,
        "sender_full_name": "Palalansouk√Æ",
        "timestamp": 1758633546
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"414485\">Palalansouk√Æ</span> <a href=\"#narrow/channel/113488-general/topic/List.20of.20Formalizing.20Mathematical.20Logic.20in.20Lean/near/541012518\">said</a>:</p>\n<blockquote>\n<p>Hi <span class=\"user-mention silent\" data-user-id=\"892220\">Pawe≈Ç Balawender</span> . I was impressed by how you are formalizing difficult results.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"892220\">Pawe≈Ç Balawender</span> <a href=\"#narrow/channel/113488-general/topic/List.20of.20Formalizing.20Mathematical.20Logic.20in.20Lean/near/540945198\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"543250\">SnO2WMaN</span> are you interested in the style of formalization of a weaker logic that doesn‚Äôt use completeness theorem, but rather quantifies over every model and this way, enables you to transfer arithmetical proofs from paper to computer 1:1? If so, I will be glad to connect our work and, hopefully, get some of it to mathlib. My number 1 goal is to design this library in such a way that people who know logic / arithmetic, but <em>don‚Äôt</em> know Lean, will believe the formalization and, perhaps, will be able to write in it</p>\n</blockquote>\n<p>I might be misunderstanding something, but I think this is the same as our approach.</p>\n<p>For example, we formalized the well-known <a href=\"https://formalizedformallogic.github.io/Foundation/doc/Foundation/FirstOrder/ISigma0/Exponential/Exp.html#LO.ISigma0.Exponential.exponential_succ\">result</a> that the graph of an exponential function is definable by a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"normal\">Œî</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\Delta_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\">Œî</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>-formula and its inductive property is provable in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"sans-serif\">I</mi><msub><mi mathvariant=\"normal\">Œî</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\mathsf I\\Delta_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord mathsf\">I</span><span class=\"mord\"><span class=\"mord\">Œî</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> , showing that this holds for every quantified model <code>V</code> of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"sans-serif\">I</mi><msub><mi mathvariant=\"normal\">Œî</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\mathsf I\\Delta_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord mathsf\">I</span><span class=\"mord\"><span class=\"mord\">Œî</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> (<code>[ORingStruc V]</code> indicates that <code>V</code> has a interpretation of language of arithmetic, and <code>[V ‚äß‚Çò* ùóúùö∫‚ÇÄ]</code> indicates that <code>V</code> is a model of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"sans-serif\">I</mi><msub><mi mathvariant=\"normal\">Œî</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\mathsf I\\Delta_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord mathsf\">I</span><span class=\"mord\"><span class=\"mord\">Œî</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>). We do not use the completeness theorem in this proof itself; rather, we use it to obtain the existence of a formalized proof (LK, Hilbert-style, Tait-style, ... etc) from this fact.</p>\n</blockquote>\n<p>Wow, it sounds like our approaches are the same indeed. I remember our previous <a href=\"https://github.com/orgs/FormalizedFormalLogic/discussions/358\">discussion</a>, from which I got the feeling that you conduct the proofs in the actual Lean model. But now that I read your code again, I see that we are essentially doing the same thing. What tricked me is that you very early prove <code>scoped instance : IsStrictOrderedRing M</code> and then use theorems from <code>Mathlib.Algebra</code>, so the usage of actual Peano axioms is hidden in the later theorems.</p>",
        "id": 541028589,
        "sender_full_name": "Pawe≈Ç Balawender",
        "timestamp": 1758637518
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"892220\">Pawe≈Ç Balawender</span> <a href=\"#narrow/channel/113488-general/topic/List.20of.20Formalizing.20Mathematical.20Logic.20in.20Lean/near/541028589\">said</a>:</p>\n<blockquote>\n<p>What tricked me is that you very early prove <code>scoped instance : IsStrictOrderedRing M</code> and then use theorems from <code>Mathlib.Algebra</code>, so the usage of actual Peano axioms is hidden in the later theorems.</p>\n</blockquote>\n<p>The reason we defined this kind of instances is that models of even very weak arithmetic (here <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"sans-serif\">P</mi><msup><mi mathvariant=\"sans-serif\">A</mi><mo>‚àí</mo></msup></mrow><annotation encoding=\"application/x-tex\">\\mathsf{PA^-}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7713em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">P</span><span class=\"mord\"><span class=\"mord mathsf\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">‚àí</span></span></span></span></span></span></span></span></span></span></span></span>) satisfies convenient algebraic structures. This allows us to use theorems from mathlib concerning algebra, and potentially even automatic proofs, making proofs about these models simpler.</p>",
        "id": 541038872,
        "sender_full_name": "Palalansouk√Æ",
        "timestamp": 1758639964
    },
    {
        "content": "<p>I think that what I'll do is leave my code in the current style (i.e. proving properties from scratch in IDelta0), as it better serves the purpose of formalizing Logical Foundations in a didactic way. Somewhat similarly to Terrence Tao's formalization of his 'Analysis' textbook - proofs could be written in a simpler way, but he decided to keep them as-is to be closer to what's in the book. </p>\n<p>However, for formalization of the field, your approach of utilizing <code>Mathlib.Algebra</code> is more scalable and I'll be glad to help pushing a part of FFL (e.g. <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi><msub><mi mathvariant=\"normal\">Œî</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">I\\Delta_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord\"><span class=\"mord\">Œî</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> up to inductive property of exp) into mathlib!</p>",
        "id": 541045769,
        "sender_full_name": "Pawe≈Ç Balawender",
        "timestamp": 1758641687
    }
]