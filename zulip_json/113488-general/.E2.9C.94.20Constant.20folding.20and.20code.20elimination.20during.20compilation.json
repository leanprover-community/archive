[
    {
        "content": "<p>Under which circumstances will calls to pure functions be inlined and simplified by constant folding, or removed as dead code during compilation? I am interested in both the old and new Lean to C compiler, and also in what the C compiler may do to the generated C code.</p>\n<p>For example, suppose I want to measure how long it takes to append two longish lists by compiling the following program and using an external timer to time the executable:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">demo1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">replicate</span><span class=\"w\"> </span><span class=\"mi\">500</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">replicate</span><span class=\"w\"> </span><span class=\"mi\">500</span><span class=\"w\"> </span><span class=\"n\">false</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">main</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">demo1</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">unit</span>\n<span class=\"w\">  </span><span class=\"n\">return</span>\n</code></pre></div>\n<p>My understanding is that the compiler might eliminate the call to demo1 for two reasons:</p>\n<ul>\n<li>the return value is discarded immediately and not used anywhere, so the call is removed by dead code elimination</li>\n<li>the return value depends on inputs which are known at compile-time, so the compiler could inline the definition of <code>demo1</code> in <code>main</code> and perform simplifications to replace <code>demo1 .unit</code> with the precomputed return value.</li>\n</ul>\n<p>Does the compiler actually perform these optimizations? Is there a way to ask it not to? Would putting <code>demo1</code> and <code>main</code> in separate modules change any of this? My goal is to be able to write pure functions in Lean and measure their execution time, so while I'm fine with any optimizations performed to make the body of <code>demo1</code> run faster, I want to be sure that the resulting computation is actually performed at runtime.</p>\n<p>I am pretty sure that the first optimization could be avoided by converting the result into an <code>UInt32</code> somehow and using it as the exit code from the executable, while the second could be prevented by changing <code>demo1</code> to take e.g. the length of the lists to concatenate as an argument read from the command-line parameters to the executable; is that right? I would prefer to keep a standalone executable, without any inputs or outputs, though.</p>",
        "id": 520033116,
        "sender_full_name": "Simon Dima",
        "timestamp": 1748000473
    },
    {
        "content": "<p>First one yes definitely, second one, actually no, it uses constant <em>extraction</em> which is to say it treats the value as its own function which is run at initialization time.</p>",
        "id": 520085655,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1748016241
    },
    {
        "content": "<p>For 2. you can avoid it using <code>@[never_extract]</code></p>",
        "id": 520085741,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1748016263
    },
    {
        "content": "<p>For 1. you can avoid it by putting it into the control flow somehow</p>",
        "id": 520085807,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1748016282
    },
    {
        "content": "<p>Something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">noinline</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">never_extract</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">discardValue</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">()</span>\n</code></pre></div>",
        "id": 520085945,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1748016320
    },
    {
        "content": "<p>In a real program you dead code elimination shouldn't be a problem though? (since pure functions shouldn't have side effects and if they do, just use <code>IO</code>)</p>",
        "id": 520086228,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1748016411
    },
    {
        "content": "<p>Thanks, that looks quite helpful!</p>\n<blockquote>\n<p>In a real program you dead code elimination shouldn't be a problem though?<br>\nOf course, for normal programs having the compiler eliminate dead code and extract closed terms is definitely a feature! Here I'm in the somewhat unusual situation of wanting to measure the execution time of pure functions, which is in a sense a side-effect, but one which the compiler doesn't preserve or reason about.</p>\n</blockquote>\n<p>The <code>noinline</code> and <code>never_extract</code> attributes look like they should make the (old) Lean compiler do what I intend (is the latter equivalent to <code>set_option compiler.extract_closed false</code> for a single definition?). Will that information also be passed to the C compiler used at the end?</p>\n<p><span class=\"user-mention\" data-user-id=\"656225\">@Cameron Zwarich</span>, from grepping around in the Lean repo, it seems like the new compiler honors <code>noinline</code>, but I haven't seen any mention of <code>never_extract</code>, or constant extraction in general for that matter, so I assume the <code>never_extract</code> attribute won't change anything. Is that right?</p>",
        "id": 520425501,
        "sender_full_name": "Simon Dima",
        "timestamp": 1748258880
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"893179\">Simon Dima</span> <a href=\"#narrow/channel/113488-general/topic/Constant.20folding.20and.20code.20elimination.20during.20compilation/near/520425501\">schrieb</a>:</p>\n<blockquote>\n<p>is the latter equivalent to <code>set_option compiler.extract_closed false</code> for a single definition?</p>\n</blockquote>\n<p>The other way round: <code>set_option compiler.extract_closed false</code> prevents closed term extraction for everything that the functions it applies to uses, and <code>@[never_extract]</code> prevents closed term extraction for any usage of functions it applies to, even if they aren't compiled with <code>set_option compiler.extract_closed false</code></p>",
        "id": 520435420,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1748261510
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"893179\">Simon Dima</span> <a href=\"#narrow/channel/113488-general/topic/Constant.20folding.20and.20code.20elimination.20during.20compilation/near/520425501\">schrieb</a>:</p>\n<blockquote>\n<p>but I haven't seen any mention of <code>never_extract</code></p>\n</blockquote>\n<p>In fact, closed term extraction got recently added to the new compiler (<a href=\"https://github.com/leanprover/lean4/pull/8458\">lean4#8458</a>) and it does respect <code>@[never_extract]</code> <a href=\"https://github.com/leanprover/lean4/blob/7b80cd24a924dd1aef9d546e501daee6a777a044/src/Lean/Compiler/LCNF/ExtractClosed.lean#L71\">here</a></p>",
        "id": 520436008,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1748261681
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"873547\">Robin Arnez</span> <a href=\"#narrow/channel/113488-general/topic/Constant.20folding.20and.20code.20elimination.20during.20compilation/near/520436008\">said</a>:</p>\n<blockquote>\n<p>In fact, closed term extraction got recently added to the new compiler (<a href=\"https://github.com/leanprover/lean4/pull/8458\">lean4#8458</a>) and it does respect <code>@[never_extract]</code> <a href=\"https://github.com/leanprover/lean4/blob/7b80cd24a924dd1aef9d546e501daee6a777a044/src/Lean/Compiler/LCNF/ExtractClosed.lean#L71\">here</a></p>\n</blockquote>\n<p>Ah, thanks! I was looking at a slightly older local copy.</p>",
        "id": 520436657,
        "sender_full_name": "Simon Dima",
        "timestamp": 1748261837
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"893179\">Simon Dima</span> has marked this topic as resolved.</p>",
        "id": 520436687,
        "sender_full_name": "Notification Bot",
        "timestamp": 1748261848
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"893179\">Simon Dima</span> has marked this topic as unresolved.</p>",
        "id": 520664062,
        "sender_full_name": "Notification Bot",
        "timestamp": 1748351142
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"873547\">Robin Arnez</span> <a href=\"#narrow/channel/113488-general/topic/.E2.9C.94.20Constant.20folding.20and.20code.20elimination.20during.20compilation/near/520436008\">said</a>:</p>\n<blockquote>\n<p>In fact, closed term extraction got recently added to the new compiler (<a href=\"https://github.com/leanprover/lean4/pull/8458\">lean4#8458</a>) and it does respect <code>@[never_extract]</code> <a href=\"https://github.com/leanprover/lean4/blob/7b80cd24a924dd1aef9d546e501daee6a777a044/src/Lean/Compiler/LCNF/ExtractClosed.lean#L71\">here</a></p>\n</blockquote>\n<p><code>@[never_extract]</code> is respected, but is the option <code>compiler.extract_closed</code> as well? Looking through the code it seems to me like it's not</p>",
        "id": 520664427,
        "sender_full_name": "Simon Dima",
        "timestamp": 1748351236
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"893179\">Simon Dima</span> <a href=\"#narrow/channel/113488-general/topic/Constant.20folding.20and.20code.20elimination.20during.20compilation/near/520664427\">said</a>:</p>\n<blockquote>\n<p><code>@[never_extract]</code> is respected, but is the option <code>compiler.extract_closed</code> as well? Looking through the code it seems to me like it's not</p>\n</blockquote>\n<p>No, it's not. All of the old compiler options are named <code>compiler.pass_name</code>, whereas the new compiler got the updated Lean 4 naming scheme of <code>Compiler.passName</code>. I didn't add a <code>Compiler.extractClosed</code> option, but if it would be useful I could. I guess there are still a few bugs in the approach that are not fixed just by porting the code to Lean.</p>",
        "id": 520686253,
        "sender_full_name": "Cameron Zwarich",
        "timestamp": 1748357074
    },
    {
        "content": "<p>I have an example of code which performs differently when run with the new and old compiler (specifically, I'm comparing the state of the new_codegen branch on May 25th (commit 4dd770fc0a, which seems to be an orphan now) and Lean 4.19.0).<br>\nI have the definition</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">list_sum</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">replicate</span><span class=\"w\"> </span><span class=\"mi\">100</span><span class=\"bp\">_</span><span class=\"mi\">000</span><span class=\"bp\">_</span><span class=\"mi\">000</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">foldl</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n</code></pre></div>\n<p>in a module <code>FromLeanCommon.lean</code>, and the runner</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">FromLeanCommon</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">noinline</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">never_extract</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">list_sum</span><span class=\"w\"> </span><span class=\"n\">u</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">noinline</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">discardValue</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">()</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">main</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">discardValue</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">()</span>\n</code></pre></div>\n<p>compiled with lake.<br>\nUsing the old compiler, the executable runs in about eight seconds, but with the new compiler, it's instantaneous (about 5ms, indistinguishable from an empty Lean program).<br>\n<code>trace.compiler.result</code> suggests that <code>ReduceArity</code> is eliminating the argument from <code>discardValue</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">new</span><span class=\"w\"> </span><span class=\"n\">compiler</span><span class=\"w\"> </span><span class=\"n\">phase</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">base</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">pass</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">toMono</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">toMono</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">3</span>\n<span class=\"w\">      </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">main</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">EStateM</span><span class=\"bp\">.</span><span class=\"n\">Result</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">Error</span><span class=\"w\"> </span><span class=\"n\">PUnit</span><span class=\"w\"> </span><span class=\"n\">PUnit</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">        </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">PUnit</span><span class=\"bp\">.</span><span class=\"n\">unit</span><span class=\"bp\">;</span>\n<span class=\"w\">        </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"m\">3</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"bp\">;</span>\n<span class=\"w\">        </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"m\">4</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">discardValue</span><span class=\"w\"> </span><span class=\"bp\">◾</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"m\">3</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"bp\">;</span>\n<span class=\"w\">        </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"m\">4</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">new</span><span class=\"w\"> </span><span class=\"n\">compiler</span><span class=\"w\"> </span><span class=\"n\">phase</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">mono</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">pass</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">      </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">main</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">EStateM</span><span class=\"bp\">.</span><span class=\"n\">Result</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">Error</span><span class=\"w\"> </span><span class=\"n\">PUnit</span><span class=\"w\"> </span><span class=\"n\">PUnit</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">        </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">discardValue</span><span class=\"bp\">._</span><span class=\"n\">redArg</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"bp\">;</span>\n<span class=\"w\">        </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"m\">2</span>\n</code></pre></div>\n<p>Is there currently a right way to force the new compiler to evaluate pure code at runtime?</p>",
        "id": 520686902,
        "sender_full_name": "Simon Dima",
        "timestamp": 1748357228
    },
    {
        "content": "<p>For future reference, I was able to get the intended behavior from both the old and new compiler by imitating what OCaml does with <a href=\"https://ocaml.org/manual/5.3/api/Sys.html#VALopaque_identity\"><code>Sys.opaque_identity</code></a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">FromLeanCommon</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">noinline</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">never_extract</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">list_sum</span><span class=\"w\"> </span><span class=\"n\">u</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">noinline</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">opaquePure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">main</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">&lt;-</span><span class=\"w\"> </span><span class=\"n\">opaquePure</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">()</span>\n<span class=\"w\">  </span><span class=\"n\">return</span>\n</code></pre></div>\n<p>I'm still not sure if this is subject to change if the compiler is updated, though.</p>",
        "id": 520867338,
        "sender_full_name": "Simon Dima",
        "timestamp": 1748431702
    },
    {
        "content": "<p>I think this is along the lines of what I would suggest today. We are going to be revisiting the implementation of <code>IO</code> (and its integration with the compiler) in the medium future, so we'll probably need to provide a better primitive that is guaranteed to work.</p>",
        "id": 520925622,
        "sender_full_name": "Cameron Zwarich",
        "timestamp": 1748447614
    },
    {
        "content": "<p>Thanks! Do you know whether noinline and never_extract will also be passed along to the C compiler in some form? I'm worried that gcc might be sufficiently smart to see dead code in the output from the Lean compiler</p>",
        "id": 520925916,
        "sender_full_name": "Simon Dima",
        "timestamp": 1748447691
    },
    {
        "content": "<p>It would be pretty easy to pass along <code>noinline</code> (which IIRC is even now standard C in C23).It doesn't look like there is a good equivalent of<code>never_extract</code>. The right way to do this would be to have IR decls carry inlining attributes like LCNF decls, so that this also applies to any new decls made by the optimizer. I'd rather wait until we switch to the new compiler to do this.</p>",
        "id": 520928174,
        "sender_full_name": "Cameron Zwarich",
        "timestamp": 1748448365
    },
    {
        "content": "<p>What's the right place to flag \"control over the run-time execution of a pure function\" as a desired feature, GitHub issues?</p>",
        "id": 520930576,
        "sender_full_name": "Simon Dima",
        "timestamp": 1748449167
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"893179\">Simon Dima</span> has marked this topic as resolved.</p>",
        "id": 521746366,
        "sender_full_name": "Notification Bot",
        "timestamp": 1748870724
    }
]