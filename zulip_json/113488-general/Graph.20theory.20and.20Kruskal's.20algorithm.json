[
    {
        "content": "<p>I wanted to convert a Finset of edges to a List <br>\nHow can I do that <br>\nThis is a part of implementation of the Kruskal's Algorithm in Lean</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- A weight function on the edges of a simple graph assigns a natural number</span>\n<span class=\"sd\">    to each edge `(u, v)` with a proof that they are adjacent. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">EdgeWeight</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Adj</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n\n<span class=\"sd\">/-- A weight function on the edges of a simple graph assigns a natural number</span>\n<span class=\"sd\">    to each edge `e` with a proof that `e` is in the edge set. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">EdgeWeight'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Sym2</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">edgeSet</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n</code></pre></div>\n<p>Above is how I defined a weight function on a graph.<br>\nBasically I can a computable function which takes either Vertex set or edgeset as an input and returns a List (in sym2 V) as an output.</p>",
        "id": 515684934,
        "sender_full_name": "Ayush Priyadarshi",
        "timestamp": 1746182222
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.toList#doc\">docs#Finset.toList</a>. This uses the axiom of choice though, but this is probably not possible without it. If your type is linearly ordered, you can always take the smallest/largest out of it.</p>",
        "id": 515685902,
        "sender_full_name": "Johannes Tantow",
        "timestamp": 1746182638
    },
    {
        "content": "<p>Do you want to use Kruskal in practice or only prove something about that</p>",
        "id": 515686146,
        "sender_full_name": "Johannes Tantow",
        "timestamp": 1746182718
    },
    {
        "content": "<p>(Note <code>Finset</code> is defined in Mathlib, so this is the wrong channel for this question.)</p>",
        "id": 515688875,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1746183835
    },
    {
        "content": "<p>I am implementing the Kruskal's algorithm algorithmically.<br>\nIn one of the parts as I am computing a MST(minimum spanning tree) for a graph.<br>\nbut for obtaining the minimum weight of an edge , I will either use a sort function or a Min function both of which I have created.<br>\nBut for that I need to define a linear order on this set.<br>\nHow do I do that?<br>\nAbout this question<br>\nDo you want to use Kruskal in practice or only prove something about that<br>\nI am implementing it in practice and proving it's optimality.</p>",
        "id": 515690014,
        "sender_full_name": "Ayush Priyadarshi",
        "timestamp": 1746184264
    },
    {
        "content": "<p>This topic was moved here from <a class=\"stream-topic\" data-stream-id=\"348111\" href=\"/#narrow/channel/348111-batteries/topic/Graph.20theory.20and.20Kruskal.27s.20algorithm\">#batteries &gt; Graph theory and Kruskal's algorithm</a> by <span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span>.</p>",
        "id": 515691131,
        "sender_full_name": "Notification Bot",
        "timestamp": 1746184681
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"728542\">@Ayush Priyadarshi</span>, note I have moved this thread, as it did not belong in the batteries channel.</p>",
        "id": 515691231,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1746184703
    },
    {
        "content": "<p>I want to convert G.edgeset to a List <br>\nAnd then use this function below to give me an edge of minimum weight.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">minBy?</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">minBy?</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">        </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">      </span><span class=\"k\">else</span>\n<span class=\"w\">        </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">y</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">myWeightFn</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"s2\">\"alpha\"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"s2\">\"beta\"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"s2\">\"gamma\"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">3</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"s2\">\"delta\"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">100</span><span class=\"w\">  </span><span class=\"c1\">-- fallback for unmatched strings</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">minBy?</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"s2\">\"alpha\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"beta\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"gamma\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"delta\"</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">myWeightFn</span><span class=\"w\"> </span><span class=\"c1\">-- some \"delta\"</span>\n</code></pre></div>",
        "id": 515691673,
        "sender_full_name": "Ayush Priyadarshi",
        "timestamp": 1746184865
    },
    {
        "content": "<p>I wouldn't store the graph as a finset then. In practice the graph will be ordered as the input in some way anyway. You could use a list.</p>",
        "id": 515693005,
        "sender_full_name": "Johannes Tantow",
        "timestamp": 1746185385
    },
    {
        "content": "<p>Or alternatively I used hashmaps to represent a graph (as an adjacency list)</p>",
        "id": 515693226,
        "sender_full_name": "Johannes Tantow",
        "timestamp": 1746185452
    },
    {
        "content": "<p>But i still want to use functions defined in SimpleGraph Module in mathlib like isAcyclic<br>\nwhich are defined for sets as G.edgeset only and not a list<br>\nI need a way to switch back and forth between computation and existentiality in vague terms.</p>",
        "id": 515693455,
        "sender_full_name": "Ayush Priyadarshi",
        "timestamp": 1746185544
    },
    {
        "content": "<p>You can have an effective graph model you work with and a translation to the mathlib model to prove stuff</p>",
        "id": 515693563,
        "sender_full_name": "Johannes Tantow",
        "timestamp": 1746185595
    },
    {
        "content": "<p>Wouldn't i need both in the same model if i wanted to compute and prove optimality both.</p>",
        "id": 515694057,
        "sender_full_name": "Ayush Priyadarshi",
        "timestamp": 1746185804
    },
    {
        "content": "<p>I don't see why. You define an internal graph representation(IGR) and a map transform: IGR -&gt; mathlib graph. (Using AC this also works backwards). Then you show that for any input transform(kruskal(G)) is the minimal spanning tree for transform(G)</p>",
        "id": 515695228,
        "sender_full_name": "Johannes Tantow",
        "timestamp": 1746186308
    },
    {
        "content": "<p>There's <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.sort#doc\">docs#Finset.sort</a> , right?</p>",
        "id": 515697299,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1746187065
    },
    {
        "content": "<p>But then you need basically a linear order again on the type</p>",
        "id": 515698692,
        "sender_full_name": "Johannes Tantow",
        "timestamp": 1746187557
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"728542\">@Ayush Priyadarshi</span> <br>\nGiven a linear order on the type, here is code to make the list if needed. In practice you can make vertices subsets of something like <code>Nat</code> which is ordered.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearOrder</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">toOrderedList</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">:</span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">min'</span><span class=\"w\"> </span><span class=\"n\">p</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">erase</span><span class=\"w\"> </span><span class=\"n\">head</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">tail</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">card_erase_lt_of_mem</span>\n<span class=\"w\">      </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">min'_mem</span>\n<span class=\"w\">    </span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">toOrderedList</span><span class=\"w\"> </span><span class=\"n\">tail</span>\n<span class=\"w\">  </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"n\">termination_by</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">card</span>\n</code></pre></div>",
        "id": 515835930,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1746241622
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.sort#doc\">docs#Finset.sort</a> would be the usual way of doing that</p>",
        "id": 515840957,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1746244837
    }
]