[
    {
        "content": "<p>A rule which makes things much more readable, and in my opinion we should advocate for proofs longer than 10 lines, say, is the following: It is forbidden to act on the main goal. So, no <code>apply</code>, no <code>rw</code> and so on. Instead, a sequence of <code>have</code> or <code>suffices</code> whose proofs may use the tactics you like -- unless the proof of such a subgoal is more than 10 lines, in which case the above rule should apply.</p>\n<p>I know that I am in the minority here, and that most people prefer shorter but harder to read proofs. But I am still convinced it would be a very very good move!</p>",
        "id": 291439887,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1659200495
    },
    {
        "content": "<p>Wow, this is radical but makes a lot of sense to me!</p>",
        "id": 291440170,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1659200845
    },
    {
        "content": "<p>I agree with this, but I would put an asterisk for computational proofs, where rewriting is soooo efficient</p>",
        "id": 291440239,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1659200919
    },
    {
        "content": "<p><code>calc</code> blocks would be allowed for computational proofs, of course. You can do it a 3 steps <code>calc</code> block, and use a lot of rewriting between two successive steps. And of course this has to be taken with a grain of salt.</p>",
        "id": 291440453,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1659201203
    },
    {
        "content": "<p>Isn't forwards reasoning vs backwards reasoning one of those \"holy wars\" in proof assistants, like emacs vs vim?</p>\n<p>That said, I like replacing golfed backwards proofs with <code>calc</code> blocks when possible.</p>",
        "id": 291440855,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1659201614
    },
    {
        "content": "<p><code>suffices</code> is still backward reasoning right? I think the main point is to write down intermediate statements? But you can also copy and paste the goal after an <code>apply</code>, for example.</p>",
        "id": 291441209,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1659202073
    },
    {
        "content": "<p>I think the advantage/problem with backwards reasoning is that we have to put way less indications. When doing forward reasoning, you are essentially forced to announce what you do, whereas you can do a full backwards proof without any structure. But that doesn’t mean that backward style is less readable, we just have to force ourselves to use suffices because Lean won’t ask for it</p>",
        "id": 291441272,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1659202123
    },
    {
        "content": "<p>By the way, why is <code>suffices</code> singular but all other (verb) tactics plural ... (any counterexamples?)<br>\nUpdate: I think the answer is that we say \"it suffices\" but \"we have\", \"we apply\".</p>",
        "id": 291441401,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1659202304
    },
    {
        "content": "<p>Yes, backward reasoning is still possible, but using <code>suffices</code>. Just like one would to in a paper proof!</p>",
        "id": 291441475,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1659202383
    },
    {
        "content": "<p>I have to say that backwards reasoning is really what of the thing that Lean stuck in my head when doing maths in general, so I will never be able to evaluate how natural it is for mathematicians</p>",
        "id": 291441486,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1659202405
    },
    {
        "content": "<p>I’d suggest that the important distinction notion isn’t (always) “forward” vs “backward”, but simpler vs more complicated. Often it’s useful to act on the goal to simplify it, whereas building up lots of material with <code>have</code> can be complicated and confusing when the reader can’t see where we’re heading.</p>",
        "id": 291441591,
        "sender_full_name": "Stuart Presnell",
        "timestamp": 1659202528
    },
    {
        "content": "<p>For example, when we’re proving an equation of the form <code>a + … x … + g = h + … x … + k</code>, the simpler approach is to bring out the common term <code>x</code> and cancel it.</p>",
        "id": 291442251,
        "sender_full_name": "Stuart Presnell",
        "timestamp": 1659203203
    },
    {
        "content": "<p>I find that length doesn't conflate with unreadability; I find most backwards reasoing proofs very legible now, and mostly I have no problem reading and understanding them, but one that really confuses me a lot is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/disjoint.disjoint_sup_left_of_disjoint_sup_right\">docs#disjoint.disjoint_sup_left_of_disjoint_sup_right</a>, which wouldn't meet your \"10 lines\" rule and therefore would be okay.</p>",
        "id": 291443475,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1659204760
    },
    {
        "content": "<p>Also, <code>by ring</code> is more readable than any manual calculation I might do on paper</p>",
        "id": 291444180,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1659205768
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/Improving.20the.20mathlib.20style.20guide/near/291424178\">said</a>:</p>\n<blockquote>\n<p>In an alternate universe I guess we could use lemma vs theorem to distinguish crucial vs minor</p>\n</blockquote>\n<p>This is something else I wanted to bring up but thought it would be too nitpicky for anyone to care</p>",
        "id": 291447763,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1659210648
    },
    {
        "content": "<p>Regarding the comments thing: I absolutely don't oppose good doc comments and module comments. I agree with Mario that ideally, all proofs should be locally trivial, and hence these comments should be enough to get the hang of a file. And in the few cases where that isn't possible, we should have good comments within the proof to make it easier to follow.</p>\n<p>I fear that we'll end up with trivial comments that just clutter up the code while not making it any clearer, but I also agree that at the current moment, this is a total non-issue.</p>",
        "id": 291448210,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1659211116
    },
    {
        "content": "<p>From the standpoint of an inept mathematician like me, something I struggle a lot when reading mathematical sources is that things are built in a bottom-up fashion whereas my reasoning happens in top-down. I find out the smaller lemmas I need to prove in the process of proving my bigger lemmas. And when I read mathematical sources I see a big pile of theorems that I have no idea what they're for and I end up lost pretty quickly.</p>\n<p>The type of documentation I usually miss is one that would say \"this result is used in &lt;bla&gt; because &lt;ble&gt;\". This way I would be able to put the pieces together <em>as</em> I go through the lemmas instead of having to stack things in my dynamic memory without a major structure. And stacking things in my memory is hard because I am a bad computer.</p>\n<p>Of course lemmas, once stated (and proved, preferably), become objects with generic purposes. But still, I can't help but say that knowing <em>why</em> things are there would help me (and maybe others?) a lot</p>",
        "id": 291448883,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1659212120
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"451983\">@Arthur Paulino</span> One trick that I use when reading math proofs, especially when I have an eye toward formalizing them, is to skim them in forward order so I don't get totally lost, but look for the result I'm interested in. Once I find the interesting theorem (e.g. the main theorem), I read that part carefully and then read the dependencies of that theorem, and then those dependencies and so on in reverse order. That way, I'm always reading a theorem with the knowledge of why it would be used (which also sometimes provides additional structure or even hypotheses you can put on the dependencies, e.g. this theorem is only ever applied when <code>a</code> is prime even though it only says <code>a</code> is odd in the theorem statement.</p>",
        "id": 291454057,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659219769
    },
    {
        "content": "<p>You can do exactly the same thing when reading a formal proof. Start at the end, and the first time you see a theorem being referenced that isn't obviously true, jump to that and read it instead, and keep doing that until you hit obvious things. That way you never have to read trivialities and you go straight to the interesting part</p>",
        "id": 291454122,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659219855
    },
    {
        "content": "<p>Forward ordering is a necessity dictacted by wanting a dag structure on proofs but it is a lot less clear IMO if the author just keeps on introducing things without it being clear why we should care about them. But even if the author pays a lot of attention to this aspect the explanation is only useful for people in the author's general headspace already. So it's up to the reader to provide their own motivation via the DFS method.</p>\n<p>When formalizing I often read papers that are mathematically out of my league and what usually happens is that everything feels unmotivated and the explanation of the motivation is completely useless to me because it connects to other things I have never heard of. So I just skip all that and read only the stuff that is relevant to the proof.</p>",
        "id": 291454521,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659220504
    },
    {
        "content": "<p>As a novice in proof assistants trying to learn different parts of mathlib, I found that many of my frustrations would be much relieved if there were more verbose documentation. For example, certain lemmas could have been tagged with \"useful for constructing/proving this other thing\" or \"useful in combination with this other lemma\" to save me the trouble of searching in what are sometimes overwhelmingly long documents.</p>\n<p>There should also be more justification for the long strings of typeclasses, e.g. why <code>[comm_ring R]</code> is needed instead of just <code>[semiring R]</code>. These stronger typeclasses are sometimes introduced because a single step of the construction/proof requires it, but this wouldn't be obvious to anyone stumbling on this theorem later, who is wondering if a generalisation could be made.</p>\n<p>If mathlib is going to become a useful tool in a mathematician's (or undergraduate's) toolbox, there needs to be examples of how an API is used, as a sort of tutorial. Conveniently, other theorems in mathlib that build upon an API are precisely such examples, but they would be less useful if not accompanied by suitable wordy explanations.</p>",
        "id": 291458967,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1659227266
    },
    {
        "content": "<blockquote>\n<p>There should also be more justification for the long strings of typeclasses, e.g. why [comm_ring R] is needed instead of just [semiring R]. These stronger typeclasses are sometimes introduced because a single step of the construction/proof requires it, but this wouldn't be obvious to anyone stumbling on this theorem later, who is wondering if a generalisation could be made.</p>\n</blockquote>\n<p>Note that making the typeclasses more \"optimal\" often makes them even less understandable</p>",
        "id": 291459377,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659227973
    },
    {
        "content": "<blockquote>\n<p>\"useful for constructing/proving this other thing\" or \"useful in combination with this other lemma\" </p>\n</blockquote>\n<p>Maybe this can be done in some cases, but it's really hard to have a lemma point to some specific other application since it may be used in many different applications (and this is the common case, not the exception)</p>",
        "id": 291459463,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659228064
    },
    {
        "content": "<p>Besides the general topical similarity you get from lemmas existing in the same file I don't really see how to make those cross links work except in the really obvious case where a lemma is only extracted from a proof to break it up and it is only intended to have one use</p>",
        "id": 291459515,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659228130
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> should we break this into a new thread?</p>\n<p>Does it make sense to think of a button in the page generated by doc-gen that can show usages?</p>\n<p>It's not as simple as a syntactical search because of simp lemmas, so maybe it would require a post-processing step to gather such information</p>",
        "id": 291460564,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1659229704
    },
    {
        "content": "<p>Something we eventually should have are Mathematica-style Guide pages (here's a random example: <a href=\"https://reference.wolfram.com/language/guide/Associations.html\">https://reference.wolfram.com/language/guide/Associations.html</a>). The idea of these is to give you a cross-cutting overview of different useful functionality for how to interact with things in some general area. I don't think they're meant to be exhaustive, but rather meant to give you enough to find a way into the rest of the library.</p>",
        "id": 291463640,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1659234598
    },
    {
        "content": "<p>They also have tutorials that are worked-out examples for how to do something, and of course documentation for individual functions.</p>",
        "id": 291463732,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1659234683
    },
    {
        "content": "<p>We so far have two guide pages that come to mind: <a href=\"https://leanprover-community.github.io/mathlib-overview.html\">https://leanprover-community.github.io/mathlib-overview.html</a> and <a href=\"https://leanprover-community.github.io/undergrad.html\">https://leanprover-community.github.io/undergrad.html</a></p>",
        "id": 291463783,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1659234733
    },
    {
        "content": "<p>The module docs for <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset\">docs#finset</a> also serve as a guide page</p>",
        "id": 291463821,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1659234820
    },
    {
        "content": "<p>But one thing to keep in mind is that the source files for mathlib don't themselves have to be the documentation -- Mathematica's rich documentation is all completely separate from the source code. One one hand, that makes it harder to remember to keep it up to date, but on the other it allows the documentation to have structure that's best for documenting (instead of needing to find compromises based on how the source is structured).</p>",
        "id": 291463937,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1659234961
    },
    {
        "content": "<p>On the same spirit (dedicated documentation): <a href=\"https://scikit-learn.org/stable/user_guide.html\">https://scikit-learn.org/stable/user_guide.html</a></p>",
        "id": 291464075,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1659235134
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113488-general/topic/Making.20mathlib.20more.20readable.20.28was.3A.20Improving.20the.20mathlib.20.2E.2E.2E/near/291463640\">said</a>:</p>\n<blockquote>\n<p>Something we eventually should have are Mathematica-style Guide pages (here's a random example: <a href=\"https://reference.wolfram.com/language/guide/Associations.html\">https://reference.wolfram.com/language/guide/Associations.html</a>). The idea of these is to give you a cross-cutting overview of different useful functionality for how to interact with things in some general area. I don't think they're meant to be exhaustive, but rather meant to give you enough to find a way into the rest of the library.</p>\n</blockquote>\n<p>Did you have a look at chapters 7 to 9 in <a href=\"https://leanprover-community.github.io/mathematics_in_lean/\">Mathematics in Lean</a>?</p>",
        "id": 291479156,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1659257723
    },
    {
        "content": "<p>Yes <span class=\"user-mention\" data-user-id=\"416472\">@Winston Yin</span> I'm not sure reading mathlib is the way to learn how to formalise mathematics in lean, we are trying to generate other documentation for this (like the link Patrick suggested)</p>",
        "id": 291479418,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1659258121
    },
    {
        "content": "<p>I would like it very much if there were some nice ways of “litterate programming in Lean”. With the same text that furnishes the Lean code and a human readable text that can be used to study the math. (This, <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> ,  would be the actual Bourbaki 2.0.)</p>",
        "id": 291483990,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1659264649
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"451983\">Arthur Paulino</span> <a href=\"#narrow/stream/113488-general/topic/Making.20mathlib.20more.20readable.20.28was.3A.20Improving.20the.20mathlib.20.2E.2E.2E/near/291460564\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> should we break this into a new thread?</p>\n<p>Does it make sense to think of a button in the page generated by doc-gen that can show usages?</p>\n<p>It's not as simple as a syntactical search because of simp lemmas, so maybe it would require a post-processing step to gather such information</p>\n</blockquote>\n<p>Are you asking for a used by list (and or a \"uses\" list) on theorems? That can very well be done in doc-gen4 by just processing the Exprs of all theorems and seeing what names pop up there is no need for special casing with <code>simp</code>.</p>",
        "id": 291484872,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1659265885
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130609\">Antoine Chambert-Loir</span> <a href=\"#narrow/stream/113488-general/topic/Making.20mathlib.20more.20readable.20.28was.3A.20Improving.20the.20mathlib.20.2E.2E.2E/near/291483990\">said</a>:</p>\n<blockquote>\n<p>I would like it very much if there were some nice ways of “litterate programming in Lean”. With the same text that furnishes the Lean code and a human readable text that can be used to study the math. (This, <span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> ,  would be the actual Bourbaki 2.0.)</p>\n</blockquote>\n<p>You are basically asking for something hte likes of <a href=\"https://alectryon-paper.github.io/\">https://alectryon-paper.github.io/</a> right? I'm already on working getting stuff like this on the way for Lean 4 as well</p>",
        "id": 291484929,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1659265956
    },
    {
        "content": "<p>I still think that making proofs readable should be an automatic post-processing step. Of course capabilities of this post-processing step would still put some constraints on proof scripts.</p>",
        "id": 291484949,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1659266007
    },
    {
        "content": "<p>What does it mean to be readable for a proof? Or to be transformed into a readable one?</p>",
        "id": 291485012,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1659266058
    },
    {
        "content": "<p>Henrik, what Antoine is asking for goes much beyond what Alectryon is currently doing. But indeed the post-processing tool would start like Alectryon.</p>",
        "id": 291485015,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1659266071
    },
    {
        "content": "<p>Did you ever read <a href=\"https://www.imo.universite-paris-saclay.fr/~pmassot/files/exposition/why_formalize.pdf\">https://www.imo.universite-paris-saclay.fr/~pmassot/files/exposition/why_formalize.pdf</a>? Section 2 is the relevant one here.</p>",
        "id": 291485108,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1659266181
    },
    {
        "content": "<p>And of course a very easy readability criterion is that someone would has already written lots of Lean proof should not have any reading advantage at all.</p>",
        "id": 291485136,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1659266254
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113488-general/topic/Making.20mathlib.20more.20readable.20.28was.3A.20Improving.20the.20mathlib.20.2E.2E.2E/near/291484949\">said</a>:</p>\n<blockquote>\n<p>I still think that making proofs readable should be an automatic post-processing step. Of course capabilities of this post-processing step would still put some constraints on proof scripts.</p>\n</blockquote>\n<p>Well, but I think a balance between making proofs readable (i.e. understandable for the interested mathematician) and making them <em>exploitable</em> (I cannot came up with a better term: I mean that someone can learn from them something about formalising, possibly formalising another similar lemma getting inspiration from that proof) would be useful. For instance, if a proof requires <code>a+b=b+a</code>, golfing <code>exact add_comm a b</code> to <code>exact add_comm _ _</code>is precisely the thing I would oppose: it adds nothing, but if one does not know yet how things works, the two underlines are genuinely painful.</p>",
        "id": 291485709,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1659267048
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> I was talking about a \"used by\" list, preferably ranked by relevance (the declarations that are used the most would come up on top)</p>",
        "id": 291485777,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1659267200
    },
    {
        "content": "<p>An \"uses\" list would be ranked in reverse order, I think. So that the most \"exquisite\" declarations would come up on top to avoid always having the same declarations at the top of almost every \"uses\" list. For instance, seeing <code>nat.add_comm</code> at the top doesn't add a lot of info</p>",
        "id": 291486093,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1659267615
    },
    {
        "content": "<p>However, this also sounds like something that could be supported by the IDE somehow. Some languages (I know Scala and Java) do</p>",
        "id": 291486181,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1659267831
    },
    {
        "content": "<p>Should the \"used by\" counter include transitive counts? For example if you have a very basic theorem in a theory you build up bigger and bigger statements from  that are each not used that often you won't really get a clear view of what is relevant without transitive counters right?</p>",
        "id": 291486303,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1659267964
    },
    {
        "content": "<p>And if we can agree on this, how far should it take transitivity into consideration? Fully? Up until module borders? A certain number of steps?</p>",
        "id": 291486486,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1659268229
    },
    {
        "content": "<p>Oh right, I meant to respond to the \"used by\" comment. I think it's a fantastic idea; it's one of the features from the metamath HTML pages that I miss in doc-gen and it is really good for helping to identify places to look when doing refactors, in addition to being one way to explore the mathematical content of a formal development. (It should probably be accompanied by a list of theorems referenced as well, so that you can go both up and down the graph of theorem references. In metamath this is automatic since the proof display is itself a list of theorem applications, but in lean it is not as trivial to reconstruct the list of referenced theorems from the source because of tactics that can pull who knows what into the proof.)</p>",
        "id": 291487194,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659269322
    },
    {
        "content": "<p>Oh since doc-gen4 analyses the Expr's that is not really an issue I can just traverse them and look for mentions of Expr.const that are <code>Prop</code> typed right?</p>",
        "id": 291487209,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1659269380
    },
    {
        "content": "<blockquote>\n<p>the declarations that are used the most would come up on top</p>\n</blockquote>\n<p>That is probably the wrong heuristic. Declarations that are used a lot tend to be uninteresting. Metamath's heuristic uses order in the file: the later a theorem is proved the more \"important\" it is</p>",
        "id": 291487212,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659269393
    },
    {
        "content": "<p>that's slightly nontrivial when the proofs are not linearized, but I think you can do something reasonable with definitional height</p>",
        "id": 291487277,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659269437
    },
    {
        "content": "<p>Regarding transitive references, I'm not sure. My first instinct is \"no, transitive references aren't interesting for this use case\"</p>",
        "id": 291487567,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1659269922
    },
    {
        "content": "<p>I think it also heavily depends on what kind of result this is. Knowing <em>where</em> (or how many times) the proof that <code>a+b=b+a</code> is used in a commutative monoid is of no interest, but knowing which parts of commutative algebra rely on the Chinese remainder theorem might be interesting. Can't we think of a flag like the <code>simp</code> one, but for doc purposes?</p>",
        "id": 291488520,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1659271280
    },
    {
        "content": "<blockquote>\n<p>if a proof requires <code>a+b=b+a</code>, golfing <code>exact add_comm a b</code> to <code>exact add_comm _ _</code>is precisely the thing I would oppose: it adds nothing, but if one does not know yet how things works, the two underlines are genuinely painful.</p>\n</blockquote>\n<p>I am actually arguing the exact opposite. Replacing variable names with underscores makes the proof much more robust to refactorings (because if you rename a variable for X reason you don't have to change the underscore), and not having an underscore is a flag that not everything can be inferred, that there's a choice being made.</p>",
        "id": 291490962,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1659274442
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113488-general/topic/Making.20mathlib.20more.20readable.20.28was.3A.20Improving.20the.20mathlib.20.2E.2E.2E/near/291479156\">said</a>:</p>\n<blockquote>\n<p>Did you have a look at chapters 7 to 9 in <a href=\"https://leanprover-community.github.io/mathematics_in_lean/\">Mathematics in Lean</a>?</p>\n</blockquote>\n<p>This is great, but it's serving a different purpose, more like a tutorial than a Guide page. (It would also be great if something like this were part of the mathlib repository itself, with some linting to make sure definitions/lemmas are kept up to date, and part of the docgen.)</p>\n<p>I've been planning on (eventually) creating some guide pages and figuring out how to incorporate them into our documentation, in my copious free time and all that...</p>",
        "id": 291497976,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1659283561
    },
    {
        "content": "<p>Worth noting. Something I've come across once is that a proof is very extensively documented, but then the API changes, the proof is golfed down, and the old comments all become superfluous.</p>",
        "id": 291503604,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1659290459
    },
    {
        "content": "<p>I imagine trying to make theorems more readable would lead to more of these long proofs necessitating comments, when in reality we should be looking to make things shorter so as to make them immediately clear.</p>",
        "id": 291503785,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1659290645
    },
    {
        "content": "<p>I disagree with top down proofs being harmful to readability. Top down reasoning is the way most people come up with proofs, and in my experience, the way most beginners to proofs try writing them. The only advantage I see to putting every next step into its own <code>have</code> block is that you can see the explicit term being proved, advantage made redundant by the goal view.</p>",
        "id": 291504049,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1659290943
    },
    {
        "content": "<p>But maybe, as has been said before, this is a holy war topic we won't get anything out of discussing.</p>",
        "id": 291504134,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1659291010
    },
    {
        "content": "<p>I think the idea of having some kind of compressed (but re-expandable) representation of proofs should be possible with the correct heuristics. </p>\n<p>The simplest I think that can actually be somewhat informative is keeping only the tactics that depend on local hypotheses; i.e. if I have 12 rewrites, and only the 4th and 7th actually use a local hypothesis, then we only show something like <code>rw [h4, h7]</code>. It isn't valid code anymore, but one can interact with this using the cursor to show the goal state after <code>h4</code>, or after <code>h7</code>, and not see any of the intermediate steps. </p>\n<p>The idea is that the human writing the proof probably rewrote <code>h4</code> as a key step, then did a bunch of <code>rw</code>s to simplify until they could use <code>h7</code>as a key step, etc. If this is a decent measure, then I feel like it would be fairly robust. </p>\n<p>And of course, if the steps between <code>h4</code> and <code>h7</code> are not immediate, then one could expand to show the rewrites in between. How this expansion happens would be chosen heuristically. Maybe through some tagging system that ranks which tactics/lemmas should be erased? <code>@[simp]</code> has been pretty effective so far</p>",
        "id": 291505768,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1659293018
    },
    {
        "content": "<p>Violeta, your opinions about proofs may change when you will encounter more sophisticated proofs.</p>",
        "id": 291511548,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1659300360
    },
    {
        "content": "<p>I think there is, honestly, a tension here between multiple conceptions of what a proof even is, and what \"readability\" of a proof should be. Personally I favour a term-first style (I love using <code>refine</code> and <code>exact</code> and <code>rintros</code> etc. as much possible to really compress down a proof). But obviously such a thing doesn't produce a proof that is very useful for understanding the mathematics or understanding how to use a proof assistant, or even necessarily grant insight into how the proof assistant itself works.</p>\n<p>There are a number of statements above that assume \"readability\" is one thing, and say whether or not it is good. My contention is that it very much isn't: to say a proof is readable without saying for whom and for what is meaningless.</p>\n<p>Far more important to get right, in my view, are statements and definitions. Because of proof irrelevance, it doesn't matter to me how things are proved in Lean, as long as they are (well, with the caveat that one should avoid the use of slow tactics as much as possible - i.e. they should be efficiently verifiable). But it absolutely does matter to me how things are defined and stated. </p>\n<p>As I also mentioned, there are also questions of \"what are proofs for\". Is a proof designed to convince a human of the truth of a statement through mathematical argument? This implies at least one kind of readability. Or perhaps it is simply meant to verify as correct a readable statement - that is another kind. And this is a social question as much as it is a technical one.</p>",
        "id": 291566959,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1659356712
    },
    {
        "content": "<p>(There are also questions of maintainability, which are related to readability but are subtly different. I <em>do</em> think proofs should be maintainable.)</p>",
        "id": 291567084,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1659356765
    },
    {
        "content": "<p>My view on proof irrelevance would be slightly different: since it does not matter for Lean how things are proved, it is better to have proofs that are human-readable (I don't think this statement is meaningless, even though human-readability is not well-defined). I agree that for trivial statements term-proofs are better (it shows that nothing interesting is happening) and if a proof is more readable then it should generally be easier to maintain.</p>",
        "id": 291574818,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1659360338
    },
    {
        "content": "<p>I agree they should be readable for some definition of readable. I don't think this necessarily translate to \"understandable for the interested mathematician\", as <span class=\"user-mention\" data-user-id=\"300245\">@Filippo A. E. Nuccio</span> puts it, for myself at least.</p>",
        "id": 291593864,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1659368983
    }
]