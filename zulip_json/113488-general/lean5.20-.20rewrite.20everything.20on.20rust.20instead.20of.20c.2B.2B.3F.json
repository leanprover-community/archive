[
    {
        "content": "<p>- <strong>User Experience</strong>: will make language core more typesafe?<br>\n  - <strong>Beneficiaries</strong>: core on rust will be easier to understand + generated code will be rust (type safe output) + linear types in lean language?</p>\n<p>or maybe it is possible to write lean on lean without any c++?</p>\n<p>just interesting what people think</p>",
        "id": 495845146,
        "sender_full_name": "Serhii Khoma (srghma)",
        "timestamp": 1737789512
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/JRcgQCHu-UIGlJiQimQ_ICbH/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/JRcgQCHu-UIGlJiQimQ_ICbH/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"296x176\" src=\"/user_uploads/thumbnail/3121/JRcgQCHu-UIGlJiQimQ_ICbH/image.png/840x560.webp\"></a></div>",
        "id": 495846436,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1737790637
    },
    {
        "content": "<p>As you can see, there isn't that much C++ in the repo. But there is a lot of Lean in the repo. Gradually the C++ is being rewritten in Lean.</p>",
        "id": 495846513,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1737790698
    },
    {
        "content": "<p>Usually programming language runtimes are small and have non-standard memory management, which makes them less viable to write in Rust. That's why Mozilla rewrote the style and rendering engines, not the scripting one.</p>",
        "id": 495853757,
        "sender_full_name": "Chris Wong",
        "timestamp": 1737796983
    },
    {
        "content": "<p>There is of course the possibility of changing the bootstrapping process to transpile Lean code into Rust instead of C++, but it's not clear to me what benefit that would bring (and I think there's ongoing work to target LLVM IR instead)</p>",
        "id": 495865108,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1737806747
    },
    {
        "content": "<p>I think if the goal is RIR as a hobby, then writing an external checker is a nice place to begin. However I do think if understandability is the goal, then rewriting in lean is a better option.</p>",
        "id": 495865399,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1737806982
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/lean5.20-.20rewrite.20everything.20on.20rust.20instead.20of.20c.2B.2B.3F/near/495865108\">said</a>:</p>\n<blockquote>\n<p>There is of course the possibility of changing the bootstrapping process to transpile Lean code into Rust instead of C++, but it's not clear to me what benefit that would bring (and I think there's ongoing work to target LLVM IR instead)</p>\n</blockquote>\n<p>LLVM already works, its just a few percentages slower than C for unknown reasons</p>",
        "id": 495866208,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1737807627
    },
    {
        "content": "<p>Rust is objectively a good pick when speed is the most important feature of a product that handles untrusted inputs. It's no surprise it was created by the great folks at Mozilla for a browser, as people judge browsers primarily by security, speed and memory footprint (assuming equal standards support). The advantages in other contexts are pretty much subjective. To state the obvious, the design space for progamming languages is huge and there are many trade-offs. Claims of the form \"Rust is easier to understand than X\" usually boil down to \"I'm more familiar with Rust than language X\" (especially when language X has orders of magnitude more users than Rust), and I think they're so prevalent because the \"Rust evangelism strike force\"/\"rewrite it in Rust\" memes just got out of hand.</p>\n<p>As for the last point, using Rust wouldn't automatically endow Lean with linear types, and if Lean's type theory was augmented to be more like QTT (or your favorite dependent type theory with linearity), it's unlikely that it would match Rust's types so precisely as to be a comfortable target for lowering.</p>",
        "id": 495874318,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1737814331
    },
    {
        "content": "<p>As far as making the language core more typesafe, I assume you mean the C++ kernel (although maybe you mean the compiler/interpreter which others have addressed above).  For the logical kernel, in my opinion  <a href=\"https://github.com/digama0/lean\">Lean4Lean</a> is the best option there.  IIRC not only does it function as a pure Lean replacement for the C++ kernel (although a bit slower), it has the huge advantage that it can be proven correct in multiple ways:</p>\n<ol>\n<li>One can formalize Lean's type theory LeanTT</li>\n<li>One can formally prove the kernel faithfully implements LeanTT (i.e. there are no implementation bugs)</li>\n<li>One can formally prove LeanTT is consistent as well as sound with respect to the usual set-theoretic model of Lean (i.e. there are no logical bugs).</li>\n</ol>\n<p>Even if it never becomes the official kernel, Lean4Lean already acts as an external type checker, and point (2) can be used to prototype optimizations to the kernel, proving that these optimizations are correct.  Then the C++ kernel can also implement those optimizations and use the Lean4Lean implementation as a reference for testing.</p>",
        "id": 495890900,
        "sender_full_name": "Jason Rute",
        "timestamp": 1737827174
    },
    {
        "content": "<p>Also, see the discussion in <a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/channel/113488-general/topic/Lean4Lean.3A.20Lean.204.20kernel.20in.20Lean\">#general &gt; Lean4Lean: Lean 4 kernel in Lean</a>.</p>",
        "id": 495892131,
        "sender_full_name": "Jason Rute",
        "timestamp": 1737828192
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"325367\">Mauricio Collares</span> <a href=\"#narrow/channel/113488-general/topic/lean5.20-.20rewrite.20everything.20on.20rust.20instead.20of.20c.2B.2B.3F/near/495874318\">said</a>:</p>\n<blockquote>\n<p>Rust is objectively a good pick when speed is the most important feature of a product that handles untrusted inputs. It's no surprise it was created by the great folks at Mozilla for a browser, as people judge browsers primarily by security, speed and memory footprint (assuming equal standards support). The advantages in other contexts are pretty much subjective. To state the obvious, the design space for progamming languages is huge and there are many trade-offs. Claims of the form \"Rust is easier to understand than X\" usually boil down to \"I'm more familiar with Rust than language X\" (especially when language X has orders of magnitude more users than Rust), and I think they're so prevalent because the \"Rust evangelism strike force\"/\"rewrite it in Rust\" memes just got out of hand.</p>\n<p>As for the last point, using Rust wouldn't automatically endow Lean with linear types, and if Lean's type theory was augmented to be more like QTT (or your favorite dependent type theory with linearity), it's unlikely that it would match Rust's types so precisely as to be a comfortable target for lowering.</p>\n</blockquote>\n<p>For completeness, I'd like to say that \"rewrite it in Rust\" has actual technical merits. (Memory safety or thread safety in C++ are, I understand, extremely hard to impossible in practice. Rust makes this much more achievable. You can in principle write correct code in any language, but C++ makes some aspects <em>much</em> harder.)</p>\n<p>A rewrite can introduce bugs itself (and takes lots of effort) --- but I really wonder: if Rust had been around 10 years earlier, would be Lean kernel have been written in Rust instead?</p>",
        "id": 495895980,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1737831321
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"634338\">Michael Rothgang</span> <a href=\"#narrow/channel/113488-general/topic/lean5.20-.20rewrite.20everything.20on.20rust.20instead.20of.20c.2B.2B.3F/near/495895980\">said</a>:</p>\n<blockquote>\n<p>You can in principle write correct code in any language, but C++ makes some aspects <em>much</em> harder.</p>\n</blockquote>\n<p>There's also an argument that the subset of bugs (safe) rust eliminates are otherwise some of the most difficult to reason about. For example, proving an optimization correct in lean before porting it to C++ cannot account for the possibility of memory safety bugs in the C++ kernel.</p>",
        "id": 495898614,
        "sender_full_name": "Nick Ward",
        "timestamp": 1737833519
    },
    {
        "content": "<p>Just to be clear there is an external checker for Lean 4 written in Rust (<a href=\"https://github.com/ammkrn/nanoda_lib\">https://github.com/ammkrn/nanoda_lib</a>).  Any important Lean project should probably also be checked with one (or all) of these external checkers (for example during CI).</p>",
        "id": 495900675,
        "sender_full_name": "Jason Rute",
        "timestamp": 1737835349
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"115715\">@Jason Rute</span> it seems to me that lean has notably more (maintained) external checkers than any other proof assistant. Assuming this is true, do you know why?</p>",
        "id": 495901241,
        "sender_full_name": "Nick Ward",
        "timestamp": 1737835913
    },
    {
        "content": "<p>It's also worth saying that ensuring correctness of any non-trivial piece of software ultimately comes down to defense in depth (of which external checkers are a great example).</p>",
        "id": 495901446,
        "sender_full_name": "Nick Ward",
        "timestamp": 1737836059
    },
    {
        "content": "<p>I’m not the one to ask.  (I assume it is because Lean has a good proof exporter and that external checking is the best way to guarantee there is nothing funny going on.  I think there are ways in Lean to hack the environment and bypass the kernel.  External checking makes sure that doesn’t happen.)</p>",
        "id": 495901578,
        "sender_full_name": "Jason Rute",
        "timestamp": 1737836170
    },
    {
        "content": "<p>Also Metamath probably has more external checkers. :)</p>",
        "id": 495901741,
        "sender_full_name": "Jason Rute",
        "timestamp": 1737836306
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"115715\">Jason Rute</span> <a href=\"#narrow/channel/113488-general/topic/lean5.20-.20rewrite.20everything.20on.20rust.20instead.20of.20c.2B.2B.3F/near/495901741\">said</a>:</p>\n<blockquote>\n<p>Also Metamath probably has more external checkers. :)</p>\n</blockquote>\n<p>I expect this is probably true, but this could be explained by the relative simplicity of writing such a verifier, correct?</p>",
        "id": 495902109,
        "sender_full_name": "Nick Ward",
        "timestamp": 1737836638
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"634338\">Michael Rothgang</span> <a href=\"#narrow/channel/113488-general/topic/lean5.20-.20rewrite.20everything.20on.20rust.20instead.20of.20c.2B.2B.3F/near/495895980\">said</a>:</p>\n<blockquote>\n<p>For completeness, I'd like to say that \"rewrite it in Rust\" has actual technical merits. (Memory safety or thread safety in C++ are, I understand, extremely hard to impossible in practice. Rust makes this much more achievable. You can in principle write correct code in any language, but C++ makes some aspects <em>much</em> harder.)</p>\n<p>A rewrite can introduce bugs itself (and takes lots of effort) --- but I really wonder: if Rust had been around 10 years earlier, would be Lean kernel have been written in Rust instead?</p>\n</blockquote>\n<p>The best bang for the buck is to write new code in Rust, if that's what you want. Battle-tested code is <a href=\"https://security.googleblog.com/2024/09/eliminating-memory-safety-vulnerabilities-Android.html\">less likely to contain issues</a>, and \"old\" code almost always contains hard-earned lessons. Interop between C++ and Rust makes it possible to implement new parts in Rust while interfacing with old parts in other languages (see the link). I was mentioning Rust's Mozilla origins before, and if there's one lesson Netscape/Mozilla learned is that companies should never rewrite large-scale programs unless they were meant to be an experiment in the first place (<a href=\"https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i/\">Things You Should Never Do, Part I</a> is one of my favorite software essays). Software gets redesigned often enough, you can just do it in Rust the next time a component gets rearchitected to satisfy new requirements. On the other hand, rewriting particularly tricky <em>libraries</em> such as image/video decoders in Rust would be great, even if it still involved some amount of assembly or unsafe code.</p>\n<p>I know it's funny to say \"rewriting stuff is bad\" in the Lean Zulip of all places, but the fact that Leo knew everything about Lean 0.1/2/3 when writing Lean 4 made sure all of the hard-earned lessons were preserved in the rewrites. Not every rewrite endeavor has this luxury. And, about your last thought, my completely unsubstantiated speculation is that if Rust was already stable in 2013 (Rust 0.7 was released around the time of the first Lean commit, but I agree that pre-1.0 doesn't count), Leo would still write the kernel in whatever low-level language he was most comfortable with in this alternate universe. Speaking of which, it's much easier to trust C and C++ codebases wrt memory management when all the code has been written by just a single experienced programmer; lots of trouble in bigger projects come from mismatched memory ownership expectations/conventions. Of course, this is not to say compiler help isn't welcome (I'm in the Lean Zulip after all!), but I just wanted to highlight another luxury of the Lean kernel when compared to most other C++ projects.</p>\n<p>I swear this is my last message on this topic, since it's pretty much off-topic for the Lean Zulip.</p>",
        "id": 495904716,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1737838742
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"776338\">Nick Ward</span> <a href=\"#narrow/stream/113488-general/topic/lean5.20-.20rewrite.20everything.20on.20rust.20instead.20of.20c.2B.2B.3F/near/495902109\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"115715\">Jason Rute</span> <a href=\"#narrow/channel/113488-general/topic/lean5.20-.20rewrite.20everything.20on.20rust.20instead.20of.20c.2B.2B.3F/near/495901741\">said</a>:</p>\n<blockquote>\n<p>Also Metamath probably has more external checkers. :)</p>\n</blockquote>\n<p>I expect this is probably true, but this could be explained by the relative simplicity of writing such a verifier, correct?</p>\n</blockquote>\n<p>This is almost certainly the case. Shameless plug for those up to the challenge: <a href=\"https://ammkrn.github.io/type_checking_in_lean4/\">https://ammkrn.github.io/type_checking_in_lean4/</a></p>\n<p>A simpler lean checker is possible by adding one more layer and having the \"real\" trusted checker only review forward reasoning chains, but that's not how the current ones work.</p>",
        "id": 495904916,
        "sender_full_name": "Chris Bailey",
        "timestamp": 1737838875
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"228466\">@Chris Bailey</span> How long do you think it would take someone to write a Lean type checker from scratch using your guide, that would be capable of checking all of (the export of) mathlib?  A week?  A month?</p>",
        "id": 495905645,
        "sender_full_name": "Jason Rute",
        "timestamp": 1737839496
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"115715\">@Jason Rute</span> I like where this is going..</p>",
        "id": 495905710,
        "sender_full_name": "Nick Ward",
        "timestamp": 1737839537
    },
    {
        "content": "<p>That's hard to say. Someone acquainted with capture avoiding substitution, debruijn indices, working with open terms, etc would be able to do it in much less time than someone who has to learn as they go. Someone who can work on it all day and keep that continuity of thought is in the same situation relative to someone who gets an hour a day to hack on it.</p>\n<p>The fork of the exporter I used outputs the recursors and computation rules as well as the quotient terms. This was done for performance reasons in my case, but it does allow someone to implement just the core checker without having to immediately do the hardest/most time consuming parts at the expense of some assurance.</p>\n<p>For someone on the happy path (familiar with lambda calculus internals, acquainted with lean, can work on it consistently, not reimplementing inductives themselves) using an agreeable language, not shy about asking for help, I think its like a two week thing?</p>",
        "id": 495914030,
        "sender_full_name": "Chris Bailey",
        "timestamp": 1737847829
    },
    {
        "content": "<p>lean on lean then (without any c++ at all, without transpilation, maybe only have  .cbor files like purescript does for caching of already proved theorms or etc ) would be awesome</p>",
        "id": 495962825,
        "sender_full_name": "Serhii Khoma (srghma)",
        "timestamp": 1737894093
    },
    {
        "content": "<p>In what sense is lean not practically already what you describe? Transpilation to C vs compilation to LLVM IR seems kind of irrelevant beyond unnecessary C source parsing, and direct compilation to x86 assembly would be a massive and mostly-pointless project.</p>",
        "id": 495967060,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1737897638
    },
    {
        "content": "<p>At some level you need some \"unsafe\" C code, because you have to call into the OS APIs with unsafe C semantics, and that is what a fair chunk of Lean's (non-transpiled) C++ code is doing.</p>",
        "id": 495967121,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1737897709
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"228466\">@Chris Bailey</span> Could you elaborate on how you think the kernel could be improved beyond essentially the architecture of lean4lean (/ the official kernel)? I'm not sure I understand how you could shortcut some or all of that even if we use the export format instead of the oleans - you still have to infer all the intermediate types and do whnf in the kernel, unless you also log defeq chains</p>",
        "id": 496795354,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1738248708
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/113488-general/topic/lean5.20-.20rewrite.20everything.20on.20rust.20instead.20of.20c.2B.2B.3F/near/496795354\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"228466\">Chris Bailey</span> Could you elaborate on how you think the kernel could be improved beyond essentially the architecture of lean4lean (/ the official kernel)? I'm not sure I understand how you could shortcut some or all of that even if we use the export format instead of the oleans - you still have to infer all the intermediate types and do whnf in the kernel, unless you also log defeq chains</p>\n</blockquote>\n<p>No shortcuts. Maybe it would have been more clear to draw a distinction between a verifier (needs to be spoon fed all of the intermediate steps) and a kernel (capable of checking the proof by itself). In that context I would rephrase it as \"a simpler <em>verifier</em> can be implemented\" which in a literal sense adds more software, but is effectively a reduction in size/complexity of the stuff in ring 0 since you would no longer have to trust the component that actually produces the reasoning chains. I'm thinking of something like lean.mm1.</p>",
        "id": 496832755,
        "sender_full_name": "Chris Bailey",
        "timestamp": 1738258743
    }
]