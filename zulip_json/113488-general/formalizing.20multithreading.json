[
    {
        "content": "<p>I've been procrasinating my operating systems homework so I decided to formalize multithreading</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Std</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Std</span>\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">  a monad `m` can be collected into a list of atomic instructions</span>\n<span class=\"cm\">  `β` is the instruction type</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Instruction</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">instructions</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">`ThreadCollector m β σ`:</span>\n\n<span class=\"sd\">Represents a **scheduler** that tracks the evolution of a global scheduling state `σ`</span>\n<span class=\"sd\">as threads execute atomic instructions of type `β` in monad `m`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">ThreadCollector</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/--</span>\n<span class=\"sd\">  Update the scheduler after a thread executes an atomic instruction.</span>\n\n<span class=\"sd\">  - `sched` — the current scheduler state.</span>\n<span class=\"sd\">  - `instr` — the instruction the thread wants to execute.</span>\n<span class=\"sd\">  - `threadIdx` — index of the thread performing the instruction.</span>\n\n<span class=\"sd\">  Returns:</span>\n<span class=\"sd\">  * `none` if the thread is **denied** (e.g., tries to lock an already-locked mutex</span>\n<span class=\"sd\">    or is currently asleep).</span>\n<span class=\"sd\">  * `some mσ` if the thread is allowed to execute, producing a monadic action</span>\n<span class=\"sd\">    `m σ` that updates the scheduler state after the instruction.</span>\n<span class=\"sd\">  -/</span>\n<span class=\"w\">  </span><span class=\"n\">step</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">threadIdx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">`scheduleOf sched instrs` means that `sched` is a **valid interleaving**</span>\n<span class=\"sd\">of the per-thread instruction lists `instrs`.</span>\n\n<span class=\"sd\">Formally:</span>\n<span class=\"sd\">1. Every instruction in `sched` is tagged by a valid thread index.</span>\n<span class=\"sd\">2. When we group `sched` by these thread tags, we recover exactly each `instrs[k]`.</span>\n<span class=\"sd\">3. `sched` and `tags` have the same length.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">scheduleOf</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sched</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">instrs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">tags</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">),</span>\n<span class=\"w\">    </span><span class=\"c1\">-- (1) sched and tags have the same length</span>\n<span class=\"w\">    </span><span class=\"n\">sched</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">tags</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">∧</span>\n<span class=\"w\">    </span><span class=\"c1\">-- (2) every tag is a valid thread index</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">tags</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">tags</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"bp\">!</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">instrs</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∧</span>\n<span class=\"w\">    </span><span class=\"c1\">-- (3) grouping by thread tag recovers the original instrs[k] (List.filterMap perserves order)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">instrs</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">,</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">grouped</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sched</span><span class=\"bp\">.</span><span class=\"n\">zip</span><span class=\"w\"> </span><span class=\"n\">tags</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">filterMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">        </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"o\">)</span><span class=\"bp\">;</span>\n<span class=\"w\">        </span><span class=\"n\">grouped</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">instrs</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"bp\">!</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I was wondering if there were similar efforts or if anybody has feedback on my formalisms</p>",
        "id": 543187408,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1759692455
    },
    {
        "content": "<p>my next goals are to formalize mutexs and show that if you have <code>n</code> threads each of which is locking from a list of <code>m</code> mutexs as long as all threads lock in ascending order of the mutex list then a deadlock can never happen</p>",
        "id": 543187532,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1759692569
    },
    {
        "content": "<p>here's teh formalizm up to deadlocks</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Std</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Std</span>\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">  a monad `m` can be collected into a list of atomic instructions</span>\n<span class=\"cm\">  `β` is the instruction type</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Instruction</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">instructions</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">`ThreadCollector m β σ`:</span>\n\n<span class=\"sd\">Represents a **scheduler** that tracks the evolution of a global scheduling state `σ`</span>\n<span class=\"sd\">as threads execute atomic instructions of type `β` in monad `m`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">ThreadCollector</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/--</span>\n<span class=\"sd\">  Update the scheduler after a thread executes an atomic instruction.</span>\n\n<span class=\"sd\">  - `sched` — the current scheduler state.</span>\n<span class=\"sd\">  - `instr` — the instruction the thread wants to execute.</span>\n<span class=\"sd\">  - `threadIdx` — index of the thread performing the instruction.</span>\n\n<span class=\"sd\">  Returns:</span>\n<span class=\"sd\">  * `none` if the thread is **denied** (e.g., tries to lock an already-locked mutex</span>\n<span class=\"sd\">    or is currently asleep).</span>\n<span class=\"sd\">  * `some mσ` if the thread is allowed to execute, producing a monadic action</span>\n<span class=\"sd\">    `m σ` that updates the scheduler state after the instruction.</span>\n<span class=\"sd\">  -/</span>\n<span class=\"w\">  </span><span class=\"n\">step</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">threadIdx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">`scheduleOf sched instrs` means that `sched` is a **valid interleaving**</span>\n<span class=\"sd\">of the per-thread instruction lists `instrs`.</span>\n\n<span class=\"sd\">- `sched : List (Nat × β)` is a list of `(threadIdx, instruction)` pairs.</span>\n<span class=\"sd\">- `instrs : List (List β)` is the per-thread list of instructions.</span>\n\n<span class=\"sd\">Formally:</span>\n<span class=\"sd\">1. Every `(threadIdx, _)` in `sched` refers to a valid thread index.</span>\n<span class=\"sd\">2. For each thread `k`, collecting all instructions in `sched` with `threadIdx = k`</span>\n<span class=\"sd\">   (in order) recovers exactly `instrs[k]`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">scheduleOf</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sched</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">instrs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"c1\">-- (1) every tag is a valid thread index</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">ib</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">sched</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ib</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">instrs</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∧</span>\n<span class=\"w\">  </span><span class=\"c1\">-- (2) grouping by thread tag recovers the original instrs[k]</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">instrs</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">grouped</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">sched</span><span class=\"bp\">.</span><span class=\"n\">filterMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"o\">)</span><span class=\"bp\">;</span>\n<span class=\"w\">    </span><span class=\"n\">grouped</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">instrs</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"bp\">!</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">`partialScheduleOf prefix instrs` means that `prefix` is a **valid partial interleaving**</span>\n<span class=\"sd\">of the per-thread instruction lists `instrs`.</span>\n\n<span class=\"sd\">- `prefix : List (Nat × β)` is a prefix of a schedule.</span>\n<span class=\"sd\">- `instrs : List (List β)` is the per-thread list of instructions.</span>\n\n<span class=\"sd\">Formally:</span>\n<span class=\"sd\">1. Every `(threadIdx, _)` in `prefix` refers to a valid thread index.</span>\n<span class=\"sd\">2. For each thread `k`, collecting all instructions in `prefix` with `threadIdx = k`</span>\n<span class=\"sd\">   (in order) forms a **prefix** of `instrs[k]`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">partialScheduleOf</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">pref</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">instrs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"c1\">-- (1) every tag is a valid thread index</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">ib</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">pref</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ib</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">instrs</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∧</span>\n<span class=\"w\">  </span><span class=\"c1\">-- (2) grouping by thread tag is a prefix of each thread's instructions</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">instrs</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">grouped</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">pref</span><span class=\"bp\">.</span><span class=\"n\">filterMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"o\">)</span><span class=\"bp\">;</span>\n<span class=\"w\">    </span><span class=\"n\">grouped</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">instrs</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"bp\">!.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">∧</span>\n<span class=\"w\">    </span><span class=\"n\">grouped</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">instrs</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"bp\">!.</span><span class=\"n\">take</span><span class=\"w\"> </span><span class=\"n\">grouped</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">pref</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">instrs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)):</span><span class=\"w\"> </span><span class=\"n\">partialScheduleOf</span><span class=\"w\"> </span><span class=\"n\">pref</span><span class=\"w\"> </span><span class=\"n\">instrs</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">sched</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">scheduleOf</span><span class=\"w\"> </span><span class=\"n\">sched</span><span class=\"w\"> </span><span class=\"n\">instrs</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">pref</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">sched</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">pref</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">sched</span><span class=\"bp\">.</span><span class=\"n\">take</span><span class=\"w\"> </span><span class=\"n\">pref</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">`scheduleValid sched σ0 TC` means that executing `sched` from initial state `σ0`</span>\n<span class=\"sd\">using the `ThreadCollector` `TC` always produces `some σ` at every step.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">scheduleValid</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}{</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">TC</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ThreadCollector</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">sched</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">))</span><span class=\"w\">  </span><span class=\"c1\">-- (threadIdx, instr)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">σ0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">σFinal</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">sched</span><span class=\"bp\">.</span><span class=\"n\">foldlM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ti</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">instr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">TC</span><span class=\"bp\">.</span><span class=\"n\">step</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">instr</span><span class=\"w\"> </span><span class=\"n\">ti</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">ms</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">ms</span><span class=\"w\">  </span><span class=\"c1\">-- bind the monadic action</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\">    </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\">  </span><span class=\"c1\">-- stop counting as valid? (could alternatively fail)</span>\n<span class=\"w\">    </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">σ0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">σFinal</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">`deadlocks TC σ0 instrs pref` means that after executing the partial schedule `pref`,</span>\n<span class=\"sd\">the system is in **deadlock** under the `ThreadCollector` `TC` starting from state `σ0`.</span>\n\n<span class=\"sd\">Formally:</span>\n<span class=\"sd\">- `pref : List (Nat × β)` is a valid partial schedule (`partialScheduleOf pref instrs`).</span>\n<span class=\"sd\">- After `pref`, **any extension** of the remaining instructions cannot produce a</span>\n<span class=\"sd\">  full valid schedule where every step returns `some`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">deadlocks</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">TC</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ThreadCollector</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">σ₀</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">instrs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">pref</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">partialScheduleOf</span><span class=\"w\"> </span><span class=\"n\">pref</span><span class=\"w\"> </span><span class=\"n\">instrs</span><span class=\"w\"> </span><span class=\"bp\">∧</span>\n<span class=\"w\">  </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">extension</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">),</span>\n<span class=\"w\">    </span><span class=\"c1\">-- extension must respect per-thread order of remaining instructions</span>\n<span class=\"w\">    </span><span class=\"n\">scheduleOf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">pref</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">extension</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">instrs</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">    </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"n\">scheduleValid</span><span class=\"w\"> </span><span class=\"n\">TC</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">pref</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">extension</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">σ₀</span>\n</code></pre></div>",
        "id": 543188529,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1759693521
    },
    {
        "content": "<p>a lot of proofs can be done via a starvation invariant which is basically like a loop invariant but you also have to prove it won't starve ie <code>starvationInv threadIdx \\sigma -&gt; match step \\sigma \\beta | x =&gt; starvationInv threadIdx x | none =&gt; False</code></p>",
        "id": 543196157,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1759702292
    }
]