[
    {
        "content": "<p>Hello!  I'm relatively inexperienced with Lean: I think I have a basic understanding of the dependent type theory involved, but I'm struggling with an error from the kernel that I think might be due to how an induction principle is being derived.  Here's a MWE of my situation:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Finmap</span>\n\n<span class=\"kn\">mutual</span>\n<span class=\"w\">  </span><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Mk</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bar</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Foo</span>\n\n<span class=\"w\">  </span><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Bar</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Mk</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finmap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bar</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n<p>And here's the resulting error message I'm seeing, focused on the <code>inductive Foo</code> line:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">kernel</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">application</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">mismatch</span>\n<span class=\"w\">  </span><span class=\"n\">entries</span><span class=\"bp\">.</span><span class=\"n\">NodupKeys</span>\n<span class=\"n\">argument</span><span class=\"w\"> </span><span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"n\">Multiset</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">nested</span><span class=\"bp\">.</span><span class=\"n\">Sigma_2</span>\n<span class=\"n\">but</span><span class=\"w\"> </span><span class=\"n\">function</span><span class=\"w\"> </span><span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"n\">Multiset</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n</code></pre></div>\n<p>Examining the message, it seems clear that the <code>Mk</code> constructor of <code>Bar</code> is being invoked by some spooky code I haven't written.  The invocation of the <code>Mk</code> constructor appears to be receiving a thing of type <code>Multiset _nested.Sigma_2</code>, a type with which I'm unfamiliar and, if the leading underscore is any indication, I perhaps shouldn't even know about.</p>\n<p>My overall goal is to prove an alignment between two proof systems, so I'm intentionally defining everything using structures like <code>Finmap</code> rather than e.g. <code>TreeMap</code>.  I suspect that there's some <code>set_option</code> that I could perform to see the code generated for the induction principle (to test my hypothesis), but if that turned out to be true, I'm not sure what I could do about it.</p>\n<p>Any suggestions?  Thanks for reading!</p>",
        "id": 540240359,
        "sender_full_name": "Zach",
        "timestamp": 1758203641
    },
    {
        "content": "<p>There are multiple problems here: <code>Finmap</code> is a subtype and nested subtypes aren't supported and <code>Multiset</code> is a quotient a nested quotients aren't supported.</p>",
        "id": 540240860,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1758203787
    },
    {
        "content": "<p>Thanks for the reply!  When you say \"aren't supported\", do you mean with respect to mutually-defined inductive types?</p>",
        "id": 540241061,
        "sender_full_name": "Zach",
        "timestamp": 1758203841
    },
    {
        "content": "<p>Well, nested quotients aren't supported in the sense that you can't do something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Fails</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Quot</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Fails</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">Perm</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>i.e. you can't have a recursive reference of any inductive type in the mutual block nested inside of a quotient</p>",
        "id": 540241488,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1758203955
    },
    {
        "content": "<p>why is it not supported?</p>",
        "id": 540242259,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758204144
    },
    {
        "content": "<p>And nested subtypes aren't supported because of how the kernel de-nests types:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">mutual</span>\n<span class=\"w\">  </span><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Mk</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bar</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Foo</span>\n\n<span class=\"w\">  </span><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Bar</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Mk</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finmap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bar</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n<p>turns into</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">mutual</span>\n<span class=\"w\">  </span><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Mk</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bar</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Foo</span>\n\n<span class=\"w\">  </span><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Bar</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Mk</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">nested</span><span class=\"bp\">.</span><span class=\"n\">Finmap_1</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bar</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- Finmap (fun (_ : Nat) =&gt; Foo)</span>\n<span class=\"w\">  </span><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">nested</span><span class=\"bp\">.</span><span class=\"n\">Finmap_1</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">    </span><span class=\"n\">entries</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Multiset</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">nested</span><span class=\"bp\">.</span><span class=\"n\">Sigma_2</span>\n<span class=\"w\">    </span><span class=\"n\">nodupKeys</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">entries</span><span class=\"bp\">.</span><span class=\"n\">NodupKeys</span><span class=\"w\"> </span><span class=\"c1\">-- error</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- Sigma (fun (_ : Nat) =&gt; Foo)</span>\n<span class=\"w\">  </span><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">nested</span><span class=\"bp\">.</span><span class=\"n\">Sigma_2</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">    </span><span class=\"n\">fst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"w\">    </span><span class=\"n\">snd</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Foo</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 540242319,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1758204161
    },
    {
        "content": "<p>I think I'm following.  (Still a novice!)  It seems almost as if I'll need to have some representation of the finite maps that appear in my proof systems that doesn't rely on the Finset part of Mathlib.  Thank you for the explanation!</p>",
        "id": 540242521,
        "sender_full_name": "Zach",
        "timestamp": 1758204218
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"927738\">@Zach</span> you'll need to use <code>List</code> and then later quotient on the big type</p>",
        "id": 540242791,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758204286
    },
    {
        "content": "<p>see how <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ZFSet#doc\">docs#ZFSet</a> works</p>",
        "id": 540242854,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758204305
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> Thanks!  I was suspecting this.  I'm using finite maps in a few different places, so I was looking for what would essentially be a dictionary structure at the proposition level.  I'm tempted to define my own: even if it goes poorly, I'm sure I'll learn something from the process.  :)</p>",
        "id": 540243248,
        "sender_full_name": "Zach",
        "timestamp": 1758204411
    }
]