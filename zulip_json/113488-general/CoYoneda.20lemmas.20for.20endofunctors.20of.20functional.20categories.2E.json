[
    {
        "content": "<p>Folks, </p>\n<p>I would like to announce that I finished the proofs of my <br>\nPointfree CoYoneda lemmas for endofunctors of functional categories.</p>\n<p>Afaik the lemma's at the end are original mathematical results (the code is self-contained).</p>\n<p>For the moment the formulations and the proofs are \"low profile\". Helping me making them more \"high profile\" (cfr. <code>MathLib</code>), as suggested in the beginning of the <code>README.md</code> file of the  <a href=\"https://github.com/LucDuponcheelAtGitHub/CoEndoYoneda-in-Lean\">GitHub Repository</a>, would be appreciated. </p>\n<p>I cannot include the code because it consists of too many lines. You'll have to copy/paste the <a href=\"https://raw.githubusercontent.com/LucDuponcheelAtGitHub/CoEndoYoneda-in-Lean/refs/heads/main/CoEndoYoneda.lean\">raw code</a>.</p>",
        "id": 561834693,
        "sender_full_name": "Luc Duponcheel",
        "timestamp": 1764841962
    },
    {
        "content": "<p>It seems what you define as <code>Category/CategoryProperties</code> is mostly what we call a concrete category. The only chance it might enter mathlib is that you use more standard terminology and do not duplicate existing definitions. In the current form of the code, I have absolutely no idea what is the statement that you have formalised.</p>",
        "id": 561852729,
        "sender_full_name": "Joël Riou",
        "timestamp": 1764847595
    },
    {
        "content": "<p>Joël, thanks for the quick reply</p>\n<p>I'll have a look at the concrete category code of Mathlib asap.<br>\nOf course I want to throw away my self contained supporting code.<br>\nThe code is really a first approach to be sure that the proofs are correct.</p>\n<p>As far as what I have proved, in short <br>\n(<code>btc</code> standing for binary type constructor, cfr. <code>Category</code>)<br>\n(<code>utc</code> standing for unary type constructor, cfr. <code>Functor</code>) :</p>\n<p>The standard CoYoneda lemma for categories <code>btc</code> is about the relationship between,<br>\non the one hand, <br>\nnatural transformations between the  CoYoneda functor, <code>coYonedaFunctorOf s</code> and function valued functors <code>utc</code>, and,<br>\non the other hand, <br>\nvalues of type <code>utc s</code>.<br>\nSee <code>pointfulCoYonedaLemma1</code>, lines 603-686</p>\n<p>My two CoEndoYoneda lemmas for <em>functional categories</em> are about the relationship between,<br>\non the one hand,<br>\nnatural transformations between the CoEndoYoneda <em>endoFunctor</em>, <code>coEndoYonedaFunctorOf s</code> and <em>endoFunctors</em> <code>utc</code>, and,<br>\non the other hand,<br>\n<em>global values</em> of type <code>btc Unit (utc s)</code>, <br>\nresp. <em>global values</em> of type <code>btc Unit (btc Unit (utc s))</code>.<br>\nSee <code>pointfreeCoEndoYonedaLemma1</code>, lines 1292-1510,<br>\nresp. <code>pointfreeCoEndoYonedaLemma3</code>, lines 1798-1991.</p>",
        "id": 561867602,
        "sender_full_name": "Luc Duponcheel",
        "timestamp": 1764852075
    },
    {
        "content": "<p>Joël, I am aware that my <code>calc</code> based proofs are long. That is one of the reasons why I hope to do better using <code>simp</code> using the capabilities of Mathlib. But first, I wanted to do everything manually, if only to have an idea which axioms I needed.<br>\nMy work is not about writing an existing proof in <code>Lean</code>, but to use <code>Lean</code> to help me proving my (a.f.a.i.k.) new idea.</p>",
        "id": 561869113,
        "sender_full_name": "Luc Duponcheel",
        "timestamp": 1764852503
    },
    {
        "content": "<p>Joël, from the wiki page :</p>\n<p>In mathematics, a concrete category is a category that is equipped with a faithful functor <em>to</em> the category of sets.</p>\n<p>What I call a functional category is a category that is equipped with a functor <em>from</em> the category of sets.</p>\n<p>I do not want to add structure to sets, I just want to treat functions as morphisms.</p>\n<p>In functional programming functions are morphisms that are  \"effectfree programs\" but there are other morphisms that are \"effectful programs\", for example, morphisms manipulating internal or external state.</p>",
        "id": 561872688,
        "sender_full_name": "Luc Duponcheel",
        "timestamp": 1764853520
    },
    {
        "content": "<p>Ok, your <code>Category/CategoryClasses</code> look more like attempting to defining a category structure on a type <code>C</code> where <code>C</code> happens to be <code>Type</code>. But, I still have no idea what is the mathematical content of your file.</p>",
        "id": 561875971,
        "sender_full_name": "Joël Riou",
        "timestamp": 1764854497
    },
    {
        "content": "<p>Joël, </p>\n<p>It is always a bit challenging to try to understand something new.</p>\n<p>The least one can require from a category <code>btc</code> to model functional programming<br>\nis that there is a functor from <code>function</code>, the category of functions, to <code>btc</code>.</p>\n<p>The standard (Co)Yoneda lemma is about functors from <code>btc</code> to <code>function</code>.<br>\nThey can then be composed with the functor from <code>function</code>, to <code>btc</code> above,<br>\nobtaining endofunctors. </p>\n<p>No more functions involved, everything is pointfree.</p>\n<p>So it is natural to ask yourself: is it possible to formulate and prove<br>\na pointfree (Co)Yoneda lemma about endofunctors of such functional categories.</p>\n<p><code>coYonedaLemma1</code> (mentioned in a previous reply) simply proves that<br>\n<code>τ = σ</code>,<br>\nwhere <code>τ</code> is the natural transformation morphism involved,<br>\nand <code>σ</code> is defined in terms of a value. It is a simplified version of<br>\n<code>pointfulCoYonedaLemma1</code> using functional extension. <code>funext</code></p>\n<p><code>pointfreeCoYonedaLemma3</code> (mentioned in a previous reply) proves that<br>\n<code>gₛₜ btc_s_t ≫ τ ≫ γν = gₛₜ btc_s_t ≫ σ</code>,<br>\nwhere <code>τ</code> is the natural transformation morphism involved,<br>\n<code>σ</code> is defined in terms of a global value and <code>gₛₜ btc_s_t</code><br>\nis a global value (actually a global morphism), <br>\nand <code>γν</code> is the neutral element of the triple <code>globalTriple</code>.<br>\nIt is not possible to simplify it to<br>\n<code>τ ≫ γν = σ</code> since <code>gₛₜ btc_s_t</code><br>\nis not a general enough. Maybe quotients of equivalence<br>\nrelations can be used to simplify?</p>\n<p>Similarly</p>\n<p><code>pointfreeCoYonedaLemma4</code> (mentioned in a previous reply) proves that<br>\n<code>gₛₜ btc_s_t ≫ τ = gₛₜ btc_s_t ≫ σ</code>, wbere the proof now<br>\nalso involves <code>γμ</code>, the multiplication of the triple <code>globalTriple</code>.<br>\nIt is not possible to simplify it to<br>\n<code>τ = σ</code> for the same reason.</p>\n<p>Hopefully this helps.</p>",
        "id": 561884137,
        "sender_full_name": "Luc Duponcheel",
        "timestamp": 1764856714
    },
    {
        "content": "<p>I will not try to understand what you are trying to say if you continue to use confusing terminology.<br>\nOne major problem with your code is that it is highly obfuscated: most of the definitions start with an extravagant number of <code>let ... := </code> in the statement itself, and as the proofs also start with a bunch of <code>let ... :=</code>, it is basically impossible to see where the statements are. Basically, anytime you need a <code>let</code> in a <em>statement</em>, this is a sign that there is a missing definition.</p>",
        "id": 561891954,
        "sender_full_name": "Joël Riou",
        "timestamp": 1764858629
    },
    {
        "content": "<p>Joël, You have a valid point. I will do my best to extract the local <code>let</code> definitions and replace them with global <code>def</code> definitions. The (slight) advantage of using  local <code>let</code> definitions is that they need less context, but, yes, the (more important) advantage of using global <code>def</code> definitions is reusability and less obfuscated code.  </p>\n<p>As far as terminology is concerned, I only used category, functor, natural transformation, triple and global value. Agreed I should, maybe, have used global element, but in the typed programming world value is more commonly used than element.</p>\n<p><em>Do not get me wrong I highly appreciate your constructive feedback. It motivates me to improve my code. Thanks so much.</em></p>",
        "id": 561910509,
        "sender_full_name": "Luc Duponcheel",
        "timestamp": 1764862587
    },
    {
        "content": "<p><strong>FYI</strong></p>\n<p><code>CoEndoYoneda02.lean</code> in <a href=\"https://github.com/LucDuponcheelAtGitHub/CoEndoYoneda-in-Lean\">my repo</a> now almost does not contain any local <code>let</code> definitions any more. </p>\n<p>Less code, but, more complex, explicit, equalities. </p>\n<p><strong>BTW</strong><br>\nNo need to try to review the code at this point. <br>\n(<code>Lean</code> reviewed both  <code>CoEndoYoneda01.lean</code> and <code>CoEndoYoneda02.lean</code>)</p>\n<p>Starting from now on I am going (to try to) integrate the code with the Mathlib category library code. I may need some help. Like I already mentioned,  It is always a bit challenging to try to understand something new (in my case that library is new for me).</p>",
        "id": 562196206,
        "sender_full_name": "Luc Duponcheel",
        "timestamp": 1764976317
    }
]