[
    {
        "content": "<p>title:A Pretty Expressive Printer (with Appendices)<br>\nlink: <a href=\"https://arxiv.org/abs/2310.01530\">https://arxiv.org/abs/2310.01530</a></p>\n<p>I haven't read the entire paper yet; I've only looked at the abstract, but it seems very interesting. The fact that it uses Lean is also intriguing, and I thought that the proposed technique might be applicable to Lean as well. What do you think?</p>",
        "id": 497487298,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1738601591
    },
    {
        "content": "<p>I already implemented it: <a href=\"https://github.com/hargoniX/pfmt\">https://github.com/hargoniX/pfmt</a>, it's just waiting for someone <span aria-label=\"tm\" class=\"emoji emoji-2122\" role=\"img\" title=\"tm\">:tm:</span> to actually make use of it to format Lean code (which is a non trivial effort)</p>",
        "id": 497494771,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1738603702
    },
    {
        "content": "<p>oh nice! good job!</p>",
        "id": 497561468,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1738630917
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> what is the process you envision for using your tool to format Lean code?  Would one build the pretty printing language (I believe <code>Doc</code> in your code) from <code>Syntax</code> values in Lean?</p>",
        "id": 497569807,
        "sender_full_name": "Walter Moreira",
        "timestamp": 1738636129
    },
    {
        "content": "<p>... and if I may add a follow up question: would <code>Lean.Parser.runParserCategory</code> be the right function to convert a source file to <code>Syntax</code>?</p>",
        "id": 497573892,
        "sender_full_name": "Walter Moreira",
        "timestamp": 1738638706
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"269975\">Walter Moreira</span> <a href=\"#narrow/stream/113488-general/topic/paper.3A.20pretty.20expressive.20printer/near/497569807\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> what is the process you envision for using your tool to format Lean code?  Would one build the pretty printing language (I believe <code>Doc</code> in your code) from <code>Syntax</code> values in Lean?</p>\n</blockquote>\n<p>Yes</p>\n<p><span class=\"user-mention silent\" data-user-id=\"269975\">Walter Moreira</span> <a href=\"#narrow/stream/113488-general/topic/paper.3A.20pretty.20expressive.20printer/near/497573892\">said</a>:</p>\n<blockquote>\n<p>... and if I may add a follow up question: would <code>Lean.Parser.runParserCategory</code> be the right function to convert a source file to <code>Syntax</code>?</p>\n</blockquote>\n<p>Its more involved than that. As lean can extend itself on the file you need to elaborate a file as you are parsing it in case someone declares a syntax in the middle of the fly. In general we most likely need an attribute to tag pretty printers of custom user declared syntax. I assume that for many syntaxes like single symbol ones or infix notation we can automatically derive a pretty printer so one would need to integrate that with these mechanisms. And then someone has to go through all of core and add a formatter for the at least dozens, potentially hundreds (I didn't count them yet) kinds of syntax that we have. And then someone has to do that for all the mathlib syntax that cannot be auto generated and then we should be good to go.</p>",
        "id": 497595934,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1738653062
    },
    {
        "content": "<p>Thank you for the information. It is indeed more involved than what I was thinking. Are you aware of someone already working on this plan, using your <code>pfmt</code> code?</p>\n<p>If so, would it be possible to contribute to that effort, or otherwise to start at least an incremental approach to mapping Lean's syntax into your framework?</p>\n<p>(I'm a big fan of auto-formatters, like <code>black</code> in Python, and I really miss that tool in Lean. It's an itch to scratch...)</p>",
        "id": 497756639,
        "sender_full_name": "Walter Moreira",
        "timestamp": 1738703266
    },
    {
        "content": "<blockquote>\n<p>Are you aware of someone already working on this plan, using your <code>pfmt</code> code?</p>\n</blockquote>\n<p>no</p>",
        "id": 497756753,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1738703292
    },
    {
        "content": "<p>Hi, I am considering using Pretty Expressive to format Lean in connection to my master thesis.</p>\n<p>My current Idea would be to get the Syntax of all top-level commands using a previous attempt at formatting (essentially call processHeader, then IO.processCommads and then format the code based on the InfoTree): <a href=\"https://github.com/leanprover/lean4/blob/master/script/reformat.lean\">https://github.com/leanprover/lean4/blob/master/script/reformat.lean</a><br>\nAs far as I can tell this would let us see the current state of the environment and options for each top-level command. Which would be useful for temporary configuration of the formatter, such as disabling it momentarily using set_option.</p>\n<p>Note that InfoTree.context has changed since the code was written. This would be my smallest fix</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">topLevelCmds</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">CommandSyntax</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">commandState</span><span class=\"bp\">.</span><span class=\"n\">infoState</span><span class=\"bp\">.</span><span class=\"n\">trees</span><span class=\"bp\">.</span><span class=\"n\">toArray</span><span class=\"bp\">.</span><span class=\"n\">mapM</span><span class=\"w\"> </span><span class=\"k\">fun</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">InfoTree</span><span class=\"bp\">.</span><span class=\"n\">context</span><span class=\"w\"> </span><span class=\"n\">i</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">InfoTree</span><span class=\"bp\">.</span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Info</span><span class=\"bp\">.</span><span class=\"n\">ofCommandInfo</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">stx</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">..</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">commandCtx</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">env</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">currNamespace</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">openDecls</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">..</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">        </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">env</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">currNamespace</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">openDecls</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"o\">}</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">        </span><span class=\"n\">failWith</span><span class=\"w\"> </span><span class=\"s2\">\"not a commandCtx\"</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">failWith</span><span class=\"w\"> </span><span class=\"s2\">\"unknown info tree\"</span>\n</code></pre></div>\n<p>I am new to Lean so I am probably missing something. <br>\nFor example, I am uncertain whether it is possible to determine the value of a reference after the code has been executed at a specific point in time.<br>\nThis interested me because I considered supporting changing how the syntax is formatted part way through the file.<br>\nHowever, this might not be important because the only use I could see is making testing slightly easier.</p>\n<p>I am also considering connecting to the LSP so we wouldn't have to evaluate the code again before formatting it, to hopefully speed up formatting while editing.</p>",
        "id": 497775954,
        "sender_full_name": "Frithjof Sletten",
        "timestamp": 1738711492
    },
    {
        "content": "<p>Your general approach to this project above sounds correct to me yes.</p>\n<p>Organization wise an important thing to keep in mind is that this project is on the Lean FRO roadmap so it will also be tackled sooner or later by a FRO employee (potentially me). I can't make any guarantees about when this is going to happen so it might be that we end up working on a similar project before or during the period you plan to write your thesis in. It might also happen that we start working on it after your thesis and find that it needs to be reworked to make it work as we would like it to.</p>",
        "id": 497822507,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1738739610
    }
]