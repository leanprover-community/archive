[
    {
        "content": "<p>For the rewrite suggestion tactic, <code>rw??</code>, there is the problem that it can take a while for the suggestions to load. This can be improved by using more paralellization, but it can also be improved by having the widget show that progress is happening, for example by showing a partial list of suggestions when only some of the suggestions have been computed.</p>\n<p>My understanding is that there is no way for the Lean side of a widget to directly tell the JavaScript to reload, in the way that a <code>setState()</code> in React does. Instead we can write a component in ProofWidgets that periodically queries Lean whether anything has changed, and if so, then reload the widget. In particular the widget could store a reference to an <code>IO.Ref Î±</code>, together with the name of a Lean function that takes in this <code>IO.Ref Î±</code> and produces <code>Option Html</code>.</p>\n<p><span class=\"user-mention\" data-user-id=\"128280\">@ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’</span> is that right, and do you think that this would be a good idea for ProofWidgets?</p>",
        "id": 547125497,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1761480412
    },
    {
        "content": "<p>Actually, I think the function that repeatedly checks if the <code>IO.Ref</code> has been modified can also be written on the Lean side.</p>\n<p>So all that we need to add to ProofWidgets is a component that displays some Html, and simultaneously asks Lean for a new Html object. The Lean function might take some time, and it can either return a new Html object, or <code>none</code>, in which case the widget stops calling Lean.</p>",
        "id": 547134913,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1761489080
    },
    {
        "content": "<blockquote>\n<p>there is no way for the Lean side of a widget to directly tell the JavaScript to reload</p>\n</blockquote>\n<p>The LSP protocol does support server-&gt;client notifications and requests. IIRC <code>RequestM</code> doesn't expose any API for sending notifications; it does allow requests via the <code>ServerRequestEmitter</code>, though I'm not sure whether user widgets can respond to those. Anyhow your idea of polling the Lean server multiple times sounds like it'd result in more understandable code.</p>",
        "id": 547158553,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1761511568
    },
    {
        "content": "<p>Are you using <code>mk_rpc_widget%</code> or also writing custom JS? If the former, one idea would be to extend <code>mk_rpc_widget%</code> to support signatures of the form <code>MyProps â†’ RequestM (RequestTask (Html âŠ• CallMeLater Html))</code> where <code>CallMeLater</code> specifies a delay after which the function will be called again.</p>",
        "id": 547158829,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1761511918
    },
    {
        "content": "<p>My current working version has the following TypeScript that repeatedly calls Lean. Since the Lean function does some polling, waiting for various <code>Task</code>s to finish (interspersed with <code>IO.sleep</code>), there is no need to also have a delay on the JavaScript side. The Lean function thas is passed as <code>RefreshPanelProps.next</code> is tagged with <code>@[server_rpc_method]</code>, but for some reason it doesn't work if I tag it <code>@[server_rpc_method_cancellable]</code></p>\n<div class=\"codehilite\" data-code-language=\"TypeScript\"><pre><span></span><code><span class=\"k\">export</span><span class=\"w\"> </span><span class=\"kd\">interface</span><span class=\"w\"> </span><span class=\"nx\">RefreshPanelProps</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">  </span><span class=\"cm\">/** The initial HTML to display */</span>\n<span class=\"w\">  </span><span class=\"nx\">initial</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Html</span>\n<span class=\"w\">  </span><span class=\"cm\">/** The Lean function to call next */</span>\n<span class=\"w\">  </span><span class=\"nx\">next</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Name</span>\n<span class=\"w\">  </span><span class=\"cm\">/** A reference to a Lean object that will be passed to `next` */</span>\n<span class=\"w\">  </span><span class=\"nx\">state</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">RpcPtr</span><span class=\"o\">&lt;</span><span class=\"s1\">''</span><span class=\"o\">&gt;</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">export</span><span class=\"w\"> </span><span class=\"kd\">interface</span><span class=\"w\"> </span><span class=\"nx\">IncrementalResult</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">  </span><span class=\"cm\">/** The new HTML to display */</span>\n<span class=\"w\">  </span><span class=\"nx\">html</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Html</span>\n<span class=\"w\">  </span><span class=\"cm\">/** Wether to try refreshing the HTML again */</span>\n<span class=\"w\">  </span><span class=\"nx\">refresh</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">boolean</span>\n<span class=\"p\">}</span>\n<span class=\"k\">export</span><span class=\"w\"> </span><span class=\"kd\">interface</span><span class=\"w\"> </span><span class=\"nx\">WidgetStateProps</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">  </span><span class=\"cm\">/** A reference to a Lean object that will be passed to `next` */</span>\n<span class=\"w\">  </span><span class=\"nx\">ctx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">RpcPtr</span><span class=\"o\">&lt;</span><span class=\"s1\">''</span><span class=\"o\">&gt;</span>\n<span class=\"p\">}</span>\n<span class=\"k\">export</span><span class=\"w\"> </span><span class=\"k\">default</span><span class=\"w\"> </span><span class=\"kd\">function</span><span class=\"w\"> </span><span class=\"nx\">RefreshPanel</span><span class=\"p\">(</span><span class=\"nx\">props</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">RefreshPanelProps</span><span class=\"p\">)</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"nx\">JSX</span><span class=\"p\">.</span><span class=\"nx\">Element</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">  </span><span class=\"kd\">const</span><span class=\"w\"> </span><span class=\"nx\">rs</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nx\">useRpcSession</span><span class=\"p\">()</span>\n<span class=\"w\">  </span><span class=\"kd\">const</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"nx\">html</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nx\">setHtml</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nx\">React</span><span class=\"p\">.</span><span class=\"nx\">useState</span><span class=\"o\">&lt;</span><span class=\"nx\">Html</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"nx\">props</span><span class=\"p\">.</span><span class=\"nx\">initial</span><span class=\"p\">)</span>\n\n<span class=\"w\">  </span><span class=\"c1\">// Repeatedly call Lean to update</span>\n<span class=\"w\">  </span><span class=\"nx\">React</span><span class=\"p\">.</span><span class=\"nx\">useEffect</span><span class=\"p\">(()</span><span class=\"w\"> </span><span class=\"p\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nx\">cancelled</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kc\">false</span>\n<span class=\"w\">    </span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"kd\">function</span><span class=\"w\"> </span><span class=\"nx\">loop</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">      </span><span class=\"kd\">const</span><span class=\"w\"> </span><span class=\"nx\">result</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">await</span><span class=\"w\"> </span><span class=\"nx\">rs</span><span class=\"p\">.</span><span class=\"nx\">call</span><span class=\"o\">&lt;</span><span class=\"nx\">WidgetStateProps</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nx\">IncrementalResult</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"nx\">props</span><span class=\"p\">.</span><span class=\"nx\">next</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"nx\">ctx</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">props.state</span><span class=\"w\"> </span><span class=\"p\">})</span>\n<span class=\"w\">      </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nx\">cancelled</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">return</span>\n<span class=\"w\">      </span><span class=\"nx\">setHtml</span><span class=\"p\">(</span><span class=\"nx\">result</span><span class=\"p\">.</span><span class=\"nx\">html</span><span class=\"p\">)</span>\n<span class=\"w\">      </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nx\">result</span><span class=\"p\">.</span><span class=\"nx\">refresh</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"nx\">loop</span><span class=\"p\">()</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"w\">    </span><span class=\"nx\">loop</span><span class=\"p\">()</span>\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"nx\">cancelled</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"w\"> </span><span class=\"p\">}</span>\n<span class=\"w\">  </span><span class=\"p\">},</span><span class=\"w\"> </span><span class=\"p\">[])</span>\n<span class=\"w\">  </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"nx\">HtmlDisplay</span><span class=\"w\"> </span><span class=\"nx\">html</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"nx\">html</span><span class=\"p\">}</span><span class=\"o\">/&gt;</span>\n<span class=\"p\">}</span>\n</code></pre></div>",
        "id": 547170747,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1761525340
    },
    {
        "content": "<p>On the Lean side I can maintain a state by storing an <code>IO.Ref</code> in the <code>WidgetStateProps</code></p>",
        "id": 547170904,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1761525500
    },
    {
        "content": "<p>That all makes sense. If you want to make a PR, it would be nice to have a general component that is parameterized over an RPC method with this general signature, perhaps as a new macro like <code>mk_rpc_widget%</code> (maybe we shouldn't tack too much functionality onto <code>mk_rpc_widget%</code>).</p>\n<blockquote>\n<p>for some reason it doesn't work if I tag it <code>@[server_rpc_method_cancellable]</code></p>\n</blockquote>\n<p>Have a look at <code>ProofWidgets.Cancellable</code>. Cancellable RPC methods should be called using <code>callCancellable</code> from <code>widget/src/cancellable.ts</code>. I guess this is not available in the <code>@leanprover-community/proofwidgets4</code> package, so maybe we should expose it. Are you using that package?</p>",
        "id": 547344632,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1761588850
    },
    {
        "content": "<p>I have now implemented it slightly differently. Instead of passing a function (as a string), and a state (as a <code>WithRpcRef</code>) to JavaScript, I now just pass a Lean <code>Task</code> (as a <code>WithRpcRef</code>) to Javascript when I want to reload something. The <code>Task</code> returns <code>Html</code>, and optionally another <code>Task</code>, which can then be called again by JavaScript.</p>\n<p>On the Lean side, this looks like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">RefreshTask</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Task</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Except</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">Error</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Html</span><span class=\"w\"> </span><span class=\"bp\">Ã—</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">RefreshTask</span><span class=\"o\">))</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">TypeName</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">RefreshResult</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">html</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Html</span>\n<span class=\"w\">  </span><span class=\"n\">refresh</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">WithRpcRef</span><span class=\"w\"> </span><span class=\"n\">RefreshTask</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">RpcEncodable</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">server_rpc_method</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">runRefresh</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">task</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">WithRpcRef</span><span class=\"w\"> </span><span class=\"n\">RefreshTask</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RequestM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">RequestTask</span><span class=\"w\"> </span><span class=\"n\">RefreshResult</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">RequestM</span><span class=\"bp\">.</span><span class=\"n\">asTask</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">task</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"bp\">.</span><span class=\"n\">go</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">error</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">throw</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">ofIoError</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">ok</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">html</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">go</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">html</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">refresh</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">â†</span><span class=\"w\"> </span><span class=\"n\">go</span><span class=\"bp\">.</span><span class=\"n\">mapM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">WithRpcRef</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"bp\">Â·</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">RefreshComponentProps</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">initial</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Html</span>\n<span class=\"w\">  </span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Name</span>\n<span class=\"w\">  </span><span class=\"n\">refresh</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">WithRpcRef</span><span class=\"w\"> </span><span class=\"n\">RefreshTask</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">RpcEncodable</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">widget_module</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">RefreshComponent</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Component</span><span class=\"w\"> </span><span class=\"n\">RefreshComponentProps</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">javascript</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n</code></pre></div>\n<p>and on the JavaScript side it looks like this</p>\n<div class=\"codehilite\" data-code-language=\"TypeScript\"><pre><span></span><code><span class=\"k\">export</span><span class=\"w\"> </span><span class=\"kd\">interface</span><span class=\"w\"> </span><span class=\"nx\">RefreshPanelProps</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">  </span><span class=\"cm\">/** The initial HTML to display */</span>\n<span class=\"w\">  </span><span class=\"nx\">initial</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Html</span>\n<span class=\"w\">  </span><span class=\"cm\">/** A Lean task for iteratively refreshing the HTML display */</span>\n<span class=\"w\">  </span><span class=\"nx\">refresh</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">RpcPtr</span><span class=\"o\">&lt;</span><span class=\"s1\">''</span><span class=\"o\">&gt;</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">export</span><span class=\"w\"> </span><span class=\"kd\">interface</span><span class=\"w\"> </span><span class=\"nx\">IncrementalResult</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">  </span><span class=\"cm\">/** The new HTML to display */</span>\n<span class=\"w\">  </span><span class=\"nx\">html</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Html</span>\n<span class=\"w\">  </span><span class=\"nx\">refresh?</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">RpcPtr</span><span class=\"o\">&lt;</span><span class=\"s1\">''</span><span class=\"o\">&gt;</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">export</span><span class=\"w\"> </span><span class=\"k\">default</span><span class=\"w\"> </span><span class=\"kd\">function</span><span class=\"w\"> </span><span class=\"nx\">RefreshPanel</span><span class=\"p\">(</span><span class=\"nx\">props</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">RefreshPanelProps</span><span class=\"p\">)</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"nx\">JSX</span><span class=\"p\">.</span><span class=\"nx\">Element</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">  </span><span class=\"kd\">const</span><span class=\"w\"> </span><span class=\"nx\">rs</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nx\">useRpcSession</span><span class=\"p\">()</span>\n<span class=\"w\">  </span><span class=\"kd\">const</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"nx\">html</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nx\">setHtml</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nx\">React</span><span class=\"p\">.</span><span class=\"nx\">useState</span><span class=\"o\">&lt;</span><span class=\"nx\">Html</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"nx\">props</span><span class=\"p\">.</span><span class=\"nx\">initial</span><span class=\"p\">)</span>\n\n<span class=\"w\">  </span><span class=\"c1\">// Repeatedly call Lean to update</span>\n<span class=\"w\">  </span><span class=\"nx\">React</span><span class=\"p\">.</span><span class=\"nx\">useEffect</span><span class=\"p\">(()</span><span class=\"w\"> </span><span class=\"p\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nx\">cancelled</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kc\">false</span>\n<span class=\"w\">    </span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"kd\">function</span><span class=\"w\"> </span><span class=\"nx\">loop</span><span class=\"p\">(</span><span class=\"nx\">refresh</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">RpcPtr</span><span class=\"o\">&lt;</span><span class=\"s1\">''</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">      </span><span class=\"kd\">const</span><span class=\"w\"> </span><span class=\"nx\">result</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">await</span><span class=\"w\"> </span><span class=\"nx\">rs</span><span class=\"p\">.</span><span class=\"nx\">call</span><span class=\"o\">&lt;</span><span class=\"nx\">RpcPtr</span><span class=\"o\">&lt;</span><span class=\"s1\">''</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nx\">IncrementalResult</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"s2\">\"runRefresh\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nx\">refresh</span><span class=\"p\">)</span>\n<span class=\"w\">      </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nx\">cancelled</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">return</span>\n<span class=\"w\">      </span><span class=\"nx\">setHtml</span><span class=\"p\">(</span><span class=\"nx\">result</span><span class=\"p\">.</span><span class=\"nx\">html</span><span class=\"p\">)</span>\n<span class=\"w\">      </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nx\">result</span><span class=\"p\">.</span><span class=\"nx\">refresh</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"nx\">loop</span><span class=\"p\">(</span><span class=\"nx\">result</span><span class=\"p\">.</span><span class=\"nx\">refresh</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"w\">    </span><span class=\"nx\">loop</span><span class=\"p\">(</span><span class=\"nx\">props</span><span class=\"p\">.</span><span class=\"nx\">refresh</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"nx\">cancelled</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"w\"> </span><span class=\"p\">}</span>\n<span class=\"w\">  </span><span class=\"p\">},</span><span class=\"w\"> </span><span class=\"p\">[])</span>\n<span class=\"w\">  </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"nx\">HtmlDisplay</span><span class=\"w\"> </span><span class=\"nx\">html</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"nx\">html</span><span class=\"p\">}</span><span class=\"o\">/&gt;</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>This approach has the advantage of not forcing the use of a single function and state.</p>\n<p>Additionally, by using <code>Task</code>, we have the benefit that the task can be spawned before stuff is sent over to JavaScript, instead of having to wait for JavaScript to call the Lean function.</p>",
        "id": 547387039,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1761607300
    },
    {
        "content": "<p>That sounds good, too. You can remove <code>RefreshComponentProps.next</code> now, right? I would also make <code>RefreshComponentProps.refresh</code> an <code>Option</code> so that the immediately-ready case is supported. And this is a matter of taste, but you could consider making <code>RefreshTask.go</code> just a <code>Task (Html Ã— Option RefreshTask)</code> for simplicity; you can still have a combinator which transforms <code>Except IO.Error (Html Ã— Option RefreshTask)</code> into this by producing some error message HTML.</p>",
        "id": 547405981,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1761623505
    },
    {
        "content": "<p>That sounds good. Though I don't see the advantage of supporting the immediately ready case, since then you could just return the html directly rather than wrapping it in this component.</p>",
        "id": 547443944,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1761643506
    },
    {
        "content": "<p>I just had simplicity in mind - you could merge <code>RefreshComponentProps</code> and <code>RefreshResult</code> - but it seems fine either way.</p>",
        "id": 547502310,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1761660238
    },
    {
        "content": "<p>Ah yes, it would be nice to merge them. But, I think another feature that would be nice is to allow the <code>RefreshResult</code> to say that the computation is finished, without providing any new html. This would make sense if <code>rw??</code> was still checking some lemmas, but in the end it turned out that none of them were applicable. Then it would be silly to create and send the same Html to JavaScript again.</p>",
        "id": 547525793,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1761665615
    },
    {
        "content": "<p>Another thing to think about would be cancellation, although I don't think it is super important for <code>rw??</code>, because the new version is pretty fast.</p>\n<p>If I used <code>@[server_rpc_method_cancellable]</code> on <code>runRefresh</code>, this would mean that <code>IO.checkCancelled</code> in that task will tell whether the task was cancelled. However, the problem with <code>runRefresh</code> is that that it calls <code>Task.get</code>, which blocks the thread until the <code>Task</code> has evaluated, so it cannot really react to being cancelled. Instead, we should tell the <code>Task</code> directly that it was cancelled, so that it can act accordingly. I haven't looked too closely how <code>ProofWidgets.CancellableTask</code> works, which seems relevant to this.</p>\n<p>The function I pass to <code>mk_rpc_widget%</code> is tagged with <code>@[server_rpc_method_cancellable]</code>, but I'm not so sure that cancelling it (after it has already finished) would also cancel any child <code>Task</code> that it spawned.</p>",
        "id": 547541186,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1761669137
    },
    {
        "content": "<p>I suppose I can just implement a function <code>cancelRefresh</code> which calls <code>IO.cancel</code> on the <code>Task</code>.</p>",
        "id": 547542227,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1761669402
    },
    {
        "content": "<p>If you don't want to rely on implicit task cancellation behaviour (probably a bad thing to rely on), I'd use a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IO.CancelToken#doc\">docs#IO.CancelToken</a>.</p>",
        "id": 547545026,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1761670113
    },
    {
        "content": "<p>Whoa, this looks really cool! :D</p>\n<p>One thing Iâ€™d love to be able to do eventually is show a loading throbber in the spot where new parts of the html are going to appear (e.g. at the bottom of the suggestion list, where the next suggestion will load in).</p>\n<p>Iâ€™ve actually created a couple of React Lean logo throbbers for fun, which I could make public if they could be used like this! :)</p>\n<p>Just curious, would this approach be able to handle that smoothly, without making the throbber start a new animation cycle each time we add a suggestion to the end? Or would that need a second iteration?</p>",
        "id": 547546941,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1761670641
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"128280\">ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’</span> <a href=\"#narrow/channel/113488-general/topic/Widget.20that.20reacts.20to.20Lean/near/547545026\">said</a>:</p>\n<blockquote>\n<p>I'd use a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IO.CancelToken#doc\">docs#IO.CancelToken</a>.</p>\n</blockquote>\n<p>Oh I seen now that e.g. <code>whnf</code> calls <code>checkInterrupted</code> (and not <code>IO.checkCancelled</code>), so it's looking at the <code>IO.CancelToken</code> in the <code>CoreM</code> context. So, I should make a (optional) <code>IO.CancelToken</code>, pass it to Javascript, and put it in my <code>CoreM</code> context wherever I'd like to support cancellation. And then I can have JavaScript, in case of cancellation, call a lean function that sets the cancel token.</p>\n<p>This also has the advantage over <code>IO.cancel</code> that we can cancel all parallel tasks in one go.</p>",
        "id": 547554600,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1761673038
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"548935\">Thomas Murrills</span> <a href=\"#narrow/channel/113488-general/topic/Widget.20that.20reacts.20to.20Lean/near/547546941\">said</a>:</p>\n<blockquote>\n<p>One thing Iâ€™d love to be able to do eventually is show a loading throbber in the spot where new parts of the html are going to appear</p>\n</blockquote>\n<p>Yes, this is one nice advantage of the interactivity. The mathlib version of <code>rw??</code> doesn't tell the user that anything is happening, it keeps saying <code>rw??: Please shift-click an expression.</code>. But the new version will say <code>rw?? is searching for rewrite lemmas...</code> when searching. And we could certainly add a throbber to this <span aria-label=\"smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"smile\">:smile:</span></p>\n<p>I wouldn't worry too much about the throbber starting a new cycle with each reload, because the new results come in very fast, so a user wouldn't be able to keep track of the throbber anyways.</p>\n<p>But, this can be achieved as follows. At the start we make a new <code>let promise : IO.Promise Unit â† IO.Promise.new</code> and make a <code>RefreshComponent</code> for the throbber that starts off as a throbber, and then awaits <code>promise.result?</code>. Then when you finish loading all results in another thread, you call <code>promise.resolve ()</code>, which unblocks the <code>promise.result?</code>, allowing it to return and replace the throbber with an empty <code>Html</code>.</p>",
        "id": 547559109,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1761674586
    },
    {
        "content": "<p>(To be clear, I've never used <code>IO.Promise</code>, but this is what the source code documentation says that it does)</p>",
        "id": 547574634,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1761680095
    },
    {
        "content": "<p>Ah, I think I seeâ€”so the throbber would be its own widget, separate from the updating list, essentially? Or do I have that wrong?</p>",
        "id": 547576506,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1761680823
    },
    {
        "content": "<p>Also, by the way, the results coming in fast is actually the case in which I think it would be most noticeable to restart the throbber each update! <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span> Weâ€™d essentially see a still or slightly jittering image making its way down the page underneath the results.</p>",
        "id": 547576814,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1761680959
    },
    {
        "content": "<p>The throbber would be a separate part of the Html tree. On the Lean side you would construct an Html tree which contains one component that shows the rewrite suggestions, and another component for the throbber, which could come before or after eachother. Both components would be a <code>RefreshComponent</code>.</p>",
        "id": 547577140,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1761681089
    },
    {
        "content": "<p>Well, the results come in so fast that the throbber would be off the page immediately <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 547577229,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1761681123
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/channel/113488-general/topic/Widget.20that.20reacts.20to.20Lean/near/547577229\">said</a>:</p>\n<blockquote>\n<p>Well, the results come in so fast that the throbber would be off the page immediately <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>\n</blockquote>\n<p>Oh, I seeâ€¦ <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span></p>",
        "id": 547577340,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1761681166
    },
    {
        "content": "<p>Maybe the solution for the continuous throbber that I sketched above is overcomplicated, assuming that it is possible to have <code>let</code> statements in an <code>Html</code> tree. Because then you can just put <code>let throbber := ...</code> at the root of the <code>Html</code> tree, and refer to <code>throbber</code> in the <code>RefreshComponent</code>. But I have next to no experience with html, so I don't know.</p>",
        "id": 547613836,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1761701480
    },
    {
        "content": "<p>I implemented the cancellation with <code>IO.CancelToken</code>. It works most of the time, but not always. I tested it with the help of an infinite loop and a <code>dbg_trace</code>.</p>\n<ul>\n<li>If I double click (i.e. click and then un-click) an expression, then the cancel token won't be set. I presume this is because the JavaScript is never run in the first place, and hence it also cannot be cancelled.</li>\n<li>If I click an expression, then reload the lean file (which stops the ongoing infinite loops), and wait for Lean to load again, then the same expression stays selected, so the tactic will run on it again. But if I now unselect that expression, the cancel token won't be set either.</li>\n</ul>",
        "id": 547614437,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1761701961
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/channel/113488-general/topic/Widget.20that.20reacts.20to.20Lean/near/547613836\">said</a>:</p>\n<blockquote>\n<p>Maybe the solution for the continuous throbber that I sketched above is overcomplicated, assuming that it is possible to have <code>let</code> statements in an <code>Html</code> tree. Because then you can just put <code>let throbber := ...</code> at the root of the <code>Html</code> tree, and refer to <code>throbber</code> in the <code>RefreshComponent</code>. But I have next to no experience with html, so I don't know.</p>\n</blockquote>\n<p>If all the in-progress <code>Html</code> objects that you send over to JS include a throbber component, its state will be preserved across renders. This is how React works in general (see <a href=\"https://react.dev/learn/preserving-and-resetting-state\">here</a>). You may have to set a <code>key</code> on the throbber to ensure React identifies it across renders.</p>",
        "id": 547616538,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1761703465
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/channel/113488-general/topic/Widget.20that.20reacts.20to.20Lean/near/547614437\">said</a>:</p>\n<blockquote>\n<p>I implemented the cancellation with <code>IO.CancelToken</code>. It works most of the time, but not always. I tested it with the help of an infinite loop and a <code>dbg_trace</code>.</p>\n<ul>\n<li>If I double click (i.e. click and then un-click) an expression, then the cancel token won't be set. I presume this is because the JavaScript is never run in the first place, and hence it also cannot be cancelled.</li>\n<li>If I click an expression, then reload the lean file (which stops the ongoing infinite loops), and wait for Lean to load again, then the same expression stays selected, so the tactic will run on it again. But if I now unselect that expression, the cancel token won't be set either.</li>\n</ul>\n</blockquote>\n<p>Hard to say what's going on without code.</p>",
        "id": 547616658,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1761703531
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/channel/113488-general/topic/Widget.20that.20reacts.20to.20Lean/near/547614437\">said</a>:</p>\n<blockquote>\n<p>I implemented the cancellation with <code>IO.CancelToken</code>. It works most of the time, but not always.</p>\n</blockquote>\n<p>I managed to fix this on the Lean side by having a global ref of the most recent <code>rw??</code> cancel token. Then each new call to <code>rw??</code> cancels the previous:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">initialize</span><span class=\"w\"> </span><span class=\"n\">currentCancelToken</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">Ref</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">CancelToken</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">â†</span>\n<span class=\"w\">  </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">mkRef</span><span class=\"w\"> </span><span class=\"n\">none</span>\n</code></pre></div>\n<p>At the start of the <code>server_rpc_method</code> in Lean I use</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">cancelTk</span><span class=\"w\"> </span><span class=\"bp\">â†</span><span class=\"w\"> </span><span class=\"n\">currentCancelToken</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"n\">cancelTk</span><span class=\"bp\">.</span><span class=\"n\">set</span>\n</code></pre></div>\n<p>And later</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">currentCancelToken</span><span class=\"bp\">.</span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"n\">cancelTk</span>\n</code></pre></div>",
        "id": 547672235,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1761731821
    },
    {
        "content": "<p>So you're implicitly assuming here that there is only one <code>rw??</code> in the document at any given time yes?</p>",
        "id": 547685544,
        "sender_full_name": "Henrik BÃ¶ving",
        "timestamp": 1761735487
    },
    {
        "content": "<p>To be more precise, I'm assuming there is only one <code>rw??</code> widget running in the infoview at any given time.</p>",
        "id": 547685908,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1761735595
    },
    {
        "content": "<p>Although this is not indended to but used, I've tested having two different <code>rw??</code> widgets in the infoview at the same time, and (after I was careful to use <code>IO.Ref.modifyGet</code> instead of a separate <code>get</code> and <code>set</code>) exactly one of the two widgets gets cancelled. The cancelled one originally said <code>Error refreshing this component:Â internal exception #0</code>, but I've now special cased it to say <code>This component was cancelled</code>.</p>",
        "id": 547837185,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1761786308
    },
    {
        "content": "<p>There is probably a way to refactor this to avoid any global refs by passing the cancel token around through RPC, no?</p>",
        "id": 547837568,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1761786576
    },
    {
        "content": "<p>Yes, I am storing the cancel token in 2 places:</p>\n<ul>\n<li>in a global ref in Lean</li>\n<li>in the RefreshComponent (in a <code>WithRpcRef</code>)</li>\n</ul>\n<p>The problem is that if I double click really fast, then the token passed around through RPC is lost.</p>",
        "id": 547837918,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1761786898
    },
    {
        "content": "<p>I have made the PR now: <a href=\"https://github.com/leanprover-community/ProofWidgets4/pull/141\">ProofWidgets4#141</a></p>\n<p>I tried to document the content as well as possible. I haven't added any tests so far. How does ProofWidgets usually go about testing? Or is the testing done in use cases in e.g. Mathlib?</p>",
        "id": 547994965,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1761845119
    },
    {
        "content": "<p>Adding a trivial demo to <a href=\"https://github.com/leanprover-community/ProofWidgets4/tree/main/ProofWidgets/Demos\">https://github.com/leanprover-community/ProofWidgets4/tree/main/ProofWidgets/Demos</a> is super helpful for me when reverse engineering these to add to lean.nvim.</p>",
        "id": 548011477,
        "sender_full_name": "Julian Berman",
        "timestamp": 1761850193
    },
    {
        "content": "<p>What sort of reverse engineering is this? Are you rewriting the TypeScript to some nvim compatible language?</p>",
        "id": 548045342,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1761864696
    },
    {
        "content": "<p>Correct, generally lean.nvim has to reimplement any widget typescript code in Lua.</p>",
        "id": 548045408,
        "sender_full_name": "Julian Berman",
        "timestamp": 1761864726
    },
    {
        "content": "<p>So it's helpful to see the minimal possible usage of things being added so that I can have a simple example to play with.</p>",
        "id": 548045456,
        "sender_full_name": "Julian Berman",
        "timestamp": 1761864755
    },
    {
        "content": "<p>If you're curious to see what that looks like, the <a href=\"https://github.com/leanprover-community/ProofWidgets4/blob/main/ProofWidgets/Demos/ExprPresentation.lean\">ExprPresentation demo file</a> for example, I literally just load and use as a test case: <a href=\"https://github.com/Julian/lean.nvim/blob/main/spec/widgets/proofwidgets_spec.lua#L31-L57\">https://github.com/Julian/lean.nvim/blob/main/spec/widgets/proofwidgets_spec.lua#L31-L57</a> which gets me my reimplementation here: <a href=\"https://github.com/Julian/lean.nvim/blob/main/lua/proofwidgets/expr_presentation.lua\">https://github.com/Julian/lean.nvim/blob/main/lua/proofwidgets/expr_presentation.lua</a></p>",
        "id": 548045890,
        "sender_full_name": "Julian Berman",
        "timestamp": 1761864997
    },
    {
        "content": "<p>In general it is really useful if as much as possible is done on the Lean side and as little as possible on the JS side.</p>",
        "id": 548047056,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1761865647
    },
    {
        "content": "<p>I have continued to work on this <code>RefreshComponent</code>, and I've now significantly redesigned it. With the previous approach, one would create a new task for each refreshing computation. Instead of that, the computation can now happen on the same thread, and it instead uses <code>IO.Promise</code> to notify the Javascript when an update has happened.</p>\n<p>I've added a test file to the Demos folder with 3 demos that show the <code>RefreshComponent</code> in action.</p>\n<p>(And the code is still in <a href=\"https://github.com/leanprover-community/ProofWidgets4/pull/141\">ProofWidgets4#141</a></p>",
        "id": 553748681,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1762307818
    },
    {
        "content": "<p>An additions that I needed that seems like it doesn't really belong to Proofwidgets is the <code>MonadDrop</code> type class:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/--</span>\n<span class=\"sd\">The class `MonadDrop m n` allows a computation in monad `m` to be run in monad `n`.</span>\n<span class=\"sd\">For example, a `MetaM` computation can be ran in `EIO Exception`,</span>\n<span class=\"sd\">which can then be ran as a task using `EIO.asTask`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">MonadDrop</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- Translates an action from monad `m` into monad `n`. -/</span>\n<span class=\"w\">  </span><span class=\"n\">dropM</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Î±</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"o\">)</span>\n\n<span class=\"kn\">export</span><span class=\"w\"> </span><span class=\"n\">MonadDrop</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">dropM</span><span class=\"o\">)</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MonadDrop</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">]</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MonadDrop</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">dropM</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">pure</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Ï</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MonadDrop</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ReaderT</span><span class=\"w\"> </span><span class=\"n\">Ï</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">dropM</span><span class=\"w\"> </span><span class=\"n\">act</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">dropM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">act</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Ïƒ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MonadDrop</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">StateT</span><span class=\"w\"> </span><span class=\"n\">Ïƒ</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">dropM</span><span class=\"w\"> </span><span class=\"n\">act</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"n\">liftM</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">dropM</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">act</span><span class=\"bp\">.</span><span class=\"n\">run'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">â†</span><span class=\"w\"> </span><span class=\"n\">get</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Ï‰</span><span class=\"w\"> </span><span class=\"n\">Ïƒ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MonadLiftT</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ST</span><span class=\"w\"> </span><span class=\"n\">Ï‰</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MonadDrop</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">StateRefT'</span><span class=\"w\"> </span><span class=\"n\">Ï‰</span><span class=\"w\"> </span><span class=\"n\">Ïƒ</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">dropM</span><span class=\"w\"> </span><span class=\"n\">act</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"n\">liftM</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">dropM</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">act</span><span class=\"bp\">.</span><span class=\"n\">run'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">â†</span><span class=\"w\"> </span><span class=\"n\">get</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 553748982,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1762308015
    },
    {
        "content": "<p>Hmm, can <code>dropM</code> always be given by <code>Functor.map pure</code>, or is it different? (Iâ€™m just looking at the types!)</p>",
        "id": 553749925,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1762308617
    },
    {
        "content": "<p>Yes, it could be given by that, but the purpose of <code>dropM</code> is that the computation is moved to the inner monad, instead of leaving it in the outer monad, as would happen with <code>Functor.map pure</code>.</p>",
        "id": 553750060,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1762308736
    },
    {
        "content": "<p>Oh and I still haven't understood why we need so many words nowadays to import things (i.e. <code>public meta import</code>). In the PR I've just used <code>import</code> so far.</p>",
        "id": 553750609,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1762309250
    },
    {
        "content": "<p>Ah, okay, I see! Makes sense. :)</p>",
        "id": 553752150,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1762310343
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/channel/113488-general/topic/Widget.20that.20reacts.20to.20Lean/near/553750609\">said</a>:</p>\n<blockquote>\n<p>Oh and I still haven't understood why we need so many words nowadays to import things (i.e. <code>public meta import</code>). In the PR I've just used <code>import</code> so far.</p>\n</blockquote>\n<p>Thereâ€™s some <a href=\"https://lean-lang.org/doc/reference/latest/The-Module-System/#module-system\">relatively new documentation</a> in the reference manual if you havenâ€™t seen it yet, by the way; pointing it out because I was unaware of it until it was pointed out to me. <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 553754507,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1762311709
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"128280\">@ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’</span>, when do you think you could review the code?</p>",
        "id": 554326572,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1762523380
    },
    {
        "content": "<p>The above PR <a href=\"https://github.com/leanprover-community/ProofWidgets4/pull/141\">ProofWidgets4#141</a> (which defines <code>RefreshComponent</code>, for making widgets that react to Lean) seems to have gotten a bit stuck, so I'll explain the problem here.</p>\n<p>There are two modes in which <code>RefreshComponent</code> can be used: </p>\n<ol>\n<li>Interactive mode, where it restarts every time you shift-click something in the goal. For example <code>rw??</code>.</li>\n<li>Passive mode, where it is simply called by a tactic/command. For example <code>hint</code> or <code>try?</code>.</li>\n</ol>\n<p>My main use case is (1), but unfortunately there is a subtle problem in (2) related to cancellation. In particular in the <code>countToTen</code> demo that I made. In that demo, the command <code>#html countToTen</code> gives a widget that counts up to 10 in 10 seconds. If you write the command a few times in a row</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">html</span><span class=\"w\"> </span><span class=\"n\">countToTen</span>\n<span class=\"bp\">#</span><span class=\"n\">html</span><span class=\"w\"> </span><span class=\"n\">countToTen</span>\n<span class=\"bp\">#</span><span class=\"n\">html</span><span class=\"w\"> </span><span class=\"n\">countToTen</span>\n<span class=\"bp\">#</span><span class=\"n\">html</span><span class=\"w\"> </span><span class=\"n\">countToTen</span>\n</code></pre></div>\n<p>And comment out the one on line <code>n</code>, then the ones on line <code>n - 1</code> and lines <code>â‰¥ n + 1</code> will restart countin from 0. The ones on lines <code>â‰¤ n - 3</code> will continue counting to 10 how they were. But the command on line <code>n - 2</code> will get cancelled if it hasn't finished yet.</p>\n<p>I don't know how Lean decides which <code>IO.CancelToken</code> to set here, but this may be possible to solve. Another way to fix this would be to have each tactic/command only finish elaboration when the widget has finished updating. I think this could be a nice feature, especially for <code>try?</code>/<code>hint</code>, but I do not know any straighforward way of implementing this (because the function has to return in order to load the widget in the first place).</p>\n<p>In any case, I think that the PR doesn't need to be blocked by this small problem.</p>",
        "id": 566854629,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1767837955
    }
]