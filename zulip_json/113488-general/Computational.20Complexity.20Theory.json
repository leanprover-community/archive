[
    {
        "content": "<p>Is there a method for writing proofs about computational complexity in lean? I have not been able to find anything of the sort but I am also not very sure where to look.</p>",
        "id": 264319554,
        "sender_full_name": "Parker Bjur",
        "timestamp": 1639064750
    },
    {
        "content": "<p>There is an apparently convenient way to do so in Coq through the λ calculus: <a href=\"https://drops.dagstuhl.de/opus/frontdoor.php?source_opus=13915\">https://drops.dagstuhl.de/opus/frontdoor.php?source_opus=13915</a></p>",
        "id": 264320056,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1639064947
    },
    {
        "content": "<p>See also these previous threads:</p>\n<ul>\n<li><a href=\"#narrow/stream/116395-maths/topic/complexity.20theory\">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/complexity.20theory</a></li>\n<li><a href=\"#narrow/stream/113488-general/topic/Ph.2ED.2E.20on.20formalizing.20complexity.20classes\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Ph.2ED.2E.20on.20formalizing.20complexity.20classes</a></li>\n<li><a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Complexity.20theory\">https://leanprover.zulipchat.com/#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Complexity.20theory</a></li>\n<li><a href=\"#narrow/stream/113489-new-members/topic/Computability.2C.20P.20.28and.20NP.29\">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/Computability.2C.20P.20.28and.20NP.29</a></li>\n</ul>",
        "id": 264320394,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1639065073
    },
    {
        "content": "<p>Thank You!</p>",
        "id": 264321904,
        "sender_full_name": "Parker Bjur",
        "timestamp": 1639065660
    },
    {
        "content": "<p>This is a long shot but ... is anyone working on any complexity theory in Lean?</p>",
        "id": 265910621,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1640261250
    },
    {
        "content": "<p>How difficult would it be to transcribe the Fabian Kunze et al's library from Coq to Lean? Any rough estimate anyone?<br>\n<a href=\"https://github.com/uds-psl/cook-levin\">https://github.com/uds-psl/cook-levin</a></p>",
        "id": 266004248,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1640354812
    },
    {
        "content": "<p>I don't see a good reason to actually transcribe it, those proofs don't look easy to follow. Probably you should just use the theorems as inspiration</p>",
        "id": 266025566,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640382181
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/266025566\">said</a>:</p>\n<blockquote>\n<p>I don't see a good reason to actually transcribe it, those proofs don't look easy to follow. Probably you should just use the theorems as inspiration</p>\n</blockquote>\n<p>Thank you for an answer!</p>\n<p>On which level would you recommend me to get inspired by it? Should I break down the problem to equivalent lemmata one-to-one?</p>",
        "id": 266026173,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1640383155
    },
    {
        "content": "<p>I've been working on a PR for the mu-recursive definition of computability. It seems like <a href=\"https://github.com/uds-psl/cook-levin\">https://github.com/uds-psl/cook-levin</a> and <a href=\"https://arxiv.org/pdf/1102.5495.pdf\">https://arxiv.org/pdf/1102.5495.pdf</a> both use definitions that have a similar approach to the model of computation. Perhaps after this PR is made, we can build up from there in terms of defining the time complexity of various algorithms.</p>",
        "id": 266031639,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1640390337
    },
    {
        "content": "<p>Ok, the PR is <a href=\"https://github.com/leanprover-community/mathlib/pull/11046\">#11046</a>. <span class=\"user-mention\" data-user-id=\"417654\">@Martin Dvořák</span> , if you or anyone else wants to contribute, feel free to push to this branch. It feels like someone comes along every few months looking for a complexity library and not finding one. Maybe the issue is that we just need to get started, and once people see there's something to build off of, it'll grow from there.</p>",
        "id": 266032132,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1640390903
    },
    {
        "content": "<p>That's exactly what happened with graph theory BTW. Consider making your own stream!</p>",
        "id": 266032352,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1640391257
    },
    {
        "content": "<p>Great initiative!</p>",
        "id": 266054882,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1640431060
    },
    {
        "content": "<p>It seems to me that I don't have permission to create new streams. Will any admin or moderator help me?</p>",
        "id": 266056104,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1640433202
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"282271\">Bolton Bailey</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/266031639\">said</a>:</p>\n<blockquote>\n<p>I've been working on a PR for the mu-recursive definition of computability. It seems like <a href=\"https://github.com/uds-psl/cook-levin\">https://github.com/uds-psl/cook-levin</a> and <a href=\"https://arxiv.org/pdf/1102.5495.pdf\">https://arxiv.org/pdf/1102.5495.pdf</a> both use definitions that have a similar approach to the model of computation. Perhaps after this PR is made, we can build up from there in terms of defining the time complexity of various algorithms.</p>\n</blockquote>\n<p>How big is the time overhead of partial recursive functions over Turing Machines? And over RAM, is it known?</p>",
        "id": 266056534,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1640433791
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"282271\">Bolton Bailey</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/266032132\">said</a>:</p>\n<blockquote>\n<p>Ok, the PR is <a href=\"https://github.com/leanprover-community/mathlib/pull/11046\">#11046</a>. <span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> , if you or anyone else wants to contribute, feel free to push to this branch. It feels like someone comes along every few months looking for a complexity library and not finding one. Maybe the issue is that we just need to get started, and once people see there's something to build off of, it'll grow from there.</p>\n</blockquote>\n<p>Idea if more than 1 person wants to contribute: open PRs to that branch instead of committing and pushing directly to it (as if it were a master branch)</p>",
        "id": 266064466,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1640447307
    },
    {
        "content": "<p>Would someone more knowledgeable mind laying down a roadmap on this subject? I am having a hard time understanding the structure of the Coq repo</p>",
        "id": 266080256,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1640474366
    },
    {
        "content": "<p>I can sketch some preliminary roadmap but somebody more knowledgeable will have to check and correct after me. Would it be for thee, knowledgeable person, easier this way?</p>",
        "id": 266081232,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1640476222
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"417654\">@Martin Dvořák</span> I'd say go for it :D. It's a brand new branch so np</p>",
        "id": 266081273,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1640476323
    },
    {
        "content": "<p>My rough sketch of the roadmap towards complexity theory in Lean is the following. We will follow the approach of Kunze et al.<br>\nPaper: <a href=\"https://drops.dagstuhl.de/opus/volltexte/2021/13915/pdf/LIPIcs-ITP-2021-20.pdf\">https://drops.dagstuhl.de/opus/volltexte/2021/13915/pdf/LIPIcs-ITP-2021-20.pdf</a><br>\nCode (Coq): <a href=\"https://github.com/uds-psl/coq-library-complexity\">https://github.com/uds-psl/coq-library-complexity</a><br>\nPlease note that we won't use the letter L for the name of the complexity class (deterministic logarithmic time).</p>\n<p>(1) Define the notion of a decision problem in the weak call-by-value λ-calculus L.<br>\n(2) Define the class P in L.<br>\n(3) Define the class NP in L.<br>\n(4) Define polytime reductions in L.<br>\n(5) Prove that, if A polytime reduces to B in P, then A in P.<br>\n(6) Define the classes NP-hard and NP-complete in L.<br>\n(7) Define a natural NP-complete problem in L.<br>\n(8) Prove that, if NP-hard A polytime reduces to B, then B is NP-hard.<br>\n(9) Define the Abstract heap machines and Turing machines — just that we can state the auxiliary decision problems about them; we will not program in them; the reductions will be always programmed in L.<br>\n(10) State and prove the polytime reductions (very challenging).<br>\n(11) State your favourite version of the tiling problem.<br>\n(12) Prove the NP-hardness of the tiling problem using the tools above (the vanilla TM will have to be reduced to it).<br>\n(13) Reduce your tiling problem to some form of SAT.<br>\n(14) We can continue building the complexity theory from here on without getting our hands dirty with the intricacies of various computational models.</p>",
        "id": 266114221,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1640532555
    },
    {
        "content": "<p>Turing machines already exist in the file <code>computability.turing_machine</code>.</p>",
        "id": 266114722,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1640533337
    },
    {
        "content": "<p>I sent an e-mail to Fabian Kunze requesting his help.</p>",
        "id": 266114950,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1640533779
    },
    {
        "content": "<p>I don't understand why ye are grinning. I did my best I could do with my very superficial understanding of Kunze et al's approach.</p>",
        "id": 266115210,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1640534216
    },
    {
        "content": "<p>I am aware of not providing much of a hint regarding the implementation.</p>",
        "id": 266115220,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1640534266
    },
    {
        "content": "<p>It looks like an impressive and ambitious plan of work. I don’t know enough to make suggestions, but I’m very pleased to see that someone’s taking this on.</p>",
        "id": 266115718,
        "sender_full_name": "Stuart Presnell",
        "timestamp": 1640534952
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/266115210\">said</a>:</p>\n<blockquote>\n<p>I don't understand why ye are grinning.</p>\n</blockquote>\n<p>Sorry, I didn't mean it in a mocking way. I was just happy that you actually did it <span aria-label=\"smiley\" class=\"emoji emoji-1f603\" role=\"img\" title=\"smiley\">:smiley:</span><br>\nZulip's mobile app doesn't have the \"on hover\" functionality that shows the actual emoji \"word\"</p>",
        "id": 266116466,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1640536063
    },
    {
        "content": "<p>I disagree with the idea of requiring everything to be done in L. Not only is that not the computational model we have chosen for the existing computability material, it is also overly restrictive; users should be able to use any computational basis they want that is relevantly equivalent to turing machines or RAM model or whatever is the best computational basis for complexity theory. Currently, <code>computability.turing_machine</code> contains 3 different computational bases that are all equivalent (although the framework for making use of the equivalences for application to complexity classes like P does not exist yet), and users should be able to write e.g. polynomial time TM2 programs. The language L is also polytime equivalent to TM0 so you should be able to write programs in L if you want to, but I would want to allow as much freedom in this area as possible.</p>",
        "id": 266129313,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640555446
    },
    {
        "content": "<p>Perhaps Fagin's equivalence of NP and sentences in existential 2nd order logic is something that  should be more prominent. (In this vein, polynomial-time solvability becomes definability in the 1st order logic).</p>",
        "id": 266132817,
        "sender_full_name": "Dima Pasechnik",
        "timestamp": 1640560792
    },
    {
        "content": "<blockquote>\n<p>I disagree with the idea of requiring everything to be done in L.</p>\n</blockquote>\n<p>A big advantage of L is that is much more ergonomic to use, since Lean quite directly maps to L and most features are directly supported (higher-order functions, partial applications, etc.) with pretty much the runtime and space complexity you'd expect.  You can directly compute the runtime of List.filter as defined in Lean.  It is also straightforward to show that concrete Lean definitions are computable in L; this is a lot more exhausting in the current computability library (particularly with recursive functions, or n-ary functions with n&gt;=3).  I don't even want to imagine a formalization using turing machines.</p>\n<blockquote>\n<p>users should be able to use any computational basis they want that is relevantly equivalent to turing machines</p>\n</blockquote>\n<p>L is one such model, I'm not sure I see your point.</p>",
        "id": 266163148,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1640601892
    },
    {
        "content": "<p>Well, the work on TMs is not get complete as far as connecting them to the primrec model. I would like to see a library closer to what we have for proving primrec, which does cover higher order stuff like list.filter.</p>",
        "id": 266163363,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640602147
    },
    {
        "content": "<p>The underlying computational model is somewhat orthogonal to this, you can build a higher order notion of time complexity on any model</p>",
        "id": 266163390,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640602191
    },
    {
        "content": "<p>From what I can tell of the complete implementation of L used to derive time bounds, it's not all that different from what you get from constructions like TM_to_partrec. It still has a pretty concrete operational model with an explicit evaluation context, so it's not as compositional as pure lambda calculus. The differences don't seem big enough to make it worth introducing yet another computational model and connecting it to the other models</p>",
        "id": 266163649,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640602454
    },
    {
        "content": "<p>I realize that you've put a lot of effort into this development, but I don't think it's a good direction.  The <code>primrec</code>/... stuff is really unergonomic to work with, e.g. for <code>list.filter</code> you need several lemmas showing that list.filter is primrec/computable/partrec if the predicate is primrec/computable/partrec.  If we wanted to tackle time complexity, I feel like we'd end up with another computational model and set of theorems anyhow.</p>",
        "id": 266163852,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1640602614
    },
    {
        "content": "<p>I do think we can borrow some ideas from Kunze et al for the \"frontend\" part of this, like h.o. time complexity</p>",
        "id": 266164178,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640602883
    },
    {
        "content": "<p><code>primrec</code> is limited to first order functions on naturals, which is why there is the proliferation of theorems. With <code>nat.partrec.code</code> it becomes more practical to express that a higher order function is \"nice\" once and for all by proving that it is h.o. equivalent to a single <code>code</code>. This option is not available in <code>primrec</code> itself because it is still bootstrapping</p>",
        "id": 266164306,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640603016
    },
    {
        "content": "<p>In other words, I think we have the tools we need to simulate everything you would do with a computational model like L (in particular all the typeclasses and such that are necessary for an ergonomic library) without actually changing the basis</p>",
        "id": 266164415,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640603122
    },
    {
        "content": "<p>I think we need to do some design work on that frontend though; I don't think transliterating the coq code precisely will actually work all that well in lean, we will need to make some modifications but it's going in the right direction</p>",
        "id": 266164522,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640603235
    },
    {
        "content": "<blockquote>\n<p>It still has a pretty concrete operational model with an explicit evaluation context, so it's not as compositional as pure lambda calculus.</p>\n</blockquote>\n<p>Yes, proving that the time complexity of <code>f t</code> is the runtime of <code>t</code> + runtime of <code>f</code> on the resulting value is the same in either formalism.  What you get with L is in my eyes the following:</p>\n<ol>\n<li>You get a single theorem for computability (namely, a definition of a lambda term that compute the function for all values).  Properties like complexity, termination, etc. are then theorems about this lambda term.  This also works for higher-order function without any friction.  (To be fair, we could also do this with partial recursive functions and maybe turing machines---but I'm not sure if there's a canonical turing machine that suffices for complexity analysis).</li>\n<li>It's obvious how to represent data in L.  <code>List.take 10 xs</code> has <code>O(10)</code> runtime, no matter what the type of the elements in <code>xs</code> is.  Depending on how lists / function arguments / return values are represented in a Turing machine, this might entail copying the elements, the whole list, etc. (Though we could also solve that with other computational models, like random-access machines.)</li>\n</ol>",
        "id": 266164668,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1640603374
    },
    {
        "content": "<blockquote>\n<p>I think we need to do some design work on that frontend though; I don't think transliterating the coq code precisely will actually work all that well in lean, we will need to make some modifications but it's going in the right direction</p>\n</blockquote>\n<p>Completely agreed on that.  Transliterating is certainly the wrong way.  But I think their ideas are good and sound, and deserve to be used as inspiration.</p>",
        "id": 266164765,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1640603450
    },
    {
        "content": "<p>I think there is value in having a more complex intermediate language than L for the sake of having nice primitive operations with crafted time bounds. For example, throwing in the natural numbers with arithmetic operations on simply typed lambda calculus</p>",
        "id": 266165175,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640603891
    },
    {
        "content": "<blockquote>\n<p>In other words, I think we have the tools we need to simulate everything you would do with a computational model like L (in particular all the typeclasses and such that are necessary for an ergonomic library) without actually changing the basis</p>\n</blockquote>\n<p>I think it's clear that we could make a nicer frontend for showing computability, that just seems like an engineering problem.  The part that I don't see is how such a frontend would scale to showing time or space complexity.  Maybe you have already this figured out though.</p>",
        "id": 266165188,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1640603906
    },
    {
        "content": "<p>Certainly it is nice to be able to say that <code>list.take 10 xs</code> has time <code>O(10)</code>. It would be even better if it takes exactly 10 steps (and lots of other basic functions like it also have exactly the right number of steps)</p>",
        "id": 266165220,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640603978
    },
    {
        "content": "<p>we probably won't be able to get that for everything, but a big haskell-ish language would make it easier to do the \"writing concrete programs\" part, which I expect to be much more important / time consuming than any work needed to set up the model and prove it is polynomially simulated by a TM or partial recursive function.</p>",
        "id": 266165300,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640604097
    },
    {
        "content": "<blockquote>\n<p>For example, throwing in the natural numbers with arithmetic operations on simply typed lambda calculus</p>\n</blockquote>\n<p>Practically speaking, this won't make any difference at all for any common NP problems because all natural numbers will be bounded by a very low bound.  Even the most basic implementation will be fast enough there.  We just need to replace <code>Nat</code> by <code>Num</code> (which is straightforward in the L approach).</p>",
        "id": 266165418,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1640604226
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110043\">Gabriel Ebner</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/266165188\">said</a>:</p>\n<blockquote>\n<p>I think it's clear that we could make a nicer frontend for showing computability, that just seems like an engineering problem.  The part that I don't see is how such a frontend would scale to showing time or space complexity.  Maybe you have already this figured out though.</p>\n</blockquote>\n<p>I've been thinking mostly about time complexity here. I would borrow Kunze's work for this part. Regarding space complexity, I haven't thought much about it, and we might need a RAM model to get all the results that complexity theorists expect here</p>",
        "id": 266165494,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640604278
    },
    {
        "content": "<blockquote>\n<p>Certainly it is nice to be able to say that <code>list.take 10 xs</code> has time <code>O(10)</code>. It would be even better if it takes exactly 10 steps (and lots of other basic functions like it also have exactly the right number of steps)</p>\n</blockquote>\n<p>It won't take exactly 10 steps in any model of computation (for a non-specialized take implementation), because decrementing natural numbers has some non-constant runtime.</p>",
        "id": 266165532,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1640604330
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110043\">Gabriel Ebner</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/266165418\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>For example, throwing in the natural numbers with arithmetic operations on simply typed lambda calculus</p>\n</blockquote>\n<p>Practically speaking, this won't make any difference at all for any common NP problems because all natural numbers will be bounded by a very low bound.  Even the most basic implementation will be fast enough there.  We just need to replace <code>Nat</code> by <code>Num</code> (which is straightforward in the L approach).</p>\n</blockquote>\n<p>Yes, but that's not the point. The idea behind the haskell-ish intermediate language is to calibrate the time bounds to be exactly some nice numbers. For example, to set the cost of <code>m * n</code> to <code>m.size * n.size + 1</code> or whatever we can get away with (and not have to introspect further on how these operations work)</p>",
        "id": 266165642,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640604448
    },
    {
        "content": "<p>The actual replacement of <code>Num</code> for <code>Nat</code> will happen in the once-and-for-all proof that this IL is polytime simulated by a TM</p>",
        "id": 266165710,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640604493
    },
    {
        "content": "<blockquote>\n<p>but a big haskell-ish language would make it easier to do the \"writing concrete programs\" part</p>\n</blockquote>\n<p>The whole idea about the L approach (and I believe what they do / want to do in Coq) is that this can be almost fully automated, since the host language maps so closely to the object language.  You write a function in pure idiomatic Lean, and then <code>deriving instance Computable for List.filter</code> and you have a realizing lambda term + theorems for the runtime of the cons and the nil case.</p>",
        "id": 266165723,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1640604534
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110043\">Gabriel Ebner</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/266165532\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>Certainly it is nice to be able to say that <code>list.take 10 xs</code> has time <code>O(10)</code>. It would be even better if it takes exactly 10 steps (and lots of other basic functions like it also have exactly the right number of steps)</p>\n</blockquote>\n<p>It won't take exactly 10 steps in any model of computation (for a non-specialized take implementation), because decrementing natural numbers has some non-constant runtime.</p>\n</blockquote>\n<p>This depends on how tight we need the simulation to be. If we can afford a log factor in the simulation then we can make decrementing numbers O(1)</p>",
        "id": 266165867,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640604699
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/266165642\">said</a>:</p>\n<blockquote>\n<p>Yes, but that's not the point. The idea behind the haskell-ish intermediate language is to calibrate the time bounds to be exactly some nice numbers. For example, to set the cost of <code>m * n</code> to <code>m.size + n.size + 1</code> or whatever we can get away with (and not have to introspect further on how these operations work)</p>\n</blockquote>\n<p>That would be a wonderful breakthough.  I believe the best known multiplication algorithms are O(n log n).</p>",
        "id": 266165963,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1640604784
    },
    {
        "content": "<p>Generally I think the focus on precise numbers is a distraction here.  Even in the best case there's going to be lots of annoying +1s and -1s that nobody cares about.  The runtime should be stated as a big-O, which is I think very much the standard in complexity theory.  Just imagine you'd have to account for all the index computations in a sorting algorithm...</p>",
        "id": 266166191,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1640605067
    },
    {
        "content": "<p>Sure, we can't build in everything so that's inevitable</p>",
        "id": 266166266,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640605098
    },
    {
        "content": "<p>Right, and if it's inevitable we might as well accept it and use big-O everywhere.</p>",
        "id": 266166306,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1640605146
    },
    {
        "content": "<p>but unfortunately I think that in practice we won't be able to use big-O nearly as much as the books would have you believe</p>",
        "id": 266166314,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640605161
    },
    {
        "content": "<p>lots of proofs require that you fix the big-O constant after the fact in some way that is not easily explained by any concrete definition of big-O</p>",
        "id": 266166384,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640605221
    },
    {
        "content": "<p>Seriously, the biggest issue with L in my eyes is with subpolynomial complexity.  I mean sure, you can prove that an algorithm has O(n log n) runtime <em>in L</em>, but I'm not sure how convincing that result is to somebody else.  Then there's the question of what LOGSPACE is in L.</p>",
        "id": 266166419,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1640605297
    },
    {
        "content": "<p>Right. I think that for the question of what computational basis to use for our definitions, we should be looking at the tightest complexity classes, because those can sometimes distinguish the bases</p>",
        "id": 266166485,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640605370
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/266166384\">said</a>:</p>\n<blockquote>\n<p>lots of proofs require that you fix the big-O constant after the fact in some way that is not easily explained by any concrete definition of big-O</p>\n</blockquote>\n<p>Do you have any concrete examples?</p>",
        "id": 266166486,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1640605373
    },
    {
        "content": "<p>You generally need the existential constant to lie outside all variables, including parameters to the algorithm. This is generally very cumbersome to write, and it is easy to leave out a variable and then get stuck when you try to use the function recursively in a proof much later</p>",
        "id": 266166619,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640605537
    },
    {
        "content": "<p>I see what you mean (in a paper I would always interpret big-O to quantify over everything unless specified otherwise), but I don't think it means big-O is problematic.  It just means we always need to quantify over all arguments, i.e. <code>is_O (fun (m,n) =&gt; runtime (m + n)) (fun (m,n) =&gt; (m+n) * (m+n).log)</code>, which is indeed a bit verbose (but fixable).</p>",
        "id": 266167180,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1640606216
    },
    {
        "content": "<p>Here's a more concrete example. Suppose we have a function like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Nat</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span> <span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"bp\">;</span> <span class=\"n\">g</span> <span class=\"n\">n</span><span class=\"bp\">;</span> <span class=\"n\">foo</span> <span class=\"n\">n</span>\n</code></pre></div>\n<p>Let's suppose that <code>f n</code> is <code>O(n)</code> and <code>g n</code> is <code>O(n^2)</code>.If we wanted to keep big-O everywhere, we might want to argue like so:</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>time(f n) is O(n)\ntime(g n) is O(n^2)\ntime(foo n) is O(n^3)\ntime(f n; g n; foo n) is O(n + n^2 + n^3) = O(n^3)\n</code></pre></div>\n<p>but of course this doesn't work because of the recursion. So we have to introduce an explicit constant:</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>time(f n) is O(n)\ntime(g n) is O(n^2)\ntime(foo n) &lt;= c n^3\ntime(f n; g n; foo n) is O(n + n^2 + c n^3) &lt;= c (n+1)^3\n</code></pre></div>\n<p>but this also doesn't work because that last step isn't valid. The correct way to prove this is:</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>time(f n) is O(n)\ntime(g n) is O(n^2)\ntime(f n) + time(g n) is O(n^2)\nSuppose time(f n) + time(g n) &lt;= d n^2\nPick c := d + 1 (or something)\nProve by induction: time(foo n) &lt;= c n^3\n\ntime(f n; g n; foo n) =\ntime(f n) + time(g n) + time(foo n) &lt;=\nd n^2 + (d+1) n^3 &lt;= (d+1) (n+1)^3\n</code></pre></div>\n<p>The big-O is really not helping here; if we just had explicit constants for everything, for example if we knew <code>time(f n) &lt;= 4 n</code> and <code>time(g n) &lt;= 37 n^2</code> then this proof would be a lot simpler.</p>",
        "id": 266167537,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640606557
    },
    {
        "content": "<p>Plus, you never know when a more precise bound might come in handy</p>",
        "id": 266167706,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640606740
    },
    {
        "content": "<p>The whole business about L seems to be geared towards various questions related to complexity of various λ-calculi. For the classical complexity theory this seems to be more of a sidetrack (which however might have technical benefits).</p>",
        "id": 266167799,
        "sender_full_name": "Dima Pasechnik",
        "timestamp": 1640606829
    },
    {
        "content": "<p>I really don't want to prove anything about church rosser here, that seems like entirely a sidetrack if the goal is P and NP</p>",
        "id": 266167880,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640606891
    },
    {
        "content": "<p>(To be fair, you don't need to take such a sidetrack if formalizing L; but it does seem likely to come up if you start thinking about compositionality in the lambda calculus)</p>",
        "id": 266167911,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640606957
    },
    {
        "content": "<blockquote>\n<p>if we just had explicit constants for everything</p>\n</blockquote>\n<p>Luckily, we can eliminate the big-O again if we need to fall back to explicit constants.  (Just like we can fall back to ε-δ-proofs if more general methods fail.)</p>",
        "id": 266168088,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1640607123
    },
    {
        "content": "<p>Isn't the problem we see with big O here due to the true nature of big O being asymptotic? One needs to argue that O(n^k)&lt;O(n^{k+1}) as n-&gt;oo.</p>\n<p>(OK in sense of proving something is in P).</p>",
        "id": 266168128,
        "sender_full_name": "Dima Pasechnik",
        "timestamp": 1640607177
    },
    {
        "content": "<p>One sweeps these explicit constants into exponents, that's OK is only done fixed number to times.</p>",
        "id": 266168166,
        "sender_full_name": "Dima Pasechnik",
        "timestamp": 1640607238
    },
    {
        "content": "<blockquote>\n<p>Isn't the problem we see with big O here due to the true nature of big O being asymptotic?</p>\n</blockquote>\n<p>This doesn't make any real difference.  If <code>f n = O(g n)</code> as <code>n → ∞</code>, then there exists a <code>c</code> such that <code>f n ≤ c * (g n + 1)</code> and vice versa. (assuming f,g≥0)</p>",
        "id": 266168318,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1640607383
    },
    {
        "content": "<p>I think it would be okay to have theorems of the form <code>\\exists N, \\all n &gt;= N, time(f n) &lt;= 37 n</code>, where we fix the <code>c</code> but not <code>N</code></p>",
        "id": 266168359,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640607463
    },
    {
        "content": "<p>since I don't think that <code>N</code> interferes with recursive proofs as much as <code>c</code> does</p>",
        "id": 266168402,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640607503
    },
    {
        "content": "<p>That's logically equivalent to a big-O so I'm not opposed.  But it's a bit unfortunate if we can't reuse the <code>is_O</code> definition.</p>",
        "id": 266168417,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1640607531
    },
    {
        "content": "<p>is it? big-O requires a multiplicative constant</p>",
        "id": 266168434,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640607560
    },
    {
        "content": "<p>or do you mean something like <code>time(f n) - 37 n in O(1)</code></p>",
        "id": 266168462,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640607598
    },
    {
        "content": "<p>We can still have <code>is_O</code>-stated theorems for \"presentation\" purposes (and who knows, maybe they will be usable in some proofs) but for the really hard time complexity theorems I will expect us to skip those and go straight for the ones with algebraically more complicated but logically simpler bounds</p>",
        "id": 266168568,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640607704
    },
    {
        "content": "<blockquote>\n<p>The whole business about L seems to be geared towards various questions related to complexity of various λ-calculi.</p>\n</blockquote>\n<p>No, that's certainly not the intention.  The idea behind L is that it is much closer to a functional language (like Lean) in syntax and operational semantics, so you don't have to do as much encoding as with Turing machines.  Like Mario is saying, a lot of basic operations (like applying a function or reading the first element of a list, etc.) take exactly one step in L, but can take several or even many steps in a Turing machine because of copying, skipping, etc.</p>",
        "id": 266168569,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1640607704
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/266168568\">said</a>:</p>\n<blockquote>\n<p>We can still have <code>is_O</code>-stated theorems for \"presentation\" purposes (and who knows, maybe they will be usable in some proofs) but for the really hard time complexity theorems I will expect us to skip those and go straight for the ones with algebraically more complicated but logically simpler bounds</p>\n</blockquote>\n<p>I'm not sure I understand you.  Are you saying that <code>37</code> is better than <code>c</code>, because presumably <code>norm_num</code> can simplify it?  While I recognize the pain, I feel like the solution here should be better automation, and not theorems with hard-coded bounds.</p>",
        "id": 266168758,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1640607861
    },
    {
        "content": "<p>Not (just) because norm_num can work with it, but also because we don't need to deal with existential elimination and the resulting scoping. It's a lot easier to automate such a proof if everything is in the empty context</p>",
        "id": 266168809,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640607934
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/266168434\">said</a>:</p>\n<blockquote>\n<p>is it? big-O requires a multiplicative constant</p>\n</blockquote>\n<p>Yes, but for the purposes of proving something in P, one can replace a constant by a sufficiently slowly growing function, e.g. <code>n</code>, or <code>log n</code>.</p>",
        "id": 266168896,
        "sender_full_name": "Dima Pasechnik",
        "timestamp": 1640608019
    },
    {
        "content": "<p>So <code>Σ' c, time (f n) ≤ c * n^2</code> would be ok then?  (No elimination, no scope.)  If you allow classical logic, you can also avoid the existential elimination with an epsilon.</p>",
        "id": 266168910,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1640608031
    },
    {
        "content": "<p>I think that still suffers from the scoping over parameters problem. The normal way to write that would imply that <code>c</code> can depend on anything in scope, whereas if it is an explicit <code>37</code> then you know it doesn't. I think lean might still be able to work with it if it can unfold the value to <code>37</code>, but it can still possibly trigger scoping issues if it is not reduced</p>",
        "id": 266169075,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640608221
    },
    {
        "content": "<p>Another way to hide the argument is to have <code>time_f_constant := 37</code> and then <code>time (f n) ≤ time_f_constant * n^2</code>, where you can control the parameters needed in <code>time_f_constant</code></p>",
        "id": 266169104,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640608308
    },
    {
        "content": "<p>Maybe I'm naive, but is this so much easier than <code>rcases time_f_spec with ⟨time_f_constant, N, time_f_le⟩</code> at the beginning of the proof?</p>",
        "id": 266169247,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1640608451
    },
    {
        "content": "<p>I guess I'm talking about completely eliminating big-O, in the sense that O(n)&lt;n^2 as n-&gt;oo, etc. This works for showing something in P.</p>",
        "id": 266169293,
        "sender_full_name": "Dima Pasechnik",
        "timestamp": 1640608516
    },
    {
        "content": "<p>For showing things are in P, I think you can avoid constants altogether and instead use closure properties for most things</p>",
        "id": 266169362,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640608593
    },
    {
        "content": "<p>The big-O stuff only comes up for tighter bounds like sorting in O(n log n)</p>",
        "id": 266169378,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640608621
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> Maybe. I haven't worked it all out, so consider me moderately dubious but willing to try things and see what sticks</p>",
        "id": 266169485,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640608714
    },
    {
        "content": "<p>This is a subject I'm very interested in and I will try to follow the discussions as hard as I can.</p>\n<p>Can we have a separate stream <code>complexity theory</code> for it? It's getting more and more laborious to backtrack every discussion made about this topic. Different topics are spread over different streams and mixed/smashed into same threads.</p>\n<p>Sorry for my ignorance, but what's the core idea for computing time and space complexity formally? The proofs that I've done/seen all my entire life about these were extremely informal, like counting loops inside loops and making some logical connection with the input size.</p>",
        "id": 266173538,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1640612754
    },
    {
        "content": "<p>Streams are usually made to divert attention away from a subject which isn't interesting to most people. Simply cut that thread into smaller ones if you feel like you can't follow the conversation.</p>",
        "id": 266173637,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1640612880
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"316505\">Dima Pasechnik</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/266132817\">said</a>:</p>\n<blockquote>\n<p>Perhaps Fagin's equivalence of NP and sentences in existential 2nd order logic is something that  should be more prominent. (In this vein, polynomial-time solvability becomes definability in the 1st order logic).</p>\n</blockquote>\n<p>As a definition? Or an additional theorem about our classes?</p>",
        "id": 266191969,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1640627885
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"451983\">Arthur Paulino</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/266173538\">said</a>:</p>\n<blockquote>\n<p>Sorry for my ignorance, but what's the core idea for computing time and space complexity formally? The proofs that I've done/seen all my entire life about these were extremely informal, like counting loops inside loops and making some logical connection with the input size.</p>\n</blockquote>\n<p>The basic idea is pretty simple: count all the basic steps evaluated by a program. You can very often get exact formulas for this, like <code>2 n^2 + 3 x - 7</code>; formally this is often an easier task than doing big-O analysis, although it can start to help once the formulas get too complicated. Once the tools to state such theorems are in place, the proofs are pretty trivial, it usually amounts to proofs like <code>\\sum i &lt; n, 1 + 2 + (3 i - 1) = O(n^2)</code>.</p>",
        "id": 266226072,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640660063
    },
    {
        "content": "<p>For space complexity, I'm not sure what the best setting is. Probably we want a computational model with a finite memory like an FSM (but with parametric memory size <code>k</code> possibly depending on the input <code>n</code>, instead of <code>O(1)</code>), and then a space complexity bound talks about whether such a limited model is capable of computing the desired function.</p>",
        "id": 266226182,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640660237
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/266191969\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"316505\">Dima Pasechnik</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/266132817\">said</a>:</p>\n<blockquote>\n<p>Perhaps Fagin's equivalence of NP and sentences in existential 2nd order logic is something that  should be more prominent. (In this vein, polynomial-time solvability becomes definability in the 1st order logic).</p>\n</blockquote>\n<p>As a definition? Or an additional theorem about our classes?</p>\n</blockquote>\n<p>either way would be useful - IMHO it's a very convenient way to think about the class NP, as it does not invoke weird stuff such as nondeterministic Turing machines.</p>",
        "id": 266339123,
        "sender_full_name": "Dima Pasechnik",
        "timestamp": 1640778898
    },
    {
        "content": "<p>What is the \"natural\" NP-complete problem in this formalism?</p>",
        "id": 266340713,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1640780338
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/266340713\">said</a>:</p>\n<blockquote>\n<p>What is the \"natural\" NP-complete problem in this formalism?</p>\n</blockquote>\n<p>the usual, e.g. SAT. For instance, see <a href=\"https://hal.archives-ouvertes.fr/hal-00017602/document\">https://hal.archives-ouvertes.fr/hal-00017602/document</a></p>",
        "id": 266341709,
        "sender_full_name": "Dima Pasechnik",
        "timestamp": 1640781375
    },
    {
        "content": "<p>this brings up the question of a \"natural reduction\" - in the classical theory, Karp vs Turing reductions. Here we have \"1st order reductions\", as well.</p>",
        "id": 266341917,
        "sender_full_name": "Dima Pasechnik",
        "timestamp": 1640781576
    },
    {
        "content": "<p>I will be free to start working on that after my Qualifying Exam on 2022-01-25. However, I'd need a lot of guidance in order to succeed in this task.</p>",
        "id": 266416089,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1640857706
    },
    {
        "content": "<p>I am super curious to see how it would be built up in Lean <span aria-label=\"eyes\" class=\"emoji emoji-1f440\" role=\"img\" title=\"eyes\">:eyes:</span></p>",
        "id": 266506605,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1640961356
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/266114221\">said</a>:</p>\n<blockquote>\n<p>(1) Define the notion of a decision problem in the weak call-by-value λ-calculus L.<br>\n(2) Define the class P in L.<br>\n(3) Define the class NP in L.<br>\n(4) Define polytime reductions in L.<br>\n(5) Prove that, if A polytime reduces to B in P, then A in P.<br>\n(6) Define the classes NP-hard and NP-complete in L.<br>\n(7) Define a natural NP-complete problem in L.<br>\n(8) Prove that, if NP-hard A polytime reduces to B, then B is NP-hard.<br>\n(9) Define the Abstract heap machines and Turing machines — just that we can state the auxiliary decision problems about them; we will not program in them; the reductions will be always programmed in L.<br>\n(10) State and prove the polytime reductions (very challenging).<br>\n(11) State your favourite version of the tiling problem.<br>\n(12) Prove the NP-hardness of the tiling problem using the tools above (the vanilla TM will have to be reduced to it).<br>\n(13) Reduce your tiling problem to some form of SAT.<br>\n(14) We can continue building the complexity theory from here on without getting our hands dirty with the intricacies of various computational models.</p>\n</blockquote>\n<p>Hi, I'm one out the authors of the Cook-Levin mechanisation in Coq.</p>\n<p>I think you are missing (or at last not explicitly acknowledging) the part that an 'time-invariant' simulation of L in terms of Turing machines is needed (if the model of computations is to be choosen L): As NP-complete talks more or less about simulating all poly-time verifiers  with a single problem, one needs to transform the L-algorithms into TMs, i.e. implement the abstract heap machine as TM. (Or is that the part (10)?)<br>\nThis part is quite hard: We developed an framework to verify Turing machines (See our <a href=\"https://www.ps.uni-saarland.de/Publications/details/ForsterEtAl:2019:VerifiedTMs.html\">publication with Wuttke</a>).</p>",
        "id": 266794676,
        "sender_full_name": "Fabian Kunze",
        "timestamp": 1641294123
    },
    {
        "content": "<p>On a more general note:</p>\n<p>Our experience there is also why we think that explicitly constructing TMs (or other low-level models of computation, like mu-recursive functions) just does not scale: There is so much overhead, like\"how do I encode different types of data? (lists, terms, programms...)\", or \"How to verify simple composition of functions and other straightforward, non-recursive (or \"non-loop-containing\") programs without to much effort?\" and of course \"How can I verify loops/recursion\"?<br>\nMaybe, with a lot of engineering work, one can come up with a scaling verification framework, but our conclusion is that functional programming is such a sweet-spot in ITPs that one would waste time not using a functional language whenever possible.</p>\n<p>It might be very much possible to support sublinear space in a lambda calculus, for example by introducing oracles for the input. No matter the model of computation, it seems that sublinear space will make it a lot more tedious to have composability of programs, as one can not use the same space measure for a program \"on top level\" and \"a program called as a subroutine of another program\".</p>",
        "id": 266794692,
        "sender_full_name": "Fabian Kunze",
        "timestamp": 1641294127
    },
    {
        "content": "<p>My judgement is that 1,2,3,4,6,7,9 are trivial.<br>\n5 and 8 are very easy once one has a basic understanding on how to compose programs.</p>\n<p>Proving that (7) is indeed NP-complete of course needs an universal L-program that runs in poly-time, for instance implementing the heap machine in L. With a good verification framework for the model of computation (in this case, L), this is not very hard, but without a good framework, this is very, very tedious, and maybe even unfeasible.</p>\n<p>(I commented on 10 above, if that is the L-to-TM-reduction, i.e. the implementation of an L-interpreter as a TM. It took us a very talented student with an excellent bachelors thesis on this topic to come up with a verification framework for TMs, and after his thesis, it still was the work of over 100 hours of work to implement and verify the TMs needed for this step. )</p>\n<p>11 and 12 were also tackled in a bachelor thesis with another extraordinary student, and needed a lot of proof Engineering to solve the many, many cases that can occur when simulating a computation with a tiling problem. </p>\n<p>13 again is trivial, assuming one can write and verify basic programs in the model of computation (of course, as always, assuming one also can verify running times).</p>",
        "id": 266796135,
        "sender_full_name": "Fabian Kunze",
        "timestamp": 1641295008
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"468318\">@Fabian Kunze</span> I'm curious whether by \"TM\" you mean in the strict sense defined by turing, or a more type-level programming friendly version. I think that while TMs construed literally are not good for verification, it is possible to get a more abstract model with user-chosen state spaces to do TM proofs without as much pain. I think that it is possible to get these looking something like WHILE programs or finite state machines with O(1) programs in between, which seems like a good balance between the native logic part used to write the programs, and the explicit step representation you need to do time and space bounds (within a constant factor).</p>",
        "id": 266796165,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1641295042
    },
    {
        "content": "<p>Yes, we abstract away the TM behind while-program like \"combinators\" that construct TMs in the background:<br>\n\"The Turing machine verification framework allows giving algorithms in the style of a<br>\nregister-based while-language, and a corresponding machine is automatically constructed<br>\nbehind the scenes. Separate correctness and verification proofs are then inclusion proofs<br>\nbetween the automatically derived and the user-given relations for the constructed machine\"</p>\n<p>But there still is the problem that the \"registers\" contain asingle tape/strings, and that one might want to change the alphabet when composing machines/</p>",
        "id": 266796407,
        "sender_full_name": "Fabian Kunze",
        "timestamp": 1641295233
    },
    {
        "content": "<p>As an example of what can be done with such a framework, see the program <a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/computability/tm_to_partrec.lean#L837-L887\"><code>tm_to_partrec</code></a> and surrounding section. That one is implemented in a multi-stack machine, but if you have ideas for a more abstract model that still supports some nice operations I'm all ears</p>",
        "id": 266796454,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1641295293
    },
    {
        "content": "<p>You <em>can</em> change the alphabet when composing machines</p>",
        "id": 266796468,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1641295313
    },
    {
        "content": "<p>Ah. I think, based on your description, that one difference between our formalisms is that the mathlib one actually changes the model of computation rather than using combinators over the original model (and there are general theorems about reduction from one model to another)</p>",
        "id": 266796621,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1641295424
    },
    {
        "content": "<p>Yes, we change the alphabet, it is all possible, and we are quite happy with our final, hoare-like verification framework that hides most, or even all of those details.</p>",
        "id": 266796630,
        "sender_full_name": "Fabian Kunze",
        "timestamp": 1641295430
    },
    {
        "content": "<p>Yes, we do only have a shallow representation of the while language, not a deep one. One aspect was that this allows to add new data typ[es (lists of other things, for example) on the fly, as long as one person wrote the \"basic\" combinators to interact with that new data.</p>",
        "id": 266796746,
        "sender_full_name": "Fabian Kunze",
        "timestamp": 1641295500
    },
    {
        "content": "<p>Partrec seems to be very close to L in my eyes by the way, and I have no doubt that this approach can work.</p>",
        "id": 266796861,
        "sender_full_name": "Fabian Kunze",
        "timestamp": 1641295578
    },
    {
        "content": "<p>That's my impression as well. I think that <code>tm_to_partrec</code> automaton is a rough equivalent of your L-to-TM reduction</p>",
        "id": 266796904,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1641295630
    },
    {
        "content": "<p>Is the theoretical problem of coming up with a time measure for partrec-functions that is invariant w.r.t. turing machines solved?</p>",
        "id": 266796938,
        "sender_full_name": "Fabian Kunze",
        "timestamp": 1641295676
    },
    {
        "content": "<p>what do you mean by invariant?</p>",
        "id": 266796990,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1641295694
    },
    {
        "content": "<p>that the TM and part rec function simulate wach other with just polynomial overhead</p>",
        "id": 266797012,
        "sender_full_name": "Fabian Kunze",
        "timestamp": 1641295714
    },
    {
        "content": "<p>probably, count all mu-rec-loop-executions, is it?</p>",
        "id": 266797031,
        "sender_full_name": "Fabian Kunze",
        "timestamp": 1641295725
    },
    {
        "content": "<p>As long as you can accept a O(n) slowdown (e.g. anything P or larger) then you can do the simulation</p>",
        "id": 266797044,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1641295734
    },
    {
        "content": "<p>the slowdown of implementing mu-rec programs in TMs is only linear?</p>",
        "id": 266797086,
        "sender_full_name": "Fabian Kunze",
        "timestamp": 1641295784
    },
    {
        "content": "<p>sorry, other way arround]</p>",
        "id": 266797103,
        "sender_full_name": "Fabian Kunze",
        "timestamp": 1641295799
    },
    {
        "content": "<p>We don't have the actual time bounds proved yet, but the current setup should have O(1) from TM0 to TM1, O(n) slowdown for TM2 from TM1, and O(log n) slowdown for partrec from TM2</p>",
        "id": 266797149,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1641295811
    },
    {
        "content": "<p>TM2 is multi-stack machines</p>",
        "id": 266797165,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1641295827
    },
    {
        "content": "<p>Ah, nice.</p>",
        "id": 266797191,
        "sender_full_name": "Fabian Kunze",
        "timestamp": 1641295850
    },
    {
        "content": "<p>Well, to be precise the last step is not partrec, it is <a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/computability/tm_to_partrec.lean#L68-L114\">this model</a> which is proven equivalent to the partrec model but has a more explicit cost model</p>",
        "id": 266797392,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1641295987
    },
    {
        "content": "<p>partrec itself is mostly only focused on computability in the abstract, some of those algorithms are really bad (like double exponential) if run literally</p>",
        "id": 266797448,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1641296041
    },
    {
        "content": "<p>but that's why <a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/computability/partrec.lean#L149-L159\">partrec</a> is defined as a Prop with no computational content, you shouldn't be extracting an actual algorithm from it</p>",
        "id": 266797570,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1641296115
    },
    {
        "content": "<p>The TM2 model looks interesting. Is there documentation/intuition on what kind of types are allowed as elements on the stacks, and what kind of \"elementary\" operations are permitted?</p>",
        "id": 266797586,
        "sender_full_name": "Fabian Kunze",
        "timestamp": 1641296131
    },
    {
        "content": "<p>The stack element can be any finite type</p>",
        "id": 266797598,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1641296146
    },
    {
        "content": "<p>The elementary operations are basic operations on stacks <a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/computability/turing_machine.lean#L1765-L1790\">here</a></p>",
        "id": 266797707,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1641296206
    },
    {
        "content": "<p>and sigma is a finite type, i assume?</p>",
        "id": 266797741,
        "sender_full_name": "Fabian Kunze",
        "timestamp": 1641296240
    },
    {
        "content": "<p>yes, that's the \"local state\"</p>",
        "id": 266797762,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1641296253
    },
    {
        "content": "<p>in the simulation using basic TMs the basic states are pairs of a local state value and a label</p>",
        "id": 266797892,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1641296338
    },
    {
        "content": "<p>Very nice abstractions, in hindsight, more transformations when going from single-tape to multi-tape TMs would have made our life simpler.</p>",
        "id": 266797901,
        "sender_full_name": "Fabian Kunze",
        "timestamp": 1641296345
    },
    {
        "content": "<p>One of the things I like a lot about the TM models is that the type <code>Λ</code> of \"labels\" (aka TM states) is <em>not</em> required to be finite, but rather finitely supported (only a finite number of labels are reachable from any given label). That means that label types can be simple infinite inductive types like <a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/computability/tm_to_partrec.lean#L761-L769\">this one</a>, and we prove separately that for any starting point of interest there is a finite set of reachable states from it. In that example, we have a single label space covering all partrec programs, and finiteness is guaranteed by the fact that you only visit programs corresponding to subterms of the original program</p>",
        "id": 266798473,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1641296821
    },
    {
        "content": "<p>We are quite happy with the fact that in our hoare-style framework, we only need one lemma for each total TM, following the execution once, to get all properties of the tm we need (and the lemmas for the Hoare rules handle the well-formatted-conditions in the background.)</p>",
        "id": 267042801,
        "sender_full_name": "Fabian Kunze",
        "timestamp": 1641463054
    },
    {
        "content": "<p>what properties are those? Functional correctness and a time bound? Do you have an example?</p>",
        "id": 267045017,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1641464512
    },
    {
        "content": "<p>Yes, the specification of functional correctness and the running time. Well-formedness is already \"baked in\" into the type of turing machines, for instance that the alphabet is finite etc.</p>",
        "id": 267603681,
        "sender_full_name": "Fabian Kunze",
        "timestamp": 1641917273
    },
    {
        "content": "<p>Is anybody going to work on the implementation in foreseeable future?</p>",
        "id": 268176724,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1642328277
    },
    {
        "content": "<p>I am going to continue working on it in <a href=\"https://github.com/leanprover-community/mathlib/pull/11046\">#11046</a>. Notwithstanding all the discussion here, I'm just going to start by trying to finish a function <code>time</code> with the same type as <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.partrec.code.eval\">docs#nat.partrec.code.eval</a>, I'm not sure how long this will take me, but it seems like the best combination of achievability and forward progress to me.</p>",
        "id": 268204371,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1642363982
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/266226072\">said</a>:</p>\n<blockquote>\n<p>The basic idea is pretty simple: count all the basic steps evaluated by a program. You can very often get exact formulas for this, like <code>2 n^2 + 3 x - 7</code>; formally this is often an easier task than doing big-O analysis, although it can start to help once the formulas get too complicated. Once the tools to state such theorems are in place, the proofs are pretty trivial, it usually amounts to proofs like <code>\\sum i &lt; n, 1 + 2 + (3 i - 1) = O(n^2)</code>.</p>\n</blockquote>\n<p>What if you have, say, <code>f(a, b) = a + b</code>, would you say that this function is <code>O(a)</code> (or <code>O(b)</code> depending on how addition is defined) or <code>O(1)</code>?</p>",
        "id": 268338141,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1642475469
    },
    {
        "content": "<p>It depends on whether that is a primitive operation or not. If it is primitive, then it is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>. For a lot of purposes it might be reasonable to take it as such; the Word RAM model of computation allows addition to be <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>, although the addends must be <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>w</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(w)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mclose\">)</span></span></span></span> bits where w, the \"word size\", is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Ω</mi><mo stretchy=\"false\">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\Omega(\\log n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">Ω</span><span class=\"mopen\">(</span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></p>",
        "id": 268339480,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642477128
    },
    {
        "content": "<p>If addition is not primitive, then I would expect <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>log</mi><mo>⁡</mo><mi>a</mi><mo>+</mo><mi>log</mi><mo>⁡</mo><mi>b</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(\\log a + \\log b)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span></span></span></span></p>",
        "id": 268339507,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642477173
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/268339480\">said</a>:</p>\n<blockquote>\n<p>It depends on whether that is a primitive operation or not. If it is primitive, then it is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>. For a lot of purposes it might be reasonable to take it as such; the Word RAM model of computation allows addition to be <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>, although the addends must be <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>w</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(w)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mclose\">)</span></span></span></span> bits where w, the \"word size\", is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Ω</mi><mo stretchy=\"false\">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\Omega(\\log n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">Ω</span><span class=\"mopen\">(</span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></p>\n</blockquote>\n<p>Why Omega?</p>",
        "id": 268748415,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1642708603
    },
    {
        "content": "<p>Could this Isabelle/HOL project be used as inspiration for us?<br>\n<a href=\"https://github.com/wimmers/poly-reductions\">https://github.com/wimmers/poly-reductions</a></p>\n<p>I don't know whether I understand what they did. They have the polytime reductions. Unfortunately, they don't have any problem proved to be NP-complete yet. Nevertheless, it is a part of their plan and their framework should be capable of that. Am I right?</p>",
        "id": 268752385,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1642710428
    },
    {
        "content": "<p>I think it's usually stated as an inequality <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>≤</mo><msup><mn>2</mn><mi>w</mi></msup></mrow><annotation encoding=\"application/x-tex\">n\\le 2^w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6644em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02691em;\">w</span></span></span></span></span></span></span></span></span></span></span>, the asymptotics of it don't matter so much. It's a hypothesis, but a fairly reasonable one for word RAM: it's saying that the entire problem fits in the address space of the machine</p>",
        "id": 268756914,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642712449
    },
    {
        "content": "<p>For a regular computer, this is saying that 64-bit machines can work on problems of size at most 2^64</p>",
        "id": 268756985,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642712483
    },
    {
        "content": "<p>For asymptotic complexity results, this is convenient because it means that as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> grows so does <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span>, so you can do larger operations in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></p>",
        "id": 268757163,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642712561
    },
    {
        "content": "<p>But can we choose word size to be much higher than Omega(log n) to reduce the time complexity in some cases?</p>",
        "id": 268757179,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1642712566
    },
    {
        "content": "<p>Yes, but the complexity bounds are stated as a function of both <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span> in this case</p>",
        "id": 268757274,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642712615
    },
    {
        "content": "<p>Oh!</p>",
        "id": 268757316,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1642712635
    },
    {
        "content": "<p>For a really intense application of word RAM capabilities check out <a href=\"https://en.wikipedia.org/wiki/Fusion_tree\">fusion trees</a></p>",
        "id": 268757324,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642712640
    },
    {
        "content": "<p>After thinking about the partial recursive implementation more, I'm not sure this approach actually works. If we are working over the naturals and the only primitive operation for mutating a natural is the successor function, it seems like there's no way for addition to be O(log n), since to construct <code>a + b</code> from <code>a</code> and <code>b</code>, you have to apply the successor at least <code>(b - a)</code> times. It also seems like you can't represent a natural in binary, since if you fix the number of registers you need for a natural at k, you can represent at most <code>t ^ k</code> numbers in <code>O(t)</code> time. I may need to rethink the approach.</p>",
        "id": 268758422,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1642713134
    },
    {
        "content": "<p>Basic question, possibly very stupid:</p>\n<p>What is the difference between the partially-recursive functions and the call-by-value lambda-calculus, please?</p>",
        "id": 268759113,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1642713445
    },
    {
        "content": "<p>That's a good question. I was a bit confused when <span class=\"user-mention\" data-user-id=\"468318\">@Fabian Kunze</span> said that mu-recursive functions wouldn't scale, after saying that the call-by-value lambda calculus was what he and his co-authors used, since I would have said that those models of computation are similar, or at least that it wouldn't be too hard to prove slowdown lemmas about one with respect to the other. Perhaps he or someone else can elaborate on the differences, or if this is indeed difficult?</p>",
        "id": 268759971,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1642713823
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"282271\">@Bolton Bailey</span> This is why you probably shouldn't define <code>time</code> based on the partrec evaluation rules. It's only intended for defining computability, not complexity, and there are several reductions involved that are exponential or double exponential</p>",
        "id": 268760906,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642714228
    },
    {
        "content": "<p>Any of the TM-based computation models should all be polynomially equivalent: <code>TM0</code>, <code>TM1</code>, <code>TM2</code>. You can also probably code binary in the <a href=\"https://leanprover-community.github.io/mathlib_docs/find/turing.to_partrec.code\">docs#turing.to_partrec.code</a> model, but the built in nats in that model are unary</p>",
        "id": 268761501,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642714465
    },
    {
        "content": "<p>It occurs to me that if only the naturals were represented in binary and I could do an O(1) doubling or halving operation on them, I would have stacks and one could use multiple stacks to implement a Turing machine, so I imagine time in this model of computation would be within a polynomial factor of the usual definition.</p>",
        "id": 268761503,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1642714466
    },
    {
        "content": "<p>Take a look at <a href=\"https://leanprover-community.github.io/mathlib_docs/computability/tm_to_partrec.html#simulating-sequentialized-partial-recursive-functions-in-tm2\">https://leanprover-community.github.io/mathlib_docs/computability/tm_to_partrec.html#simulating-sequentialized-partial-recursive-functions-in-tm2</a>, that's exactly what it does</p>",
        "id": 268761708,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642714561
    },
    {
        "content": "<p>There are computational models similar to primitive recursive functions which compute functions in P, you have to switch out the <code>prec</code> constructor with \"recursion on notation\" aka <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.binary_rec\">docs#nat.binary_rec</a></p>",
        "id": 268762107,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642714731
    },
    {
        "content": "<p>Regarding the observation with \"not enough space to madd numbers\":<br>\nThat exactly is the complication, function composition does not behave like before, where one cold just concatenate the resource consumption functions.</p>\n<p>For TMs, one approach is to have input (and output) tapes, on which one can only read (or write and move one step to the right). I have not looked into it that deep, but as far as I understood,  you can arrange things such that one can compose \"online\" algorithms, for instance one can think of addition as a function that traverses two binary representations and, on the fly,. returns the stream of bits of the sum. If the function called on that result directly \"consumes\" the output (or, more explicitly, pauses and resumes the computation of the bits as needed), one can add numbers inside an log(n) algorithm.</p>\n<p>Another approach (which I think is more common) is to represent numbers not as numbers, but as algorithms that, given an index i, return the i-the bit of the number. This allows to represent numbers of size up to n in log(n) space (But only a constant amount of them, because the code has to exists in the program itself). As long as one is only interested in space, this very inefficient representation does work.</p>\n<p>But this inability of writing down intermediate results explicitly makes formalizations of space really complicated.</p>",
        "id": 268804964,
        "sender_full_name": "Fabian Kunze",
        "timestamp": 1642750703
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"282271\">Bolton Bailey</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/268759971\">said</a>:</p>\n<blockquote>\n<p>That's a good question. I was a bit confused when <span class=\"user-mention silent\" data-user-id=\"468318\">Fabian Kunze</span> said that mu-recursive functions wouldn't scale, after saying that the call-by-value lambda calculus was what he and his co-authors used,</p>\n</blockquote>\n<p>I'm sorry, I was inconsitent: when I said \"[I have no doubts that] partrec [] can work\", this was meant as a retraction of my previous statement that I was sceptical using murec for time-complexity. I used those two names, partrec and murec, interchangeably, as they mean the same.</p>\n<p>The one complication I see is that without an abstraction layer for encodings (gödel-numbers?), the statements and programs get a bit messy when programming an universal machine. With the lambda calculus, we more or less get any Algebraic data type \"for free\" using Scott encodings (wich are similar to church encodings, but vor cbv-languages).</p>",
        "id": 268805372,
        "sender_full_name": "Fabian Kunze",
        "timestamp": 1642751130
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/266165642\">said</a>:</p>\n<blockquote>\n<p>The idea behind the haskell-ish intermediate language</p>\n</blockquote>\n<p>Do you have any more concrete thoughts how a haskell-ish intermediate language might look Mario?</p>",
        "id": 268861857,
        "sender_full_name": "Yannick Forster",
        "timestamp": 1642780589
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/266797149\">said</a>:</p>\n<blockquote>\n<p>We don't have the actual time bounds proved yet, but the current setup should have O(1) from TM0 to TM1, O(n) slowdown for TM2 from TM1, and O(log n) slowdown for partrec from TM2</p>\n</blockquote>\n<p>Do you see a chance to find a good notion of space complexity for <code>partrec</code>?</p>",
        "id": 268862026,
        "sender_full_name": "Yannick Forster",
        "timestamp": 1642780660
    },
    {
        "content": "<p>I think the most natural thing would be to use a computational model which is similar in structure to <code>partrec</code> but uses binary strings as the basic data type instead of <code>nat</code></p>",
        "id": 268898755,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642796783
    },
    {
        "content": "<p>Ok, thanks Fabian for responding, I guess I'll start thinking about a binary-string <code>partrec</code>.</p>",
        "id": 268906109,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1642800788
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"444411\">Yannick Forster</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/268862026\">said</a>:</p>\n<blockquote>\n<p>Do you see a chance to find a good notion of space complexity for <code>partrec</code>?</p>\n</blockquote>\n<p>I think that space-complexity for <code>partrec</code> can look very similar to time-complexity for <code>partrec</code> in structure. Instead of <code>time (comp f g) = time f + time g</code> we have something like <code>space (comp f g) = max (space f) (space g)</code> (with appropriate inputs to <code>f</code> and <code>g</code>).</p>",
        "id": 268906443,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1642800979
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"468318\">Fabian Kunze</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/268804964\">said</a>:</p>\n<blockquote>\n<p>For TMs, one approach is to have input (and output) tapes, on which one can only read (or write and move one step to the right).</p>\n</blockquote>\n<p>Would the TM always have a constant amount of tapes?</p>",
        "id": 268911193,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1642803644
    },
    {
        "content": "<p>Would the number of tapes be baked into the TM type?</p>",
        "id": 268912072,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1642804144
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/268898755\">said</a>:</p>\n<blockquote>\n<p>I think the most natural thing would be to use a computational model which is similar in structure to <code>partrec</code> but uses binary strings as the basic data type instead of <code>nat</code></p>\n</blockquote>\n<p>What makes <code>partrec</code> tedious in my opinion is that you don't have a lambda, so all programs are combinatorial and passing around input is not as easy as in functional programming languages. But, of course, with a lambda you buy into the harder simulation proof. And why restrict to binary strings? Intuitively I'd rather argue for binary trees (like in the computability book by Jones. On top of that I would imagine that one can build an even more expressive simply typed language with natural numbers, lists, options and trees (which is immediately reduced to the simpler case with just one base type)</p>",
        "id": 268960216,
        "sender_full_name": "Yannick Forster",
        "timestamp": 1642861481
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"282271\">Bolton Bailey</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/268906443\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"444411\">Yannick Forster</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/268862026\">said</a>:</p>\n<blockquote>\n<p>Do you see a chance to find a good notion of space complexity for <code>partrec</code>?</p>\n</blockquote>\n<p>I think that space-complexity for <code>partrec</code> can look very similar to time-complexity for <code>partrec</code> in structure. Instead of <code>time (comp f g) = time f + time g</code> we have something like <code>space (comp f g) = max (space f) (space g)</code> (with appropriate inputs to <code>f</code> and <code>g</code>).</p>\n</blockquote>\n<p>It's not obvious to me that this works. (But of course it would be great if it would!) To implement on a Turing machine, you'd probably need some kind of environment implemented with pointers, and pointers can grow linear-logarithmically instead of just linearly. At least, that's what happens with lambda calculus and why for e.g. the full lambda calculus space complexity is still an open problem. For RAM machines, defining space is also way more subtle  than one might think (that was the content of the first paper by Slot and van Emde Boas, where they came up with the conjecture that all reasonable models of computation can simulate each other with polynomial overhead in time and constanct-factor (i.e. linear) overhead in space</p>",
        "id": 268960371,
        "sender_full_name": "Yannick Forster",
        "timestamp": 1642861714
    },
    {
        "content": "<p>Hey <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> , I'm noticing that the definition of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/turing.to_partrec.code.eval\">docs#turing.to_partrec.code.eval</a> for <code>code.fix</code> could be changed to<br>\n<code>| (code.fix f) := pfun.fix $ λ v, pure (if v.head = 0 then sum.inl v.tail else sum.inr v.tail)</code><br>\nWhich is shorter than what is there currently. I believe this essentially changes it from a \"while\" to a \"do-while\" semantics. I think this doesn't change the model too much and might be cleaner in the long run (if I can fix what breaks in this file). Is there a reason I'm missing for it to be defined the way we have it?</p>",
        "id": 270335764,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1643778935
    },
    {
        "content": "<p>you don't use <code>f</code> in that snippet?</p>",
        "id": 270335855,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643779031
    },
    {
        "content": "<p>Uhh, oops, you're right, just a sec</p>",
        "id": 270335878,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1643779079
    },
    {
        "content": "<p>I think this is what I meant:<br>\n<code>| (code.fix f) := pfun.fix $ λ v, if v.head = 0 then pure (sum.inl v.tail) else ((f.eval v.tail).map sum.inr) </code></p>",
        "id": 270336176,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1643779322
    },
    {
        "content": "<p>I guess it doesn't end up that much shorter</p>",
        "id": 270336426,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1643779539
    },
    {
        "content": "<p>I think we should establish some regular Zoom meetings on formalizing complexity theory in Lean.<br>\nMany of us are interested in having such a library, but it will require a lot of collaboration which seems that we haven't started yet.</p>",
        "id": 318138491,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1672164473
    },
    {
        "content": "<p>I suggest we start in the 3rd week of 2023. Indicate your time preferences please:<br>\n<a href=\"https://doodle.com/meeting/participate/id/ep84nEQe\">https://doodle.com/meeting/participate/id/ep84nEQe</a></p>",
        "id": 318236300,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1672226471
    },
    {
        "content": "<p>Also note that graph algorithms are of interest to me, if you happen to need one at some point.</p>",
        "id": 318241892,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1672228763
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/318236300\">said</a>:</p>\n<blockquote>\n<p>I suggest we start in the 3rd week of 2023. Indicate your time preferences please:<br>\n<a href=\"https://doodle.com/meeting/participate/id/ep84nEQe\">https://doodle.com/meeting/participate/id/ep84nEQe</a></p>\n</blockquote>\n<p>I signed up but mostly because this has been a topic of interest for me for a while, not necessarily because I'm actually competent enough to contribute something from a purley mathematical POV so if my vote ends up being a deal breaker just ignore me.</p>",
        "id": 318250885,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1672232217
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/318250885\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/318236300\">said</a>:</p>\n<blockquote>\n<p>I suggest we start in the 3rd week of 2023. Indicate your time preferences please:<br>\n<a href=\"https://doodle.com/meeting/participate/id/ep84nEQe\">https://doodle.com/meeting/participate/id/ep84nEQe</a></p>\n</blockquote>\n<p>I signed up but mostly because this has been a topic of interest for me for a while, not necessarily because I'm actually competent enough to contribute something from a purley mathematical POV so if my vote ends up being a deal breaker just ignore me.</p>\n</blockquote>\n<p>Complexity theory is broad enough as a subject that it is unlikely that  everyone knows all the relevant math beforehand, beyond the basic stuff.</p>",
        "id": 318277684,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1672242011
    },
    {
        "content": "<p>My knowledge ends at \"There is P and NP and there is a couple of fun reductions to SAT  you can do to show things are in NP\" :P</p>",
        "id": 318282831,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1672243937
    },
    {
        "content": "<p>:O I'm very interested as well! It seems I can't sign up for the meeting though. May I have an invite?</p>",
        "id": 318353815,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1672283986
    },
    {
        "content": "<p>Everyone is invited! Just vote in the poll, please.</p>",
        "id": 318371141,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1672300292
    },
    {
        "content": "<p>Oh apologies I was doing something wrong -- I've signed up now</p>",
        "id": 318374104,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1672302105
    },
    {
        "content": "<p>No need to apologize. Just clarify, please, did you just indicate that only one time works for you?</p>",
        "id": 318374286,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1672302195
    },
    {
        "content": "<p>Doodle asks every participant for a subset of time slots.</p>",
        "id": 318374441,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1672302273
    },
    {
        "content": "<p>Don't forget to record the meetings and post on YouTube.</p>",
        "id": 318377629,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1672303922
    },
    {
        "content": "<p>Is it necessary?</p>",
        "id": 318377896,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1672304034
    },
    {
        "content": "<p>Recording meetings makes many people afraid of embarrassing themselves.</p>",
        "id": 318378188,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1672304156
    },
    {
        "content": "<p>Participants may request to remove any problematic part of the video before posting on youtube, but it will rarely happen. Most Lean meetings are public. See for example mathlib4 porting meetings at leanprover community youtube channel. People who can't participate for whatever reason should have access to video materials.</p>",
        "id": 318399312,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1672313192
    },
    {
        "content": "<p>2c: I would suggest the first meetings not to be recorded because it's important that participants feel as comfortable to speak as possible. And the group still has to find its dynamics. Recording will be more natural when there's a minimal shape to begin with. (I'm not participating, but I have some experience starting out informal study groups)</p>",
        "id": 318416427,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1672319795
    },
    {
        "content": "<p>Please don't let anything hinder the spontaneity of the movement. It's an important ingredient!</p>",
        "id": 318416700,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1672319895
    },
    {
        "content": "<p>I'd very much like to attend but this is the same week as the POPL conference (Principles of Programming Languages). I only marked times as available when they didn't conflict with this (i.e. before 9:00 AM).</p>\n<p>On the other hand, it seems there are quite a few talks about Lean, which presumably means other Lean people will be there. So while I can't really do a Zoom call, if other people will be at POPL I am willing to do an in-person meeting!</p>",
        "id": 318903929,
        "sender_full_name": "Praneeth Kolichala",
        "timestamp": 1672605731
    },
    {
        "content": "<p>I am sorry I chose an inconvenient week for the first call. Given how many people have responded to the poll, I will not change it now. I will be happy if you join us for the next meetings!</p>",
        "id": 318949099,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1672647140
    },
    {
        "content": "<p>This discussion <a href=\"#narrow/stream/113488-general/topic/elementary.20probability.20advice/near/306030991\">on elementary probability</a> is very relevant to us. Most theoretical CS people may not be fluent in measure theory either.</p>",
        "id": 319818095,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1673023492
    },
    {
        "content": "<p>We shall meet on Monday 2023-01-16 at 15:00 GMT.</p>",
        "id": 320405042,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1673342038
    },
    {
        "content": "<p>Can someone with Zoom Pro generate a Zoom link for our meeting please? My links are limited to 40 minutes.</p>",
        "id": 320405909,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1673342384
    },
    {
        "content": "<p>If you use the add global time button when composing message you can add a time which will be rendered as everyones local time, eg: <time datetime=\"2023-01-16T15:00:00Z\">2023-01-16T15:00:00Z</time></p>",
        "id": 320443790,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1673355247
    },
    {
        "content": "<p>Yes <time datetime=\"2023-01-16T15:00:00Z\">2023-01-16T15:00:00+00:00</time> is correct.</p>",
        "id": 320444669,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1673355520
    },
    {
        "content": "<p>Hot news! The Cook-Levin theorem has been proved in Isabelle!<br>\n<a href=\"https://www.isa-afp.org/entries/Cook_Levin.html\">https://www.isa-afp.org/entries/Cook_Levin.html</a></p>",
        "id": 320537019,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1673381861
    },
    {
        "content": "<p>Wow!! Only two days ago as well :O</p>",
        "id": 320537861,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1673382210
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"468318\">@Fabian Kunze</span> Can you please tell us a brief comparison with your proof in Coq?</p>",
        "id": 320542822,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1673384088
    },
    {
        "content": "<p>The first 360 odd pages in the proof doc are just for establishing the basic machinery of TMs and other basic stuff. I wonder how much we can shave this in size with effective use of mathlib</p>",
        "id": 320548042,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1673386036
    },
    {
        "content": "<p>and how much of this machinery related to TMs is reusable for the rest of the theorems in that book</p>",
        "id": 320548224,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1673386109
    },
    {
        "content": "<p>A significant chunk of the TM related proofs is about writing TMs for specific languages and proving their correctness and complexity.</p>",
        "id": 320548444,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1673386198
    },
    {
        "content": "<p>In general I would usually expect isabelle results to be shorter than ours because they can cut proofs quite short thanks to superior automation.</p>",
        "id": 320548609,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1673386251
    },
    {
        "content": "<p>I don't mean shorter through automation, but shorter in an amortized sense, because we have a library which might come in handy for proving this theorem, and the theorems we develop for this might come in handy elsewhere.</p>",
        "id": 320650952,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1673428414
    },
    {
        "content": "<p>Can somebody please generate the Zoom link?</p>",
        "id": 320796051,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1673470684
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/320796051\">said</a>:</p>\n<blockquote>\n<p>Can somebody please generate the Zoom link?</p>\n</blockquote>\n<p>I need to check if our institutions still have licenses.</p>",
        "id": 320816724,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1673479714
    },
    {
        "content": "<p>I'll be able to check if I can create a room by Friday evening</p>",
        "id": 320816774,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1673479748
    },
    {
        "content": "<p>I think I can generate one under my institution</p>",
        "id": 320816998,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1673479911
    },
    {
        "content": "<p><a href=\"https://usc.zoom.us/j/96278860441?pwd=YXFjdlJ2aFVlOUovMUVscitNWHZCdz09\">https://usc.zoom.us/j/96278860441?pwd=YXFjdlJ2aFVlOUovMUVscitNWHZCdz09</a></p>",
        "id": 320817069,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1673479931
    },
    {
        "content": "<p>Does this work lol</p>",
        "id": 320817079,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1673479938
    },
    {
        "content": "<p>Over the past couple weeks, I've been working on my reworked definitions of polynomial time computation. I've uploaded the repository <a href=\"https://github.com/prakol16/circuits\">here</a> with a reasonably detailed README. I feel like I have a reasonable path towards Cook-Levin, although the machinery for circuits is still quite basic. Essentially, we need to define uniform circuit families and show that composition (which is mostly straightforward with circuits) can actually be computed in polynomial time.</p>\n<p>If anyone would like to help out or contribute, that would be very appreciated (especially now that winter break has ended, I will probably be busy again).</p>",
        "id": 320855917,
        "sender_full_name": "Praneeth Kolichala",
        "timestamp": 1673500014
    },
    {
        "content": "<p>Your README looks great! When I have more time, I will READYOU more carefully.</p>",
        "id": 320867245,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1673507550
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"355764\">Hanting Zhang</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/320817069\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://usc.zoom.us/j/96278860441?pwd=YXFjdlJ2aFVlOUovMUVscitNWHZCdz09\">https://usc.zoom.us/j/96278860441?pwd=YXFjdlJ2aFVlOUovMUVscitNWHZCdz09</a></p>\n</blockquote>\n<p>Is it all right that I can join the call already now?</p>",
        "id": 320867680,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1673507787
    },
    {
        "content": "<p>uhhhh yeah idk how to restrict it</p>",
        "id": 320868337,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1673508120
    },
    {
        "content": "<p>Do other people use the same link?</p>",
        "id": 320868528,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1673508205
    },
    {
        "content": "<p>Can I distribute the link without a risk that the recipients will land into unrelated meetings?</p>",
        "id": 320893321,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1673516815
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/320542822\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"468318\">Fabian Kunze</span> Can you please tell us a brief comparison with your proof in Coq?</p>\n</blockquote>\n<p>The author of the new proof in Isabelle compares his proof to the proof in Coq as follows:<br>\n<a href=\"/user_uploads/3121/Av_8_ATe9nMHRIxE_yh96r_V/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/Av_8_ATe9nMHRIxE_yh96r_V/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/Av_8_ATe9nMHRIxE_yh96r_V/image.png\"></a></div>",
        "id": 321015891,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1673551329
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/91P4mtevTE51q7CeJB6wIMfM/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/91P4mtevTE51q7CeJB6wIMfM/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/91P4mtevTE51q7CeJB6wIMfM/image.png\"></a></div>",
        "id": 321015982,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1673551354
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/320542822\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"468318\">Fabian Kunze</span> Can you please tell us a brief comparison with your proof in Coq?</p>\n</blockquote>\n<p>We use a different intermediate problem to get from n-Tape TMs to SAT: Instead of oblivious 2-tape TMs, we use 1-tape TMs, and then look at the configuration history, which is a 2-dimensional table: Line $i$ line corresponds to the tape, head position and state after $i$ computation steps, and each cell in that line is more or less one cell of the tape. Then, we express the transition function of the Turing machine as a set of 2x3 cell large \"dominos\", and each 2x3 cell in the configuration history must be in this set of allowed states.<br>\nThis means that validity of the computation is a very local property, and we can just AND that each position in the table is one of the different allowed dominos.<br>\nBoth the intermediate problem used by us, and by the authors of the Isabelle formalization, are  standard proof ideas sketched in text books <br>\non complexity theory.</p>",
        "id": 321027812,
        "sender_full_name": "Fabian Kunze",
        "timestamp": 1673555196
    },
    {
        "content": "<p>On a higher level, our approach of using the lambda calculus as a model of computation enables us to more or less generate the witnesses of computability (i.e., the programs computing reduction functions etc) directly from the (functional) specification of those functions in Coq. We still have to verify many Turing machines (a TM interpreting lambda-calculus, and a translation from multi-tape TMs to single-tape-TMs), but at least not all the reduction functions need to be modeled as TMs.</p>",
        "id": 321028311,
        "sender_full_name": "Fabian Kunze",
        "timestamp": 1673555381
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"437861\">Praneeth Kolichala</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/320855917\">said</a>:</p>\n<blockquote>\n<p>I feel like I have a reasonable path towards Cook-Levin, although the machinery for circuits is still quite basic. Essentially, we need to define uniform circuit families and show that composition (which is mostly straightforward with circuits) can actually be computed in polynomial time.</p>\n</blockquote>\n<p>Interesting, I would not have thought that circuits are a natural path towards formalizing cook-levin, doesn't one still need another model of computation to define \"uniformity\" of circuit families?</p>",
        "id": 321028899,
        "sender_full_name": "Fabian Kunze",
        "timestamp": 1673555593
    },
    {
        "content": "<p>Yes, we still need a model of computation to define uniformity (and this is the main model of computation; it is based on  an inductive definition akin to the current <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.primrec\">docs#nat.primrec</a>). The main thing is that (hopefully) we avoid having to deal with TMs directly.</p>",
        "id": 321063540,
        "sender_full_name": "Praneeth Kolichala",
        "timestamp": 1673571076
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"437861\">Praneeth Kolichala</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/321063540\">said</a>:</p>\n<blockquote>\n<p>Yes, we still need a model of computation to define uniformity (and this is the main model of computation; it is based on  an inductive definition akin to the current <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.primrec\">docs#nat.primrec</a>). The main thing is that (hopefully) we avoid having to deal with TMs directly.</p>\n</blockquote>\n<p>Depends on your goal. If it is to just prove variants of complexity results in your model, then this will certainly do. There will have to be suitable adaptations of statements. For instance, in the time/space hierarchy theorems. If however your goal is to build a larger library of results which the TCS community finds useful, and builds upon further, then TM and RAM are unavoidable. There are relatively few  uniform translations of complexity results from one model to another, and usually one can do better for various classes of problems. Most people in this field care about them. There was a similar discussion in another thread.</p>",
        "id": 321064179,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1673571394
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 321064254,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1673571439
    },
    {
        "content": "<p>If you wish to try model agnostic approaches, then descriptive complexity might be a nice approach.</p>",
        "id": 321064998,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1673571823
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/321064998\">said</a>:</p>\n<blockquote>\n<p>If you wish to try model agnostic approaches, then descriptive complexity might be a nice approach.</p>\n</blockquote>\n<p>I've actually been playing around with something in this vein (I use vein loosely here, mostly its the idea of quantifying over models) (there is another thread in Is there code for X? with some of my earlier thoughts leading up to here). Basically define a model of computation and then we can write theorems about all models.<br>\n<a href=\"https://github.com/calcu16/lean_complexity/blob/67ebab10624a272cf7c6c2a5345d26b2096e1c55/src/complexity/basic.lean\">https://github.com/calcu16/lean_complexity/blob/67ebab10624a272cf7c6c2a5345d26b2096e1c55/src/complexity/basic.lean</a><br>\nFor better or worse I've been trying to abuse instances so that in theory I could autogenerate a  complexity bound from the lean definitions.<br>\nfor example I've defined nat.mul generically on any model to have complexity based on an equivalent formulation using nat.iterate</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">mul_complexity</span> <span class=\"o\">[</span><span class=\"n\">has_encoding</span> <span class=\"n\">m</span> <span class=\"n\">ℕ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_encoding</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">ℕ</span><span class=\"bp\">×</span><span class=\"n\">ℕ</span><span class=\"o\">)]</span>\n  <span class=\"o\">[</span><span class=\"n\">cf</span><span class=\"o\">:</span> <span class=\"n\">has_complexity</span> <span class=\"n\">m</span>\n    <span class=\"o\">(</span><span class=\"n\">curry</span> <span class=\"o\">(</span><span class=\"n\">compose</span>\n      <span class=\"n\">prod.fst</span>\n      <span class=\"o\">((</span><span class=\"n\">compose</span>\n        <span class=\"o\">(</span><span class=\"n\">uncurry</span> <span class=\"o\">(</span><span class=\"n\">nat.iterate</span> <span class=\"o\">(</span><span class=\"n\">fork</span> <span class=\"o\">(</span><span class=\"n\">uncurry</span> <span class=\"n\">nat.add</span><span class=\"o\">)</span> <span class=\"n\">prod.snd</span><span class=\"o\">)))</span>\n        <span class=\"o\">(((</span><span class=\"n\">fork</span> <span class=\"n\">prod.snd</span> <span class=\"o\">(</span><span class=\"n\">fork</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">const</span> <span class=\"n\">ℕ</span> <span class=\"o\">(</span><span class=\"n\">ℕ</span><span class=\"bp\">×</span><span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"n\">prod.fst</span><span class=\"o\">))))))))]:</span>\n  <span class=\"n\">has_complexity</span> <span class=\"n\">m</span> <span class=\"n\">nat.mul</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>Then assuming you have a model with the complexities of the necessary primitives defined for a model the complexity will \"pop\" out.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">complexity</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_equiv</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">preorder</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">γ</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">:</span> <span class=\"n\">complexity.model</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">δ</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">complexity.has_encodable_function</span> <span class=\"n\">m</span> <span class=\"n\">δ</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">δ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">c</span><span class=\"o\">:</span> <span class=\"n\">complexity.has_complexity</span> <span class=\"n\">m</span> <span class=\"n\">f</span><span class=\"o\">]:</span>\n  <span class=\"n\">complexity.cost_function'</span> <span class=\"n\">m</span> <span class=\"n\">δ</span> <span class=\"o\">:=</span> <span class=\"n\">c.value.cost</span>\n</code></pre></div>\n<p>For example in my case I'm using a model of counting beta reductions in untyped lambda calculus and I can get a complexity for it without having to write(or cost) nat.mul myself in lambda calculus.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span><span class=\"o\">:</span>  <span class=\"o\">(</span><span class=\"n\">complexity</span> <span class=\"n\">distance_model</span> <span class=\"n\">nat.mul</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"o\">((</span><span class=\"mi\">30</span><span class=\"bp\">*</span><span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"mi\">43</span><span class=\"o\">):</span><span class=\"n\">ℕ</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">n</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">complexity</span><span class=\"o\">,</span> <span class=\"n\">complexity.cost_function.less_than_or_equal</span><span class=\"o\">,</span> <span class=\"n\">has_complexity.value</span><span class=\"o\">,</span> <span class=\"n\">fork</span><span class=\"o\">,</span> <span class=\"n\">const</span><span class=\"o\">,</span> <span class=\"n\">uncurry</span><span class=\"o\">],</span>\n  <span class=\"n\">ring_nf</span><span class=\"o\">,</span>\n  <span class=\"n\">norm_num</span><span class=\"o\">,</span>\n  <span class=\"n\">induction</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">iteration_complexity.cost_zero</span><span class=\"o\">],</span>\n    <span class=\"n\">ring_nf</span> <span class=\"o\">},</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">iteration_complexity.cost_succ'</span><span class=\"o\">,</span> <span class=\"n\">function.iterate_succ'</span><span class=\"o\">,</span> <span class=\"n\">nat.mul_succ</span><span class=\"o\">,</span> <span class=\"n\">add_mul</span><span class=\"o\">,</span> <span class=\"n\">nat.add_assoc</span><span class=\"o\">],</span>\n  <span class=\"n\">nlinarith</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>One cute thing with this approach is that you don't even need a model, you could say something basically akin to \"for all models with properties X Y Z\" my function will have complexity better than C.</p>\n<p>One thing that's not clear to me is how to interact with general recursion using the instance strategy (or even if the instance strategy is a good idea). Additionally functions need to be written in a point-free style, so pointers on how I could get generic pattern matching against lambdas would also be of use I think.</p>",
        "id": 321423357,
        "sender_full_name": "Andrew Carter",
        "timestamp": 1673742891
    },
    {
        "content": "<p>[not relevant anymore]</p>",
        "id": 321581523,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1673856398
    },
    {
        "content": "<p>We have discussed that we would like to meet probably twice a month.<br>\nLet's vote for a regular meeting — it will happen every other week, starting with the week that we vote about!<br>\n<a href=\"https://doodle.com/meeting/participate/id/e791Lj8b\">https://doodle.com/meeting/participate/id/e791Lj8b</a></p>",
        "id": 321691751,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1673891205
    },
    {
        "content": "<p>Please vote. I would like to announce the time of our meetings tomorrow.</p>",
        "id": 322997385,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1674473713
    },
    {
        "content": "<p>Next meeting: <time datetime=\"2023-01-31T16:00:00Z\">2023-01-31T16:00:00+00:00</time></p>",
        "id": 323695221,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1674732535
    },
    {
        "content": "<p>Probably can't make it tomorrow, but I was looking into <span class=\"user-mention\" data-user-id=\"466334\">@Shreyas Srinivas</span> suggestion of the matching algorithm, and one concern I have is that most of the math doesn't seem to be there yet (blossoms but no augmenting paths). Also I have some concerns about how cardinality is handled, I've had to add noncomputable to indicate finiteness, hopefully if I have a fintype I can avoid it, but it does make me worried (I don't think berg's lemma holds on infinite graphs for example).</p>\n<p>Anyway, I think ideally for the initial algorithms we explore, the math exists (i.e. provably correctness) but the complexity is the missing piece. Is there any other suggestions (I had been working towards Karatsuba but maybe that's not impressive enough?).</p>",
        "id": 324800216,
        "sender_full_name": "Andrew Carter",
        "timestamp": 1675122429
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"355764\">Hanting Zhang</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/320817069\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://usc.zoom.us/j/96278860441?pwd=YXFjdlJ2aFVlOUovMUVscitNWHZCdz09\">https://usc.zoom.us/j/96278860441?pwd=YXFjdlJ2aFVlOUovMUVscitNWHZCdz09</a></p>\n</blockquote>\n<p>Can we use the same link today?</p>",
        "id": 324931452,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1675176378
    },
    {
        "content": "<p>I got there. You can join me.</p>",
        "id": 324949773,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1675180675
    },
    {
        "content": "<p><a href=\"https://cs-uni-saarland-de.zoom.us/j/82352578108?pwd=REhLWHFQN2VCVUd4cW9CbG0wL0Z5UT09\">https://cs-uni-saarland-de.zoom.us/j/82352578108?pwd=REhLWHFQN2VCVUd4cW9CbG0wL0Z5UT09</a></p>",
        "id": 324967603,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1675185019
    },
    {
        "content": "<p>Do we meet same time two weeks from now?</p>",
        "id": 325032030,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1675204921
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  I recall that you had a question about promise problems yesterday : here's a well-motivated presentation: <a href=\"https://www.wisdom.weizmann.ac.il/~oded/PSX/prpr-r.pdf\">https://www.wisdom.weizmann.ac.il/~oded/PSX/prpr-r.pdf</a></p>",
        "id": 325115912,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1675247088
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/325032030\">said</a>:</p>\n<blockquote>\n<p>Do we meet same time two weeks from now?</p>\n</blockquote>\n<p>Yes. We will meet on <time datetime=\"2023-02-14T16:00:00Z\">2023-02-14T17:00:00+01:00</time> not today.</p>",
        "id": 326294122,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1675753777
    },
    {
        "content": "<p>The old Zoom link does not work anymore. Can someone generate a new link, please?</p>",
        "id": 327767507,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1676379119
    },
    {
        "content": "<p><a href=\"https://cmu.zoom.us/j/97134152768?pwd=K2NxRW9SMEg0dTdXQ21oUjNUd1dLQT09\">https://cmu.zoom.us/j/97134152768?pwd=K2NxRW9SMEg0dTdXQ21oUjNUd1dLQT09</a></p>",
        "id": 327777265,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1676381914
    },
    {
        "content": "<p>Is this definition of RAM in Coq useful for us?<br>\n<a href=\"https://link.springer.com/chapter/10.1007/978-3-540-45208-9_5\">https://link.springer.com/chapter/10.1007/978-3-540-45208-9_5</a></p>",
        "id": 327835441,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1676396536
    },
    {
        "content": "<p>FYI, we didn't schedule another meeting yet. When we have a concrete topic to discuss, we will call a meeting.</p>",
        "id": 327851872,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1676401273
    },
    {
        "content": "<p>I've sketched out a complexity model based on <span class=\"user-mention\" data-user-id=\"466334\">@Shreyas Srinivas</span>  memory-bank suggestion here:<br>\n<a href=\"https://github.com/calcu16/lean_complexity/blob/96c3d3580dcdd6b457728fb2d9fdec0ebc9ede64/src/membank/basic.lean\">https://github.com/calcu16/lean_complexity/blob/96c3d3580dcdd6b457728fb2d9fdec0ebc9ede64/src/membank/basic.lean</a><br>\nI've golfed it a little bit, but the basic premise is that you start with a fixed amount of memory, but behind each memory is even more memory. The golfing is rather than having each memory bank have n data and n more memory banks, each memory bank only has 1 data, but this is just pushing things one level down because the n more banks 1 data is n data.<br>\nAll data starts zeroed out (and I use has_zero rather than inhabited for this reason), I allow arbitrary binary operations and random-access through any (constant) number of memory banks. I figure we can always put a filter over the instructions later if someone doesn't want that.<br>\nAs <span class=\"user-mention\" data-user-id=\"466334\">@Shreyas Srinivas</span> suggested, I've added a \"call\" instruction which takes one of these memory banks and limits the call's visibility inside of it. When you run out of instructions the function returns (and this works at the top level to create the final \"result\"). This makes proving composability easier, which I've proved here (<a href=\"https://github.com/calcu16/lean_complexity/blob/main/src/membank/encoding/basic.lean\">https://github.com/calcu16/lean_complexity/blob/main/src/membank/encoding/basic.lean</a>) - the proof is messy right now.<br>\nOne tricky thing is allowing recursion, right now recurse is essentially creates a do-while around the current function and calls continue. I'm not the happiest about this, and am open to suggestions. I've considered a giant map of function names (numeric or otherwise), but I feel like that would impede composability since you'd have to limit the scope, possibly deal with alpha-equivalence etc.</p>\n<p>I currently allow any type as the memory bank, but I think bool or finset 2 is all that is required. However, leaving it general does allow infinite data types such as natural numbers or even reals which could be fun to think about (especially by constraining the binary op).</p>",
        "id": 328757827,
        "sender_full_name": "Andrew Carter",
        "timestamp": 1676780949
    },
    {
        "content": "<p>Actually, recurse is more like the y-combinator than do-while since you can call it multiple times and get new stacks etc.</p>",
        "id": 328758356,
        "sender_full_name": "Andrew Carter",
        "timestamp": 1676781623
    },
    {
        "content": "<p>I've worked through the master theorem modulo asymptotic analysis (its just a recursive function at the moment instead, although it could be easily converted into a sum, which I will probably do at some point).<br>\n<a href=\"https://github.com/calcu16/lean_complexity/blob/45dbf0afed8bea0cea6fed6b1e43b366a1ea979c/src/membank/master.lean\">https://github.com/calcu16/lean_complexity/blob/45dbf0afed8bea0cea6fed6b1e43b366a1ea979c/src/membank/master.lean</a><br>\n(I haven't cleaned up the proofs yet)<br>\nBasically culminating in</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">divide_and_conquer_cost_sound</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">:</span> <span class=\"n\">program</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">{</span><span class=\"n\">fr</span><span class=\"o\">:</span> <span class=\"n\">bank</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hfr</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">inp</span> <span class=\"n\">arg</span><span class=\"o\">,</span> <span class=\"n\">recurse_arg</span> <span class=\"n\">p</span> <span class=\"n\">inp</span> <span class=\"n\">arg</span> <span class=\"bp\">→</span> <span class=\"n\">fr</span> <span class=\"n\">arg</span> <span class=\"bp\">&lt;</span> <span class=\"n\">fr</span> <span class=\"n\">inp</span><span class=\"o\">)</span>\n  <span class=\"o\">{</span><span class=\"n\">fc</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hfc</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">inp</span><span class=\"o\">,</span> <span class=\"n\">call_cost_le</span> <span class=\"o\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">inp</span><span class=\"o\">⟩</span> <span class=\"o\">(</span><span class=\"n\">fc</span> <span class=\"o\">(</span><span class=\"n\">fr</span> <span class=\"n\">inp</span><span class=\"o\">))):</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">inp</span><span class=\"o\">,</span> <span class=\"n\">p.cost_le</span> <span class=\"n\">inp</span> <span class=\"o\">(</span><span class=\"n\">divide_and_conquer_cost</span> <span class=\"n\">p</span> <span class=\"n\">fc</span> <span class=\"o\">(</span><span class=\"n\">fr</span> <span class=\"n\">inp</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>Where divide_and_conquer_cost is defined as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">divide_and_conquer_cost</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">:</span> <span class=\"n\">program</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fc</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">):</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">internal_cost_bound</span> <span class=\"n\">p</span> <span class=\"bp\">+</span> <span class=\"n\">fc</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">internal_cost_bound</span> <span class=\"n\">p</span> <span class=\"bp\">+</span> <span class=\"n\">fc</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">divide_and_conquer_cost</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"n\">recurse_count</span> <span class=\"n\">p</span>\n</code></pre></div>\n<p>I changed some of the definitions to make things work, but they are basically the same as before with extra properties that are essentially transparent to the \"programmer\".</p>\n<p>This should in theory make proving complexity of basic recursive functions straightforward, and I think I've implemented merge_sort <span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> :<br>\n<a href=\"https://github.com/calcu16/lean_complexity/blob/main/src/membank/encoding/list.lean\">https://github.com/calcu16/lean_complexity/blob/main/src/membank/encoding/list.lean</a><br>\nAlthough I haven't proved it (but the bugs are presumably minor) and I haven't proved complexity yet either, but those are next on my docket (it should be less heavy lifting and more just building ergonomic machinery for stepping through programs).</p>",
        "id": 338410968,
        "sender_full_name": "Andrew Carter",
        "timestamp": 1677520708
    },
    {
        "content": "<p>Can you please make a unit test for your mergesort?</p>",
        "id": 338411672,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1677520872
    },
    {
        "content": "<p>I was just going to go straight for the proof, probably a similar amount of work</p>",
        "id": 338415243,
        "sender_full_name": "Andrew Carter",
        "timestamp": 1677521774
    },
    {
        "content": "<p>Ah. I was eager to see something executable.</p>",
        "id": 338415671,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1677521887
    },
    {
        "content": "<p>Well memory access is done via a function definition (bank.mem.memory has type α → bank) so I'm not sure #eval would work (although maybe it'd be fine, \"step\" claims to be computable) but even if it was I'd have to define an encoding for the elements of the list as well as a comparator before I could run anything.</p>",
        "id": 338416619,
        "sender_full_name": "Andrew Carter",
        "timestamp": 1677522137
    },
    {
        "content": "<p>On second thought if I define an inverse of encode (dare say decode) I think it'll work, how would you feel about a unit test of sorting a list of \"fin 2\"s?</p>",
        "id": 338425080,
        "sender_full_name": "Andrew Carter",
        "timestamp": 1677524376
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/338411672\">said</a>:</p>\n<blockquote>\n<p>Can you please make a unit test for your mergesort?</p>\n</blockquote>\n<p><a href=\"https://github.com/calcu16/lean_complexity/blob/main/src/membank/encoding/example.lean\">https://github.com/calcu16/lean_complexity/blob/main/src/membank/encoding/example.lean</a></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">test</span><span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">frame</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">((</span><span class=\"n\">stack.step</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"mi\">1000</span><span class=\"o\">])</span> <span class=\"o\">((</span><span class=\"n\">merge_sort</span> <span class=\"n\">nat_cmp</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"n\">push_list</span> <span class=\"o\">[</span><span class=\"mi\">9</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"mi\">6</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">]</span> <span class=\"n\">bank.null</span><span class=\"o\">)))</span><span class=\"bp\">.</span><span class=\"n\">val</span>\n\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"n\">list.length</span> <span class=\"n\">test</span><span class=\"o\">)</span> <span class=\"c1\">-- 1</span>\n<span class=\"k\">#eval</span> <span class=\"n\">list.length</span> <span class=\"o\">(</span><span class=\"n\">frame.current</span> <span class=\"o\">(</span><span class=\"n\">list.ilast</span> <span class=\"n\">test</span><span class=\"o\">))</span> <span class=\"c1\">-- 0</span>\n<span class=\"k\">#eval</span> <span class=\"n\">decode_list</span> <span class=\"o\">(</span><span class=\"n\">frame.register</span> <span class=\"o\">(</span><span class=\"n\">list.ilast</span> <span class=\"n\">test</span><span class=\"o\">))</span> <span class=\"c1\">-- [2, 3, 5, 6, 9]</span>\n</code></pre></div>\n<p>1000 is probably (hopefully?) overkill</p>",
        "id": 338501676,
        "sender_full_name": "Andrew Carter",
        "timestamp": 1677561383
    },
    {
        "content": "<p>Thanks a lot !!!!!</p>",
        "id": 338618477,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1677598434
    },
    {
        "content": "<p>FYI, for sorting a list of twenty numbers, nearly 3500 steps are needed.</p>",
        "id": 338618974,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1677598548
    },
    {
        "content": "<p>BTW, I get error when building <code>src/local/maximal_matching.lean</code> on line 330.<br>\nDoes it work on your computer?</p>",
        "id": 338619619,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1677598689
    },
    {
        "content": "<p>Oh yeah it does, I was trying to work on Shreyas's graph matching problem, but then  switched over to exploring the new membank/RAM model. I'll comment out that theorem for now, looks like the rest of the file is fine (I had just realized I needed alternating paths in addition to augmenting paths in order to prove berg's lemma so I was copying the proofs from augmenting and patching them).</p>\n<p>Split takes: 8n + 2 steps<br>\nMerge takes less than 26n + 5 steps<br>\nMerge sort internal takes 18 steps, so for a list of length 2^m the recurrence relations should be</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">cost</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">):</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n.succ</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">))</span>\n<span class=\"k\">#eval</span> <span class=\"n\">cost</span> <span class=\"mi\">5</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"mi\">24</span><span class=\"bp\">*</span><span class=\"mi\">2</span><span class=\"bp\">^</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">35</span><span class=\"o\">)</span> <span class=\"c1\">-- 6813</span>\n</code></pre></div>\n<p>Which for m=5 gives 6813, so you got off easy<br>\n(I had an off by one error in the original recurrence definition)</p>",
        "id": 338629425,
        "sender_full_name": "Andrew Carter",
        "timestamp": 1677601079
    },
    {
        "content": "<p>I had a chance to read part of  the Isabelle Proof of the Cook Levin Theorem. A few observations:</p>\n<ol>\n<li>They spend a lot of time doing the work we have already done in mathlib e.g. Arithmetic with bit representations. Much of this is TM-independent</li>\n<li>They spend a lot of time formalising basic theorems about TMs. These are the kind of things any library on complexity should have. </li>\n<li>They spend a lot of time defining and formalising concepts about complexity classes and TMs for them.</li>\n<li>They follow the Barak-Arora book for definitions.</li>\n</ol>\n<p>Conclusion:</p>\n<ol>\n<li>We should try to replicate this work in Lean</li>\n<li>We should make sure we are not doing redundant things. We can probably achieve more modularity and reduce work.</li>\n<li>Much of the things we formalise will be of use in other places. So we have to organise the definitions and proofs like designing a library for future use, not just proving this theorem.</li>\n</ol>",
        "id": 340382576,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1678287068
    },
    {
        "content": "<p>Finally : We can probably make savings in effort if we are willing to use loose inequalities in the number of steps that TMs take to compute their functions</p>",
        "id": 340382866,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1678287138
    },
    {
        "content": "<p>The SAT stuff should probably go in a separate folder. This is because it is likely to be of much wider interest.</p>",
        "id": 340383315,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1678287243
    },
    {
        "content": "<p>BTW has anybody explored the project by <span class=\"user-mention\" data-user-id=\"562941\">@Andrew Carter</span> ? What do you think about the \"infinitely hierarchical\" memory model?</p>",
        "id": 340390903,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1678288843
    },
    {
        "content": "<p>I don't understand the hierarchy very well yet. But to be fair I should invest a little more time into it first.</p>",
        "id": 340392953,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1678289210
    },
    {
        "content": "<p>for instance, is it like a call stack, except each call stack has one cell?</p>",
        "id": 340394996,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1678289703
    },
    {
        "content": "<p>But I like the prospect that in principle the cell can be of any type. This allows us a lot of flexibility.</p>",
        "id": 340395313,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1678289770
    },
    {
        "content": "<p>I think the best description of the memory bank is \"tree\".</p>",
        "id": 340395454,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1678289815
    },
    {
        "content": "<p>The nice thing is that you can pass a subtree to a subprogram.</p>",
        "id": 340395646,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1678289869
    },
    {
        "content": "<p>The subprogram has no way of damaging the rest of the memory.</p>",
        "id": 340395749,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1678289888
    },
    {
        "content": "<p>Therefore, you can express a clear \"contract\" for each routine.</p>",
        "id": 340396373,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1678290034
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/340382576\">said</a>:</p>\n<blockquote>\n<p>I had a chance to read part of  the Isabelle Proof of the Cook Levin Theorem. A few observations:</p>\n<ol>\n<li>They spend a lot of time doing the work we have already done in mathlib e.g. Arithmetic with bit representations. Much of this is TM-independent</li>\n<li>They spend a lot of time formalising basic theorems about TMs. These are the kind of things any library on complexity should have. </li>\n<li>They spend a lot of time defining and formalising concepts about complexity classes and TMs for them.</li>\n<li>They follow the Barak-Arora book for definitions.</li>\n</ol>\n<p>Conclusion:</p>\n<ol>\n<li>We should try to replicate this work in Lean</li>\n<li>We should make sure we are not doing redundant things. We can probably achieve more modularity and reduce work.</li>\n<li>Much of the things we formalise will be of use in other places. So we have to organise the definitions and proofs like designing a library for future use, not just proving this theorem.</li>\n</ol>\n</blockquote>\n<p>Another thing in this paper is that a lot of effort is spent on trying to prove that given a function <code>f : A -&gt; B</code> and a <code>m : TM</code>, <code>m</code> computes <code>f</code> in <code>t x.card</code> steps for input <code>x</code>.   The instance consists of a suitable proof that is typically like : <code>x : A</code> has such and such bit string <code>encoding x</code> and the output of the TM is <code>y</code> and <code>decoding y</code> is <code>f x</code>. This suggests two things:</p>\n<ol>\n<li>A tactic which extracts the proof obligations of this translation and presents it to us.</li>\n<li>A typeclass say <code>ComputableIn</code> which has three types : the function, the TM, and the bound on step count. </li>\n</ol>\n<p>Point 2 should significantly ease our proof burden, and in particular allow a somewhat top to bottom proof.</p>",
        "id": 340396878,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1678290134
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/340395454\">said</a>:</p>\n<blockquote>\n<p>I think the best description of the memory bank is \"tree\".</p>\n</blockquote>\n<p>Ah okay. Now I can map this to what I said in the meeting. If we can express the idea that this is equivalent to what is classically understood as RAM (upto asymptotics) and then show some simple algorithms' time and space complexities, this should probably qualify as a single publishable unit. The critical thing is to demonstrate that we can reason about algorithms without the memory bank structure getting in our way.</p>",
        "id": 340397505,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1678290272
    },
    {
        "content": "<p>RAM can be expressed as a special case of the memory-bank model afaik. So we should eventually write a transpiler from a general memory-bank machine to the RAM-like memory-bank machine.</p>",
        "id": 340400900,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1678291050
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/340396878\">said</a>:</p>\n<blockquote>\n<p>Another thing in this paper is that a lot of effort is spent on trying to prove that given a function <code>f : A -&gt; B</code> and a <code>m : TM</code>, <code>m</code> computes <code>f</code> in <code>t x.card</code> steps for input <code>x</code>.   </p>\n</blockquote>\n<p>What is <code>t x.card</code> please?</p>",
        "id": 340401382,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1678291158
    },
    {
        "content": "<p><code>x</code> is the input. <code>x.card</code> a hypothetical name for the size of the encoding of <code>x</code>. <code>t : \\N -&gt; NNReal</code> is a time complexity function</p>",
        "id": 340403760,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1678291666
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/340396878\">said</a>:</p>\n<blockquote>\n<ol start=\"2\">\n<li>A typeclass say <code>ComputableIn</code> which has three types : the function, the TM, and the bound on step count. </li>\n</ol>\n<p>Point 2 should significantly ease our proof burden, and in particular allow a somewhat top to bottom proof.</p>\n</blockquote>\n<p>So I'm not sure if the TM is necessary for the typeclass, I chose to just use the function and the bound on step count (and the model which in this case is just TM as a model). What is the point of having the specific TM as part of the typeclass?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">has_complexity</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">:</span> <span class=\"n\">model</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">δ</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_encodable_function</span> <span class=\"n\">m</span> <span class=\"n\">δ</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">δ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">value</span><span class=\"o\">:</span> <span class=\"n\">is_complexity</span> <span class=\"n\">m</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Underneath is_complexity is witness which takes an element of the model (so a specific TM in your case)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">witness</span><span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">enf</span> <span class=\"o\">:</span> <span class=\"n\">encodable_function</span> <span class=\"n\">m</span><span class=\"o\">),</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">enf.unwrap</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">cost_function</span> <span class=\"n\">enf</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">encodable_function.result</span> <span class=\"n\">en</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">prog</span> <span class=\"n\">data</span><span class=\"o\">,</span> <span class=\"n\">en.model.accepts_with_cost</span> <span class=\"n\">prog</span> <span class=\"o\">(</span><span class=\"n\">en.encode</span> <span class=\"n\">data</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">encodable_function.application</span> <span class=\"n\">en</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">prog</span> <span class=\"n\">f</span> <span class=\"n\">cost</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">arg</span> <span class=\"o\">:</span> <span class=\"n\">en.type</span><span class=\"o\">,</span>\n  <span class=\"n\">witness</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"n\">encoding.application</span> <span class=\"n\">en</span> <span class=\"n\">prog</span> <span class=\"n\">arg</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">arg</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">cost</span> <span class=\"n\">arg</span><span class=\"o\">)</span>\n<span class=\"bp\">````</span>\n</code></pre></div>",
        "id": 340760585,
        "sender_full_name": "Andrew Carter",
        "timestamp": 1678421342
    },
    {
        "content": "<p>That being said I have doubts about the typeclass model at least as far as introspecting lambdas goes (point-free functions seem straightforward with typeclasses - but generally annoying to work with), and am coming around to <span class=\"user-mention\" data-user-id=\"437861\">@Praneeth Kolichala</span>'s idea of a compile tactic (I think he calls it complexity).</p>",
        "id": 340760719,
        "sender_full_name": "Andrew Carter",
        "timestamp": 1678421507
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/340397505\">said</a>:</p>\n<blockquote>\n<p>Ah okay. Now I can map this to what I said in the meeting. If we can express the idea that this is equivalent to what is classically understood as RAM (upto asymptotics) and then show some simple algorithms' time and space complexities, this should probably qualify as a single publishable unit. The critical thing is to demonstrate that we can reason about algorithms without the memory bank structure getting in our way.</p>\n</blockquote>\n<p>So I think proving that any RAM program is a membank program should be straightforward (always use bank \"0\" which is effectively executed in place by bank) the only wrinkle is that I use recurse which is essentially the y-combinator instead of GOTO. But GOTO can be simulated easily with a giant WHILE(true)...IF...IF..IF...</p>\n<p>Going the other direction is trickier and probably requires a simulator that flattens the memory banks into a single much larger RAM program. We can also restrict membank operations after the fact to make this more palatable. The biggest wrinkle is that I allow copying a whole memory bank at once, but copy-on-write imperative semantics should smooth that out I think. Otherwise you would have to define a copy function for every datatype which could get tedious.</p>",
        "id": 340761270,
        "sender_full_name": "Andrew Carter",
        "timestamp": 1678421924
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"562941\">Andrew Carter</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/340760585\">said</a>:</p>\n<blockquote>\n<p>So I'm not sure if the TM is necessary for the typeclass, I chose to just use the function and the bound on step count (and the model which in this case is just TM as a model). What is the point of having the specific TM as part of the typeclass?</p>\n</blockquote>\n<p>In the context of Cook Levin theorem as formulated in textbooks and this Isabelle proof, having the TM is useful because, with the relevant TM and  suitable TM composition laws, you get new TMs, and that is basically how this version of the proof goes.</p>",
        "id": 340798978,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1678439382
    },
    {
        "content": "<p>The purpose of the typeclass is to abstract the away the equivalence between a function and a TM that computes the function.</p>",
        "id": 340799263,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1678439453
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/340799263\">said</a>:</p>\n<blockquote>\n<p>The purpose of the typeclass is to abstract the away the equivalence between a function and a TM that computes the function.</p>\n</blockquote>\n<p>But do you actually care what the TM is, or just that a TM with certain properties exists (in this case step count. but things like memory usage could also be included)? You can still \"get\" a TM through any existence quantifier, you just don't know what it looks like at proof time.</p>",
        "id": 340910544,
        "sender_full_name": "Andrew Carter",
        "timestamp": 1678466243
    },
    {
        "content": "<p>The TMs are the meat of this particular proof. So I do care about what the TM looks like.</p>",
        "id": 340910966,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1678466350
    },
    {
        "content": "<p>Whether that is necessary for \"a\" proof of this theorem is a different matter. Being able to construct and reason about TMs is more broadly useful in complexity theory results, so I can see some value in doing things this way</p>",
        "id": 340911204,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1678466404
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/340910966\">said</a>:</p>\n<blockquote>\n<p>The TMs are the meat of this particular proof. So I do care about what the TM looks like.</p>\n</blockquote>\n<p>Then I'm not really sure what the typeclass buys you over just the appropriate theorems, if you care what the TM is each time then I would wonder whatthe auto-resolution buys you (i.e. what if it picks the wrong resolution). Then again I'm not an expert in correct uses of typeclasses, and I think I'm already abusing them.</p>",
        "id": 340916472,
        "sender_full_name": "Andrew Carter",
        "timestamp": 1678467630
    },
    {
        "content": "<p>Top down proofs</p>",
        "id": 340916615,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1678467652
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/340916615\">said</a>:</p>\n<blockquote>\n<p>Top down proofs</p>\n</blockquote>\n<p>This I don't think I understand, the proof in my mind is exactly the same inside of typeclasses vs. theorems. The only benefit I've noticed is the autoresolution of 'apply_instance'. Do you have a simple example of the a top down proof via typeclasses vs. what the equivalent theorem based approach would look like?</p>",
        "id": 340920473,
        "sender_full_name": "Andrew Carter",
        "timestamp": 1678468673
    },
    {
        "content": "<p>Ok, I did another draft, and now I have merge_sort's complexity of<br>\n  ((37 + c) * l.length * (nat.clog 2 l.length) + 5)<br>\nwhere c is the cost of a comparison.<br>\n<a href=\"https://github.com/calcu16/lean_complexity/blob/aae684cc55a9beb196d4acabd06a2c22951b810f/src/hmem/encoding/list_complexity.lean\">https://github.com/calcu16/lean_complexity/blob/aae684cc55a9beb196d4acabd06a2c22951b810f/src/hmem/encoding/list_complexity.lean</a></p>\n<p>I renamed the model to hmem (for hierarchical memory) and made it more tree-like - hopefully this would make it easier for people to understand the model (based on <span class=\"user-mention\" data-user-id=\"417654\">@Martin Dvořák</span>  and <span class=\"user-mention\" data-user-id=\"466334\">@Shreyas Srinivas</span>'s discussion above), I also hid the memory in a quotient group so we can use eq.subst in proofs. Assuming a simulator interns memory.null then it would use memory.usage_le memory, if it interns everything it would use memory.unique_usage_le:<br>\n<a href=\"https://github.com/calcu16/lean_complexity/blob/aae684cc55a9beb196d4acabd06a2c22951b810f/src/hmem/memory.lean\">https://github.com/calcu16/lean_complexity/blob/aae684cc55a9beb196d4acabd06a2c22951b810f/src/hmem/memory.lean</a><br>\nI haven't written any proofs about memory usage yet though.</p>\n<p>I've also modified stack so that it embeds well-formedness within the data structure because it was annoying to work with,<br>\nand I've added a new concept trace which captures the essence of an execution that's required for proofs.<br>\n<a href=\"https://github.com/calcu16/lean_complexity/blob/aae684cc55a9beb196d4acabd06a2c22951b810f/src/hmem/trace.lean\">https://github.com/calcu16/lean_complexity/blob/aae684cc55a9beb196d4acabd06a2c22951b810f/src/hmem/trace.lean</a><br>\nIdeally (I think) the future \"compile\" tactic would take a lean defined function and generate a program with its corresponding trace.</p>\n<p>Also the math is quite onerous, it would be nice to deal with asymptotics, the majority of the complexity proof for merge_sort_complexity is just proving a less than or equal condition.</p>",
        "id": 346395602,
        "sender_full_name": "Andrew Carter",
        "timestamp": 1680458148
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"605479\">Junaid Ahmed Mohammed</span> has marked this topic as resolved.</p>",
        "id": 346397627,
        "sender_full_name": "Notification Bot",
        "timestamp": 1680459331
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"605479\">Junaid Ahmed Mohammed</span> has marked this topic as unresolved.</p>",
        "id": 346397638,
        "sender_full_name": "Notification Bot",
        "timestamp": 1680459338
    },
    {
        "content": "<p>Has anyone tried to prove complexity bounds for distributed graph algorithms? These should be simpler in principle because we don't count the computations that happen in a node. Only the communications happening between them (in lockstep). It would be nice to see the Cole-Vishkin algorithm on a directed path. formalised.</p>",
        "id": 351021180,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1681905007
    },
    {
        "content": "<p>I don't know about that specifically - I did see some coloring work in the graph folder though (although not sure about directedness). But  for any of the graph things I would worry much more about proving correctness rather than complexity per se, especially since the inner loop of the algorithm is trivially constant time. I'd imagine you'd get better visibility by asking about this as a graph question rather than a complexity question.</p>",
        "id": 351155985,
        "sender_full_name": "Andrew Carter",
        "timestamp": 1681939735
    },
    {
        "content": "<p>I'm a little bit stuck, although mostly in a not letting it go way, and not in an actually stuck way. I've defined memory of a quotient of hidden.memory as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universe</span> <span class=\"n\">u</span>\n<span class=\"kn\">namespace</span> <span class=\"n\">hidden</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">memory</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">leaf</span><span class=\"o\">:</span> <span class=\"n\">memory</span>\n<span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"o\">(</span><span class=\"n\">value</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">children</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">memory</span><span class=\"o\">):</span> <span class=\"n\">memory</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">getvp</span><span class=\"o\">:</span> <span class=\"n\">memory</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">memory.leaf</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">memory.node</span> <span class=\"n\">v</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"n\">v</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">memory.node</span> <span class=\"n\">_</span> <span class=\"n\">vs</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">::</span><span class=\"n\">as</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">getvp</span> <span class=\"o\">(</span><span class=\"n\">vs</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">as</span>\n<span class=\"kd\">end</span> <span class=\"n\">hidden</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">memory</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">quotient</span> <span class=\"o\">(</span><span class=\"n\">hidden.memory</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">infer_instance</span>\n</code></pre></div>\n<p>and it seems to me, I should be able to computably define a constructor for the equivalent of hidden.memory.node for memory using some form of lift, the noncomputable version is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">mk</span> <span class=\"o\">(</span><span class=\"n\">value</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">children</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">memory</span> <span class=\"n\">α</span><span class=\"o\">):</span> <span class=\"n\">memory</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"n\">quotient.mk</span> <span class=\"o\">(</span><span class=\"n\">hidden.memory.node</span> <span class=\"n\">value</span> <span class=\"o\">(</span><span class=\"n\">quotient.out</span> <span class=\"bp\">∘</span> <span class=\"n\">children</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>I think this sound in the sense that no matter what representative is chosen mk has equal output. This doesn't strictly matter because (a) we can use the noncomputable version in proofs still and (b) if α is a fintype then I can actually generate a canonical hidden.memory α and so I have a computable quotient.out. Also I could use the hidden form instead, it just makes the proofs more annoying since I can't rw as easily.</p>\n<p>That being said the ability to #eval has been cool, and nat is slightly easier to work with when testing then fin, so it would be nice to have it working.</p>\n<p>Does anyone have any ideas on how to achieve this?</p>\n<p>One thing I've noticed is a lot of things that I would normally mathematically define as quotients (such as integers and rationals) are actually defined as dependent types of the canonical member instead. So maybe there is a better way of defining memory?</p>",
        "id": 351502684,
        "sender_full_name": "Andrew Carter",
        "timestamp": 1682049515
    },
    {
        "content": "<p>My understanding is that these mathematically ugly (ie non-quotient) definitions of int and rat have been defended on the grounds of speed and/or efficiency (so in particular it's nothing to do with mathematics, it's an implementation issue). In practice it makes the basic API much harder to develop but if you're prepared to pay this price then you get a quotient-avoiding definition.</p>",
        "id": 351533837,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1682063126
    },
    {
        "content": "<p>This is another matching algorithm paper appearing in ITP: <a href=\"https://arxiv.org/pdf/2302.13747.pdf\">https://arxiv.org/pdf/2302.13747.pdf</a><br>\nAlthough it is in Isabelle, I think it illustrates what I have in mind when I speak of verifying things at a higher level of abstraction</p>",
        "id": 352570817,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1682436417
    },
    {
        "content": "<p>How far can we replicate this in lean ? <br>\n<a href=\"https://lawrencecpaulson.github.io/2023/02/22/Binary_GCD.html\">https://lawrencecpaulson.github.io/2023/02/22/Binary_GCD.html</a></p>\n<p>I was able to verify the equivalent for normal Euclidean GCD algo,  but proofs about binary GCD quickly became rather long (caveat: I used conv to make the proofs feel natural, and control <code>unfold</code>). I never got around to finishing  the binary version.</p>",
        "id": 363855731,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1686006280
    },
    {
        "content": "<p>do you have lean code?</p>",
        "id": 363856501,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686006633
    },
    {
        "content": "<p>The normal euclidean algorithm for GCD is already implemented in lean core and verified in std/mathlib</p>",
        "id": 363856564,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686006667
    },
    {
        "content": "<p>First part of it below. Warning : it has <code>import Mathlib</code> at the beginning. This was in my scratch repo so it isn't online</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n<span class=\"kn\">import</span> <span class=\"n\">Std</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">BinaryGCD</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">dzero</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">BinaryGCD</span> <span class=\"n\">x</span> <span class=\"mi\">0</span> <span class=\"n\">x</span>\n  <span class=\"bp\">|</span> <span class=\"n\">deven</span> <span class=\"o\">:</span> <span class=\"n\">BinaryGCD</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"bp\">→</span> <span class=\"n\">BinaryGCD</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">z</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">dodd</span> <span class=\"o\">:</span> <span class=\"n\">BinaryGCD</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"bp\">→</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">∣</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">BinaryGCD</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"n\">z</span>\n  <span class=\"bp\">|</span> <span class=\"n\">dstep</span> <span class=\"o\">:</span> <span class=\"n\">BinaryGCD</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"bp\">→</span> <span class=\"n\">y</span> <span class=\"bp\">&lt;</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">BinaryGCD</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span>\n  <span class=\"bp\">|</span> <span class=\"n\">dswap</span> <span class=\"o\">:</span> <span class=\"n\">BinaryGCD</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"bp\">→</span> <span class=\"n\">BinaryGCD</span> <span class=\"n\">y</span> <span class=\"n\">x</span> <span class=\"n\">z</span>\n\n\n\n<span class=\"kd\">theorem</span> <span class=\"n\">BinaryGCD_Div</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">BinaryGCD</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">→</span>  <span class=\"n\">z</span> <span class=\"bp\">∣</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">z</span> <span class=\"bp\">∣</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span>\n  <span class=\"n\">induction</span> <span class=\"n\">h</span>\n  <span class=\"n\">case</span> <span class=\"n\">dzero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">simp</span>\n  <span class=\"n\">case</span> <span class=\"n\">deven</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">rename_i</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"n\">a</span> <span class=\"n\">a_ih</span>\n    <span class=\"n\">cases'</span> <span class=\"n\">a_ih</span> <span class=\"k\">with</span> <span class=\"n\">left</span> <span class=\"n\">right</span>\n    <span class=\"n\">cases'</span> <span class=\"n\">left</span> <span class=\"k\">with</span> <span class=\"n\">w</span> <span class=\"n\">wh</span>\n    <span class=\"n\">cases'</span> <span class=\"n\">right</span> <span class=\"k\">with</span> <span class=\"n\">v</span> <span class=\"n\">vh</span>\n    <span class=\"n\">constructor</span>\n    <span class=\"bp\">·</span> <span class=\"n\">use</span> <span class=\"n\">w</span>\n      <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">wh</span><span class=\"o\">,</span> <span class=\"n\">Int.mul_assoc</span><span class=\"o\">]</span>\n    <span class=\"bp\">·</span> <span class=\"n\">use</span> <span class=\"n\">v</span>\n      <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">vh</span><span class=\"o\">,</span> <span class=\"n\">Int.mul_assoc</span><span class=\"o\">]</span>\n  <span class=\"n\">case</span> <span class=\"n\">dstep</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">rename_i</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"n\">step</span> <span class=\"n\">_</span> <span class=\"n\">a_h</span>\n    <span class=\"n\">cases'</span> <span class=\"n\">a_h</span> <span class=\"k\">with</span> <span class=\"n\">left</span> <span class=\"n\">right</span>\n    <span class=\"k\">have</span> <span class=\"n\">div_sum</span> <span class=\"o\">:=</span> <span class=\"n\">Int.dvd_add</span> <span class=\"n\">left</span> <span class=\"n\">right</span>\n    <span class=\"n\">cases'</span> <span class=\"n\">div_sum</span> <span class=\"k\">with</span> <span class=\"n\">w</span> <span class=\"n\">wh</span>\n    <span class=\"n\">constructor</span>\n    <span class=\"n\">case</span> <span class=\"n\">intro.left</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">use</span> <span class=\"n\">w</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">wh</span><span class=\"o\">]</span>\n      <span class=\"n\">ring</span>\n    <span class=\"n\">case</span> <span class=\"n\">intro.right</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">exact</span> <span class=\"n\">right</span>\n  <span class=\"n\">case</span> <span class=\"n\">dswap</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">rename_i</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"n\">a</span> <span class=\"n\">a_ih</span>\n    <span class=\"n\">cases'</span> <span class=\"n\">a_ih</span> <span class=\"k\">with</span> <span class=\"n\">left</span> <span class=\"n\">right</span>\n    <span class=\"n\">constructor</span>\n    <span class=\"n\">exact</span> <span class=\"n\">right</span>\n    <span class=\"n\">exact</span> <span class=\"n\">left</span>\n  <span class=\"n\">case</span> <span class=\"n\">dodd</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">rename_i</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"n\">a</span> <span class=\"n\">_</span> <span class=\"n\">a_ih</span>\n    <span class=\"n\">cases'</span> <span class=\"n\">a_ih</span> <span class=\"k\">with</span> <span class=\"n\">left</span> <span class=\"n\">right</span>\n    <span class=\"n\">cases'</span> <span class=\"n\">left</span> <span class=\"k\">with</span> <span class=\"n\">w</span> <span class=\"n\">wh</span>\n    <span class=\"n\">constructor</span>\n    <span class=\"n\">case</span> <span class=\"n\">intro.intro.right</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">exact</span> <span class=\"n\">right</span>\n    <span class=\"n\">case</span> <span class=\"n\">intro.intro.left</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">use</span> <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">w</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">wh</span><span class=\"o\">]</span>\n      <span class=\"n\">ring</span>\n  <span class=\"n\">done</span>\n</code></pre></div>",
        "id": 363857013,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1686006855
    },
    {
        "content": "<p>There's more, but it is too messy for me to make sense a month later.</p>",
        "id": 363857215,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1686006945
    },
    {
        "content": "<p><code>import Mathlib.Tactic.Ring</code> is sufficient</p>",
        "id": 363857300,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686006974
    },
    {
        "content": "<p>My first question is : Does it even make sense to pursue this style?</p>",
        "id": 363857788,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1686007188
    },
    {
        "content": "<p>here's some minor style cleanup:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">BinaryGCD_Div</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">BinaryGCD</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">z</span> <span class=\"bp\">∣</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">z</span> <span class=\"bp\">∣</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">h</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">dzero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">simp</span>\n  <span class=\"bp\">|</span> <span class=\"n\">deven</span> <span class=\"n\">_</span> <span class=\"n\">a_ih</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"o\">⟨⟨</span><span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">wh</span><span class=\"o\">⟩,</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">vh</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">a_ih</span>\n    <span class=\"n\">constructor</span>\n    <span class=\"bp\">·</span> <span class=\"n\">use</span> <span class=\"n\">w</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">wh</span><span class=\"o\">,</span> <span class=\"n\">Int.mul_assoc</span><span class=\"o\">]</span>\n    <span class=\"bp\">·</span> <span class=\"n\">use</span> <span class=\"n\">v</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">vh</span><span class=\"o\">,</span> <span class=\"n\">Int.mul_assoc</span><span class=\"o\">]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">dstep</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">a_h</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"n\">right</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">a_h</span>\n    <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">wh</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">Int.dvd_add</span> <span class=\"n\">left</span> <span class=\"n\">right</span>\n    <span class=\"n\">constructor</span>\n    <span class=\"bp\">·</span> <span class=\"n\">use</span> <span class=\"n\">w</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">wh</span><span class=\"o\">]</span>\n      <span class=\"n\">ring</span>\n    <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">right</span>\n  <span class=\"bp\">|</span> <span class=\"n\">dswap</span> <span class=\"n\">_</span> <span class=\"n\">a_ih</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"n\">right</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">a_ih</span>\n    <span class=\"n\">constructor</span>\n    <span class=\"n\">exact</span> <span class=\"n\">right</span>\n    <span class=\"n\">exact</span> <span class=\"n\">left</span>\n  <span class=\"bp\">|</span> <span class=\"n\">dodd</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">a_ih</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"o\">⟨⟨</span><span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">wh</span><span class=\"o\">⟩,</span> <span class=\"n\">right</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">a_ih</span>\n    <span class=\"n\">constructor</span>\n    <span class=\"bp\">·</span> <span class=\"n\">use</span> <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">w</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">wh</span><span class=\"o\">]</span>\n      <span class=\"n\">ring</span>\n    <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">right</span>\n</code></pre></div>",
        "id": 363857949,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686007259
    },
    {
        "content": "<p>what do you mean by \"does it make sense to pursue this style\"? What level of this proof / formalization are you questioning</p>",
        "id": 363858043,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686007300
    },
    {
        "content": "<p>I think mathlib would generally not have the definition <code>BinaryGCD</code> unless it is required by something else</p>",
        "id": 363858131,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686007325
    },
    {
        "content": "<p>this is also (as pointed out in the blog post) not really an algorithm</p>",
        "id": 363858170,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686007350
    },
    {
        "content": "<p>it's a bunch of legal moves you can do but no decision procedure among them</p>",
        "id": 363858205,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686007379
    },
    {
        "content": "<p>for example you could just keep applying <code>dswap</code> and not really approach a solution</p>",
        "id": 363858243,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686007395
    },
    {
        "content": "<p>if the goal is just to replicate the formalization in the blog post then this looks correct</p>",
        "id": 363858375,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686007466
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/363858043\">said</a>:</p>\n<blockquote>\n<p>what do you mean by \"does it make sense to pursue this style\"? What level of this proof / formalization are you questioning</p>\n</blockquote>\n<p>Exactly. It isn't an algorithm. It is just an inductively defined predicate, and we check if objects satisfying this predicate have the properties we seek.</p>",
        "id": 363858821,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1686007711
    },
    {
        "content": "<p>It doesn't deal with messy implementation details</p>",
        "id": 363858869,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1686007744
    },
    {
        "content": "<p>only with the structural aspects. This is close to the level a lot of algorithms folks operate in.</p>",
        "id": 363858989,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1686007807
    },
    {
        "content": "<p>we arguably already have the structural aspects, this is just theorems like <code>gcd (x + y) y = gcd x y</code></p>",
        "id": 363859170,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686007935
    },
    {
        "content": "<p>where <code>gcd</code> is here being treated as just the abstract gcd and not a particular algorithm to compute it</p>",
        "id": 363859210,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686007971
    },
    {
        "content": "<p>each of the <code>BinaryGCD</code> constructors should correspond to an existing theorem about gcd</p>",
        "id": 363859269,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686008019
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/363859269\">said</a>:</p>\n<blockquote>\n<p>each of the <code>BinaryGCD</code> constructors should correspond to an existing theorem about gcd</p>\n</blockquote>\n<p>okay. Question 2: At present what is the best lean equivalent for <code>auto</code> in isabelle?</p>",
        "id": 363860224,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1686008597
    },
    {
        "content": "<p>By the way, <code>BinaryGCD</code> does not compute the same result as <code>Int.gcd</code>, because the first clause says <code>dzero (x : ℤ) : BinaryGCD x 0 x</code> but <code>Int.gcd x 0 = x.natAbs</code></p>",
        "id": 363860230,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686008600
    },
    {
        "content": "<p>i.e. this gcd function produces negative results but ours never does</p>",
        "id": 363860256,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686008631
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/363860224\">said</a>:</p>\n<blockquote>\n<p>Question 2: At present what is the best lean equivalent for <code>auto</code> in isabelle?</p>\n</blockquote>\n<p><code>aesop</code></p>",
        "id": 363860264,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686008641
    },
    {
        "content": "<p>I switched to <code>Int</code> to use <code>ring</code>. Because of the subtraction in <code>dstep</code> zify doesn't work very well if I use Nat.</p>",
        "id": 363860338,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1686008670
    },
    {
        "content": "<p>oh I see, the original was about Nat</p>",
        "id": 363860372,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686008706
    },
    {
        "content": "<p>you shouldn't change the theorem statement, that's cheating</p>",
        "id": 363860391,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686008726
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/363860264\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/363860224\">said</a>:</p>\n<blockquote>\n<p>Question 2: At present what is the best lean equivalent for <code>auto</code> in isabelle?</p>\n</blockquote>\n<p><code>aesop</code></p>\n</blockquote>\n<p><code>aesop</code> seems to require a lot of fiddling to make it work. I read the paper, and they are quite explicit that it is a whitebox search tactic. Most of the time  I just call <code>aesop</code> I get <code>failed to prove the goal after exhaustive search.</code></p>",
        "id": 363860513,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1686008807
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">BinaryGCD</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">dzero</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">BinaryGCD</span> <span class=\"n\">x</span> <span class=\"mi\">0</span> <span class=\"n\">x</span>\n  <span class=\"bp\">|</span> <span class=\"n\">deven</span> <span class=\"o\">:</span> <span class=\"n\">BinaryGCD</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"bp\">→</span> <span class=\"n\">BinaryGCD</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">z</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">dodd</span> <span class=\"o\">:</span> <span class=\"n\">BinaryGCD</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"bp\">→</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">∣</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">BinaryGCD</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"n\">z</span>\n  <span class=\"bp\">|</span> <span class=\"n\">dstep</span> <span class=\"o\">:</span> <span class=\"n\">BinaryGCD</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"bp\">→</span> <span class=\"n\">y</span> <span class=\"bp\">&lt;</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">BinaryGCD</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span>\n  <span class=\"bp\">|</span> <span class=\"n\">dswap</span> <span class=\"o\">:</span> <span class=\"n\">BinaryGCD</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"bp\">→</span> <span class=\"n\">BinaryGCD</span> <span class=\"n\">y</span> <span class=\"n\">x</span> <span class=\"n\">z</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">BinaryGCD_Div</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">BinaryGCD</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">z</span> <span class=\"bp\">∣</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">z</span> <span class=\"bp\">∣</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">h</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">dzero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">simp</span>\n  <span class=\"bp\">|</span> <span class=\"n\">deven</span> <span class=\"n\">_</span> <span class=\"n\">a_ih</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"o\">⟨⟨</span><span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">wh</span><span class=\"o\">⟩,</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">vh</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">a_ih</span>\n    <span class=\"n\">constructor</span>\n    <span class=\"bp\">·</span> <span class=\"n\">use</span> <span class=\"n\">w</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">wh</span><span class=\"o\">,</span> <span class=\"n\">Nat.mul_assoc</span><span class=\"o\">]</span>\n    <span class=\"bp\">·</span> <span class=\"n\">use</span> <span class=\"n\">v</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">vh</span><span class=\"o\">,</span> <span class=\"n\">Nat.mul_assoc</span><span class=\"o\">]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">dstep</span> <span class=\"n\">_</span> <span class=\"n\">yx</span> <span class=\"n\">a_h</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"n\">right</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">a_h</span>\n    <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">wh</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.dvd_add</span> <span class=\"n\">left</span> <span class=\"n\">right</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.sub_add_cancel</span> <span class=\"o\">(</span><span class=\"n\">Nat.le_of_lt</span> <span class=\"n\">yx</span><span class=\"o\">)]</span> <span class=\"n\">at</span> <span class=\"n\">wh</span>\n    <span class=\"n\">constructor</span>\n    <span class=\"bp\">·</span> <span class=\"n\">use</span> <span class=\"n\">w</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">wh</span><span class=\"o\">]</span>\n    <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">right</span>\n  <span class=\"bp\">|</span> <span class=\"n\">dswap</span> <span class=\"n\">_</span> <span class=\"n\">a_ih</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"n\">right</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">a_ih</span>\n    <span class=\"n\">constructor</span>\n    <span class=\"n\">exact</span> <span class=\"n\">right</span>\n    <span class=\"n\">exact</span> <span class=\"n\">left</span>\n  <span class=\"bp\">|</span> <span class=\"n\">dodd</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">a_ih</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"o\">⟨⟨</span><span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">wh</span><span class=\"o\">⟩,</span> <span class=\"n\">right</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">a_ih</span>\n    <span class=\"n\">constructor</span>\n    <span class=\"bp\">·</span> <span class=\"n\">use</span> <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">w</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">wh</span><span class=\"o\">]</span>\n      <span class=\"n\">ring</span>\n    <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">right</span>\n</code></pre></div>",
        "id": 363860527,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686008816
    },
    {
        "content": "<p><code>auto</code> also requires a lot of fiddling, the library is marked up quite a bit to make it work</p>",
        "id": 363860602,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686008878
    },
    {
        "content": "<p>My <code>nat</code> version was longer than this. At some point I remember that <code>library_search</code> was not returning useful results (this is before recent improvements as I recall).</p>",
        "id": 363860688,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1686008921
    },
    {
        "content": "<p>I'm sure it was, <code>Nat.sub_add_cancel</code> is a really important lemma to use here and our tactics won't use it automatically for the most part</p>",
        "id": 363860733,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686008956
    },
    {
        "content": "<p>In any case, the length of the proof compared to Isabelle's was a sufficient deterrent for me to put this off back then.</p>",
        "id": 363861311,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1686009317
    },
    {
        "content": "<p>well the proof can still be golfed a lot</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">BinaryGCD_Div</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">BinaryGCD</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">z</span> <span class=\"bp\">∣</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">z</span> <span class=\"bp\">∣</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">h</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">dzero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">simp</span>\n  <span class=\"bp\">|</span> <span class=\"n\">deven</span> <span class=\"n\">_</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">mul_dvd_mul_left</span> <span class=\"n\">_</span> <span class=\"n\">ih.1</span><span class=\"o\">,</span> <span class=\"n\">mul_dvd_mul_left</span> <span class=\"n\">_</span> <span class=\"n\">ih.2</span><span class=\"o\">⟩</span>\n  <span class=\"bp\">|</span> <span class=\"n\">dstep</span> <span class=\"n\">_</span> <span class=\"n\">yx</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">Nat.sub_add_cancel</span> <span class=\"o\">(</span><span class=\"n\">Nat.le_of_lt</span> <span class=\"n\">yx</span><span class=\"o\">)]</span> <span class=\"n\">using</span> <span class=\"n\">Nat.dvd_add</span> <span class=\"n\">h.1</span> <span class=\"n\">h.2</span><span class=\"o\">,</span> <span class=\"n\">h.2</span><span class=\"o\">⟩</span>\n  <span class=\"bp\">|</span> <span class=\"n\">dswap</span> <span class=\"n\">_</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">ih.2</span><span class=\"o\">,</span> <span class=\"n\">ih.1</span><span class=\"o\">⟩</span>\n  <span class=\"bp\">|</span> <span class=\"n\">dodd</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">dvd_mul_of_dvd_right</span> <span class=\"n\">ih.1</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">ih.2</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 363861447,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686009408
    },
    {
        "content": "<p>it's not really in the same style as just calling <code>blast</code> on everything, but that's probably possible</p>",
        "id": 363861618,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686009521
    },
    {
        "content": "<p>This syntax is quite convenient for induction. In my syntax I was getting a whole different set of variables than the one I started with <code>(BinaryGCD x y z)</code> and just keeping track of which variable was getting used  at what point was painful</p>",
        "id": 363861666,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1686009553
    },
    {
        "content": "<p>well it is the induction tactic after all :)</p>",
        "id": 363861696,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686009577
    },
    {
        "content": "<p>blast is a tableau prover right? In principle shouldn't it be possible to implement a lean version (within whatever strange limitations that come with DTT unification)</p>",
        "id": 363862092,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1686009781
    },
    {
        "content": "<p>lean has <code>tauto</code> and <code>itauto</code> for propositional proving</p>",
        "id": 363862122,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686009813
    },
    {
        "content": "<p>lean 3 had <code>cc</code> and <code>eblast</code> and a <code>smt_tactic</code> mode but it was not maintained</p>",
        "id": 363862205,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686009859
    },
    {
        "content": "<p>Here's a more blasty proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">BinaryGCD_Div</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">BinaryGCD</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">z</span> <span class=\"bp\">∣</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">z</span> <span class=\"bp\">∣</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">h</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">dstep</span> <span class=\"n\">_</span> <span class=\"n\">yx</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">Nat.sub_add_cancel</span> <span class=\"o\">(</span><span class=\"n\">Nat.le_of_lt</span> <span class=\"n\">yx</span><span class=\"o\">)]</span> <span class=\"n\">using</span> <span class=\"n\">Nat.dvd_add</span> <span class=\"n\">h.1</span> <span class=\"n\">h.2</span><span class=\"o\">,</span> <span class=\"n\">h.2</span><span class=\"o\">⟩</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">aesop</span> <span class=\"o\">(</span><span class=\"n\">add</span> <span class=\"n\">safe</span> <span class=\"n\">mul_dvd_mul_left</span><span class=\"o\">,</span> <span class=\"n\">unsafe</span> <span class=\"mi\">50</span><span class=\"bp\">%</span> <span class=\"n\">dvd_mul_of_dvd_right</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 363863109,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686010533
    },
    {
        "content": "<p>to mimic the isabelle proof we need a better <code>Nat.dvd_sub</code> lemma</p>",
        "id": 363863271,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686010623
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">Nat.dvd_sub_iff_left</span> <span class=\"o\">{</span><span class=\"n\">k</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">mn</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">k</span> <span class=\"bp\">∣</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">k</span> <span class=\"bp\">∣</span> <span class=\"n\">m</span> <span class=\"bp\">↔</span> <span class=\"n\">k</span> <span class=\"bp\">∣</span> <span class=\"n\">m</span> <span class=\"bp\">-</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">Nat.sub_add_cancel</span> <span class=\"n\">mn</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"o\">(</span><span class=\"n\">Nat.dvd_add_iff_left</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"n\">m</span> <span class=\"bp\">-</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">BinaryGCD_Div</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">BinaryGCD</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">z</span> <span class=\"bp\">∣</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">z</span> <span class=\"bp\">∣</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">h</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">dstep</span> <span class=\"n\">_</span> <span class=\"n\">yx</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"o\">⟨(</span><span class=\"n\">Nat.dvd_sub_iff_left</span> <span class=\"o\">(</span><span class=\"n\">Nat.le_of_lt</span> <span class=\"n\">yx</span><span class=\"o\">)</span> <span class=\"n\">h.2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">h.1</span><span class=\"o\">,</span> <span class=\"n\">h.2</span><span class=\"o\">⟩</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">aesop</span> <span class=\"o\">(</span><span class=\"n\">add</span> <span class=\"n\">safe</span> <span class=\"n\">mul_dvd_mul_left</span><span class=\"o\">,</span> <span class=\"n\">unsafe</span> <span class=\"mi\">50</span><span class=\"bp\">%</span> <span class=\"n\">dvd_mul_of_dvd_right</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>maybe there is a way to get <code>aesop</code> to find the <code>dstep</code> proof, not sure</p>",
        "id": 363863779,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686011023
    },
    {
        "content": "<p>So having read a bit about aesop rule sets and attributes, and having taken a peek at the continuity tactic, would a similar divisibility tactic written on top of aesop make sense? This is of course to avoid having to configure aesop posthoc after figuring out which theorems are needed.</p>",
        "id": 364035896,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1686064875
    },
    {
        "content": "<p>Yes. Although first we should fix the current <code>aesop</code> based <code>continuity</code> implementation, which is broken in many places. It's not clear to me that it's possible to implement it properly on top of <code>aesop</code>, although I hope so. Just look for porting notes mentioning <code>continuity</code> to find test cases. :-)</p>",
        "id": 364128595,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1686091487
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/363858170\">said</a>:</p>\n<blockquote>\n<p>this is also (as pointed out in the blog post) not really an algorithm</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I found  one of the papers I was looking for, to explain why I think inductively defining invariants and proving them might be tenable  : <a href=\"https://dl.acm.org/doi/pdf/10.1145/3519939.3523707\">https://dl.acm.org/doi/pdf/10.1145/3519939.3523707</a></p>",
        "id": 364263416,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1686141106
    },
    {
        "content": "<p>there is nothing about this formalization that isn't doable, after all we basically did it above</p>",
        "id": 364263589,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686141143
    },
    {
        "content": "<p>it's just, not really an algorithm</p>",
        "id": 364263651,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686141156
    },
    {
        "content": "<p>if your goal is to describe an algorithm you probably want something you can <code>#eval</code></p>",
        "id": 364263959,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686141232
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/364263589\">said</a>:</p>\n<blockquote>\n<p>there is nothing about this formalization that isn't doable, after all we basically did it above</p>\n</blockquote>\n<p>The other paper is cited by this one and is more relevant : <a href=\"https://link.springer.com/chapter/10.1007/978-3-642-35308-6_9\">https://link.springer.com/chapter/10.1007/978-3-642-35308-6_9</a></p>",
        "id": 364264112,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1686141257
    },
    {
        "content": "<p>It shows how to extract a total computable function from an inductive relation</p>",
        "id": 364264158,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1686141271
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/364263651\">said</a>:</p>\n<blockquote>\n<p>it's just, not really an algorithm</p>\n</blockquote>\n<p>Agreed that it isn't an algorithm and that it is doable. I am making the case that this level of abstraction captures what algorithms peopel normally do and as the papers I linked argue, functions can be extracted from some of them.</p>",
        "id": 364265417,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1686141587
    },
    {
        "content": "<p>I disagree with that</p>",
        "id": 364265494,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686141602
    },
    {
        "content": "<p>algorithms people don't write inductive types</p>",
        "id": 364265571,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686141610
    },
    {
        "content": "<p>they write pseudocode</p>",
        "id": 364265593,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686141619
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/364265593\">said</a>:</p>\n<blockquote>\n<p>they write pseudocode</p>\n</blockquote>\n<p>Which would barely qualify as an algorithm these days (which is why implementing most modern algorithms in code is non-trivial).</p>",
        "id": 364266089,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1686141722
    },
    {
        "content": "<p>Would it help to adopt an approach that combines defining terminating functions and inductive properties? One part of it would be to write functions that do the computation, and proving that they satisfy some inductive property (whose arms are invariants). Another part would be proving theorems about the inductive prop. According to the papers I linked, it should be possible to extract functions from (some?) such inductive props.</p>",
        "id": 364272160,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1686143036
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/364266089\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/364265593\">said</a>:</p>\n<blockquote>\n<p>they write pseudocode</p>\n</blockquote>\n<p>Which would barely qualify as an algorithm these days (which is why implementing most modern algorithms in code is non-trivial).</p>\n</blockquote>\n<p>What's wrong with publishing algorithms in pseudocode?</p>",
        "id": 364752745,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1686294820
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/364752745\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/364266089\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory/near/364265593\">said</a>:</p>\n<blockquote>\n<p>they write pseudocode</p>\n</blockquote>\n<p>Which would barely qualify as an algorithm these days (which is why implementing most modern algorithms in code is non-trivial).</p>\n</blockquote>\n<p>What's wrong with publishing algorithms in pseudocode?</p>\n</blockquote>\n<p>Nothing if  they are written well. Big emphasis on \"if\"</p>",
        "id": 364771092,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1686299374
    },
    {
        "content": "<p>I think I should elaborate on that point. I have been discussing the idea of building a library of formalized algorithms and at least their correctness with a few leading people in the field. This issue of how to specify algorithms came up quite often. We agreed that if one starts looking at the algorithms literature, extracting something implementable out of the pseudocode provided in most papers is non trivial enough to warrant a masters thesis lasting a year for each of them. This applies to anything beyond basic clrs (or other equivalent textbooks) stuff. </p>\n<p>This is a problem entirely separate from actually constructing a model in which to specify such an implementation and prove something about it. This is not true for all papers of course and quite a lot of good ones exist. But the current state of affairs is highly non-ideal to pursue an implementation focused approach. Just implementing them in a normal imperative language and measuring their performance, without proving anything about them would be worth a paper or two.</p>",
        "id": 364959580,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1686341317
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 364961183,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1686341843
    },
    {
        "content": "<p>I guess that this is one of the reasons that there are so few entries in Isabelle's AFP for algorithms and data structures, relative to how much content there is out there. There are 40 entries under algorithms and 65 entries under data structures, stretching back to 2004. Not all of them are directly concerned with topics that an algorithms textbook would consider, while some are about mathematical results that algorithms use.</p>",
        "id": 364961263,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1686341875
    },
    {
        "content": "<p>Is conversion <code>TM1</code> to <code>TM2</code> missing in <a href=\"https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Computability/TuringMachine.lean\">https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Computability/TuringMachine.lean</a> or did I just overlook it?</p>",
        "id": 389124030,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1693899416
    },
    {
        "content": "<p>There is the <code>TM2to1</code> namespace... if you mean a simulation of TM1 machines on TM2, there isn't much need, the interesting direction is that TM2 machines can be simulated on TM1. For all the reverse implications it is easiest to just have something close the cycle and prove everything turing-equivalent</p>",
        "id": 389143541,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693906027
    },
    {
        "content": "<p>Yes, this is exactly what I had on my mind!</p>\n<p>So, for example, if I prove that <code>TM0</code> can be simulated by <code>Grammar</code> and that <code>Grammar</code> can be simulated by <code>TM2</code> then all of <code>TM0</code>, <code>TM1</code>, <code>TM2</code>, and <code>Grammar</code> will be proven equivalent regarding computability, right?</p>",
        "id": 389164909,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1693912492
    }
]