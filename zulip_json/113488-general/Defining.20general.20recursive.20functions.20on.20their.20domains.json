[
    {
        "content": "<p>Given an arbitrary general recursive function, how can we (1) define the domain on which it is total, and (2) define the function as a <code>PFun</code>? Here's my method which is in theory generally workable:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c\">/-</span>\n<span class=\"cm\">To define a function</span>\n\n<span class=\"cm\">  f(0) = f(1) = 0</span>\n<span class=\"cm\">  f(n) = f(n/2) + 1  for n even</span>\n<span class=\"cm\">  f(n) = f(3*n+1) + 1 for n odd</span>\n\n<span class=\"cm\">But we don't know whether it is total yet. Can we</span>\n<span class=\"cm\">define f as a `PFun`? To do that, we need a</span>\n<span class=\"cm\">predicate for its domain.</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Domain</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">Domain</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">one</span> <span class=\"o\">:</span> <span class=\"n\">Domain</span> <span class=\"mi\">1</span>\n<span class=\"c1\">-- We can have cycles here, eg.</span>\n<span class=\"c1\">--  even : Domain n → Domain (2*n)</span>\n<span class=\"c1\">-- But this is slightly cleaner.</span>\n<span class=\"bp\">|</span> <span class=\"n\">even</span> <span class=\"o\">:</span> <span class=\"n\">Domain</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Domain</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">odd</span> <span class=\"o\">:</span> <span class=\"n\">Domain</span> <span class=\"o\">(</span><span class=\"mi\">6</span><span class=\"bp\">*</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">10</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Domain</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">3</span><span class=\"o\">)</span>\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">If we define `Domain` as a Type, then it is</span>\n<span class=\"cm\">known as the Bove–Capretta predicate, and we can</span>\n<span class=\"cm\">happily recurse along that, giving</span>\n<span class=\"cm\">  f (n : Nat) : Domain n → Nat</span>\n<span class=\"cm\">And if one day we manage to prove ∀ n, Domain n</span>\n<span class=\"cm\">then we can get the total function.</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Prec</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">even</span> <span class=\"o\">:</span> <span class=\"n\">Prec</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">odd</span> <span class=\"o\">:</span> <span class=\"n\">Prec</span> <span class=\"o\">(</span><span class=\"mi\">6</span><span class=\"bp\">*</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">10</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">3</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">trans</span> <span class=\"o\">:</span> <span class=\"n\">Prec</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">Prec</span> <span class=\"n\">n</span> <span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">Prec</span> <span class=\"n\">m</span> <span class=\"n\">p</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Prec'</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Subtype</span> <span class=\"n\">Domain</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">Prec</span> <span class=\"n\">u.val</span> <span class=\"n\">v.val</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> Mostly just do the obvious thing, induction</span>\n<span class=\"cm\">on `Prec` is now available because we are proving</span>\n<span class=\"cm\">a `Prop` too. -/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">WfPrec'</span> <span class=\"o\">:</span> <span class=\"n\">WellFounded</span> <span class=\"n\">Prec'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Now we just do well-founded recursion, giving <code>Subtype Domain -&gt; Nat</code>, which can then be converted to a <code>PFun</code>. Is there a neater way to do this? And can this be fully automated?</p>",
        "id": 361769324,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1685285315
    },
    {
        "content": "<p>Can you write a <code>sorry</code> for your <code>PFun</code> question?</p>",
        "id": 361810869,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685302374
    },
    {
        "content": "<p>It's not clear to me what you're asking for</p>",
        "id": 361810892,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685302383
    },
    {
        "content": "<p>Use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PFun.equivSubtype#doc\">docs4#PFun.equivSubtype</a></p>",
        "id": 361840612,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1685323373
    },
    {
        "content": "<p>After looking at the library I think the current fastest way is to write it as a fixpoint, then using PFun.fix</p>",
        "id": 361840713,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1685323447
    }
]