[
    {
        "content": "<p>Hi. When I have</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">foo</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LT</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"o\">]</span>\n<span class=\"w\">         </span><span class=\"o\">[</span><span class=\"n\">DecidableRel</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·&lt;·</span><span class=\"o\">)]</span>\n<span class=\"w\">         </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">idx</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ordering</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">idx</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">[</span><span class=\"n\">idx</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">LT</span><span class=\"bp\">.</span><span class=\"n\">lt</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span>\n<span class=\"w\">                      </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">idx</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"w\">                      </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">Ordering</span><span class=\"bp\">.</span><span class=\"n\">gt</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Ordering</span><span class=\"bp\">.</span><span class=\"n\">gt</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Ordering</span><span class=\"bp\">.</span><span class=\"n\">lt</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Ordering</span><span class=\"bp\">.</span><span class=\"n\">eq</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">foo</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ord</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ord</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">compare</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n</code></pre></div>\n<p>I get an error:<br>\n<code>error: LeanSitter/Length.lean:43:24: typeclass instance problem is stuck, it is often due to metavariables</code></p>\n<p>When I change '[DecidableRel (·&lt;·)]' to ' [DecidableRel (fun a b : foo =&gt; @LT.lt foo inst a b)]' I get </p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>rror: LeanSitter/Length.lean:42:4: fail to show termination for\n  LeanSitter.Length.comp\nwith errors\nfailed to infer structural recursion:\nNot considering parameter foo of LeanSitter.Length.comp:\n  it is unchanged in the recursive calls\nNot considering parameter inst of LeanSitter.Length.comp:\n  it is unchanged in the recursive calls\nNot considering parameter #3 of LeanSitter.Length.comp:\n  it is unchanged in the recursive calls\nNot considering parameter a of LeanSitter.Length.comp:\n  it is unchanged in the recursive calls\nNot considering parameter b of LeanSitter.Length.comp:\n  it is unchanged in the recursive calls\nCannot use parameter idx:\n  failed to eliminate recursive application\n    comp a b (idx + 1)\n\n\nfailed to prove termination, possible solutions:\n  - Use `have`-expressions to prove the remaining goals\n  - Use `termination_by` to specify a different well-founded relation\n  - Use `decreasing_by` to specify your own tactic for discharging this kind of goal\nidx : Nat\n⊢ idx + 1 &lt; idx\n</code></pre></div>\n<p>I don't understand what's going on. What do I need to do?</p>",
        "id": 561781017,
        "sender_full_name": "Chris Moline",
        "timestamp": 1764812776
    },
    {
        "content": "<p>the termination prover couldn't automatically prove that your algorithm doesn't go into an infinite loop</p>",
        "id": 561782235,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764813648
    },
    {
        "content": "<p>Maybe like this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">foo</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LT</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"o\">]</span>\n<span class=\"w\">         </span><span class=\"o\">[</span><span class=\"n\">DecidableRel</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">LT</span><span class=\"bp\">.</span><span class=\"n\">lt</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)]</span>\n<span class=\"w\">         </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">idx</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ordering</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">idx</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hb</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">[</span><span class=\"n\">idx</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">LT</span><span class=\"bp\">.</span><span class=\"n\">lt</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span>\n<span class=\"w\">                      </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">idx</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"w\">                      </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">Ordering</span><span class=\"bp\">.</span><span class=\"n\">gt</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Ordering</span><span class=\"bp\">.</span><span class=\"n\">gt</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Ordering</span><span class=\"bp\">.</span><span class=\"n\">lt</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Ordering</span><span class=\"bp\">.</span><span class=\"n\">eq</span>\n<span class=\"n\">termination_by</span>\n<span class=\"w\">  </span><span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">idx</span>\n<span class=\"n\">decreasing_by</span>\n<span class=\"w\">  </span><span class=\"n\">rcases</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"bp\">.</span><span class=\"n\">getElem_of_getElem?</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"bp\">⟨_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_⟩</span>\n<span class=\"w\">  </span><span class=\"n\">rcases</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"bp\">.</span><span class=\"n\">getElem_of_getElem?</span><span class=\"w\"> </span><span class=\"n\">hb</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"bp\">⟨_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_⟩</span>\n<span class=\"w\">  </span><span class=\"n\">omega</span>\n</code></pre></div>\n<p>More example how to use <code>termination_by</code> and <code>decreasing_by</code> can be found <a href=\"https://lean-lang.org/theorem_proving_in_lean4/Induction-and-Recursion/#well-founded-recursion-and-induction\">here</a> in <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/\">#tpil</a>.</p>",
        "id": 561826992,
        "sender_full_name": "Malvin Gattinger",
        "timestamp": 1764839494
    },
    {
        "content": "<p>For your <code>DecidableRel</code> problem: use <code>[DecidableLT foo]</code> instead. For your termination problem: you can use something like <code>termination_by a.size - idx</code> (i.e the difference of size and index should decrease in recursive calls). With some other adjustments:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LT</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableLT</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">idx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ordering</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">idx</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">[</span><span class=\"n\">idx</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">idx</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">Ordering</span><span class=\"bp\">.</span><span class=\"n\">gt</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Ordering</span><span class=\"bp\">.</span><span class=\"n\">gt</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Ordering</span><span class=\"bp\">.</span><span class=\"n\">lt</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Ordering</span><span class=\"bp\">.</span><span class=\"n\">eq</span>\n<span class=\"n\">termination_by</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">idx</span>\n<span class=\"n\">decreasing_by</span><span class=\"w\"> </span><span class=\"n\">grind</span>\n</code></pre></div>\n<p>Although I will note that there already is an <code>Ord</code> instance for <code>Array</code>s, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Array.instOrd#doc\">docs#Array.instOrd</a></p>",
        "id": 561941803,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1764870559
    },
    {
        "content": "<p>Thank you very much for the help. I didn't know you could write 'a : a[idx]?' to bind the result of 'a[idx]?'. I also haven't covered much for tactics either so to learn about rcases and grind was good. I've updated my code to use the array Ord instance.</p>\n<p>I will strive to do better in the hopes of one day being useful to the lean community.</p>",
        "id": 561971863,
        "sender_full_name": "Chris Moline",
        "timestamp": 1764881292
    }
]