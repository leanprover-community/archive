[
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">Left</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">Right</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"kn\">instance</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Coe</span><span class=\"w\"> </span><span class=\"n\">Left</span><span class=\"w\"> </span><span class=\"n\">Right</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"kn\">instance</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HasSubset</span><span class=\"w\"> </span><span class=\"n\">Right</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Left</span><span class=\"o\">)</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Right</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">⊆</span><span class=\"n\">B</span>\n</code></pre></div>\n<p>Hey, I just noticed that the above MRE doesn't work since I'm getting an error that it can't convert <code>B</code> of type <code>Right</code> to type <code>Left</code>. Could this be because it has the wrong elaborator? Sorry if this isn't the right place to put it.</p>",
        "id": 478912853,
        "sender_full_name": "Adalynn",
        "timestamp": 1729860744
    },
    {
        "content": "<p>Putting an explicit coercion on <code>a</code> solves it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">Left</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">Right</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"kn\">instance</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Coe</span><span class=\"w\"> </span><span class=\"n\">Left</span><span class=\"w\"> </span><span class=\"n\">Right</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"kn\">instance</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HasSubset</span><span class=\"w\"> </span><span class=\"n\">Right</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Left</span><span class=\"o\">)</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Right</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"c1\">--works</span>\n</code></pre></div>",
        "id": 478914049,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1729861156
    },
    {
        "content": "<p>Oh yeah I know that, it just... feels as if the elaborator should be the same as <code>=</code>? For <code>=</code> it automatically coes.</p>",
        "id": 478914316,
        "sender_full_name": "Adalynn",
        "timestamp": 1729861236
    },
    {
        "content": "<p>You are correct that <code>a⊆B</code> has no special support. This one is tricky because generally it's for types like <code>Set X</code> or <code>Finset X</code> that are functorial, where you might want something that can compute a target functor to coerce everything to. Maybe a target carrier type too.</p>\n<p>You could try your luck with the <code>binrel%</code> elaborator though. It does make your example work.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">local</span><span class=\"w\"> </span><span class=\"kn\">macro_rules</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">binrel</span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"n\">HasSubset</span><span class=\"bp\">.</span><span class=\"n\">Subset</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">B</span>\n<span class=\"c1\">-- Coe.coe a ⊆ B : Prop</span>\n</code></pre></div>",
        "id": 478958218,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729876139
    },
    {
        "content": "<p>(Relately, mathlib has an <code>fbinop%</code> elaborator to support being able to create products of set-like objects with <code>×ˢ</code> notation.)</p>",
        "id": 478958421,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729876212
    },
    {
        "content": "<p>Oh, that should work well! I had a workaround (literally just overloading the notation, admittedly not the best solution), but this feels more like the intended/correct way to do it that won't run into problems down the line. Thanks!</p>",
        "id": 478961314,
        "sender_full_name": "Adalynn",
        "timestamp": 1729877430
    },
    {
        "content": "<p>This isn't great though because <code>binrel%</code> is meant to be for arithmetic binary relations. It won't interact with intersections and unions for example, since these are not using the <code>binop%</code> elaborator.</p>",
        "id": 478962047,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729877729
    },
    {
        "content": "<p>Ah, yeah. I'll play it by ear: but I came from lean 3 and I just ditched preludes when I worked on my from-scratch ZFC file I work on when I'm bored. So heterogeneous intersections will probably have to be using overloading.</p>",
        "id": 478963480,
        "sender_full_name": "Adalynn",
        "timestamp": 1729878350
    }
]