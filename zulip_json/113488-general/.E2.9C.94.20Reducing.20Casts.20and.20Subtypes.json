[
    {
        "content": "<p>Is there a way to reduce a term of this form:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">(</span><span class=\"bp\">⋯</span><span class=\"w\"> </span><span class=\"bp\">▸</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">⋯⟩</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"m\">1</span>\n</code></pre></div>\n<p>My intuition is that the cast can only effect the second projection of the subtype, so this should just reduce to <code>x</code>, but I can't seem to make that happen.</p>",
        "id": 510489450,
        "sender_full_name": "Harry Goldstein",
        "timestamp": 1743951035
    },
    {
        "content": "<p>My intuition is that if the first ... is a proof that x=y then the cast can certainly affect the first projection.</p>",
        "id": 510491362,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1743952421
    },
    {
        "content": "<p>i imagine the solution to prove equality of the casts will be along the lines of <code>cases h ; rfl</code> where <code>h</code> is the equality on the lhs</p>",
        "id": 510491667,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1743952640
    },
    {
        "content": "<p>in order to verify, a bit more context or a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> would be nice</p>",
        "id": 510491699,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1743952678
    },
    {
        "content": "<p>This MWE might be too minimal, but it illustrates my point:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">})</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">conv</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">congr</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">eq_comm</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"bp\">#</span><span class=\"n\">reduce</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"m\">1</span>\n</code></pre></div>\n<p>I want this to reduce to <code>x.1</code> but it doesn't.</p>",
        "id": 510496048,
        "sender_full_name": "Harry Goldstein",
        "timestamp": 1743955688
    },
    {
        "content": "<p>yea, that's not happening with lean as-is</p>",
        "id": 510496108,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1743955737
    },
    {
        "content": "<p>i believe lean would need to implement something like observational type theory for that to happen</p>",
        "id": 510496140,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1743955760
    },
    {
        "content": "<p>(i.e. maybe in lean 5, but don't expect that to happen within like 4 years. \\j)</p>",
        "id": 510496240,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1743955818
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"587858\">@Fernando Chu</span> can you check my understanding of observational type theory here? this <em>does</em> reduce in observational type theory, right?</p>",
        "id": 510496466,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1743955968
    },
    {
        "content": "<p>OK, that tracks. Are there unsound / unsafe / \"outside the theory\" things that I could do here? I really need this as sort of an extraction step, because I want to show the value to the user.</p>",
        "id": 510503556,
        "sender_full_name": "Harry Goldstein",
        "timestamp": 1743960788
    },
    {
        "content": "<p>[clarification: not only is there no talk at all about Lean 5 right now, but also there is certainly no talk about implementing a new type theory; the above comment about Lean 5 is really disinformation]</p>",
        "id": 510504144,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1743961242
    },
    {
        "content": "<p>Understood. I took it in the spirit that (I think) it was intended, which is to say \"don't hold your breath.\" Although like I said, if there is some workaround that folks can help me find, I'd really appreciate it.</p>\n<p>For a bit of context: I'm working on a project right now where I'm implementing a program synthesis algorithm entirely using proof search. I use tactics to construct a term of type <code>{p : Prog // f p}</code> for some specification <code>f</code>, and then I reduce that term to get an appropriate <code>p</code>. It'd be unfortunate if things fell apart at that last step, because the previous steps have worked great so far.</p>\n<p>(Anticipating the usual concerns: I'm assuming <code>f</code> fully specifies the desired <code>p</code>, so it doesn't matter what proof the tactics find, and <code>Prog</code> has Lean functions embedded in it, so it's not as simple as just pretty-printing.)</p>",
        "id": 510505288,
        "sender_full_name": "Harry Goldstein",
        "timestamp": 1743962101
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113488-general/topic/Reducing.20Casts.20and.20Subtypes/near/510504144\">said</a>:</p>\n<blockquote>\n<p>[clarification: not only is there no talk at all about Lean 5 right now, but also there is certainly no talk about implementing a new type theory; the above comment about Lean 5 is really disinformation]</p>\n</blockquote>\n<p>indeed, my comment was meant as a joke</p>",
        "id": 510505355,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1743962160
    },
    {
        "content": "<p>This indeed reduces in observational type theory, but even in Lean you can prove the equality <code>(y f x).1 = x.1</code>, so for your particular goal you could make this a simp lemma I guess</p>",
        "id": 510508141,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1743964187
    },
    {
        "content": "<p>Actually that raises a good question — how <em>do</em> I prove that lemma?</p>",
        "id": 510514392,
        "sender_full_name": "Harry Goldstein",
        "timestamp": 1743968984
    },
    {
        "content": "<p><code>cases</code> on the proofs used for rewriting tends to do the trick here, i think</p>",
        "id": 510514488,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1743969051
    },
    {
        "content": "<p>Like this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">pp</span><span class=\"bp\">.</span><span class=\"n\">proofs</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">cast</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">proof_1</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I get the error</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">dependent</span><span class=\"w\"> </span><span class=\"n\">elimination</span><span class=\"w\"> </span><span class=\"n\">failed</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">failed</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">solve</span><span class=\"w\"> </span><span class=\"n\">equation</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 510514762,
        "sender_full_name": "Harry Goldstein",
        "timestamp": 1743969249
    },
    {
        "content": "<p>This turned out to be surprisingly tricky, but <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=HEq#doc\">docs#HEq</a> is your friend (sometimes)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Logic</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">GeneralizeProofs</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">})</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">conv</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">congr</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">eq_comm</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">y</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">congr_heq</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">congr_arg_heq</span>\n<span class=\"w\">    </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">eq_comm</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 510514961,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1743969453
    },
    {
        "content": "<p>In your example, it looks like it'd be easier to construct <code>y</code> in a different way, which would make your equality true by definition. That is, </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">?_⟩</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"o\">]</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>Perhaps this is just because of the example, but if the <code>conv</code> is just changing the property part of the subtype (even if that proof is very long), then it will be a lot cleaner to take this approach</p>",
        "id": 510526542,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1743978797
    },
    {
        "content": "<p>Oh this is a <em>great</em> point. I was using <code>conv</code> because it seemed convenient, but it hadn't occurred to me that I'd avoid this reduction issue if wrote the proof a little differently. Thank you! I think that may actually be everything I need.</p>",
        "id": 510532173,
        "sender_full_name": "Harry Goldstein",
        "timestamp": 1743983737
    },
    {
        "content": "<p>Maybe this is better:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">]⟩</span>\n</code></pre></div>\n<p>as it's best not to use <code>by</code> in data part of <code>def</code>. In the proof part I think it's OK to use <code>by</code> and followed with a long proof.</p>\n<p>This is even better:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 510583349,
        "sender_full_name": "Jz Pan",
        "timestamp": 1744011382
    },
    {
        "content": "<p>Good point, yes. I just refactored implementation to do just that.</p>",
        "id": 510693558,
        "sender_full_name": "Harry Goldstein",
        "timestamp": 1744037400
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"686704\">Harry Goldstein</span> has marked this topic as resolved.</p>",
        "id": 514114285,
        "sender_full_name": "Notification Bot",
        "timestamp": 1745498418
    },
    {
        "content": "<p>Sorry to revive this old topic, but I've hit a big roadblock involving proofs like these and the one below. I can also try to construct a MWE of what I'm working on if what's below doesn't capture it. </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">▸</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Overall, is the conclusion that this cannot be proven?</p>",
        "id": 569845704,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769241072
    },
    {
        "content": "<p>Aha, after messing with it some more, I got the ideas here to work on a different statement that should still be good enough for what I need <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span> .</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">▸</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">congr_heq</span>\n<span class=\"w\">  </span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">congr_arg_heq</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n<span class=\"w\">  </span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 569846347,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769241766
    },
    {
        "content": "<p>Your first lemma seems unprovable. You have no way of knowing under what conditions <code>List α</code> and <code>List β</code> are equal, and there's no reason that this equality should respect any kind of property at the individual list level, such as length.</p>",
        "id": 569856203,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1769251888
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"878804\">@Liam Schilling</span> To expand on Violeta's answer, to have an idea what is can be unprovable about type equality, it can be useful to imagine so-called cardinality model. It is consistent with Lean's type theory (not compiler but that's another discussion thread) that for every cardinality, there is only one type of that cardinality.</p>\n<p>So for example, there is just one countable infinite type <code>Nat</code>, and every other countable infinite type, such as <code>List Bool</code>, or <code>List Nat</code> is in fact <code>Nat</code> under the hood, and the list-properties is just encoding on top. So <code>List Bool = List Nat</code>, however it cannot happen that the translation between <code>List Nat</code> and <code>List Bool</code> preserves lengths because there are only two lists of length 1 in <code>List Bool</code> but infinitely many in <code>List Nat</code>.</p>",
        "id": 569857945,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1769253684
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">▸</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>is the easy way to prove this. You can often <code>subst</code> away equality hypotheses to avoid dependent type hell.</p>",
        "id": 569859285,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1769254936
    }
]