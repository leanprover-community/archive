[
    {
        "content": "<p>I am trying to prove that a simple definition of a function over lists is doing the right thing. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.list</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.real.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">init.function</span>\n<span class=\"kn\">open</span> <span class=\"n\">function</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">splitAt</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">a</span> <span class=\"bp\">×</span> <span class=\"n\">list</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n <span class=\"bp\">|</span>                   <span class=\"mi\">0</span> <span class=\"n\">xs</span> <span class=\"o\">:=</span> <span class=\"o\">([],</span> <span class=\"n\">xs</span><span class=\"o\">)</span>\n <span class=\"bp\">|</span>                   <span class=\"n\">_</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"o\">([],</span> <span class=\"o\">[])</span>\n <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">nat.succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"o\">:=</span>  <span class=\"k\">match</span> <span class=\"n\">splitAt</span> <span class=\"n\">n</span> <span class=\"n\">xs</span> <span class=\"k\">with</span> <span class=\"o\">(</span><span class=\"n\">ys</span><span class=\"o\">,</span> <span class=\"n\">zs</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">ys</span><span class=\"o\">,</span> <span class=\"n\">zs</span><span class=\"o\">)</span>  <span class=\"kd\">end</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">splitAt</span> <span class=\"mi\">2</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">4</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"o\">([</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">],[</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">4</span><span class=\"o\">])</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n <span class=\"n\">rw</span> <span class=\"n\">splitAt</span><span class=\"o\">,</span>\n <span class=\"n\">rw</span> <span class=\"n\">splitAt</span><span class=\"o\">,</span>\n <span class=\"n\">rw</span> <span class=\"n\">splitAt</span><span class=\"o\">,</span>\n <span class=\"n\">rw</span> <span class=\"n\">splitAt._match_1</span><span class=\"o\">,</span>\n <span class=\"n\">rw</span> <span class=\"n\">splitAt._match_1</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">prod.fst</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"n\">prod.snd</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">==</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">splitAt</span> <span class=\"n\">n</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n <span class=\"n\">induction</span> <span class=\"n\">xs</span> <span class=\"k\">with</span> <span class=\"n\">d</span> <span class=\"n\">hd</span><span class=\"o\">,</span>\n <span class=\"n\">simp</span><span class=\"o\">,</span>\n <span class=\"n\">rw</span> <span class=\"n\">splitAt</span><span class=\"o\">,</span>    <span class=\"c1\">--  &lt;- ERROR</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<ol>\n<li>why <code>unfold</code> does not work in the proofs? </li>\n<li>why the <code>rw</code> is working in the first proof, but in the second it doesn't work.</li>\n<li>The definition looks ugly compared to the original Haskell code, is it possible to simplify it?</li>\n</ol>",
        "id": 228846925,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1614890561
    },
    {
        "content": "<p>If you look at the output of <code>#print prefix splitAt</code> you will see that there are four equation lemmas -- <code>0 []</code>, <code>0 (a :: L)</code>, <code>(succ n) []</code> and <code>(succ n) (a :: L)</code>. So you need to do <code>cases n</code> and then the rewrite will work.</p>",
        "id": 228852673,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614892946
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 228853513,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1614893286
    },
    {
        "content": "<p>Here's my effort to tidy up:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">splitAt</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">a</span> <span class=\"bp\">×</span> <span class=\"n\">list</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n <span class=\"bp\">|</span>              <span class=\"mi\">0</span> <span class=\"n\">xs</span> <span class=\"o\">:=</span> <span class=\"o\">([],</span> <span class=\"n\">xs</span><span class=\"o\">)</span>\n <span class=\"bp\">|</span>              <span class=\"n\">_</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"o\">([],</span> <span class=\"o\">[])</span>\n <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"o\">:=</span>  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">ys</span><span class=\"o\">,</span> <span class=\"n\">zs</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">splitAt</span> <span class=\"n\">n</span> <span class=\"n\">xs</span> <span class=\"k\">in</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">ys</span><span class=\"o\">,</span> <span class=\"n\">zs</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">splitAt</span> <span class=\"mi\">2</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">4</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"o\">([</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">],[</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">4</span><span class=\"o\">])</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">splitAt</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Note: you don't need any imports. You never need <code>import init.function</code> -- this is not in mathlib, this is core Lean so already imported.</p>",
        "id": 228910281,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614930581
    },
    {
        "content": "<p>As for <code>==</code>, I think that you think that <code>==</code> means something different to what Lean means by it. It's heterogeneous equality, which is used to compare elements of different types in certain circumstances, and is not needed in situations like this.</p>",
        "id": 228911307,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614931427
    },
    {
        "content": "<p>Technically, not all of core Lean is imported automatically, only what is in <code>init</code>, but this doesn't change anything here.</p>",
        "id": 228912031,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1614931857
    },
    {
        "content": "<p>After some experimenting I realise that using either <code>let</code> or <code>match</code> in a recursive definition like this is a lousy idea. I think that this is best in Lean:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">splitAt</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">a</span> <span class=\"bp\">×</span> <span class=\"n\">list</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n <span class=\"bp\">|</span>              <span class=\"mi\">0</span> <span class=\"n\">xs</span> <span class=\"o\">:=</span> <span class=\"o\">([],</span> <span class=\"n\">xs</span><span class=\"o\">)</span>\n <span class=\"bp\">|</span>              <span class=\"n\">_</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"o\">([],</span> <span class=\"o\">[])</span>\n <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">splitAt</span> <span class=\"n\">n</span> <span class=\"n\">xs</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">splitAt</span> <span class=\"n\">n</span> <span class=\"n\">xs</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Then the simplifier can prove</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">prod.fst</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"n\">prod.snd</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">splitAt</span> <span class=\"n\">n</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>without too much trouble (I can post my proof if you want, but I don't know if it's a spoiler)</p>",
        "id": 228912448,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614932106
    },
    {
        "content": "<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>I remembered Zulip does spoilers  now :-)</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\"><pre><span></span><code>import tactic\n\ndef splitAt {a : Type} : ℕ → (list a) → (list a × list a)\n |              0 xs := ([], xs)\n |              _ [] := ([], [])\n | (n + 1) (x :: xs) := (x :: (splitAt n xs).1, (splitAt n xs).2)\n\nexample : splitAt 2 [1,2,3,4] = ([1,2],[3,4]) :=\nbegin\n  simp [splitAt],\nend\n\nexample (a : Type) (n : ℕ) (xs : list a) :\n (λ x, (prod.fst x) ++ (prod.snd x) = xs) (splitAt n xs) :=\nbegin\n  induction xs with d hd IH generalizing n,\n  { induction n with m hm;\n    simp [splitAt] },\n  { induction n with m hm,\n    { simp [splitAt] },\n    { simp [splitAt, IH, hm] } }\nend\n</code></pre></div>\n</div></div>",
        "id": 228912826,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614932339
    },
    {
        "content": "<blockquote>\n<p>After some experimenting I realise that using either let or match in a recursive definition like this is a lousy idea.</p>\n</blockquote>\n<p>Thank you <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> for your ideas. But the main point here is precise that your second -- and the standard definition -- for splitAt traverses the list twice. The implementation of splitAt with only one traverse of the list was proposed as an exercise in <a href=\"https://www.amazon.com/Thinking-Functionally-Haskell-Richard-Bird/dp/1107452643\">https://www.amazon.com/Thinking-Functionally-Haskell-Richard-Bird/dp/1107452643</a>. During the Haskell course, I am trying to use Lean to formalize some informal (equational) proofs from the book. But clearly, not all of them are obvious to formalize...</p>",
        "id": 229477026,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1615296960
    },
    {
        "content": "<p>I conjecture that most of them will not be too bad if you know some of the tricks. Would you like to post some <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> examples of things which you think might not be obvious to formalise?</p>",
        "id": 229484770,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1615300007
    },
    {
        "content": "<p>Sure, I will share more examples. The problem is that once functions are optimized in a way or another, proofs became more difficult, as the example above. But for some properties such as <code>map f . map g = map (f . g)</code> we done, see <a href=\"https://github.com/emap-aa/demo-lean/blob/main/src/fp.lean#L60-L69\">https://github.com/emap-aa/demo-lean/blob/main/src/fp.lean#L60-L69</a></p>",
        "id": 229531086,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1615315689
    },
    {
        "content": "<p>One more case <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> , the <code>reverse (reverse xs)</code> was fine.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">rev_rev_id</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">reverse</span> <span class=\"bp\">∘</span> <span class=\"n\">reverse</span><span class=\"o\">)</span> <span class=\"n\">xs</span>  <span class=\"bp\">=</span> <span class=\"n\">id</span> <span class=\"n\">xs</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n <span class=\"n\">induction</span> <span class=\"n\">xs</span> <span class=\"k\">with</span> <span class=\"n\">b</span> <span class=\"n\">bs</span> <span class=\"n\">hi</span><span class=\"o\">,</span>\n <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">reverse</span><span class=\"o\">,</span><span class=\"n\">append</span><span class=\"o\">],</span>\n\n <span class=\"n\">unfold</span> <span class=\"n\">comp</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">reverse</span><span class=\"o\">,</span>\n <span class=\"n\">unfold</span> <span class=\"n\">comp</span> <span class=\"n\">at</span> <span class=\"n\">hi</span><span class=\"o\">,</span>\n <span class=\"n\">rw</span> <span class=\"n\">rev_aux</span><span class=\"o\">,</span>\n <span class=\"n\">rw</span> <span class=\"n\">hi</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>But why I can't use the point-free Haskell style in the declaration?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">rev_rev_id</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">reverse</span> <span class=\"bp\">∘</span> <span class=\"n\">reverse</span><span class=\"o\">)</span>  <span class=\"bp\">=</span> <span class=\"n\">id</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 231472040,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1616507025
    },
    {
        "content": "<p>Because lean doesn't know what type of list you're stating it aabout</p>",
        "id": 231472315,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616507124
    },
    {
        "content": "<p><code>(reverse ∘ reverse) = (id : list a → list a)</code> should work</p>",
        "id": 231472378,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616507149
    },
    {
        "content": "<p>Hum, but Lean understood <code>#check reverse ∘ reverse = id</code>.</p>",
        "id": 231472416,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1616507162
    },
    {
        "content": "<p>yes, but it put wildcards in. Those aren't allowed in lemma statements.</p>",
        "id": 231472484,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616507184
    },
    {
        "content": "<p>Thank you</p>",
        "id": 231472834,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1616507308
    },
    {
        "content": "<p>Turns out the proof is more complex anyway.</p>",
        "id": 231472855,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1616507322
    },
    {
        "content": "<p>The proof should only have two more steps of</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">funext</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">function.comp_app</span><span class=\"o\">,</span> <span class=\"n\">id.def</span><span class=\"o\">],</span>\n</code></pre></div>\n<p>and then your proof above.</p>",
        "id": 231481494,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1616510581
    }
]