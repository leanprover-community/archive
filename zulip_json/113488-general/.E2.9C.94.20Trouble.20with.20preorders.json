[
    {
        "content": "<p>So, probably my trouble is not with preorders but with something more fundamental. What happens is that I am playing around with a preorder s, I have a hypothesis containing \"<a href=\"http://s.lt\">s.lt</a> b a\", I try to hit it with a \"rw lt_iff_le_not_le\" and I get an error message \"rewrite tactic failed, did not find instance of the pattern in the target expression b &lt; a\". I tried making all the implicit arguments explicit or invoking s.lt_iff_le_not_le instead, it doesn't help. It's driving me up the wall. :-(<br>\nHere is a mwe:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">init.algebra.order</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">preorder</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s.lt</span> <span class=\"n\">b</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">lt_iff_le_not_le</span> <span class=\"n\">α</span> <span class=\"n\">s</span> <span class=\"n\">b</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 341337102,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1678656309
    },
    {
        "content": "<p>Preorders are typeclasses, so they should be declared as <code>[preorder alpha]</code></p>",
        "id": 341337173,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1678656372
    },
    {
        "content": "<p>You will then be able to use the &lt; notation as usual</p>",
        "id": 341337194,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1678656407
    },
    {
        "content": "<p>Ok, but what if I have several preorders on the same set ? (Which will happen later.) I would like them to have names.</p>",
        "id": 341337210,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1678656437
    },
    {
        "content": "<p>Oh, I can just write [s : preorder alpha] !</p>",
        "id": 341337310,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1678656497
    },
    {
        "content": "<p>Ah. Yes you can do that, but if you end up needing more than one later on the the same lemma, that would get annoying</p>",
        "id": 341337349,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1678656525
    },
    {
        "content": "<p>Can you say a bit more about what you will do later that involves more than one preorder?</p>",
        "id": 341337379,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1678656555
    },
    {
        "content": "<p>I am defining a map from preorders on alpha to set (set alpha), sending a preorder to the set of its (nonempty) right ideals, and proving stuff about it like the fact that it is monotonous and injective. The ultimate goal is to prove that total preorders on a finite set form a poset that is isomorphic to an abstract simplicial complex; the image of the set of total preorders by my map will be an abstract simplicial complex in   set (set alpha) (i.e. closed by taking subsets).</p>",
        "id": 341338093,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1678657099
    },
    {
        "content": "<p>I'm actually using preorders as a stand-in for ordered set partitions (which don't seem to exist in mathlib). Another solution would be to take setoids on alpha plus an order on the quotient, but then I would be dealing with multiple setoids, which is maybe not better.</p>",
        "id": 341338264,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1678657208
    },
    {
        "content": "<p>By the way, I never wanted to use the \"&lt;\" notation ! (Because it's ambiguous in my situation.) But somehow Lean seems to really really want me to use it...</p>",
        "id": 341338378,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1678657315
    },
    {
        "content": "<p>I see. I would recommend looking at the file defining the lattice structure on topologies where one has to deal with multiple topological space structures on a given type. I think the file is <code>topology/order.lean</code>? In any case, that file should at least give some indication for how to do such things.</p>",
        "id": 341338445,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1678657337
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_preorder\">docs#is_preorder</a> will let you avoid using a canonical ordering on the type</p>",
        "id": 341338464,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1678657355
    },
    {
        "content": "<p>Although that might not be the right choice</p>",
        "id": 341338498,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1678657383
    },
    {
        "content": "<p>You could also use the lemma as is with s an explicit variable and rely on tactics such as <code>letI</code> to tell lean which instance to use in the middle of a tactic proof</p>",
        "id": 341338537,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1678657413
    },
    {
        "content": "<p>Thank you Adam and Eric, I will have a look at these files ! At least my immediate problem is solved, I'll continue playing around with examples.</p>",
        "id": 341338562,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1678657434
    },
    {
        "content": "<p>Ooooh, I didn't know that tactic. (Shiny new tactic !) I'll have a look at it too.</p>",
        "id": 341338637,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1678657478
    },
    {
        "content": "<p>There’s a whole family of tactics of the form <code>fooI</code> that help managing instances in tactic blocks</p>",
        "id": 341338694,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1678657550
    },
    {
        "content": "<p>I think juggling tactics with <code>letI</code> will become more painful in Lean 4, as it really likes to complain if you have multiple instances on the same type</p>",
        "id": 341338917,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1678657710
    },
    {
        "content": "<p>Lean4 should mind its own business, I'll have as many preorders on a type as I like ! <span aria-label=\"stuck out tongue\" class=\"emoji emoji-1f61b\" role=\"img\" title=\"stuck out tongue\">:stuck_out_tongue:</span> <br>\nAnyway thanks for the new tactics Adam, it's high time I became more comfortable with instances (I read about them in \"Theorem proving in Lean\" but they are little more than a scary word at the moment).</p>",
        "id": 341339282,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1678658002
    },
    {
        "content": "<p>This might not be a good way to learn about <code>instance</code>s; you'll likely be fighting them every step of the way since they're fundamentally intended for when you have just once canonical preorder on a type</p>",
        "id": 341339561,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1678658228
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/Trouble.20with.20preorders/near/341338464\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_preorder\">docs#is_preorder</a> will let you avoid using a canonical ordering on the type</p>\n</blockquote>\n<p>So I tried doing this :</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">is_preorder</span> <span class=\"n\">α</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>but now I don't know how to access any of the lemmas about preorders ! (Or how to talk about the associated strict order relation.)  So now I have a bunch of new problems... Ok, it's past my bedtime anyway, I'll try again tomorrow.</p>",
        "id": 341341658,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1678659764
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/refl_of\">docs#refl_of</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/trans_of\">docs#trans_of</a></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_preorder</span> <span class=\"n\">α</span> <span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"n\">a</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">refl_of</span> <span class=\"n\">s</span>\n</code></pre></div>",
        "id": 341341732,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1678659818
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"318709\">Sophie Morel</span> <a href=\"#narrow/stream/113488-general/topic/Trouble.20with.20preorders/near/341339282\">said</a>:</p>\n<blockquote>\n<p>Lean4 should mind its own business, I'll have as many preorders on a type as I like ! <span aria-label=\"stuck out tongue\" class=\"emoji emoji-1f61b\" role=\"img\" title=\"stuck out tongue\">:stuck_out_tongue:</span> <br>\nAnyway thanks for the new tactics Adam, it's high time I became more comfortable with instances (I read about them in \"Theorem proving in Lean\" but they are little more than a scary word at the moment).</p>\n</blockquote>\n<p>I read <a href=\"https://leanprover.github.io/theorem_proving_in_lean/\">#tpil</a> three times and was still a bit hazy about typeclasses and instances; I then defined schemes and I had to use them, and it was at this point that the penny dropped.  The unification system (the one that fills in inputs in <code>{}</code> brackets) is easy to understand: Lean just fills in the hole with the only possible solution which makes everything logically valid. The type class inference system (the <code>[]</code> brackets) just fills in the holes with the first example it finds in its big database of instances; examples of instances are \"the reals are a field\", and \"every field is a monoid\" (so the system can find a term of type <code>monoid \\R</code> if you ask it). You'll have a bit less luck than me though because you appear to be doing battle with the typeclass system. They also had to do this in the topology file when proving topologies on a type were a lattice; it helps to understand the typeclass system well before you do battle with it, I'm sure!</p>",
        "id": 341345810,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1678662853
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/Trouble.20with.20preorders/near/341341732\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/refl_of\">docs#refl_of</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/trans_of\">docs#trans_of</a></p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_preorder</span> <span class=\"n\">α</span> <span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"n\">a</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">refl_of</span> <span class=\"n\">s</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I'm sorry, I don't understand your answer. I know that is_preorder implies reflexivity and transitivity, it's the definition. My problem is that I was doing other things with that preorder: I was assuming that the associated strict order is well-founded, I was taking minimal elements in nonempty sets etc. Now if instead of writing \"s : preorder alpha\" I take s to be a relation and tell Lean \"is_preorder s\", well, I don't even know if there is an associated strict order anymore in Lean (what was called \"<a href=\"http://s.lt\">s.lt</a>\" for a preorder), so I'm stuck at the first step. Also, the lemma that I was trying to use to manipulate my minimal elements, lt_iff_le_not_le (and all its little friends) will refuse to work because  it wants the preorder to be an instance, so the only solution I can see is to redefine \"<a href=\"http://s.lt\">s.lt</a>\" and prove all the lemmas by hand, which makes my situation worse than before, where I thought I'd have to reprove all the lemmas by hand but at least I didn't have to define the \"<a href=\"http://s.lt\">s.lt</a>\" myself.<br>\nBy the way, I would be perfectly happy to let the preorder be unique in my auxiliary results (and let it be an instance or whatever Lean wants). But then I still want to be able to use these auxiliary results in  a situation where I have several preorders, which seems far from guaranteed now since I can't even use the basic mathlib lemmas.</p>",
        "id": 341384241,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1678691267
    },
    {
        "content": "<p>The way to go is probably to have an instance in all your preliminary lemmas, as you say, and then in your main results use <code>@</code> versions of the lemmas, in which you can prescribe the preorder you want to use instead of letting Lean figure it out.</p>",
        "id": 341385665,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1678691851
    },
    {
        "content": "<p>That sounds reasonable, but what makes me nervous is that at the moment I am not able to use the mathlib lemmas in that way. That is, to come back to my mwe at the beginning of this thread, I cannot make the lemma lt_iff_le_not_le work in that exemple (with a non-instance named preorder) even if I use its <code>@</code> version., like so:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">preorder</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s.lt</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">@</span><span class=\"n\">lt_iff_le_not_le</span> <span class=\"n\">α</span> <span class=\"n\">s</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>(I still get the same error: \"rewrite tactic failed, did not find instance of the pattern in the target expression a &lt; b\", where by the way I suppose that the word \"instance\" is used in its regular meaning). So I'm afraid that I will write a bunch of preliminary lemmas and then will be unable to use them. Or maybe I am not giving the arguments to the <code>@</code> version of lt_iff_le_not_le in the correct way ? Is there a special way to give the explicit version of an \"instance\" argument ?</p>",
        "id": 341387834,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1678692690
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"318709\">@Sophie Morel</span> I understand your pain <span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span> <span aria-label=\"see no evil\" class=\"emoji emoji-1f648\" role=\"img\" title=\"see no evil\">:see_no_evil:</span> <br>\nYou can write <code>(h : @has_lt.lt _ s a b)</code>, and then it should work. Of course this is not very nice.<br>\nSo if you can keep this \"multiple preorders on one type\" stuff contained to 5% of the project, that will help you a lot.</p>",
        "id": 341388336,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1678692886
    },
    {
        "content": "<p>By the way, I am trying every combination of characters in the hope that something will work, so I also trying writing the example above with <code>[s : preorder α]</code> instead of  <code>(s : preorder α)</code>, but this did not seem to change anything. I really need the preorders to be named after a certain point.</p>",
        "id": 341388457,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1678692946
    },
    {
        "content": "<p>After you use <code>letI</code> to decree that this preorder is temporarily the \"canonical\" one, you can use <code>change</code> to put your hypotheses into this canonical form. The problem is that <code>rw</code> works up to syntactic equality so wants to see everything using <code>&lt;</code>. Alternatively you can use tactics like <code>refine</code> and <code>apply</code> which work up to definitional equality so won't care that you're syntactically incorrect</p>",
        "id": 341388459,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1678692948
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">preorder</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">has_lt.lt</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">b</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">lt_iff_le_not_le</span> <span class=\"n\">α</span> <span class=\"n\">s</span> <span class=\"n\">b</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 341388570,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1678692988
    },
    {
        "content": "<p>This code is tested and works. I don't claim it looks nice.</p>",
        "id": 341388597,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1678693010
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> : I still haven't figured out how to make <code>letI</code> do anything for me. :-( But <code>change</code> has become one of my best friends recently, so I'm getting comfortable with it. Thanks for the tips about <code>rw</code> vs <code>refine</code> and <code>apply</code>, I hadn't realized.<br>\n<span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> : Unfortunately the \"multiple preoders\" thing seems to be most of the project at the moment... But thank for the code that works, it's better than what I had yesterday !</p>",
        "id": 341388996,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1678693194
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">preorder</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s.lt</span> <span class=\"n\">b</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">replace</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">lt_iff_le_not_le</span> <span class=\"n\">α</span> <span class=\"n\">s</span> <span class=\"n\">b</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"c1\">-- also works</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 341389069,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1678693213
    },
    {
        "content": "<p>I'm also reading the mathlib file about the order on topologies as Adam suggested. It's not easy going but it's interesting. Sometimes the topologies on the type are instances in it, sometimes they're not, and I have yet to understand the logic behind that.</p>",
        "id": 341389219,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1678693287
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113488-general/topic/Trouble.20with.20preorders/near/341389069\">said</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">preorder</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s.lt</span> <span class=\"n\">b</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">replace</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">lt_iff_le_not_le</span> <span class=\"n\">α</span> <span class=\"n\">s</span> <span class=\"n\">b</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"c1\">-- also works</span>\n<span class=\"kd\">end</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Ah, so <code>replace</code> also works up to definitional equality !<br>\nWhat made me mad about the first example is that I am not the one who wanted to write <code>s.lt a b</code> as <code>a&lt;b</code>, it was Lean, and then <code>rw</code> was giving me trouble because of that. Come on Lean. :-(</p>",
        "id": 341389372,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1678693339
    },
    {
        "content": "<p>This might be a question where targeted \"I'm now stuck with this issue\" might be fruitful (responses such as \"you can use this hack\" are probably going to be available). The whole typeclass setup is based on this usually-true-but-not-always assumption that there's only one &lt; on a set, and as I mentioned before occasionally this needs to be worked around, like in the topology file when ordering topologies.</p>",
        "id": 341389412,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1678693350
    },
    {
        "content": "<p>General rule: if in a lemma or a proof you will have two preorders on a type, then don't declare them as instances.</p>",
        "id": 341389470,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1678693373
    },
    {
        "content": "<p>(even using <code>letI</code>).</p>",
        "id": 341389538,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1678693385
    },
    {
        "content": "<p>It's really only <code>rw</code> and <code>simp</code> which look for syntactic equality.</p>",
        "id": 341389556,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1678693394
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/113488-general/topic/Trouble.20with.20preorders/near/341389470\">said</a>:</p>\n<blockquote>\n<p>General rule: if in a lemma or a proof you will have two preorders on a type, then don't declare them as instances.</p>\n</blockquote>\n<p>Got it, thanks !</p>",
        "id": 341389643,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1678693436
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">[</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">preorder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_lt</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span>\n<span class=\"k\">#print</span> <span class=\"n\">foo</span> <span class=\"c1\">-- preorder.to_has_lt α</span>\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">preorder.to_has_lt</span> <span class=\"c1\">-- Π (α) [self : preorder α], has_lt α</span>\n\n<span class=\"kn\">local</span> <span class=\"kd\">notation</span> <span class=\"n\">a</span> <span class=\"bp\">`&lt;</span><span class=\"o\">[</span><span class=\"bp\">`</span><span class=\"n\">s</span><span class=\"bp\">`</span><span class=\"o\">]</span><span class=\"bp\">`</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">has_lt.lt</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">preorder.to_has_lt</span> <span class=\"n\">_</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n<span class=\"kn\">local</span> <span class=\"kd\">notation</span> <span class=\"n\">a</span> <span class=\"bp\">`≤</span><span class=\"o\">[</span><span class=\"bp\">`</span><span class=\"n\">s</span><span class=\"bp\">`</span><span class=\"o\">]</span><span class=\"bp\">`</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">has_le.le</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">preorder.to_has_le</span> <span class=\"n\">_</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">preorder</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span><span class=\"o\">[</span><span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">lt_iff_le_not_le</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"c1\">-- works</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 341389701,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1678693444
    },
    {
        "content": "<p>Hahaha, I will need some more time to digest your last suggestion, Johan. (I have never used <code>apply_instance</code> before, and I have never successfully defined notation.)</p>",
        "id": 341389878,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1678693525
    },
    {
        "content": "<p>Those three lines are meant to figure out how Lean infers a <code>&lt;</code> on a preorder.</p>",
        "id": 341390101,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1678693631
    },
    {
        "content": "<p>You can remove the <code>def ... #check</code> lines, and the code will still work.</p>",
        "id": 341390128,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1678693645
    },
    {
        "content": "<p>What I <em>do not</em> know how to do, is make sure that this notation is also used in the goal state.</p>",
        "id": 341390169,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1678693662
    },
    {
        "content": "<p>It would be very useful if we could overrule the normal notation.</p>",
        "id": 341390197,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1678693675
    },
    {
        "content": "<p>Now is the time for somebody to arrive and say \"in Lean4 we can\" !</p>",
        "id": 341390360,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1678693725
    },
    {
        "content": "<p>You already can in Lean 3 by setting the new instance to have a higher priority. But I'm not sure it won't mess up display of existing uses of the notations.</p>",
        "id": 341393322,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1678694923
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span>  Please teach me how to do this. I've messed around with priorities, but the goal state still doesn't use <code>&lt;[s]</code></p>",
        "id": 341394123,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1678695202
    },
    {
        "content": "<p>Sophie, the situation is a bit confusing because there are several mostly unrelated mechanisms playing a role in your first snippet. I have very little time now but let me write some stuff so that people that don't have to run and teach can expand on it. A first very important thing to keep in mind is that the <code>(... : ...)</code> vs <code>{... : ...}</code> vs <code>[... : ...]</code> (vs <code>⦃... : ...⦄</code> but let's ignore that one) issue when you state a lemma has no impact whatsoever on what happens in the proof of that lemma. It has a big impact when you want to <em>use</em> that lemma (and same with definitions).</p>\n<p>Then there is the question of syntactic vs definitional equality. The rewrite tactic <code>rw stuff</code> tries to match the left-hand side of <code>stuff</code> with part of your current goal. But this matching is a syntactic one, it won't unfold any definition. See:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">my_add</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">my_add</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">my_add</span> <span class=\"n\">b</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"c1\">-- rw nat.add_comm, --fails</span>\n  <span class=\"n\">change</span> <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">+</span><span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"bp\">+</span><span class=\"n\">a</span><span class=\"o\">),</span>\n  <span class=\"n\">rw</span> <span class=\"n\">nat.add_comm</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>In your case <code>s.lt a b</code> is equal by definition to <code>@has_lt.lt _ _ a b</code> but not syntactically. The type class mechanism kicks in to explain when and why Lean fills in the second underscore to make sure they are equal by definition, but it won't change the syntactic issue. Now I should bike really fast. I'll come back during the lunch break.</p>",
        "id": 341395769,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1678695725
    },
    {
        "content": "<p>Johan's solution to define <code>&lt;[s]</code> and <code>≤[s]</code> as notation is the right solution. <br>\nI believe this is not displayed in the goal because the pretty printer has issues with notation declared using <code>@</code> and/or <code>_</code>. I don't know a workaround for this.</p>\n<p>Another place you can look at in the library is in measure theory, where we deal with multiple sigma-algebras on a single type. We use the notation<code>measurable_set[m]</code> to indicate measurable w.r.t. a particular <code>measurable_space</code> instance (sigma-algebra) <code>m</code>.<br>\nMany lemmas in this library have <code>{m : measurable_space a}</code> as implicit argument instead of the more usual type-class argument <code>[measurable_space a]</code>. The reason for this is that  if you apply a lemma with an argument <code>[measurable_space a]</code>, it will only apply the lemma for the last-declared <code>measurable_space</code> structure. If you write the lemma using <code>{m : measurable_space a}</code> it will use the context (i.e. a subterm that appears in your goal) to find the right <code>measurable_space</code> structure. However: using implicit arguments means that it doesn't use type-class inference to synthesize this argument, if there is not enough context in the goal to know what this argument should be.<br>\nThis last part was maybe a bit technical, but I recommend to search for <code>measurable_set[</code> (with the open bracket) to see some examples of how such notation is used in the measure theory library.</p>",
        "id": 341445342,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1678710246
    },
    {
        "content": "<p>Thanks Floris, I'll have a look at the measure theory parts of the library.</p>",
        "id": 341495622,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1678721266
    },
    {
        "content": "<p>I'm not sure that reading measure theory will help much. In principle Johan's solution with a notation is the correct one but there is the issue in Lean 3 with using such a notation in the goal view. Your options are:</p>\n<ul>\n<li>Use Lean 4 (untested for this specific issue but I guess it would be better)</li>\n<li>Use the notation defined by Johan and when the information is missing in the infoview you can use <code>set_option pp.implicit true</code> before the proof and click on stuff in the infoview to get the information or use also <code>set_option pp.notation false</code> to see it all the time</li>\n<li>Define a new function getting the notation, for instance</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">my_lt</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">preorder</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">&lt;</span><span class=\"o\">)</span>\n\n<span class=\"kd\">notation</span> <span class=\"n\">a</span> <span class=\"bp\">`&lt;</span><span class=\"o\">[</span><span class=\"bp\">`</span><span class=\"n\">s</span><span class=\"bp\">`</span><span class=\"o\">]</span><span class=\"bp\">`</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">my_lt</span> <span class=\"n\">s</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n</code></pre></div>\n<p>and unfold the definition of <code>my_lt</code> when you need to use a tactic that cares about syntactical equality.</p>",
        "id": 341506096,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1678723480
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">notation</span> <span class=\"n\">a</span> <span class=\"bp\">`</span> <span class=\"bp\">&lt;</span><span class=\"o\">(</span><span class=\"bp\">`</span><span class=\"n\">s</span><span class=\"bp\">`</span><span class=\"o\">)</span> <span class=\"bp\">`</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">has_lt.lt</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">preorder.to_has_lt</span> <span class=\"n\">_</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n\n<span class=\"c1\">-- See the tactic state display at the beginning of the next proof with the</span>\n<span class=\"c1\">-- following two lines commmented out, then uncomment the first one, then uncomment both?</span>\n<span class=\"c1\">--set_option pp.implicit true</span>\n<span class=\"c1\">--set_option pp.notation false</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">preorder</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">lt_iff_le_not_le</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n\n\n<span class=\"c1\">-- Now let's try to define a new function taking the preorder as an explicit argument</span>\n<span class=\"kd\">def</span> <span class=\"n\">my_lt</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">preorder</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">&lt;</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- and a notation for it.</span>\n<span class=\"kd\">notation</span> <span class=\"n\">a</span> <span class=\"bp\">`</span> <span class=\"bp\">&lt;</span><span class=\"o\">[</span><span class=\"bp\">`</span><span class=\"n\">s</span><span class=\"bp\">`</span><span class=\"o\">]</span> <span class=\"bp\">`</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">my_lt</span> <span class=\"n\">s</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">preorder</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span><span class=\"o\">[</span><span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"c1\">-- Here tactic state display is nice without any set_option trick, but you need to</span>\n  <span class=\"c1\">-- unfold `my_lt` below.</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">my_lt</span><span class=\"o\">,</span> <span class=\"n\">lt_iff_le_not_le</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 341507333,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1678723788
    },
    {
        "content": "<p>I guess you could even have a lemma <code>my_lt_rev</code> that folds back the notation.</p>",
        "id": 341515686,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1678725797
    },
    {
        "content": "<p>Thanks Patrick ! I'll try solution number 2, probably. I haven't cared too much if the goal view is a bit ambiguous so far, I usually can remember what is going on (I already had to deal with that, when I had several preorders/partial orders floating around). Now that you've told me how to change the pretty printing settings, it should be easier.</p>",
        "id": 341553362,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1678735122
    },
    {
        "content": "<p>Note that if you are using VScode, then you can also click on the <code>&lt;</code>, and then on the <code>preorder.to_has_lt</code>.</p>",
        "id": 341553551,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1678735189
    },
    {
        "content": "<p>In the nested pop-up, you will then see which <code>s</code> is being used.</p>",
        "id": 341553689,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1678735214
    },
    {
        "content": "<p>Johan, I think what you say is correct only under <code>set_option pp.implicit true</code></p>",
        "id": 341554557,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1678735507
    },
    {
        "content": "<p>Otherwise <code>s</code> shouldn't show up</p>",
        "id": 341554589,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1678735517
    },
    {
        "content": "<p>I am using vscode, for now. I just tried your solution in my more complicated real-life example, where the hypothesis <code>b&lt;a</code> arises as a consequence of a mathlib lemma. I hit it with a <code>change (b&lt;[s]a)</code> and after that I was able to apply <code>rw lt_iff_le_not_le</code> to it ! Thanks !</p>",
        "id": 341554951,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1678735636
    },
    {
        "content": "<p>Patrick, indeed without <code>set_option pp.implicit true</code>, I don't see the <code>s</code> when I click on <code>&lt;</code> in the infoview.</p>",
        "id": 341555062,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1678735675
    },
    {
        "content": "<p>Hmm, I thought you could drill down in those pop-ups to see it nevertheless.</p>",
        "id": 341556549,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1678736105
    },
    {
        "content": "<p>Ah, clicking a second time ! I should have read your message better. Indeed, then I see the <code>s</code>.</p>",
        "id": 341556963,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1678736222
    },
    {
        "content": "<p>(I usually don't click at all...)</p>",
        "id": 341557151,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1678736276
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"318709\">Sophie Morel</span> has marked this topic as resolved.</p>",
        "id": 341574393,
        "sender_full_name": "Notification Bot",
        "timestamp": 1678742082
    },
    {
        "content": "<p>Also, FWIW: I started today translating all that stuff into Lean4, and the issue seems to have magically disappeared, i.e. so far <code>rw</code> works without any need to introduce custom notation and <code>change</code> the terms to use it. (Which is lucky as I was having trouble figuring out how to declare that particular notation in Lean4. <span aria-label=\"sweat\" class=\"emoji emoji-1f613\" role=\"img\" title=\"sweat\">:sweat:</span> ) Expect soon a lot of questions on the model of \"aaaaargh how do I this in Lean4\".</p>",
        "id": 357058139,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1683653628
    }
]