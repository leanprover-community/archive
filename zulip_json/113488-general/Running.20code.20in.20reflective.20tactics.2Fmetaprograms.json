[
    {
        "content": "<p>I am implementing a reflective metaprogram that takes in a Lean expression, <strong>reifies</strong> it into an AST, then runs a user supplied function with a proof of correctness to optimise the AST, then <strong>denotes</strong> that AST back into a Lean expression. I believe this is a pretty standard way of proof, and the reification and denotation metaprograms are inverses of eachother and return proofs:</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>(reify) Expr -&gt; IR, returns a proof that IR.eval = expr\n(denote) IR -&gt; Expr, returns a proof that IR.eval = expr\n\n\n  ir  = reify lhs     (IR.eval ir = lhs)\n  ir' = opt ir        (IR.eval ir ~&gt; IR.eval ir')   (opt.wf)\n  rhs = denote ir'    (IR.eval ir' = rhs)\n\n  lhs = IR.eval ir ~&gt; IR.eval ir' = rhs\n  ⊢ lhs ~&gt; rhs                               (by proof chaining)\n</code></pre></div>\n<p>Optimisations are declared as follows, using the <code>Rule</code> type like below, they're just programs:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">addNsw_refine_add'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Rule</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">impl</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">ir</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">ir</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">IR</span><span class=\"bp\">.</span><span class=\"n\">addNsw</span><span class=\"w\"> </span><span class=\"n\">lhs</span><span class=\"w\"> </span><span class=\"n\">rhs</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">IR</span><span class=\"bp\">.</span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"n\">lhs</span><span class=\"w\"> </span><span class=\"n\">rhs</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">ir</span>\n\n<span class=\"w\">  </span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">wf</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"n\">intros</span><span class=\"w\"> </span><span class=\"n\">idx</span><span class=\"w\"> </span><span class=\"n\">ξ</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"n\">lhs</span>\n\n<span class=\"w\">      </span><span class=\"n\">split</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">try</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">      </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">addNsw_refine_add</span>\n<span class=\"w\">  </span><span class=\"o\">}</span>\n</code></pre></div>\n<p>However, I have an issue. After reifying, I need to actually <strong>run</strong> the <code>impl</code> function on the reified IR. So, right now given the <code>rule</code> supplied to the metaprogram as an <code>Expr</code>, I evaluate the the <code>impl</code> function using an unsafe program:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">rule</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Rule</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span><span class=\"w\">  </span><span class=\"c\">/-</span><span class=\"cm\"> user supplied -/</span>\n\n<span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">ir</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">irExpr</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">irProof</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">reifyIRExpr</span><span class=\"w\"> </span><span class=\"n\">resultIdx</span><span class=\"w\"> </span><span class=\"n\">body</span><span class=\"w\">   </span><span class=\"c\">/-</span><span class=\"cm\"> irExpr = toExpr ir -/</span>\n<span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">ir'</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">evalImpl</span><span class=\"w\"> </span><span class=\"n\">resultIdx</span><span class=\"w\"> </span><span class=\"n\">irExpr</span><span class=\"w\"> </span><span class=\"n\">rule</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">unsafe</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">evalImplUnsafe</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">idx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">irExpr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">IR</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">idx</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rule</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Rule</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">IR</span><span class=\"w\"> </span><span class=\"n\">idx</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">((</span><span class=\"bp\">$</span><span class=\"n\">rule</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">impl</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">irExpr</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">evalExpr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">IR</span><span class=\"w\"> </span><span class=\"n\">idx</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">IR</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">idx</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">expr</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">implemented_by</span><span class=\"w\"> </span><span class=\"n\">evalImplUnsafe</span><span class=\"kd\">]</span>\n<span class=\"kn\">opaque</span><span class=\"w\"> </span><span class=\"n\">evalImpl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">idx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">irExpr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">IR</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">idx</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rule</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Rule</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">IR</span><span class=\"w\"> </span><span class=\"n\">idx</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>The thing is, even though this actually evaluates the IR on the <code>rule.impl</code>, it's useless to me because there isn't any proof that this new IR <code>ir'</code> is equal to <code>impl ir</code>.</p>\n<p>If I were to do proof chaining, I wouldn't want to work on the <code>impl ir</code> expression, I would like to work on the actual evaluated version of that, but after the evaluation, Lean doesn't know that they're equivalent (I need a proof that <code>ir = impl ir</code>, but I don't have that)</p>\n<p>\"Running the code\" has got me stuck here. What is the solution? Using something like <code>Lean.ofReduceBool</code>? I can see that's what <code>bv_decide</code> sort of does. I appreciate any insight, since I'm quite new to this.</p>",
        "id": 565869066,
        "sender_full_name": "l1mey",
        "timestamp": 1767164958
    },
    {
        "content": "<p>I was thinking using <code>Lean.ofReduceBool</code> to do this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">rule</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Rule</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span><span class=\"w\">  </span><span class=\"c\">/-</span><span class=\"cm\"> user supplied -/</span>\n\n<span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">ir</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">irExpr</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">irProof</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">reifyIRExpr</span><span class=\"w\"> </span><span class=\"n\">resultIdx</span><span class=\"w\"> </span><span class=\"n\">body</span><span class=\"w\">   </span><span class=\"c\">/-</span><span class=\"cm\"> irExpr = toExpr ir -/</span>\n<span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">ir'</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">evalImpl</span><span class=\"w\"> </span><span class=\"n\">resultIdx</span><span class=\"w\"> </span><span class=\"n\">irExpr</span><span class=\"w\"> </span><span class=\"n\">rule</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> ir' = rule.impl ir -/</span>\n<span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">proofType</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">ir</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">@$</span><span class=\"o\">(</span><span class=\"n\">rule</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">impl</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">resultIdx</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">reified</span><span class=\"bp\">.</span><span class=\"n\">irExpr</span><span class=\"o\">))</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> then, as they're both inductive ASTs this can be proved by just running the code</span>\n<span class=\"cm\">  by doing Lean.reduceBool + Lean.ofReduceBool -/</span>\n</code></pre></div>\n<p>This seems like the right fit, but honestly, I wouldn't know since there isn't much documentation on writing tactics of this form and knowing when or not to use these reflection primitives.</p>\n<p>If I were to do it this way, it does seem that I'll have to run the code twice as well. I'll have to run it once in the unsafae eval (to run <code>impl</code> on it and denote), and a second time using <code>Lean.reduceBool</code> to get the proof that the <code>ir'</code> is actually <code>impl ir</code>.</p>",
        "id": 565869832,
        "sender_full_name": "l1mey",
        "timestamp": 1767165697
    },
    {
        "content": "<p>Okay, so using <code>rfl</code> the function is \"ran\" inside the kernel. However I don't know to what extent this works for all Lean functions:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">addNsw_refine_add'</span><span class=\"bp\">.</span><span class=\"n\">impl</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">IR</span><span class=\"bp\">.</span><span class=\"n\">var</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">addNsw</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">IR</span><span class=\"bp\">.</span><span class=\"n\">var</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IR</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">IR</span><span class=\"bp\">.</span><span class=\"n\">var</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">IR</span><span class=\"bp\">.</span><span class=\"n\">var</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>Since I am only admitting optimisations that you can prove correct, these optimisation functions must be all provably terminating (so just normal Lean functions). To what extent can normal Lean functions be evaluated in the kernel? (For example, the function above is defined using pattern matching, what about functions that use other constructs?)</p>\n<p>These optimisations might be quite heavy, since I'm planning to port and reimplement certain LLVM optimisations. The kernel might not be able to keep up eventually, so reduceBool might be an option eventually?</p>",
        "id": 565875578,
        "sender_full_name": "l1mey",
        "timestamp": 1767170880
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"956930\">l1mey</span> <a href=\"#narrow/channel/113488-general/topic/Running.20code.20in.20reflective.20tactics.2Fmetaprograms/near/565875578\">said</a>:</p>\n<blockquote>\n<p>To what extent can normal Lean functions be evaluated in the kernel? (For example, the function above is defined using pattern matching, what about functions that use other constructs?)</p>\n</blockquote>\n<p>Can you elaborate? For inductive types, recursive pattern matching is essentially the only thing you can do.</p>",
        "id": 565907900,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1767195250
    }
]