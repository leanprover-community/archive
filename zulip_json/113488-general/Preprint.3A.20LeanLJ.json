[
    {
        "content": "<p>Hi everyone! We've been working for a while on formalizing molecular dynamics simulations. We've drafted our first manuscript on this, where we perform Lennard-Jones energy calculations in Lean, compare with NIST benchmarks, and accompany the calculations with proofs. Take a look! We're planning to post the preprint on ChemRxiv and submit the paper to a molecular physics journal this week. <a href=\"/user_uploads/3121/Bidyi-KyvnDU1WZJ_2RsFOx5/LeanLJ.pdf\">LeanLJ.pdf</a> Code available <a href=\"https://github.com/ATOMSLab/LeanLJ/\">here</a>.</p>",
        "id": 514824099,
        "sender_full_name": "Tyler Josephson ⚛️",
        "timestamp": 1745849209
    },
    {
        "content": "<p>Hi Tyler! This looks great, congrats!</p>\n<p>One quick comment: The licensing on the repo is a bit confusing. The attached license is <code>Apache License 2.0</code>, but at the bottom of the read me it says <code>MIT license</code>.</p>",
        "id": 514829611,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1745850519
    },
    {
        "content": "<p>Very cool! I would suggest clarifying what <code>noncomputable</code> and <code>executing</code> means when you say</p>\n<blockquote>\n<p>Because real numbers are noncomputable, Lean requires this definition to be prefaced with the noncomputable keyword. This would be an issue if we were executing this function in our calculations</p>\n</blockquote>\n<p>Perhaps reinterpreting it as \"noncomputable: compilable by Lean to generate code that the VM can run on the objects directly referenced in the function. That is why we intend to execute other versions of this function ...\"</p>",
        "id": 514859604,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1745858633
    },
    {
        "content": "<p>Some initial comments:</p>\n<ol>\n<li>The use of <code>⟨0, by decide⟩</code> to write <code>(0 : Fin 3)</code> seems to be doing Lean a bit of a disservice; it makes it look like the system gets in your way more than it actually has to.</li>\n<li>\n<p>Regarding<br>\n<code>\n  def lj_p {α : Type} [LE α] [DecidableLE α] [HDiv α α α] [HPow α α α] [HSub α α α]\n  [HMul α α α] [OfNat α 2] [OfNat α 4] [OfNat α 6] [Zero α] (r r_c ε σ : α) : α :=\n  </code><br>\n  it would probably make sense to bundle all of these together into a <code>RealLike</code> class, to keep things brief; that also lets you demonstrate defining a new typeclass.</p>\n</li>\n<li>\n<p>In fig 5, \"Bottom: the equivalent recursive implementation in Lean 4, which<br>\nmirrors the same logic using functional programming.\" - you could use <code>Id.run do</code> and <code>for</code> notation here to almost exactly match the python code.</p>\n</li>\n</ol>",
        "id": 514875227,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1745863645
    },
    {
        "content": "<ol start=\"4\">\n<li>Is there any chance you can move the whole project to a stable release, eg <code>v4.16.0</code> or <code>v4.17.0</code>? This will make it more likely that people will be able to depend on your project, and is generally good practice.</li>\n<li>Can you make Figure 2 show a case where the periodic boundary condition and minimum image conventions differ? Currently, it feels like the figure is not conveying the point.</li>\n<li>Minor but in the caption of Figure 3, \"This plot was generated using Python and matplotlib, since data visualization in Lean is still experimental.\" reads more like a footnote than a caption.</li>\n<li>The informal description preceding <code>lj_real</code> does not match its implementation: You are not defining <code>r3</code> and instead you are defining <code>r12</code> (which won't ever save any compute since <code>r12</code> is used exactly once in the definition).</li>\n<li>In the statement of <code>ljp_eq_le</code>, <code>{r | r &gt; 0 ∧ r ≤ r_c }</code> has got one too many space at the end.</li>\n<li>Just to hammer Eric's nail, \"for- and while-loops, which are not supported by Lean\" is factually incorrect. For loops exist in Lean, although they have a slightly different flavor than in imperative languages.</li>\n</ol>",
        "id": 514905871,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1745875200
    },
    {
        "content": "<ol start=\"10\">\n<li>\"the <code>real</code> version\" should be \"the <code>Real</code> version\"</li>\n<li>\"The proofs do not catch bugs like these, but the tests do.\", probably worth mentioning CakeML at this point</li>\n</ol>",
        "id": 514908561,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1745876320
    },
    {
        "content": "<p>Your code indentation is very inconsistent. If you were sticking with mathlib's conventions (which I think are the same conventions that core, batteries etc uses) then examples of errors are: p8 <code>thing_to_be_proved</code> is indented 5 spaces not 4, p10 <code>lj_real...</code> in the first box is indented 0 spaces not 4, and the first proof is indented 0 spaces not 2, in the second box <code>lj_real</code> is indented 1 space not 4, in the second box ContinuousOn is indented 2 spaces not 4, basically you are indenting a random number of spaces so it all looks very inconsistent, this goes on throughout the paper.</p>",
        "id": 514925356,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1745885469
    },
    {
        "content": "<p>These are great points, thanks everyone for the helpful feedback!</p>\n<p>Re for/while loops - thanks for catching this! In an earlier draft, we actually mentioned do notation as a way to do imperative programming in Lean, but that was removed and soon the text didn’t reflect reality. We’ll clean that up. </p>\n<p>It likely would have been easier if we had just used imperative style for the summations - but we made it recursive so we could do proofs. Would it be accurate to say that proving things with “for” and “do” in Lean is difficult? Do these come with termination proofs, like recursive functions do? Looking back, I notice we didn’t end up doing that much with the recursive function, as far as proofs are concerned. Our proofs are about other functions. Like we mentioned, it would have been nice to figure out a proof that this summation function loops over N*(N-1) pairs of interactions, but we didn’t figure that out.</p>",
        "id": 515020359,
        "sender_full_name": "Tyler Josephson ⚛️",
        "timestamp": 1745921988
    },
    {
        "content": "<p>Proving things about <code>do</code> and <code>for</code> isn't too bad, with caveats: </p>\n<ul>\n<li>If your loop uses <code>break</code> or early returns then it is fiddler</li>\n<li>The simp-normal form around <a href=\"http://Id.run\">Id.run</a> is a slight mess, I have an open draft PR to fix this</li>\n</ul>",
        "id": 515031243,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1745924634
    },
    {
        "content": "<p>Did I have a misconception about whether certain loop-like functions should be expressed with <code>do</code> and <code>for</code> vs. recursion, in order to have proofs about them? I went hunting to find where I got this idea from, and <a href=\"\">this</a> summarizes how I've been thinking about this. I had the impression that Lean <em>allows</em> imperative-style code, but obtaining the guarantees with this is harder than when you write code in the functional style.</p>",
        "id": 515064454,
        "sender_full_name": "Tyler Josephson ⚛️",
        "timestamp": 1745933456
    },
    {
        "content": "<p>We make a rather big point about this in the paper, trying to teach our audience about recursion, but that's because I thought there was a benefit to that. If no benefit, then it's likely better to skip that point; it's harder to write code that way (at least for people who learn imperative languages first), and it's better not to demonstrate harder ways of doing things when our goal is to make this a gentle introduction.</p>",
        "id": 515066434,
        "sender_full_name": "Tyler Josephson ⚛️",
        "timestamp": 1745933953
    },
    {
        "content": "<p>If your loop-like function is really a (filtered) sum, then you should be using functions about sums and filtering sequences</p>",
        "id": 515073055,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1745935444
    },
    {
        "content": "<p>I think your function in question can literally be written using the notation for <code>Finset.sum</code>, which will look more similar to the mathematics than even the Python</p>",
        "id": 515073700,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1745935589
    },
    {
        "content": "<p>That would be nice, indeed! Much closer to the mathematics. It would still be a learning curve / requiring translation from the traditional loop implementation.</p>",
        "id": 515080723,
        "sender_full_name": "Tyler Josephson ⚛️",
        "timestamp": 1745937179
    },
    {
        "content": "<p>But isn't the traditional loop implementation itself translated from LaTeX?</p>",
        "id": 515081511,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1745937360
    },
    {
        "content": "<p>Good question. I checked the two intro molecular simulation textbooks that I learned from (by Allen and Tildesley and by Frenkel and Smit), and both show typeset equations with summation, and both demonstrate in code (e.g. FORTRAN) using for loops. For instance, from Frenkel and Smit (this for loop code is about forces):<br>\n<a href=\"/user_uploads/3121/rBsbeFTB9pLjcyfBQ4maLecD/Screenshot-2025-04-29-at-10.40.03AM.png\">Screenshot 2025-04-29 at 10.40.03 AM.png</a><br>\n<a href=\"/user_uploads/3121/b5jqznBVxYigW_CKA1TLQQw-/Screenshot-2025-04-29-at-10.42.15AM.png\">Screenshot 2025-04-29 at 10.42.15 AM.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/rBsbeFTB9pLjcyfBQ4maLecD/Screenshot-2025-04-29-at-10.40.03AM.png\" title=\"Screenshot 2025-04-29 at 10.40.03 AM.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1732x592\" src=\"/user_uploads/thumbnail/3121/rBsbeFTB9pLjcyfBQ4maLecD/Screenshot-2025-04-29-at-10.40.03AM.png/840x560.webp\"></a></div><div class=\"message_inline_image\"><a href=\"/user_uploads/3121/b5jqznBVxYigW_CKA1TLQQw-/Screenshot-2025-04-29-at-10.42.15AM.png\" title=\"Screenshot 2025-04-29 at 10.42.15 AM.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1772x1478\" src=\"/user_uploads/thumbnail/3121/b5jqznBVxYigW_CKA1TLQQw-/Screenshot-2025-04-29-at-10.42.15AM.png/840x560.webp\"></a></div><p>So, I suppose the convenience for scientists is that someone else has already translated the math into a FORTRAN loop implementation, and all they'd need to do is to translate that into their context (usually, another imperative language).</p>",
        "id": 515086289,
        "sender_full_name": "Tyler Josephson ⚛️",
        "timestamp": 1745938425
    },
    {
        "content": "<p>I'd argue that the convenience is that there is no translation, and you just transcribe <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mo>∑</mo><mi>i</mi></msub><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\sum_i x_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0497em;vertical-align:-0.2997em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.162em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2997em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> as <code>∑ i, x i</code></p>",
        "id": 515104556,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1745942546
    },
    {
        "content": "<p>(I don't see where the <strong>n</strong> from that LaTeX went in the translation, or how \"the term with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo>=</mo><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">i = j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.854em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span></span></span></span> is to be excluded when <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"bold\">n</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">\\mathbf{n} = 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4444em;\"></span><span class=\"mord mathbf\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>\" is represented there)</p>",
        "id": 515104959,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1745942659
    },
    {
        "content": "<p>The above summation is a summation over <em>all</em> pairs in a periodic system. This is illustrated in revised Figure 2 (thanks <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> for point <a href=\"https://github.com/leanprover-community/mathlib4/pull/5\">#5</a> above)</p>\n<p>So the central green atom interacts with <em>every</em> purple and green atom in the extended system (which goes out infinitely), except for itself. That's what summing over i, j, and n does. It's halved to remove double-counting interactions from i to j with that from j to i.</p>",
        "id": 515119090,
        "sender_full_name": "Tyler Josephson ⚛️",
        "timestamp": 1745946522
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/mtViDSOyuZ6x-omTDlOzTJgu/MID.png\">MID.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/mtViDSOyuZ6x-omTDlOzTJgu/MID.png\" title=\"MID.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1961x1966\" src=\"/user_uploads/thumbnail/3121/mtViDSOyuZ6x-omTDlOzTJgu/MID.png/840x560.webp\"></a></div>",
        "id": 515119612,
        "sender_full_name": "Tyler Josephson ⚛️",
        "timestamp": 1745946687
    },
    {
        "content": "<p>But let me highlight a better equation - this is closer to our implementation:<br>\n<a href=\"/user_uploads/3121/UWjQildRQuB3EDVPFh1EM3oQ/Screenshot-2025-04-29-at-1.12.18PM.png\">Screenshot 2025-04-29 at 1.12.18 PM.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/UWjQildRQuB3EDVPFh1EM3oQ/Screenshot-2025-04-29-at-1.12.18PM.png\" title=\"Screenshot 2025-04-29 at 1.12.18 PM.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1742x1168\" src=\"/user_uploads/thumbnail/3121/UWjQildRQuB3EDVPFh1EM3oQ/Screenshot-2025-04-29-at-1.12.18PM.png/840x560.webp\"></a></div>",
        "id": 515120341,
        "sender_full_name": "Tyler Josephson ⚛️",
        "timestamp": 1745946916
    },
    {
        "content": "<p>If the interaction is truncated at a distance &lt; L/2, then you only need to keep track of one pair. You no longer need the 1/2 or the condition around i = j when the condition over the summation is i &lt; j.</p>",
        "id": 515120518,
        "sender_full_name": "Tyler Josephson ⚛️",
        "timestamp": 1745946970
    },
    {
        "content": "<p>Right, this is summing over <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.sym2#doc\">docs#List.sym2</a> or <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.sym2#doc\">docs#Finset.sym2</a></p>",
        "id": 515176936,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1745970930
    },
    {
        "content": "<p>Or two nested sums over <code>Ico 0 n</code> and <code>Ioo i n</code></p>",
        "id": 515177090,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1745971008
    }
]