[
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"240862\">Oliver Nash</span> <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/AI.20in.20math.20reasoning.20conference/near/368309738\">said</a>:</p>\n<blockquote>\n<p>Even more evil things are possible:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">12</span><span class=\"bp\">^</span><span class=\"mi\">3</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"mi\">10</span><span class=\"bp\">^</span><span class=\"mi\">3</span> <span class=\"bp\">+</span> <span class=\"mi\">9</span><span class=\"bp\">^</span><span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Wait how does that work? 12^3 is 1728 and 10^3+9^3 is 1729</p>",
        "id": 368555490,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1687440099
    },
    {
        "content": "<p><code>Nat.sub</code></p>",
        "id": 368555679,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1687440124
    },
    {
        "content": "<p>Oh damn. Default values</p>",
        "id": 368555779,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1687440137
    },
    {
        "content": "<p>You mean \"junk values\"?</p>",
        "id": 368555863,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1687440150
    },
    {
        "content": "<p>Yes junk values sounds more accurate</p>",
        "id": 368555996,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1687440172
    },
    {
        "content": "<p>But why do we use them instead of requiring a proof that the second value is not greater than the first</p>",
        "id": 368556477,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1687440260
    },
    {
        "content": "<p>That's stuff for a new thread. But see <a href=\"https://xenaproject.wordpress.com/2020/07/05/division-by-zero-in-type-theory-a-faq/\">https://xenaproject.wordpress.com/2020/07/05/division-by-zero-in-type-theory-a-faq/</a></p>",
        "id": 368556742,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1687440310
    },
    {
        "content": "<p>7 messages were moved here from <a class=\"stream-topic\" data-stream-id=\"219941\" href=\"/#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/AI.20in.20math.20reasoning.20conference\">#Machine Learning for Theorem Proving &gt; AI in math reasoning conference</a> by <span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span>.</p>",
        "id": 368566319,
        "sender_full_name": "Notification Bot",
        "timestamp": 1687441909
    },
    {
        "content": "<p>Question : why not use an <code>Option</code> Type with suitably deduced type class instances to define a \"partial\" function?</p>",
        "id": 368574926,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1687443162
    },
    {
        "content": "<p>Alternatively define an inductive type that includes the extra values (say <code>$-\\infty$</code> and <code>$\\infty$</code> in some algorithmic problems), and derive instances for those.</p>",
        "id": 368575201,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1687443206
    },
    {
        "content": "<p>A version of <code>Option Nat</code> with special notation is <code>WithBot Nat</code>. You can use it, but it seems to be more useful when you expect to actually make use of this additional \"bot\" value. When you expect to have true <code>Nat</code>s, (1) it should be said that you can't expect to know what a <code>Nat</code> expression means unless you know the definitions of the operations, and (2) when there's subtraction, it's on you to do a followup proof that you're not in the truncation regime. It's easy to check here that we are truncating:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">12</span><span class=\"bp\">^</span><span class=\"mi\">3</span> <span class=\"bp\">&lt;</span> <span class=\"o\">(</span><span class=\"mi\">10</span><span class=\"bp\">^</span><span class=\"mi\">3</span> <span class=\"bp\">+</span> <span class=\"mi\">9</span><span class=\"bp\">^</span><span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span>\n</code></pre></div>\n<p>Of course, if you're dealing with subtraction you can immediately move to <code>Int</code> with no loss of representation while also being able to do subtraction freely. That's much better than whatever algebraic structure <code>WithBot Nat</code> happens to be.</p>\n<p>And yes, there are types with infinities tacked on. For example, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=EReal#doc\">docs4#EReal</a> is <code>WithBot (WithTop ℝ)</code>, to model the extended real numbers.</p>",
        "id": 368613236,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1687449055
    },
    {
        "content": "<p>IMHO the superiority of the junk value design pattern over partial (or monadic) functions is an empircal observation.</p>\n<p>The best justification I have is that junk values allow you to defer the duty of proving the input was good, whereas a partial function requires you to immediately discharge this duty because the obligation exists at the type level (rather than the term level).</p>\n<p>Maybe one day some fancy new foundational idea will allow us the benefit of this deferral without having to nominate junk values.</p>",
        "id": 368614374,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1687449254
    },
    {
        "content": "<p>There is of course the chance/hope/wish/dream that proving that the input was good immediately <em>and</em> recording it in the type, will mean that at many other places the obligation can be discharged automatically by unification or other automation.</p>",
        "id": 368615601,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1687449480
    },
    {
        "content": "<p>We want to write <code>a ≤ b → b - a + a = b</code>, not <code>a ≤ b → </code> some bizarre stuff with subtypes.</p>",
        "id": 368615841,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1687449517
    },
    {
        "content": "<p>I think the way junk values are handled can be discomforting to those who have a programming background.</p>\n<ol>\n<li>On one hand, (functional) programmers like having type systems that can tell them during compilation whether they have programming defects. You never want to construct a junk value (that's a defect), and so they accept having proofs (via type compatibility) that everything is within bounds scattered throughout the program code.</li>\n<li>On the other, mathematicians write definitions (\"programs\") and then prove many things about them separately. There's less of a need to make sure the types in definitions are compatible because, if they weren't, then the expected proofs wouldn't carry through.</li>\n</ol>",
        "id": 368615846,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1687449518
    },
    {
        "content": "<p>Garden variety programmers are more used to junk values I think</p>",
        "id": 368616226,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1687449588
    },
    {
        "content": "<p>There is at least one case where I would consider the junk value to be not actually junk. When doing group theory, many cardinality results are stated with <code>nat.card</code> which uses <code>0</code> as a junk value when the type is infinite. But most cardinality results in group theory involve only multiplication and divisibility, in which case <code>0</code> is the perfect junk value.</p>",
        "id": 368617193,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1687449737
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"253861\">Thomas Browning</span> <a href=\"#narrow/stream/113488-general/topic/junk.20values/near/368617193\">said</a>:</p>\n<blockquote>\n<p>There is at least one case where I would consider the junk value to be not actually junk. When doing group theory, many cardinality results are stated with <code>nat.card</code> which uses <code>0</code> as a junk value when the type is infinite. But most cardinality results in group theory involve only multiplication and divisibility, in which case <code>0</code> is the perfect junk value.</p>\n</blockquote>\n<p>I don't have an example right away (I am inside a bus that is hot as an oven), but the issue with picking a junk value for an operation like this is that one might need different junk values for the same type in different circumstances</p>",
        "id": 368623451,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1687450807
    },
    {
        "content": "<p>Also, from a programming perspective it would be awesome if subtypes worked nicely, considering that something like that is often the sales pitch for dependent types.</p>",
        "id": 368624364,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1687450975
    },
    {
        "content": "<p>One should never rely on the specific value of a junk value (at least in mathematics) -- the whole point is that mathematicians shouldn't ever be calling those functions with values outside the \"mathematical region\". Maybe in programming it's different though.</p>",
        "id": 368624376,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1687450978
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/junk.20values/near/368624376\">said</a>:</p>\n<blockquote>\n<p>One should never rely on the specific value of a junk value (at least in mathematics) -- the whole point is that mathematicians shouldn't ever be calling those functions with values outside the \"mathematical region\". Maybe in programming it's different though.</p>\n</blockquote>\n<p>In programming, we eventually want to run programs. So ideally we are forced to prove that we aren't giving functions the wrong values, when we call a function</p>",
        "id": 368624770,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1687451062
    },
    {
        "content": "<p>However, also in programming, there is a rule \"trash in, trash out\".</p>",
        "id": 368625471,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1687451190
    },
    {
        "content": "<p>Dependently typed programming is supposed to improve static type checking to help exclude junk values.</p>",
        "id": 368625782,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1687451255
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"466334\">@Shreyas Srinivas</span> This is what I was trying to get at when I mentioned how junk values are discomforting to programmers. Said another way, is the person who writes the definition obligated to prove as they go that everything is perfectly compatible? Or is the obligation that you need to write follow-up theorems that the definition behaves exactly as expected?</p>\n<p>Dependent types are necessary in both cases. Sometimes though it's easier to write a program/definition with as simple typing as possible and then reserve dependent types for the proof object itself (dependent types are necessary for Lean-as-a-theorem-prover).</p>",
        "id": 368628716,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1687451839
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> I think this <code>Nat.card = 0</code> junk value is one that you can actually rely on, since it's mathematically meaningful: given an element <code>g : G</code> of a group <code>G</code>, then you get the exponentiation map <code>Int -&gt; G</code>, and <code>Nat.card</code> of the image of this map is exactly the non-negative generator of the kernel. <code>0</code> is the \"generic\" value for <code>Int</code> after all...</p>\n<p>This is just a counter to how you should \"never\" rely on a specific junk value. On the other hand, perhaps you're right and setting <code>Nat.card</code> to <code>0</code> for infinite types isn't junk, but a specification.</p>",
        "id": 368629936,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1687452085
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113488-general/topic/junk.20values/near/368628716\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> This is what I was trying to get at when I mentioned how junk values are discomforting to programmers. Said another way, is the person who writes the definition obligated to prove as they go that everything is perfectly compatible? Or is the obligation that you need to write follow-up theorems that the definition behaves exactly as expected?</p>\n<p>Dependent types are necessary in both cases. Sometimes though it's easier to write a program/definition with as simple typing as possible and then reserve dependent types for the proof object itself (dependent types are necessary for Lean-as-a-theorem-prover).</p>\n</blockquote>\n<p>Agreed. But it kind of negates the whole promise that dependent types force programmers to prove things. After all, who is checking if the programmer writes the theorems. </p>\n<p>I was wondering if we couldn't automate the proof checking for subtypes like liquid types. In lean, since there is no (at least widely known) inbuilt support for refinement types, I would assume this would be written as a meta program (with syntactic sugar) that takes in the program code, and spits a proof obligation as a goal state from which the proof can be completed if it hasn't already been (could they be called semi-liquid types? ;) )</p>",
        "id": 368635305,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1687453125
    },
    {
        "content": "<p>I don't think there's any promise being negated -- these are two ends of a spectrum, and in math-land, where theorems are the point, it seems to be fine to use junk values and avoid dependent types in definitions (and one of the things we try to avoid is \"dependent type hell\", which is when dependent types make it difficult to prove things).</p>\n<p>Dependent types are great and all, but I think what subtypes do in practice is make sure you're maintaining some local invariants -- this can help detect defects, but it does little for the bigger picture. After all, who is checking if a programmer writes a program that matches the specification? <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 368641239,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1687454323
    },
    {
        "content": "<p>Personally I suspect one reason functional programmers find \"discharge the obligation up front\" so much more natural is because we all grew up with weaker type systems that didn't <em>allow</em> us to save proofs til the end. We have to \"parse, not validate\" at the very start to get any type safety at all, because our usual type systems don't let us unfold function definitions in our proofs of properties, so if you don't do your proof right away, you've missed your chance.</p>",
        "id": 368647265,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1687455634
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"117987\">Patrick Stevens</span> <a href=\"#narrow/stream/113488-general/topic/junk.20values/near/368647265\">said</a>:</p>\n<blockquote>\n<p>Personally I suspect one reason functional programmers find \"discharge the obligation up front\" so much more natural is because we all grew up with weaker type systems that didn't <em>allow</em> us to save proofs til the end. We have to \"parse, not validate\" at the very start to get any type safety at all, because our usual type systems don't let us unfold function definitions in our proofs of properties, so if you don't do your proof right away, you've missed your chance.</p>\n</blockquote>\n<p>Maybe. But I think there is more to it, as I have already mentioned (and Kyle addressed): </p>\n<ol>\n<li>\n<p>Functional programmers want to run the code they write. The role of static type checking is to identify malformed programs before running them. They dont want to just prove that a function is well behaved as long as they dont make a mistake. They want the compiler to scream at them when they try to divide by zero, or violate a bound check on a collection. Even in Lean's Std, a lot of functions on the collection data structures are implemented with two or more alternatives, one of which requires proof obligation, another which has an Option type output, and sometimes a third that panics on bad arguments.</p>\n</li>\n<li>\n<p>The problem with putting a proof obligation in a separate theorem is, as I said before, the issue that the obligation to write the theorem doesn't exist. This then goes back to point 1.</p>\n</li>\n</ol>",
        "id": 368662367,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1687459276
    },
    {
        "content": "<p>In mathlib the obligation to write the theorem does exist, because mathlibs existence depends on the existence of theorems that depend on theorems that depend on theorems that are such \"spec api coherence lemmas for definitions with junk values\".</p>",
        "id": 368685790,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1687465436
    },
    {
        "content": "<p>By obligation, I mean something enforced by a compiler, specifically through compiler errors or warnings.</p>",
        "id": 368689320,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1687466454
    },
    {
        "content": "<p>To clarify, I am not complaining about the approach for math. I am sure that it works very well if proving theorems is the end goal, mathlib being good evidence for that.</p>",
        "id": 368690330,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1687466755
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113488-general/topic/junk.20values/near/368556742\">said</a>:</p>\n<blockquote>\n<p>That's stuff for a new thread. But see <a href=\"https://xenaproject.wordpress.com/2020/07/05/division-by-zero-in-type-theory-a-faq/\">https://xenaproject.wordpress.com/2020/07/05/division-by-zero-in-type-theory-a-faq/</a></p>\n</blockquote>\n<p>We submitted a paper and cited this blog post to explain why Lean defines 1/0=0. A peer reviewer (like us) found this blog post extremely helpful, saying “I was \"upset\" (in a scientific way) about an undefined derivative being assigned as zero.  After the blog post, I had made my peace with it, particularly after the last paragraph. …” They then suggested that we don’t rely on a blog post in the “volatile internet” to make such a critical point in our paper, and that we cite something more permanent. Does anyone have suggestions for papers or other citable works that illustrate the points of this blog post?</p>",
        "id": 368694448,
        "sender_full_name": "Tyler Josephson ⚛️",
        "timestamp": 1687467990
    },
    {
        "content": "<p>Anyone is welcome to do anything they like with the information on that blog post: I'll agree to any reuse of it, with or without citation, if that helps</p>",
        "id": 368695769,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1687468451
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"424214\">@Tyler Josephson ⚛️</span> : If they want something \"permanent\" maybe you could put the blog link in the wayback machine and  get the archive link for use as citation URL. As a bonus you also get the date on which it was archived, in case something changes in the future, and people want to know when you the page was in the state you describe in your citation.</p>",
        "id": 368714719,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1687476838
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 368714873,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1687476925
    },
    {
        "content": "<p>For programming specifically, there is a <code>divp</code> (notated by <code>/ₚ</code>) which requires you to prove that division is valid before you use it. I think if you are using integers, it also requires you to prove that the dividend is divisible by the divisor. I've never used it, but it might make sense to use a different operator in math and in programming. Something like <code>3 - 5 = 0</code> might be arguably worse than division by zero in terms of programming, though I suppose you could use integers instead of natural numbers. However, I do agree with everyone else here that the <code>1 / 0 = 0</code> convention makes more sense for mathematics at the present moment.</p>",
        "id": 368717479,
        "sender_full_name": "Niels Voss",
        "timestamp": 1687478547
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=divp#doc\">docs#divp</a> doesn't do anything useful on integers besides division by 1 and -1</p>",
        "id": 368726586,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1687482763
    },
    {
        "content": "<p>Oh right it requires the value to have an inverse. Maybe I was thinking of something else in mathlib</p>",
        "id": 368745445,
        "sender_full_name": "Niels Voss",
        "timestamp": 1687493317
    },
    {
        "content": "<p>I guess what I am looking for is something like <code>Program</code> in Coq : <a href=\"https://coq.inria.fr/refman/addendum/program.html#coq:flag.Program-Mode\">https://coq.inria.fr/refman/addendum/program.html#coq:flag.Program-Mode</a></p>",
        "id": 368832394,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1687514702
    },
    {
        "content": "<p>In lean, something like the following works :</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">incr</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">//</span> <span class=\"n\">y</span> <span class=\"bp\">≥</span> <span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"n\">prop</span><span class=\"o\">⟩</span>\n  <span class=\"n\">where</span>\n    <span class=\"n\">prop</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">linarith</span>\n</code></pre></div>\n<p>unless the where clause is put inside a <code>match</code> arm. Then the goal becomes some metavariable. For example see the goal for proof in</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">sub</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">//</span><span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span><span class=\"o\">})</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">x</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">sub</span> <span class=\"n\">x</span> <span class=\"o\">⟨</span><span class=\"n\">y.val</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">proof</span><span class=\"o\">⟩</span>\n      <span class=\"n\">where</span>\n        <span class=\"n\">proof</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n              <span class=\"gr\">sorry</span> <span class=\"c1\">--    .... ⊢ ?m.9036 x y</span>\n</code></pre></div>\n<p>and of course this leads to an error on proof also. I am guessing that <code>where</code> is always parsed as if it were outside the entire <code>match</code> expression</p>",
        "id": 368837620,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1687515665
    },
    {
        "content": "<p>In Coq's program mode, I get a message that there are so many unfulfilled obligations, then (in a similar fashion to conv here), I can access each obligation and write a proof for it. This is in addition to Coq trying to automatically prove the goals first.</p>",
        "id": 368838348,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1687515796
    },
    {
        "content": "<p>EDIT: Corrected example:<br>\nIn the second example, using <code>have</code> or <code>let</code> solves the issue a little bit (not metavars),  but the somehow the goal is still <code>yval ≤ m + 1</code> </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">sub</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">//</span><span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span><span class=\"o\">})</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">y.val</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span>\n  <span class=\"bp\">|</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">have</span> <span class=\"n\">proof</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n        <span class=\"n\">cases'</span> <span class=\"n\">y</span> <span class=\"k\">with</span> <span class=\"n\">yval</span> <span class=\"n\">yprop</span>\n        <span class=\"n\">simp_all</span>\n        <span class=\"n\">done</span> <span class=\"c1\">-- Error</span>\n      <span class=\"n\">sub</span> <span class=\"n\">m</span> <span class=\"o\">⟨</span><span class=\"n\">y.val</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">proof</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 368839791,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1687516050
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/113488-general/topic/junk.20values/near/368662367\">said</a>:</p>\n<blockquote>\n<p>Even in Lean's Std, a lot of functions on the collection data structures are implemented with two or more alternatives, one of which requires proof obligation, another which has an Option type output, and sometimes a third that panics on bad arguments.</p>\n</blockquote>\n<p>To me, this suggests that proof obligation, option, and panics are all useful ways to programmatically handle partial functions. In my experience  in CS, junk values are often quite useful. Panics (which use junk values) are useful when you want to ignore a particular edge case even if that edge case is not provably avoidable -- some failures are so fatal that handling them is irrelevant because everything else will fail  (this is particularly common in impure code). There are also many algorithms which work better with certain junk values e.g. <code>1/0=0</code> because that is the special case they want anyway. Similarly, the ability to preserve type homogeneity that junk values provide is sometimes more valuable than special casing(because doing otherwise may e.g. induce large performance costs or complicate the model too severely).</p>",
        "id": 373378919,
        "sender_full_name": "Mac Malone",
        "timestamp": 1688791037
    },
    {
        "content": "<p>An good example of where <code>Nat.sub</code> in particular is useful is for values which deplete but can never go below zero (e.g., resource counters or health counters in video games).</p>",
        "id": 373379097,
        "sender_full_name": "Mac Malone",
        "timestamp": 1688791140
    }
]