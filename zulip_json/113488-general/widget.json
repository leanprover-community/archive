[
    {
        "content": "<p>Hi everyone, I've built a prototype functional UI framework for lean that you can try out here: <a href=\"https://demo.edayers.com\" title=\"https://demo.edayers.com\">https://demo.edayers.com</a><br>\nIt's still very much WIP but I thought I would share it here now because I am now happy with it as a proof of concept.<br>\nThe idea is that you can use <code>widget.component</code> and <code>widget.html</code> to build a virtual HTML tree in Lean (with support for stateful components).<br>\nThere is a new constant called <code>save_widget</code> which performs the analogue of <code>save_info_thunk</code>. If this is called, then instead of rendering the goal state, the editor will render an interactive widget.  It is also possible for the widget to send commands to the editor.<br>\nThis means that it is possible to make an interactive UI for tactic states (eg you could click on a goal and it would give you a list of available tactics) entirely within lean, without having to write any javascript or C++.<br>\nThe UI building API is still very rough and subject to change.</p>\n<p>The source code is on a branch called 'widget'  in the following places: </p>\n<ul>\n<li>lean: <a href=\"https://github.com/EdAyers/lean/tree/widget\" title=\"https://github.com/EdAyers/lean/tree/widget\">https://github.com/EdAyers/lean/tree/widget</a></li>\n<li>vscode extension: <a href=\"https://github.com/EdAyers/vscode-lean/tree/widget\" title=\"https://github.com/EdAyers/vscode-lean/tree/widget\">https://github.com/EdAyers/vscode-lean/tree/widget</a></li>\n<li>lean-web-editor: <a href=\"https://github.com/EdAyers/lean-web-editor/tree/widget\" title=\"https://github.com/EdAyers/lean-web-editor/tree/widget\">https://github.com/EdAyers/lean-web-editor/tree/widget</a><br>\nAlso massive thanks to <span class=\"user-mention\" data-user-id=\"123965\">@Bryan Gin-ge Chen</span> for helping me get the emscripten build working!</li>\n</ul>",
        "id": 196758988,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1588852064
    },
    {
        "content": "<p>So apparently this can be used to implement go-to-definition in the goal view.  And it should also be possible to implement a feature where you can click on a subterm and it expands the implicit arguments.</p>",
        "id": 196759477,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1588852424
    },
    {
        "content": "<p>Yep, go-to-definition would require writing a hook in the client editor but subterm implicit arguments is straightforward. The tooltip message is generated by lean and it has the full tactic state and subexpression to work with when generating the UI.</p>",
        "id": 196759709,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1588852595
    },
    {
        "content": "<blockquote>\n<p>And it should also be possible to implement a feature where you can click on a subterm and it expands the implicit arguments.</p>\n</blockquote>\n<p>I would love to have something similar to <a href=\"https://blog.jetbrains.com/scala/2018/07/25/intellij-scala-plugin-2018-2-advanced-implicit-support-improved-patterns-autocompletion-semantic-highlighting-scalafmt-and-more/\" title=\"https://blog.jetbrains.com/scala/2018/07/25/intellij-scala-plugin-2018-2-advanced-implicit-support-improved-patterns-autocompletion-semantic-highlighting-scalafmt-and-more/\">IntelliJ's Scala Plugin's \"show implicits\"</a>.</p>\n<p>The other IntelliJ feature that I'd love to have is to select a subexpression (not just a single word) and to get the type of the whole subexpression.</p>\n<p>... and \"reverse go to definition\" which finds all uses of a definition in the codebase.</p>",
        "id": 196760259,
        "sender_full_name": "Jason Rute",
        "timestamp": 1588852974
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"115715\">Jason Rute</span> <a href=\"#narrow/stream/113488-general/topic/widget/near/196760259\" title=\"#narrow/stream/113488-general/topic/widget/near/196760259\">said</a>:</p>\n<blockquote>\n<p>The other IntelliJ feature that I'd love to have is to select a subexpression (not just a single word) and to get the type of the whole subexpression.</p>\n</blockquote>\n<p>That works on the demo right now.</p>",
        "id": 196760428,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1588853074
    },
    {
        "content": "<p>Oooh, this is slick!</p>",
        "id": 196760466,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1588853122
    },
    {
        "content": "<p>Only, when I have the counter, I don't see any other goal state anymore. And after the <code>split</code>, I only have 1 counter, whereas I interpret the comments as saying that I should see two. Is that right?</p>",
        "id": 196760559,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1588853172
    },
    {
        "content": "<p>Yes the counter replaces the goal state widget.</p>",
        "id": 196760600,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1588853210
    },
    {
        "content": "<p>But you could easily make a component that shows both the counter and the tactic state</p>",
        "id": 196760646,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1588853246
    },
    {
        "content": "<p>But what does the comment after the <code>split</code> mean?</p>",
        "id": 196760769,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1588853332
    },
    {
        "content": "<p>Should I then see two counters?</p>",
        "id": 196760776,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1588853338
    },
    {
        "content": "<p>There is a separate counter state (the number between buttons) for each command in the block. So if you click between the counters you can observe that the state is preserved, the idea is that you would use this state for ephemeral things like whether a UI menu is open or scroll position or whatever</p>",
        "id": 196760777,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1588853338
    },
    {
        "content": "<blockquote>\n<p>This means that it is possible to make an interactive UI for tactic states (eg you could click on a goal and it would give you a list of available tactics) entirely within lean, without having to write any javascript or C++.</p>\n</blockquote>\n<p>To flesh this out a little more, how would you implement this \"available tactics\" example?  Would you write a  \"widget\" (formally a function of type <code>component tactic_state string</code>) in lean similar to your <code>counter</code> example, but which looks at the tactic_state and then figures out which tactics are applicable (sort of a like many of the current tactics which generate <code>Try it:</code>s).  Then the result of that widget tactic would be printed on the right?</p>",
        "id": 196763830,
        "sender_full_name": "Jason Rute",
        "timestamp": 1588855303
    },
    {
        "content": "<p>I'm mixing up my types a little.  Can you call tactics from within your widgets (again, functions of type <code>component tactic_state string</code>)?  Maybe you would directly apply the tactic to the tactic_state?</p>",
        "id": 196764012,
        "sender_full_name": "Jason Rute",
        "timestamp": 1588855415
    },
    {
        "content": "<p>Yes that's the rough idea. Since <code>tactic a := tactic_state -&gt; interaction_monad (tactic_state x a)</code> (OWTTE) you can run tactics inside the 'view' method of a component. But you can't output a tactic_state to anywhere, instead you have to get the component to emit a string (as it does in the <code>counter</code> example) which is a command in the begin/end block.</p>",
        "id": 196764591,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1588855738
    },
    {
        "content": "<p>There is a helper def <code>widget.mk_tactic_widget</code> for making widgets which use tactics</p>",
        "id": 196765005,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1588855925
    },
    {
        "content": "<p>Yes I just found that.  Makes more sense.</p>",
        "id": 196765030,
        "sender_full_name": "Jason Rute",
        "timestamp": 1588855943
    },
    {
        "content": "<p>Also, one big advantage of this over just adding a tactic at the end of your block is that you can delay running this \"suggest\" tactic (which might be expensive) until the user clicks on the goal (or some button which says \"find relevant tactics\").  Is that the idea?</p>",
        "id": 196765223,
        "sender_full_name": "Jason Rute",
        "timestamp": 1588856028
    },
    {
        "content": "<p>Yes. Eg the contents of the type tooltip is not computed until you click on it</p>",
        "id": 196765485,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1588856156
    },
    {
        "content": "<p>currently  there is no support for having a long-running computation in a <code>task a</code> and having the UI update when it is done, so the user experience is not going to be great if there is a long-running comp that is needed before showing the UI</p>",
        "id": 196765673,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1588856247
    }
]