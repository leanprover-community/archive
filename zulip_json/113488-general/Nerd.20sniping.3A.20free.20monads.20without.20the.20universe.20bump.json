[
    {
        "content": "<p>It has come up a few times that we can construct a free monad from a functor <code>f</code> in Lean:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span><span class=\"w\"> </span><span class=\"n\">FreeMonad</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">FreeMonad</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">lift</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">FreeMonad</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">bind</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">FreeMonad</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">FreeMonad</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">FreeMonad</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">β</span>\n</code></pre></div>\n<p>We can then take a suitable quotient so that <code>FreeMonad f</code> is indeed a lawful monad, and if <code>f</code> is a lawful functor, then I think that <code>FreeMonad f</code> is indeed the free monad we were looking for. </p>\n<p>Unfortunately, <code>FreeMonad f</code> suffers a universe bump since its codomain is <code>Type (v + 1)</code>. After I was angry at Lean about this for some time, I finally convinced myself that this bump is unavoidable for some choices of <code>f</code>. For example, let <code>f α := α → Bool</code>. If we had a free monad <code>FreeMonad f : Type v → Type v</code>, then we could lift elements from <code>f (FreeMonad f α)</code> into <code>FreeMonad f (FreeMonad f α)</code> and flatten this into <code>FreeMonad f α</code>. I think, without having a formal proof, that this mapping is injective. But the cardinality of the power set <code>f (FreeMonad f α) = (FreeMonad f α → Bool)</code> is strictly larger than that of <code>FreeMonad f α</code>, so this injection is impossible. Contradiction.</p>\n<p>However, I can't help but ask whether we can avoid the universe bump in the following more restricted situation: Let <code>m : Type v → Type v</code> be any lawful monad. Can we construct the most general monad <code>m' : Type v → Type v</code>, without universe bump, that extends <code>m</code> by a new operation <code>op : m' PUnit</code>? By \"most general\", I mean that we don't assume any equations involving <code>op</code> except those we need to obtain a lawful monad.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>More formal problem statement</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>Is there a monad <code>m' : Type v → Type v</code> together with a morphism <code>m -&gt; m'</code> (i.e. a family of maps <code>m α → m' α</code> that preserves the monadic operations) such that for every monad morphism <code>m -&gt; n</code> and a choice of <code>opn : n Unit</code> there is exactly one lift <code>m' -&gt; n</code> that maps <code>op : m' PUnit</code> to <code>opn : n PUnit</code>?</p>\n</div></div>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Motivation</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>I have arrived at this question while working on the new iterator library. There, an iterator is represented as an element of some type <code>α : Type u</code>. In a simplified setting, we can iterate with repeated applications of <code>step : α → m (Option (α x β))</code>, where <code>β : Type v</code> contains the potential outputs of the iterator. I was wondering whether we can sometimes \"squash\" <code>α</code> into a lower universe if <code>v</code> (remember: <code>β : Type v</code>) is small enough. The idea is to represent the information of the iterator without reference to <code>α</code>, and this information could be encoded as a monad the extends <code>m</code> with a carefully chosen family of monadic <code>step</code> operations that only return the iterator's output value and keep the iterator object itself hidden in its internal state. This monad, in turn, gives rise to an interpreter of the free extension of <code>m</code> by the <code>step</code> operations, and if this free construction lives in a small universe, then we can \"squash\" <code>α</code> into this small universe.<br>\nThere are lots of complications I'm leaving out here. Moreover, even if we can find a construction without universe bumps, that wouldn't mean we could actually efficiently squash <code>α</code>, so this question is driven by curiosity, not practical applications.</p>\n</div></div>\n<p>The following obvious construction almost solves the problem but it requires a universe bump:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span><span class=\"w\"> </span><span class=\"n\">FreeMonad</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">lift</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">FreeMonad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">bind</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">FreeMonad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">FreeMonad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">FreeMonad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">β</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FreeMonad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">PUnit</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>I feel like <code>m</code> being a lawful monad should help us prevent paradoxes like the one from the power set example above. However, I couldn't come up with a concrete construction. Any ideas?</p>",
        "id": 513207610,
        "sender_full_name": "Paul Reichert",
        "timestamp": 1745098612
    },
    {
        "content": "<p>I came up against the same limitation in my own project! One answer is that the free monad of a <em>polynomial</em> functor <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor\"><code>PFunctor</code></a> does not require a universe bump.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">PFunctor</span><span class=\"bp\">.</span><span class=\"n\">Univariate</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span>\n\n<span class=\"sd\">/-- The free monad on a polynomial functor.</span>\n<span class=\"sd\">This extends the `W`-type construction with an extra `pure` constructor. -/</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">FreeM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PFunctor</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FreeM</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">roll</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"bp\">.</span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"bp\">.</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">FreeM</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FreeM</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Inhabited</span>\n\n<span class=\"sd\">/-- Lift an object of the base polynomial functor into the free monad. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">always_inline</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">inline</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">lift</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"bp\">.</span><span class=\"n\">Obj</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FreeM</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">FreeM</span><span class=\"bp\">.</span><span class=\"n\">roll</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">FreeM</span><span class=\"bp\">.</span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">))</span>\n\n<span class=\"sd\">/-- Bind operator on `FreeM P` operation used in the monad definition. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">always_inline</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">inline</span><span class=\"kd\">]</span>\n<span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">bind</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FreeM</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">FreeM</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">FreeM</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">β</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">FreeM</span><span class=\"bp\">.</span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">FreeM</span><span class=\"bp\">.</span><span class=\"n\">roll</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">FreeM</span><span class=\"bp\">.</span><span class=\"n\">roll</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">FreeM</span><span class=\"bp\">.</span><span class=\"n\">bind</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Lots of functors are polynomials, though I'm not sure if they apply to your use case</p>",
        "id": 513211675,
        "sender_full_name": "Quang Dao",
        "timestamp": 1745102181
    },
    {
        "content": "<p>Thanks! Very interesting! Unfortunately, I fear that that construction won't help in the general case of adjoining some new operation to an arbitrary monad. I find it more and more plausible that even such a modest extension can require a universe bump... quite surprising if you ask me.</p>",
        "id": 513296785,
        "sender_full_name": "Paul Reichert",
        "timestamp": 1745174678
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246591\">@Quang Dao</span> interesting, are there more low-level/without-deps approach to make a coinductive types?</p>",
        "id": 522572207,
        "sender_full_name": "Serhii Khoma (srghma)",
        "timestamp": 1749124323
    },
    {
        "content": "<p>Coinductives aren't supported by the Lean kernel, so I'm afraid the best way to get to them is via M-type construction / quotients of polynomial functors (<code>QPF</code> in mathlib)</p>",
        "id": 522618095,
        "sender_full_name": "Quang Dao",
        "timestamp": 1749136972
    },
    {
        "content": "<p>I made <a href=\"https://github.com/srhhma/lean-pipes/blob/main/Pipes/FreeMonad.lean\">free monad using church encoding</a> (though I couldnt make Proxy using it - couldnt make the function <a href=\"https://github.com/srhhma/lean-pipes/blob/f9fd768de2cd874cb459ed7a511aaddf1a69d15e/Pipes/InternalProxyF.lean#L113\"><code>flipComposeResponse</code></a>)</p>\n<p>Also tried to make Church-encoded Proxy (<a href=\"https://github.com/srhhma/lean-pipes/blob/f9fd768de2cd874cb459ed7a511aaddf1a69d15e/Pipes/Internal.lean#L200C22-L200C45\">though couldnt make <code>connectProducerConsumer</code> too</a> and theorems that are present in <a href=\"https://www.google.com/search?q=pipes+coq&amp;oq=pipes+coq&amp;gs_lcrp=EgZjaHJvbWUyBggAEEUYOTIICAEQABgWGB4yCAgCEAAYFhgeMg0IAxAAGIYDGIAEGIoFMgoIBBAAGIAEGKIEMgcIBRAAGO8FMgoIBhAAGIAEGKIEMgoIBxAAGIAEGKIEMgcICBAAGO8F0gEINjI1N2owajeoAgCwAgA&amp;sourceid=chrome&amp;ie=UTF-8\">coq version</a>)</p>\n<p><span class=\"user-mention\" data-user-id=\"246591\">@Quang Dao</span> I have a question. Is it possible to use Church encoding everywhere for coinductive datatypes instead of QPF?</p>",
        "id": 522970647,
        "sender_full_name": "Serhii Khoma (srghma)",
        "timestamp": 1749380480
    },
    {
        "content": "<p>Is <span class=\"user-mention\" data-user-id=\"677310\">@Tanner Duve</span>'s <a href=\"https://github.com/leanprover-community/mathlib4/pull/25491\">#25491</a> relevant to this thread?</p>",
        "id": 522972266,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1749382434
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"813382\">Serhii Khoma (srghma)</span> <a href=\"#narrow/channel/113488-general/topic/Nerd.20sniping.3A.20free.20monads.20without.20the.20universe.20bump/near/522970647\">said</a>:</p>\n<blockquote>\n<p>I made <a href=\"https://github.com/srhhma/lean-pipes/blob/main/Pipes/FreeMonad.lean\">free monad using church encoding</a> (though I couldnt make Proxy using it - couldnt make the function <a href=\"https://github.com/srhhma/lean-pipes/blob/f9fd768de2cd874cb459ed7a511aaddf1a69d15e/Pipes/InternalProxyF.lean#L113\"><code>flipComposeResponse</code></a>)</p>\n<p>Also tried to make Church-encoded Proxy (<a href=\"https://github.com/srhhma/lean-pipes/blob/f9fd768de2cd874cb459ed7a511aaddf1a69d15e/Pipes/Internal.lean#L200C22-L200C45\">though couldnt make <code>connectProducerConsumer</code> too</a> and theorems that are present in <a href=\"https://www.google.com/search?q=pipes+coq&amp;oq=pipes+coq&amp;gs_lcrp=EgZjaHJvbWUyBggAEEUYOTIICAEQABgWGB4yCAgCEAAYFhgeMg0IAxAAGIYDGIAEGIoFMgoIBBAAGIAEGKIEMgcIBRAAGO8FMgoIBhAAGIAEGKIEMgoIBxAAGIAEGKIEMgcICBAAGO8F0gEINjI1N2owajeoAgCwAgA&amp;sourceid=chrome&amp;ie=UTF-8\">coq version</a>)</p>\n<p><span class=\"user-mention silent\" data-user-id=\"246591\">Quang Dao</span> I have a question. Is it possible to use Church encoding everywhere for coinductive datatypes instead of QPF?</p>\n</blockquote>\n<p>This is really cool, and I'm out of my depth here. Perhaps others can answer</p>",
        "id": 522983373,
        "sender_full_name": "Quang Dao",
        "timestamp": 1749396221
    }
]