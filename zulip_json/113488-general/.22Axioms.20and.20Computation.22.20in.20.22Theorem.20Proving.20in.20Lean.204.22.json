[
    {
        "content": "<p>Hi,</p>\n<p>I'm re-reading the chapter \"<a href=\"https://leanprover.github.io/theorem_proving_in_lean4/axioms_and_computation.html\">Axioms and Computation</a>\" in \"Theorem Proving in Lean 4 but still a bit confused about this part:</p>\n<blockquote>\n<p>Lean's standard library defines an additional axiom, propositional extensionality, and a quotient construction which in turn implies the principle of function extensionality. These extensions are used, for example, to develop theories of sets and finite sets. We will see below that using these theorems can block evaluation in Lean's kernel, so that closed terms of type Nat no longer evaluate to numerals. But Lean erases types and propositional information when compiling definitions to bytecode for its virtual machine evaluator, and since these axioms only add new propositions, they are compatible with that computational interpretation. Even computationally inclined users may wish to use the classical law of the excluded middle to reason about computation. This also blocks evaluation in the kernel, but it is compatible with compilation to bytecode.</p>\n<p>The standard library also defines a choice principle that is entirely antithetical to a computational interpretation, since it magically produces \"data\" from a proposition asserting its existence. Its use is essential to some classical constructions, and users can import it when needed. But expressions that use this construction to produce data do not have computational content, and in Lean we are required to mark such definitions as noncomputable to flag that fact.</p>\n<p>Using a clever trick (known as Diaconescu's theorem), one can use propositional extensionality, function extensionality, and choice to derive the law of the excluded middle. As noted above, however, use of the law of the excluded middle is still compatible with bytecode compilation and code extraction, as are other classical principles, as long as they are not used to manufacture data.</p>\n</blockquote>\n<p>My questions are:</p>\n<ol>\n<li>What does it mean to \"block evaluation in Lean's kernel\"? From my understanding, given a Lean expression, the kernel tries to reduce it to a normal form. Does it mean this process is blocked? If so, at which step is it blocked? Is there a simple example to show this?</li>\n<li>These paragraphs have mentioned \"compilation to bytecode\", \"virtual machine evaluator\", \"code extraction\". Also, other resources (e.g., <a href=\"https://github.com/leanprover-community/lean4-metaprogramming-book/blob/master/md/main/02_overview.md#connection-to-compilers\">Metaprogramming in Lean 4</a>) have touched upon how Lean code is translated to C code and then compiled by a C compiler. However, I'm confused about how these concepts fit together. Or maybe some of them are only relevant to Lean 3 but not Lean 4? It would be great if there existed a unified explanation of what happens under the hood when one compiles/runs Lean. Currently, information on this topic seems to be quite scattered.</li>\n</ol>\n<p>Thank you!</p>",
        "id": 385705347,
        "sender_full_name": "Kaiyu Yang",
        "timestamp": 1692287717
    },
    {
        "content": "<p>Here's an example of a term that doesn't compute. They're fairly rare, in fact the main reason terms might not reduce in Lean is not because of Propext or Funext, but because of undecidability of defeq.</p>\n<p>It's a pretty random example though, you won't do stuff like this very often.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">|</span> <span class=\"n\">ofNat</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">T</span> <span class=\"n\">f</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"n\">id</span> <span class=\"o\">:=</span> <span class=\"n\">T.ofNat</span> <span class=\"mi\">0</span>\n  <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">id</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">funext</span><span class=\"bp\">;</span> <span class=\"n\">simp</span>\n  <span class=\"k\">let</span> <span class=\"n\">x'</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">cast</span> <span class=\"o\">(</span><span class=\"n\">congrArg</span> <span class=\"n\">T</span> <span class=\"n\">h.symm</span><span class=\"o\">)</span> <span class=\"n\">x</span>\n  <span class=\"k\">match</span> <span class=\"n\">x'</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">T.ofNat</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span>\n\n<span class=\"c1\">-- It is true that `n = 0`</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hfg</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"n\">f</span><span class=\"o\">),</span>\n    <span class=\"o\">(</span><span class=\"k\">match</span> <span class=\"n\">cast</span> <span class=\"o\">(</span><span class=\"n\">congrArg</span> <span class=\"n\">T</span> <span class=\"n\">hfg</span><span class=\"o\">)</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"n\">T.ofNat</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span><span class=\"o\">)</span>  <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"k\">match</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"bp\">|</span> <span class=\"n\">T.ofNat</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rintro</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">rfl</span> <span class=\"n\">n</span>\n    <span class=\"n\">rfl</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">]</span>\n  <span class=\"n\">apply</span> <span class=\"n\">h</span>\n  <span class=\"n\">simp</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">id</span><span class=\"o\">]</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">n</span> <span class=\"c1\">--works</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">--doesn't work</span>\n</code></pre></div>",
        "id": 385709212,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1692288835
    },
    {
        "content": "<p>Basically we prove that <code>T (fun x =&gt; (1 + x) - 1) = T id</code> and use this equality to define a function between them. I think this is the only time <code>propext</code> or <code>Quot.sound</code> will block computation in Lean4, when you cast across an equality of types that would not be provable without those axioms. This isn't something you do very often.</p>",
        "id": 385709702,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1692288990
    },
    {
        "content": "<p>The references to \"compilation to bytecode\", \"virtual machine evaluator\", \"code extraction\" are dated and inherited from Lean 3. They should be updated but Lean 4 is still actively working on a new code generator, so I think everyone's waiting for that to settle down until updating the docs.</p>",
        "id": 385717103,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1692291662
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span>  Thanks! That's really helpful.</p>",
        "id": 385718954,
        "sender_full_name": "Kaiyu Yang",
        "timestamp": 1692292364
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119741\">@François G. Dorais</span> Thanks! So in Lean 4, the \"compilation to bytecode\" in the paragraphs above can be roughly understood as \"generating C code\"? Also, how is the Lean 4 code generator under development different from the existing mechanism for generating C code (in <code>build/ir</code> after running <code>lake build</code>)?</p>",
        "id": 385719283,
        "sender_full_name": "Kaiyu Yang",
        "timestamp": 1692292511
    },
    {
        "content": "<p>And marking a function <code>noncomputable</code> just means the code generator cannot generate C code for this function?</p>",
        "id": 385720691,
        "sender_full_name": "Kaiyu Yang",
        "timestamp": 1692293022
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"584504\">Kaiyu Yang</span> <a href=\"#narrow/stream/113488-general/topic/.22Axioms.20and.20Computation.22.20in.20.22Theorem.20Proving.20in.20Lean.204.22/near/385719283\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"119741\">François G. Dorais</span> Thanks! So in Lean 4, the \"compilation to bytecode\" in the paragraphs above can be roughly understood as \"generating C code\"? Also, how is the Lean 4 code generator under development different from the existing mechanism for generating C code (in <code>build/ir</code> after running <code>lake build</code>)?</p>\n</blockquote>\n<p>Not 100% I will outline the current pipeline briefly:</p>\n<ol>\n<li>The parser takes the Lean code and turns it into <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Syntax#doc\">docs4#Lean.Syntax</a></li>\n<li>The elaborator then (among other things) turns the code into <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Expr#doc\">docs4#Lean.Expr</a> this is like the \"Type theory lambda calculus\" which can be type checked by the kernel</li>\n<li>Then a pipeline consisting of a piece of C++ and a piece of Lean turn this representation into <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.IR.Expr#doc\">docs4#Lean.IR.Expr</a>, applying all of the Lean compiler optimizations along the way</li>\n</ol>\n<p>This is where the paths split again:<br>\n4.1 in a sense <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.IR.Expr#doc\">docs4#Lean.IR.Expr</a> can be seen as bytecode and it is what gets executed with an interpreter if you run <code>#eval foo</code><br>\n4.2 you can also turn this representation into C or LLVM and compile that</p>\n<p>The new code generator aims at swapping out the procedure from step 3 onwards (it is right now at good progress with step 3 I would say). Namely:</p>\n<ol start=\"3\">\n<li>We aim to remove the C++ code and write the entire pipeline in Lean itself and provide better and more correct optimizations on top of that</li>\n</ol>\n<p>Since we operate in a different representation than the current pipeline we will at some point also swap out the implementation of 4.1/4.2 although their behavior should pretty much remain the same.</p>\n<p>Marking a function as <code>noncomputable</code> does not mean the generator <em>cannot</em> generate code for it it means you want to prohibit it from trying, while this is most often done on functions that we cannot generate code for you can in principle mark any function with it.</p>",
        "id": 385721958,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1692293538
    },
    {
        "content": "<p>Thanks! That's very clear.</p>",
        "id": 385724873,
        "sender_full_name": "Kaiyu Yang",
        "timestamp": 1692294772
    }
]