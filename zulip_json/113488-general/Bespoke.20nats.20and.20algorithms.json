[
    {
        "content": "<p>In the tutorial world of NNG4 I force people to prove 2+2=4 by unfolding numerals and rewriting <code>add_zero</code> and <code>add_succ</code>. I'm now adding an \"algorithm world\", an optional world where people who care more about the CS side of things can prove things like <code>20 + 20 = 40</code>. </p>\n<p>I was surprised by several things in the experiment below. <br>\n1) You can prove 100+200=300 in <code>MyNat</code> with <code>rfl</code> quickly. Is this Lean just doing tens of thousands of manipulations quickly or is something cleverer going on?<br>\n2) But you can't prove 1000+2000=3000 with <code>rfl</code> on <code>MyNat</code>, although you can with <code>Nat</code>. So there is special support for <code>Nat</code> in <code>rfl</code>?<br>\n3) <code>simp</code> uses <code>decide</code> and <code>norm_num</code> uses <code>simp</code>? Is that right?<br>\n4) But <code>decide</code> on <code>MyNat</code> is <em>worse</em> than <code>rfl</code>?? (it can't do 100+200=300) Can I write a better <code>decide</code>?<br>\n5) I am assuming that <code>norm_num</code> is doing something clever. How much hard work is it to make <code>norm_num</code> work on MyNat? Does this involve making binary nats? Can someone prove <code>1000+2000=3000</code> for <code>MyNat</code>? (without the hack of bijecting it with Nat, doing it there, and then moving back?) Can I teach this in NNG4?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">! Define bespoke naturals -/</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">MyNat</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span>\n<span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span> <span class=\"bp\">→</span> <span class=\"n\">MyNat</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">MyNat</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">! Get numerals working -/</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">myNatFromNat</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">x</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Nat.zero</span>   <span class=\"bp\">=&gt;</span> <span class=\"n\">MyNat.zero</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Nat.succ</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">MyNat.succ</span> <span class=\"o\">(</span><span class=\"n\">myNatFromNat</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">ofNat</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">MyNat</span> <span class=\"n\">n</span> <span class=\"n\">where</span>\n  <span class=\"n\">ofNat</span> <span class=\"o\">:=</span> <span class=\"n\">myNatFromNat</span> <span class=\"n\">n</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">! Get addition working -/</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">add</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span> <span class=\"bp\">→</span> <span class=\"n\">MyNat</span> <span class=\"bp\">→</span> <span class=\"n\">MyNat</span>\n  <span class=\"bp\">|</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">MyNat.zero</span>  <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span>\n  <span class=\"bp\">|</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">MyNat.succ</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">MyNat.succ</span> <span class=\"o\">(</span><span class=\"n\">MyNat.add</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Add</span> <span class=\"n\">MyNat</span> <span class=\"n\">where</span>\n  <span class=\"n\">add</span> <span class=\"o\">:=</span> <span class=\"n\">MyNat.add</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">! `rfl` experiments -/</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">10</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">20</span> <span class=\"bp\">=</span> <span class=\"mi\">30</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- OK</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">100</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">200</span> <span class=\"bp\">=</span> <span class=\"mi\">300</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- how the heck does this work so quickly???</span>\n\n<span class=\"c1\">-- example : (1000 : MyNat) + 2000 = 3000 := rfl -- max recursion depth has been reached</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1000</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">2000</span> <span class=\"bp\">=</span> <span class=\"mi\">3000</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- ℕ not MyNat</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">! `simp` experiments -/</span>\n\n<span class=\"c1\">-- example : (10 : MyNat) + 20 = 30 := by simp -- simp made no progress</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">! Get decidability working -/</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">instDecidableEq</span> <span class=\"o\">:</span> <span class=\"n\">DecidableEq</span> <span class=\"n\">MyNat</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">isTrue</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">rfl</span>\n<span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">isFalse</span> <span class=\"bp\">&lt;|</span> <span class=\"kd\">by</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨⟩</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">succ</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">isFalse</span> <span class=\"bp\">&lt;|</span> <span class=\"kd\">by</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨⟩</span>\n<span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">succ</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">match</span> <span class=\"n\">instDecidableEq</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">isTrue</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">isTrue</span> <span class=\"bp\">&lt;|</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">isFalse</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">≠</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">isFalse</span> <span class=\"bp\">&lt;|</span> <span class=\"kd\">by</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">h</span><span class=\"o\">⟩</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">h</span> <span class=\"n\">rfl</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">! `decide` experiments -/</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">10</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">20</span> <span class=\"bp\">=</span> <span class=\"mi\">30</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span> <span class=\"c1\">-- OK</span>\n\n<span class=\"c1\">-- example : (100 : MyNat) + 200 = 300 := by decide -- max recursion depth</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">! `simp` again -/</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">10</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">20</span> <span class=\"bp\">=</span> <span class=\"mi\">30</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"c1\">-- now works?!</span>\n\n<span class=\"c1\">-- example : (100 : MyNat) + 200 = 300 := by simp -- simp made no progress</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">! What about `norm_num`? -/</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">10</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">20</span> <span class=\"bp\">=</span> <span class=\"mi\">30</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">norm_num</span> <span class=\"c1\">-- presumably it tried `simp`?</span>\n\n<span class=\"c1\">-- example : (100 : MyNat) + 200 = 300 := by norm_num  -- unsolved goals `100 + 200 = 300`</span>\n</code></pre></div>",
        "id": 398910005,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1698417055
    },
    {
        "content": "<p>for 2), as far as I know, <code>Nat</code> operations are reduced with GMP in the kernel, and therefore are much faster.</p>",
        "id": 398910425,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1698417187
    },
    {
        "content": "<p>for 4), that's to be expected, <code>rfl</code> will check for decidable equality between the two terms, looking at their shape after reduction. <code>decide</code> on the other hand, is a function in your language, and will pattern-match on the two terms, and reduce iteratively, creating new terms and doing heavier computations. Note also that <code>native_decide</code> handles bigger numbers with no issue, though it still causes a stack-overflow on numbers too big:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">5000</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">2000</span> <span class=\"bp\">=</span> <span class=\"mi\">7000</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">native_decide</span> <span class=\"c1\">-- works</span>\n</code></pre></div>",
        "id": 398916571,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1698419252
    },
    {
        "content": "<p>Oh thanks Arthur! So both algorithms reduce but then one of them starts cancelling and the other one just goes \"yes they are the same\".</p>",
        "id": 398917120,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1698419432
    },
    {
        "content": "<p><code>rfl</code> reduces the two numbers and checks them syntactically. <code>decide</code> has to reduce the comparison function you gave as a <code>DecidableEq</code> instance, applied to your two arguments, doing heavier computations along the way, before checking whether the value is <code>isTrue</code> of <code>isFalse</code>.</p>",
        "id": 398917431,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1698419535
    },
    {
        "content": "<p>With a more efficient tail-recursive equality check, we can push <code>decide</code> a bit farther. But it still can't do 7000; apparently the interpreter has some internal recursion limit even for tail-recursive functions.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">MyNat</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span>\n<span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span> <span class=\"bp\">→</span> <span class=\"n\">MyNat</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">MyNat</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">myNatFromNat</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">x</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Nat.zero</span>   <span class=\"bp\">=&gt;</span> <span class=\"n\">MyNat.zero</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Nat.succ</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">MyNat.succ</span> <span class=\"o\">(</span><span class=\"n\">myNatFromNat</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">ofNat</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">MyNat</span> <span class=\"n\">n</span> <span class=\"n\">where</span>\n  <span class=\"n\">ofNat</span> <span class=\"o\">:=</span> <span class=\"n\">myNatFromNat</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">add</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span> <span class=\"bp\">→</span> <span class=\"n\">MyNat</span> <span class=\"bp\">→</span> <span class=\"n\">MyNat</span>\n  <span class=\"bp\">|</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">MyNat.zero</span>  <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span>\n  <span class=\"bp\">|</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">MyNat.succ</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">MyNat.succ</span> <span class=\"o\">(</span><span class=\"n\">MyNat.add</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Add</span> <span class=\"n\">MyNat</span> <span class=\"n\">where</span>\n  <span class=\"n\">add</span> <span class=\"o\">:=</span> <span class=\"n\">MyNat.add</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">beq</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span> <span class=\"bp\">→</span> <span class=\"n\">MyNat</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">true</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">succ</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n  <span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n  <span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">succ</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">beq</span> <span class=\"n\">m</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">beq_eq</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"n\">m</span><span class=\"o\">},</span> <span class=\"n\">beq</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">m</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">succ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">congrArg</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">beq_eq</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">beq_refl</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">beq</span> <span class=\"n\">n</span> <span class=\"n\">n</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">beq_refl</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">eq_beq</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">beq</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">beq_refl</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">instDecidableEq</span> <span class=\"o\">:</span> <span class=\"n\">DecidableEq</span> <span class=\"n\">MyNat</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">beq</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"k\">then</span>\n    <span class=\"n\">isTrue</span> <span class=\"bp\">$</span> <span class=\"n\">beq_eq</span> <span class=\"n\">h</span>\n  <span class=\"k\">else</span>\n    <span class=\"n\">isFalse</span> <span class=\"bp\">λ</span> <span class=\"n\">contra</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">eq_beq</span> <span class=\"n\">contra</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">10</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">20</span> <span class=\"bp\">=</span> <span class=\"mi\">30</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span> <span class=\"c1\">-- OK</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">100</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">200</span> <span class=\"bp\">=</span> <span class=\"mi\">300</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span> <span class=\"c1\">-- OK</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">5000</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">2000</span> <span class=\"bp\">=</span> <span class=\"mi\">7000</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span> <span class=\"c1\">-- max recursion depth</span>\n</code></pre></div>",
        "id": 398921922,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1698420881
    },
    {
        "content": "<p>For 1), isn't it only something like 600 operations?</p>",
        "id": 398925181,
        "sender_full_name": "Reid Barton",
        "timestamp": 1698422147
    },
    {
        "content": "<p>Computers are fast, e.g., this below runs in &lt;1 second in the <em>interpreter</em> ghci, which is doing something vaguely analogous to kernel reduction:</p>\n<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"nf\">myReplicate</span><span class=\"w\"> </span><span class=\"ow\">::</span><span class=\"w\"> </span><span class=\"kt\">Integer</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">a</span><span class=\"p\">]</span>\n<span class=\"nf\">myReplicate</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">[]</span>\n<span class=\"nf\">myReplicate</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"kt\">:</span><span class=\"w\"> </span><span class=\"n\">myReplicate</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"nf\">myEq</span><span class=\"w\"> </span><span class=\"ow\">::</span><span class=\"w\"> </span><span class=\"kt\">Eq</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"ow\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">a</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">a</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Bool</span>\n<span class=\"nf\">myEq</span><span class=\"w\"> </span><span class=\"kt\">[]</span><span class=\"w\"> </span><span class=\"kt\">[]</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">True</span>\n<span class=\"nf\">myEq</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"kt\">:</span><span class=\"n\">xs</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"kt\">:</span><span class=\"n\">ys</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kr\">if</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"kr\">then</span><span class=\"w\"> </span><span class=\"n\">myEq</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"kr\">else</span><span class=\"w\"> </span><span class=\"kt\">False</span>\n<span class=\"nf\">myEq</span><span class=\"w\"> </span><span class=\"kr\">_</span><span class=\"w\"> </span><span class=\"kr\">_</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">False</span>\n\n<span class=\"nf\">myConcat</span><span class=\"w\"> </span><span class=\"ow\">::</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">a</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">a</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">a</span><span class=\"p\">]</span>\n<span class=\"nf\">myConcat</span><span class=\"w\"> </span><span class=\"kt\">[]</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"n\">ys</span>\n<span class=\"nf\">myConcat</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"kt\">:</span><span class=\"n\">xs</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"kt\">:</span><span class=\"w\"> </span><span class=\"n\">myConcat</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">ys</span>\n\n<span class=\"nf\">main</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"o\">$</span>\n<span class=\"w\">  </span><span class=\"n\">myEq</span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"n\">myConcat</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">myReplicate</span><span class=\"w\"> </span><span class=\"mi\">100000</span><span class=\"w\"> </span><span class=\"nb\">()</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">myReplicate</span><span class=\"w\"> </span><span class=\"mi\">200000</span><span class=\"w\"> </span><span class=\"nb\">()</span><span class=\"p\">))</span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"n\">myReplicate</span><span class=\"w\"> </span><span class=\"mi\">300000</span><span class=\"w\"> </span><span class=\"nb\">()</span><span class=\"p\">)</span>\n</code></pre></div>",
        "id": 398925611,
        "sender_full_name": "Reid Barton",
        "timestamp": 1698422307
    },
    {
        "content": "<p>So then why does 1000+2000 fail?</p>",
        "id": 398932801,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1698424464
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> I think GHC will have bounded stack size for this implementation, but it is very unlikely that the kernel will have this property. I can check using lean4lean if you are interested, but my guess is that it's not strictly lazy evaluating, and a term of size <code>300000*&lt;term size of some relatively large intermediate&gt;</code> is actually produced at some point during the computation.</p>\n<p>Improving kernel reduction has been something I've been looking into with Leo. There are a lot of low hanging fruits. In fact, if you (or anyone else) has examples of proofs that require a lot of kernel reduction, it would be helpful to send them to me so that I can demonstrate progress on them. I don't think the lean 4 test suite has much in this area.</p>",
        "id": 398975758,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1698445414
    }
]