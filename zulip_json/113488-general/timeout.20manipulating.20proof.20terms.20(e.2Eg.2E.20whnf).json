[
    {
        "content": "<p>Hey! I'm using metaprogramming to analyze proof terms from mathlib, and simple manipulations in some of them seem to often cause timeouts. But these timeouts seem to be independent of that - just typechecking these terms by putting them in standalone files also doesn't work. Here is an example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">IntermediateField</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">instIsCompactlyGenerated2</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u_2</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_2</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">inst_1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">inst_2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">],</span><span class=\"w\"> </span><span class=\"n\">IsCompactlyGenerated</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">IntermediateField</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">F</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">E</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">  </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">    </span><span class=\"n\">exists_sSup_eq</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"n\">Exists</span><span class=\"bp\">.</span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"bp\">⟮</span><span class=\"n\">x</span><span class=\"bp\">⟯</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">''</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">s</span><span class=\"o\">)</span>\n<span class=\"w\">        </span><span class=\"bp\">⟨</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">          </span><span class=\"n\">Exists</span><span class=\"bp\">.</span><span class=\"n\">casesOn</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">            </span><span class=\"n\">And</span><span class=\"bp\">.</span><span class=\"n\">casesOn</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">left</span><span class=\"w\"> </span><span class=\"n\">right</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">right</span><span class=\"w\"> </span><span class=\"bp\">▸</span><span class=\"w\"> </span><span class=\"n\">IntermediateField</span><span class=\"bp\">.</span><span class=\"n\">adjoin_simple_isCompactElement</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span>\n<span class=\"w\">          </span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"n\">sSup_image</span>\n<span class=\"w\">            </span><span class=\"o\">(</span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">IntermediateField</span><span class=\"bp\">.</span><span class=\"n\">biSup_adjoin_simple</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">s</span><span class=\"o\">)</span>\n<span class=\"w\">              </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"n\">root_</span><span class=\"bp\">.</span><span class=\"n\">le_antisymm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">IntermediateField</span><span class=\"bp\">.</span><span class=\"n\">adjoin_le_iff</span><span class=\"bp\">.</span><span class=\"n\">mpr</span><span class=\"w\"> </span><span class=\"n\">le_rfl</span><span class=\"o\">)</span>\n<span class=\"w\">                </span><span class=\"o\">(</span><span class=\"n\">IntermediateField</span><span class=\"bp\">.</span><span class=\"n\">subset_adjoin</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">s</span><span class=\"o\">)))</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>\n<p>Running this file gives me <code>(deterministic) timeout at </code>whnf<code>, maximum number of heartbeats (200000) has been reached</code> (on v4.24.0-rc1). This term in particular is generated for a <a href=\"https://github.com/leanprover-community/mathlib4/blob/b0a3a60fe248ca40d44e35da24fee26fecbdb242/Mathlib/FieldTheory/IntermediateField/Adjoin/Basic.lean#L212\">typeclass instance</a>, but if it helps I have other small examples.</p>\n<p>The practical case for me happens when trying to iterate over <code>thmInfo</code> constants, converting their values into <a href=\"https://github.com/chasenorman/CanonicalLean\">Canonical</a>'s Term representation (which involves traversing the term and calling <code>whnf</code> and <code>inferType</code>), and then creating a dataset out of that. The current goal is to build a simple data structure to help guide proof search in Canonical. But since these timeouts are reproducible independently of Canonical, I wonder if it's unstable to do much with mathlib proof terms outside of the kernel besides just processing them syntactically (e.g., traversing them as <code>Expr</code>). Is that expected to happen?</p>",
        "id": 555641722,
        "sender_full_name": "Gabriel Poesia",
        "timestamp": 1763141072
    },
    {
        "content": "<p>To be clear, you're serialising proof terms into explicit lean code and reparsing it? I wouldn't be particularly surprised that that goes wrong</p>",
        "id": 555643865,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1763141804
    },
    {
        "content": "<p>In the actual use case I'm just trying to call <a href=\"https://github.com/chasenorman/CanonicalLean/blob/29da9c49ce69c70708f1234bc84b47013681c1e8/Canonical/ToCanonical.lean#L42\">Canonical.toTerm</a> on proof terms I get directly from the global context (so not reparsed). <code>toTerm</code> mostly relies on <code>whnf</code> and <code>inferType</code> while traversing the term. The file above is just a case where this times out, and yes, that's a case where printing and reparsing also times out (perhaps for similar underlying reasons?)</p>",
        "id": 555645589,
        "sender_full_name": "Gabriel Poesia",
        "timestamp": 1763142512
    },
    {
        "content": "<p>Does it work if you make everything explicit</p>",
        "id": 555646804,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763142962
    }
]