[
    {
        "content": "<p>Over this past week, I've been working on and off on a document that describes common pitfalls and footguns I've seen on this Zulip as well as things I personally struggled with when learning Lean. Topics covered include <code>autoImplicit</code>, integer division, distance in <code>Fin n ‚Üí ‚Ñù</code>, etc. The document is available here (although I would be willing to move it anywhere else or merge it into any other documentation if it makes sense to do so):<br>\n<a href=\"https://github.com/nielsvoss/lean-pitfalls\">https://github.com/nielsvoss/lean-pitfalls</a></p>\n<p>I am interested in hearing about whether or not this document is useful to you, as well as any mistakes I've made, writing that I should clean up, things I should add, and whether this is similar to something someone else has already made.</p>\n<p>This document was partially inspired by this message:<br>\n<span class=\"user-mention silent\" data-user-id=\"115715\">Jason Rute</span> <a href=\"#narrow/channel/219941-Machine-Learning-for-Theorem-Proving/topic/DeepSeek-Prover.20V2/near/515563136\">said</a>:</p>\n<blockquote>\n<p>Someone needs to write a document for AI researchers telling them about common pitfalls, axioms, checking proofs, errors in benchmarks, and other things which would embarrass them if they don't handle correctly.</p>\n</blockquote>\n<p>although it is designed to be of interest to all Lean users, and not just AI researchers. Also, I didn't add anything about the correct way to check lean proofs, because I don't think I understand the situation well enough to write about that (although I can add it in the future).</p>",
        "id": 520155520,
        "sender_full_name": "Niels Voss",
        "timestamp": 1748055186
    },
    {
        "content": "<p>Nice! Certainly seems like a.. virtuous thing to have.</p>\n<p>Notes from a scan through:</p>\n<ul>\n<li>I think the inlay hint functionality bears mentioning in the autoimplicit section as it makes them a lot less error prone (or at least a lot less invisibly poisonous, as long as someone knows to look for them)</li>\n<li>Possibly instead of executing <code>lake exe cache get</code> the \"recommended\" way to perform that these days is to invoke the action inside VSCode? I.e. <a href=\"https://github.com/leanprover/vscode-lean4/blob/master/vscode-lean4/manual/manual.md#project-actions\">here</a></li>\n<li>Maybe it's worth dividing the content into \"Lean language gotchas\", \"Math in Lean gotchas\" and \"Lean tooling/ecosystem gotchas\" (the above are the latter, but then you start with a few of the former two)</li>\n<li>It'd probably be nice to interlink mentions of tactics to the docs</li>\n<li><em>In Lean, <code>&lt;</code> and <code>‚â§</code> are preferred to <code>&gt;</code> and <code>‚â•</code></em> -- is this Lean, or Mathlib?</li>\n<li>\"Subtraction of natural numbers truncates at <code>0</code>\" -- maybe a few more words just saying this is because its return type has to be Nat?</li>\n<li>The \"Other partial functions\" section is so nice maybe it could be a table (of partial function, description, and what you add if you want to say your input is sane, if such a declaration exists?) Also maybe it's worth <em>not</em> mentioning the specific junk values or at least saying they're not meant to be relied on?</li>\n</ul>",
        "id": 520156634,
        "sender_full_name": "Julian Berman",
        "timestamp": 1748056178
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321696\">Julian Berman</span> <a href=\"#narrow/channel/113488-general/topic/Documenting.20lean.20pitfalls.3A.20feedback.20requested/near/520156634\">said</a>:</p>\n<blockquote>\n<ul>\n<li>I think the inlay hint functionality bears mentioning in the autoimplicit section as it makes them a lot less error prone (or at least a lot less invisibly poisonous, as long as someone knows to look for them)</li>\n</ul>\n</blockquote>\n<p>Done.</p>\n<blockquote>\n<ul>\n<li>Possibly instead of executing <code>lake exe cache get</code> the \"recommended\" way to perform that these days is to invoke the action inside VSCode? I.e. <a href=\"https://github.com/leanprover/vscode-lean4/blob/master/vscode-lean4/manual/manual.md#project-actions\">here</a></li>\n</ul>\n</blockquote>\n<p>I edited the cache section to be less terminal-centric, and mentioned this.</p>\n<blockquote>\n<ul>\n<li>Maybe it's worth dividing the content into \"Lean language gotchas\", \"Math in Lean gotchas\" and \"Lean tooling/ecosystem gotchas\" (the above are the latter, but then you start with a few of the former two)</li>\n</ul>\n</blockquote>\n<p>To be honest I don't really know how to organize this. I originally tried to place the most common errors closest to the top (<code>autoImplicit</code> comes up more often than <code>native_decide</code>, for often) but then I tried to group the library gotchas together, and now it's fairly disorganized. I'll have to think about how best to do this.</p>\n<p>In any case, I don't know if they divide that easily into groups. Integer division could be considered a \"Math in Lean gotcha\" but the way in which type inference relates to integer division could be considered a \"Lean language gotcha\".</p>\n<blockquote>\n<ul>\n<li>It'd probably be nice to interlink mentions of tactics to the docs</li>\n</ul>\n</blockquote>\n<p>Some tactics are documented in the reference manual, but some are mathlib specific. Is there a centralized documentation location for tactics?</p>\n<p>In the future this document might be verso-ified if it makes sense which will remove the need to manually link tactics but this makes sense for the meantime once I get around to it.</p>\n<blockquote>\n<ul>\n<li><em>In Lean, <code>&lt;</code> and <code>‚â§</code> are preferred to <code>&gt;</code> and <code>‚â•</code></em> -- is this Lean, or Mathlib?</li>\n</ul>\n</blockquote>\n<p>I don't know. I think I'll wait for further community input.</p>\n<blockquote>\n<ul>\n<li>\"Subtraction of natural numbers truncates at <code>0</code>\" -- maybe a few more words just saying this is because its return type has to be Nat?</li>\n</ul>\n</blockquote>\n<p>Done.</p>\n<blockquote>\n<ul>\n<li>The \"Other partial functions\" section is so nice maybe it could be a table (of partial function, description, and what you add if you want to say your input is sane, if such a declaration exists?) Also maybe it's worth <em>not</em> mentioning the specific junk values or at least saying they're not meant to be relied on?</li>\n</ul>\n</blockquote>\n<p>I can consider this, but the point of listing these functions is just to make the point that a lot of unrelated functions in Mathlib behave this way and this is generally something to watch out for. The list is not anywhere close to comprehensive.</p>\n<p>Is there consensus on whether or not junk values should be considered implementation details? I know there were some comments about how <code>0 / 0</code> could return <code>37</code> and no one would be bothered but that isn't at all what I've seen in Mathlib; lemmas in Mathlib seem quite happy to rely on the specific junk values.</p>",
        "id": 520159343,
        "sender_full_name": "Niels Voss",
        "timestamp": 1748058914
    },
    {
        "content": "<p>I definitely made that comment in my \"why is 1/0=0\" blog post but I was well aware at the time that it was not 100% accurate; some junk values are better than others. I decided to leave it there to stress the point that it was not the actual value that mattered, just that there had to be a value.</p>",
        "id": 520174521,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1748072840
    },
    {
        "content": "<p>An \"index of junk values\" would be good to maintain more broadly, I think. </p>\n<p>Division by zero, subtracting Nats, sure. But also things like: Real.sqrt on negatives, Real.log 0, subtracting NNReal or ENNReal, basically any arithmetic with EReal or ENNReal that would conventionally be a NaN (quick: what is top - bottom? Bottom * 0?), division of Nat rounds down... Division of PNat rounds down like Nat except that 1/5=1... etc etc</p>",
        "id": 520216178,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1748108078
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"448405\">Alex Meiburg</span> <a href=\"#narrow/channel/113488-general/topic/Documenting.20lean.20pitfalls.3A.20feedback.20requested/near/520216178\">said</a>:</p>\n<blockquote>\n<p>(quick: what is top - bottom? Bottom * 0?)</p>\n</blockquote>\n<p>Well clearly <code>‚ä§ - ‚ä• = ‚ä§</code>, and I also know that <code>‚ä• * 0 = 0</code></p>",
        "id": 520216608,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1748108431
    },
    {
        "content": "<p>Maybe Mathlib should keep test files for these junk values, as a place to document choices made + motivation</p>",
        "id": 520216797,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1748108566
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/stream/113488-general/topic/Documenting.20lean.20pitfalls.3A.20feedback.20requested/near/520216608\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"448405\">Alex Meiburg</span> <a href=\"#narrow/channel/113488-general/topic/Documenting.20lean.20pitfalls.3A.20feedback.20requested/near/520216178\">said</a>:</p>\n<blockquote>\n<p>(quick: what is top - bottom? Bottom * 0?)</p>\n</blockquote>\n<p>Well clearly <code>‚ä§ - ‚ä• = ‚ä§</code>, and I also know that <code>‚ä• * 0 = 0</code></p>\n</blockquote>\n<p>Sure yes, I meant to say top + bottom or top - top. (Which is much less intuitive to me.) I accidentally did \"both\" when I wrote the message :)</p>",
        "id": 520219572,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1748110700
    },
    {
        "content": "<p>Nice work! I remember being surprised by the division by zero (I was working with Rat).</p>\n<p>As for something to add: this may be a hot take, but array indexing by Fins. Basically ask them to read <a href=\"https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Isn%27t.20Fin.20a.20bad.20type.20for.20safe.20array.20lookup.3F.html\">this</a>. I'm not sure if anything has changed since then; Functional Programming in Lean still recommends <a href=\"https://docs.lean-lang.org/functional_programming_in_lean/programs-proofs/fin.html\">using Fins for indexing</a>. To rank the various indexing options from most safe to least:</p>\n<ul>\n<li><code>a[i]'bounds_proof</code>. Safe but tedious. Perhaps package the index value i and the bounds_proof together into a Subtype to pass around. </li>\n<li><code>a[i]?</code> I truly am not sure whether i is in bounds or not</li>\n<li><code>a[i]!</code> I am a Java/Python programmer; I sometimes venture into C++ but use <code>.at()</code> instead of <code>[]</code>. If I make a mistake, my program will at least give a runtime error.</li>\n<li><code>a[i]</code> with Fin type index. I write C/C++ and live on the edge. I just want to turn off bounds checking. If I make a mistake, which I won't.... valgrind will catch it, right?...</li>\n</ul>\n<p>The last option is so convenient, I sometimes use it because I was too lazy to do the safer way. I'm a C++ programmer, what can say...</p>",
        "id": 520219861,
        "sender_full_name": "GasStationManager",
        "timestamp": 1748110926
    },
    {
        "content": "<p>How is using <code>Fin</code> for indexing dangerous?</p>\n<p>Edit: I see, it's not that it causes undefined behavior, it's that it causes confusing total code</p>",
        "id": 520220503,
        "sender_full_name": "Niels Voss",
        "timestamp": 1748111472
    },
    {
        "content": "<p>I think the current way indexing is designed makes it unfortunate when you have a <code>Fin n</code> and want to pass it to a <code>Fin n -&gt; A</code> packed as a vector or the like</p>",
        "id": 520220890,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1748111820
    },
    {
        "content": "<p>like that shouldn't be hard but the typeclasses put so much junk in the term</p>",
        "id": 520220912,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1748111841
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/113488-general/topic/Documenting.20lean.20pitfalls.3A.20feedback.20requested/near/520220912\">said</a>:</p>\n<blockquote>\n<p>like that shouldn't be hard but the typeclasses put so much junk in the term</p>\n</blockquote>\n<p>What kind of junk?</p>",
        "id": 520221603,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1748112427
    },
    {
        "content": "<p>opened <a href=\"https://github.com/leanprover-community/mathlib4/pull/25173\">#25173</a> as an attempt at this, making a MathlibTest file documenting lots of junk values. I'm sure there are many more to add.</p>",
        "id": 520254018,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1748144253
    },
    {
        "content": "<p>Another pitfall with default/junk values arises with indexed inf / sup: <code>‚®Ö i ‚àà s, f i</code> is the infimum over all <code>i</code> in the relevant type of the infimum over all proofs of <code>i ‚àà s</code> of <code>f i</code>, and that infimum over proofs can be a default value for <code>i</code> not in <code>s</code>, resulting in the outer inf not giving the desired result.</p>",
        "id": 520528339,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1748292664
    },
    {
        "content": "<p>I'm not sure I understand. Can you provide a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> or link to a zulip thread that discusses this issue?</p>",
        "id": 520536332,
        "sender_full_name": "Niels Voss",
        "timestamp": 1748297008
    },
    {
        "content": "<p>Regarding \"Parameters for instances that already exist\": one sign that this sort of \"instance diamond\" behavior is occuring is if two quantities that look identical in the infoview, are not being treated as equal by Lean (e.g., they are not being cancelled in the expected fashion by tactics such as <code>rfl</code>, <code>congr</code>, <code>convert</code>, etc.).  Often one has to hover over the various terms in the infoview to look at various implicit instances that are used; sometimes one has to go two or three levels deep into a type before one sees the discrepancy.</p>",
        "id": 520538273,
        "sender_full_name": "Terence Tao",
        "timestamp": 1748298276
    },
    {
        "content": "<p>That's a good point. I've encountered this exact problem with the infoview a lot in the past. It seems to be more common for function calls than notation, because if there was an extra <code>One Nat</code> instance for example, the bad <code>1</code> value seems to display as <code>One.one</code> which is at least a clue that something is going on.</p>\n<p>A somewhat artificial MWE is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Topology</span><span class=\"bp\">.</span><span class=\"n\">MetricSpace</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MetricSpace</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">dist</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">.</span><span class=\"n\">dist</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"c\">/-</span>\n<span class=\"cm\">  Tactic state:</span>\n<span class=\"cm\">  1 goal</span>\n<span class=\"cm\">  inst : MetricSpace ‚Ñù</span>\n<span class=\"cm\">  ‚ä¢ dist 0 1 = dist 0 1</span>\n<span class=\"cm\">  -/</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>where you can no longer tell in the infoview that the two distance functions are the same.</p>",
        "id": 520540937,
        "sender_full_name": "Niels Voss",
        "timestamp": 1748299870
    },
    {
        "content": "<p>I will add a note about this in the document but I'm hoping that in the future this can be fixed at the level of the delaborator. Perhaps the delaborator could keep track of which instances have been inferred for a given typeclass and if they aren't all definitionally equal, it could print them all explicitly.</p>",
        "id": 520541098,
        "sender_full_name": "Niels Voss",
        "timestamp": 1748299980
    },
    {
        "content": "<p>I could be misremembering but I think <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> did some related work on this sort of thing. Maybe just relating to error messages and not showing ones that say \"foo expected got foo\"</p>",
        "id": 520546426,
        "sender_full_name": "Julian Berman",
        "timestamp": 1748303214
    },
    {
        "content": "<p>Yeah, it shows the difference between both <code>dist</code>s when you try using <code>rfl</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MetricSpace</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">dist</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">.</span><span class=\"n\">dist</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"c\">/-</span>\n<span class=\"cm\">  tactic 'rfl' failed, the left-hand side</span>\n<span class=\"cm\">    @dist ‚Ñù (@PseudoMetricSpace.toDist ‚Ñù Real.pseudoMetricSpace) 0 1</span>\n<span class=\"cm\">  is not definitionally equal to the right-hand side</span>\n<span class=\"cm\">    @dist ‚Ñù (@PseudoMetricSpace.toDist ‚Ñù MetricSpace.toPseudoMetricSpace) 0 1</span>\n<span class=\"cm\">  inst : MetricSpace ‚Ñù</span>\n<span class=\"cm\">  ‚ä¢ dist 0 1 = dist 0 1</span>\n<span class=\"cm\">  -/</span>\n</code></pre></div>",
        "id": 520547320,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1748303788
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"657719\">@Terence Tao</span> When <code>congr</code>/<code>convert</code> creates side goals, do you ever try using <code>rfl</code> on them to help play the spot-the-difference puzzle? (This UI could be improved, but that's the one trick I know might help.)</p>\n<p>I wonder if Eq in general should pretty print with differences made explicit.</p>",
        "id": 520548306,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1748304323
    },
    {
        "content": "<p>No, but thanks for the tip.</p>",
        "id": 520559071,
        "sender_full_name": "Terence Tao",
        "timestamp": 1748310579
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"521331\">Niels Voss</span> <a href=\"#narrow/channel/113488-general/topic/Documenting.20lean.20pitfalls.3A.20feedback.20requested/near/520536332\">said</a>:</p>\n<blockquote>\n<p>I'm not sure I understand. Can you provide a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> or link to a zulip thread that discusses this issue?</p>\n</blockquote>\n<p>I think David Loeffler's example here <a class=\"message-link\" href=\"/#narrow/channel/287929-mathlib4/topic/sup.20and.20inf.20over.20sets/near/472565284\">#mathlib4 &gt; sup and inf over sets @ üí¨</a> explains the (terrifying!) issue very clearly :-)</p>",
        "id": 520619522,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1748337448
    },
    {
        "content": "<p>Another general pitfall is when manipulating elements <code>x</code> of a set <code>S: Set X</code> via the subtype <code>(x:S)</code> rather than <code>(x:X) (hx: x ‚àà S)</code>.  The two are of course related by <code>Subtype.val</code>, but when I first started out I was tripped out for a long time by the fact that various lemmas holding in <code>X</code> that I wanted to use did not seem to be applicable to elements of <code>S</code>.</p>\n<p>The situation gets worse when dealing with finite sets of <code>X</code>, which are modeled by no fewer than four different structures: <code>(S : Finset X)</code>, <code>(S: Set X) [Fintype S]</code>, <code>(S: Set X) (hS: Set.Finite S)</code>, and <code>(S: Set X) [Finite S]</code>(in two of these cases there is an implicit coercion from a set to its associated subtype).  But that (together with some companion discussion on decidable equality) requires a whole separate guide I think...</p>",
        "id": 520692794,
        "sender_full_name": "Terence Tao",
        "timestamp": 1748358716
    },
    {
        "content": "<p>Yeah, for example, the confusion with \"finite sets\" just happened minutes ago in <a class=\"stream-topic\" data-stream-id=\"217875\" href=\"/#narrow/channel/217875-Is-there-code-for-X.3F/topic/Finite.20sum.20over.20two.20disjoint.20sets/with/520688214\">#Is there code for X? &gt; Finite sum over two disjoint sets</a></p>",
        "id": 520694139,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1748359085
    },
    {
        "content": "<p>There is a general mistake (not sure if a pitfall) that I do of not noticing types of numerals. The same numeral can have different types with no visual distinction in infoview, consider following</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">^</span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">rpow_sub</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">ring_nf</span>\n<span class=\"w\">  </span><span class=\"c\">/-</span>\n<span class=\"cm\">  state now is following, h2 and goal seem same, but they are not</span>\n<span class=\"cm\">  x y : ‚Ñù</span>\n<span class=\"cm\">  h1 : 0 &lt; y</span>\n<span class=\"cm\">  h2 : y ^ 3 = 10</span>\n<span class=\"cm\">  ‚ä¢ y ^ 3 = 10</span>\n<span class=\"cm\">  -/</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"w\">  </span><span class=\"c1\">-- doesn't work</span>\n</code></pre></div>\n<p>Maybe this could also be added</p>",
        "id": 520694343,
        "sender_full_name": "Sabbir Rahman",
        "timestamp": 1748359144
    },
    {
        "content": "<p>This should probably be mentioned as a pitfall:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚®Ü</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">le_antisymm</span>\n<span class=\"w\">  </span><span class=\"bp\">¬∑</span><span class=\"w\"> </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">ciSup_le</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">iSup_le</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">le_rfl</span>\n<span class=\"w\">    </span><span class=\"n\">linarith</span>\n<span class=\"w\">  </span><span class=\"bp\">¬∑</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">iSup_nonneg'</span>\n<span class=\"w\">    </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"mi\">37</span>\n<span class=\"w\">    </span><span class=\"n\">norm_num</span>\n</code></pre></div>",
        "id": 520695180,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1748359370
    },
    {
        "content": "<p>(oh, <span class=\"user-mention\" data-user-id=\"266253\">@Joseph Myers</span> already mentioned this)</p>",
        "id": 520695291,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1748359407
    },
    {
        "content": "<p>Having two non-def-eq instances is another common pitfall (related to the mentioned \"don't use have for data\" and the \"parameters for instances that already exist\")</p>",
        "id": 520695750,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1748359534
    },
    {
        "content": "<p>Maybe mention <code>#lint</code> somewhere (in the \"ignoring warnings\" section?), which can also spot some common errors (e.g. syntactic tautologies)</p>",
        "id": 520695930,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1748359582
    },
    {
        "content": "<p>This list seems very useful, and we should definitely link it from the learning resources page! I'd also be in favor of making this an official subpage of <a href=\"https://leanprover-community.github.io/\">https://leanprover-community.github.io/</a></p>",
        "id": 520696388,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1748359715
    },
    {
        "content": "<p>Thank you for all the suggestions everyone! I will try to see if I have time to go through and implement them later today.</p>",
        "id": 520697775,
        "sender_full_name": "Niels Voss",
        "timestamp": 1748360040
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/stream/113488-general/topic/Documenting.20lean.20pitfalls.3A.20feedback.20requested/near/520696388\">said</a>:</p>\n<blockquote>\n<p>This list seems very useful, and we should definitely link it from the learning resources page! I'd also be in favor of making this an official subpage of <a href=\"https://leanprover-community.github.io/\">https://leanprover-community.github.io/</a></p>\n</blockquote>\n<p>I would be willing to move the document anywhere that's best for the community.</p>",
        "id": 520698103,
        "sender_full_name": "Niels Voss",
        "timestamp": 1748360117
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"776090\">GasStationManager</span> <a href=\"#narrow/channel/113488-general/topic/Documenting.20lean.20pitfalls.3A.20feedback.20requested/near/520219861\">said</a>:</p>\n<blockquote>\n<p>Nice work! I remember being surprised by the division by zero (I was working with Rat).</p>\n<p>As for something to add: this may be a hot take, but array indexing by Fins. Basically ask them to read <a href=\"https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Isn%27t.20Fin.20a.20bad.20type.20for.20safe.20array.20lookup.3F.html\">this</a>. I'm not sure if anything has changed since then; Functional Programming in Lean still recommends <a href=\"https://docs.lean-lang.org/functional_programming_in_lean/programs-proofs/fin.html\">using Fins for indexing</a>. To rank the various indexing options from most safe to least:</p>\n<ul>\n<li><code>a[i]'bounds_proof</code>. Safe but tedious. Perhaps package the index value i and the bounds_proof together into a Subtype to pass around. </li>\n<li><code>a[i]?</code> I truly am not sure whether i is in bounds or not</li>\n<li><code>a[i]!</code> I am a Java/Python programmer; I sometimes venture into C++ but use <code>.at()</code> instead of <code>[]</code>. If I make a mistake, my program will at least give a runtime error.</li>\n<li><code>a[i]</code> with Fin type index. I write C/C++ and live on the edge. I just want to turn off bounds checking. If I make a mistake, which I won't.... valgrind will catch it, right?...</li>\n</ul>\n<p>The last option is so convenient, I sometimes use it because I was too lazy to do the safer way. I'm a C++ programmer, what can say...</p>\n</blockquote>\n<p>I just tried this and as far as I can tell, the <code>xs[n]</code> notation doesn't seem to assume that <code>n</code> is a <code>Fin</code> unless you explicitly give it that type. It seems to me that the only unintuitive part is that <code>Fin</code> arithmetic is wrapping and I don't see any issues with the indexing notation.</p>",
        "id": 520805621,
        "sender_full_name": "Niels Voss",
        "timestamp": 1748409587
    },
    {
        "content": "<p>I will however be adding a section on how <code>Fin</code> arithmetic is wrapping and how <code>Fin</code> is different from <code>ZMod</code></p>",
        "id": 520805727,
        "sender_full_name": "Niels Voss",
        "timestamp": 1748409651
    },
    {
        "content": "<p>Changelog:</p>\n<ul>\n<li>Added note about using <code>rfl</code> to detect mismatching instances</li>\n<li>Added section on using <code>Set</code>s as types and the implicit coercion to Subtype</li>\n<li>Added note about #lint to the ignoring warnings section</li>\n<li>Added section about wrapping arithmetic in Fin</li>\n</ul>\n<p>TODO:</p>\n<ul>\n<li>Add section on the counterintuitive iInf behavior mentioned in this thread</li>\n<li>Describe the different ways to describe Finite sets (maybe this should just be a short section with a link to a more detailed description in another resource?)</li>\n<li>(Maybe) Add section on the difference between <code>Prop</code> and <code>Bool</code>, <code>True</code> vs <code>true</code>, and <code>=</code> vs <code>==</code>.</li>\n</ul>",
        "id": 520809481,
        "sender_full_name": "Niels Voss",
        "timestamp": 1748411961
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"521331\">Niels Voss</span> <a href=\"#narrow/channel/113488-general/topic/Documenting.20lean.20pitfalls.3A.20feedback.20requested/near/520805621\">said</a>:</p>\n<blockquote>\n<ul>\n<li><code>a[i]</code> with Fin type index. I write C/C++ and live on the edge. I just want to turn off bounds checking. If I make a mistake, which I won't.... valgrind will catch it, right?...</li>\n</ul>\n</blockquote>\n<p>I'm confused about the claim that <code>a[i]</code> is unsafe in a memory safety sense <span class=\"user-mention\" data-user-id=\"776090\">@GasStationManager</span>. If <code>i : Fin a.size</code>, then <code>a[i]</code> is exactly the same as <code>a[i.1]'i.2</code>, right? The \"unsafe\" part is just that the arithmetic silently wraps around and you might not get the element you thought you were getting.</p>",
        "id": 520837896,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1748422504
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> I didn't mean to suggest that <code>a[i]</code> is memory unsafe, sorry for being unclear. I guess what I meant is that silently wrapping is sometimes even worse, in that it's harder to debug; in C/C++ if you go out of bounds at least tools like valgrind can catch it. And good C programmers know they are living on the edge and are willing to use tools like valgrind, whereas <code>a[i]</code> with Fin gives you a sense of security, that <code>i</code> is \"proven\" to be in bounds, so don't even think of looking here for bugs.</p>",
        "id": 520907788,
        "sender_full_name": "GasStationManager",
        "timestamp": 1748442735
    },
    {
        "content": "<p>I do think <code>a[i]</code> with Fin can be done safely, just like C/C++ style array access can be safe. You just need to make sure the rest of your code's logic has not accidentally wrapped the index around. So if it is a simple loop or forall over the values of <code>Fin a.size</code>, it should be fine.</p>",
        "id": 520917548,
        "sender_full_name": "GasStationManager",
        "timestamp": 1748445252
    },
    {
        "content": "<p>Ah I see, your question \"valgrind will catch it, right?\" is following Betteridge's law of headlines: no, no it won't.</p>",
        "id": 520917744,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1748445321
    },
    {
        "content": "<p>People like addition wrapping on Fin because without it you can't use <code>+</code> at all without jumping through hoops supplying proofs. Presumably C++ programmers expect to be able to use \"unsafe <code>+</code>\" but in Lean \"unsafe <code>+</code>\" is either \"inconvenient <code>+</code> where you have to supply proofs every time\" or \"<code>+</code> taking values in <code>Option</code>\" (also super-inconvenient) or \"<code>+</code> taking junk values\". I have suggested removing <code>+</code> from <code>Fin n</code> completely on the basis that if you want to add things you should just add <code>a.1</code> and <code>b.1</code> and then supply the proof that <code>a.1+b.1&lt;n</code> yourself) (didn't go down well) and I've also suggested that <code>+</code> saturates on n-1 (also didn't go down well) and I am always happy to point out that if you <em>want</em> wrapping <code>+</code> then we have <code>ZMod n</code> which everyone <em>expects</em> to have a wrapping <code>+</code>; at the end of the day I don't really get why we have <code>+</code> on Fin n at all but apparently some people want it enough to think it's OK that other people will get totally confused by it. We get regular questions on the Zulip from people who can't figure out why <code>(2 : Fin 3) + (2 :Fin 3)</code> works.</p>",
        "id": 520974512,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1748466597
    },
    {
        "content": "<p>Does what I've added to the document yesterday (under \"Wrapping arithmetic on Fin\") cover this to a sufficient extent?</p>",
        "id": 520974977,
        "sender_full_name": "Niels Voss",
        "timestamp": 1748466764
    },
    {
        "content": "<p>Has the #eval vector indexing issue been fixed? It used to be the case that #eval would sorry out proof obligations like the index check on Vector if it couldn‚Äôt find a proof and then promptly crash the editor if the index was out of bounds. If this is unfixed or has been deemed fine then it could count as a pitfall.</p>",
        "id": 520975361,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1748466937
    },
    {
        "content": "<p><code>#eval</code> gives an error if the term depends on <code>sorry</code> in any way now</p>",
        "id": 520975506,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1748466987
    },
    {
        "content": "<p>There was also that issue of creating an array of size exactly 33 or something. Upto 32 it would work fast and after that lean would grind to a halt. This was pointed out only a few months ago</p>",
        "id": 520975669,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1748467068
    },
    {
        "content": "<p>I think this could be flagged under one pitfall ‚Äúit is hard to predict when FBIP or some C implementation kicks in when writing functions without looking carefully at the IR‚Äù or more succinctly ‚ÄúFBIP is highly non trivial‚Äù.</p>",
        "id": 520975911,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1748467154
    },
    {
        "content": "<p>Another point: the discussion on native_decide should also mention other such tactics like csimp and bv_decide</p>",
        "id": 520976787,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1748467621
    },
    {
        "content": "<p>Here is another pitfall: spending a lot of time looking for an \"obvious\" lemma that is, in fact, true by definition. </p>\n<p>For instance, when I was still new to Lean I had at some point wanted to prove<code>Function.Injective f</code> for some <code>f</code>.  I spent a fair amount of time scouring Mathlib for some sort of <code>Function.injective_iff</code> type lemma that would equate this with the assertion that if <code>f x = f y</code> then <code>x = y</code> (or maybe the contrapositive of this statement).  It took an embarrassingly long amount of time before I actually opened the definition of <code>Function.Injective</code> and saw that this lemma I needed was in fact true by definition, and I could just directly open up this claim with <code>intro x y hxy</code> and continue with the proof.  So I guess the point is that one should actually inspect the formal definition of key mathematical concepts and not just rely on the API.</p>\n<p>EDIT: okay, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Function.injective_iff_pairwise_ne#doc\">docs#Function.injective_iff_pairwise_ne</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Function.not_injective_iff#doc\">docs#Function.not_injective_iff</a> do exist, but hopefully my broader point still stands.</p>",
        "id": 520978276,
        "sender_full_name": "Terence Tao",
        "timestamp": 1748468371
    },
    {
        "content": "<p>I think that situation has improved quite a bit with <code>exact?</code> and <code>apply?</code></p>",
        "id": 520978860,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1748468644
    },
    {
        "content": "<p>These days if I don‚Äôt know how to prove it, I set up a simple example and play around with these tactics until I find the correct lemma.</p>",
        "id": 520978914,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1748468679
    },
    {
        "content": "<p>Fair enough.  For instance with</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">Injective</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">hint</span>\n</code></pre></div>\n<p>The first suggestion is indeed <code>intro</code>, which is a good start.  </p>\n<p>Another example is subset inclusion: one can get started on proving <code>A ‚äÜ B</code> with <code>intro x hx</code> rather than try to look for something like an axiom of extensionality (there is no <code>Set.subset_iff</code> method in Mathlib).</p>",
        "id": 520979346,
        "sender_full_name": "Terence Tao",
        "timestamp": 1748468882
    },
    {
        "content": "<p>That's <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.subset_def#doc\">docs#Set.subset_def</a></p>",
        "id": 520980989,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1748469693
    },
    {
        "content": "<p>(not an iff for some reason)</p>",
        "id": 520981081,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1748469723
    },
    {
        "content": "<p>OK, that was embarrassing.  Perhaps my experience is outdated, coming from a time when Mathlib was somewhat less developed.  Would it be standard practice nowadays to add some <code>concept_iff</code> or <code>concept_def</code> lemmas that are true by <code>rfl</code> every time a new <code>Concept</code> is defined?</p>\n<p>I guess one could also just <code>unfold</code> any definition within tactic mode.  Perhaps I should simply withdraw this suggested addition to the document.  (Though perhaps it is still worth making the point that Mathlib doesn't operate on a 100% \"object-oriented programming\" philosophy, in that it still assumes that the Mathlib user is willing to unfold objects and classes to use their implementation, rather than just the provided API.)</p>",
        "id": 520981547,
        "sender_full_name": "Terence Tao",
        "timestamp": 1748469918
    },
    {
        "content": "<p>I've never really known when to add <code>_iff</code>/<code>_def</code> lemmas and when not. If they're exact statements of definitions, they're superfluous, since there are auto-generated such lemmas (e.g. <code>Function.Injective.eq_def</code>, which doesn't show up in documentation, but which has the type <code>‚àÄ {Œ± : Sort u_1} {Œ≤ : Sort u_2} (f : Œ± ‚Üí Œ≤), Function.Injective f = ‚àÄ ‚¶Éa‚ÇÅ a‚ÇÇ : Œ±‚¶Ñ, f a‚ÇÅ = f a‚ÇÇ ‚Üí a‚ÇÅ = a‚ÇÇ</code>), but on the other hand since they don't show up in documentation it can be hard to know if it's something you're supposed to rely on or not.</p>\n<p>Sometimes there are definitions that seem like they could change. In those cases having definition lemmas is nice, but if you know in advance the definition might change, maybe it should be changed immediately...</p>\n<p>Definition lemmas that characterize a definition are nice though. For example, that <code>Nat.find</code> gives the least natural number satisfying a predicate, rather than the concrete implementation.</p>",
        "id": 520983677,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1748471002
    },
    {
        "content": "<p>More generally, mathlib isn't great at making it clear what is supposed to be considered an implementation detail or not. The \"classic example\" of an implementation detail in Mathlib is <code>Set X</code> being defeq to <code>X -&gt; Prop</code> but I'm willing to bet that if we changed the definition of <code>Set X</code> a ton of mathlib would break. Of course, there's the argument that since Mathlib doesn't make any attempt to be backwards incompatible, we don't have to worry as much about this.</p>",
        "id": 520984149,
        "sender_full_name": "Niels Voss",
        "timestamp": 1748471276
    },
    {
        "content": "<p>So the thing is there are easy ways to go between <code>iff</code> and <code>=</code>. There is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=propext#doc\">docs#propext</a> in one direction and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Iff.of_eq#doc\">docs#Iff.of_eq</a>` in the other.</p>",
        "id": 520986756,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1748472771
    },
    {
        "content": "<p>Also rw works with both kinds of statements</p>",
        "id": 520986908,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1748472868
    },
    {
        "content": "<p>So the distinction is practically just in the name.</p>",
        "id": 520986954,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1748472900
    },
    {
        "content": "<p>I think the question is not whether the lemma should be <code>iff</code> of <code>=</code> (although that is a reasonable question), but whether either type of lemma should be added at all, or if we should just rely on tactics like <code>unfold</code></p>",
        "id": 520987035,
        "sender_full_name": "Niels Voss",
        "timestamp": 1748472957
    },
    {
        "content": "<p>Don‚Äôt we have rewriting with definitions now? Isn‚Äôt that the main purpose of these iff and def lemmas?</p>",
        "id": 520988924,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1748474018
    },
    {
        "content": "<p>We've had rewriting with definitions for a long time, pre Lean 4</p>",
        "id": 520989303,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1748474261
    },
    {
        "content": "<p>Then it probably makes sense to have iff lemmas since it takes some standard extra steps over unfold to go from a definition to an iff lemma and from that to an mp or mpr.</p>",
        "id": 520990550,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1748475051
    },
    {
        "content": "<p>I think it's definitely a good idea to have lemmas like that, even without the \"maybe we'll change the definition\" argument (which I subscribe to as well). For example, I recently used subset_def so I could apply a simp lemma for x \\in (one of the sets in the subset expression)</p>",
        "id": 521026394,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1748498797
    },
    {
        "content": "<p>Perhaps one could add the functionality to allow an automatically generated lemma to be explicitly added to the documentation via some suitable line in the Lean file?  Not sure what the right syntax would be here but I'm thinking something like <code>@[document] Function.Injective.eq_def</code>.</p>",
        "id": 521027508,
        "sender_full_name": "Terence Tao",
        "timestamp": 1748499362
    },
    {
        "content": "<p>I'm less convinced that we want to rely on the automatically generated lemma, though, since I think the lemma should be stable under changes to the actual underlying definition</p>",
        "id": 521027904,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1748499549
    },
    {
        "content": "<p>But it could still be useful to have it in the documentation, of course</p>",
        "id": 521027961,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1748499585
    },
    {
        "content": "<p>One could flag it in the documentation as auto-generated</p>",
        "id": 521028028,
        "sender_full_name": "Terence Tao",
        "timestamp": 1748499603
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/113488-general/topic/Documenting.20lean.20pitfalls.3A.20feedback.20requested/near/520989303\">said</a>:</p>\n<blockquote>\n<p>We've had rewriting with definitions for a long time, pre Lean 4</p>\n</blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"o\">]</span>\n<span class=\"c1\">-- invalid '‚Üê' modifier, 'foo' is a declaration name to be unfolded</span>\n</code></pre></div>\n<p><span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span></p>",
        "id": 521032205,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1748501797
    },
    {
        "content": "<p>The day simp allows me to refold definitions, I will start claiming that we truly have \"rewriting with definitions\" and have a strong argument against adding all those <code>_def</code> and <code>_iff</code> lemmas</p>",
        "id": 521032310,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1748501874
    },
    {
        "content": "<blockquote>\n<p>Some tactics are documented in the reference manual, but some are mathlib specific. Is there a centralized documentation location for tactics?</p>\n</blockquote>\n<p>Are you aware of the mathlib manual? <a href=\"https://leanprover-community.github.io/mathlib-manual/html-multi/Tactics/All-tactics\">https://leanprover-community.github.io/mathlib-manual/html-multi/Tactics/All-tactics</a> That has a list of all tactics.</p>",
        "id": 521066228,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1748514671
    },
    {
        "content": "<p>I just finished reading the whole document. Thanks a lot for compiling this; it's great to have such a list (and I also learned a thing or two).<br>\nI have two small comments/suggestions:</p>\n<ul>\n<li>about the unicode characters table: move the asterisk next to the \"vertical dots\"? Right now, between * and various central dots there are various arrows (which look quite different).</li>\n<li>non-terminal simps: do you know about the flexible linter and the distinction between flexible and rigid tactics? (This has definitely been discussed on zulip, I'm not sure if it's documented anywhere else already. It probably should be...)</li>\n</ul>",
        "id": 521068907,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1748515698
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/channel/113488-general/topic/Documenting.20lean.20pitfalls.3A.20feedback.20requested/near/521027904\">said</a>:</p>\n<blockquote>\n<p>I'm less convinced that we want to rely on the automatically generated lemma, though, since I think the lemma should be stable under changes to the actual underlying definition</p>\n</blockquote>\n<p>You could have a command like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">generated_def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bar</span>\n</code></pre></div>\n<p>which checks whether a lemma <code>foo</code> with type <code>Bar</code> exists. This would ensure that changes in the auto-generated lemma don't go unnoticed. There could also be a code action that adds the type after <code>generated_def foo</code>.</p>",
        "id": 521069681,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1748516006
    },
    {
        "content": "<p>If the idea is that these lemmas are a stable API to a potentially changing definition, then they should probably not be autogenerated</p>",
        "id": 521073444,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1748517360
    },
    {
        "content": "<p>Could the papercut linter be extended or modified to catch constants in mathlib which are floats? (Perhaps that one will land more quickly; I'm certainly happy to review it.) Or is there some use of them in mathlib that I have overlooked?<br>\nCC <span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span></p>",
        "id": 521083417,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1748521132
    },
    {
        "content": "<p>I'm also wondering: could or should the papercut linter be modified to catch addition (or multiplication) on Fin n --- within mathlib, where <code>ZMod</code> is presumably what the user wants instead?</p>",
        "id": 521083515,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1748521178
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/113488-general/topic/Documenting.20lean.20pitfalls.3A.20feedback.20requested/near/521073444\">said</a>:</p>\n<blockquote>\n<p>If the idea is that these lemmas are a stable API to a potentially changing definition, then they should probably not be autogenerated</p>\n</blockquote>\n<p>I don't see the downside of auto-generated definitions in combination with my proposal. If the definition changes, the <code>generated_def</code> throws an error and you replace it with an actual theorem to preserve the API. I guess if you care about defeqs of the auto-generated definition, you'd need to include these as well.</p>",
        "id": 521083954,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1748521356
    },
    {
        "content": "<p>Catching floats with a linter is pretty easy.  The linter cannot simply inspect the <em>syntax</em>, since floats do not have a unique dedicated kind, but examining the infotrees, or the resulting expression you can detect the presence of <code>Float</code>s.</p>",
        "id": 521092861,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1748524701
    },
    {
        "content": "<p>The <code>papercut</code> linter is currently dormant: I got stumped while trying to make it more aware of the local context and then got sidetracked by other issues.</p>",
        "id": 521092991,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1748524754
    },
    {
        "content": "<p>I do not exclude going back to it, but it will probably not be in the short term.  If someone else wants to bump it and revive it, I would be happy to take a look!</p>",
        "id": 521093089,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1748524789
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Ya√´l Dillies</span> <a href=\"#narrow/channel/113488-general/topic/Documenting.20lean.20pitfalls.3A.20feedback.20requested/near/521032205\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/113488-general/topic/Documenting.20lean.20pitfalls.3A.20feedback.20requested/near/520989303\">said</a>:</p>\n<blockquote>\n<p>We've had rewriting with definitions for a long time, pre Lean 4</p>\n</blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"o\">]</span>\n<span class=\"c1\">-- invalid '‚Üê' modifier, 'foo' is a declaration name to be unfolded</span>\n</code></pre></div>\n<p><span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span></p>\n</blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"bp\">.</span><span class=\"n\">eq_def</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 521094215,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1748525113
    },
    {
        "content": "<p>Another example of definition lemmas is when you have a field of a structure, and that field is used indirectly in some notation class. You need to write a definition lemma to unfold that notation for that structure in a controlled manner. Recent example: <a class=\"message-link\" href=\"/#narrow/channel/270676-lean4/topic/.E2.9C.94.20Simplifier.20simplifying.20too.20much/near/521136995\">#lean4 &gt; ‚úî Simplifier simplifying too much @ üí¨</a></p>",
        "id": 521138360,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1748539670
    },
    {
        "content": "<p>I've been busy these past two weeks, so I didn't finish the document yet, but I'm hoping to finish implementing the rest of the suggestions in this thread within the next few days. I just added a section on the difference between <code>Prop</code> and <code>Bool</code>.</p>",
        "id": 523692904,
        "sender_full_name": "Niels Voss",
        "timestamp": 1749713411
    },
    {
        "content": "<p>That being said, I'm happy to hear more suggestions if anyone has any</p>",
        "id": 523693427,
        "sender_full_name": "Niels Voss",
        "timestamp": 1749713607
    },
    {
        "content": "<p>I like this document.</p>",
        "id": 523699556,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749715710
    },
    {
        "content": "<p>Regarding using Fin for indexing: this isn't simp-normal, is it? Morally speaking I like using Nat for indexing but trusting in get_elem_tactic most of the time so I don't explicitly have to give a proof for it.</p>",
        "id": 523699743,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749715772
    },
    {
        "content": "<p>I think something I would say is true, I'm not sure if it's a pitfall or not, but morally speaking every <code>def</code> statement, I believe, creates a mortgage that one has to pay back with the creation of suitable API.</p>",
        "id": 523700107,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749715880
    },
    {
        "content": "<p>I think when one is starting out one defines a lot of stuff, but over time you begin to realise that that's just a way to spend a lot of time unwrapping things or ending in lemma hell.</p>",
        "id": 523700246,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749715918
    },
    {
        "content": "<p>I'd have to check tomorrow but I don't think using Fin for indexing is actually the default; if you don't mention Fin I don't think your code will do wrapping arithmetic</p>",
        "id": 523700328,
        "sender_full_name": "Niels Voss",
        "timestamp": 1749715942
    },
    {
        "content": "<p>Definitions have meaning, I believe, only when they connect into an existing set of definitions that are robust.</p>",
        "id": 523700398,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749715964
    },
    {
        "content": "<p>A \"formalisation\" that just makes definitions and proves stuff about those definitions with reference to each other isn't in my view very meaningful.</p>",
        "id": 523700540,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749716009
    },
    {
        "content": "<p>There is a real skill in making a \"good\" definition I find. Perhaps that's more true in some contexts than others.</p>",
        "id": 523700645,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749716039
    },
    {
        "content": "<p>Something you could mention, which I think in some ways is more of a Mathlib thing but is true in general, is how you declare that something is a group. </p>\n<p>In maths obviously the normal way is to say \"G is a set with an operation yadda yadda\". But obviously in Mathlib G is normally a type and we then assert the existence of a <code>Group G</code> instance.</p>",
        "id": 523700948,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749716140
    },
    {
        "content": "<p>Related, there's probably something about propositional and definitional equality and the perils of instance diamonds that you could add.</p>",
        "id": 523701215,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749716220
    },
    {
        "content": "<p>If I were to add a section on definitions, I guess it could be called \"Overuse of definitions\"</p>",
        "id": 523702137,
        "sender_full_name": "Niels Voss",
        "timestamp": 1749716549
    },
    {
        "content": "<p>Would it make more sense if there was a dedicated \"tips for writing definitions\" document?</p>",
        "id": 523702742,
        "sender_full_name": "Niels Voss",
        "timestamp": 1749716762
    },
    {
        "content": "<p>I can try to add a section on definitional vs propositional equality. What would you say is the most likely problem new users run into when they aren't aware of this distinction?</p>",
        "id": 523703185,
        "sender_full_name": "Niels Voss",
        "timestamp": 1749716912
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/113488-general/topic/Documenting.20lean.20pitfalls.3A.20feedback.20requested/near/520975669\">said</a>:</p>\n<blockquote>\n<p>There was also that issue of creating an array of size exactly 33 or something. Upto 32 it would work fast and after that lean would grind to a halt. This was pointed out only a few months ago</p>\n<p>I think this could be flagged under one pitfall ‚Äúit is hard to predict when FBIP or some C implementation kicks in when writing functions without looking carefully at the IR‚Äù or more succinctly ‚ÄúFBIP is highly non trivial‚Äù.</p>\n</blockquote>\n<p>I can see how this would be a pitfall, but I don't actually know what this error is or what FBIP is. So I don't think I'm qualified to write about this unless you can provide me a link to a discussion. Also, do we know if this is going to be fixed when the new compiler releases?</p>",
        "id": 524081762,
        "sender_full_name": "Niels Voss",
        "timestamp": 1749926821
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/113488-general/topic/Documenting.20lean.20pitfalls.3A.20feedback.20requested/near/520976787\">said</a>:</p>\n<blockquote>\n<p>Another point: the discussion on native_decide should also mention other such tactics like csimp and bv_decide</p>\n</blockquote>\n<p>I thought csimp was an attribute, not a tactic? Also, is <code>bv_decide</code> really as risky as <code>native_decide</code> (as in, does it let you depend on an unbounded number of extensions to the compiler?)</p>",
        "id": 524086376,
        "sender_full_name": "Niels Voss",
        "timestamp": 1749932977
    },
    {
        "content": "<p>No it doesn't</p>",
        "id": 524086893,
        "sender_full_name": "Henrik B√∂ving",
        "timestamp": 1749933720
    },
    {
        "content": "<p>For that array issue, I think Shreyas is referring to <a href=\"#narrow/channel/348111-batteries/topic/Large.20vector.20hangs/near/473234634\">this thread</a>, and as far as I understand it is not related to FBIP.</p>",
        "id": 524087191,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1749934267
    },
    {
        "content": "<p>Is this something you would recommend be mentioned in this document? My opinion is that if it is counterintuitive behavior that is unlikely to be changed any time soon, it belongs in the pitfalls document, but if it is a bug that will most likely be fixed at some point in the near future it should not be added.</p>",
        "id": 524087309,
        "sender_full_name": "Niels Voss",
        "timestamp": 1749934445
    },
    {
        "content": "<p>bv_decide definitely extends the TCB, albeit for good reasons, and users should be aware of this. </p>\n<p>About that error in vectors. That‚Äôs the one Kyle mentioned, and now I recall that it had something to do with macro expansion and has probably been fixed, or it not, will get fixed eventually.</p>",
        "id": 524090247,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1749939079
    },
    {
        "content": "<p>That's true, but it's much less extreme than <code>native_decide</code>, because <code>native_decide</code> also extends your circle of trust to include an arbitrary set of user-defined extensions that are like axioms but are not tracked.</p>",
        "id": 524090287,
        "sender_full_name": "Niels Voss",
        "timestamp": 1749939164
    },
    {
        "content": "<p>Changelog:</p>\n<ul>\n<li>Added section describing the counterintuitive double iInf and iSup behavior</li>\n<li>Added section on trying to extract data from propositions, and why this isn't possible / what alternatives there are</li>\n</ul>",
        "id": 524092161,
        "sender_full_name": "Niels Voss",
        "timestamp": 1749942055
    },
    {
        "content": "<blockquote>\n<p>but you cannot¬†<code>match</code>¬†on terms of type¬†<code>Prop</code></p>\n</blockquote>\n<p>Maybe you want to give a workaround how to \"match\" on terms of type¬†<code>Prop</code>: if <code>p : Prop</code>, then the correct spelling of \"match p\" should be <code>by_cases hp : p</code></p>",
        "id": 524143328,
        "sender_full_name": "Jz Pan",
        "timestamp": 1750006064
    },
    {
        "content": "<p>Perhaps this is well trodden territory, but one common pitfall for beginners arises when trying to apply a rewrite to an expression which is only definitionally equal (or even merely propositionally equal) to the expression one is trying to match with.  For instance, applying a rewrite that uses a hypothesis <code>a &lt; b</code> to an expression that instead involves <code>b &gt; a</code>.  This particular obstacle arises frequently because most Mathlib lemmas are only expressed using the former (which is in simp normal form etc.) rather than the latter. In this particular case of course one just needs to rewrite using <code>gt_iff_lt</code> first, but I've seen this be a significant speedbump for beginners.</p>",
        "id": 524306306,
        "sender_full_name": "Terence Tao",
        "timestamp": 1750095933
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/channel/113488-general/topic/Documenting.20lean.20pitfalls.3A.20feedback.20requested/near/524306306\">said</a>:</p>\n<blockquote>\n<p>Perhaps this is well trodden territory, but one common pitfall for beginners arises when trying to apply a rewrite to an expression which is only definitionally equal (or even merely propositionally equal) to the expression one is trying to match with.  For instance, applying a rewrite that uses a hypothesis <code>a &lt; b</code> to an expression that instead involves <code>b &gt; a</code>.  This particular obstacle arises frequently because most Mathlib lemmas are only expressed using the former (which is in simp normal form etc.) rather than the latter. In this particular case of course one just needs to rewrite using <code>gt_iff_lt</code> first, but I've seen this be a significant speedbump for beginners.</p>\n</blockquote>\n<p>I decided to split this into two sections: one about how tactics don't always operate up to definitional equality, and another specifically about <code>a &lt; b</code> vs <code>b &gt; a</code>. Please let me know if this covers your suggestion sufficiently.</p>",
        "id": 524341804,
        "sender_full_name": "Niels Voss",
        "timestamp": 1750112388
    },
    {
        "content": "<p>Looks good to me!</p>",
        "id": 524346055,
        "sender_full_name": "Terence Tao",
        "timestamp": 1750115392
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/channel/113488-general/topic/Documenting.20lean.20pitfalls.3A.20feedback.20requested/near/520696388\">said</a>:</p>\n<blockquote>\n<p>This list seems very useful, and we should definitely link it from the learning resources page! I'd also be in favor of making this an official subpage of <a href=\"https://leanprover-community.github.io/\">https://leanprover-community.github.io/</a></p>\n</blockquote>\n<p>How would I go about making this an official subpage? Should I submit a PR to <a href=\"https://github.com/leanprover-community/leanprover-community.github.io/\">https://github.com/leanprover-community/leanprover-community.github.io/</a> ?</p>",
        "id": 524359601,
        "sender_full_name": "Niels Voss",
        "timestamp": 1750126074
    },
    {
        "content": "<p>One addendum to the natural number subtraction section: One often has to work with the positive natural numbers, and prove statements such as <code>‚àÄ n ‚â• 1, P n</code> where one naturally tends to encounter <code>n-1</code> at some point (particularly if doing some sort of induction argument), thus apparently forcing one to use the dreaded natural number subtraction.  But one can often sidestep this by replacing <code>‚àÄ n ‚â• 1, P n</code> from the start with <code>‚àÄ n, P (n+1)</code>, so that any previous appearance of <code>n-1</code> is now <code>n</code>, and no natural number subtraction is required.  (This also makes <code>positivity</code> and related tools such as <code>gcongr</code> work better, and also slightly reduces the \"double <code>iInf</code>/<code>iSup</code>\" issue that you also refer to.)</p>",
        "id": 524360887,
        "sender_full_name": "Terence Tao",
        "timestamp": 1750127092
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"521331\">Niels Voss</span> <a href=\"#narrow/channel/113488-general/topic/Documenting.20lean.20pitfalls.3A.20feedback.20requested/near/524359601\">said</a>:</p>\n<blockquote>\n<p>How would I go about making this an official subpage? Should I submit a PR to <a href=\"https://github.com/leanprover-community/leanprover-community.github.io/\">https://github.com/leanprover-community/leanprover-community.github.io/</a> ?</p>\n</blockquote>\n<p>Yes, please! Feel free to ping / DM me if you have any trouble.</p>",
        "id": 524362917,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1750128964
    },
    {
        "content": "<p>I am going to finish implementing the last few suggestions, then I'll submit a PR :)</p>",
        "id": 524363443,
        "sender_full_name": "Niels Voss",
        "timestamp": 1750129484
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"366779\">Jz Pan</span> <a href=\"#narrow/channel/113488-general/topic/Documenting.20lean.20pitfalls.3A.20feedback.20requested/near/524143328\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>but you cannot¬†<code>match</code>¬†on terms of type¬†<code>Prop</code></p>\n</blockquote>\n<p>Maybe you want to give a workaround how to \"match\" on terms of type¬†<code>Prop</code>: if <code>p : Prop</code>, then the correct spelling of \"match p\" should be <code>by_cases hp : p</code></p>\n</blockquote>\n<p>Done, and I also mentioned the dependent if-then-else statement as well.</p>",
        "id": 524370523,
        "sender_full_name": "Niels Voss",
        "timestamp": 1750135237
    },
    {
        "content": "<p>Changelog:</p>\n<ul>\n<li>Implemented Terence Tao's suggestion on avoiding natural subtraction</li>\n<li>Add section on why you should avoid working with equality of types</li>\n</ul>",
        "id": 524376387,
        "sender_full_name": "Niels Voss",
        "timestamp": 1750139590
    },
    {
        "content": "<p>Changelog:</p>\n<ul>\n<li>Add section about rewriting under binders, which mentions <code>simp_rw</code> and <code>conv</code></li>\n</ul>",
        "id": 524380266,
        "sender_full_name": "Niels Voss",
        "timestamp": 1750141885
    },
    {
        "content": "<p>I really enjoy the read! one nitpick: in the partial function / sSup part, it should mention sSup is 0 also for empty set. And I think the sqrt =sSup example there is  actually demonstrating this</p>",
        "id": 524442291,
        "sender_full_name": "Weiyi Wang",
        "timestamp": 1750163603
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"873350\">Weiyi Wang</span> <a href=\"#narrow/channel/113488-general/topic/Documenting.20lean.20pitfalls.3A.20feedback.20requested/near/524442291\">said</a>:</p>\n<blockquote>\n<p>I really enjoy the read! one nitpick: in the partial function / sSup part, it should mention sSup is 0 also for empty set. And I think the sqrt =sSup example there is  actually demonstrating this</p>\n</blockquote>\n<p>Done, thanks for the suggestion!</p>",
        "id": 524820326,
        "sender_full_name": "Niels Voss",
        "timestamp": 1750313383
    },
    {
        "content": "<p>Another pitfall: treating a symbol introduced by <code>let</code> or <code>set</code> as if it were a genuine variable, for instance starting with <code>set n := expr</code> and then attempting <code>induction n</code> or something similar.  In such cases, <code>generalize h:expr = n</code> works as a substitute for <code>set n := expr</code>that gives the symbol <code>n</code> the status of a true variable, allowing for tactics such as <code>induction</code> or <code>revert</code> to work.</p>",
        "id": 525095276,
        "sender_full_name": "Terence Tao",
        "timestamp": 1750448481
    },
    {
        "content": "<p>I think you should be able to do <code>induction h : n</code> now, which does the generalization step for you.</p>",
        "id": 525095965,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750448885
    },
    {
        "content": "<p>The document is now available on the community website here: <a href=\"https://leanprover-community.github.io/extras/pitfalls.html\">https://leanprover-community.github.io/extras/pitfalls.html</a>. Thank you to everyone for all your feedback and suggestions, and thank you to <span class=\"user-mention\" data-user-id=\"123965\">@Bryan Gin-ge Chen</span> for helping me get this contributed to the website. I'm still open to suggestions for improvements to the document, which can be mentioned in this thread.</p>",
        "id": 525119069,
        "sender_full_name": "Niels Voss",
        "timestamp": 1750468561
    },
    {
        "content": "<blockquote>\n<p>\"and¬†<code>rw</code>¬†is unable to look into the¬†<code>fun</code>¬†expression.\"</p>\n</blockquote>\n<p>This is a common misconception: the failure is that <code>rw</code> can't rewrite subexpressions that contain bound variables. It's able to rewrite under <code>fun</code>/<code>forall</code>/<code>let</code> except for that.</p>\n<p>E.g. if you had <code>fun x =&gt; n + 0 + x</code> with <code>n</code> in the local context, you could do <code>rw [Nat.add_zero]</code>.</p>",
        "id": 525119643,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750469453
    },
    {
        "content": "<p>Speaking of rw, another thing that I'd like to see more explanation on is the \"motive is not type correct\" error, which can probably be considered a pitfall. For example</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"bp\">‚ü©</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">7</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h3</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"bp\">‚ü©</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">7</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"c1\">-- rw [‚Üê h3]  -- doesn't work</span>\n<span class=\"w\">  </span><span class=\"n\">simp_rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">h3</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h2</span>\n</code></pre></div>\n<p>I myself hasn't fully understood this yet. All I know is this often occurs with dependent types, and simp_rw / conv mode can usually resolve it (but simp_rw also sent me into infinite recursion in some occasion)<br>\n(Please find a better example than this weird one)</p>",
        "id": 525121783,
        "sender_full_name": "Weiyi Wang",
        "timestamp": 1750473094
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"873350\">@Weiyi Wang</span> It might be helpful searching for \"motive not type correct\" on this Zulip, since there are a number of explanations. The tactic also tries to explain the issue in its error message.</p>",
        "id": 525121859,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750473256
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/113488-general/topic/Documenting.20lean.20pitfalls.3A.20feedback.20requested/near/525119643\">said</a>:</p>\n<blockquote>\n<p>This is a common misconception: the failure is that <code>rw</code> can't rewrite subexpressions that contain bound variables. It's able to rewrite under <code>fun</code>/<code>forall</code>/<code>let</code> except for that.</p>\n<p>E.g. if you had <code>fun x =&gt; n + 0 + x</code> with <code>n</code> in the local context, you could do <code>rw [Nat.add_zero]</code>.</p>\n</blockquote>\n<p>I updated the document to fix this.</p>",
        "id": 527522004,
        "sender_full_name": "Niels Voss",
        "timestamp": 1751907908
    },
    {
        "content": "<p>One might isolate within the \"Using have for data\" pitfall the special case \"Using have for instances\" which tripped me up recently.  I had a finite type <code>(E:Type) [Finite E]</code> and I needed the <code>Fintype E</code> instance so I carelessly wrote <code>have hEfintype : Fintype E := Fintype.ofFinite _</code> and then ran into instance diamonds later on because Lean could not work out that <code>hEfintype</code> was equal to <code>Fintype.ofFinite _</code>.  Of course replacing <code>have</code> with <code>let</code> solved the problem.  This is the identical problem to the existing \"Using have for data\" section in the pitfalls document, but I think the instance subcase is frequent enough that it is worth noting.</p>\n<p>[EDIT: perhaps it is also worth clarifying that only some instances carry data, and for propositional instances this issue does not arise.]</p>",
        "id": 528109443,
        "sender_full_name": "Terence Tao",
        "timestamp": 1752161485
    },
    {
        "content": "<blockquote>\n<p>which tripped me up recently...</p>\n</blockquote>\n<p>This also hit me recently, not because I actually needed to refer to the instance in my proof, but because I had simply added the line by way of debugging to make sure that the <code>Fintype</code> instance was derivable as I expected. My not-so-minimal mwe is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">noncomputable</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">proj_subspace</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">EuclideanSpace</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\"> </span><span class=\"n\">LinearMap</span><span class=\"bp\">.</span><span class=\"n\">ker</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">LinearMap</span><span class=\"bp\">.</span><span class=\"n\">proj</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span>\n\n<span class=\"kn\">noncomputable</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">proj_subspace_has_dim_one_less</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">EuclideanSpace</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">‚â†</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">‚âÉ‚Çó·µ¢</span><span class=\"o\">[</span><span class=\"n\">‚Ñù</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">‚Ü•</span><span class=\"o\">(</span><span class=\"n\">proj_subspace</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">basis</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Pi</span><span class=\"bp\">.</span><span class=\"n\">basisFun</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">‚â†</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">}</span>\n\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">J</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">‚â†</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"c1\">---- UNCOMMENT the following line and break the partial proof</span>\n<span class=\"w\">  </span><span class=\"c1\">-- have fintypeJ : Fintype J := inferInstance</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">setmap</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">J</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">proj_subspace</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">inj</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">EuclideanSpace</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">‚â†</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">‚âÉ‚Çó</span><span class=\"o\">[</span><span class=\"n\">‚Ñù</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">proj_subspace</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">pres_norm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">EuclideanSpace</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">‚â†</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">}),</span><span class=\"w\"> </span><span class=\"bp\">‚Äñ</span><span class=\"n\">inj</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">‚Äñ</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">‚Äñ</span><span class=\"n\">x</span><span class=\"bp\">‚Äñ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">LinearIsometryEquiv</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"n\">pres_norm</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">z</span>\n</code></pre></div>",
        "id": 528118826,
        "sender_full_name": "Jason Reed",
        "timestamp": 1752164439
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/channel/113488-general/topic/Documenting.20lean.20pitfalls.3A.20feedback.20requested/near/528109443\">said</a>:</p>\n<blockquote>\n<p>I carelessly wrote <code>have hEfintype : Fintype E := Fintype.ofFinite _</code> and then ran into instance diamonds later on because Lean could not work out that <code>hEfintype</code> was equal to <code>Fintype.ofFinite _</code>. Of course replacing <code>have</code> with <code>let</code> solved the problem.</p>\n</blockquote>\n<p>I don't understand how this situation could have caused any issue. Either <code>hEfintype</code> is defeq to <code>Fintype.ofFinite _</code>, or it is not, but what you're describing is a mix of both, and no lemma in mathlib should mention <code>Fintype.ofFinite _</code> explicitly.</p>",
        "id": 528122756,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1752165741
    },
    {
        "content": "<p>Do you have a repro we could look at? Probably there is so lemma somewhere in mathlib that was stated wrongly</p>",
        "id": 528122818,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1752165768
    },
    {
        "content": "<p>I don't know if it is the same issue, but not long ago I wrote an adhoc <code>have : One M :=...</code>. Then when I want to use the 1 from it, it didn't work because <code>have</code> forgets what 1 is. Changing it to let resolved the issue</p>",
        "id": 528123221,
        "sender_full_name": "Weiyi Wang",
        "timestamp": 1752165931
    },
    {
        "content": "<p>Did you want to use the <em>definition</em> of <code>1 : M</code>, or just that it was defined?</p>",
        "id": 528123657,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1752166121
    },
    {
        "content": "<p>I wanted use the definition and indeed that was the problem</p>",
        "id": 528123711,
        "sender_full_name": "Weiyi Wang",
        "timestamp": 1752166146
    },
    {
        "content": "<p>Okay, so indeed that is expected. What Terry is describing above is rather a case where one shouldn't need to use the definition, but one somehow still gets issues (?!)</p>",
        "id": 528124687,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1752166476
    },
    {
        "content": "<p>OK, I see now that the problem was self-inflicted.  I was writing code for involving <code>Finset.sum</code> in which the ambient space had a <code>Finite</code> instance but not a <code>Fintype</code> instance, so that <code>Finset.univ</code> was not defined.  I dealt with this by manually inserting the <code>Fintype</code> instance into the <code>Finset.univ</code> call, and then later on when I wanted to use this expression I introduced the <code>Fintype</code> instance again, but mistakenly used <code>have</code> instead of <code>let</code> causing an instance diamond.  Here is the MWE (which looks silly now that I see it, but in my original code the manual insertion of <code>Fintype</code> and the second introduction of <code>Fintype</code> were in very different locations and I didn't see the issue.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">e</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">he</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">Bijective</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"bp\">‚àë</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">‚àë</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">ofFinite</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">hYfintype</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">ofFinite</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\">  </span><span class=\"c1\">-- fails if `let` becomes `have`</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">he</span><span class=\"bp\">.</span><span class=\"n\">sum_comp</span><span class=\"w\"> </span><span class=\"n\">f</span>\n</code></pre></div>",
        "id": 528127845,
        "sender_full_name": "Terence Tao",
        "timestamp": 1752167694
    },
    {
        "content": "<p>Glad it's sorted out!</p>",
        "id": 528128044,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1752167776
    },
    {
        "content": "<p>Preferring to avoid defeq abuse seems to be a recurring theme in discussions, but I don't know if it's documented nicely in one place. Is the \"Pitfalls\" section a good place for an example of what can go wrong? I don't think I'm an expert enough to suggest a good one. I only remember encountering some issues in the context of Fin n ‚Üí ‚Ñù vs. EuclideanSpace ‚Ñù n.</p>",
        "id": 533591852,
        "sender_full_name": "Jason Reed",
        "timestamp": 1754760795
    },
    {
        "content": "<p>(or is <a href=\"https://leanprover-community.github.io/extras/pitfalls.html#working-with-equality-of-types\">https://leanprover-community.github.io/extras/pitfalls.html#working-with-equality-of-types</a> already capturing everything worth saying at a beginner level? I got the impression that the phrase \"defeq abuse\" meant more than the issues discussed there, somehow)</p>",
        "id": 533591905,
        "sender_full_name": "Jason Reed",
        "timestamp": 1754760898
    },
    {
        "content": "<p>That section is about propositional equality of types, which is much worse behaved than definitional equality of types. I think defeq abuse is more about when you have an <code>x : A</code> and <code>A</code> is definitionally equal to <code>B</code>, so you use <code>x : B</code> instead of <code>x.toB</code>, but later find out that <code>A</code> and <code>B</code> are not actually interchangeable (for example, maybe they have different typeclasses)</p>",
        "id": 533607579,
        "sender_full_name": "Niels Voss",
        "timestamp": 1754781868
    },
    {
        "content": "<p>That said, I think defeq abuse shows up in other contexts than just that. I think over-reliance upon unfolding rather than developing proper APIs could be seen as a type of defeq abuse</p>",
        "id": 533607673,
        "sender_full_name": "Niels Voss",
        "timestamp": 1754782002
    },
    {
        "content": "<p>I think your penultimate message represents the vast majority of the defeq abuse that actually matters</p>",
        "id": 533608902,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1754783692
    },
    {
        "content": "<p>Yes, applying <code>hf : Injective f</code> (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Function.Injective#doc\">docs#Function.Injective</a>) is <em>not</em> defeq abuse in my book, even though Kevin has called it that in the past</p>",
        "id": 533620541,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1754800316
    },
    {
        "content": "<p>If you use it enough it becomes not defeq abuse</p>",
        "id": 533646154,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754826249
    }
]