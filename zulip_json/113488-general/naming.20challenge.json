[
    {
        "content": "<p>How should I (re)name this concept?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/--</span>\n<span class=\"sd\">An element `a : α` is `regular` (name subject to change) if `x ↦ a + x` is order-reflecting.</span>\n<span class=\"sd\">We will make a separate version of lemmas that require `[contravariant_class α α (+) (≤)]` with</span>\n<span class=\"sd\">`regular` assumptions instead. These can then be easily instantiated to specific types, like</span>\n<span class=\"sd\">`ennreal`, where we can replace the assumption `regular x` by `x ≠ ∞`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">def</span> <span class=\"n\">regular</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_le</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"o\">⦃</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">⦄,</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span>\n</code></pre></div>",
        "id": 247862123,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1627829031
    },
    {
        "content": "<p>How about <code>cancellable</code>? Or <code>add_le_cancellable</code> (if the relation is <code>≤</code> and operation is <code>+</code>)? Or <code>rel_cancellable</code> (if the same name is to be used for many relations)?</p>\n<p>I am not very familiar yet with the naming conventions, but I thought having various suggestions to consider can hardly hurt <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span>.</p>",
        "id": 247864120,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1627832259
    },
    {
        "content": "<p>The term \"regular\" would of course be following a time-honored tradition in math naming conventions for just about anything... By which I mean: I hope mathlib will <em>not</em> adopt it in this case! <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 247864409,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1627832716
    },
    {
        "content": "<p>I think I'll go for <code>add_le_cancellable</code>. Thanks for the suggestions.</p>",
        "id": 247883438,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1627862411
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> pointed out in <a href=\"https://github.com/leanprover-community/mathlib/issues/8503\">#8503</a> that lean actually already has a notion of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_left_regular\">docs#is_left_regular</a> (added by <span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span>). Interestingly, that definition doesn't have<code>@[to_additive]</code>. We could try to make these definitions more closely connected, for example by calling the both <code>is_[left|right]_[mul|add]_[le_]_cancellable</code> or both <code>is_[left|right]_[mul|add]_[le_]_regular</code></p>",
        "id": 247937646,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1627920928
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 248179498,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1627962550
    },
    {
        "content": "<p>I like the idea of connecting the two notions: it is a common trick to prove injectivity by showing strict monotonicity!</p>\n<p>As for the name, I chose <code>regular</code> because I was thinking of using this for regular elements and regular sequences in commutative algebra.  For this same reason, it had not occurred to me to do the same for additive.  Also, at the time of the PR I was less \"Lean-mature\" and was not aware of the <code>to_additive</code> attribute.</p>\n<p>In fact, following up on a comment by Eric, it seems to make sense to define <code>co(ntra)variant</code> as <code>∀ (m), analogue_of_mul_le_cancellable_with_explicit_m_input</code>.</p>",
        "id": 248179603,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1627962712
    },
    {
        "content": "<p>Anyone have a nice idea how to give these two definitions distinct, but not too long, names in <a href=\"https://github.com/leanprover-community/mathlib/issues/8514\">#8514</a>? </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Given `P 0`, `P 1`, and `P (p ^ k)` for positive prime powers, and a way to extend `P a` and</span>\n<span class=\"sd\">`P b` to `P (a * b)` when `a, b` are coprime, you can define `P` for all natural numbers. -/</span>\n<span class=\"kd\">@[elab_as_eliminator]</span>\n<span class=\"kd\">def</span> <span class=\"n\">rec_on_coprime'</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">p</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">prime</span> <span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">^</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">h0</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">coprime</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"n\">rec_on_prime_pow</span> <span class=\"n\">h0</span> <span class=\"n\">h1</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">p</span> <span class=\"n\">n</span> <span class=\"n\">hp'</span> <span class=\"n\">hpa</span> <span class=\"n\">ha</span><span class=\"o\">,</span>\n  <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">^</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"o\">((</span><span class=\"n\">prime.coprime_pow_of_not_dvd</span> <span class=\"n\">hp'</span> <span class=\"n\">hpa</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"n\">eq.rec</span> <span class=\"n\">h1</span> <span class=\"n\">h.symm</span> <span class=\"k\">else</span> <span class=\"n\">hp</span> <span class=\"n\">p</span> <span class=\"n\">n</span> <span class=\"n\">hp'</span> <span class=\"bp\">$</span> <span class=\"n\">nat.pos_of_ne_zero</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"n\">ha</span>\n\n<span class=\"sd\">/-- Given `P 0`, `P (p ^ k)` for all prime powers, and a way to extend `P a` and `P b` to</span>\n<span class=\"sd\">`P (a * b)` when `a, b` are coprime, you can define `P` for all natural numbers. -/</span>\n<span class=\"kd\">@[elab_as_eliminator]</span>\n<span class=\"kd\">def</span> <span class=\"n\">rec_on_coprime</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h0</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">p</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">prime</span> <span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">^</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">coprime</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"n\">rec_on_coprime'</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">p</span> <span class=\"n\">n</span> <span class=\"n\">h</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">hp</span> <span class=\"n\">p</span> <span class=\"n\">n</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"n\">h0</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"mi\">2</span> <span class=\"mi\">0</span> <span class=\"n\">prime_two</span><span class=\"o\">)</span> <span class=\"n\">h</span>\n</code></pre></div>",
        "id": 249584866,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1629118736
    },
    {
        "content": "<p>Swapping the order of the arguments in the first one so that <code>hp</code> comes after <code>h1</code> would make it easier to tell what the difference is!</p>",
        "id": 249591383,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1629122081
    },
    {
        "content": "<p><code>rec_on_prime_coprime</code> and <code>rec_on_pos_prime_coprime</code>?</p>",
        "id": 249591407,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1629122101
    },
    {
        "content": "<p>Anyone have any ideas to name the following linear maps?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">name_me1</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"bp\">𝕜</span><span class=\"o\">]</span> <span class=\"n\">E'</span> <span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"bp\">𝕜</span><span class=\"o\">]</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"bp\">𝕜</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">E''</span> <span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"bp\">𝕜</span><span class=\"o\">]</span> <span class=\"n\">E'</span><span class=\"o\">)</span> <span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"bp\">𝕜</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">E''</span> <span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"bp\">𝕜</span><span class=\"o\">]</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">continuous_linear_map.compL</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E''</span> <span class=\"n\">E'</span> <span class=\"n\">F</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"n\">L</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">name_me2</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"bp\">𝕜</span><span class=\"o\">]</span> <span class=\"n\">E'</span> <span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"bp\">𝕜</span><span class=\"o\">]</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">E''</span> <span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"bp\">𝕜</span><span class=\"o\">]</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"bp\">𝕜</span><span class=\"o\">]</span> <span class=\"n\">E'</span> <span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"bp\">𝕜</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">E''</span> <span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"bp\">𝕜</span><span class=\"o\">]</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">name_me1</span> <span class=\"n\">E''</span> <span class=\"o\">(</span><span class=\"n\">flip</span> <span class=\"n\">L</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">flip</span>\n</code></pre></div>",
        "id": 273630949,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1646136920
    },
    {
        "content": "<p>Can you include the <code>simps</code> lemma they generate too?</p>",
        "id": 273633684,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646138390
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">ᾰ</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">⇑</span><span class=\"o\">(</span><span class=\"n\">name_me1</span> <span class=\"n\">E''</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"n\">ᾰ</span> <span class=\"bp\">=</span> <span class=\"bp\">⇑</span><span class=\"o\">(</span><span class=\"n\">compL</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E''</span> <span class=\"n\">E'</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">⇑</span><span class=\"n\">L</span> <span class=\"n\">ᾰ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">ᾰ</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">E''</span> <span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"bp\">𝕜</span><span class=\"o\">]</span> <span class=\"n\">E'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">⇑</span><span class=\"o\">(</span><span class=\"bp\">⇑</span><span class=\"o\">(</span><span class=\"n\">name_me1</span> <span class=\"n\">E''</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"n\">ᾰ</span><span class=\"o\">)</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">⇑</span><span class=\"n\">L</span> <span class=\"n\">ᾰ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"n\">f</span>\n<span class=\"o\">(</span><span class=\"n\">ᾰ</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">E''</span> <span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"bp\">𝕜</span><span class=\"o\">]</span> <span class=\"n\">E'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ᾰ_1</span> <span class=\"o\">:</span> <span class=\"n\">E''</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">⇑</span><span class=\"o\">(</span><span class=\"bp\">⇑</span><span class=\"o\">(</span><span class=\"bp\">⇑</span><span class=\"o\">(</span><span class=\"n\">name_me1</span> <span class=\"n\">E''</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"n\">ᾰ</span><span class=\"o\">)</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">ᾰ_1</span> <span class=\"bp\">=</span> <span class=\"bp\">⇑</span><span class=\"o\">(</span><span class=\"bp\">⇑</span><span class=\"n\">L</span> <span class=\"n\">ᾰ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">⇑</span><span class=\"n\">f</span> <span class=\"n\">ᾰ_1</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 273635676,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1646139411
    },
    {
        "content": "<p>I'm thinking of something like <code>precompose_right</code> / <code>precompose_left</code>, since we're precomposing the function <code>E'' →L[𝕜] E'</code> on the right/left argument.</p>",
        "id": 273636613,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1646139827
    },
    {
        "content": "<p>Maybe <code>compL₂</code> for the first one to be consistent with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/linear_map\">docs#linear_map</a>.compl₂ ? your second map should correspond to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/linear_map\">docs#linear_map</a>.compr₂</p>\n<p>edit: it's not quite the same thing and I did not immediately find the corresponding definition in <code>bilinear_map</code>.</p>",
        "id": 273637914,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1646140505
    },
    {
        "content": "<p>Those are indeed very close, my maps have the second linear map bundled. <br>\n<code>flip (name_me1 L) f</code> is basically the same as <code>linear_map.compl₂ L f</code> (up to continuity and semilinearity).</p>",
        "id": 273646267,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1646143917
    },
    {
        "content": "<p>I think it would be a good idea if the API of bilinear maps and continuous bilinear maps would be as close as possible, but I also think that the bundled definitions are better then <code>linear_map.compl₂ L f</code> (btw please change your linear map from L to B, it is really confusing with the L from the clm notation).</p>",
        "id": 273649276,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1646145145
    },
    {
        "content": "<p>but there is already diverging notation with <code>continuous_linear_map.compL</code> and <code>linear_map.lcomp</code>.</p>",
        "id": 273649355,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1646145192
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 273649429,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1646145228
    },
    {
        "content": "<p>Sometimes I wonder if we're shooting ourselves in the foot with this heavy point-free approach, and would do better to just write <code>\\lam a f x, L a (f x)</code> and use some <code>linearity</code> tactic to find the linearity proof automatically.</p>",
        "id": 273659071,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646149037
    },
    {
        "content": "<p>Indeed all this doesn't exist on paper, and we certainly want to keep it that way on paper.</p>",
        "id": 273708901,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1646168258
    },
    {
        "content": "<p>This sounds like some abstract nonsense that does exist in cartesian closed categories (possibly with some extra structure).</p>",
        "id": 273787581,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1646218344
    },
    {
        "content": "<p>/poll What statement would people expect for the name <code>equiv.subtype_congr</code>?<br>\n<code>{α} {p q : α → Prop} (e : {x // p x} ≃ {x // q x}) (f : {x // ¬p x} ≃ {x // ¬q x}) : perm α</code><br>\n<code>(e : α₁ ≃ α₂) (p : α₂ → Prop) : {a₁ // (p ∘ e) a₁} ≃ {a₂ // p a₂}</code></p>",
        "id": 282267098,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1652457299
    },
    {
        "content": "<p>answer: <a href=\"https://leanprover-community.github.io/mathlib_docs/find/equiv.subtype_congr\">docs#equiv.subtype_congr</a><br>\nbonus: what would you call the other? (I'm making the one of these that isn't in mathlib already and not sure what name to give it if not that)</p>",
        "id": 282267196,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1652457335
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/equiv.subtype_equiv\">docs#equiv.subtype_equiv</a> is one of the other ones</p>",
        "id": 282269632,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1652458308
    },
    {
        "content": "<p>I think the current <code>equiv.subtype_congr</code> should be called <code>equiv.subtype_piecewise</code>?</p>",
        "id": 282269883,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1652458414
    },
    {
        "content": "<p>I was rewriting option 3 as I didn't think of it, d'ah!</p>",
        "id": 282269934,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1652458437
    },
    {
        "content": "<p>Or maybe even just <code>equiv.piecewise</code></p>",
        "id": 282270068,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1652458496
    },
    {
        "content": "<p>oh, I think my proof is nicer so I'll PR that (no non-terminal simps :]) I currently don't have a good computer though, so I will refactor the names when I get to a good computer</p>",
        "id": 282270107,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1652458511
    },
    {
        "content": "<p>Option 1 looks like a <code>perm.subtype_piecewise</code> to me.  I would expect <code>equiv.subtype_piecewise</code> to be <code>{α β} {p : α → Prop} {q : β → Prop} (e : { a // p a } ≃ { b // q b }) (f : { a // ¬ p a } ≃ { b // ¬ q b }) : α ≃ β</code>.</p>",
        "id": 282270791,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1652458814
    },
    {
        "content": "<p>oh, and option 2 is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/equiv.subtype_equiv_of_subtype\">docs#equiv.subtype_equiv_of_subtype</a></p>",
        "id": 282271227,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1652459012
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/14125\">#14125</a></p>",
        "id": 282271609,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1652459185
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284160\">Eric Rodriguez</span> <a href=\"#narrow/stream/113488-general/topic/naming.20challenge/near/282271227\">said</a>:</p>\n<blockquote>\n<p>oh, and option 2 is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/equiv.subtype_equiv_of_subtype\">docs#equiv.subtype_equiv_of_subtype</a></p>\n</blockquote>\n<p>what should this be called? I don't like this name but not sure what a better one would be</p>",
        "id": 283177882,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1653145334
    },
    {
        "content": "<p>I rarely see stuff in the <code>equiv.subty</code> namespace <span aria-label=\"stuck out tongue\" class=\"emoji emoji-1f61b\" role=\"img\" title=\"stuck out tongue\">:stuck_out_tongue:</span></p>",
        "id": 283179182,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1653147083
    }
]