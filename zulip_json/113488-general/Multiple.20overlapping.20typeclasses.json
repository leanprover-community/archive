[
    {
        "content": "<p>How should one deal with lemmas where the \"natural\" generality involves several typeclass assumptions which contain conflicting data?</p>\n<p>For instance, suppose I have a lemma which requires a type <code>X</code> with a norm, an additive group structure, and a distinguished element \"1\". The typeclass <code>[NormedAddGroup X]</code> gives a norm and add-group structure satisfying sensible compatibilities, while <code>[AddGroupWithOne X]</code> gives an add-group structure and a 1.</p>\n<p>However, if you use both at once,</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedAddGroup</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddGroupWithOne</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>you don't get the right thing: you get a type with two possibly <em>different</em> add-group structures, one of which one has the norm and the other has the 1.</p>\n<p>How do I force the NormedAddGroup structure and the AddGroupWithOne structure to have the same underlying AddGroup structure?</p>",
        "id": 473971453,
        "sender_full_name": "David Loeffler",
        "timestamp": 1727768085
    },
    {
        "content": "<p>You make a new <code>NormedAddCommGroupWithOne</code> typeclass extending <code>NormedAddCommGroup</code> and <code>AddCommGroupWithOne</code></p>",
        "id": 473972564,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1727768385
    },
    {
        "content": "<p>But doesn't <code>NormedRing</code> fit your purposes?</p>",
        "id": 473972628,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1727768399
    },
    {
        "content": "<p><code>NormedRing</code> has far more structure; it calls for the existence of multiplication on <code>X</code> (and for the norm to be submultiplicative), both of which are irrelevant in the case at hand. Probably it's true that there are no interesting examples of <code>NormedAddCommGroupWithOne</code>s that are not <code>NormedRing</code>s, but this was only intended as an example of a more general problem.</p>",
        "id": 473974868,
        "sender_full_name": "David Loeffler",
        "timestamp": 1727769053
    },
    {
        "content": "<blockquote>\n<p>You make a new <code>NormedAddCommGroupWithOne</code> typeclass extending <code>NormedAddCommGroup</code> and <code>AddCommGroupWithOne</code></p>\n</blockquote>\n<p>I'm wary of creating a special-purpose typeclass just for one or two lemmas...</p>",
        "id": 473975145,
        "sender_full_name": "David Loeffler",
        "timestamp": 1727769137
    },
    {
        "content": "<p><span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span> That's how typeclasses work. The other option is to have more mixins, eg make <code>NormedAddCommGroup α</code> take in an <code>[AddCommGroup α]</code> parameter, rather than implying it</p>",
        "id": 473976294,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1727769474
    },
    {
        "content": "<p>So how would this work in practice?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">NormedAddMonoidWithOne</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">NormedAddGroup</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">AddMonoidWithOne</span><span class=\"w\"> </span><span class=\"n\">R</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NormedAddCommMonoidWithOne</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">infer_instance</span><span class=\"w\"> </span><span class=\"c1\">-- fails</span>\n</code></pre></div>",
        "id": 473977497,
        "sender_full_name": "David Loeffler",
        "timestamp": 1727769791
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">NormedAddMonoidWithOne</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">NormedAddGroup</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">AddMonoidWithOne</span><span class=\"w\"> </span><span class=\"n\">R</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NormedAddCommMonoidWithOne</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">__</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">‹</span><span class=\"n\">NormedRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"bp\">›</span>\n</code></pre></div>\n<p>?</p>",
        "id": 473977716,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1727769847
    },
    {
        "content": "<p>Are you saying I would need to add an explicit instance of <code>NormedAddMonoidWithOne</code> for every single pre-existing typeclass that extends both <code>NormedAddGroup</code> and <code>AddMonoidWithOne</code>? Then adding the new typeclass doesn't really achieve much. Is there not some way of automating this?</p>",
        "id": 473978729,
        "sender_full_name": "David Loeffler",
        "timestamp": 1727770186
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"481963\">David Loeffler</span> <a href=\"#narrow/stream/113488-general/topic/Multiple.20overlapping.20typeclasses/near/473978729\">said</a>:</p>\n<blockquote>\n<p>Are you saying I would need to add an explicit instance of <code>NormedAddMonoidWithOne</code> for every single pre-existing typeclass that extends both <code>NormedAddGroup</code> and <code>AddMonoidWithOne</code>?</p>\n</blockquote>\n<p>No, only for the direct common children. Eg you don't need to add <code>NormedField α → NormedAddMonoidWithOne α</code> because typeclass search already knows <code>NormedField α → NormedRing α</code>.</p>",
        "id": 473979485,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1727770476
    },
    {
        "content": "<p>That should be very few typeclasses. In fact, I can't think of another one besides <code>NormedRing</code>!</p>",
        "id": 473979618,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1727770518
    },
    {
        "content": "<blockquote>\n<p>That should be very few typeclasses. In fact, I can't think of another one besides <code>NormedRing</code>!</p>\n</blockquote>\n<p>That's very probably true for this example, but I think the question makes sense more generally.</p>\n<p>&lt;rant&gt; To pick up on another point you made (about mixins): I found this one of the most opaque aspects of mathlib when I was first getting used to it: some typeclasses <em>must</em> be used together, while others <em>must not</em> be used together else you get craziness, and there seems to be absolutely no convention as to which; e.g. <code>[NormedSpace ℝ V]</code> requires a pre-existing <code>NormedAddCommGroup</code> structure, but you are in for a world of pain if you use it on a type that already has a <code>[Module ℝ V]</code> structure.&lt;/rant&gt;</p>",
        "id": 473982364,
        "sender_full_name": "David Loeffler",
        "timestamp": 1727771478
    },
    {
        "content": "<p>We all feel your pain, <span class=\"user-mention\" data-user-id=\"481963\">@David Loeffler</span>. This design question is a difficult one, and far from completely settled. The trend has generally been towards converting things to mixins, but obviously it's a lot of work.</p>",
        "id": 474008359,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1727780334
    },
    {
        "content": "<p>I tried to split <code>NormedGroup</code> from <code>AddCommGroup</code> long ago, but:</p>\n<ul>\n<li>As Kim says It's a lot of tedious work</li>\n<li>Inevitably proofs break for performance reasons; while unbundling might be faster in principle [citation needed], it won't be faster in the places that optimized the proof for the bundled spelling.</li>\n<li>it makes analysts sad because they now have to write<p><code>lean\n  variable [AddCommGroup V] [NormedAddCommGroup V] [Module K V] [NormedSpace K V]\n  </code></p>\n<p>instead of what we have now</p>\n<p><code>lean\n  variable [NormedAddCommGroup V] [NormedSpace K V]\n  </code></p>\n</li>\n</ul>",
        "id": 474011366,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727781277
    },
    {
        "content": "<p>I think we need a good way to handle your \"it makes analysts sad\". Because only then can we realistically try this out in practice.<br>\n<code>variable?</code> is a good start, but not enough, I think.</p>",
        "id": 474033686,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1727788135
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> do we have examples where <code>class abbrev</code> <em>really</em> hurts performance? I ask because, while I thought it might be truly detrimental, it didn't seem to be much/any worse when I tried it in <a href=\"https://github.com/leanprover-community/mathlib4/pull/16975\">#16975</a> compared to just adding the relevant instance.</p>\n<p>If it didn't significantly impact performance (which would still surprise me), the solution to \"it makes analysts sad\" would just be to <code>class abbrev</code> the important structures.</p>",
        "id": 474052935,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1727793181
    },
    {
        "content": "<p>Thanks for the comments folks! I am sure that a great deal of thought and energy has gone into trying to find a solution that keeps the pain to a minimum.</p>\n<p>I'd be interested in your thoughts on the following particular issue. Suppose you have a series of definitions / theorems all applying in some given setting, described by a list of section-level typeclass variables. (E.g. you have a ring R and an R-module M and a linear map from M to R, ...) Then for one such lemma you want to slightly strengthen the assumptions, maybe \"if we are in the above situation but R happens to be a <em>normed</em> ring, then...\". If the stronger assumption is implemented as an extension class, rather than a mixin, the only option seems to be to throw away the existing section variables and rebuild the whole edifice of assumptions from scratch. </p>\n<p>Is there any hope whatsoever of setting up some syntax to handle this situation? Something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">instead</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>and having it re-build the existing typeclass assumptions with the more specific typeclass?</p>",
        "id": 474071174,
        "sender_full_name": "David Loeffler",
        "timestamp": 1727798327
    },
    {
        "content": "<p>I think you can do that with <code>omit [Ring R] in variable [NormedRing R] in</code>, but you still have to rebuild everything on <code>M</code></p>",
        "id": 474074695,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727799399
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/Multiple.20overlapping.20typeclasses/near/474074695\">said</a>:</p>\n<blockquote>\n<p>I think you can do that with <code>omit [Ring R] in variable [NormedRing R] in</code>, but you still have to rebuild everything on <code>M</code></p>\n</blockquote>\n<p>I'm not sure that works. If I understand correctly, <code>omit</code> only reverses the effect of <code>include</code>, setting a variable back to \"include if relevant\" rather than \"include always\". But it doesn't explicitly forbid a typeclass variable from being included, so you can still end up in the dreaded situation of accidentally having two unrelated ring structures on the same type simultaneously.</p>",
        "id": 474090289,
        "sender_full_name": "David Loeffler",
        "timestamp": 1727803870
    },
    {
        "content": "<p>It took me a while to cook up an example, but here's one:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> lemmas lemmas lemmas... -/</span>\n\n<span class=\"n\">omit</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">in</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‖</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">‖</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"bp\">‖</span><span class=\"n\">a</span><span class=\"bp\">‖</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">‖</span><span class=\"n\">b</span><span class=\"bp\">‖</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"c\">/-</span><span class=\"cm\"> tactic state is now:</span>\n<span class=\"cm\">R : Type u_1</span>\n<span class=\"cm\">inst✝¹ : AddCommGroup R</span>\n<span class=\"cm\">inst✝ : NormedAddCommGroup R</span>\n<span class=\"cm\">a b : R -/</span>\n<span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">norm_add_le</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"c1\">-- fails, wrong \"+\"!</span>\n</code></pre></div>\n<p>Here the call to \"norm_add_le\" fails because Lean interprets the \"+\" in the theorem statement as the one from the AddCommGroup instance, while \"norm_add_le a b\" is a proof of the triangle ineq for the entirely unrelated \"+\" coming from the NormedAddCommGroup instance.</p>",
        "id": 474092165,
        "sender_full_name": "David Loeffler",
        "timestamp": 1727804472
    },
    {
        "content": "<p>I don't understand that example, where did <code>AddGroup</code> come from?</p>",
        "id": 474092566,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727804619
    },
    {
        "content": "<p>(assuming it's a typo, I think I agree with your diagnosis)</p>",
        "id": 474092704,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727804664
    },
    {
        "content": "<p>Sorry, that was a typo; I realised commutativity was irrelevant to my example but introduced an inconsistency in removing it. Edited.</p>",
        "id": 474095448,
        "sender_full_name": "David Loeffler",
        "timestamp": 1727805544
    },
    {
        "content": "<p>Hmmm, thanks for that MWE. <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> is this intended behaviour or a bug?</p>",
        "id": 474191769,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1727844804
    },
    {
        "content": "<p>Personally, I always thought <code>omit</code> meant \"forbid\".</p>",
        "id": 474191782,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1727844823
    },
    {
        "content": "<p>That sounds like a reasonable expectation, feel free to file an issue</p>",
        "id": 474227891,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1727856955
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/113488-general/topic/Multiple.20overlapping.20typeclasses/near/474227891\">said</a>:</p>\n<blockquote>\n<p>That sounds like a reasonable expectation, feel free to file an issue</p>\n</blockquote>\n<p>OK this is now <a href=\"https://github.com/leanprover/lean4/pull/5595\">lean#5595</a>.</p>",
        "id": 474239811,
        "sender_full_name": "David Loeffler",
        "timestamp": 1727859988
    },
    {
        "content": "<p>I like this, since it is going to automatically make <code>include</code> be \"very\" scoped, since there is no way to revert an <code>include</code> to \"possibly include\"!</p>",
        "id": 474240516,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1727860173
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span>  makes the fair point that this change would leave us with no way of precisely reverting the effect of an <code>include</code>. Some might find that desirable, but others might not. So maybe, rather than changing the behaviour of <code>omit</code>, we could retain the current behaviour of <code>omit</code> and have another keyword -- <code>omit!</code> or <code>forget</code> perhaps -- for entirely removing a variable from the context.</p>",
        "id": 474241819,
        "sender_full_name": "David Loeffler",
        "timestamp": 1727860484
    },
    {
        "content": "<p>Having both versions seems very reasonable.</p>",
        "id": 474242925,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1727860812
    },
    {
        "content": "<p>How about <code>end h</code> for moving <code>h</code> out of the scope?  I find that lots of different ways of managing variables cause more problems than they solve.</p>",
        "id": 474245102,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1727861500
    },
    {
        "content": "<p>So you can end a namespace or section, removing <em>all</em> variables in scope, or you can selectively remove a single (or list?) of variables with it as well.</p>",
        "id": 474245360,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1727861583
    },
    {
        "content": "<p>Wasn't omit supposed to be a temporary solution while we moved to sections?</p>",
        "id": 474255263,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1727864936
    },
    {
        "content": "<p>Well, I think that the original suggested change would accelerate the process...</p>",
        "id": 474256241,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1727865330
    },
    {
        "content": "<p>I <em>really</em> don't think we should have two versions of <code>omit</code>. It sounds like a recipe for pain and confusion. If <code>variable</code> issues are really getting to you, then it probably means you need more <code>section</code>s.</p>",
        "id": 474312106,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1727878907
    },
    {
        "content": "<blockquote>\n<p>If <code>variable</code>issues are really getting to you, then it probably means you need more <code>section</code>s.</p>\n</blockquote>\n<p>Using sections does not solve the general problem (although it probably does solve as much of it as the <code>omit!</code> command would, which is not a perfect solution either). The section-based idiom would be something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">section</span><span class=\"w\"> </span><span class=\"n\">Ring</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsArtinian</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NoZeroSMulDivisors</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">etc</span><span class=\"w\"> </span><span class=\"n\">etc</span><span class=\"w\"> </span><span class=\"n\">etc</span><span class=\"bp\">...</span><span class=\"o\">]</span>\n\n<span class=\"o\">[</span><span class=\"bp\">...</span><span class=\"o\">]</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">Ring</span>\n\n<span class=\"kn\">section</span><span class=\"w\"> </span><span class=\"n\">CommRing</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsArtinian</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NoZeroSMulDivisors</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">etc</span><span class=\"w\"> </span><span class=\"n\">etc</span><span class=\"w\"> </span><span class=\"n\">etc</span><span class=\"bp\">...</span><span class=\"o\">]</span>\n\n<span class=\"bp\">...</span>\n</code></pre></div>\n<p>and we have to re-declare the entire pile of instance variables at the start of the new section, because it's \"not the same R\" any more, even though CommRing extends Ring so the new situation is a special case of the old one.</p>",
        "id": 474315910,
        "sender_full_name": "David Loeffler",
        "timestamp": 1727879883
    },
    {
        "content": "<p>One argument against sections is that it's harder to review diffs, as lemmas which haven't actually changed can appear as deleted and recreated in the diff. If you can leave them in the same place, then this issue goes away</p>",
        "id": 474315918,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727879886
    },
    {
        "content": "<p>(but this could be solved with something like leaff)</p>",
        "id": 474315995,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727879909
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/Multiple.20overlapping.20typeclasses/near/474315918\">said</a>:</p>\n<blockquote>\n<p>One argument against sections is ...</p>\n</blockquote>\n<p>One argument in favor of sections is that lemmas with similar assumptions get grouped together, which I think is more important (and has more lasting impact), than the diff on GitHub. So, I don't buy your argument.</p>",
        "id": 474317014,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1727880218
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"481963\">David Loeffler</span> <a href=\"#narrow/stream/113488-general/topic/Multiple.20overlapping.20typeclasses/near/474315910\">said</a>:</p>\n<blockquote>\n<p>we have to re-declare the entire pile of instance variables at the start of the new section</p>\n</blockquote>\n<p>I agree, this can be annoying. Repeated cases of this may mean we want to refactor Mathlib (e.g., in this case <code>Comm</code> could become a mixin, although I don't actually think that's a good idea).</p>",
        "id": 474317483,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1727880345
    },
    {
        "content": "<p>What I'm hoping for here is precisely some sort of syntax that would allow us to treat an extension class like a mix-in, without actually refactoring it as such – e.g. temporarily \"upgrading\" a [Ring R] to a [CommRing R] or a [NormedRing R] or whatever, etc, while keeping the rest of the previously-declared instances in force.</p>",
        "id": 474319573,
        "sender_full_name": "David Loeffler",
        "timestamp": 1727880905
    },
    {
        "content": "<p>I have often wanted a model where the fields of a class are automatically classes themselves and you can lump them together or take them apart at will...</p>",
        "id": 474355590,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1727890015
    },
    {
        "content": "<p>I could imagine a future where minimal data-carrying classes are the only things that aren't mixins. So e.g. you start with things like a <code>Norm G</code>, <code>Preorder G</code>, <code>Topological Space G</code>, <code>Add G</code>, <code>Zero G</code>... then <code>NormedAddGroup G</code> takes mixin arguments for Add/Neg/Sub/Zero/Norm. Then if you _also_ had an <code>AddCommGroup</code> or <code>GroupWithOne</code> in the context, they would share all their data fields so there wouldn't be unification failures.</p>\n<p>Of course no one wants to start each file talking about rings with <code>variable [Add G] [Sub G] [Mul G] [Zero G] [One G] [SMul Nat G] [SMul Int G] [Pow G Nat]</code>, so we could have a few classes that just bundle together commonly coexisting data. Like I could picture a <code>GroupData G extends Mul G, One G, Inv G, Div G, Pow G Nat, Pow G Int</code>, and then <code>Group</code>/<code>CommGroup</code>/<code>Semiring</code>/<code>NormedGroup</code> would all take a <code>GroupData</code> mixin.</p>\n<p>But now you would only have to create an appropriate collection of <code>___Data</code> classes to cover all your bases, as opposed to one for each combination of properties too, which is definitely a huge shrinkage</p>",
        "id": 506761458,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1742398310
    },
    {
        "content": "<p>Does it make the exponential blow-up better or worse? If you have a complicated type (e.g., continuous linear maps taking values in the spaces of continuous multilinear maps, add 1 or 2 more layers), then sometimes lean falls to generate an instance (e.g., <code>Norm</code>), because the expression is too large.</p>",
        "id": 506767802,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1742399715
    },
    {
        "content": "<p>These types naturally appear when you try to define, e.g., composition of bundled (multi)linear maps add a bundled map.</p>",
        "id": 506768116,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1742399792
    },
    {
        "content": "<p>I admit I don't know anything about that. It feels like it would be easier to manage the problem here (when you have overlapping typeclasses, the need to essentially create a bespoke new class), easier in the sense of the codebase - but I have no idea what the impact on runtime would look like</p>",
        "id": 506768853,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1742399982
    }
]