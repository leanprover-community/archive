[
    {
        "content": "<p>Love this. Since you are writing about discrete mathematics, I was wondering if the book could guide users on how to move between Finsets and finite maps. When it is advisable to use <code>Fintype</code>, <code>FinEnum</code>, and just <code>Fin n</code> and  so on.</p>",
        "id": 455385554,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1722435532
    },
    {
        "content": "<p>(I think <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FinEnum#doc\">docs#FinEnum</a> is probably not currently that useful for anything, and could be redesigned from scratch)</p>",
        "id": 455385765,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1722435585
    },
    {
        "content": "<p>Well, I used it in finite graphs.</p>",
        "id": 455385805,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1722435599
    },
    {
        "content": "<p>It was easy to extract an ordering of neighbours from a Finset.</p>",
        "id": 455385925,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1722435613
    },
    {
        "content": "<p>See : <a href=\"https://github.com/Shreyas4991/DGAlgorithms/blob/cb167b1911aca1a4158e9d1069804306ebd98a7d/DGAlgorithms/Models/Fingraph.lean#L132\">https://github.com/Shreyas4991/DGAlgorithms/blob/cb167b1911aca1a4158e9d1069804306ebd98a7d/DGAlgorithms/Models/Fingraph.lean#L132</a></p>",
        "id": 455386080,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1722435658
    },
    {
        "content": "<p><code>Fintype</code> only gives you a <code>Finset</code>. Not great when you want to write a computation iterating over it, which can be the case for a lot of proofs in discrete math.</p>",
        "id": 455386533,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1722435755
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/113488-general/topic/Finset.20vs.20Finite/near/455386533\">said</a>:</p>\n<blockquote>\n<p><code>Fintype</code> only gives you a <code>Finset</code>. Not great when you want to write a computation iterating over it, which can be the case for a lot of proofs in discrete math.</p>\n</blockquote>\n<p>With regards to discrete maths, it is absolutely true that FinEnum is pretty useless, a Finset is indeed plenty when you want to have a proof with iteration. The difference happens only when you want to work with a finset together with a specific ordering, which is a rare (non-existent?) situation in discrete mathematics.</p>",
        "id": 455389140,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1722436438
    },
    {
        "content": "<p>Well. Here is an easy example: round robin algorithm for finding EF 1 allocations of indivisible goods</p>",
        "id": 455391240,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1722437000
    },
    {
        "content": "<p>You start by allocating goods  ( to say two agents) in some order determined by their valuation functions</p>",
        "id": 455391340,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1722437034
    },
    {
        "content": "<p>This is used to prove the existence of EF1 allocations</p>",
        "id": 455391568,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1722437083
    },
    {
        "content": "<p>I think this discussion is not on topic any more, but - just going off the wikipedia description - the way this is typically done in mathlib is picking an ordering of the elements (wikipedia's step 1: \"Number the people arbitrarily from 1 to n\") by taking a list representative of the given finset, and running step 2 with a list fold. This immediately gives you the existence of EF1 allocations that you ask for.</p>",
        "id": 455392221,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1722437249
    },
    {
        "content": "<p>How is the ordering of the elements chosen? FinEnum gives one directly.</p>",
        "id": 455392542,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1722437332
    },
    {
        "content": "<p>Anyway, this is the kind of confusion that beginners like me tend to have</p>",
        "id": 455392726,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1722437392
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/113488-general/topic/Finset.20vs.20Finite/near/455392726\">said</a>:</p>\n<blockquote>\n<p>Anyway, this is the kind of confusion that beginners like me tend to have</p>\n</blockquote>\n<p>Right, I think this is a great example of why mentioning FinEnum increases the confusion! Let's continue the EF1 discussion elsewhere</p>",
        "id": 455392896,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1722437429
    },
    {
        "content": "<p>Can some selection messages be moved to a different thread? EF1 is just one example. I am thinking of all the problems whose solutions are some dynamic programming style recurrence.</p>",
        "id": 455393918,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1722437736
    },
    {
        "content": "<p>Yes, somehow <a href=\"https://tqft.net/mathlib4files/Combinatorics/Enumerative/DoubleCounting\">file#Combinatorics/Enumerative/DoubleCounting</a> is a stupidly easy but very crucial file</p>",
        "id": 455401091,
        "sender_full_name": "YaÃ«l Dillies",
        "timestamp": 1722439058
    },
    {
        "content": "<p>Shreyas, this is probably a nice example but not relevant to MIL which is about mathematics.</p>",
        "id": 455455334,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1722450308
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"466334\">@Shreyas Srinivas</span> For verifying combinatorial computation, you want to choose efficient representations and use the mathematical objects as ideal references to state and prove correctness. I agree that <code>Finset</code> and <code>Fintype</code> are not good for computation! As Patrick says, that's out of scope for MIL, though it is a good topic for  lots of papers and tutorial.</p>",
        "id": 455480799,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1722458728
    },
    {
        "content": "<p>25 messages were moved here from <a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/stream/113488-general/topic/Finset.20vs.20Finite\">#general &gt; Finset vs Finite</a> by <span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span>.</p>",
        "id": 455502543,
        "sender_full_name": "Notification Bot",
        "timestamp": 1722467234
    },
    {
        "content": "<p>I have moved messages here, to try to increase the signal to noise ratio of the other thread.</p>\n<p>(Avoiding the need for this in the first place may have been helpful!)</p>",
        "id": 455503173,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1722467543
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span> : Apologies, I didn't want to side track that discussion. My primary goal was to bring up the kind of confusion that beginners face with finite types. Also, there is such a huge overlap between discrete mathematics and theoretical CS (especially complexity and algorithms theory) that I didnt quite see these topics as \"not math\". In fact the example I picked comes from social choice theory where mathematicians (Nash, Gale, Shapley, Steinhaus etc) have contributed a lot.</p>",
        "id": 455597589,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1722503855
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110865\">@Jeremy Avigad</span> : I am not trying to write efficient combinatorial procedures. Just prove things. Some proofs are just most elegantly described as recursive procedures upon which we do induction. I recall that this is also sometimes true in pure mathematics from Halmos' proof of the Steinitz lemma in his FDVS book. In such cases there is a \"choose some ordering of elements\" step, and my point is FinEnum does that for free.</p>",
        "id": 455598591,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1722504197
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/113488-general/topic/FinEnum/near/455386533\">said</a>:</p>\n<blockquote>\n<p><code>Fintype</code> only gives you a <code>Finset</code>. Not great when you want to write a computation iterating over it, which can be the case for a lot of proofs in discrete math.</p>\n</blockquote>\n<p>My claim is not that \"<code>FinEnum</code> is a useless idea\", but rather \"<code>FinEnum</code> is a poorly-executed idea\". The API works in terms of bijections with <code>Fin</code>, but every instance goes back and forth with lists, making many things O(n) which should be O(1)</p>",
        "id": 455609608,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1722507438
    }
]