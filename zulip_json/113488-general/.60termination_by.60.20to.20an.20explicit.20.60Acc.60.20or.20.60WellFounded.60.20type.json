[
    {
        "content": "<p>I'm tinkering a bit with termination proofs. A couple of sources state that what <code>termination_by</code> and <code>decreasing_by</code> do is confirm that a function is in some sort of way related with a wellfounded relationship. Can we give a function type or <code>Prop</code> type that explicitly states the relation enforced by <code>termination_by</code> and mentions the terminating function (and is effectively the predicate stating that a function terminates)?  Would this type mention <code>Acc</code> or <code>WellFounded</code>? <code>(f : A -&gt; B) -&gt;  Acc ? A -&gt; ?</code></p>",
        "id": 483368556,
        "sender_full_name": "nrs",
        "timestamp": 1732056858
    },
    {
        "content": "<p>I'm not quite sure what you mean. Well founded recursion is ultimately compiled to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=WellFounded.fix#doc\">docs#WellFounded.fix</a>, where <code>termination_by</code> determines what's used to produce <code>C</code>, and <code>decreasing_by</code> creates the proof of <code>r y x</code> in all calls to <code>((y : α) → r y x → C y)</code></p>",
        "id": 483412336,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1732082856
    },
    {
        "content": "<p>hm this is probably a noob question, but if well founded recursion is compiled to <code>WellFounded.fix</code>, how can we use computable recursive functions when it is tagged <code>noncomputable</code>?</p>",
        "id": 483412759,
        "sender_full_name": "nrs",
        "timestamp": 1732083154
    },
    {
        "content": "<p>The compiler handles it differently then the elaborator, I'm not sure about how the compiler does this</p>",
        "id": 483420149,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1732087654
    },
    {
        "content": "<p>I see ty!</p>",
        "id": 483430118,
        "sender_full_name": "nrs",
        "timestamp": 1732091882
    },
    {
        "content": "<p>When you write a recursive function, the pipeline from “source” to “native code” (i.e. the compiler) and the pipeline from “source” to “proof objects” (i.e. the theorem prover) split after elaboration, but before dealing with recursion. So the compiler doesn’t see <code>WellFounded.fix</code>, but rather an actually recursive function definition (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.PreDefinition#doc\">docs#Lean.PreDefinition</a>), and compiles that.</p>",
        "id": 483454268,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1732099527
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/channel/113488-general/topic/.60termination_by.60.20to.20an.20explicit.20.60Acc.60.20or.20.60WellFounded.60.20type/near/483454268\">said</a>:</p>\n<blockquote>\n<p>When you write a recursive function, the pipeline from “source” to “native code” (i.e. the compiler) and the pipeline from “source” to “proof objects” (i.e. the theorem prover) split after elaboration, but before dealing with recursion. So the compiler doesn’t see <code>WellFounded.fix</code>, but rather an actually recursive function definition (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.PreDefinition#doc\">docs#Lean.PreDefinition</a>), and compiles that.</p>\n</blockquote>\n<p>ah that makes a lot of sense, thank you very much for the explanation!</p>",
        "id": 483525394,
        "sender_full_name": "nrs",
        "timestamp": 1732120130
    }
]