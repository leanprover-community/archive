[
    {
        "content": "<p>I am working through the book, and just completed the chapter on classes. I wanted to try to make a simple calculator-style example.</p>\n<p>I figured something like this would be natural:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Exp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">reduce</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Exp</span><span class=\"w\"> </span><span class=\"n\">Î²</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>But I obviously can't declare Î² in the \"Signature\" (not sure what that is referred to in Lean) because then I'd have to also declare it in the \"return type\" of <code>reduce</code>.</p>\n<p>Am I modelling this wrong? At first I tried having a separate Î² that has to be [Exp ... o - 1] but I ran into similar problems about recursing in classes.</p>",
        "id": 534911155,
        "sender_full_name": "Kai Jellinghaus",
        "timestamp": 1755510388
    },
    {
        "content": "<p>can you state in maths what you're doing? i have no clue what you intend with your code</p>",
        "id": 534922659,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1755514413
    },
    {
        "content": "<p>I can't really, I don't really come from Maths but from Software <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>\n<p>The idea is to take a typical calculator example like \"2 * 5 + 1\" and turn it into a tree of expressions, and then reduce this step-by-step, (2 * 5 + 1 -&gt; 10 + 1 -&gt; 11).</p>\n<p>This might look something like this in pseudo-C#:</p>\n<div class=\"codehilite\" data-code-language=\"C#\"><pre><span></span><code><span class=\"k\">interface</span><span class=\"w\"> </span><span class=\"n\">Exp</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">Exp</span><span class=\"w\"> </span><span class=\"n\">Reduce</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">};</span>\n\n<span class=\"c1\">// Example expression implementation</span>\n<span class=\"k\">class</span><span class=\"w\"> </span><span class=\"nc\">ExpAdd</span><span class=\"w\"> </span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"n\">Exp</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">Exp</span><span class=\"w\"> </span><span class=\"n\">Left</span><span class=\"p\">;</span>\n<span class=\"w\">    </span><span class=\"n\">Exp</span><span class=\"w\"> </span><span class=\"n\">Right</span><span class=\"p\">;</span>\n\n<span class=\"w\">    </span><span class=\"n\">Exp</span><span class=\"w\"> </span><span class=\"nf\">Reduce</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">Left</span><span class=\"w\"> </span><span class=\"k\">is</span><span class=\"w\"> </span><span class=\"n\">ExpCons</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">Right</span><span class=\"w\"> </span><span class=\"k\">is</span><span class=\"w\"> </span><span class=\"n\">ExpCons</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">Left</span><span class=\"p\">.</span><span class=\"n\">Value</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">Right</span><span class=\"p\">.</span><span class=\"n\">Value</span><span class=\"p\">;</span>\n<span class=\"w\">        </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"k\">new</span><span class=\"w\"> </span><span class=\"nf\">ExpAdd</span><span class=\"p\">(</span><span class=\"n\">Left</span><span class=\"p\">.</span><span class=\"n\">Reduce</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">Right</span><span class=\"p\">.</span><span class=\"n\">Reduce</span><span class=\"p\">());</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>Of course most languages can't really safely represent this (The above implementation doesn't guarantee reducing actually makes any progress, it doesn't even really guarantee that the function returns).<br>\nIn Rust this could be extended with lifetimes to ensure no cyclic expressions, maybe with const generics it could track the \"order\" (what I tried with <code>o : Nat</code> here) so complete reduction can be guaranteed.</p>\n<p>I would've guessed the \"Lean way\" would be a type class, but it seems like I can't make a type class reference itself?<br>\nI hope this clarifies what I'm trying to do?</p>",
        "id": 534941379,
        "sender_full_name": "Kai Jellinghaus",
        "timestamp": 1755520092
    },
    {
        "content": "<p>You can make this sort of dynamic dispatch work if you really want to by building a dependent sum type but the usual approach to solve the expression problem in languages like Lean would be to use an <code>inductive</code></p>",
        "id": 534941714,
        "sender_full_name": "Henrik BÃ¶ving",
        "timestamp": 1755520206
    },
    {
        "content": "<p>Yeah, I first tried with <code>inductive</code> but couldn't really see how I can make the \"order\" tracking work (so it's clear that reduce must always improve the situation).<br>\nIn my mind it is also a little ugly, doesn't it? You'd have to have an increasingly larger match? Can make sense of course, just doesn't seem \"right\"?</p>",
        "id": 534942075,
        "sender_full_name": "Kai Jellinghaus",
        "timestamp": 1755520318
    },
    {
        "content": "<p>In Lean you (provably) can't create cyclic expressions (with an <code>inductive</code>)</p>",
        "id": 534942228,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755520382
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"949068\">Kai Jellinghaus</span> <a href=\"#narrow/stream/113488-general/topic/Help.3A.20Recursive.20Classes.3F/near/534942075\">said</a>:</p>\n<blockquote>\n<p>Yeah, I first tried with <code>inductive</code> but couldn't really see how I can make the \"order\" tracking work (so it's clear that reduce must always improve the situation).</p>\n</blockquote>\n<p>What do you mean \"order\"? What did you try?</p>",
        "id": 534942420,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755520451
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"949068\">Kai Jellinghaus</span> <a href=\"#narrow/channel/113488-general/topic/Help.3A.20Recursive.20Classes.3F/near/534942075\">said</a>:</p>\n<blockquote>\n<p>In my mind it is also a little ugly, doesn't it? You'd have to have an increasingly larger match? Can make sense of course, just doesn't seem \"right\"?</p>\n</blockquote>\n<p>You're asking about the expression problem here, one approach is to have a large match, the other is to have more and more type class instances, both of these approaches have their own pros and cons</p>",
        "id": 534942532,
        "sender_full_name": "Henrik BÃ¶ving",
        "timestamp": 1755520489
    },
    {
        "content": "<blockquote>\n<p>In Lean you (provably) can't create cyclic expressions (with an <code>inductive</code>)</p>\n</blockquote>\n<p>Right which is really nice, but <code>reduce</code> could still create more nodes, ie <code>reduce</code> on <code>Cons</code> could create an <code>(Add (Cons x - 1) (Cons 1))</code>, leading to repeatedly calling reduce going nowhere.</p>",
        "id": 534942582,
        "sender_full_name": "Kai Jellinghaus",
        "timestamp": 1755520504
    },
    {
        "content": "<p><a href=\"https://en.wikipedia.org/wiki/Expression_problem\">https://en.wikipedia.org/wiki/Expression_problem</a></p>",
        "id": 534942612,
        "sender_full_name": "Henrik BÃ¶ving",
        "timestamp": 1755520514
    },
    {
        "content": "<p>Looks like that's what I'm asking? Not sure, at a glance the wikipedia link mentions avoiding recompiling, which is not really what I try, but I guess I don't want to modify existing code. Right now I can't get the version with more type class instances to compile at all <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 534942896,
        "sender_full_name": "Kai Jellinghaus",
        "timestamp": 1755520614
    },
    {
        "content": "<blockquote>\n<p>What do you mean \"order\"? What did you try?</p>\n</blockquote>\n<p>My math knowledge is wonky, so \"order\" may not be the right term, sorry.<br>\nBasically <code>Cons</code> is 0 (no further children) <code>Add (Cons .) (Cons .)</code> is 1, <code>(Add (Add (Cons .) (Cons.)) (Cons .)</code> is 2, etc. if this number decreases after a reduction, it's clear progress towards termination has been made.</p>",
        "id": 534943252,
        "sender_full_name": "Kai Jellinghaus",
        "timestamp": 1755520741
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"949068\">Kai Jellinghaus</span> <a href=\"#narrow/channel/113488-general/topic/Help.3A.20Recursive.20Classes.3F/near/534942582\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>In Lean you (provably) can't create cyclic expressions (with an <code>inductive</code>)</p>\n</blockquote>\n<p>Right which is really nice, but <code>reduce</code> could still create more nodes, ie <code>reduce</code> on <code>Cons</code> could create an <code>(Add (Cons x - 1) (Cons 1))</code>, leading to repeatedly calling reduce going nowhere.</p>\n</blockquote>\n<p>You don't seem to be repeatedly calling it at all?</p>",
        "id": 534943290,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755520753
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"949068\">Kai Jellinghaus</span> <a href=\"#narrow/channel/113488-general/topic/Help.3A.20Recursive.20Classes.3F/near/534943252\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>What do you mean \"order\"? What did you try?</p>\n</blockquote>\n<p>My math knowledge is wonky, so \"order\" may not be the right term, sorry.<br>\nBasically <code>Cons</code> is 0 (no further children) <code>Add (Cons .) (Cons .)</code> is 1, <code>(Add (Add (Cons .) (Cons.)) (Cons .)</code> is 2, etc. if this number decreases after a reduction, it's clear progress towards termination has been made.</p>\n</blockquote>\n<p>When you write an inductive type Lean automatically makes a <code>sizeOf</code> instance which is some rough approximation to how big it is</p>",
        "id": 534943382,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755520782
    },
    {
        "content": "<p>This would be a lot easier with a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a></p>",
        "id": 534943476,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755520817
    },
    {
        "content": "<p>Right, main would look something like this (can't do this in Lean this quickly yet, but I think the example should demonstrate):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">var</span><span class=\"w\"> </span><span class=\"n\">input</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">readline</span><span class=\"o\">()</span><span class=\"bp\">;</span>\n<span class=\"n\">var</span><span class=\"w\"> </span><span class=\"n\">exp</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">parse</span><span class=\"o\">(</span><span class=\"n\">input</span><span class=\"o\">)</span><span class=\"bp\">;</span>\n\n<span class=\"n\">while</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">exp</span><span class=\"bp\">.</span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">):</span>\n<span class=\"w\">    </span><span class=\"n\">exp</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">exp</span><span class=\"bp\">.</span><span class=\"n\">reduce</span><span class=\"o\">()</span><span class=\"bp\">;</span>\n<span class=\"w\">    </span><span class=\"n\">print</span><span class=\"o\">(</span><span class=\"n\">exp</span><span class=\"o\">)</span><span class=\"bp\">;</span>\n</code></pre></div>\n<p>Inputting \"2 * 5 + 1\" will then print<br>\n\"10 + 1\", \"11\"b</p>",
        "id": 534943640,
        "sender_full_name": "Kai Jellinghaus",
        "timestamp": 1755520878
    },
    {
        "content": "<p>I'd love to provide a better example in Lean, but I don't have the skill to go beyond the given broken type class definition - can't really make implementations or parsing or whatever without it.</p>",
        "id": 534943863,
        "sender_full_name": "Kai Jellinghaus",
        "timestamp": 1755520959
    },
    {
        "content": "<p>oh so you want that repeatedly calling <code>reduce</code> will make the <code>exp.o</code> go to zero</p>",
        "id": 534943918,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755520974
    },
    {
        "content": "<p>Am I correct in understanding that <code>exp.o</code> is some sort of depth function?</p>",
        "id": 534944014,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755521008
    },
    {
        "content": "<p>Yes? Basically, by \"reducing\" constant expressions like (Add (Cons 1) (Cons 2)) to (Cons 3)</p>",
        "id": 534944018,
        "sender_full_name": "Kai Jellinghaus",
        "timestamp": 1755521011
    },
    {
        "content": "<p><code>o</code> (I suppose order is the wrong term) is the depth yes. Could be a function, field, whatever.</p>",
        "id": 534944089,
        "sender_full_name": "Kai Jellinghaus",
        "timestamp": 1755521038
    },
    {
        "content": "<p>ok so are these \"expressions\" supposed to be extensible?</p>",
        "id": 534944222,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755521085
    },
    {
        "content": "<p>Yes. As in new structures can be defined w/ instances of the type class</p>",
        "id": 534944332,
        "sender_full_name": "Kai Jellinghaus",
        "timestamp": 1755521124
    },
    {
        "content": "<p>what do you mean exactly be \"new structures\"?</p>",
        "id": 534944583,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755521234
    },
    {
        "content": "<p>Like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">ExpSub</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Î²</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î±</span>\n<span class=\"w\">  </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î²</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Repr</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">ExpNeg</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î±</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Repr</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">ExpCons</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Repr</span>\n</code></pre></div>\n<p>where I can then introduce <code>ExpMul</code> etc.</p>\n<p>(Class instances missing of course)</p>",
        "id": 534944893,
        "sender_full_name": "Kai Jellinghaus",
        "timestamp": 1755521349
    },
    {
        "content": "<p>oh ok that makes sense</p>",
        "id": 534944960,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755521369
    },
    {
        "content": "<p>You will end up having a large type living in the next universe up because of size issues</p>",
        "id": 534945178,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755521443
    },
    {
        "content": "<p>Okay, I'm guessing that is bad (will need to read the book further). So what is the way to represent this kind of thing then? Is <code>inductive</code> really the way even if I would plan on expanding this to a ton of expression types? (A thousand line <code>match</code> seems like bad practice)</p>",
        "id": 534945542,
        "sender_full_name": "Kai Jellinghaus",
        "timestamp": 1755521569
    },
    {
        "content": "<p>I <em>don't know</em> what will be best for your use case</p>",
        "id": 534945731,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755521627
    },
    {
        "content": "<p>I understand you to say a big type class like this is probably bad practice? What would be an alternative? Maybe I'm just not informed enough and jumped into this too early, but not really sure at this point what other option I can consider beyond <code>inductive</code> (which seems to me like it would be hard to maintain, so bad practice) and a big type class, which is also bad practice or just outright not possible?</p>",
        "id": 534946336,
        "sender_full_name": "Kai Jellinghaus",
        "timestamp": 1755521836
    },
    {
        "content": "<p>You would have to bundle both the type and the typeclass instance into the data, which gets you into DTT hell very quickly</p>",
        "id": 534947307,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755522114
    },
    {
        "content": "<p>How many expression nodes do you envision having? Knowing more about the scope is a good analogue for \"can you state in maths what you're doing\" â€” \"can you state the program design problem more concretely?\" (Not just the abstract 'design patterns' problems.)</p>\n<p>Btw, \"classes\" in Lean can be thought of as being more like interfaces. They're all resolved at compile time, so unless you have some flexible data type that covers what you want to do at runtime, a purely class-based approach might limit you to evaluating expressions that are more-or-less known at compile time.</p>",
        "id": 534948925,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1755522616
    },
    {
        "content": "<p>let's say a few hundred? Mostly just exploring with an example I know well (and, I think, lends itself well to exploring safety &amp; tradeoffs in a language)<br>\nAnd yes, thanks for the explanation. This is a bit of an X Y problem, but that is because there is no \"real\" problem, just me trying to apply what I learned :)</p>\n<p>That makes sense. Parsing into a hierarchy would probably be an issue then.</p>",
        "id": 534950123,
        "sender_full_name": "Kai Jellinghaus",
        "timestamp": 1755522984
    },
    {
        "content": "<p>Can you be more concrete? What would the few hundred expression node types look like? Are the known at compile time? Should users of the library be able to extend the set of them? (I know there's no \"real\" problem, but it's easier to talk about it like there is one.)</p>",
        "id": 534951415,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1755523355
    },
    {
        "content": "<p>Sure, I'll try. Beyond the basics of add/sub/mul/div I can imagine extending with simple built-in functions like pow/sqrt/sin/cos/etc. Could also build load/store on top of this, etc. So a design that at least somewhat scales is the goal.<br>\nIdeally these can be loaded &amp; reduced at runtime. I haven't looked into parsing and such at all yet, just interested to see where it leads. If having everything known at compile time is very different, that's fine in my mind.<br>\nI don't really care about extending with new types, especially not at runtime, it just seems like a normal thing to reach for when more then a few options exist, for the sake of maintainability on my side (reducing coupling and all that).<br>\nDoes that make sense?</p>",
        "id": 534953212,
        "sender_full_name": "Kai Jellinghaus",
        "timestamp": 1755523908
    },
    {
        "content": "<p>Must pow/sqrt/sin/cos be nodes, or would it make sense having <code>unop</code>/<code>binop</code> nodes and types for operators? That's usually how expression trees tend to be handled.</p>",
        "id": 534955616,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1755524737
    },
    {
        "content": "<p>e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Const</span><span class=\"w\"> </span><span class=\"n\">Op</span><span class=\"w\"> </span><span class=\"n\">Binop</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Const</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">unop</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Op</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"n\">Const</span><span class=\"w\"> </span><span class=\"n\">Op</span><span class=\"w\"> </span><span class=\"n\">Binop</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">binop</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Binop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">e'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"n\">Const</span><span class=\"w\"> </span><span class=\"n\">Op</span><span class=\"w\"> </span><span class=\"n\">Binop</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 534955938,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1755524841
    },
    {
        "content": "<p>That's for a simply-typed language. Where classes could come in potentially is in giving interpretations to <code>Const</code>/<code>Op</code>/<code>Binop</code> terms for the evaluator.</p>",
        "id": 534956027,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1755524871
    },
    {
        "content": "<p>Here's an easily arbitrarily extensible language:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">unop</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">binop</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">e'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"bp\">.</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Î±</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">c</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">unop</span><span class=\"w\"> </span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">eval</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">binop</span><span class=\"w\"> </span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">eval</span>\n</code></pre></div>\n<p>It embeds the operations right in the tree. The cost of doing this is that you can't match on operations, for example you can't print the expression trees when encoded this way.</p>",
        "id": 534956397,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1755524997
    },
    {
        "content": "<p>I came across <a href=\"https://github.com/leanprover/lean4/blob/master/doc/examples/phoas.lean\">https://github.com/leanprover/lean4/blob/master/doc/examples/phoas.lean</a> and was reminded of this thread. Parametric higher order abstract syntax (PHOAS) is a really cool technique for doing a functional programming version of the visitor pattern. You can also extend the type to some degree after the fact as well.</p>",
        "id": 535218939,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1755648929
    },
    {
        "content": "<p>Oh that is really cool. Will have to dig more into that.<br>\nI haven't gotten this far yet, but proving the constant folding is sound is really cool in my mind.<br>\nThanks a lot for the input <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 535219349,
        "sender_full_name": "Kai Jellinghaus",
        "timestamp": 1755649221
    },
    {
        "content": "<p>Perhaps of some relevance:<br>\n<a href=\"https://lean-lang.org/doc/reference/latest///Type-Classes/Instance-Declarations/#recursive-instances\">https://lean-lang.org/doc/reference/latest///Type-Classes/Instance-Declarations/#recursive-instances</a></p>\n<p>\"The standard idiom to work around this limitation is to create a local instance in a recursively-defined function that includes a reference to the function being defined, taking advantage of the fact that instance synthesis may use every binding in the local context with the right type.\"</p>",
        "id": 535224192,
        "sender_full_name": "Yan Yablonovskiy ðŸ‡ºðŸ‡¦",
        "timestamp": 1755653510
    }
]