[
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- my own implementation of Nat -/</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- get a term of `MyNat` from one of `Nat` -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"bp\">.</span><span class=\"n\">ofNat</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"bp\">.</span><span class=\"n\">zero</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MyNat</span><span class=\"bp\">.</span><span class=\"n\">ofNat</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">default_instance</span><span class=\"kd\">]</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OfNat</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">ofNat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"bp\">.</span><span class=\"n\">ofNat</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"sd\">/-- one of Peano axiom -/</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n\n<span class=\"sd\">/-- one of Peano axiom, literal version -/</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"c1\">-- unsolved goals...</span>\n<span class=\"w\">  </span><span class=\"c1\">-- how to unfold numeric literal automatically?</span>\n</code></pre></div>",
        "id": 485947666,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1733258127
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- This works, but is too ad hoc.</span>\n<span class=\"c1\">-- I want a way that doesn't get me into trouble when the numbers get bigger.</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">change</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">zero</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 485948270,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1733258311
    },
    {
        "content": "<p><code>intro h; cases h</code> should prove it.</p>",
        "id": 485948329,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1733258337
    },
    {
        "content": "<p>Or you can do <code>change MyNat.zero ≠ MyNat.succ _</code> and let Lean handle filling in the <code>_</code>.</p>",
        "id": 485948431,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1733258376
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> </p>\n<p>thanks. but why this works? </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n</code></pre></div>\n<p>what is the difference between <code>MyNat</code> and <code>Nat</code>?</p>",
        "id": 485950109,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1733258962
    },
    {
        "content": "<p>Try <code>simp?</code> to see</p>",
        "id": 485950271,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1733259011
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ne_eq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">reduceCtorEq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">not_false_eq_true</span><span class=\"o\">]</span>\n</code></pre></div>\n<p><del>what is  <code>reduceCtorEq</code>?</del> I see. <code>reduceCtorEq</code> is defined as simproc...</p>",
        "id": 485950442,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1733259078
    },
    {
        "content": "<p>There is special support for Nat literals in reduceCtorEq as well. It sees <code>1</code> as <code>Nat.succ 0</code>.</p>",
        "id": 485950909,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1733259247
    },
    {
        "content": "<p>Does this mean that a <code>simproc</code> can be defined for <code>MyNat</code> as well, so that a proof can be done with single <code>simp</code>?</p>",
        "id": 485951062,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1733259300
    },
    {
        "content": "<p>Yes</p>",
        "id": 485951138,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1733259327
    }
]