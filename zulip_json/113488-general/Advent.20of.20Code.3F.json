[
    {
        "content": "<p>Is anyone trying to do Advent of Code in Lean this year?</p>",
        "id": 405279074,
        "sender_full_name": "Omri Schwarz",
        "timestamp": 1701408555
    },
    {
        "content": "<p><a href=\"https://github.com/adomani/advents\">I am</a>.<br>\n(Not polished yet, but it should work!)</p>\n<p>I plan to polish at least the first day or two, since I am planning to \"Christmas\" lecture on Lean as a programming language for my students.</p>",
        "id": 405289417,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1701412874
    },
    {
        "content": "<p>Hi, I missed this thread. I’m also doing it in Lean (as well as a billion other languages, probably)</p>",
        "id": 405346467,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1701431979
    },
    {
        "content": "<p>My terrible first attempt is at <a href=\"#narrow/stream/113488-general/topic/Advent.20of.20Code.202023\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Advent.20of.20Code.202023</a> but it takes couple hours, I think</p>",
        "id": 405348546,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1701432386
    },
    {
        "content": "<p>First night of the advent and I missed how a misclick gave me the 1st day puzzle from 2015. ..</p>",
        "id": 405368393,
        "sender_full_name": "Omri Schwarz",
        "timestamp": 1701438862
    },
    {
        "content": "<p>Also, the author has asked people not to publish their input data publicly: <a href=\"https://twitter.com/ericwastl/status/1465805354214830081\">https://twitter.com/ericwastl/status/1465805354214830081</a></p>",
        "id": 405371136,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1701439608
    },
    {
        "content": "<p>And I am stuck because of what happens when digit words overlap, I think.</p>",
        "id": 405378020,
        "sender_full_name": "Omri Schwarz",
        "timestamp": 1701441962
    },
    {
        "content": "<p>Yeah, a lot of people did</p>",
        "id": 405379123,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1701442302
    },
    {
        "content": "<p>I will also be trying to do the Advent of Code <a href=\"https://github.com/arthur-adjedj/AOC/tree/master\">here</a></p>",
        "id": 405406147,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1701450996
    },
    {
        "content": "<p>I'm not sure how long I'll keep it up, but I have my solutions <a href=\"https://github.com/kmill/kmill-aoc2023\">here</a></p>",
        "id": 405412614,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1701453451
    },
    {
        "content": "<p>There is also an <a href=\"https://homepages.inf.ed.ac.uk/loconno/\">Advent of Proof</a>!</p>",
        "id": 405414078,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1701453976
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"128280\">Wojciech Nawrocki</span> <a href=\"#narrow/stream/113488-general/topic/Advent.20of.20Code.3F/near/405414078\">said</a>:</p>\n<blockquote>\n<p>There is also an <a href=\"https://homepages.inf.ed.ac.uk/loconno/\">Advent of Proof</a>!</p>\n</blockquote>\n<p>Is this supposed to just be a discord invite?</p>",
        "id": 405415377,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1701454527
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/113488-general/topic/Advent.20of.20Code.3F/near/405415377\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"128280\">Wojciech Nawrocki</span> <a href=\"#narrow/stream/113488-general/topic/Advent.20of.20Code.3F/near/405414078\">said</a>:</p>\n<blockquote>\n<p>There is also an <a href=\"https://homepages.inf.ed.ac.uk/loconno/\">Advent of Proof</a>!</p>\n</blockquote>\n<p>Is this supposed to just be a discord invite?</p>\n</blockquote>\n<p>There is a webpage, but it appears to ask for access to a Discord account to use as your submission account.</p>",
        "id": 405415931,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1701454794
    },
    {
        "content": "<p>How hard is it? I will try tonight but I feel kind of nervous (???)</p>",
        "id": 405419663,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1701456473
    },
    {
        "content": "<p>Okay it's not hard at all, at least D1</p>",
        "id": 405429689,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1701460769
    },
    {
        "content": "<p>I'm also doing it, at least for the first few days. Repository <a href=\"https://github.com/dupuisf/aoc2023\">here</a>.</p>",
        "id": 405453060,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1701472676
    },
    {
        "content": "<p>Is anyone considering writing formal specs and proofs? :-)</p>\n<p>I did day 1, and will probably do as many (in lean) as my kid does (in python). I didn't attempt to verify it, but looking at the code here are some basic facts that I would have wanted:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">proof_wanted</span> <span class=\"n\">String.intercalate_splitOn</span> <span class=\"o\">{</span><span class=\"n\">sep</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n    <span class=\"n\">sep.intercalate</span> <span class=\"o\">(</span><span class=\"n\">s.splitOn</span> <span class=\"n\">sep</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">s</span>\n\n<span class=\"n\">proof_wanted</span> <span class=\"n\">List.insertionSort_sorted</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">DecidableRel</span> <span class=\"n\">r</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">l.insertionSort</span> <span class=\"n\">r</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">Sorted</span> <span class=\"n\">r</span>\n\n<span class=\"n\">proof_wanted</span> <span class=\"n\">String.mem_findAllSubstr_iff</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n    <span class=\"n\">t</span> <span class=\"bp\">∈</span> <span class=\"n\">s.findAllSubstr</span> <span class=\"n\">p</span> <span class=\"bp\">↔</span> <span class=\"n\">t.str</span> <span class=\"bp\">=</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"n\">t.toString</span> <span class=\"bp\">=</span> <span class=\"n\">p</span>\n\n<span class=\"sd\">/-- `String.findAllSubstr` returns results in order. -/</span>\n<span class=\"n\">proof_wanted</span> <span class=\"n\">String.findAllSubstr_sorted</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">s.findAllSubstr</span> <span class=\"n\">p</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">Substring.startPos</span><span class=\"o\">)</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">toList</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">Sorted</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">·</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>We really need to add the <code>String</code> instances for <code>slim_check</code> so we can sanity check statement like these; I bet at least one is wrong! :-)</p>",
        "id": 405454520,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1701473742
    },
    {
        "content": "<p>The AOC might be a great opportunity to find missing functions/theorems currently missing in Lean.  I found myself being limited in my options when writing my code. For example, manipulating <code>Substring</code> isn't so easy, since the functions aren't documented. Furthermore, I don't feel like the <code>str[a:b]</code> notation should give an Array as it does now, I feel like it would make sense for it to return a Substring, in the same way that <code>arr[a:b]</code> returns a Subarray for a given Array.</p>",
        "id": 405455449,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1701474422
    },
    {
        "content": "<p>Here's a problem that came up for me: how do we prove termination of a monadic parser, such as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">getFirstNum</span> <span class=\"o\">:</span> <span class=\"n\">Parsec</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"n\">parseNumberForwards</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"o\">(</span><span class=\"k\">do</span> <span class=\"k\">let</span> <span class=\"n\">_</span> <span class=\"bp\">←</span> <span class=\"n\">anyChar</span><span class=\"bp\">;</span> <span class=\"n\">getFirstNum</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>where <code>getFirstNum</code> is another parser that tries to get a digit at the current position either as an actual digit or spelled out as a word. Here termination should be guaranteed by the fact that the string being parsed gets strictly shorter with every recursive call, but this is all hidden under monadic code.</p>",
        "id": 405457397,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1701475334
    },
    {
        "content": "<p>You can't, at least not written that way. One way you could do it is to have a <code>Parsec.fix : (Parsec A -&gt; Parsec A) -&gt; Parsec A</code> parser, which calls the passed function with a parser that acts like the one under construction except it fails if called from the same or lower string position</p>",
        "id": 405458177,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701475730
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"432410\">Arthur Adjedj</span> <a href=\"#narrow/stream/113488-general/topic/Advent.20of.20Code.3F/near/405455449\">said</a>:</p>\n<blockquote>\n<p>The AOC might be a great opportunity to find missing functions/theorems currently missing in Lean.</p>\n</blockquote>\n<p>I think this every year. Maybe what we should do is have a wiki page so that people can jot down their pain points or missing theorems as they come up. Or just post here on zulip</p>",
        "id": 405458396,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701475856
    },
    {
        "content": "<p>Yeah, also I guess there's always the \"fuel\" trick:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">getFirstNum</span> <span class=\"o\">(</span><span class=\"n\">fuel</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Parsec</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"n\">parseNumberForwards</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">if</span> <span class=\"n\">fuel</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"n\">fail</span> <span class=\"s2\">\"end of string\"</span>\n    <span class=\"k\">else</span>\n      <span class=\"k\">let</span> <span class=\"n\">_</span> <span class=\"bp\">←</span> <span class=\"n\">anyChar</span>\n      <span class=\"n\">getFirstNum</span> <span class=\"o\">(</span><span class=\"n\">fuel</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 405458442,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1701475893
    },
    {
        "content": "<p>It's important to catch people in the moment though, because even a few hours later going back over the code you may already have forgotten what lemma you were missing and worked around</p>",
        "id": 405458462,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701475906
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"311453\">@Frédéric Dupuis</span> the downside of that version is that every recursive parser needs an if statement</p>",
        "id": 405458569,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701475953
    },
    {
        "content": "<p>and you have to set the fuel correctly and prove that it is large enough etc</p>",
        "id": 405458618,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701475990
    },
    {
        "content": "<p>Yeah, in this case it's not a big problem but it's definitely a downside.</p>",
        "id": 405458650,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1701476011
    },
    {
        "content": "<p>As for missing lemmas, would you welcome PRs to Std for functions like <code>String.reverse</code> or is this just going to get annoying?</p>",
        "id": 405459526,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1701476563
    },
    {
        "content": "<p>Yes certainly we want such theorems</p>",
        "id": 405459569,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701476591
    },
    {
        "content": "<p>I think it's probably better to get the <code>proof_wanted</code> version of the theorems first though, the proofs can come later</p>",
        "id": 405459629,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701476639
    },
    {
        "content": "<p>Right. (Though in this case it's just the function that reverses a string.)</p>",
        "id": 405459813,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1701476753
    },
    {
        "content": "<p>oh you mean the function itself, not the lemmas</p>",
        "id": 405459891,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701476784
    },
    {
        "content": "<p>We'd prefer lemmas over functions for now. :-)</p>",
        "id": 405459986,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1701476847
    },
    {
        "content": "<p>Alright, makes sense!</p>",
        "id": 405460014,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1701476870
    },
    {
        "content": "<p>rust std doesn't have a <code>String::reverse</code> so I'm a bit meh</p>",
        "id": 405460021,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701476874
    },
    {
        "content": "<p>I think PRs with new functions for Std are okay, but perhaps they could come with a fair bit of effort to include all the lemmas, at least as <code>proof_wanted</code>.</p>",
        "id": 405460023,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1701476879
    },
    {
        "content": "<p>We would really like to get to the point where we know what is missing in terms of adding API, i.e. where we can post a graph of the number of <code>proof_wanted</code> statements and feel like getting it to zero will be a meaningful milestone.</p>",
        "id": 405460158,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1701476949
    },
    {
        "content": "<p>In fact I think we should push people to use <code>proof_wanted</code> more aggressively in those PRs, that way they can be focused on the API design rather than adding a bunch of work which may need to be discarded in response to definition changes</p>",
        "id": 405460188,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701476966
    },
    {
        "content": "<p>So I guess this is what you had in mind, Mario?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Parsec.fix</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Parsec</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Parsec</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Parsec</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">it</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"k\">let</span> <span class=\"n\">p'</span> <span class=\"o\">:</span> <span class=\"n\">Parsec</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">it'</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">it.s.endPos</span> <span class=\"bp\">-</span> <span class=\"n\">it.i</span> <span class=\"bp\">≤</span> <span class=\"n\">it'.s.endPos</span> <span class=\"bp\">-</span> <span class=\"n\">it'.i</span> <span class=\"k\">then</span>\n      <span class=\"bp\">.</span><span class=\"n\">error</span> <span class=\"n\">it'</span> <span class=\"s2\">\"recursive call going backwards in the string\"</span>\n    <span class=\"k\">else</span>\n      <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">it'.s.endPos</span> <span class=\"bp\">-</span> <span class=\"n\">it'.i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">it.s.endPos</span> <span class=\"bp\">-</span> <span class=\"n\">it.i</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n        <span class=\"k\">have</span> <span class=\"n\">h''</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">it.s.endPos</span> <span class=\"bp\">-</span> <span class=\"n\">it.i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">byteIdx</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">it'.s.endPos</span> <span class=\"bp\">-</span> <span class=\"n\">it'.i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">byteIdx</span> <span class=\"o\">:=</span> <span class=\"n\">h</span>\n        <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"n\">Nat.not_le</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h''</span>\n      <span class=\"n\">fix</span> <span class=\"n\">p</span> <span class=\"n\">it'</span>\n  <span class=\"n\">p</span> <span class=\"n\">p'</span> <span class=\"n\">it</span>\n<span class=\"n\">termination_by</span> <span class=\"n\">fix</span> <span class=\"n\">p</span> <span class=\"n\">it</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">it</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">getFirstNum</span> <span class=\"o\">:</span> <span class=\"n\">Parsec</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">fix</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"n\">parseNumberForwards</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"k\">do</span> <span class=\"k\">let</span> <span class=\"n\">_</span> <span class=\"bp\">←</span> <span class=\"n\">anyChar</span><span class=\"bp\">;</span> <span class=\"n\">p</span>\n</code></pre></div>",
        "id": 405471085,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1701481665
    },
    {
        "content": "<p>Very nice, I expected this to be more painful.</p>",
        "id": 405471350,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1701481811
    },
    {
        "content": "<p>or more simply</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Parsec.fix</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Parsec</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Parsec</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Parsec</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">it</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"k\">let</span> <span class=\"n\">p'</span> <span class=\"o\">:</span> <span class=\"n\">Parsec</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">it'</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">if</span> <span class=\"n\">it'.s.endPos</span> <span class=\"bp\">-</span> <span class=\"n\">it'.i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">it.s.endPos</span> <span class=\"bp\">-</span> <span class=\"n\">it.i</span> <span class=\"k\">then</span>\n      <span class=\"n\">fix</span> <span class=\"n\">p</span> <span class=\"n\">it'</span>\n    <span class=\"k\">else</span>\n      <span class=\"bp\">.</span><span class=\"n\">error</span> <span class=\"n\">it'</span> <span class=\"s2\">\"recursive call going backwards in the string\"</span>\n  <span class=\"n\">p</span> <span class=\"n\">p'</span> <span class=\"n\">it</span>\n</code></pre></div>",
        "id": 405471364,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701481822
    },
    {
        "content": "<p>What is <code>parseNumberForwards</code>? Loogle gives no hits.<br>\n(by the way, my AoC is <a href=\"https://github.com/adomasbaliuka/AdventOfCode2023\">here</a> but I probably won't be using <code>Parsec</code> because I couldn't find a tutorial yet and it feels I'm doing it very wrong).</p>",
        "id": 405523531,
        "sender_full_name": "Adomas Baliuka",
        "timestamp": 1701514568
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 405523712,
        "sender_full_name": "Adomas Baliuka",
        "timestamp": 1701514626
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"638715\">@Adomas Baliuka</span>  You can find my full solutions <a href=\"https://github.com/dupuisf/aoc2023\">here</a>. This code is in <code>Aoc2023/Day01.lean</code>, and the functions I use there that are not in core or Std are in <code>Aoc2023/Utils.lean</code>.</p>",
        "id": 405542404,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1701529993
    },
    {
        "content": "<p>I am also participating, <a href=\"https://github.com/AntanasKal/Advent-of-Code-2023\">here</a> are my solutions. Hoping to go through the whole event.</p>",
        "id": 405558886,
        "sender_full_name": "Antanas Kalkauskas",
        "timestamp": 1701543932
    },
    {
        "content": "<p>Is anyone hosting a private Advent of Code leaderboard for lean4 solutions?</p>",
        "id": 405559029,
        "sender_full_name": "Antanas Kalkauskas",
        "timestamp": 1701544041
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Advent.20of.20Code.3F/near/405471364\">said</a>:</p>\n<blockquote>\n<p>or more simply</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Parsec.fix</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Parsec</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Parsec</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Parsec</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">it</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"k\">let</span> <span class=\"n\">p'</span> <span class=\"o\">:</span> <span class=\"n\">Parsec</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">it'</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">if</span> <span class=\"n\">it'.s.endPos</span> <span class=\"bp\">-</span> <span class=\"n\">it'.i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">it.s.endPos</span> <span class=\"bp\">-</span> <span class=\"n\">it.i</span> <span class=\"k\">then</span>\n      <span class=\"n\">fix</span> <span class=\"n\">p</span> <span class=\"n\">it'</span>\n    <span class=\"k\">else</span>\n      <span class=\"bp\">.</span><span class=\"n\">error</span> <span class=\"n\">it'</span> <span class=\"s2\">\"recursive call going backwards in the string\"</span>\n  <span class=\"n\">p</span> <span class=\"n\">p'</span> <span class=\"n\">it</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Can we reuse the parser propositions I developed for the lean3 parser here?</p>",
        "id": 405572817,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1701557053
    },
    {
        "content": "<p>quite possibly. I think they all have to be rewritten since the underlying types and operations have changed but the ideas should still work</p>",
        "id": 405573409,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701557197
    },
    {
        "content": "<p>Agree on the rewrite. There might be a need for special support in the termination checker for parsecs to look for a <a href=\"https://leanprover-community.github.io/mathlib_docs/find/parser.prog\">docs3#parser.prog</a></p>",
        "id": 405573663,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1701557323
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"128280\">Wojciech Nawrocki</span> <a href=\"#narrow/stream/113488-general/topic/Advent.20of.20Code.3F/near/405414078\">said</a>:</p>\n<blockquote>\n<p>There is also an <a href=\"https://homepages.inf.ed.ac.uk/loconno/\">Advent of Proof</a>!</p>\n</blockquote>\n<p>this is meant as a competition for beginners/intermediate lean users associated with the university of edinburgh's TypeSig and related student societies, not really for general admission. If this works well perhaps we will expand the scope next year.</p>",
        "id": 405708081,
        "sender_full_name": "Liam O'Connor",
        "timestamp": 1701645882
    },
    {
        "content": "<p>I am also using AoC to learn more about practical programming in Lean. Here are my <a href=\"https://github.com/philnguyen/aoc/tree/main/2023\">solutions</a></p>\n<p>For input processing, I'm either doing naive parsing using <code>String.splitOn</code>, or emacs's macros to massage the input. Are there tutorials/examples out there for using Lean's parser library? Thanks!</p>",
        "id": 405710265,
        "sender_full_name": "Phil Nguyen",
        "timestamp": 1701647629
    },
    {
        "content": "<p>I don't think there are any tutorials, but if you want a more extended example, I wrote a bibtex parser <a href=\"https://github.com/dupuisf/BibtexQuery\">here</a>. It's probably not great code though, this was my first attempt at using monadic parsers.</p>",
        "id": 405713263,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1701649633
    },
    {
        "content": "<p>Can we make a \"blessed\" solution of AoC that shows best practices (while remaining concise so people can easily read all of it)? Which of the solutions referenced here so far (certainly not mine) might be candidates?</p>",
        "id": 405715031,
        "sender_full_name": "Adomas Baliuka",
        "timestamp": 1701650575
    },
    {
        "content": "<p>Just joined this Zulip. I am using <a href=\"https://github.com/21eleven/drink-lean-for-christmas-2023/tree/main/Aoc\">Advent of Code  to learn Lean</a> . Found this thread while searching for documentation on parsers :p</p>",
        "id": 405748221,
        "sender_full_name": "21eleven",
        "timestamp": 1701667603
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"638715\">@Adomas Baliuka</span> Of the examples linked so far, I think <a href=\"https://github.com/kmill/kmill-aoc2023\">Kyle's</a> solutions are the most best-practice looking. It's a lot more work to write this kind of teaching material every day compared to just solving the problem though</p>",
        "id": 405749268,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701668391
    },
    {
        "content": "<p>I wonder, why are some definitions marked <code>partial</code> there? I removed it at two random examples and it seemed the keyword was not necessary. Why does one mark definitions <code>partial</code> when it's not needed to make Lean accept them?</p>",
        "id": 405750250,
        "sender_full_name": "Adomas Baliuka",
        "timestamp": 1701669116
    },
    {
        "content": "<p>probably just copy pasta</p>",
        "id": 405751256,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701669697
    },
    {
        "content": "<p>It's possibly a bit faster to compile if you don't have to do the termination proof? But for most functions this is barely noticeable</p>",
        "id": 405751394,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701669744
    },
    {
        "content": "<p>If you're talking about the <code>partial</code>s in day 1 part 2, I just forgot to remove them. I started by writing a state machine to process characters one at a time, but then I realized there was <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=String.findAllSubstr#doc\">docs#String.findAllSubstr</a> (which uses a KMP matcher by the way) and went with that.</p>",
        "id": 405892275,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1701715985
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"476925\">@Phil Nguyen</span> I've been using Lean's Parsec library here and there. It's a bit anemic as a parser library, but it has just enough to be able to write what you need. <a href=\"https://github.com/kmill/kmill-aoc2023/blob/main/AoC2023/Day4/Part1.lean#L8-L16\">Here</a> is a parser for today's format. I put the <code>ws</code> whitespace parser probably in more places than I needed, which is harmless, but one gotcha is that because Parsec commits to a parse, I needed to write <code>many (nat &lt;* ws)</code> instead of <code>many (ws *&gt; nat)</code>, since in the latter matching whitespace causes it to think there ought to be another <code>nat</code>.</p>\n<p>I had to define the <code>nat</code> parser myself, and it's <a href=\"https://github.com/kmill/kmill-aoc2023/blob/main/AoC2023/Util.lean#L23-L24\">here</a>.</p>",
        "id": 405892923,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1701716239
    },
    {
        "content": "<p>I should have written a general <code>sepBy</code> parser, but instead in day 2 I wrote <a href=\"https://github.com/kmill/kmill-aoc2023/blob/main/AoC2023/Day2/Format.lean#L44-L68\">specialized versions</a>. I'll probably factor it out when it's needed in a future day.</p>",
        "id": 405893207,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1701716331
    },
    {
        "content": "<p>My solutions are <a href=\"https://github.com/fNBU/aoc23\">here</a>. First time using Lean. Using it as an opportunity to get better at monads/applicatives.</p>",
        "id": 406080732,
        "sender_full_name": "Adam Layne",
        "timestamp": 1701789447
    },
    {
        "content": "<p>AoC23 seems pretty heavy on text parsing, so I should probably learn the parser library as well.</p>",
        "id": 406081077,
        "sender_full_name": "Adam Layne",
        "timestamp": 1701789536
    },
    {
        "content": "<p>Also using AoC to learn some Lean (coming from Haskell/Rust). I got to use Parsec for day 2. My solutions are <a href=\"https://github.com/TristanCacqueray/advent-of-lean/tree/main/AdventOfLean\">here</a> if that helps. It's a lot of fun, cheers :)</p>",
        "id": 406118449,
        "sender_full_name": "tristanC",
        "timestamp": 1701800012
    },
    {
        "content": "<p>Hey y'all <span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span> Late to the party here, but I'm <a href=\"https://github.com/jamesdabbs/advent-2023\">getting started</a> as well. Similarly, just wrapped up <a href=\"https://github.com/jamesdabbs/advent-2023/blob/ab8f0c55a371e4047c4b173ca288c596b5167aa8/Advent2023/2.lean#L25-L46\">my first non-trivial bit of parsing</a> for day 2.</p>",
        "id": 406120658,
        "sender_full_name": "James Dabbs",
        "timestamp": 1701800830
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"422543\">Stuart Presnell</span> has marked this topic as resolved.</p>",
        "id": 406165323,
        "sender_full_name": "Notification Bot",
        "timestamp": 1701813016
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"422543\">Stuart Presnell</span> has marked this topic as unresolved.</p>",
        "id": 406165366,
        "sender_full_name": "Notification Bot",
        "timestamp": 1701813048
    },
    {
        "content": "<p>Sorry, misclicked the \"mark as resolved\" button</p>",
        "id": 406165459,
        "sender_full_name": "Stuart Presnell",
        "timestamp": 1701813109
    },
    {
        "content": "<p>Kind of silly, but is there a standard library function for sorting a list? I couldn't find it for day 7 so ended up implementing a basic one today. I tried autocompletion in emacs, and searching for <code>{a : Type} -&gt; [Ord a] -&gt; List a -&gt; List a</code> on Loogle but couldn't find anything <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 406495623,
        "sender_full_name": "Phil Nguyen",
        "timestamp": 1701938826
    },
    {
        "content": "<p>I can offer you <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Array.qsort#doc\">docs#Array.qsort</a> but I think nobody bothered to implement list sorting yet</p>",
        "id": 406526047,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1701949731
    },
    {
        "content": "<p>For what it's worth, I propose this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- From https://codereview.stackexchange.com/questions/197868/bubble-sort-in-haskell</span>\n<span class=\"kd\">def</span> <span class=\"n\">swapTill</span> <span class=\"o\">[</span><span class=\"n\">Min</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Max</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">List</span> <span class=\"n\">α</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">y</span> <span class=\"o\">::</span> <span class=\"n\">xs</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">min</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">::</span> <span class=\"n\">swapTill</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">xs</span>\n<span class=\"kd\">def</span> <span class=\"n\">List.bubbleSort</span> <span class=\"o\">[</span><span class=\"n\">Min</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Max</span> <span class=\"n\">α</span><span class=\"o\">]:</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">List.foldr</span> <span class=\"n\">swapTill</span> <span class=\"o\">[]</span>\n</code></pre></div>",
        "id": 406533002,
        "sender_full_name": "tristanC",
        "timestamp": 1701952274
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.insertionSort#doc\">docs#List.insertionSort</a></p>",
        "id": 406539379,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1701954634
    },
    {
        "content": "<p>or <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.mergeSort#doc\">docs#List.mergeSort</a>.</p>",
        "id": 406770688,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1702045823
    },
    {
        "content": "<p>Doing AoC and find myself wanting to use Lean's builtin parser, perhaps naively. Is there an easy interface to it along the lines of <code>parse : Parser -&gt; String -&gt; Option Syntax</code>? I guess it is specialized to Lean enough to make this a chore and not a good idea.</p>",
        "id": 406856241,
        "sender_full_name": "ohhaimark",
        "timestamp": 1702079022
    },
    {
        "content": "<p>You could use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Parser.runParserCategory#doc\">docs#Lean.Parser.runParserCategory</a> for a parser category that you define, or here's some code for running a parser for a named <code>syntax</code>: <a href=\"https://github.com/nomeata/loogle/blob/master/Loogle.lean#L18\">https://github.com/nomeata/loogle/blob/master/Loogle.lean#L18</a></p>",
        "id": 406875432,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702090105
    },
    {
        "content": "<p>For sorting, I converted to an Array (<code>.toArray.qsort</code>). I suspect it's the fastest way, since it can mutate in place.</p>",
        "id": 406884027,
        "sender_full_name": "Steve Dunham",
        "timestamp": 1702095677
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113488-general/topic/Advent.20of.20Code.3F/near/406875432\">said</a>:</p>\n<blockquote>\n<p>You could use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Parser.runParserCategory#doc\">docs#Lean.Parser.runParserCategory</a> for a parser category that you define</p>\n</blockquote>\n<p>Thanks, that looks very useful. Though I can't find how to create the Lean.Environment, do we need to setup a CoreM for that? Is there an example that demonstrates using <code>runParserCategory</code> from the main IO Unit?</p>",
        "id": 406929970,
        "sender_full_name": "tristanC",
        "timestamp": 1702124903
    },
    {
        "content": "<p>would anyone like to pair on advent? i live in the bay area and i just started aoc. i'm on part 1b (writing a parser combinator to handle it, or figuring out <code>Lean.Data.Parsec</code>). i'm familiar with functional programming.</p>",
        "id": 407021247,
        "sender_full_name": "Alok Singh (S1'17)",
        "timestamp": 1702192807
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"337670\">Alok Singh (S1'17)</span> <a href=\"#narrow/stream/113488-general/topic/Advent.20of.20Code.3F/near/407021247\">said</a>:</p>\n<blockquote>\n<p>would anyone like to pair on advent? i live in the bay area and i just started aoc. i'm on part 1b (writing a parser combinator to handle it, or figuring out <code>Lean.Data.Parsec</code>). i'm familiar with functional programming.</p>\n</blockquote>\n<p><a href=\"https://github.com/leanprover-community/lean4-samples/blob/main/CSVParser/README.md\">https://github.com/leanprover-community/lean4-samples/blob/main/CSVParser/README.md</a></p>\n<p>I was also thinking the same and I saw this one is archived but maybe can help in understanding Parsec.</p>",
        "id": 407080661,
        "sender_full_name": "Shubham Kumar 🦀 (he/him)",
        "timestamp": 1702223654
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"480750\">Steve Dunham</span> <a href=\"#narrow/stream/113488-general/topic/Advent.20of.20Code.3F/near/406884027\">said</a>:</p>\n<blockquote>\n<p>For sorting, I converted to an Array (<code>.toArray.qsort</code>). I suspect it's the fastest way, since it can mutate in place.</p>\n</blockquote>\n<p>I did the same didn't know how to add Mathlib to the project, maybe need to have a look at FPIL</p>",
        "id": 407081729,
        "sender_full_name": "Shubham Kumar 🦀 (he/him)",
        "timestamp": 1702224121
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"244748\">ohhaimark</span> <a href=\"#narrow/stream/113488-general/topic/Advent.20of.20Code.3F/near/406856241\">said</a>:</p>\n<blockquote>\n<p>Doing AoC and find myself wanting to use Lean's builtin parser, perhaps naively. Is there an easy interface to it along the lines of <code>parse : Parser -&gt; String -&gt; Option Syntax</code>? I guess it is specialized to Lean enough to make this a chore and not a good idea.</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"672257\">tristanC</span> <a href=\"#narrow/stream/113488-general/topic/Advent.20of.20Code.3F/near/406929970\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113488-general/topic/Advent.20of.20Code.3F/near/406875432\">said</a>:</p>\n<blockquote>\n<p>You could use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Parser.runParserCategory#doc\">docs#Lean.Parser.runParserCategory</a> for a parser category that you define</p>\n</blockquote>\n<p>Thanks, that looks very useful. Though I can't find how to create the Lean.Environment, do we need to setup a CoreM for that? Is there an example that demonstrates using <code>runParserCategory</code> from the main IO Unit?</p>\n</blockquote>\n<p>The <a href=\"https://github.com/tydeu/lean4-partax\">Partax</a> library provides an interface for converting Lean syntax / parsers into simpler functions that can be easily run without a full<code> Lean.Enviroment</code>. (Sorry for the shameless self-plug!)</p>",
        "id": 407106616,
        "sender_full_name": "Mac Malone",
        "timestamp": 1702241340
    },
    {
        "content": "<p>That also avoids what Loogle needs to do, which is to embed Lean (using <code>supportInterpreter := true</code> in the lakefile) and then set up CoreM by importing modules: <a href=\"https://github.com/nomeata/loogle/blob/master/Loogle.lean#L142\">https://github.com/nomeata/loogle/blob/master/Loogle.lean#L142</a></p>\n<p>If you're not attached to doing <code>runParserCategory</code> from the command line, then you can use <code>#eval</code>, which can run <code>CoreM</code> using the current environment at that point.</p>",
        "id": 407106850,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702241623
    },
    {
        "content": "<p>Today's part 2 was mathematically interesting, though yesterday task was a classic.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>It involves finding the area of the interior of a closed loop in the plane. The curve is made of segments between integer coordinates, and to figure out which cells are in the interior you can use Z/2Z intersection numbers between the curve and a ray that goes to infinity -- the count is 1 iff it's an interior cell.</p>\n<p>My solution: <a href=\"https://github.com/kmill/kmill-aoc2023/blob/main/AoC2023/Day10/Part2.lean\">https://github.com/kmill/kmill-aoc2023/blob/main/AoC2023/Day10/Part2.lean</a></p>\n<p>I'm curious what other approaches anyone took with this part.</p>\n</div></div>",
        "id": 407124997,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702256245
    },
    {
        "content": "<p>I just went with the first thing that popped into my head, namely:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>\"Puffing\" up the grid by adding a filler character so that a DFS search on the inside of the curve can get between the pipes. Also I didn't even bother figuring out where the inside was; I just started four searches at the NW, NE, SW and SE corners of the starting position. Definitely not a clean as your solution! :-)</p>\n</div></div>",
        "id": 407135682,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1702261449
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"311453\">@Frédéric Dupuis</span> I like that idea to manipulate the data. It makes it conceptually clear what's being calculated. Mine takes an arbitrary choice (a direction) which is a bit inelegant.</p>",
        "id": 407148647,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702265640
    },
    {
        "content": "<p>I also spent an embarrassing amount of time playing with this sort of pattern for verification, which looked quite promising:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">PropWrapper</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">pf</span> <span class=\"o\">:</span> <span class=\"n\">p</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">checkThat</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">a</span><span class=\"o\">)]</span> <span class=\"o\">:</span>\n    <span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">PropWrapper</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">x</span> <span class=\"k\">then</span> <span class=\"n\">some</span> <span class=\"o\">⟨</span><span class=\"n\">h</span><span class=\"o\">⟩</span>\n  <span class=\"k\">else</span> <span class=\"n\">none</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Array.checkThatAll</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">a</span><span class=\"o\">)]</span> <span class=\"o\">:</span>\n    <span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">PropWrapper</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">xs.size</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"n\">xs</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]))</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">xs.all</span> <span class=\"n\">p</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">false</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span>\n  <span class=\"bp\">|</span> <span class=\"n\">true</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">have</span> <span class=\"n\">hmain</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">xs.size</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"n\">xs</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n        <span class=\"k\">have</span> <span class=\"n\">htmp</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">xs.all_eq_true</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">h</span>\n        <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">decide_eq_true_iff</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">htmp</span>\n      <span class=\"n\">some</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"n\">hi</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">hmain</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"o\">⟩⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">toyExample</span> <span class=\"o\">(</span><span class=\"n\">input</span> <span class=\"o\">:</span> <span class=\"n\">FilePath</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">data</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">IO.FS.lines</span> <span class=\"n\">input</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">String.toCharArray</span>\n  <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"o\">⟨</span><span class=\"n\">hdata</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">checkThat</span> <span class=\"n\">data</span> <span class=\"k\">fun</span> <span class=\"n\">as</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">as.size</span> <span class=\"bp\">|</span> <span class=\"n\">panic</span><span class=\"bp\">!</span> <span class=\"s2\">\"no input\"</span>\n  <span class=\"c1\">-- here I have `hdata : 0 &lt; as.size` in context</span>\n  <span class=\"k\">let</span> <span class=\"n\">firstrow</span> <span class=\"o\">:=</span> <span class=\"n\">data</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span>   <span class=\"c1\">-- which lets me access the first element without using `data[0]!`</span>\n  <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"o\">⟨</span><span class=\"n\">hdata'</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span>\n    <span class=\"n\">data.checkThatAll</span> <span class=\"k\">fun</span> <span class=\"n\">as</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">as.size</span> <span class=\"bp\">=</span> <span class=\"n\">data</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">size</span> <span class=\"bp\">|</span> <span class=\"n\">panic</span><span class=\"bp\">!</span> <span class=\"s2\">\"Rows not all the same size!\"</span>\n  <span class=\"c1\">-- here I have `hdata' : ∀ i &lt; data.size, data[i].size = data[0].size` in context</span>\n</code></pre></div>",
        "id": 407153296,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1702267485
    },
    {
        "content": "<p>It seems like a clean way to get proofs of facts we want asserted, and that we can then use later in the code to e.g. check array bounds.</p>",
        "id": 407153510,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1702267555
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PLift#doc\">docs#PLift</a> is the core Lean structure for <code>PropWrapper</code> btw. That pattern seems to be similar to <a href=\"#narrow/stream/113489-new-members/topic/.E2.9C.94.20How.20to.20keep.20hypothesis.20in.20do.20block.20as.20we.20do.20in.20match.20term/near/404990675\">this one</a>, which came up when someone was asking about this recently.</p>",
        "id": 407161420,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702271671
    },
    {
        "content": "<p>Thanks! I figured something like this had to exist...</p>",
        "id": 407163060,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1702272810
    },
    {
        "content": "<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>spoiler</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>I simply assigned a \"counterclockwise rotation of the next step along the path\", then moved along each row until I hit the path and depending on where the outward normal was pointing, I decided if it was inside or not.</p>\n<p>My very messy code is <a href=\"https://github.com/adomani/advents/blob/master/Advents/day10.lean\">https://github.com/adomani/advents/blob/master/Advents/day10.lean</a></p>\n</div></div>",
        "id": 407178840,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1702279390
    },
    {
        "content": "<p>Getting a stack overflow but no stack trace. I'm running a built executable through <code>lake exe</code>, so I'm not sure if running it interpreted would get a stack trace. Is there a debug flag I can set for executable targets or an easy way to run a lake exe on the interpreter with stack traces?</p>\n<p>Getting used to strict evaluation and having foldr be a no no.<br>\nEDIT: tried <code>buildType := BuildType.debug</code>, still no stack trace</p>",
        "id": 407288548,
        "sender_full_name": "ohhaimark",
        "timestamp": 1702316029
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"244748\">@ohhaimark</span> does your binary coredump? If so you can easily get a stacktrace from that using any reasonably good C debugger.</p>",
        "id": 407290905,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1702316788
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/113488-general/topic/Advent.20of.20Code.3F/near/407290905\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"244748\">ohhaimark</span> does your binary coredump? If so you can easily get a stacktrace from that using any reasonably good C debugger.</p>\n</blockquote>\n<p>Ah, running it through <code>lean exe</code> didn't print that it core dumped, but running the binary directly did.</p>\n<p>Now to remember the systemd incantation to find it.</p>",
        "id": 407291008,
        "sender_full_name": "ohhaimark",
        "timestamp": 1702316846
    },
    {
        "content": "<p><code>coredumpctl debug</code> if you have a somewhat recent distro <span class=\"user-mention\" data-user-id=\"244748\">@ohhaimark</span></p>",
        "id": 407292083,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1702317302
    },
    {
        "content": "<p>Ah, it seems the foldl in the parser library I'm using (<a href=\"https://github.com/fgdorais/lean4-parser\">https://github.com/fgdorais/lean4-parser</a>) isn't tail recursive.</p>",
        "id": 407292140,
        "sender_full_name": "ohhaimark",
        "timestamp": 1702317329
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> </p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>Nice, so it seems like you did something like the winding number algorithm and I did something like the even-odd algorithm: <a href=\"https://en.wikipedia.org/wiki/Point_in_polygon\">https://en.wikipedia.org/wiki/Point_in_polygon</a></p>\n</div></div>",
        "id": 407292953,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702317645
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">specialize</span> <span class=\"n\">f</span><span class=\"kd\">]</span>\n<span class=\"kn\">private</span> <span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">foldAux</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ParserT</span> <span class=\"n\">ε</span> <span class=\"n\">σ</span> <span class=\"n\">α</span> <span class=\"n\">m</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ParserT</span> <span class=\"n\">ε</span> <span class=\"n\">σ</span> <span class=\"n\">α</span> <span class=\"n\">m</span> <span class=\"n\">γ</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">rec</span> <span class=\"n\">rest</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ParserT</span> <span class=\"n\">ε</span> <span class=\"n\">σ</span> <span class=\"n\">α</span> <span class=\"n\">m</span> <span class=\"n\">γ</span> <span class=\"o\">:=</span>\n    <span class=\"n\">try</span>\n      <span class=\"k\">let</span> <span class=\"n\">x</span> <span class=\"bp\">←</span> <span class=\"n\">withBacktracking</span> <span class=\"n\">p</span>\n      <span class=\"n\">rest</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">y</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n    <span class=\"n\">catch</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"n\">y</span>\n  <span class=\"n\">rest</span> <span class=\"n\">y</span>\n</code></pre></div>\n<p>Or maybe it's specialized to my <code>f</code> that is screwing things, but that doesn't explain the repeated <code>foldAux</code> in the backtrace.</p>",
        "id": 407292992,
        "sender_full_name": "ohhaimark",
        "timestamp": 1702317656
    },
    {
        "content": "<p>I guess the try-catch could muddy the waters, haven't thought too deeply about how that translates. Or just the parser monad in general. I use the <code>SimpleParserT</code> with <code>StateT ... ExceptT ... Id</code>, so maybe in <code>SimpleParser</code> it is tail recursive.</p>",
        "id": 407293520,
        "sender_full_name": "ohhaimark",
        "timestamp": 1702317818
    },
    {
        "content": "<p>Using parser combinators at the stage I'm on (Day 3) is overkill anyway, but now I stubbornly want to get this to work. This is why I never get anything done.</p>",
        "id": 407294748,
        "sender_full_name": "ohhaimark",
        "timestamp": 1702318259
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> </p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>spoiler</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>Indeed!  I hadn't seen the wikipedia page that you linked, my first thought was counting parity of intersections, but got stuck trying to convince myself how to deal efficiently with a ray sharing several steps with the path (i.e. non-transverse intersections).  I convinced myself more quickly that the first hitting points was enough and I coded that.  I was definitely thinking of winding numbers!</p>\n</div></div>",
        "id": 407296018,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1702318802
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span></p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>I was used to dealing with transversality problems because of some algorithms in low-dimensional topology, so I jumped at that. The trick here is that the loop has tangent vectors that lie only in cardinal directions, so you can displace the loop by an epsilon amount in a non-cardinal direction. There's some ascii art in my solution as I worked out the combinatorics from there.</p>\n</div></div>",
        "id": 407296593,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702319055
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> </p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>spoiler</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>Ah, good point!  I eventually convinced that it worked as well, by carrying around the two vectors until the first time that the path changes direction.  But that is mostly because I was walking around the path in the first place!</p>\n</div></div>",
        "id": 407296920,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1702319195
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"244748\">@ohhaimark</span> Your <code>foldAux</code> is not tail-recursive, it calls <code>rest</code> inside a <code>tryCatch</code> which means it builds up a stack of <code>tryCatch</code>es</p>",
        "id": 407397293,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1702362351
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Advent.20of.20Code.3F/near/407397293\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"244748\">ohhaimark</span> Your <code>foldAux</code> is not tail-recursive, it calls <code>rest</code> inside a <code>tryCatch</code> which means it builds up a stack of <code>tryCatch</code>es</p>\n</blockquote>\n<p>It's the library's. I've filed an issue <a href=\"https://github.com/fgdorais/lean4-parser/issues/5\">https://github.com/fgdorais/lean4-parser/issues/5</a>.</p>\n<p>From the issue:<br>\nIn the process of trying to come up with a minimal example for, I caused an internal panic instead <span aria-label=\"sob\" class=\"emoji emoji-1f62d\" role=\"img\" title=\"sob\">:sob:</span>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Parser</span>\n<span class=\"kn\">import</span> <span class=\"n\">Parser.Char</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Parser</span> <span class=\"n\">Parser.Char</span> <span class=\"n\">Std</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"n\">SimpleParser</span> <span class=\"n\">Substring</span> <span class=\"n\">Char</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">test</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">Parser.run</span> <span class=\"o\">(</span><span class=\"n\">Parser.foldl</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">())</span> <span class=\"o\">(</span><span class=\"n\">pure</span> <span class=\"o\">())</span> <span class=\"o\">(</span><span class=\"n\">pure</span> <span class=\"o\">())</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">Unit</span><span class=\"o\">)</span> <span class=\"s2\">\"\"</span>\n  <span class=\"k\">match</span> <span class=\"n\">x</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">ok</span> <span class=\"n\">_</span> <span class=\"n\">res</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"n\">res</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">error</span> <span class=\"n\">err</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">IO.println</span> <span class=\"n\">err</span>\n<span class=\"kd\">def</span> <span class=\"n\">main</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"n\">test</span>\n</code></pre></div>\n<p>stdout/stderr</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">INTERNAL</span> <span class=\"n\">PANIC</span><span class=\"o\">:</span> <span class=\"n\">unreachable</span> <span class=\"n\">code</span> <span class=\"n\">has</span> <span class=\"n\">been</span> <span class=\"n\">reached</span>\n</code></pre></div>\n<p>Where do I report upstream?</p>",
        "id": 407418492,
        "sender_full_name": "ohhaimark",
        "timestamp": 1702369155
    },
    {
        "content": "<p>looks like it's already fixed upstream</p>",
        "id": 407419762,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1702369622
    },
    {
        "content": "<p>Actually can you make a <code>lean4-parser</code>-free MWE for the <code>INTERNAL PANIC</code> issue?</p>",
        "id": 407419917,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1702369676
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Advent.20of.20Code.3F/near/407419762\">said</a>:</p>\n<blockquote>\n<p>looks like it's already fixed upstream</p>\n</blockquote>\n<p>I tried, but I don't know enough about the cause to understand how to repro without it.</p>",
        "id": 407421999,
        "sender_full_name": "ohhaimark",
        "timestamp": 1702370410
    },
    {
        "content": "<p>I mean can you just inline what you need and remove things as long as the problem persists</p>",
        "id": 407422582,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1702370643
    },
    {
        "content": "<p>You presumably only need the <code>Parser</code> type, <code>Parser.run</code> and <code>Parser.foldl</code> to make this (mis)compile</p>",
        "id": 407422739,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1702370690
    },
    {
        "content": "<p>you should pull up the Output panel so that you can see when the panic occurs, since only the first panic in a session gets a popup</p>",
        "id": 407422938,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1702370758
    },
    {
        "content": "<p>I'm livestreaming day 2 at <a href=\"https://www.youtube.com/watch?v=IgeXFbOG_Nc\">https://www.youtube.com/watch?v=IgeXFbOG_Nc</a></p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"IgeXFbOG_Nc\" href=\"https://www.youtube.com/watch?v=IgeXFbOG_Nc\"><img src=\"https://uploads.zulipusercontent.net/cac9ee2128d63b6ddd67ca9c11c137ce0f67eff9/68747470733a2f2f692e7974696d672e636f6d2f76692f4967655846624f475f4e632f64656661756c742e6a7067\"></a></div>",
        "id": 407548325,
        "sender_full_name": "Alok Singh (S1'17)",
        "timestamp": 1702408973
    },
    {
        "content": "<p>For day 10 part 2, </p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>I vaguely remembered the even-odd thing and came up with scanning each row  toggling inside/outside for vertical lines (and using the flag for above/below on a horizontal line segment).</p>\n<p><a href=\"https://github.com/dunhamsteve/aoc2023/blob/main/day10/day10.lean\">https://github.com/dunhamsteve/aoc2023/blob/main/day10/day10.lean</a></p>\n</div></div>",
        "id": 407638737,
        "sender_full_name": "Steve Dunham",
        "timestamp": 1702443699
    },
    {
        "content": "<p>To show totality in day12, I needed to tell lean that <code>List.drop</code> returned something the same or smaller than its argument. I ended up coming up with this, but I'm somewhat new to proofs in Lean 4. Is there a better way to do this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">drop_le</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">cs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Char</span><span class=\"o\">)</span> <span class=\"o\">:</span>  <span class=\"n\">sizeOf</span> <span class=\"o\">(</span><span class=\"n\">cs.drop</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">&lt;=</span> <span class=\"n\">sizeOf</span> <span class=\"n\">cs</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">revert</span> <span class=\"n\">cs</span>\n  <span class=\"n\">induction</span> <span class=\"n\">r</span>\n  <span class=\"n\">intro</span> <span class=\"n\">cs</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Nat.le_of_eq</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n  <span class=\"n\">intro</span> <span class=\"n\">cs</span>\n  <span class=\"n\">cases</span> <span class=\"n\">cs</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Nat.le_of_eq</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n  <span class=\"n\">rename_i</span> <span class=\"n\">n</span> <span class=\"n\">ih</span> <span class=\"n\">head</span> <span class=\"n\">tail</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Nat.le_trans</span> <span class=\"o\">(</span><span class=\"n\">ih</span> <span class=\"n\">tail</span><span class=\"o\">)</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Nat.le_add_left</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Full code, but spoilers, at <a href=\"https://github.com/dunhamsteve/aoc2023/blob/main/day12/day12.lean\">https://github.com/dunhamsteve/aoc2023/blob/main/day12/day12.lean</a></p>",
        "id": 407639288,
        "sender_full_name": "Steve Dunham",
        "timestamp": 1702444052
    },
    {
        "content": "<p>Working from phone:<br>\n<a href=\"/user_uploads/3121/-RNWiK6m2e4kXz6uVYvdfUTn/IMG_4478.PNG\">IMG_4478.PNG</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/-RNWiK6m2e4kXz6uVYvdfUTn/IMG_4478.PNG\" title=\"IMG_4478.PNG\"><img src=\"/user_uploads/3121/-RNWiK6m2e4kXz6uVYvdfUTn/IMG_4478.PNG\"></a></div>",
        "id": 407821866,
        "sender_full_name": "Steve Dunham",
        "timestamp": 1702506700
    },
    {
        "content": "<p>Is there a library function for parsing a hex string to a <code>Nat</code>? Thanks! (I figure it's straightforward but just wonder if the library already has it)</p>",
        "id": 408536446,
        "sender_full_name": "Phil Nguyen",
        "timestamp": 1702879800
    },
    {
        "content": "<p>Day 19 was pretty fun. What <a href=\"https://github.com/philnguyen/aoc/blob/main/2023/P19.lean\">I did</a> was writing a monadic interpreter for the language, then by swapping out the monad, we obtain the standard semantics for q1, and symbolic execution for q2. I found out Lean doesn't really have something like <code>ListT</code> in Haskell (probably because it's not practical in an eager language?). Also I think I need to learn more about Parsec to write less verbose parsers...</p>",
        "id": 409064431,
        "sender_full_name": "Phil Nguyen",
        "timestamp": 1703038673
    }
]