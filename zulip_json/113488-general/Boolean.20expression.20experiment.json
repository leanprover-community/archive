[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"545566\">@Brandon Sisler</span> shared this Lean file with me as the foremost Lean expert on faculty at his institution. Which ain't saying much, so I thought moving the conversation here would be more productive in general. <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- Hello Dr.Clontz! I was reading up on how the some of the simplifying tactics work in Lean4 and found that it was remarably insightful into teaching students how to reduce logical statements. So I thought that I would write this up and send it along.</span>\n<span class=\"c1\">-- Document Start:</span>\n<span class=\"c1\">-- To begin we need to be specific about what a logical statement is. One thing it is not for instance is \"I think therefore I am.\" I am just a computer and I do not understand how you want me to parse such a thing. Perhaps \"IThink therefore IAM\" is a little better, and even best would probably be \"IThink ⇒ IAM.\" So the lesson is clear. A logical statment should have implications, on each end should be some variable (prop.) and there are some special variables which we will call True and False, each with their own unique features.</span>\n\n<span class=\"c1\">-- So let us say that a Boolean Expresion consists of</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">BoolExpr</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">var</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"c1\">-- variables, which have names (atomic statments)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">val</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"c1\">-- special variables, T or F</span>\n  <span class=\"bp\">|</span> <span class=\"n\">implication</span>  <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">BoolExpr</span><span class=\"o\">)</span> <span class=\"c1\">-- an implication of other Boolean Expressions</span>\n  <span class=\"bp\">|</span> <span class=\"n\">not</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">BoolExpr</span><span class=\"o\">)</span> <span class=\"c1\">-- the negation of a Boolean Expression</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Repr</span><span class=\"o\">,</span> <span class=\"n\">BEq</span><span class=\"o\">,</span> <span class=\"n\">DecidableEq</span>\n\n<span class=\"c1\">-- Okay great, so now we should discuss how these things aught to actually work. We have a few cases.</span>\n\n<span class=\"c1\">-- ⬝ T ⇒ T should be True</span>\n<span class=\"c1\">-- ⬝ T ⇒ F should be False</span>\n<span class=\"c1\">-- ⬝ F ⇒ T should be True</span>\n<span class=\"c1\">-- ⬝ F ⇒ F should be True</span>\n<span class=\"c1\">-- ⬝ P ⇒ T should be True</span>\n<span class=\"c1\">-- ⬝ P ⇒ F should be equivalent to ~ P</span>\n<span class=\"c1\">-- ⬝ T ⇒ P should be equivalent to P</span>\n<span class=\"c1\">-- and ~ should work in the typical way of flipping true to falses and falses to trues.</span>\n\n<span class=\"c1\">-- Lets do an example by hand (ugh.)</span>\n<span class=\"c1\">-- ~((T ⇒ (P ⇒ T)) ⇒ F)</span>\n<span class=\"c1\">-- To begin I look at the not, but there is really nothing I can do about it, and I wish to simplify what is inside first. Therefore, next I look at the first implication. I see that the implication ends in a false, which means that only the truth of the predicate matters (and its negation, see our chart).</span>\n  <span class=\"c1\">-- ⇒ ~ ~ (T ⇒ (P ⇒ T))</span>\n<span class=\"c1\">-- Now again I look at the interior again and we notice that the implication begins with true, so the truth value depends solely on the consequence.</span>\n  <span class=\"c1\">-- ⇒ ~ ~ (P ⇒ T)</span>\n<span class=\"c1\">-- Similairly here, we can recodnize that we only need care about the consequence.</span>\n  <span class=\"c1\">-- ⇒ ~ ~ T</span>\n<span class=\"c1\">-- At this point there is no longer anything to simplify for implications, so we look at the nots.</span>\n  <span class=\"c1\">-- ⇒ ~ F</span>\n<span class=\"c1\">-- and again,</span>\n  <span class=\"c1\">-- ⇒ T</span>\n<span class=\"c1\">--  et voila</span>\n\n<span class=\"c1\">-- Well that was exhasting, lets spend a few hours writing a simplifier so that we never have to do five minutes of work again.</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">simplify</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">BoolExpr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">BoolExpr</span> <span class=\"o\">:=</span>\n<span class=\"k\">match</span> <span class=\"n\">P</span> <span class=\"k\">with</span> <span class=\"c1\">-- Let P be some Boolean Expression, which implies it is of one such form.</span>\n  <span class=\"bp\">|</span> <span class=\"n\">BoolExpr.not</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">mkNot</span> <span class=\"o\">(</span><span class=\"n\">simplify</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"c1\">-- If we have ~ (T ⇒ T)  then we wish to write ~ T. That is we wish to simplify what is bracketed and then take the negation.</span>\n  <span class=\"bp\">|</span> <span class=\"n\">BoolExpr.implication</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">mkIm</span> <span class=\"o\">(</span><span class=\"n\">simplify</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">simplify</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"c1\">-- similairly we simplify the subimplications before the main implication.</span>\n  <span class=\"bp\">|</span> <span class=\"n\">e</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">e</span> <span class=\"c1\">--everything else we just return as is</span>\n<span class=\"n\">where</span>\n  <span class=\"n\">mkNot</span> <span class=\"o\">:</span> <span class=\"n\">BoolExpr</span> <span class=\"bp\">→</span> <span class=\"n\">BoolExpr</span> <span class=\"c1\">--negates booleans</span>\n    <span class=\"bp\">|</span><span class=\"n\">BoolExpr.val</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">BoolExpr.val</span> <span class=\"o\">(</span><span class=\"bp\">¬</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span><span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">BoolExpr.not</span> <span class=\"n\">p</span>\n  <span class=\"n\">mkIm</span> <span class=\"o\">:</span> <span class=\"n\">BoolExpr</span> <span class=\"bp\">→</span> <span class=\"n\">BoolExpr</span> <span class=\"bp\">→</span> <span class=\"n\">BoolExpr</span> <span class=\"c1\">--simplifies implications with T or F in them.</span>\n    <span class=\"bp\">|</span> <span class=\"n\">BoolExpr.val</span> <span class=\"n\">true</span><span class=\"o\">,</span> <span class=\"n\">q</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">q</span>\n    <span class=\"bp\">|</span> <span class=\"n\">BoolExpr.val</span> <span class=\"n\">false</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">BoolExpr.val</span> <span class=\"n\">True</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">BoolExpr.val</span> <span class=\"n\">true</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">BoolExpr.val</span> <span class=\"n\">true</span>\n    <span class=\"bp\">|</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">BoolExpr.val</span> <span class=\"n\">false</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">BoolExpr.not</span> <span class=\"n\">p</span>\n    <span class=\"bp\">|</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">BoolExpr.implication</span> <span class=\"n\">p</span> <span class=\"n\">q</span>\n\n<span class=\"c1\">-- There is one issue we still have, which is that it is difficult to write even simple statements. As an example,</span>\n<span class=\"c1\">-- T ⇒ T → BoolExpr.implication (BoolExpr.val true) (BoolExper.val true)</span>\n<span class=\"c1\">-- is expressed like this, which is already unmanagable. So we should start to define notation to make our lives easier.</span>\n\n<span class=\"c1\">-- Here we just define the notation so it is natural and protect some common variable names.</span>\n<span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"mi\">65</span> <span class=\"n\">lhs</span><span class=\"o\">:</span><span class=\"mi\">65</span> <span class=\"s2\">\" ⇒ \"</span> <span class=\"n\">rhs</span><span class=\"o\">:</span><span class=\"mi\">66</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">BoolExpr.implication</span> <span class=\"n\">lhs</span> <span class=\"n\">rhs</span>\n<span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"mi\">67</span> <span class=\"s2\">\" ~ \"</span> <span class=\"n\">rhs</span><span class=\"o\">:</span><span class=\"mi\">40</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">BoolExpr.not</span> <span class=\"n\">rhs</span>\n<span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"n\">max</span> <span class=\"s2\">\"T\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">BoolExpr.val</span> <span class=\"n\">true</span>\n<span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"n\">max</span> <span class=\"s2\">\"F\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">BoolExpr.val</span> <span class=\"n\">false</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">atom</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">BoolExpr</span> <span class=\"o\">:=</span> <span class=\"n\">BoolExpr.var</span> <span class=\"n\">P</span> <span class=\"c1\">--Lets you define your own atomic formulas.</span>\n<span class=\"c1\">-- Define an atomic proposition</span>\n<span class=\"kd\">def</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"n\">BoolExpr.var</span> <span class=\"s2\">\"P\"</span>\n<span class=\"kd\">def</span> <span class=\"n\">Q</span> <span class=\"o\">:=</span> <span class=\"n\">BoolExpr.var</span> <span class=\"s2\">\"Q\"</span>\n<span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"n\">max</span> <span class=\"s2\">\"prop \"</span> <span class=\"n\">P</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">BoolExpr.var</span> <span class=\"n\">P</span>\n\n<span class=\"c1\">-- And now, we can see our work in action.</span>\n<span class=\"k\">#reduce</span> <span class=\"n\">simplify</span> <span class=\"o\">(</span><span class=\"bp\">~</span> <span class=\"o\">((</span><span class=\"n\">T</span> <span class=\"bp\">⇒</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">⇒</span> <span class=\"n\">T</span><span class=\"o\">))</span> <span class=\"bp\">⇒</span> <span class=\"n\">F</span><span class=\"o\">))</span>\n\n<span class=\"k\">#reduce</span> <span class=\"n\">simplify</span> <span class=\"o\">(</span><span class=\"bp\">~</span><span class=\"o\">((</span><span class=\"n\">T</span> <span class=\"bp\">⇒</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"bp\">⇒</span> <span class=\"o\">(</span><span class=\"bp\">~</span><span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"bp\">⇒</span> <span class=\"n\">T</span><span class=\"o\">))))</span>\n\n<span class=\"c1\">-- And let us see where this tactic couls be improved. Consider</span>\n<span class=\"k\">#reduce</span> <span class=\"n\">simplify</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">⇒</span> <span class=\"n\">P</span><span class=\"o\">)</span>\n<span class=\"c1\">-- We know this is a tautology, and yet our tactic does not know how to handle it! This is a common encounter in tactic writing. After all, we can always add features that do more, but which slow our program down. We also note that we can only handle implications and nots at the moment. But we have no way to speak about ors, ands, ect!</span>\n</code></pre></div>",
        "id": 408490328,
        "sender_full_name": "Steven Clontz",
        "timestamp": 1702856854
    },
    {
        "content": "<p>I've been nerd-baited into trying to add <code>P⇒P</code> simplifications, but as a relative novice it's going slow</p>",
        "id": 408492184,
        "sender_full_name": "Steven Clontz",
        "timestamp": 1702858158
    },
    {
        "content": "<p>Note that you can just write</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"s2\">\"lean code\"</span>\n</code></pre></div>\n<p>and Zulip will add a link to the top right that opens the web editor. It might make sense to edit that into your first message so that people don't need to leave Zulp.</p>",
        "id": 408494125,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1702859088
    },
    {
        "content": "<p>Note that what you have written there is not a \"tactic\" in the usual lean sense of the word</p>",
        "id": 408494341,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1702859188
    },
    {
        "content": "<p>Thats true, but I wrote it for absolute beginners and I find the actual tactic notations to be just slightly harder to read than definitions. In my mind it \"acts like\" a tactic, and gives intuition into how you can automate irritating parts of proofs. On the other hand, perhaps it would be better for me to avoid using the word tactic, since I suppose the meaning is sort of protected.</p>",
        "id": 408494841,
        "sender_full_name": "Brandon Sisler",
        "timestamp": 1702859436
    },
    {
        "content": "<p>One crucial way in which it does not act like a tactic is that it does not produce a proof!</p>",
        "id": 408494905,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1702859473
    },
    {
        "content": "<p>Aha, thats a good point! Yes, I'm convinced the wording aught to be changed now</p>",
        "id": 408495061,
        "sender_full_name": "Brandon Sisler",
        "timestamp": 1702859536
    },
    {
        "content": "<p>(to elaborate on that: I can add <code>| BoolExpr.val false =&gt; BoolExpr.val true</code> and it clearly doesn't do what you want, but Lean won't protect you against it)</p>",
        "id": 408495115,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1702859567
    },
    {
        "content": "<p>To prove that <code>simplify</code> is correct, you could define <code>BoolExpr.eval vars : Bool</code>, and prove that <code>(simplify b).eval vars = b.eval vars</code></p>",
        "id": 408495313,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1702859662
    },
    {
        "content": "<blockquote>\n<p><code>⬝ F ⇒ P should be equivalent to ~ P</code></p>\n</blockquote>\n<p>This is not true classically, or in lean's logical framework; are you working in a weird logical system, or is this an error? It contradicts</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- ⬝ F ⇒ T should be True</span>\n<span class=\"c1\">-- ⬝ F ⇒ F should be True</span>\n</code></pre></div>",
        "id": 408495555,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1702859769
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"468051\">Steven Clontz</span> <a href=\"#narrow/stream/113488-general/topic/Boolean.20expression.20experiment/near/408492184\">said</a>:</p>\n<blockquote>\n<p>I've been nerd-baited into trying to add <code>P⇒P</code> simplifications, but as a relative novice it's going slow</p>\n</blockquote>\n<div class=\"codehilite\" data-code-language=\"Diff\"><pre><span></span><code><span class=\"gd\">-| p, q =&gt; BoolExpr.implication p q</span>\n<span class=\"gi\">+| p, q =&gt; if p = q then T else BoolExpr.implication p q</span>\n</code></pre></div>\n<p>is enough to do that</p>",
        "id": 408496032,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1702859956
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/Boolean.20expression.20experiment/near/408495555\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p><code>⬝ F ⇒ P should be equivalent to ~ P</code></p>\n</blockquote>\n<p>This is not true classically, or in lean's logical framework; are you working in a weird logical system, or is this an error?</p>\n</blockquote>\n<p>Just an error there, but to save face I'll say its a weird logical system. And I like the suggestion for the proof, it would be a nice addition.</p>",
        "id": 408496183,
        "sender_full_name": "Brandon Sisler",
        "timestamp": 1702860004
    },
    {
        "content": "<p>In your defence your implementation looks correct, and the comment was the only error</p>",
        "id": 408496326,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1702860061
    },
    {
        "content": "<p>Well there we have it, I have a marvelous bit of code but the margins of my text editor are simply too narrow for me to include correct information</p>",
        "id": 408496779,
        "sender_full_name": "Brandon Sisler",
        "timestamp": 1702860227
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/Boolean.20expression.20experiment/near/408496032\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"468051\">Steven Clontz</span> <a href=\"#narrow/stream/113488-general/topic/Boolean.20expression.20experiment/near/408492184\">said</a>:</p>\n<blockquote>\n<p>I've been nerd-baited into trying to add <code>P⇒P</code> simplifications, but as a relative novice it's going slow</p>\n</blockquote>\n<div class=\"codehilite\" data-code-language=\"Diff\"><pre><span></span><code><span class=\"gd\">-| p, q =&gt; BoolExpr.implication p q</span>\n<span class=\"gi\">+| p, q =&gt; if p = q then T else BoolExpr.implication p q</span>\n</code></pre></div>\n<p>is enough to do that</p>\n</blockquote>\n<p>Thanks - that's what I had in my head but I was obviously overthinking how it'd be expressed in Lean</p>",
        "id": 408497121,
        "sender_full_name": "Steven Clontz",
        "timestamp": 1702860346
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/Boolean.20expression.20experiment/near/408494125\">said</a>:</p>\n<blockquote>\n<p>Note that you can just write</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"s2\">\"lean code\"</span>\n</code></pre></div>\n<p>and Zulip will add a link to the top right that opens the web editor. It might make sense to edit that into your first message so that people don't need to leave Zulp.</p>\n</blockquote>\n<p>Took me a while to realize what you were saying here: in this Zulip every(?) code block has the feature to open the code in the web editor in one click, if you hover over it and click the external link icon. Neat.</p>",
        "id": 408497987,
        "sender_full_name": "Steven Clontz",
        "timestamp": 1702860619
    },
    {
        "content": "<p>Every code editor marked as <code>lean</code> (which is the default) gets this button. <code>lean3</code> blocks get a similar link.</p>",
        "id": 408498736,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1702860917
    },
    {
        "content": "<p>Anyway Brandon, who needs ANDs and ORs when you have NOTs and IMPLIESs? <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span> </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- or</span>\n<span class=\"k\">#reduce</span> <span class=\"n\">simplify</span> <span class=\"o\">((</span><span class=\"bp\">~</span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"bp\">⇒</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"c1\">-- T</span>\n<span class=\"k\">#reduce</span> <span class=\"n\">simplify</span> <span class=\"o\">((</span><span class=\"bp\">~</span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"bp\">⇒</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"c1\">-- T</span>\n<span class=\"k\">#reduce</span> <span class=\"n\">simplify</span> <span class=\"o\">((</span><span class=\"bp\">~</span><span class=\"n\">F</span><span class=\"o\">)</span><span class=\"bp\">⇒</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"c1\">-- T</span>\n<span class=\"k\">#reduce</span> <span class=\"n\">simplify</span> <span class=\"o\">((</span><span class=\"bp\">~</span><span class=\"n\">F</span><span class=\"o\">)</span><span class=\"bp\">⇒</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"c1\">-- F</span>\n<span class=\"c1\">-- and</span>\n<span class=\"k\">#reduce</span> <span class=\"n\">simplify</span> <span class=\"o\">(</span><span class=\"bp\">~</span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"bp\">⇒</span> <span class=\"bp\">~</span><span class=\"n\">T</span><span class=\"o\">))</span> <span class=\"c1\">-- T</span>\n<span class=\"k\">#reduce</span> <span class=\"n\">simplify</span> <span class=\"o\">(</span><span class=\"bp\">~</span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"bp\">⇒</span> <span class=\"bp\">~</span><span class=\"n\">F</span><span class=\"o\">))</span> <span class=\"c1\">-- F</span>\n<span class=\"k\">#reduce</span> <span class=\"n\">simplify</span> <span class=\"o\">(</span><span class=\"bp\">~</span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"bp\">⇒</span> <span class=\"bp\">~</span><span class=\"n\">T</span><span class=\"o\">))</span> <span class=\"c1\">-- F</span>\n<span class=\"k\">#reduce</span> <span class=\"n\">simplify</span> <span class=\"o\">(</span><span class=\"bp\">~</span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"bp\">⇒</span> <span class=\"bp\">~</span><span class=\"n\">F</span><span class=\"o\">))</span> <span class=\"c1\">-- F</span>\n</code></pre></div>",
        "id": 408500342,
        "sender_full_name": "Steven Clontz",
        "timestamp": 1702861569
    },
    {
        "content": "<p>We have logical operators at home!<br>\nThe logical operators at home:</p>\n<p><span class=\"user-mention silent\" data-user-id=\"468051\">Steven Clontz</span> <a href=\"#narrow/stream/113488-general/topic/Boolean.20expression.20experiment/near/408500342\">said</a>:</p>\n<blockquote>\n<p>Anyway Brandon, who needs ANDs and ORs when you have NOTs and IMPLIESs? <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span> </p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- or</span>\n<span class=\"k\">#reduce</span> <span class=\"n\">simplify</span> <span class=\"o\">((</span><span class=\"bp\">~</span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"bp\">⇒</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"c1\">-- T</span>\n<span class=\"k\">#reduce</span> <span class=\"n\">simplify</span> <span class=\"o\">((</span><span class=\"bp\">~</span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"bp\">⇒</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"c1\">-- T</span>\n<span class=\"k\">#reduce</span> <span class=\"n\">simplify</span> <span class=\"o\">((</span><span class=\"bp\">~</span><span class=\"n\">F</span><span class=\"o\">)</span><span class=\"bp\">⇒</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"c1\">-- T</span>\n<span class=\"k\">#reduce</span> <span class=\"n\">simplify</span> <span class=\"o\">((</span><span class=\"bp\">~</span><span class=\"n\">F</span><span class=\"o\">)</span><span class=\"bp\">⇒</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"c1\">-- F</span>\n<span class=\"c1\">-- and</span>\n<span class=\"k\">#reduce</span> <span class=\"n\">simplify</span> <span class=\"o\">(</span><span class=\"bp\">~</span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"bp\">⇒</span> <span class=\"bp\">~</span><span class=\"n\">T</span><span class=\"o\">))</span> <span class=\"c1\">-- T</span>\n<span class=\"k\">#reduce</span> <span class=\"n\">simplify</span> <span class=\"o\">(</span><span class=\"bp\">~</span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"bp\">⇒</span> <span class=\"bp\">~</span><span class=\"n\">F</span><span class=\"o\">))</span> <span class=\"c1\">-- F</span>\n<span class=\"k\">#reduce</span> <span class=\"n\">simplify</span> <span class=\"o\">(</span><span class=\"bp\">~</span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"bp\">⇒</span> <span class=\"bp\">~</span><span class=\"n\">T</span><span class=\"o\">))</span> <span class=\"c1\">-- F</span>\n<span class=\"k\">#reduce</span> <span class=\"n\">simplify</span> <span class=\"o\">(</span><span class=\"bp\">~</span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"bp\">⇒</span> <span class=\"bp\">~</span><span class=\"n\">F</span><span class=\"o\">))</span> <span class=\"c1\">-- F</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 408500851,
        "sender_full_name": "Brandon Sisler",
        "timestamp": 1702861878
    },
    {
        "content": "<p>Actually if you want them included you're in luck because that is going to be document two, where I add in not, and, or, and implication. Then you really get cooking with writing a super simplify.</p>",
        "id": 408501002,
        "sender_full_name": "Brandon Sisler",
        "timestamp": 1702861978
    },
    {
        "content": "<p>Heres an odd problem, I am not sure if it is possible to prove that simplify terminates (which I would actually need to prove what we discussed earlier, at least if I am doing things in a sensible way). After all if I have an expression <code>p ⇒ q</code> it will try and compute <code>mkIm (simplify p) (simplify q)</code> but what if <code>p</code> is an implication, and what if its components are implications. In principle I know that this is no issue because I must have entered a finite expression, and it is not turtles all the way down, so I do stop calling mkIm at some point. But the question is, does Lean realy know that, is it build into the inductive type somehow or is this really an instance in which we cannot prove the function terminates?</p>\n<p><strong><em>Disregard, got it</em></strong></p>",
        "id": 408521515,
        "sender_full_name": "Brandon Sisler",
        "timestamp": 1702871282
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"s2\">\"lean code\"</span>\n\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"c1\">-- import Lean</span>\n<span class=\"c1\">-- Hello Dr.Clontz! I was reading up on how the some of the simplifying tactics work in Lean4 and found that it was remarably insightful into teaching students how to reduce logical statements. So I thought that I would write this up and send it along.</span>\n<span class=\"c1\">-- Document Start:</span>\n<span class=\"c1\">-- To begin we need to be specific about what a logical statement is. One thing it is not for instance is \"I think therefore I am.\" I am just a computer and I do not understand how you want me to parse such a thing. Perhaps \"IThink therefore IAM\" is a little better, and even best would probably be \"IThink ⇒ IAM.\" So the lesson is clear. A logical statment should have implications, on each end should be some variable (prop.) and there are some special variables which we will call True and False, each with their own unique features.</span>\n\n<span class=\"c1\">-- So let us say that a Boolean Expresion consists of</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">BoolExpr</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">var</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"c1\">-- variables, which have names (atomic statments)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">val</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"c1\">-- special variables, T or F</span>\n  <span class=\"bp\">|</span> <span class=\"n\">implication</span>  <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">BoolExpr</span><span class=\"o\">)</span> <span class=\"c1\">-- an implication of other Boolean Expressions</span>\n  <span class=\"bp\">|</span> <span class=\"n\">not</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">BoolExpr</span><span class=\"o\">)</span> <span class=\"c1\">-- the negation of a Boolean Expression</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Repr</span><span class=\"o\">,</span> <span class=\"n\">BEq</span><span class=\"o\">,</span> <span class=\"n\">DecidableEq</span>\n\n<span class=\"c1\">-- Okay great, so now we should discuss how these things aught to actually work. We have a few cases.</span>\n\n<span class=\"c1\">-- ⬝ T ⇒ T should be True</span>\n<span class=\"c1\">-- ⬝ T ⇒ F should be False</span>\n<span class=\"c1\">-- ⬝ F ⇒ T should be True</span>\n<span class=\"c1\">-- ⬝ F ⇒ F should be True</span>\n<span class=\"c1\">-- ⬝ P ⇒ T should be True</span>\n<span class=\"c1\">-- ⬝ P ⇒ F should be equivalent to ~ P</span>\n<span class=\"c1\">-- ⬝ T ⇒ P should be equivalent to P</span>\n<span class=\"c1\">-- ⬝ F ⇒ P should be True</span>\n<span class=\"c1\">-- and ~ should work in the typical way of flipping true to falses and falses to trues.</span>\n<span class=\"c1\">-- Keep this list in mind, it is going to become our logics demands and will become the basis by which we know if an operation is legal on a boolean expression.</span>\n\n<span class=\"c1\">-- Lets do an example by hand (ugh.)</span>\n<span class=\"c1\">-- ~((T ⇒ (P ⇒ T)) ⇒ F)</span>\n<span class=\"c1\">-- To begin I look at the not, but there is really nothing I can do about it, and I wish to simplify what is inside first. Therefore, next I look at the first implication. I see that the implication ends in a false, which means that only the truth of the predicate matters (and its negation, see our chart).</span>\n  <span class=\"c1\">-- ⇒ ~ ~ (T ⇒ (P ⇒ T))</span>\n<span class=\"c1\">-- Now again I look at the interior again and we notice that the implication begins with true, so the truth value depends solely on the consequence.</span>\n  <span class=\"c1\">-- ⇒ ~ ~ (P ⇒ T)</span>\n<span class=\"c1\">-- Similairly here, we can recodnize that we only need care about the consequence.</span>\n  <span class=\"c1\">-- ⇒ ~ ~ T</span>\n<span class=\"c1\">-- At this point there is no longer anything to simplify for implications, so we look at the nots.</span>\n  <span class=\"c1\">-- ⇒ ~ F</span>\n<span class=\"c1\">-- and again,</span>\n  <span class=\"c1\">-- ⇒ T</span>\n<span class=\"c1\">--  et voila</span>\n\n<span class=\"c1\">-- Well that was exhasting, lets spend a few hours writing a simplifier so that we never have to do five minutes of work again.</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">simplify</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">BoolExpr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">BoolExpr</span> <span class=\"o\">:=</span>\n<span class=\"k\">match</span> <span class=\"n\">P</span> <span class=\"k\">with</span> <span class=\"c1\">-- Let P be some Boolean Expression, which implies it is of one such form.</span>\n  <span class=\"bp\">|</span> <span class=\"n\">BoolExpr.not</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">mkNot</span> <span class=\"o\">(</span><span class=\"n\">simplify</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"c1\">-- If we have ~ (T ⇒ T)  then we wish to write ~ T. That is we wish to simplify what is bracketed and then take the negation.</span>\n  <span class=\"bp\">|</span> <span class=\"n\">BoolExpr.implication</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">mkIm</span> <span class=\"o\">(</span><span class=\"n\">simplify</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">simplify</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"c1\">-- similairly we simplify the subimplications before the main implication.</span>\n  <span class=\"bp\">|</span> <span class=\"n\">e</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">e</span> <span class=\"c1\">--everything else we just return as is</span>\n<span class=\"n\">where</span>\n  <span class=\"n\">mkNot</span> <span class=\"o\">:</span> <span class=\"n\">BoolExpr</span> <span class=\"bp\">→</span> <span class=\"n\">BoolExpr</span> <span class=\"c1\">--negates booleans</span>\n    <span class=\"bp\">|</span> <span class=\"n\">BoolExpr.val</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">BoolExpr.val</span> <span class=\"o\">(</span><span class=\"bp\">¬</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">BoolExpr.not</span> <span class=\"n\">p</span>\n  <span class=\"n\">mkIm</span> <span class=\"o\">:</span> <span class=\"n\">BoolExpr</span> <span class=\"bp\">→</span> <span class=\"n\">BoolExpr</span> <span class=\"bp\">→</span> <span class=\"n\">BoolExpr</span> <span class=\"c1\">--simplifies implications with T or F in them.</span>\n    <span class=\"bp\">|</span> <span class=\"n\">BoolExpr.val</span> <span class=\"n\">true</span><span class=\"o\">,</span> <span class=\"n\">q</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">q</span>\n    <span class=\"bp\">|</span> <span class=\"n\">BoolExpr.val</span> <span class=\"n\">false</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">BoolExpr.val</span> <span class=\"n\">True</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">BoolExpr.val</span> <span class=\"n\">true</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">BoolExpr.val</span> <span class=\"n\">true</span>\n    <span class=\"bp\">|</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">BoolExpr.val</span> <span class=\"n\">false</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">BoolExpr.not</span> <span class=\"n\">p</span>\n    <span class=\"bp\">|</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">BoolExpr.implication</span> <span class=\"n\">p</span> <span class=\"n\">q</span>\n\n<span class=\"c1\">-- There is one issue we still have, which is that it is difficult to write even simple statements. As an example,</span>\n<span class=\"c1\">-- T ⇒ T → BoolExpr.implication (BoolExpr.val true) (BoolExper.val true)</span>\n<span class=\"c1\">-- is expressed like this, which is already unmanagable. So we should start to define notation to make our lives easier.</span>\n\n<span class=\"c1\">-- Here we just define the notation so it is natural and protect some common variable names.</span>\n<span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"mi\">65</span> <span class=\"n\">lhs</span><span class=\"o\">:</span><span class=\"mi\">65</span> <span class=\"s2\">\" ⇒ \"</span> <span class=\"n\">rhs</span><span class=\"o\">:</span><span class=\"mi\">66</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">BoolExpr.implication</span> <span class=\"n\">lhs</span> <span class=\"n\">rhs</span>\n<span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"mi\">67</span> <span class=\"s2\">\" ~ \"</span> <span class=\"n\">rhs</span><span class=\"o\">:</span><span class=\"mi\">40</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">BoolExpr.not</span> <span class=\"n\">rhs</span>\n<span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"n\">max</span> <span class=\"s2\">\"T\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">BoolExpr.val</span> <span class=\"n\">true</span>\n<span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"n\">max</span> <span class=\"s2\">\"F\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">BoolExpr.val</span> <span class=\"n\">false</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">atom</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">BoolExpr</span> <span class=\"o\">:=</span> <span class=\"n\">BoolExpr.var</span> <span class=\"n\">P</span> <span class=\"c1\">--Lets you define your own atomic formulas.</span>\n<span class=\"c1\">-- Define an atomic proposition</span>\n<span class=\"kd\">def</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"n\">BoolExpr.var</span> <span class=\"s2\">\"P\"</span>\n<span class=\"kd\">def</span> <span class=\"n\">Q</span> <span class=\"o\">:=</span> <span class=\"n\">BoolExpr.var</span> <span class=\"s2\">\"Q\"</span>\n<span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"n\">max</span> <span class=\"s2\">\"prop \"</span> <span class=\"n\">P</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">BoolExpr.var</span> <span class=\"n\">P</span>\n\n<span class=\"c1\">-- And now, we can see our work in action.</span>\n<span class=\"k\">#reduce</span> <span class=\"n\">simplify</span> <span class=\"o\">(</span><span class=\"bp\">~</span> <span class=\"o\">((</span><span class=\"n\">T</span> <span class=\"bp\">⇒</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">⇒</span> <span class=\"n\">T</span><span class=\"o\">))</span> <span class=\"bp\">⇒</span> <span class=\"n\">F</span><span class=\"o\">))</span>\n\n<span class=\"k\">#reduce</span> <span class=\"n\">simplify</span> <span class=\"o\">(</span><span class=\"bp\">~</span><span class=\"o\">((</span><span class=\"n\">T</span> <span class=\"bp\">⇒</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"bp\">⇒</span> <span class=\"o\">(</span><span class=\"bp\">~</span><span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"bp\">⇒</span> <span class=\"n\">T</span><span class=\"o\">))))</span>\n\n<span class=\"c1\">-- And let us see where this function could be improved. Consider</span>\n<span class=\"k\">#reduce</span> <span class=\"n\">simplify</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">⇒</span> <span class=\"n\">P</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- We know this is a tautology, and yet our simplifier does not know how to handle it! This is a common encounter in writing. After all, we can always add features that do more, but which slow our program down. We also note that we can only handle implications and nots at the moment. But we have no way to speak about ors, ands, ect!</span>\n\n<span class=\"c1\">-- In addition, as pointed out by Eric Weiser, there is not yet any garentee that this generates anything sensible. It is simply a function, and it would return anything that we asked, without caring about the logic at all. So lets do something about that by shamelessly stealing his idea for a proof.</span>\n\n<span class=\"c1\">-- Now we will define what we mean by a legal transformation, note that it is a redundant definition, and many of its demands are equivalent. We have not shortened it for educational purposes.</span>\n<span class=\"c1\">-- Here I'll write something about how the law of the excluded middle is useful and bite my tongue about how it sucks.</span>\n<span class=\"kd\">def</span> <span class=\"n\">excluded_middle</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">BoolExpr</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">F</span><span class=\"o\">)</span>\n<span class=\"c1\">-- Now, we have seen above that our simplifier takes a boolean expression, and spits out another boolean expression. We may well be worried however, that the expression we return has a different truth value to the one we put in. This would make our reduction commletely erroniuos (spell check), and our function totally useless (after all, we could write a one line simplifier which also does work, just always return true). Thus we now have the concept of, what we will call, a legal transformation. That is, a transformation (function) whose output is true/false iff the original input is true/false respectively.</span>\n<span class=\"kd\">def</span> <span class=\"n\">legal_transformation</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">BoolExpr</span> <span class=\"bp\">→</span> <span class=\"n\">BoolExpr</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">BoolExpr</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">T</span> <span class=\"bp\">↔</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">F</span> <span class=\"bp\">↔</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">F</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Now let us show that our simplifier is legal (assuming the LOM is valid).</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">simplify_is_legal</span> <span class=\"o\">(</span><span class=\"n\">EM</span><span class=\"o\">:</span> <span class=\"n\">excluded_middle</span><span class=\"o\">):</span> <span class=\"n\">legal_transformation</span> <span class=\"o\">(</span><span class=\"n\">simplify</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">b</span> <span class=\"c1\">-- Let b be a boolean expression</span>\n  <span class=\"n\">constructor</span> <span class=\"c1\">-- Let us break this into the forward and backwards direction</span>\n  <span class=\"n\">constructor</span> <span class=\"c1\">-- Let us break this into the forward and backwards direction</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span> <span class=\"c1\">-- suppose that simplify b = T, we wish to show that b = T</span>\n  <span class=\"k\">have</span> <span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"c1\">--Note that it is the case that either b = T or b = F</span>\n    <span class=\"n\">exact</span> <span class=\"n\">EM</span> <span class=\"n\">b</span> <span class=\"c1\">-- which we know due to the LOM.</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">H</span> <span class=\"k\">with</span> <span class=\"n\">h1</span> <span class=\"bp\">|</span> <span class=\"n\">h2</span> <span class=\"c1\">-- So let us break into the cases, the first in which b is true, and the second in which b is false</span>\n  <span class=\"n\">assumption</span> <span class=\"c1\">-- If it happens that b is true then we are done by assumption</span>\n  <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">h2</span><span class=\"o\">]</span> <span class=\"c1\">-- on the other hand if b is false then we may convert b = T into b = simplify b.</span>\n  <span class=\"n\">rfl</span> <span class=\"c1\">-- Which we know to be true vacuously, since b is false.</span>\n\n  <span class=\"n\">intro</span> <span class=\"n\">h</span> <span class=\"c1\">-- Now suppose that b = T</span>\n  <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n  <span class=\"n\">rfl</span> <span class=\"c1\">--Then we are done immediately</span>\n\n  <span class=\"n\">constructor</span> <span class=\"c1\">-- This part of the proof is entirely dual.</span>\n  <span class=\"n\">intro</span> <span class=\"n\">H</span>\n  <span class=\"k\">have</span> <span class=\"n\">Cases</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">exact</span> <span class=\"n\">EM</span> <span class=\"n\">b</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">Cases</span> <span class=\"k\">with</span> <span class=\"n\">h1</span> <span class=\"bp\">|</span> <span class=\"n\">h2</span>\n  <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">h1</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">H</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">simplify</span> <span class=\"n\">at</span> <span class=\"n\">H</span>\n  <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">h1</span><span class=\"o\">]</span>\n  <span class=\"n\">assumption</span>\n  <span class=\"n\">assumption</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span>\n  <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n  <span class=\"n\">rfl</span>\n<span class=\"c1\">--Thus simplify preserves truth values of the boolean expressions it is applied to.</span>\n</code></pre></div>\n<p>Here is round two (not spell checked nor checked suer carfully in any way, but its a nice start).</p>",
        "id": 409283882,
        "sender_full_name": "Brandon Sisler",
        "timestamp": 1703119232
    }
]