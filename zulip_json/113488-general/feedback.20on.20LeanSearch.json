[
    {
        "content": "<p>I've been having trouble with <a href=\"http://leansearch.net\">leansearch.net</a> recently --- and I'm getting suspicious that it <em>never</em> returns results from the standard library!</p>\n<p>e.g.</p>\n<p><a href=\"https://leansearch.net/?q=If%20two%20lists%20are%20permutations%20of%20each%20other%2C%20the%20counts%20of%20each%20term%20in%20those%20lists%20are%20equal\">https://leansearch.net/?q=If%20two%20lists%20are%20permutations%20of%20each%20other%2C%20the%20counts%20of%20each%20term%20in%20those%20lists%20are%20equal</a>.</p>\n<p>should surely show <code>List.perm_iff_count</code>, but everything it mentions is from Mathlib, nothing from the standard library!</p>\n<p><span class=\"user-mention\" data-user-id=\"611077\">@Jiang Jiedong</span>?</p>",
        "id": 511959011,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1744591572
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span>  Thank you for your feedback! The standard library isn't currently included in the database.</p>\n<p>I've been discussing this issue with the current maintainer <span class=\"user-mention\" data-user-id=\"652127\">@Tony Beta Lambda</span> of LeanSearch, as there are varying user needs:</p>\n<ul>\n<li>Some want Mathlib-only searches (more presicely, mathematical declarations only, excluding things like tactic parsers)</li>\n<li>Others want broader searches including metaprogramming and other libraries</li>\n</ul>\n<p>Our current consideration is to:</p>\n<ol>\n<li>Expand the database coverage (but a simple expansion may affect the searching quality)</li>\n<li>Add configurable toggles for showing different declaration groups in searching results (these declaration groups could be: metaprogramming-related, Batteries library, instances, etc.)</li>\n</ol>\n<p>We'd greatly appreciate any suggestions on:</p>\n<ul>\n<li>What toggles would be most useful</li>\n<li>Any alternative solutions beyond toggles</li>\n</ul>\n<p>Thanks for bringing this up!</p>",
        "id": 512131081,
        "sender_full_name": "Jiang Jiedong",
        "timestamp": 1744649953
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"480079\">@Evgenia Karunus</span> also discussed some related ideas with me.</p>",
        "id": 512132154,
        "sender_full_name": "Jiang Jiedong",
        "timestamp": 1744650241
    },
    {
        "content": "<p>If you want to exclude things like tactic parsers / metaprogramming, then probably dropping (or rather, filtering) things in the <code>Lean</code> namespace is a reasonable approximation. Dropping based on which folder things are in probably isn't a good heuristic.</p>",
        "id": 512132490,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1744650293
    },
    {
        "content": "<p>Yes, you <em>certainly</em> want to index and return everything from <code>Init.Data</code> and <code>Std.Data</code>!</p>",
        "id": 512187574,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1744671268
    },
    {
        "content": "<p>As a concrete example, for \"If n is less than or equal to m, then $n+1$ is less than or equal to $m+1$\" the result <code>Nat.succ_le_succ</code> does not show up and is the result I usually want. This is in the Lean core.</p>",
        "id": 512201451,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1744679491
    },
    {
        "content": "<p>(Well, you want <code>by omega</code>, but sure. :-)</p>",
        "id": 512201530,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1744679526
    },
    {
        "content": "<p>Well, _I_ as a user want Std and Batteries to be searched.</p>",
        "id": 512204197,
        "sender_full_name": "Alok Singh",
        "timestamp": 1744681128
    },
    {
        "content": "<p>LeanSearch is down.</p>",
        "id": 512238793,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1744699697
    },
    {
        "content": "<p>I think it's also safe to say that any <em>proposition</em> no matter where it comes from should be indexed.</p>",
        "id": 512362901,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1744733865
    },
    {
        "content": "<p>Really? What about the lemmas internal to eg <code>linarith</code>?</p>",
        "id": 512363086,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1744733919
    },
    {
        "content": "<p>It is apparent that everyone has different needs, so instead of deciding it for everyone, how about we discuss and find out what set of filter options should be available to the user?  Right now I can figure: packages to include, namespace, kind (tactic/prop/def).</p>",
        "id": 512732074,
        "sender_full_name": "Tony Beta Lambda",
        "timestamp": 1744862850
    },
    {
        "content": "<p>I don't think there's that much variation asked for above.</p>\n<p>Everyone wants everything that isn't internal to a tactic, or internal to Lean. (e.g. filter just by having <code>.Tactic.</code> in the namespace, or <code>Lean.</code>) </p>\n<p>No one wants \"auxiliary declarations\", e.g. things starting with <code>_</code>.</p>\n<p>I think just a single \"metaprogramming\" filter, and including the repositories upstream of Mathlib, would get most of the way.</p>",
        "id": 512732454,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1744863033
    },
    {
        "content": "<p>I'm PRing search over metaprogramming functions to LeanSearch, so thinking about what declarations should be in \"maths db\" vs what declarations should be in \"metaprogramming db\".</p>\n<p>I thought about sorting declarations in Lean and Mathlib into these 2 groups based on the presence of <code>Lean</code> namespace like <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> suggested, but e.g. <code>Mathlib.Util.isCompiled</code> (<a href=\"https://github.com/leanprover-community/mathlib4/blob/e97a31b68161195df93aa15e7f39809583d24e1c/Mathlib/Util/CompileInductive.lean#L78\">link</a>) is a nice function that wouldn't make it into the \"metaprogramming db\" by the Lean-namespace heuristic.</p>\n<p>The only other heuristic that comes to mind is the by-folder heuristic, meaning we'd get:</p>\n<h4>Maths db</h4>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">&lt;</span><span class=\"n\">path_to_mathlib</span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">EXCLUDE</span><span class=\"o\">:</span><span class=\"n\">Mathlib</span><span class=\"bp\">/</span><span class=\"n\">Lean</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">/</span><span class=\"n\">Util</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">MathlibTest</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">/</span><span class=\"n\">Tactic</span><span class=\"o\">]</span>\n<span class=\"bp\">&lt;</span><span class=\"n\">path_to_lean</span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Init</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Std</span>\n</code></pre></div>\n<h4>Metaprogramming db</h4>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">&lt;</span><span class=\"n\">path_to_mathlib</span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Cache</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">/</span><span class=\"n\">Lean</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">/</span><span class=\"n\">Tactic</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">/</span><span class=\"n\">Util</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">/</span><span class=\"n\">Control</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Shake</span><span class=\"bp\">/</span><span class=\"n\">Main</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">scripts</span>\n<span class=\"bp\">&lt;</span><span class=\"n\">path_to_lean</span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Init</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">lake</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">EXCLUDE</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">lake</span><span class=\"bp\">/</span><span class=\"n\">tests</span><span class=\"o\">]</span>\n</code></pre></div>\n<blockquote>\n<p>Note: from each of these modules, we want only <code>def</code>s for the programming db.</p>\n</blockquote>\n<hr>\n<p>Does that seem like a sensible heuristic/are there some other heuristics that come to mind?</p>",
        "id": 520216466,
        "sender_full_name": "Evgenia Karunus",
        "timestamp": 1748108306
    },
    {
        "content": "<p>One might just index everything and rely on semantic search to figure it out by the search query, but that will worsen relevance/signal-to-noise. On the other hand, if determining what's useful for metaprogramming VS what's useful for formalization is too unreliable, then indexing everything and leaving this separation to embeddings might still be a good solution.</p>",
        "id": 520216619,
        "sender_full_name": "Evgenia Karunus",
        "timestamp": 1748108433
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"480079\">Evgenia Karunus</span> <a href=\"#narrow/channel/113488-general/topic/feedback.20on.20LeanSearch/near/520216466\">said</a>:</p>\n<blockquote>\n<p>are there some other heuristics that come to mind?</p>\n</blockquote>\n<p>Nothing in the <code>Mathlib</code> namespace is mathematics, so maybe the heuristic should be \"Either <code>Lean</code> or <code>Mathlib</code> namespace\" (and maybe <code>Batteries</code> too)</p>",
        "id": 520217599,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1748109254
    },
    {
        "content": "<p>If we were only indexing declarations with <code>Mathlib</code> in their namespace for the \"metaprogramming db\", then we'd miss e.g. these:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">&lt;</span><span class=\"n\">path_to_mathlib</span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"n\">Cache</span>\n<span class=\"n\">Cache</span><span class=\"bp\">.</span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">ModuleHashMap</span><span class=\"bp\">.</span><span class=\"n\">filterExists</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hashMap</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ModuleHashMap</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">keep</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"w\"> </span><span class=\"n\">ModuleHashMap</span>\n<span class=\"bp\">&lt;</span><span class=\"n\">path_to_mathlib</span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"n\">Mathlib</span><span class=\"bp\">/</span><span class=\"n\">Control</span><span class=\"bp\">/</span><span class=\"n\">Monad</span><span class=\"bp\">/</span><span class=\"n\">Basic</span>\n<span class=\"n\">StateT</span><span class=\"bp\">.</span><span class=\"n\">eval</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Functor</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cmd</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">StateT</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">α</span>\n</code></pre></div>\n<p>Lean-Mathlib-namespace heuristic sounds useful to avoid including excessive definitions into \"maths db\" as an additional check on top of the by-folder heuristic.</p>",
        "id": 520221047,
        "sender_full_name": "Evgenia Karunus",
        "timestamp": 1748111948
    },
    {
        "content": "<p>While using LeanSearch, I noticed something funny.  I used the <a href=\"https://leansearch.net/?q=A+simple+group+that+is+commutative+is+cyclic\">query</a></p>\n<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code>A<span class=\"w\"> </span>simple<span class=\"w\"> </span>group<span class=\"w\"> </span>that<span class=\"w\"> </span>is<span class=\"w\"> </span>commutative<span class=\"w\"> </span>is<span class=\"w\"> </span>cyclic\n</code></pre></div>\n<p>and the very first hit was exactly what I wanted: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsSimpleGroup.isCyclic#doc\">docs#IsSimpleGroup.isCyclic</a>.</p>\n<p>So far, everything is great!</p>\n<p>However, what I think is the LLM generated description of this result says</p>\n<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code><span class=\"w\"> </span>Finite<span class=\"w\"> </span>Simple<span class=\"w\"> </span>Abelian<span class=\"w\"> </span>Groups<span class=\"w\"> </span>are<span class=\"w\"> </span>Cyclic\nEvery<span class=\"w\"> </span>finite<span class=\"w\"> </span>simple<span class=\"w\"> </span>abelian<span class=\"w\"> </span>group<span class=\"w\"> </span>is<span class=\"w\"> </span>cyclic.\n</code></pre></div>\n<p>And my question: why <code>Finite</code>?</p>",
        "id": 536772811,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1756468690
    },
    {
        "content": "<p>I noticed today that the results are no longer using notation. It has explicit <code>Iff</code></p>",
        "id": 538113294,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1757289727
    },
    {
        "content": "<p>I'm getting 'Rate limit exceeded: 1 per 1 second' errors very frequently whenever I try to use LeanSearch</p>",
        "id": 563662363,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1765685203
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"753178\">Aaron Hill</span> <a href=\"#narrow/channel/113488-general/topic/feedback.20on.20LeanSearch/near/563662363\">said</a>:</p>\n<blockquote>\n<p>I'm getting 'Rate limit exceeded: 1 per 1 second' errors very frequently whenever I try to use LeanSearch</p>\n</blockquote>\n<p>It's just a bug. Everytime I meet this, I will close LeanSearch and open <a href=\"https://www.moogle.ai/\">https://www.moogle.ai/</a></p>",
        "id": 563663636,
        "sender_full_name": "Nick Adfor",
        "timestamp": 1765687088
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"753178\">Aaron Hill</span> <a href=\"#narrow/channel/113488-general/topic/feedback.20on.20LeanSearch/near/563662363\">said</a>:</p>\n<blockquote>\n<p>I'm getting 'Rate limit exceeded: 1 per 1 second' errors very frequently whenever I try to use LeanSearch</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"652127\">@Tony Beta Lambda</span>, <span class=\"user-mention\" data-user-id=\"611077\">@Jiang Jiedong</span>, LeanSearch is down still.</p>",
        "id": 563946748,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1765844048
    },
    {
        "content": "<p>it works for me... however it would be hilarious if only one person could use <a href=\"http://leansearch.net\">leansearch.net</a> at a time or else it hits rate limits</p>",
        "id": 563947669,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1765844885
    },
    {
        "content": "<p>they should implement a queue mechanism to avoid rate limiting if that's the issue</p>",
        "id": 563947734,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1765844933
    },
    {
        "content": "<p>also I find it very amusing that <span class=\"user-mention\" data-user-id=\"877182\">@Nick_adfor</span>, who is working on LeanSearch, has responded to rate limit complaints with \"it's just a bug, when it happens I use some other software\"</p>\n<p>I would hope that Nick means \"we're working on it, but in the meantime you can use Moogle\" but it's just a funny way to respond</p>",
        "id": 563948170,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1765845278
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"380294\">Matt Diamond</span> <a href=\"#narrow/channel/113488-general/topic/feedback.20on.20LeanSearch/near/563948170\">said</a>:</p>\n<blockquote>\n<p>also I find it very amusing that <span class=\"user-mention silent\" data-user-id=\"877182\">Nick_adfor</span>, who is working on LeanSearch, has responded to rate limit complaints with \"it's just a bug, when it happens I use some other software\"</p>\n<p>I would hope that Nick means \"we're working on it, but in the meantime you can use Moogle\" but it's just a funny way to respond</p>\n</blockquote>\n<p>No. The truth is that I work for the part FATE-H. You can see the whole workflow here. <a href=\"https://frenzymath.com/blog/fate/\">https://frenzymath.com/blog/fate/</a></p>",
        "id": 563956775,
        "sender_full_name": "Nick Adfor",
        "timestamp": 1765853320
    },
    {
        "content": "<p>LeanSearch is a neighborhood's work. It is often convenient to ask for your neighbor's help. But this time seems not so we can change to the community</p>",
        "id": 563957015,
        "sender_full_name": "Nick Adfor",
        "timestamp": 1765853509
    },
    {
        "content": "<p>Thank you for the feedback! I’ll talk with <span class=\"user-mention\" data-user-id=\"652127\">@Tony Beta Lambda</span> , who is our maintainer of LeanSearch, about the current issue. Currently, the rate limit is set due to previous outside large search requests beyond the capacity of our server. We suspect that people are trying to benchmarking LeanSearch. Sometimes there are other issues about LeanSearch, but the error message is still the RPM limit. We’ll investigate what is happening now.</p>",
        "id": 563958716,
        "sender_full_name": "Jiang Jiedong",
        "timestamp": 1765855098
    },
    {
        "content": "<p>The webpage of LeanSearch is responding normally now under a small scale test.</p>",
        "id": 563958815,
        "sender_full_name": "Jiang Jiedong",
        "timestamp": 1765855217
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"877182\">@Nick_adfor</span> Thank you for your contribution on formalizing the proofs of problems in FATE-H. I am pretty sorry that LeanSearch is not stable enough for your work…</p>",
        "id": 563959869,
        "sender_full_name": "Jiang Jiedong",
        "timestamp": 1765856252
    },
    {
        "content": "<p>I've heard that LeanSearch is goint to build a better Docs to replace Mathlib's origin Docs. It is a long-term, hard work, but it deserves!</p>",
        "id": 563967166,
        "sender_full_name": "Nick Adfor",
        "timestamp": 1765862555
    },
    {
        "content": "<p>LeanSearch server had a bug where the rate limiter was not correctly identifying client IP, which has now been fixed.  Hopefully it resolves the \"rate limit exceeded\" error.</p>",
        "id": 564404513,
        "sender_full_name": "Tony Beta Lambda",
        "timestamp": 1766046816
    },
    {
        "content": "<p>I was curious if it is just me. I usually use these AI searches for definitions, not theorems. When I need a theorem, I have a decent idea of what I am searching for -- which global constants should appear there, so Loogle is typically good enough. On the other hand, I need string-based query when I have no idea how the concept I have in mind is represented in Lean, which happens rather with definitions than with theorems</p>\n<p>So it is a bit surprising to me how both Moogle &amp; Leansearch is marketed as \"find your theorems\", when I mostly go there to find my definitions.</p>",
        "id": 564431150,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1766055733
    },
    {
        "content": "<p>Well, there seems another way: to find the associated theorem to help find the definition:)</p>",
        "id": 564436777,
        "sender_full_name": "Nick Adfor",
        "timestamp": 1766057635
    },
    {
        "content": "<p>Is there any plan to release the dataset for the latest version of LeanSearch?</p>",
        "id": 564877128,
        "sender_full_name": "Lawrence Wu (llllvvuu)",
        "timestamp": 1766301036
    },
    {
        "content": "<p>It seems hard</p>",
        "id": 569174597,
        "sender_full_name": "Nick Adfor",
        "timestamp": 1768973250
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"607118\">Lawrence Wu (llllvvuu)</span> <a href=\"#narrow/stream/113488-general/topic/feedback.20on.20LeanSearch/near/564877128\">said</a>:</p>\n<blockquote>\n<p>Is there any plan to release the dataset for the latest version of LeanSearch?</p>\n</blockquote>\n<p>As you can see here, the same problem<br>\n<a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/LeanCat.20benchmark.20.28category.20theory.20in.20Lean.204.29\">https://leanprover.zulipchat.com/#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/LeanCat.20benchmark.20.28category.20theory.20in.20Lean.204.29</a></p>",
        "id": 569174919,
        "sender_full_name": "Nick Adfor",
        "timestamp": 1768973447
    }
]