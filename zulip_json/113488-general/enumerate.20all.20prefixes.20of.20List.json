[
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">module</span>\n\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">List</span>\n\n<span class=\"sd\">/-- Enumerate all prefixes of a list `xs`. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">prefixes</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[[]]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">prefixes</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">guard</span><span class=\"w\"> </span><span class=\"n\">prefixes</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">[[],</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">],</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">],</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">]]</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- Every list returned by `prefixes` is indeed a prefix of the original list. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">isPrefix_of_prefixes</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">prefixes</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">isPrefixOf</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">grind</span>\n\n<span class=\"sd\">/-- Every prefix is enumerated by the `prefixes` function. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">prefixes_of_isPrefix</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">isPrefixOf</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">prefixes</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">fun_induction</span><span class=\"w\"> </span><span class=\"n\">isPrefixOf</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">prefixes</span><span class=\"bp\">.</span><span class=\"n\">eq_def</span><span class=\"o\">]</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">prefixes_iff_isPrefixOf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">prefixes</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">isPrefixOf</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">⟨</span><span class=\"n\">isPrefix_of_prefixes</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">prefixes_of_isPrefix</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">List</span>\n</code></pre></div>",
        "id": 567134826,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1767963062
    },
    {
        "content": "<p>Recently, I wrote a function that enumerates all prefixes of a list and proved its correctness.<br>\nI think this function could be useful in other contexts as well, but after checking with Loogle, it seems that it is not yet available in the libraries.<br>\nIf others think this would be useful, I would be happy to open a PR.</p>",
        "id": 567135144,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1767963157
    },
    {
        "content": "<p>This seems like a reasonable definition to have</p>",
        "id": 567135349,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1767963232
    },
    {
        "content": "<p>(though I think the lemmas could do with some bikeshedding)</p>",
        "id": 567135499,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1767963281
    },
    {
        "content": "<p>This is suitable for Batteries?</p>",
        "id": 567135641,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1767963326
    },
    {
        "content": "<p>That's <a href=\"https://leanprover-community.github.io/mathlib4_docs/Batteries/Data/List/Basic.html#List.inits\">List.inits</a> I think?</p>",
        "id": 567141194,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1767965049
    },
    {
        "content": "<p>And <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/List/Infix.html#List.mem_inits\">List.mem_inits</a> is more or less <code>prefixes_iff_isPrefixOf</code>, but with <code>List.IsPrefix</code>. Adding <code>List.isPrefixOf</code> version to Batteries could be useful though.</p>",
        "id": 567141558,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1767965170
    },
    {
        "content": "<p>I don't see why we'd want the <code>isPrefixOf</code> version, that's only simp-normal when working with <code>bool</code>, which <code>↔</code> doesn't.</p>",
        "id": 567142276,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1767965389
    },
    {
        "content": "<p>Why do we even have <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Data/List/Basic.html#List.isPrefixOf\">List.isPrefixOf</a>? Also, its doc-string mentions <code>List.IsPrefixOf</code> which doesn't exist?</p>",
        "id": 567143098,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1767965653
    },
    {
        "content": "<p>The Bool one is used to implement decidability of the Prop one</p>",
        "id": 567151480,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1767968264
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/113488-general/topic/enumerate.20all.20prefixes.20of.20List/near/567151480\">said</a>:</p>\n<blockquote>\n<p>The Bool one is used to implement decidability of the Prop one</p>\n</blockquote>\n<p>This feels like an instance of missing automation for decidability.</p>",
        "id": 567641784,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1768251425
    },
    {
        "content": "<p>As in you would like to automate <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=decidable_of_iff#doc\">docs#decidable_of_iff</a> or <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=decidable_of_decidable_of_iff#doc\">docs#decidable_of_decidable_of_iff</a> instances somehow?</p>",
        "id": 567646918,
        "sender_full_name": "Chris Henson",
        "timestamp": 1768253475
    },
    {
        "content": "<p>The point is to have an optimized implementation</p>",
        "id": 567647222,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1768253587
    },
    {
        "content": "<p>My proposal is that you should be able to write a function returning bool, tag it with something, and get the same function returning Prop + a decidable instance.</p>",
        "id": 567691676,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1768285536
    },
    {
        "content": "<p>The Prop one is the one you should usually be working with in proofs. So that one is defined in a way to be easy to work with in proofs. The boolean one (i.e. decidable instance) is made with performance in mind. Though, I think that we shouldn't have <code>List.isPrefixOf?</code> be public. Having public decidable instance should be enough?</p>",
        "id": 567694728,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768287394
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/113488-general/topic/enumerate.20all.20prefixes.20of.20List/near/567691676\">said</a>:</p>\n<blockquote>\n<p>My proposal is that you should be able to write a function returning bool, tag it with something, and get the same function returning Prop + a decidable instance.</p>\n</blockquote>\n<p>This practically already exists with the coercion from <code>Bool</code> to <code>Prop</code> (which is defined as <code>b =&gt; b = true</code>) and the <code>DecidableEq</code> instance for <code>Bool</code></p>",
        "id": 567734489,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1768301736
    },
    {
        "content": "<p>Does that mean we should just be using <code>bool</code>-valued functions for all computational purposes? And skip the <code>Prop</code> valued ones entirely.</p>",
        "id": 567898399,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1768362227
    },
    {
        "content": "<p>When you define something as an inductive predicate rather than a recursive function, there are times when I find it inconvenient because functional induction cannot be used.</p>",
        "id": 567899658,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1768363200
    },
    {
        "content": "<p>Nat.le is defined as an inductive predicate, whereas List.Prefix is written as an existential proposition rather than an inductive predicate. I would like to know if there are any guidelines for deciding when one should use an inductive predicate.</p>",
        "id": 567899879,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1768363353
    }
]