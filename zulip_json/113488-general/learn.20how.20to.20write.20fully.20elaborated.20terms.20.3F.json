[
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/lean4-metaprogramming-book/main/02_overview.html\">https://leanprover-community.github.io/lean4-metaprogramming-book/main/02_overview.html</a> talks about 'Fully Elaborated Terms'</p>\n<p>Is there a tutorial / reference / set of exercises I can go through to learn how to write 'Fully Elaborated Terms' ?</p>\n<p>I fully understand (1) this is not normally used, (2) this is going to be verbose/tedious, (3) typically this is some low level thing the elaborator/compiler emits, (4) humans are not meant to write at this level.</p>\n<p>Purely out of intellectual curiosity, I'm curious what fully elaborated terms look like, how to manually construct them, (and what trusted kernels like nanoda_lib verify).</p>\n<p>What is the best reading material / written exercises to go through to understand <code>Fully Elaborated Terms</code> ?</p>\n<p>Thanks!</p>",
        "id": 562580514,
        "sender_full_name": "TongKe Xue",
        "timestamp": 1765240038
    },
    {
        "content": "<p>Where does it mention fully elaborated terms?</p>",
        "id": 562581032,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765240462
    },
    {
        "content": "<p>Maybe I am using the wrong terminology. I am referring to the structure that:</p>\n<ol>\n<li>happens after the \"elaboration\" step (in the diagram) and</li>\n<li>is fed directly into the \"trusted lean4 kernel checker\"</li>\n</ol>",
        "id": 562581246,
        "sender_full_name": "TongKe Xue",
        "timestamp": 1765240614
    },
    {
        "content": "<p>Oh you mean the <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Expr#doc\">docs#Lean.Expr</a></p>",
        "id": 562581295,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765240663
    },
    {
        "content": "<p>The next chapter in that book is all about them</p>",
        "id": 562581324,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765240686
    },
    {
        "content": "<p>and there's some exercises at the end</p>",
        "id": 562581335,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765240697
    },
    {
        "content": "<p>at the end of chapter 3, not at the end of the book</p>",
        "id": 562581351,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765240711
    },
    {
        "content": "<p>Is that the thing that goes into the \"Kernel Check\" at <a href=\"https://lean-lang.org/doc/reference/latest/Elaboration-and-Compilation/#:~:text=There%20are%20multiple%20kinds%20of,the%20state%20for%20subsequent%20commands\">https://lean-lang.org/doc/reference/latest/Elaboration-and-Compilation/#:~:text=There%20are%20multiple%20kinds%20of,the%20state%20for%20subsequent%20commands</a>. ?</p>",
        "id": 562581501,
        "sender_full_name": "TongKe Xue",
        "timestamp": 1765240821
    },
    {
        "content": "<p>yes it is</p>",
        "id": 562581630,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765240930
    },
    {
        "content": "<p>I'm 99% sure the answer to this is yes, but I just want to sanity check, as getting this wrong would be very bad</p>\n<ol>\n<li><a href=\"https://leanprover-community.github.io/lean4-metaprogramming-book/main/03_expressions.html\">https://leanprover-community.github.io/lean4-metaprogramming-book/main/03_expressions.html</a></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/Lean/Expr.html#Lean.Expr\">https://leanprover-community.github.io/mathlib4_docs/Lean/Expr.html#Lean.Expr</a></li>\n<li><a href=\"https://github.com/ammkrn/nanoda_lib/blob/master/src/expr.rs#L20-L101\">https://github.com/ammkrn/nanoda_lib/blob/master/src/expr.rs#L20-L101</a></li>\n</ol>\n<p>are the same thing; and in theory, I can take any Lean4 proof, push it to the point until we get a Lean.Expr out of it, write it, read it in nanoda_lib, and it should verify/pass the checker ?</p>",
        "id": 562582700,
        "sender_full_name": "TongKe Xue",
        "timestamp": 1765241901
    },
    {
        "content": "<p>I don't know about nanoda_lib, but everything else seems correct</p>",
        "id": 562583096,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765242228
    },
    {
        "content": "<p>I think there a few caveats: Lean proofs can have metavariables while they are being assembled, and metavariable are a valid branch in Expr, but the kernel won't accept proofs with metavariables. Similarly, I'm not sure what the role of metadata is. Also, functions written using recursion will literally refer to themselves until some part of Lean removes it and replaces it with a recursor; if you get the expr before that happens somehow, I think the kernel will reject it</p>",
        "id": 562783350,
        "sender_full_name": "Niels Voss",
        "timestamp": 1765309580
    },
    {
        "content": "<p>So basically the finished proof will be an expr, but not all exprs are finished proofs</p>",
        "id": 562783575,
        "sender_full_name": "Niels Voss",
        "timestamp": 1765309641
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"1001511\">TongKe Xue</span> <a href=\"#narrow/channel/113488-general/topic/learn.20how.20to.20write.20fully.20elaborated.20terms.20.3F/near/562582700\">said</a>:</p>\n<blockquote>\n<p>I'm 99% sure the answer to this is yes, but I just want to sanity check, as getting this wrong would be very bad</p>\n<ol>\n<li><a href=\"https://leanprover-community.github.io/lean4-metaprogramming-book/main/03_expressions.html\">https://leanprover-community.github.io/lean4-metaprogramming-book/main/03_expressions.html</a></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/Lean/Expr.html#Lean.Expr\">https://leanprover-community.github.io/mathlib4_docs/Lean/Expr.html#Lean.Expr</a></li>\n<li><a href=\"https://github.com/ammkrn/nanoda_lib/blob/master/src/expr.rs#L20-L101\">https://github.com/ammkrn/nanoda_lib/blob/master/src/expr.rs#L20-L101</a></li>\n</ol>\n<p>are the same thing; and in theory, I can take any Lean4 proof, push it to the point until we get a Lean.Expr out of it, write it, read it in nanoda_lib, and it should verify/pass the checker ?</p>\n</blockquote>\n<p>A notable difference is that nanoda_lib doesn't support <code>mvar</code> or <code>mdata</code> because they're not essential for type checking (reading more of the thread I see someone mentioned the mvar part).</p>",
        "id": 562837881,
        "sender_full_name": "Chris Bailey",
        "timestamp": 1765330385
    }
]