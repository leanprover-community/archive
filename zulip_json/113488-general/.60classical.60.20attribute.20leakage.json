[
    {
        "content": "<p>I'm wondering whether it's intended that the new <code>classical</code> tactic adds the <code>instance</code> attribute to <code>classical.prop_decidable</code> globally. The tactic is adding it non-persistently, but that only means that it's scoped to the <code>section</code>/<code>namespace</code> (it's the difference between the <code>local attribute</code> and <code>attribute</code> commands.)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic.interactive</span>\n\n<span class=\"c1\">-- Fails</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">foo1</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">decidable_eq</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"kd\">begin</span> <span class=\"n\">apply_instance</span><span class=\"o\">,</span> <span class=\"kd\">end</span>\n\n<span class=\"c1\">-- Succeeds</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">foo2</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">decidable_eq</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"kd\">begin</span> <span class=\"n\">classical</span><span class=\"o\">,</span> <span class=\"n\">apply_instance</span><span class=\"o\">,</span> <span class=\"kd\">end</span>\n\n<span class=\"c1\">-- Succeeds?</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">foo3</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">decidable_eq</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"kd\">begin</span> <span class=\"n\">apply_instance</span><span class=\"o\">,</span> <span class=\"kd\">end</span>\n</code></pre></div>\n<p>(ping <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>)</p>",
        "id": 282726128,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1652834793
    },
    {
        "content": "<p>Oh darn, I wasn't sure what persistent meant (I don't think there's a docstring), and thought I'd tested it as ok</p>",
        "id": 282726224,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1652834909
    },
    {
        "content": "<p>I would guess we want to use <del>docs#bracket</del> <em>whatever the spelling of try/finally is</em> to add and remove the attribute</p>",
        "id": 282726246,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1652834949
    },
    {
        "content": "<p>Yeah, I was just trying to write <code>by_classical { ... }</code> that'd do that</p>",
        "id": 282726477,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1652835175
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/tactic.finally\">docs#tactic.finally</a> is what I meant</p>",
        "id": 282726502,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1652835214
    },
    {
        "content": "<p>I wonder if there's ever a situation where with nested tactic blocks, the inner tactic block executes <em>after</em> the outer one.</p>",
        "id": 282726560,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1652835265
    },
    {
        "content": "<p>In that case the inner one won't get the instances</p>",
        "id": 282726566,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1652835279
    },
    {
        "content": "<p>I don't follow; can't you just restore the previous attribute?</p>",
        "id": 282726588,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1652835309
    },
    {
        "content": "<p>Or do nothing if the attribute is already there</p>",
        "id": 282726601,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1652835329
    },
    {
        "content": "<p>Regarding the notation, I was thinking about something slightly different; a <code>classical! expr</code> notation  to allow <code>classical! if p then y else n</code></p>",
        "id": 282726663,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1652835387
    },
    {
        "content": "<p>Although actually for that, maybe</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">classically</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">P</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">classically</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">classical.dec</span>\n</code></pre></div>\n<p>is a better spelling</p>",
        "id": 282726923,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1652835638
    },
    {
        "content": "<p>Here's a seemingly working <code>with_classical { ... }</code> block:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic.interactive</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">tactic</span>\n\n<span class=\"sd\">/-- Temporarily give the `instance` attribute to a declaration with</span>\n<span class=\"sd\">a given priority then restore the original attribute settings. -/</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">with_instance</span> <span class=\"o\">(</span><span class=\"n\">c_name</span> <span class=\"o\">:</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">prio</span> <span class=\"o\">:</span> <span class=\"n\">option</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">tac</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"k\">do</span> <span class=\"n\">old</span> <span class=\"bp\">←</span> <span class=\"n\">try_core</span> <span class=\"o\">(</span><span class=\"n\">tactic.has_attribute</span> <span class=\"bp\">`</span><span class=\"kd\">instance</span> <span class=\"n\">c_name</span><span class=\"o\">),</span>\n   <span class=\"n\">tactic.set_basic_attribute</span> <span class=\"bp\">`</span><span class=\"kd\">instance</span> <span class=\"n\">c_name</span> <span class=\"n\">ff</span> <span class=\"n\">prio</span><span class=\"o\">,</span>\n   <span class=\"n\">tactic.finally</span> <span class=\"n\">tac</span> <span class=\"bp\">$</span>\n     <span class=\"k\">match</span> <span class=\"n\">old</span> <span class=\"k\">with</span>\n     <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"o\">:=</span> <span class=\"n\">tactic.unset_attribute</span> <span class=\"bp\">`</span><span class=\"kd\">instance</span> <span class=\"n\">c_name</span>\n     <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">persistent</span><span class=\"o\">,</span> <span class=\"n\">prio</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">tactic.set_basic_attribute</span> <span class=\"bp\">`</span><span class=\"kd\">instance</span> <span class=\"n\">c_name</span> <span class=\"n\">persistent</span> <span class=\"n\">prio</span>\n     <span class=\"kd\">end</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">interactive</span>\n<span class=\"n\">setup_tactic_parser</span>\n\n<span class=\"sd\">/-- Have the effect of `open_locale classical` for the duration of</span>\n<span class=\"sd\">the given tactic block. -/</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">with_classical</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">parse</span> <span class=\"n\">parser.itactic</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"n\">with_instance</span> <span class=\"bp\">`</span><span class=\"n\">classical.prop_decidable</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"mi\">9</span><span class=\"o\">)</span> <span class=\"bp\">$</span>\n<span class=\"n\">with_instance</span> <span class=\"bp\">`</span><span class=\"n\">decidable_eq_of_decidable_le</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"mi\">8</span><span class=\"o\">)</span> <span class=\"bp\">$</span>\n<span class=\"n\">t</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">interactive</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">tactic</span>\n\n<span class=\"c1\">-- Succeeds</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">foo1</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">decidable_eq</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"kd\">begin</span> <span class=\"n\">with_classical</span> <span class=\"o\">{</span> <span class=\"n\">apply_instance</span> <span class=\"o\">}</span> <span class=\"kd\">end</span>\n\n<span class=\"c1\">-- Fails (good!)</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">foo2</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">decidable_eq</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"kd\">begin</span> <span class=\"n\">apply_instance</span><span class=\"o\">,</span> <span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 282727284,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1652836018
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/.60classical.60.20attribute.20leakage/near/282726923\">said</a>:</p>\n<blockquote>\n<p>Although actually for that, maybe</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">classically</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">P</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">classically</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">classical.dec</span>\n</code></pre></div>\n<p>is a better spelling</p>\n</blockquote>\n<p>That's an interesting idea for classical <code>if</code>, though it might get in the way rewrites... Making it <code>@[reducible]</code> might help somewhat.</p>",
        "id": 282727492,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1652836218
    },
    {
        "content": "<p>Could you use <code>bracket</code>? e.g. <a href=\"https://leanprover-community.github.io/mathlib_docs/find/tactic.with_local_reducibility/src\">src#tactic.with_local_reducibility</a></p>",
        "id": 282727550,
        "sender_full_name": "Reid Barton",
        "timestamp": 1652836278
    },
    {
        "content": "<p>It looks like <code>bracket a b c = a &gt;&gt; finally b c</code> so yes -- is there a reason to?</p>",
        "id": 282728076,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1652836894
    },
    {
        "content": "<p>I guess I would have said it is the more idiomatic way to express this kind of intent, but otherwise I suppose not</p>",
        "id": 282728788,
        "sender_full_name": "Reid Barton",
        "timestamp": 1652837803
    },
    {
        "content": "<p>Is it possible to create a tactic block in a <code>pexpr</code>? I wanted to see if it was possible to implement Eric's <code>classical!</code> user notation.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>code</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic.interactive</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">tactic</span>\n\n<span class=\"sd\">/-- Temporarily give the `instance` attribute to a declaration with</span>\n<span class=\"sd\">a given priority then restore the original attribute settings. -/</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">with_instance</span> <span class=\"o\">(</span><span class=\"n\">c_name</span> <span class=\"o\">:</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">prio</span> <span class=\"o\">:</span> <span class=\"n\">option</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">tac</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"k\">do</span> <span class=\"n\">old</span> <span class=\"bp\">←</span> <span class=\"n\">try_core</span> <span class=\"o\">(</span><span class=\"n\">tactic.has_attribute</span> <span class=\"bp\">`</span><span class=\"kd\">instance</span> <span class=\"n\">c_name</span><span class=\"o\">),</span>\n   <span class=\"n\">bracket</span> <span class=\"o\">(</span><span class=\"n\">tactic.set_basic_attribute</span> <span class=\"bp\">`</span><span class=\"kd\">instance</span> <span class=\"n\">c_name</span> <span class=\"n\">ff</span> <span class=\"n\">prio</span><span class=\"o\">)</span> <span class=\"n\">tac</span> <span class=\"bp\">$</span>\n     <span class=\"k\">match</span> <span class=\"n\">old</span> <span class=\"k\">with</span>\n     <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"o\">:=</span> <span class=\"n\">tactic.unset_attribute</span> <span class=\"bp\">`</span><span class=\"kd\">instance</span> <span class=\"n\">c_name</span>\n     <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">persistent</span><span class=\"o\">,</span> <span class=\"n\">prio</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">tactic.set_basic_attribute</span> <span class=\"bp\">`</span><span class=\"kd\">instance</span> <span class=\"n\">c_name</span> <span class=\"n\">persistent</span> <span class=\"n\">prio</span>\n     <span class=\"kd\">end</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">interactive</span>\n<span class=\"n\">setup_tactic_parser</span>\n\n<span class=\"sd\">/-- Have the effect of `open_locale classical` for the duration of</span>\n<span class=\"sd\">the given tactic block. -/</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">with_classical</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">parse</span> <span class=\"n\">parser.itactic</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"n\">with_instance</span> <span class=\"bp\">`</span><span class=\"n\">classical.prop_decidable</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"mi\">9</span><span class=\"o\">)</span> <span class=\"bp\">$</span>\n<span class=\"n\">with_instance</span> <span class=\"bp\">`</span><span class=\"n\">decidable_eq_of_decidable_le</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"mi\">8</span><span class=\"o\">)</span> <span class=\"bp\">$</span>\n<span class=\"n\">t</span>\n\n<span class=\"kd\">reserve</span> <span class=\"kd\">notation</span> <span class=\"bp\">`</span><span class=\"n\">classical</span><span class=\"bp\">!`</span><span class=\"o\">:</span><span class=\"mi\">0</span>\n\n<span class=\"kd\">@[user_notation]</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">by_classical_notation</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">parse</span> <span class=\"bp\">$</span> <span class=\"n\">tk</span> <span class=\"s2\">\"classical!\"</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">parse</span> <span class=\"n\">parser.pexpr</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">parser</span> <span class=\"n\">pexpr</span> <span class=\"o\">:=</span>\n<span class=\"k\">do</span> <span class=\"n\">trace</span> <span class=\"n\">t</span><span class=\"o\">,</span>\n  <span class=\"n\">return</span> <span class=\"n\">t</span>\n  <span class=\"c1\">-- is it possible to do something that does what it seems like this should mean?</span>\n  <span class=\"c1\">--return ``(by with_classical { exact %%t })</span>\n  <span class=\"c1\">-- it appears that tactics inside quotations execute immediately</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">interactive</span>\n\n\n<span class=\"kd\">end</span> <span class=\"n\">tactic</span>\n</code></pre></div>\n</div></div>",
        "id": 282729342,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1652838417
    },
    {
        "content": "<p>Where is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/bracket\">docs#bracket</a> defined?</p>",
        "id": 282746777,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1652857168
    },
    {
        "content": "<p>I looked for it and couldn't find it</p>",
        "id": 282746799,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1652857187
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/interaction_monad.bracket\">docs#interaction_monad.bracket</a> (btw, <code>with_instance</code> in the code block just above is using it)</p>",
        "id": 282749111,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1652858897
    },
    {
        "content": "<p>(I was going to use it in the original PR but couldn't see the effect; I just thought I imagined it when the doc link didn't work!)</p>",
        "id": 282749837,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1652859455
    },
    {
        "content": "<p>Hmm, <code>bracket</code> doesn't work here as it would need to modify the syntax of <code>classical</code></p>",
        "id": 283239984,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1653236600
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>, do you have any opinions about what we should do here?</p>",
        "id": 284194373,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1653692845
    },
    {
        "content": "<p>Maybe there's some \"at end of tactic\" hook we can use like the \"step\" hook?</p>",
        "id": 284194393,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1653692872
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> Interesting idea. I've been reading through the tactic parser source code to see what features we might be able to use.</p>\n<p>The extent of a tactic appears to be handled by the <code>execute_with</code> field of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/interactive.executor\">docs#interactive.executor</a>, where the default implementation for plain old tactic blocks is doing nothing. So, if we could inject cleanup routines here then that would probably work, but we probably shouldn't touch the main interactive tactic... (But if we were ok with doing that, we could add state to the <code>config_type</code> field recording whether we need to do clean up for <code>classical</code>.)</p>\n<p>One option is that we could make a custom <code>classical</code> tactic class, so then you would write <code>begin [classical] ... end</code>, and then <code>execute_with</code> would be responsible for bracketing the attribute manipulation. However, as far as I can tell custom tactic classes have their own namespace for interactive tactics and there's no way to include interactive tactics from another tactic class, short of copying them all over. That's what the natural number game does (but we don't want to do that since the tactic set changes depending on what you've got imported).</p>\n<p>Maybe there could be a systematic way to let one tactic class use interactive tactics from another tactic class. This seems to be the place where name lookup happens: <a href=\"https://github.com/leanprover-community/lean/blob/master/src/frontends/lean/tactic_notation.cpp#L136\">https://github.com/leanprover-community/lean/blob/master/src/frontends/lean/tactic_notation.cpp#L136</a></p>\n<p>I thought that perhaps it could be made to respect aliases similar to how name lookup works in the elaborator (\"aliases\" are not to be confused with the <code>alias</code> command -- these are the aliases used to implement <code>open</code> and <code>export</code>). You can <code>export</code> names from one namespace to another, but you probably would need to refresh the aliases to the <code>classical.interactive</code> namespace when you import more tactics...</p>",
        "id": 284204481,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1653705478
    },
    {
        "content": "<blockquote>\n<p>So, if we could inject cleanup routines here then that would probably work, but we probably shouldn't touch the main interactive tactic...</p>\n</blockquote>\n<p>It's a hack, but we can even do it from within mathlib:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">my_executor</span> <span class=\"o\">:</span> <span class=\"n\">interactive.executor</span> <span class=\"n\">tactic</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">config_type</span> <span class=\"o\">:=</span> <span class=\"n\">unit</span><span class=\"o\">,</span>\n  <span class=\"n\">execute_with</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">block</span><span class=\"o\">,</span> <span class=\"k\">do</span>\n    <span class=\"n\">tactic.trace</span> <span class=\"s2\">\"record state of classical\"</span><span class=\"o\">,</span>\n    <span class=\"n\">block</span><span class=\"o\">,</span>\n    <span class=\"n\">tactic.trace</span> <span class=\"s2\">\"restore initial state\"</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">vm_override</span> <span class=\"n\">my_executor</span><span class=\"o\">]</span> <span class=\"n\">interactive.executor_tactic</span>\n</code></pre></div>",
        "id": 284215960,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1653723153
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> Gabriel's hack seems to work perfectly:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">tactic</span>\n\n<span class=\"sd\">/-- Execute a tactic that might modify the given attribute for hte given declaration and then</span>\n<span class=\"sd\">restore the original attribute state. -/</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">with_local_attribute</span> <span class=\"o\">(</span><span class=\"n\">c_name</span> <span class=\"o\">:</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">attr</span> <span class=\"o\">:</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">tac</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"k\">do</span> <span class=\"n\">old</span> <span class=\"bp\">←</span> <span class=\"n\">try_core</span> <span class=\"o\">(</span><span class=\"n\">tactic.has_attribute</span> <span class=\"n\">attr</span> <span class=\"n\">c_name</span><span class=\"o\">),</span>\n   <span class=\"n\">finally</span> <span class=\"n\">tac</span> <span class=\"bp\">$</span> <span class=\"k\">do</span>\n     <span class=\"c\">/-</span><span class=\"cm\"> I haven't checked, but I think it might be more efficient to only</span>\n<span class=\"cm\">        change it back if it's different... -/</span>\n     <span class=\"n\">new</span> <span class=\"bp\">←</span> <span class=\"n\">try_core</span> <span class=\"o\">(</span><span class=\"n\">tactic.has_attribute</span> <span class=\"n\">attr</span> <span class=\"n\">c_name</span><span class=\"o\">),</span>\n     <span class=\"n\">when</span> <span class=\"o\">(</span><span class=\"n\">new</span> <span class=\"bp\">≠</span> <span class=\"n\">old</span><span class=\"o\">)</span> <span class=\"bp\">$</span> <span class=\"k\">do</span>\n       <span class=\"k\">match</span> <span class=\"n\">old</span> <span class=\"k\">with</span>\n       <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"o\">:=</span> <span class=\"n\">tactic.unset_attribute</span> <span class=\"n\">attr</span> <span class=\"n\">c_name</span>\n       <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">persistent</span><span class=\"o\">,</span> <span class=\"n\">prio</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">tactic.set_basic_attribute</span> <span class=\"n\">attr</span> <span class=\"n\">c_name</span> <span class=\"n\">persistent</span> <span class=\"n\">prio</span>\n       <span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">mathlib_tactic_executor</span> <span class=\"o\">:</span> <span class=\"n\">interactive.executor</span> <span class=\"n\">tactic</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">config_type</span> <span class=\"o\">:=</span> <span class=\"n\">unit</span><span class=\"o\">,</span>\n  <span class=\"n\">execute_with</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">block</span><span class=\"o\">,</span>\n    <span class=\"n\">tactic.with_local_attribute</span> <span class=\"bp\">`</span><span class=\"n\">classical.prop_decidable</span> <span class=\"bp\">`</span><span class=\"kd\">instance</span> <span class=\"bp\">$</span>\n    <span class=\"n\">tactic.with_local_attribute</span> <span class=\"bp\">`</span><span class=\"n\">classical.decidable_eq_of_decidable</span> <span class=\"bp\">`</span><span class=\"kd\">instance</span> <span class=\"bp\">$</span>\n    <span class=\"n\">block</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">vm_override</span> <span class=\"n\">mathlib_tactic_executor</span><span class=\"o\">]</span> <span class=\"n\">interactive.executor_tactic</span>\n\n<span class=\"c1\">-- Fails</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">foo1</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">decidable_eq</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"kd\">begin</span> <span class=\"n\">apply_instance</span><span class=\"o\">,</span> <span class=\"kd\">end</span>\n\n<span class=\"c1\">-- Succeeds</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">foo2</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">decidable_eq</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"kd\">begin</span> <span class=\"n\">classical</span><span class=\"o\">,</span> <span class=\"n\">apply_instance</span><span class=\"o\">,</span> <span class=\"kd\">end</span>\n\n<span class=\"c1\">-- Fails! (good!)</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">foo3</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">decidable_eq</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"kd\">begin</span> <span class=\"n\">apply_instance</span><span class=\"o\">,</span> <span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 284243466,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1653764481
    },
    {
        "content": "<p>Incidentally, I remember someone had the idea a couple months ago of experimenting with a version of tactic blocks that would automatically do <code>assumption</code> or <code>refl</code> at the end -- this is a way you could try taking that idea for a spin.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">mathlib_tactic_executor'</span> <span class=\"o\">:</span> <span class=\"n\">interactive.executor</span> <span class=\"n\">tactic</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">config_type</span> <span class=\"o\">:=</span> <span class=\"n\">unit</span><span class=\"o\">,</span>\n  <span class=\"n\">execute_with</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">block</span><span class=\"o\">,</span>\n    <span class=\"k\">do</span> <span class=\"n\">a</span> <span class=\"bp\">←</span> <span class=\"n\">block</span><span class=\"o\">,</span> <span class=\"n\">tactic.try</span> <span class=\"n\">tactic.assumption</span><span class=\"o\">,</span> <span class=\"n\">return</span> <span class=\"n\">a</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">vm_override</span> <span class=\"n\">mathlib_tactic_executor'</span><span class=\"o\">]</span> <span class=\"n\">interactive.executor_tactic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span> <span class=\"kd\">end</span> <span class=\"c1\">-- tada!</span>\n</code></pre></div>",
        "id": 284243625,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1653764677
    },
    {
        "content": "<p>Presumably something like <code>try {classical, tactic.fail}, apply_instance</code> still picks up the classical instance?</p>",
        "id": 284243727,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1653764804
    },
    {
        "content": "<p>Nope, the inner tactic block seems to get its own <code>execute_with</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">foo3</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">decidable_eq</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"kd\">begin</span> <span class=\"n\">try</span> <span class=\"o\">{</span> <span class=\"n\">classical</span> <span class=\"o\">},</span> <span class=\"n\">apply_instance</span><span class=\"o\">,</span> <span class=\"kd\">end</span> <span class=\"c1\">-- fails at `apply_instance`</span>\n</code></pre></div>",
        "id": 284243813,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1653764896
    },
    {
        "content": "<p>Even if it didn't get its own <code>execute_with</code>, <code>try</code> would discard the tactic state with the classical instances.  A better challenge would be <code>have : 1 = 1, { classical, refl }, apply_instance</code>.</p>",
        "id": 284243827,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1653764950
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>  You can see the nested <code>execute_explicit</code> if you do this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"n\">tactic.trace</span> <span class=\"o\">(</span><span class=\"bp\">``</span><span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">try</span> <span class=\"o\">{</span> <span class=\"n\">classical</span> <span class=\"o\">},</span> <span class=\"n\">apply_instance</span> <span class=\"o\">}))</span>\n</code></pre></div>",
        "id": 284243911,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1653765027
    },
    {
        "content": "<p>This is a complicated way of saying:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#print</span> <span class=\"n\">raw</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">try</span> <span class=\"o\">{</span> <span class=\"n\">classical</span> <span class=\"o\">},</span> <span class=\"n\">apply_instance</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 284243928,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1653765062
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> Success:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">foo3</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">decidable_eq</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"kd\">begin</span> <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"o\">{</span> <span class=\"n\">classical</span><span class=\"o\">,</span> <span class=\"n\">refl</span> <span class=\"o\">},</span> <span class=\"n\">apply_instance</span> <span class=\"kd\">end</span> <span class=\"c1\">-- fails at `apply_instance`</span>\n</code></pre></div>",
        "id": 284243931,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1653765066
    }
]