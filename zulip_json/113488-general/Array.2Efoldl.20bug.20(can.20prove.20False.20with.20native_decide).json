[
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"bp\">.</span><span class=\"n\">foldl_broken</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">foldl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">stop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">native_decide</span>\n<span class=\"w\">  </span><span class=\"n\">contradiction</span>\n</code></pre></div>\n<p><a href=\"https://live.lean-lang.org/#codez=C4Cwpg9gTmC2AEBBKUCGBPAdAMwgGwBM8B9AIyggGswA7eALngDFU8BnMBgXnlPQCh48PGGDwAHt3gBiANoBGADQAmRQGYAujnxF4ACkzwA1PEwBKeAAZ9bYBAAOUgKxnB8EKgBunRpJ4A2KT54KGw8Nw9vBgl4Hmt6HmCaVGAAS29iAjAAY1Sst2yIGmA0AlTstKL+IA\">playground</a></p>\n<p>Array.foldlMUnsafe and Array.foldlM (the latter of which is <code>@[implemented_by]</code>the former) are not equivalent functions. When <code>stop</code> is larger than the length of the array, the functions behave differently (the reference implementation handles <code>stop &gt; as.size</code> by clamping stop, while foldMUnsafe returns <code>init</code>). </p>\n<p><code>foldr</code> does not seem to suffer from this issue (both implementations seem to choose the clamping behavior). Is clamping the intended behavior? I can submit a PR if so.</p>\n<p>(as a side note, I wonder if it might be worth having theorems that prove that the unsafe Array functions are equivalent to their public definitions, given that <code>\\forall array, array.size &lt; USize.size</code>. the documentation guarantees this is true  but it is unprovable. You could prove that this hypothesis implies  the functions are equivalent though)</p>",
        "id": 565077432,
        "sender_full_name": "cmlsharp",
        "timestamp": 1766442404
    },
    {
        "content": "<p>(nvm wrong)</p>",
        "id": 565080100,
        "sender_full_name": "cmlsharp",
        "timestamp": 1766444486
    },
    {
        "content": "<p>GitHub issue</p>\n<p><a href=\"https://github.com/leanprover/lean4/issues/11773\">https://github.com/leanprover/lean4/issues/11773</a></p>",
        "id": 565080116,
        "sender_full_name": "cmlsharp",
        "timestamp": 1766444505
    },
    {
        "content": "<p>I took the liberty of renaming this thread, to avoid it drawing more attention than necessary; <code>native_decide</code> is well-known to have soundness bugs, but it is still very valuable to report them each time you find them in Lean and Mathlib!</p>",
        "id": 565081086,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1766445393
    },
    {
        "content": "<p>Gotcha, appreciate it!</p>",
        "id": 565081150,
        "sender_full_name": "cmlsharp",
        "timestamp": 1766445484
    },
    {
        "content": "<p>I'll rename the Github issue as well</p>",
        "id": 565081155,
        "sender_full_name": "cmlsharp",
        "timestamp": 1766445492
    },
    {
        "content": "<p>Fix at <a href=\"https://github.com/leanprover-community/mathlib4/pull/11774\">#11774</a></p>",
        "id": 565081462,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1766445811
    },
    {
        "content": "<p>(<a href=\"https://github.com/leanprover/lean4/pull/11774\">lean4#11774</a>)</p>",
        "id": 565081728,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1766446125
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span>  thanks! From reading the PR it seems like the “return init” behavior was selected, is this correct?</p>\n<p>If so I think there’s a divergence between Array.foldl and Array.foldr. Maybe it’s not worth fixing, but it’s at least a bit odd.</p>\n<p>When start &gt; arr.size, I believe foldr clamps (no longer at my laptop so I can’t test)</p>",
        "id": 565082349,
        "sender_full_name": "cmlsharp",
        "timestamp": 1766446664
    },
    {
        "content": "<p>I think this is worth discussing in an RFC, would you like to figure out what other languages do and write up a change proposal?</p>",
        "id": 565082624,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1766446936
    },
    {
        "content": "<p>Note that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Array.foldlM_start_stop#doc\">docs#Array.foldlM_start_stop</a> is already a specification for how Array.foldl should behave when <code>stop</code> is not its default value, and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Array.extract#doc\">docs#Array.extract</a> has lemmas for this case.</p>",
        "id": 565082948,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1766447250
    },
    {
        "content": "<p>Sure I can do that. Off the top of my head, I’m not aware of any languages that have fold itself take these parameters (usually you’d create a slice of the array which is where the validation would occur and then fold over that, whereas in Lean Subarray.fold is implemented in terms of the more general Array.fold with start/stop indices) but that might be my own ignorance talking. I’ll dig a bit to see if there’s other precedent for defining fold this way.</p>",
        "id": 565082996,
        "sender_full_name": "cmlsharp",
        "timestamp": 1766447305
    },
    {
        "content": "<p>Out of curiosity do you know why Lean chose to do things this way? </p>\n<p>E.g. why not make “mapping/folding over a subarray” just be accomplished by creating a Subarray and then calling map/ fold. Then you never have to deal with what a sensible return value is if you get bad start/stop indices (or rather you deal with it exactly once when defining the semantics of slicing)</p>",
        "id": 565083093,
        "sender_full_name": "cmlsharp",
        "timestamp": 1766447431
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"1006649\">cmlsharp</span> <a href=\"#narrow/channel/113488-general/topic/Array.2Efoldl.20bug.20.28can.20prove.20False.20with.20native_decide.29/near/565083093\">said</a>:</p>\n<blockquote>\n<p>Out of curiosity do you know why Lean chose to do things this way? </p>\n<p>E.g. why not make “mapping/folding over a subarray” just be accomplished by creating a Subarray and then calling map/ fold. Then you never have to deal with what a sensible return value is if you get bad start/stop indices (or rather you deal with it exactly once when defining the semantics of slicing)</p>\n</blockquote>\n<p>Creating a subarray currently allocates a subarray structure unless you have enough inlining and worker/wrapper style functions available to make the compiler optimize it away again. Though I'm inclined to believe it was simply done because it's possible back in the day.</p>",
        "id": 565085409,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1766449819
    },
    {
        "content": "<p>I’m surprised that creating a Subarray allocates. (I assume you mean it allocates a boxed structure that contains e.g. the pointer and length effectively?). is there somewhere I can read more about this?</p>",
        "id": 565085975,
        "sender_full_name": "cmlsharp",
        "timestamp": 1766450528
    },
    {
        "content": "<p>In particular I’m interested by your “enough worker/wrapper functions” comment.</p>",
        "id": 565086192,
        "sender_full_name": "cmlsharp",
        "timestamp": 1766450792
    },
    {
        "content": "<blockquote>\n<p>(I assume you mean it allocates a boxed structure that contains e.g. the pointer and length effectively?)<br>\nYes, Lean does nto currently have stack allocated structures, it will in the future.</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"1006649\">cmlsharp</span> <a href=\"#narrow/channel/113488-general/topic/Array.2Efoldl.20bug.20.28can.20prove.20False.20with.20native_decide.29/near/565086192\">said</a>:</p>\n<blockquote>\n<p>In particular I’m interested by your “enough worker/wrapper functions” comment.</p>\n</blockquote>\n<p>Well if you write <code>Subarray.foldl</code> to be effectively <code>Array.foldl subarray.arr subarray.start subarray.stop</code> and inline that the compiler is smart enough to eliminate the subarray allocation because it is evidently not necessary.</p>",
        "id": 565087989,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1766452712
    },
    {
        "content": "<p>Ah I see. From a pure interface perspective what makes the most sense to me is for Array.foldl to not take start/stop indices but rather to actually be a wrapper around Subarray.foldl (or some common helper function which is where the real logic lives). That way you fully separate slice index validation from fold/map/etc and you don’t have to manually duplicate the same handling across all those functions. But the fact that the definitions of these functions are part of their public interface (and the allocation issue) makes this is challenging, perhaps untenable.</p>\n<p>If foldl/foldr/map/etc really do need to be parameterized by an index, then I think the behavior that’s most consistent with subslice construction behavior in non-dependent typed languages while retaining totality is to clamp the stop  index if it is too large. In my brief survey, the most common behaviors are either   to throw an exception/panic (Rust, Haskell, OCaml, Go, etc) or clamp (Scala, F#, Python, JavaScript, Ruby, Elixir).  I wasn’t able to find any languages that do Array.foldl’s now  consistent behavior of treating an in-bounds start and out of bounds end as an empty array. </p>\n<p>Another option of course would be to force you to provide proofs that start &lt;= end &lt;= array.size but that might be unwieldy.</p>",
        "id": 565092554,
        "sender_full_name": "cmlsharp",
        "timestamp": 1766458271
    },
    {
        "content": "<p>Claude code actually found an issue with the fixed version:<br>\n<a href=\"https://github.com/leanprover/lean4/issues/11778\">https://github.com/leanprover/lean4/issues/11778</a><br>\nBasically, when start &gt;= size and start &lt; stop, this causes a seg fault</p>",
        "id": 565125241,
        "sender_full_name": "GasStationManager",
        "timestamp": 1766482638
    },
    {
        "content": "<p>Great catch. This really makes me think it would be nice to have theorems which prove “arr.size &lt; Usize.size =&gt; arr.foldlM = arr.foldlMUnsafe”.</p>",
        "id": 565158740,
        "sender_full_name": "cmlsharp",
        "timestamp": 1766497436
    }
]