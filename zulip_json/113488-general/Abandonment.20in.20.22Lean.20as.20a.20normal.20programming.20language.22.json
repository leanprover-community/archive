[
    {
        "content": "<p>When using Lean as \"just an improved Haskell\", I wish that I could \"abandon\" when I detect a bug, in the sense of <a href=\"https://joeduffyblog.com/2016/02/07/the-error-model/#bugs-arent-recoverable-errors\">https://joeduffyblog.com/2016/02/07/the-error-model/#bugs-arent-recoverable-errors</a>.</p>\n<p>The advantage to abandonment as opposed to returning <code>Option a</code> is that it gives me a good stack trace that I can use to start debugging. Is there a way of doing this in lean? So far what I've seen requires the return type to implement <code>Inhabited</code>.</p>",
        "id": 535195771,
        "sender_full_name": "Owen Lynch",
        "timestamp": 1755633913
    },
    {
        "content": "<p>Perhaps the solution would be to have something like a typeclass <code>MonadPanic</code> which could be used for code whose correctness is not yet proved, and which intends to abandon on bug detection.</p>",
        "id": 535195922,
        "sender_full_name": "Owen Lynch",
        "timestamp": 1755633985
    },
    {
        "content": "<p>In a similar vein, are there projects to get Dafny-style program verification in Lean? It would be useful to have a \"gradual typing\" approach to program verification, where one can choose to dynamically assert conditions which are not yet proven to hold.</p>",
        "id": 535196146,
        "sender_full_name": "Owen Lynch",
        "timestamp": 1755634085
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"949772\">Owen Lynch</span> <a href=\"#narrow/channel/113488-general/topic/Abandonment.20in.20.22Lean.20as.20a.20normal.20programming.20language.22/near/535195922\">said</a>:</p>\n<blockquote>\n<p>Perhaps the solution would be to have something like a typeclass <code>MonadPanic</code> which could be used for code whose correctness is not yet proved, and which intends to abandon on bug detection.</p>\n</blockquote>\n<p>We have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Alternative#doc\">docs#Alternative</a> which gives you recoverable errors</p>",
        "id": 535196486,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755634249
    },
    {
        "content": "<p>We have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MonadExcept#doc\">docs#MonadExcept</a> which gives you catchable errors</p>",
        "id": 535197194,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755634590
    },
    {
        "content": "<p>I unfortunately don't see any \"monad unrecoverable error\"</p>",
        "id": 535197283,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755634628
    },
    {
        "content": "<p>but if your monad implements <code>Inhabited</code> then you can just use <code>panic!</code></p>",
        "id": 535197317,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755634642
    },
    {
        "content": "<p>Lean has <code>panic!</code> to abandon a computation</p>",
        "id": 535203787,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1755637754
    },
    {
        "content": "<p>You can also use <code>if h : p then ... else panic! \"error\"</code> for getting access to a proof of <code>h</code> in the success branch.</p>",
        "id": 535203938,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1755637846
    },
    {
        "content": "<p>It doesn't actually abandon though unless you set the right environment variable</p>",
        "id": 535208420,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1755640519
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"949772\">Owen Lynch</span> <a href=\"#narrow/channel/113488-general/topic/Abandonment.20in.20.22Lean.20as.20a.20normal.20programming.20language.22/near/535196146\">said</a>:</p>\n<blockquote>\n<p>In a similar vein, are there projects to get Dafny-style program verification in Lean? It would be useful to have a \"gradual typing\" approach to program verification, where one can choose to dynamically assert conditions which are not yet proven to hold.</p>\n</blockquote>\n<p>Have you seen <a class=\"message-link\" href=\"/#narrow/channel/236449-Program-verification/topic/Monadic.20program.20logic.3A.20Request.20for.20feedback/near/499713950\">#Program verification &gt; Monadic program logic: Request for feedback @ ðŸ’¬</a>  already?</p>",
        "id": 535312363,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1755695924
    },
    {
        "content": "<p>What environment variable do you need to set to abort on panics? Coming from Rust, I found it quite unintuitive that panics don't kill the process.</p>",
        "id": 535546045,
        "sender_full_name": "Paul Biberstein",
        "timestamp": 1755796262
    },
    {
        "content": "<p>Nevermind, see this discussion <a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/channel/113488-general/topic/lean.204.20and.20panics/with/489552217\">#general &gt; lean 4 and panics</a></p>",
        "id": 535546810,
        "sender_full_name": "Paul Biberstein",
        "timestamp": 1755796615
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/113488-general/topic/Abandonment.20in.20.22Lean.20as.20a.20normal.20programming.20language.22/near/535197317\">said</a>:</p>\n<blockquote>\n<p>but if your monad implements <code>Inhabited</code> then you can just use <code>panic!</code></p>\n</blockquote>\n<p>Ah, this is perhaps the most reasonable strategy: it's annoying to have to make all of my types <code>Inhabited</code>, but it is a good idea to make the monad implement <code>Inhabited</code>. Especially because I'm already using <code>MonadExcept Unit</code> for expected kinds of errors.</p>",
        "id": 535573257,
        "sender_full_name": "Owen Lynch",
        "timestamp": 1755807776
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/channel/113488-general/topic/Abandonment.20in.20.22Lean.20as.20a.20normal.20programming.20language.22/near/535312363\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"949772\">Owen Lynch</span> <a href=\"#narrow/channel/113488-general/topic/Abandonment.20in.20.22Lean.20as.20a.20normal.20programming.20language.22/near/535196146\">said</a>:</p>\n<blockquote>\n<p>In a similar vein, are there projects to get Dafny-style program verification in Lean? It would be useful to have a \"gradual typing\" approach to program verification, where one can choose to dynamically assert conditions which are not yet proven to hold.</p>\n</blockquote>\n<p>Have you seen <a class=\"message-link\" href=\"/#narrow/channel/236449-Program-verification/topic/Monadic.20program.20logic.3A.20Request.20for.20feedback/near/499713950\">#Program verification &gt; Monadic program logic: Request for feedback @ ðŸ’¬</a>  already?</p>\n</blockquote>\n<p>This looks quite cool!</p>",
        "id": 535573507,
        "sender_full_name": "Owen Lynch",
        "timestamp": 1755807901
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"949772\">Owen Lynch</span> <a href=\"#narrow/channel/113488-general/topic/Abandonment.20in.20.22Lean.20as.20a.20normal.20programming.20language.22/near/535573257\">said</a>:</p>\n<blockquote>\n<p>it's annoying to have to make all of my types <code>Inhabited</code></p>\n</blockquote>\n<p>Are you using <code>deriving Inhabited</code>?</p>",
        "id": 535576680,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1755809404
    }
]