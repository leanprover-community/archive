[
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Functoriality.20of.20finset/near/265811687\">said</a>:</p>\n<blockquote>\n<p>For <a href=\"https://github.com/leanprover-community/mathlib/pull/10955\">#10955</a>, I need the fact that <code>finset</code> is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/alternative\">docs#alternative</a>. It seems like the only ingredients we have in that direction are <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.is_lawful_functor\">docs#finset.is_lawful_functor</a> and <a href=\"https://tqft.net/mathlib/src/data/multiset/functor\">file#src/data/multiset/functor</a>.lean. Am I right?</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Functoriality.20of.20finset/near/265812724\">said</a>:</p>\n<blockquote>\n<p>I'm thinking this might end up being noncomputable, because the obvious choice for <code>or_else</code> is <code>insert</code> (using the list version for reference) and that requires decidability, for which there's no way to accept a <code>decidable</code> instance</p>\n</blockquote>\n<p>Given that one of the main uses of the monadic stuff seems to be for actually writing executable meta code, it seems awfully unfortunate that the typeclass design doesn't allow a computable instance here</p>",
        "id": 265813573,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1640184956
    },
    {
        "content": "<p>Indeed, it would be an amazing function if we could somehow restrict the quantification of classes. Here, we have that <code>finset</code> is (computably) applicative, but only if there's <code>decidable_eq</code> on the parameter to <code>finset</code>. Similarly, I would love to just write <code>instance : monoid_hom_class ring_hom</code> but this only holds under the assumption that the domain and codomain are rings. And I think a lot of the category theory library could do without bundling.</p>",
        "id": 265813758,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1640185075
    },
    {
        "content": "<p>One way to fix this monadic stuff (both in terms of extra assumptions, and in terms of universe polymorphism) might be to change the classes to:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">functor'</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">out_param</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fα</span> <span class=\"n\">fβ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">fα</span> <span class=\"bp\">→</span> <span class=\"n\">fβ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">map_const</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">fα</span> <span class=\"bp\">→</span> <span class=\"n\">fβ</span> <span class=\"o\">:=</span> <span class=\"n\">map</span> <span class=\"bp\">∘</span> <span class=\"n\">function.const</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">functor'</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"n\">list.map</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>It wasn't immediately obvious whether this would work for the full heirarchy of classes</p>",
        "id": 265815648,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1640186188
    },
    {
        "content": "<p>Or even using <code>out_param</code> to avoid some verbosity:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- this name is lousy!</span>\n<span class=\"kd\">class</span> <span class=\"n\">is_monadic</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">out_param</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fα</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">is_monadic</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">is_monadic.mk</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">functor'</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">out_param</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">fα</span> <span class=\"n\">fβ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_monadic</span> <span class=\"n\">α</span> <span class=\"n\">fα</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_monadic</span> <span class=\"n\">β</span> <span class=\"n\">fβ</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">fα</span> <span class=\"bp\">→</span> <span class=\"n\">fβ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">map_const</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">fα</span> <span class=\"bp\">→</span> <span class=\"n\">fβ</span> <span class=\"o\">:=</span> <span class=\"n\">map</span> <span class=\"bp\">∘</span> <span class=\"n\">function.const</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">functor'</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"n\">list.map</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 265816021,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1640186394
    },
    {
        "content": "<p>Hmm, <code>is_monadic</code> reminds me of implementing <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.bundled\">docs#category_theory.bundled</a> but in the class-sublanguage</p>",
        "id": 265816223,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1640186512
    },
    {
        "content": "<p>I explored this a little more in <a href=\"https://github.com/leanprover-community/mathlib/tree/eric-wieser/monad-universes\">branch#eric-wieser/monad-universes</a>, all the way up to <code>applicative</code></p>",
        "id": 265819797,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1640188440
    },
    {
        "content": "<p>(I split this to a new thread)</p>",
        "id": 265959513,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1640298832
    },
    {
        "content": "<p>How is it going?</p>",
        "id": 265960049,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1640299368
    },
    {
        "content": "<p>Something I noticed is that <code>multiset</code> does not have a <a href=\"https://leanprover-community.github.io/mathlib_docs/find/traversable\">docs#traversable</a> instance because it does not commute with all applicative functors, but only all commutative applicative functors. <code>data.multiset.functor</code> currently contains the guts of what could be <code>traversable multiset</code> where it not for this problem. Should we thus change <code>traversable</code>to take in a specific functor?</p>",
        "id": 265960167,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1640299495
    },
    {
        "content": "<p>It's not really a problem. <code>traversable</code> is about things you can iterate over in a fixed order, <code>multiset</code> doesn't have an order, so there is no <code>traversable multiset</code>--that's just the way it is.</p>",
        "id": 265961373,
        "sender_full_name": "Reid Barton",
        "timestamp": 1640300737
    }
]