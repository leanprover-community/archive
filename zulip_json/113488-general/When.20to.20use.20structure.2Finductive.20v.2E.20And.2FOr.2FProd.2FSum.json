[
    {
        "content": "<p>When defining a relatively simple type that is just the product or sum of other types, when should I use <code>structure</code> or <code>inductive</code> as opposed to just using <code>And</code>/<code>Prod</code> or <code>Or</code>/<code>Sum</code>? For more complicated types, it makes sense to use the former, but I see some inconsistency on simpler things like <code>Iff</code> (which uses <code>structure</code>) and <code>Function.Bijective</code> (which uses <code>And</code>).<br>\nSide note: would it be accurate to call types defined like <code>Function.Bijective</code> as \"anonymous types\"?</p>",
        "id": 462407330,
        "sender_full_name": "Ricardo Prado Cunha",
        "timestamp": 1723664545
    },
    {
        "content": "<p>The nice thing with structure compared to <code>And</code> in this case is that you get to name the components.</p>",
        "id": 462408385,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1723665053
    },
    {
        "content": "<p>Yeah, that's another advantage. I'm asking this since I'm going to be teaching Lean to some students, and I want to get ahead of any \"when should we use <code>And</code> v. defining our own <code>structure</code>\" questions. I guess I'll just say that they should use non-anonymous types for things that show up often and anonymous types for quick things like <code>Exists</code> predicates.</p>",
        "id": 462430939,
        "sender_full_name": "Ricardo Prado Cunha",
        "timestamp": 1723677330
    },
    {
        "content": "<p>Also, <code>Or</code> for things that return a disjunction, though I'll make sure to tell them that in the case of arguments they should just stick to have them being separate arguments (for <code>And</code>) or separate theorems (for <code>Or</code>, unless the combinatorics start getting out of hand).</p>",
        "id": 462431149,
        "sender_full_name": "Ricardo Prado Cunha",
        "timestamp": 1723677427
    },
    {
        "content": "<p>Please let me know if anyone has different opinions on this. I'm also just debating letting them try them out and figure out what they like on their own.</p>",
        "id": 462431222,
        "sender_full_name": "Ricardo Prado Cunha",
        "timestamp": 1723677478
    },
    {
        "content": "<p>I think it's usually better to use a <code>structure</code> for the reason Patrick mentions. Plus, if you use <code>@[mk_iff]</code> you get a rw lemma to transform between the two for free:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">mk_iff</span><span class=\"kd\">]</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">MyProperty</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">5</span>\n<span class=\"w\">  </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">k</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">myProperty_iff</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">myProperty_iff (n : ℕ) : MyProperty n ↔ n &gt; 5 ∧ ∃ k ≤ n, n ∣ 2 * k</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 462436080,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1723680515
    },
    {
        "content": "<p><code>@[mk_iff]</code> works for <code>inductive</code> too</p>",
        "id": 462436131,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1723680567
    },
    {
        "content": "<p>As soon as you have three fields, using <code>And</code> twice and ending up with <code>.1</code>, <code>.2.1</code>, and <code>.2.2</code> is much less appealing than defining your own thing and ending up with <code>.p</code>, <code>.q</code>, and <code>.r</code></p>",
        "id": 462436138,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1723680573
    },
    {
        "content": "<p>You can of course define <code>theorem MyType.r (h : MyType) := p.2.2</code> etc though, so this isn't a major reason</p>",
        "id": 462436231,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1723680623
    },
    {
        "content": "<p>In programming, there's a similar tension between setting up the boilerplate to make things nice with a <code>structure</code>/<code>inductive</code>, and just using <code>Prod</code> and <code>Sum</code> (which are direct analogues of <code>And</code> and <code>Or</code>).</p>",
        "id": 462436300,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1723680665
    }
]