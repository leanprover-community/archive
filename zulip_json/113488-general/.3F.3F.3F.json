[
    {
        "content": "<p>What am I supposed to investigate when Lean complains that</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">application</span>\n  <span class=\"n\">eq</span> <span class=\"o\">(</span><span class=\"n\">fderiv</span> <span class=\"err\">𝕜</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">),</span> <span class=\"mi\">0</span><span class=\"o\">))</span>\n<span class=\"n\">term</span>\n  <span class=\"n\">fderiv</span> <span class=\"err\">𝕜</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">),</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"err\">𝕜</span><span class=\"o\">]</span> <span class=\"n\">continuous_multilinear_map</span> <span class=\"err\">𝕜</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"n\">F</span><span class=\"o\">)</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"err\">𝕜</span><span class=\"o\">]</span> <span class=\"n\">continuous_multilinear_map</span> <span class=\"err\">𝕜</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"n\">F</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>and when the output with <code>pp.all</code> makes 174 lines, but still exactly identical between the type and the expected type?</p>",
        "id": 187754292,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1581244621
    },
    {
        "content": "<p>Can you try and get <code>convert</code> to tell you more information?</p>",
        "id": 187754393,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1581244805
    },
    {
        "content": "<p>I spent some time staring at <code>pp.all</code> output yesterday convinced that two terms were defeq, but it turned out that an errant <code>have</code> instead of <code>let</code> meant that some definition had been forgotten. The terms didn't look identical though. <code>pp.all</code> still gives you some <code>...</code> sometimes, right?</p>",
        "id": 187754403,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1581244863
    },
    {
        "content": "<p>I can not use <code>convert</code> in this situation. The offending line is</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">fderiv</span> <span class=\"err\">𝕜</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">[</span><span class=\"bp\">×</span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"err\">𝕜</span><span class=\"o\">]</span> <span class=\"n\">F</span><span class=\"o\">)))</span>\n      <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"err\">𝕜</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">[</span><span class=\"bp\">×</span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"err\">𝕜</span><span class=\"o\">]</span> <span class=\"n\">F</span><span class=\"o\">)))</span> <span class=\"o\">:=</span> <span class=\"n\">fderiv_const</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n</pre></div>\n\n\n<p>where Lean complains that the left and right hand side don't have the same type, although with <code>pp.all</code> the two types it gives to me are the same.</p>\n<p>I got away with</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">let</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"n\">fderiv</span> <span class=\"err\">𝕜</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">[</span><span class=\"bp\">×</span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"err\">𝕜</span><span class=\"o\">]</span> <span class=\"n\">F</span><span class=\"o\">))),</span>\n<span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"err\">𝕜</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">[</span><span class=\"bp\">×</span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"err\">𝕜</span><span class=\"o\">]</span> <span class=\"n\">F</span><span class=\"o\">)))</span> <span class=\"o\">:=</span> <span class=\"n\">fderiv_const</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n<span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n</pre></div>",
        "id": 187756923,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1581250569
    },
    {
        "content": "<p>If you really want to see if/how the types of the terms differ, you can compare the raw expr structures. Something like this; replace <code>f 0</code> with one side of the equality.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">open</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"o\">(</span><span class=\"n\">do</span> <span class=\"n\">e</span> <span class=\"err\">←</span> <span class=\"n\">to_expr</span> <span class=\"bp\">```</span><span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">infer_type</span><span class=\"o\">,</span> <span class=\"n\">trace</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">to_raw_fmt</span><span class=\"o\">),</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 187757930,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1581252796
    },
    {
        "content": "<p>I bet Gauss never had to do this</p>",
        "id": 187765189,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1581267305
    }
]