[
    {
        "content": "<p>I want to define an instance <code>BEq Type</code>, as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"w\"> </span><span class=\"n\">Term</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Is there a good definition of (bool) equality for types?</span>\n<span class=\"w\">  </span><span class=\"n\">beq</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">isNat</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">false</span>\n\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">alias_Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">myNat</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">myNat</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">myNat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">myNat</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">isNat</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\">         </span><span class=\"c1\">-- true</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">isNat</span><span class=\"w\"> </span><span class=\"n\">alias_Nat</span><span class=\"w\">   </span><span class=\"c1\">-- **false**. I want it to be **false**</span>\n<span class=\"w\">                        </span><span class=\"c1\">-- because it may makes the question simpler.</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">isNat</span><span class=\"w\"> </span><span class=\"n\">myNat</span><span class=\"w\">       </span><span class=\"c1\">-- **false**. For simplicity's sake, let's</span>\n<span class=\"w\">                        </span><span class=\"c1\">-- not consider isomorphism or anything like that.</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">isNat</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\">      </span><span class=\"c1\">-- false</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">isNat</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- false</span>\n</code></pre></div>\n<p>Returns <code>false</code> in all cases except <code>isNat Nat</code> which returns <code>true</code>.</p>\n<h3>Question:</h3>\n<ul>\n<li>Can we define such a <strong>pure</strong> <code>isNat</code>?</li>\n<li>Or we have to do this in meta-programming?</li>\n<li>Or we can not do this at all?</li>\n</ul>",
        "id": 484033629,
        "sender_full_name": "White Chen",
        "timestamp": 1732338961
    },
    {
        "content": "<h3>Motivation</h3>\n<p>Although <strong>it's not directly related to my question</strong>, but in case it is helpful to answer:</p>\n<p>My initial motivation was to define a function that, when p is actually in the form of <code>?a ∧ ?b</code>, returns <code>?a</code> and <code>?b</code>, else returns none.</p>\n<p>I want to do this because I am following <code>Handbook of Practical Logic and Automated Reasoning</code>, which has a <strong>OCaml</strong> code snip:</p>\n<div class=\"codehilite\" data-code-language=\"OCaml\"><pre><span></span><code><span class=\"c\">(*</span>\n<span class=\"c\">There are codes about define the `Formula` and parser about it,</span>\n<span class=\"c\">Therefore, I believe it is fair to allow the implementation of this</span>\n<span class=\"c\">function in the meta-programming environment of Lean.</span>\n<span class=\"c\">*)</span>\n<span class=\"k\">let</span> <span class=\"n\">dest_and</span> <span class=\"n\">fm</span> <span class=\"o\">=</span>\n  <span class=\"k\">match</span> <span class=\"n\">fm</span> <span class=\"k\">with</span> <span class=\"nc\">And</span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">,</span><span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">,</span><span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">|</span> <span class=\"o\">_</span> <span class=\"o\">-&gt;</span> <span class=\"n\">failwith</span> <span class=\"s2\">\"dest_and\"</span><span class=\"o\">;;</span>\n</code></pre></div>\n<p>And I want to do the same in Lean.<br>\nTo do this, I think I should first be able to decide a prop is in specified form or not.<br>\nSo I construct the function <code>isNat</code> given above.<br>\nI know the axiom <code>propext</code>, So I'm going to determine if it's of the form <code>p ∧ q</code> directly (and only ) in terms of syntactic structure.</p>\n<p>Or maybe I should do this in meta-programming, using <code>Expr</code> for example ?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- return `some (p,q)` if `p` is something like `p ∧ q`</span>\n<span class=\"c1\">-- return `none` otherwise</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">split_and?</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 484033795,
        "sender_full_name": "White Chen",
        "timestamp": 1732339117
    },
    {
        "content": "<p>Equality of <code>Nat</code> and <code>Int</code> is undecidable in lean meta theory (AFAIK).</p>",
        "id": 484035400,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1732340910
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/channel/113488-general/topic/Can.20we.20define.20.60BEq.60.20instance.20for.20.60Type.60.3F/near/484035400\">said</a>:</p>\n<blockquote>\n<p>Equality of <code>Nat</code> and <code>Int</code> is undecidable in lean meta theory (AFAIK).</p>\n</blockquote>\n<p>I know that in Lean's meta-programming, we can determine if an <code>Expr</code> has the desired structure by <code>Lean.Expr.appFn</code>.</p>\n<p>But can we implement a <strong>pure function</strong> that determines solely from the syntax whether a <code>Prop</code> has the form <code>?p and ?q</code>? Just like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">likeAnd</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">t1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">q</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">t2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\">  </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"n\">q</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">likeAnd</span><span class=\"w\"> </span><span class=\"n\">t1</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">likeAnd</span><span class=\"w\"> </span><span class=\"n\">t2</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"n\">false</span>\n</code></pre></div>",
        "id": 484037030,
        "sender_full_name": "White Chen",
        "timestamp": 1732342606
    },
    {
        "content": "<p>If that's the case, then the only (or the best) way to reproduce the OCaml example I mentioned above would be to define an inductive type <code>Formula</code> (<code>Formula</code> is equal to <code>Prop</code> in that example), and then use a <code>match</code> statement. <br>\nAnd that would be closer to the OCaml example than using <code>Prop</code> from Lean instead of defining <code>Formula</code> by myself.</p>",
        "id": 484037278,
        "sender_full_name": "White Chen",
        "timestamp": 1732342817
    },
    {
        "content": "<p>No, propositionally equal <code>Prop</code>s are equal in lean.</p>",
        "id": 484038384,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1732343953
    },
    {
        "content": "<p>Oh this is basically the same as <a href=\"#narrow/channel/113488-general/topic/stupid.20question.3A.20.60Nat.20.3D.20String.60.3F\">#general&gt;stupid question: &#96;Nat = String&#96;?</a> <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span></p>",
        "id": 484055594,
        "sender_full_name": "Jz Pan",
        "timestamp": 1732360410
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"366779\">Jz Pan</span> <a href=\"#narrow/channel/113488-general/topic/Can.20we.20define.20.60BEq.60.20instance.20for.20.60Type.60.3F/near/484055594\">said</a>:</p>\n<blockquote>\n<p>Oh this is basically the same as <a href=\"#narrow/channel/113488-general/topic/stupid.20question.3A.20.60Nat.20.3D.20String.60.3F\">#general&gt;stupid question: &#96;Nat = String&#96;?</a> <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span></p>\n</blockquote>\n<p>Well, the <code>BEq</code> I want here is actually <strong>determine by <code>Name</code></strong>. <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span> <br>\nSo, regardless of what the two definitions are actually, only determine whether their names are the same.</p>",
        "id": 484056406,
        "sender_full_name": "White Chen",
        "timestamp": 1732360916
    },
    {
        "content": "<p>That's <code>unsafe</code>, because you can't have <code>x == y</code> and <code>x != z</code> and <code>y = z</code> without a contradiction</p>",
        "id": 484056503,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1732360997
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"670422\">White Chen</span> <a href=\"#narrow/channel/113488-general/topic/Can.20we.20define.20.60BEq.60.20instance.20for.20.60Type.60.3F/near/484056406\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"366779\">Jz Pan</span> <a href=\"#narrow/channel/113488-general/topic/Can.20we.20define.20.60BEq.60.20instance.20for.20.60Type.60.3F/near/484055594\">said</a>:</p>\n<blockquote>\n<p>Oh this is basically the same as <a href=\"#narrow/channel/113488-general/topic/stupid.20question.3A.20.60Nat.20.3D.20String.60.3F\">#general&gt;stupid question: &#96;Nat = String&#96;?</a> <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span></p>\n</blockquote>\n<p>Well, the <code>BEq</code> I want here is actually <strong>determine by <code>Name</code></strong>. <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span> <br>\nSo, regardless of what the two definitions are actually, only determine whether their names are the same.</p>\n</blockquote>\n<p>But it doesn't matter, I've solved the original problem that led to this question.</p>",
        "id": 484056515,
        "sender_full_name": "White Chen",
        "timestamp": 1732361013
    },
    {
        "content": "<p>Also, <code>==</code> is usually used for <em>runtime</em> concepts, not for proving; but at runtime, all types are erased and therefore all have the same representation in memory</p>",
        "id": 484056821,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1732361254
    },
    {
        "content": "<p>You can see this with <code>#eval unsafe ptrAddrUnsafe Nat</code>; all the types refer to the dummy address 1, and so there is no data to distinguish them by</p>",
        "id": 484056883,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1732361308
    },
    {
        "content": "<blockquote>\n<p><strong>determine by <code>Name</code></strong></p>\n</blockquote>\n<p>I think this should be possible, but it's not defined in Lean's logic system, but defined via tactic metaprogramming or something like that, you need to access something in <code>Lean</code> namespace...</p>",
        "id": 484056925,
        "sender_full_name": "Jz Pan",
        "timestamp": 1732361360
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"670422\">White Chen</span> has marked this topic as resolved.</p>",
        "id": 484058066,
        "sender_full_name": "Notification Bot",
        "timestamp": 1732362365
    },
    {
        "content": "<p>As others have said, this is not something you can do at the value level, but your OCaml example isn't operating at the value level, but the meta level. The Formula type isn't Prop itself right? It's formulae? In that case the analogue would be <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Expr#doc\">docs#Lean.Expr</a>, not Prop, and this and-deconstruction function exists as <a href=\"https://github.com/leanprover/lean4/blob/7dc1ceb8d4312850b39cef9e751e0a3b651946e3/src/Lean/Util/Recognizers.lean#L64-L65\"><code>Lean.Expr.and?</code></a>.</p>",
        "id": 484086020,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1732386950
    },
    {
        "content": "<p>What about this <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span><span class=\"w\"> </span><span class=\"n\">IHaveAName</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span>\n\n<span class=\"kd\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IHaveAName</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">⟨</span><span class=\"s2\">\"Nat\"</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IHaveAName</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">⟨</span><span class=\"s2\">\"Int\"</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IHaveAName</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">⟨</span><span class=\"s2\">\"String\"</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IHaveAName</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IHaveAName</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">⟨</span><span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"Array ({IHaveAName.name T})\"</span><span class=\"o\">⟩</span>\n\n<span class=\"k\">#eval</span><span class=\"w\"> </span><span class=\"n\">IHaveAName.name</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"o\">))</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">isTypeEq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T1</span><span class=\"w\"> </span><span class=\"n\">T2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IHaveAName</span><span class=\"w\"> </span><span class=\"n\">T1</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IHaveAName</span><span class=\"w\"> </span><span class=\"n\">T2</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">IHaveAName.name</span><span class=\"w\"> </span><span class=\"n\">T1</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"n\">IHaveAName.name</span><span class=\"w\"> </span><span class=\"n\">T2</span>\n\n<span class=\"k\">#eval</span><span class=\"w\"> </span><span class=\"n\">isTypeEq</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n\n<span class=\"k\">#eval</span><span class=\"w\"> </span><span class=\"n\">isTypeEq</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n\n<span class=\"n\">abbrev</span><span class=\"w\"> </span><span class=\"n\">alias_Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n\n<span class=\"k\">#eval</span><span class=\"w\"> </span><span class=\"n\">isTypeEq</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"n\">alias_Nat</span>\n</code></pre></div>",
        "id": 484219307,
        "sender_full_name": "Jz Pan",
        "timestamp": 1732516669
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"366779\">Jz Pan</span> <a href=\"#narrow/channel/113488-general/topic/.E2.9C.94.20Can.20we.20define.20.60BEq.60.20instance.20for.20.60Type.60.3F/near/484219307\">said</a>:</p>\n<blockquote>\n<p>What about this <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span></p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span><span class=\"w\"> </span><span class=\"n\">IHaveAName</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span>\n\n<span class=\"kd\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IHaveAName</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">⟨</span><span class=\"s2\">\"Nat\"</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IHaveAName</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">⟨</span><span class=\"s2\">\"Int\"</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IHaveAName</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">⟨</span><span class=\"s2\">\"String\"</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IHaveAName</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IHaveAName</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">⟨</span><span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"Array ({IHaveAName.name T})\"</span><span class=\"o\">⟩</span>\n\n<span class=\"k\">#eval</span><span class=\"w\"> </span><span class=\"n\">IHaveAName.name</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"o\">))</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">isTypeEq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T1</span><span class=\"w\"> </span><span class=\"n\">T2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IHaveAName</span><span class=\"w\"> </span><span class=\"n\">T1</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IHaveAName</span><span class=\"w\"> </span><span class=\"n\">T2</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">IHaveAName.name</span><span class=\"w\"> </span><span class=\"n\">T1</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"n\">IHaveAName.name</span><span class=\"w\"> </span><span class=\"n\">T2</span>\n\n<span class=\"k\">#eval</span><span class=\"w\"> </span><span class=\"n\">isTypeEq</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n\n<span class=\"k\">#eval</span><span class=\"w\"> </span><span class=\"n\">isTypeEq</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n\n<span class=\"n\">abbrev</span><span class=\"w\"> </span><span class=\"n\">alias_Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n\n<span class=\"k\">#eval</span><span class=\"w\"> </span><span class=\"n\">isTypeEq</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"n\">alias_Nat</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>It might be more \"elegant\" if we had something like <code>deriving IHaveAName</code>? <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span></p>",
        "id": 484219817,
        "sender_full_name": "White Chen",
        "timestamp": 1732517015
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"670422\">White Chen</span> <a href=\"#narrow/channel/113488-general/topic/.E2.9C.94.20Can.20we.20define.20.60BEq.60.20instance.20for.20.60Type.60.3F/near/484219817\">said</a>:</p>\n<blockquote>\n<p>It might be more \"elegant\" if we had something like <code>deriving IHaveAName</code>? <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span></p>\n</blockquote>\n<p>Yes, but I don't know how to write such meta code...</p>",
        "id": 484220176,
        "sender_full_name": "Jz Pan",
        "timestamp": 1732517257
    },
    {
        "content": "<p><code>ToExpr</code> would probably work just as well here, with the benefit that you can also use it to distinguish <code>Fin 2</code> from <code>Fin 3</code>, and the derive handler already exists</p>",
        "id": 484416317,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1732582722
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/113488-general/topic/.E2.9C.94.20Can.20we.20define.20.60BEq.60.20instance.20for.20.60Type.60.3F/near/484416317\">said</a>:</p>\n<blockquote>\n<p><code>ToExpr</code> would probably work just as well here, with the benefit that you can also use it to distinguish <code>Fin 2</code> from <code>Fin 3</code>, and the derive handler already exists</p>\n</blockquote>\n<p>Thank you! This code works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean.ToExpr</span>\n\n<span class=\"kd\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">isTypeEq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Lean.ToExpr</span><span class=\"w\"> </span><span class=\"n\">T1</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Lean.ToExpr</span><span class=\"w\"> </span><span class=\"n\">T2</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Lean.ToExpr.toTypeExpr</span><span class=\"w\"> </span><span class=\"n\">T1</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"n\">Lean.ToExpr.toTypeExpr</span><span class=\"w\"> </span><span class=\"n\">T2</span>\n\n<span class=\"k\">#eval</span><span class=\"w\"> </span><span class=\"n\">Lean.ToExpr.toTypeExpr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"o\">))</span>\n\n<span class=\"k\">#eval</span><span class=\"w\"> </span><span class=\"n\">isTypeEq</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n\n<span class=\"k\">#eval</span><span class=\"w\"> </span><span class=\"n\">isTypeEq</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n\n<span class=\"k\">#eval</span><span class=\"w\"> </span><span class=\"n\">isTypeEq</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"n\">String</span>\n\n<span class=\"n\">abbrev</span><span class=\"w\"> </span><span class=\"n\">alias_Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n\n<span class=\"k\">#eval</span><span class=\"w\"> </span><span class=\"n\">isTypeEq</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"n\">alias_Nat</span>\n\n<span class=\"k\">#eval</span><span class=\"w\"> </span><span class=\"n\">isTypeEq</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"n\">PUnit</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- oops, this doesn't work</span>\n<span class=\"k\">#eval</span><span class=\"w\"> </span><span class=\"n\">isTypeEq</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"n\">PUnit</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">2</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 484440642,
        "sender_full_name": "Jz Pan",
        "timestamp": 1732601162
    },
    {
        "content": "<p>Note that implementing <code>==</code> itself is still impossible though, drive you can't smuggle in any extra typeclass data there</p>",
        "id": 484475243,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1732615514
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/113488-general/topic/.E2.9C.94.20Can.20we.20define.20.60BEq.60.20instance.20for.20.60Type.60.3F/near/484475243\">said</a>:</p>\n<blockquote>\n<p>Note that implementing <code>==</code> itself is still impossible though, drive you can't smuggle in any extra typeclass data there</p>\n</blockquote>\n<p>This is reasonable, since <code>Type</code> itself by default is not comparable, only <code>Type</code>s which allow them being comparable (i.e. implements <code>Lean.ToExpr</code> or something similar) can be compared.</p>",
        "id": 484640437,
        "sender_full_name": "Jz Pan",
        "timestamp": 1732682959
    }
]