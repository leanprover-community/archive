[
    {
        "content": "<p>I would like to use <code>•</code> as an infix left associative operator, but I am unable to successfully override the notation associated with the <code>Mathlib.Algebra.Group.Defs.HSMul</code> class, which  specifies <code>•</code> to be right associative. Here's an example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Part</span><span class=\"w\"> </span><span class=\"c1\">-- this is what I actually import</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">HasApp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">C</span>\n\n<span class=\"kn\">infixl</span><span class=\"o\">:</span><span class=\"mi\">73</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">priority</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">high</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"s2\">\" • \"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">HasApp</span><span class=\"bp\">.</span><span class=\"n\">app</span>\n\n<span class=\"kn\">macro_rules</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">HasApp</span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">HasApp</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- works</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- HSMul still kicks in,  why?</span>\n</code></pre></div>",
        "id": 481505519,
        "sender_full_name": "Andrej Bauer",
        "timestamp": 1731195892
    },
    {
        "content": "<p>Why not use one of the 37 other dots which unicode has to offer?</p>",
        "id": 481506423,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1731196672
    },
    {
        "content": "<p>My initial thought was that macro was redundant and using it produced a right infix operator. But this issue persists even after removing it</p>",
        "id": 481506469,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1731196689
    },
    {
        "content": "<p>The macro is still redundant</p>",
        "id": 481506472,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1731196696
    },
    {
        "content": "<p>The macro feels redundant, it's just an attempt.<br>\n<span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> : I think I will in fact  use one of the other dotst, but I'd like to understand why the code isn't working (I am currently wearing mu computer science hat).</p>",
        "id": 481506521,
        "sender_full_name": "Andrej Bauer",
        "timestamp": 1731196775
    },
    {
        "content": "<p>Yeah I am also curious to find out what's happening</p>",
        "id": 481506659,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1731196856
    },
    {
        "content": "<p>When parsing the term beginning at <code>a</code>, the infixr notation allows us to parse all of <code>a • b • c</code> while the infixl notation stops after <code>b</code> with the remainder left to be parsed by any \"trailing\" parsers, as in Pratt's algorithm. At this point, the Lean parser commits to the first interpretation as per the \"local longest parse\" rule briefly mentioned at <a href=\"https://lean-lang.org/lean4/doc/notation.html\">https://lean-lang.org/lean4/doc/notation.html</a>.</p>\n<p>This right-leaning bias inherited by Pratt parsing is of course an implementation detail that ideally would not be exposed to users. The current local longest parse rule has been designed before we added a packrat-like parser cache, we might revise it in the future.</p>",
        "id": 481557791,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1731241959
    }
]