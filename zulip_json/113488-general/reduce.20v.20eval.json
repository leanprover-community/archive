[
    {
        "content": "<p>I never use <code>#reduce</code> or <code>#eval</code> but I'm about to do a demo in front of a bunch of computer scientists and I noticed this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">KCL</span><span class=\"w\"> </span><span class=\"c1\">-- so as not to clash with `List` in root namespace</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">List</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"mi\">37</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">reduce</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"c1\">-- cons 2 (cons 37 nil)</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"c1\">-- KCL.List.cons 2 (KCL.List.cons 37 (KCL.List.nil))</span>\n</code></pre></div>\n<p>I was surprised the results were different (and this is somehow confusing). Does <code>#eval</code> not care about namespaces but <code>#reduce</code> does for some reason?</p>",
        "id": 500393499,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1739883104
    },
    {
        "content": "<p>The main difference here is that <code>#reduce</code> is printing an interactive expression, but <code>#eval</code> is printing a string</p>",
        "id": 500394411,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739883354
    },
    {
        "content": "<p>Add a <code>deriving Lean.ToExpr</code>, and they have the same output:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">KCL</span><span class=\"w\"> </span><span class=\"c1\">-- so as not to clash with `List` in root namespace</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">ToExpr</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">List</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"mi\">37</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">reduce</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"c1\">-- cons 2 (cons 37 nil)</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"c1\">-- cons 2 (cons 37 nil)</span>\n</code></pre></div>",
        "id": 500473077,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739899565
    },
    {
        "content": "<p>Oh wow, I didn't know <code>Lean.ToExpr</code> was a deriving handle. This is amazingly useful!<br>\ncc <span class=\"user-mention\" data-user-id=\"432681\">@John Burnham</span></p>",
        "id": 500514043,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1739914086
    },
    {
        "content": "<p>(Thanks to <span class=\"user-mention\" data-user-id=\"481133\">@Alex Keizer</span> for his work to get this into Lean core!)</p>",
        "id": 500724829,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739992739
    },
    {
        "content": "<p>Currently, the reason <code>#eval L</code> worked is that <code>#eval</code> can auto-derive a <code>Repr</code> instance. That frees you from needing to add <code>deriving Repr</code> for a one-off <code>#eval</code>.</p>\n<p>I was thinking of having <code>#eval</code> be able to auto-derive a <code>ToExpr</code> instances as well. I haven't been completely sure whether it would be surprising to use an auto-derived ToExpr instance over a user-defined Repr instance. (I'm sure that there will be a question down the line of \"why isn't my Repr instance being used here?\")</p>",
        "id": 500725518,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739992982
    },
    {
        "content": "<p>isn't a possible solution to that to prefer to use a Repr instance if one can be found, and only then try auto-deriving ToExpr and Repr?</p>",
        "id": 500834335,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1740044413
    },
    {
        "content": "<p>Yeah, that's a possible solution and is under consideration too. That also has the issue where people ask \"why isn't this <code>#eval</code> output hoverable?\" or \"why does this <code>#eval</code> give different-looking output from <code>#reduce</code>\" (I'm less inclined to worry about this last question because of how different the evaluation models are)</p>\n<p>Another thing to throw in is that it would be nice if <code>#eval</code> would add in instances for types that have no representation, with a hover explaining why not (maybe it's a function type) or what instances are missing. There's also the possibility of having recursive derivation too.</p>",
        "id": 500941632,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740075045
    },
    {
        "content": "<p>ideally hoverable #eval output should be addressed by having an even more rich text format class being preferred if available, I guess <code>ToMessageData</code> is the relevant one in this case</p>",
        "id": 500974796,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1740087941
    },
    {
        "content": "<p>maybe it should even be possible to evaluate to a widget, so we can be like mathematica<br>\n<a href=\"/user_uploads/3121/EcTlZ4D_tOk2K6Iyt_Ejj_x2/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/EcTlZ4D_tOk2K6Iyt_Ejj_x2/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"445x468\" src=\"/user_uploads/thumbnail/3121/EcTlZ4D_tOk2K6Iyt_Ejj_x2/image.png/840x560.webp\"></a></div>",
        "id": 500975639,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1740088293
    },
    {
        "content": "<p>I daren't ask what kind of graph product sends two graphs with three vertices to a graph with six vertices...</p>",
        "id": 500977156,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1740088851
    },
    {
        "content": "<p>I think there's a planar immersion failure here...</p>",
        "id": 500977498,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740088985
    },
    {
        "content": "<p>To get something mathematica-like, one approach could be to have a separate Syntax formatting path that outputs something richer. Syntax is basically what Mathematica operates on anyway, so it has to be possible to make a \"<code>StandardForm</code>\" formatter that outputs widgets, maybe in conjunction with some delaborator configuration option to make sure the output Syntax is formattable. (I know this is sort of hacky, but this would let us take advantage of the pre-existing core delaborators.)</p>",
        "id": 500978143,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740089224
    }
]