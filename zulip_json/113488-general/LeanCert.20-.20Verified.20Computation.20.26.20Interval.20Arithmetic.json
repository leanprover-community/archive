[
    {
        "content": "<p>Finally hit v1.0! Full verification, no <code>sorry</code> markers in the core.</p>\n<p><strong>What it does:</strong></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Prove bounds on transcendentals</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">exp</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">interval_bound</span>\n\n<span class=\"c1\">-- Prove root existence (√2)</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">interval_roots</span>\n\n<span class=\"c1\">-- Global optimization</span>\n<span class=\"bp\">#</span><span class=\"n\">minimize</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">sin</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">on</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">]</span>\n</code></pre></div>\n<p><strong>Discovery Mode:</strong> Don't have a bound in mind? Branch-and-bound optimization finds tight constants, then auto-generates the formal proof.</p>\n<p><strong>Fully verified:</strong></p>\n<ul>\n<li>Interval arithmetic (FTIA) for <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>^</code></li>\n<li>Transcendentals: <code>exp</code>, <code>sin</code>, <code>cos</code>, <code>sinh</code>, <code>cosh</code>, <code>tanh</code>, <code>atan</code>, <code>arsinh</code>, <code>log</code></li>\n<li>Taylor remainder bounds (Lagrange form)</li>\n<li>Forward-mode AD</li>\n<li>Global optimization (<code>globalMinimize_lo_correct</code>)</li>\n<li>Root finding: bisection + Newton contraction</li>\n<li>Integration bounds<br>\n<strong>Architecture:</strong> Certificate-driven — reify to AST, compute with rationals, lift to <code>ℝ</code> via golden theorems. All checked by <code>native_decide</code>.</li>\n</ul>\n<p>Also includes a Python SDK for exploration workflows.</p>\n<p><a href=\"https://github.com/alerad/leancert\">https://github.com/alerad/leancert</a></p>\n<p>Feedback, issues, PRs welcome!</p>",
        "id": 567526744,
        "sender_full_name": "Alejandro Radisic",
        "timestamp": 1768223071
    },
    {
        "content": "<p>Finally, interval arithmetics! It sounds great! Just two comments</p>\n<ul>\n<li>I am a bit surprised that <code>sqrt</code> is not a basic function. Does it just work with some default efficient translation? (then I would put it to the examples too)</li>\n<li>As I am aware of some degree of skepticism with <code>native_decide</code>, do you plan to also look into kernel proofs (it could work with <code>decide +kernel</code> but perhaps there is a more optimized way)?</li>\n</ul>",
        "id": 567545480,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1768227354
    },
    {
        "content": "<p>Could you bump up Mathlib version? Or is there some easy way for me to do that locally?</p>",
        "id": 567572586,
        "sender_full_name": "Bbbbbbbbba",
        "timestamp": 1768232952
    },
    {
        "content": "<p>Thanks!</p>\n<p><strong>On sqrt</strong>: You're right, it's not a primitive, it's defined as <code>exp(log(x)/2)</code> so we can reuse the verified Taylor series for exp and log without deriving separate error bounds. It works, but it's slower than it should be.</p>\n<p>Caveat: the automated tactics (<code>interval_bound</code> etc.) don't support sqrt yet because <code>log</code> isn't in the computable core subset (<code>ExprSupportedCore</code>). So while you can use <code>Expr.sqrt</code> in expressions, you can't currently prove bounds on it with the one-liner tactics. Will be working on adding log/sqrt in these days. </p>\n<p><strong>On native_decide:</strong> Yeah, valid concern about TCB. The short version: rational arithmetic was killing us with GCD computations in deep Taylor series, so we went with native_decide for speed.</p>\n<p>Good news is the switch to dyadic arithmetic (integers + bit shifts, no GCDs) <em>might</em> make kernel proofs viable now. Haven't tested it yet, but <code>decide</code> could plausibly work for smaller problems. Plan is to support both; native_decide when you need speed &amp; kernel proofs when you want minimal TCB</p>",
        "id": 567588580,
        "sender_full_name": "Alejandro Radisic",
        "timestamp": 1768236399
    },
    {
        "content": "<p>Regarding GCD, I thought there could be a more efficient way on operating rational numbers in kernel -- you do not need to know that you are dividing with GCD, only that you are dividing with a common divisor. But might not matter if you switched number representation.</p>",
        "id": 567590069,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1768236766
    },
    {
        "content": "<p>sqrt added <span aria-label=\"saluting face\" class=\"emoji emoji-1fae1\" role=\"img\" title=\"saluting face\">:saluting_face:</span></p>",
        "id": 567614932,
        "sender_full_name": "Alejandro Radisic",
        "timestamp": 1768242952
    },
    {
        "content": "<p>Have I done something wrong? I cloned the repo, created an experimental file with</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">LeanBound</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">exp</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">interval_bound</span>\n</code></pre></div>\n<p>and it failed on</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Application</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">mismatch</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">In</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">application</span>\n<span class=\"w\">  </span><span class=\"n\">LeanBound</span><span class=\"bp\">.</span><span class=\"n\">Numerics</span><span class=\"bp\">.</span><span class=\"n\">Certificate</span><span class=\"bp\">.</span><span class=\"n\">verify_upper_bound_Icc</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">LeanBound</span><span class=\"bp\">.</span><span class=\"n\">Core</span><span class=\"bp\">.</span><span class=\"n\">Expr</span><span class=\"bp\">.</span><span class=\"n\">var</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">exp</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">LeanBound</span><span class=\"bp\">.</span><span class=\"n\">Numerics</span><span class=\"bp\">.</span><span class=\"n\">ExprSupportedCore</span><span class=\"bp\">.</span><span class=\"n\">exp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">LeanBound</span><span class=\"bp\">.</span><span class=\"n\">Numerics</span><span class=\"bp\">.</span><span class=\"n\">ExprSupportedCore</span><span class=\"bp\">.</span><span class=\"n\">var</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">))</span>\n<span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">argument</span>\n<span class=\"w\">  </span><span class=\"n\">LeanBound</span><span class=\"bp\">.</span><span class=\"n\">Numerics</span><span class=\"bp\">.</span><span class=\"n\">ExprSupportedCore</span><span class=\"bp\">.</span><span class=\"n\">exp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">LeanBound</span><span class=\"bp\">.</span><span class=\"n\">Numerics</span><span class=\"bp\">.</span><span class=\"n\">ExprSupportedCore</span><span class=\"bp\">.</span><span class=\"n\">var</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"n\">LeanBound</span><span class=\"bp\">.</span><span class=\"n\">ExprSupportedCore</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">LeanBound</span><span class=\"bp\">.</span><span class=\"n\">Core</span><span class=\"bp\">.</span><span class=\"n\">Expr</span><span class=\"bp\">.</span><span class=\"n\">var</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">exp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"n\">but</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">expected</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"n\">LeanBound</span><span class=\"bp\">.</span><span class=\"n\">ExprSupported</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">LeanBound</span><span class=\"bp\">.</span><span class=\"n\">Core</span><span class=\"bp\">.</span><span class=\"n\">Expr</span><span class=\"bp\">.</span><span class=\"n\">var</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">exp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n</code></pre></div>\n<p>perhaps I cloned an unstable version?</p>",
        "id": 567860224,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1768338991
    },
    {
        "content": "<p>Feel free to try the latest commit please! Wiil tag new version soon too.</p>\n<p>I fixed a bunch of bugs related to that one, and have been testing different things throughout  the whole day, finding some more issues and fixing them. It should work as expected now, and the library is in a way more solid state.</p>\n<p>Sorry about that!</p>",
        "id": 568029539,
        "sender_full_name": "Alejandro Radisic",
        "timestamp": 1768408286
    },
    {
        "content": "<p>Great, now it works.</p>",
        "id": 568034886,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1768409582
    },
    {
        "content": "<p>Is there also a tactic to prove numerical inequality only? Like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">exp</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">sqrt</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">sqrt</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">pi</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 568035168,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1768409656
    },
    {
        "content": "<p>Not yet, interval_bound only handles ∀ x ∈ I, ... form currently :(</p>\n<p>a workaround for single-point expressions:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">exp</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">exp</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">interval_bound</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">le_refl</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">le_refl</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"bp\">⟩</span>\n</code></pre></div>\n<p>For multi-constant expressions like √2 + √3 &gt; π, there's no direct support yet, will prioritize it, and probably have it ready tomorrow.</p>\n<p>Thanks a lot for the feedback!</p>",
        "id": 568038222,
        "sender_full_name": "Alejandro Radisic",
        "timestamp": 1768410422
    },
    {
        "content": "<p>You work with a fixed precision?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">exp</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mf\">2.718282</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">interval_bound</span><span class=\"w\"> </span><span class=\"c1\">-- failed</span>\n</code></pre></div>\n<p>It would be cool if the tactic could figure out the necessary precision, and heuristically optimize it to minimize computation in the proof term.</p>",
        "id": 568043365,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1768411864
    },
    {
        "content": "<p>Also, it is a bit silly that the other direction of inequality is not supported</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">exp</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">interval_bound</span><span class=\"w\"> </span><span class=\"c1\">-- failed</span>\n</code></pre></div>\n<p>(Sorry I am throwing feature requests at you so quickly.)</p>",
        "id": 568044409,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1768412186
    },
    {
        "content": "<p>Hey! No, I'm happy with them, keep em coming! haha</p>\n<p>Both of these are done:</p>\n<p>1. <strong>Adaptive precision</strong> - the tactic now tries Taylor depths [10, 15, 20, 25, 30] automatically until one works</p>\n<p>2. <strong>Reversed inequalities</strong> - added preprocessing that rewrites ≥ → ≤ and &gt; → &lt; before running</p>\n<p>Both examples should work now!</p>",
        "id": 568110298,
        "sender_full_name": "Alejandro Radisic",
        "timestamp": 1768440272
    },
    {
        "content": "<p>do you plan to support lebesgue integration?</p>",
        "id": 568458294,
        "sender_full_name": "Cookie Guy",
        "timestamp": 1768576666
    },
    {
        "content": "<p>What are the main differences of this project and its aims with <a href=\"https://github.com/girving/interval\">https://github.com/girving/interval</a> ?</p>",
        "id": 568541329,
        "sender_full_name": "Adomas Baliuka",
        "timestamp": 1768607843
    },
    {
        "content": "<p>Great question <span class=\"user-mention\" data-user-id=\"638715\">@Adomas Baliuka</span> </p>\n<p><strong>Disclaimer:</strong> Didn't know girving/interval existed until today <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> (Also started rebranding from LeanBound to LeanCert yesterday, your question confirms the timing was right!)</p>\n<p>From what I've seen, girving/interval focuses on a clean, trusted implementation of conservative interval arithmetic with good approximation typeclasses.</p>\n<p>We share the mathematical foundation, but LeanCert has a different philosophy and broader scope.</p>\n<p><strong>Philosophy:</strong><br>\nNumerical computation is scaffolding; the product is a theorem.</p>\n<p><strong>Discovery → Proof:</strong></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Find minimum, get a proven existential</span>\n<span class=\"bp\">#</span><span class=\"n\">minimize</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">sin</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">on</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">]</span>\n<span class=\"c1\">-- Output: ∃ m, ∀ x, f(x) ≥ m  (with rigorous rational bound)</span>\n</code></pre></div>\n<p><strong>Bound certification:</strong></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Transcendentals with Taylor models</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">exp_bound</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">exp</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">interval_bound</span><span class=\"w\"> </span><span class=\"mi\">15</span>\n\n<span class=\"c1\">-- Or faster with Dyadic arithmetic</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">fast</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">sin</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">certify_bound</span>\n</code></pre></div>\n<p><strong>Multivariate:</strong></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">mv</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">multivariate_bound</span>\n</code></pre></div>\n<p><strong>Root existence via IVT</strong></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Prove √2 exists</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">sqrt2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">²</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">interval_roots</span>\n\n<span class=\"c1\">-- Prove exp(x) has no roots (always positive)</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">exp_no_root</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">exp</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">root_bound</span>\n</code></pre></div>\n<p><strong>Architecture:</strong> Built around \"Golden Theorems\" connecting boolean checks to mathematical properties. Multiple backends (exact Rational, fast Dyadic) feed into the same trusted verifier.</p>\n<p>Also supports counterexample hunting (interval_refute), neural network verification with affine arithmetic.</p>\n<p><strong>Python SDK:</strong> LeanCert includes a JSON-RPC bridge for Python integration. Python acts as an untrusted oracle, you can use NumPy/SciPy to explore, find candidate bounds, then send them to Lean for formal verification. The SDK provides a high-level symbolic API <code>(x**2 + sin(x))</code> that translates automatically, with no de Bruijn indices or Lean AST knowledge needed. Lets anyone compute fast and prove rigorously in the process.</p>\n<p>Let me know if this solves your doubt, happy to discuss more!</p>",
        "id": 568574363,
        "sender_full_name": "Alejandro Radisic",
        "timestamp": 1768642516
    },
    {
        "content": "<p>How does this compare with Scilean?</p>",
        "id": 568607386,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1768674617
    },
    {
        "content": "<p>Thanks for asking <span class=\"user-mention\" data-user-id=\"466334\">@Shreyas Srinivas</span> </p>\n<p>I’m aiming at something different.<br>\nSciLean is about doing scientific computing in Lean, while LeanCert is about proving numerical facts.</p>\n<p>SciLean treats Lean as a high-level numerical / scientific language: you write models, run simulations, do differentiation, optimization, etc, and you get numerical results</p>\n<p>LeanCert treats Lean as a proof checker: you may explore numerically, but the end goal is to turn those insights into formal theorems. The output is proof terms, not floats.</p>\n<p>For example:</p>\n<p>SciLean:<br>\n\"Simulate this damped oscillator and plot the response.\"</p>\n<p>LeanCert:<br>\n\"Prove that the damped response never exceeds 1.\"</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">damped_bounded</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">exp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">sin</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">certify_bound</span>\n</code></pre></div>\n<p>So while SciLean optimizes for expressiveness and performance, LeanCert optimizes for rigor via interval arithmetic and certified bounds.</p>\n<p>I think they'll complement nicely, you might use SciLean to model, experiment, and discover invariants, then use LeanCert to formally certify the critical numerical properties you care about.</p>",
        "id": 568613261,
        "sender_full_name": "Alejandro Radisic",
        "timestamp": 1768681203
    },
    {
        "content": "<p>Exciting! <br>\nHow does this relate to the porting effort from Rocq's Floqc library that was discussed a couple of times?<br>\n<span class=\"user-mention\" data-user-id=\"241007\">@Jason Gross</span> also expressed plans to try to automatically port flocq.</p>",
        "id": 568663918,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1768743228
    },
    {
        "content": "<p>There's also <a href=\"https://github.com/Timeroot/ComputableReal\">https://github.com/Timeroot/ComputableReal</a>, but I'm very happy that LeanCert seems to completely eclipse that one in scope in several ways. :)</p>",
        "id": 568667896,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1768747082
    },
    {
        "content": "<p><a href=\"#narrow/channel/113488-general/topic/LeanCert.20-.20Verified.20Computation.20.26.20Interval.20Arithmetic/near/568663918\">A message</a> was moved here from <a href=\"#narrow/channel/113486-announce/topic/LeanCert.20-.20.20Verified.20Computation.20.26.20Interval.20Arithmetic\">#announce &gt; LeanCert -  Verified Computation &amp; Interval Arithmetic</a> by <span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span>.</p>",
        "id": 568681649,
        "sender_full_name": "Notification Bot",
        "timestamp": 1768758094
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"259452\">@Bas Spitters</span> I moved your message to this discussion thread.</p>",
        "id": 568681692,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1768758149
    },
    {
        "content": "<p>Great tool. I was able to use it to formally verify a solution to an actuarial textbook question. The answer in the back of the book was \"0.064\" whereas the precise answer was</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">exp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">7</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">144</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\">  </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">exp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">6</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">125</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">100</span>\n</code></pre></div>\n<p>Minor suggestion: maybe make this work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mf\">0.9</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mf\">1.08</span><span class=\"bp\">⁻¹</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"mf\">1.08</span><span class=\"bp\">⁻¹</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">interval_decide</span>\n</code></pre></div>\n<p>Right now this works:<br>\n<code>constructor;interval_decide</code> (typing<code>interval_decide</code> only once)</p>",
        "id": 568697768,
        "sender_full_name": "Bjørn Kjos-Hanssen",
        "timestamp": 1768774444
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"259452\">@Bas Spitters</span> </p>\n<p>My understanding is that FLOQC is about precise reasoning about floating-point arithmetic itself (IEEE semantics, rounding, ulps, etc), whereas LeanCert is operating at a different layer: it works over ℝ and uses interval arithmetic and Taylor models to <em>certify numerical properties</em> (bounds, roots, optima) as <strong>theorems</strong> in Lean.</p>\n<p>FLOQC-style libraries are ideal when you need to reason about floating-point error in algorithms, while LeanCert is aimed at proving analytic facts and safety bounds without committing to a specific floating-point model</p>",
        "id": 568763448,
        "sender_full_name": "Alejandro Radisic",
        "timestamp": 1768817293
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"347475\">@Bjørn Kjos-Hanssen</span> </p>\n<p>Thanks! <br>\nTextbook use case, literally! Just pushed a fix, interval_decide should handle conjunctions directly now.</p>",
        "id": 568764921,
        "sender_full_name": "Alejandro Radisic",
        "timestamp": 1768817720
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"1010219\">@Alejandro Radisic</span> you are right, I was trying to say too many things at the same time. There is a porting effort going on for flocq. This made me think of the related work by the same author on coq interval and gappa. <a href=\"https://gappa.gitlabpages.inria.fr/\">https://gappa.gitlabpages.inria.fr/</a><br>\n<a href=\"https://coqinterval.gitlabpages.inria.fr/\">https://coqinterval.gitlabpages.inria.fr/</a></p>",
        "id": 568769213,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1768818972
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"259452\">@Bas Spitters</span> </p>\n<p>Thanks, that makes sense.</p>\n<p>Yes, CoqInterval is definitely much closer in spirit. I see LeanCert as exploring a similar analytic layer, but with a different emphasis: certificate-driven automation, and especially \"discovery workflows\" (optimization, root finding, not just discharging given inequalities).</p>\n<p>That being said, I realize I should probably make positioning clearer in the announcement section, and I’ll update that shortly.</p>\n<p>From what I've read, Gappa sits lower, closer to implementation-level reasoning, while LeanCert intentionally stays at the ℝ level</p>\n<p>So I don’t see this as overlapping with the Flocq porting effort, I think they will actually complement too!</p>",
        "id": 568780022,
        "sender_full_name": "Alejandro Radisic",
        "timestamp": 1768822414
    },
    {
        "content": "<p>Yes, gappa sits at a lower level.<br>\nFrom what you write, I don't see a big distinction in approach with coq-interval, but that's probably my limited understanding of LeanCert. So, I look forward to the positioning. In any case, exciting to see this in lean!</p>",
        "id": 568782012,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1768823166
    },
    {
        "content": "<p>Why am I getting this error? <span aria-label=\"embarrassed\" class=\"emoji emoji-1f633\" role=\"img\" title=\"embarrassed\">:embarrassed:</span>  Is it that I have to be on the same Mathlib version as LeanCert is?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">error</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LeanCert</span><span class=\"bp\">/</span><span class=\"n\">Core</span><span class=\"bp\">/</span><span class=\"n\">Taylor</span><span class=\"bp\">.</span><span class=\"n\">lean</span><span class=\"o\">:</span><span class=\"mi\">144</span><span class=\"o\">:</span><span class=\"mi\">32</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Application</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">mismatch</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">The</span><span class=\"w\"> </span><span class=\"n\">argument</span>\n<span class=\"w\">  </span><span class=\"n\">h_one_le</span>\n<span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"n\">but</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">expected</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">application</span>\n<span class=\"w\">  </span><span class=\"n\">ContDiff</span><span class=\"bp\">.</span><span class=\"n\">differentiable</span><span class=\"w\"> </span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"n\">h_one_le</span>\n</code></pre></div>",
        "id": 569157542,
        "sender_full_name": "Bjørn Kjos-Hanssen",
        "timestamp": 1768960194
    },
    {
        "content": "<p>Well yes, of course leancert needs to use the version of mathlib that it works with. But lake should handle that. How did you get to this point?</p>",
        "id": 569182425,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1768978463
    },
    {
        "content": "<p>I did something like <code>rm -rf .lake/leancert</code> and then redid <code>lake update leancert</code>, after lake initially complained that leancert \"has no branch called master\". Maybe that was not the cleanest approach.</p>",
        "id": 569186583,
        "sender_full_name": "Bjørn Kjos-Hanssen",
        "timestamp": 1768980799
    },
    {
        "content": "<p>Why are you running <code>lake update</code> and where?</p>",
        "id": 569192199,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1768983299
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"347475\">@Bjørn Kjos-Hanssen</span> The default branch is 'main', so that's likely the issue. Your lakefile should have:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">[[</span><span class=\"n\">require</span><span class=\"o\">]]</span>\n<span class=\"n\">name</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"s2\">\"leancert\"</span>\n<span class=\"n\">git</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"s2\">\"https://github.com/alerad/leancert\"</span>\n<span class=\"n\">rev</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"s2\">\"main\"</span>\n</code></pre></div>\n<p>Then do a clean rebuild:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">rm</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"n\">rf</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">lake</span><span class=\"w\"> </span><span class=\"n\">lake</span><span class=\"bp\">-</span><span class=\"n\">manifest</span><span class=\"bp\">.</span><span class=\"n\">json</span>\n<span class=\"n\">lake</span><span class=\"w\"> </span><span class=\"n\">update</span>\n<span class=\"n\">lake</span><span class=\"w\"> </span><span class=\"n\">build</span>\n</code></pre></div>\n<p>Lake will pull LeanCert along with its pinned Mathlib version (v4.27.0-rc1) and everything should match up.</p>\n<p>Curious though, where did you get master from? Just want to make sure there isn't stale documentation floating around somewhere</p>",
        "id": 569256074,
        "sender_full_name": "Alejandro Radisic",
        "timestamp": 1769002635
    },
    {
        "content": "<p>I think if you don't put a <code>rev</code>, lake tries <code>master</code></p>",
        "id": 569257838,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1769003148
    },
    {
        "content": "<p>I will create a master branch that tracks main to avoid these kind of issues...</p>\n<p>Thanks <span class=\"user-mention\" data-user-id=\"307953\">@Ruben Van de Velde</span></p>",
        "id": 569258913,
        "sender_full_name": "Alejandro Radisic",
        "timestamp": 1769003436
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/channel/113488-general/topic/LeanCert.20-.20Verified.20Computation.20.26.20Interval.20Arithmetic/near/569257838\">said</a>:</p>\n<blockquote>\n<p>I think if you don't put a <code>rev</code>, lake tries <code>master</code></p>\n</blockquote>\n<p>Indeed, I didn't put a <code>rev</code>.</p>\n<p>Now my only problem is that <code>Warning: some files were not found in the cache.</code> and therefore it will take hours to run <code>lake build</code>.</p>",
        "id": 569297141,
        "sender_full_name": "Bjørn Kjos-Hanssen",
        "timestamp": 1769012405
    },
    {
        "content": "<p>That sounds like a setup issue</p>",
        "id": 569327745,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1769020491
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"347475\">@Bjørn Kjos-Hanssen</span> </p>\n<p>Maybe you need to fetch mathlib cache?</p>\n<p>Run <code>lake exe cache get</code> before <code>lake build</code>,  that downloads prebuilt Mathlib artifacts. Should take a few minutes instead of hours.</p>\n<p>If still gives warnings, maybe:</p>\n<p>lake exe cache get! (with the !) to force download it?</p>\n<p>Will try to replicate on my side meanwhile</p>",
        "id": 569342684,
        "sender_full_name": "Alejandro Radisic",
        "timestamp": 1769025159
    },
    {
        "content": "<p>Now I'm back to the original error message about <code>h_one_le</code> even though I added the <code>rev=\"main\"</code>.<br>\nI guess the error is related to <a href=\"https://github.com/leanprover-community/mathlib4/pull/33131\">#33131</a> from last month.<br>\nI'll try manually changing my Mathlib version to match yours.</p>",
        "id": 569343569,
        "sender_full_name": "Bjørn Kjos-Hanssen",
        "timestamp": 1769025444
    },
    {
        "content": "<p>Just to be clear -- your Lakefield doesn't mention mathlib explicitly, right?</p>",
        "id": 569352326,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1769028358
    },
    {
        "content": "<p>What's a Lakefield?</p>",
        "id": 569352426,
        "sender_full_name": "Bjørn Kjos-Hanssen",
        "timestamp": 1769028390
    },
    {
        "content": "<p><del>Anyway, it seems to be working now...</del> I just went in to lake-manifest.json and changed the Mathlib version. Now I get instead</p>\n<p>stderr:<br>\n⚠ [2847/2893] Replayed LeanCert.Engine.Optimization.BoundVerify<br>\nwarning: LeanCert/Engine/Optimization/BoundVerify.lean:266:13: This simp argument is unused:<br>\n  globalMaximize</p>",
        "id": 569352771,
        "sender_full_name": "Bjørn Kjos-Hanssen",
        "timestamp": 1769028506
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  LeanCert pins Mathlib v4.27.0-rc1, is it a bad call? Also I think adding  a separate mathlib requirement breaks it yeah</p>",
        "id": 569353383,
        "sender_full_name": "Alejandro Radisic",
        "timestamp": 1769028716
    },
    {
        "content": "<p>Does that warn block it from building <span class=\"user-mention\" data-user-id=\"347475\">@Bjørn Kjos-Hanssen</span> ? Should be just a linter warning</p>",
        "id": 569353824,
        "sender_full_name": "Alejandro Radisic",
        "timestamp": 1769028865
    },
    {
        "content": "<p>My .lean file that actually uses LeanCert builds fine, but then the main project file Interest.lean (that imports the working one) does not.</p>",
        "id": 569354193,
        "sender_full_name": "Bjørn Kjos-Hanssen",
        "timestamp": 1769028992
    },
    {
        "content": "<p>Does Interest.lean throw any particular error / what error does it throw?</p>",
        "id": 569354400,
        "sender_full_name": "Alejandro Radisic",
        "timestamp": 1769029062
    },
    {
        "content": "<p>That's the one that says</p>\n<p>stderr:<br>\n⚠ [2847/2893] Replayed LeanCert.Engine.Optimization.BoundVerify<br>\nwarning: LeanCert/Engine/Optimization/BoundVerify.lean:266:13: This simp argument is unused:<br>\nglobalMaximize</p>",
        "id": 569354537,
        "sender_full_name": "Bjørn Kjos-Hanssen",
        "timestamp": 1769029108
    },
    {
        "content": "<p>(But then again it also has other errors from my own code right now, because my library was using a newer version of Mathilb)</p>",
        "id": 569354719,
        "sender_full_name": "Bjørn Kjos-Hanssen",
        "timestamp": 1769029166
    },
    {
        "content": "<p>Hmmh, are you canceling early maybe, or is it just stuck there? No build issues so far in that log</p>",
        "id": 569354746,
        "sender_full_name": "Alejandro Radisic",
        "timestamp": 1769029171
    },
    {
        "content": "<p>It might be that it's failing (in VSCode) because of the other errors and not because of the unused simp argument. I can try to down-version my code and see if that does it.</p>",
        "id": 569355414,
        "sender_full_name": "Bjørn Kjos-Hanssen",
        "timestamp": 1769029382
    },
    {
        "content": "<p>Can you check that your project's Mathlib version matches LeanCert's (v4.27.0-rc1)? Check your lakefile.toml or lake-manifest.json for the mathlib rev.</p>",
        "id": 569355500,
        "sender_full_name": "Alejandro Radisic",
        "timestamp": 1769029405
    },
    {
        "content": "<p>Yes I manually set the mathlib rev in lake-manifest.json to <code>32d24245c7a12ded17325299fd41d412022cd3fe</code> to match LeanCert and it seems to work now.</p>",
        "id": 569355950,
        "sender_full_name": "Bjørn Kjos-Hanssen",
        "timestamp": 1769029535
    },
    {
        "content": "<p>Awesome, glad it's working! Getting Mathlib versions to align can be... a bit of a dance. lmk if you need help with anything else!</p>",
        "id": 569356183,
        "sender_full_name": "Alejandro Radisic",
        "timestamp": 1769029610
    },
    {
        "content": "<p>Thanks a lot. I guess whenever you import somebody else's project you have to be careful about the versions. If I import two independent projects (LeanCert and LeanSomeOtherProject) I guess there's no way it will consistently work?</p>",
        "id": 569356409,
        "sender_full_name": "Bjørn Kjos-Hanssen",
        "timestamp": 1769029682
    },
    {
        "content": "<p>If LeanCert and LeanSomeOtherProject don't coordinate their Mathlib versions?</p>",
        "id": 569356489,
        "sender_full_name": "Bjørn Kjos-Hanssen",
        "timestamp": 1769029714
    },
    {
        "content": "<p>If both projects pin the same Mathlib version no issues, otherwise... prayer and manual manifest editing</p>\n<p>I'm considering adding a small lake run leancert:check-compat or something like that though, I have fought with this many times too haha</p>",
        "id": 569357010,
        "sender_full_name": "Alejandro Radisic",
        "timestamp": 1769029901
    },
    {
        "content": "<p>If Project1 uses <code>ContDiff.differentiable</code> prior to <a href=\"https://github.com/leanprover-community/mathlib4/pull/33131\">#33131</a> and Project2 uses <code>ContDiff.differentiable</code> posterior to <a href=\"https://github.com/leanprover-community/mathlib4/pull/33131\">#33131</a> I guess one is out of luck.</p>",
        "id": 569357541,
        "sender_full_name": "Bjørn Kjos-Hanssen",
        "timestamp": 1769030104
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"1010219\">Alejandro Radisic</span> <a href=\"#narrow/channel/113488-general/topic/LeanCert.20-.20Verified.20Computation.20.26.20Interval.20Arithmetic/near/569353383\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span>  LeanCert pins Mathlib v4.27.0-rc1, is it a bad call? Also I think adding  a separate mathlib requirement breaks it yeah</p>\n</blockquote>\n<p>Nonono, I was just checking that Bjorn wasn't <em>also</em> requiring (a different version of) Mathlib.</p>",
        "id": 569358852,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1769030569
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"347475\">Bjørn Kjos-Hanssen</span> <a href=\"#narrow/channel/113488-general/topic/LeanCert.20-.20Verified.20Computation.20.26.20Interval.20Arithmetic/near/569355950\">said</a>:</p>\n<blockquote>\n<p>Yes I manually set the mathlib rev in lake-manifest.json to <code>32d24245c7a12ded17325299fd41d412022cd3fe</code> to match LeanCert and it seems to work now.</p>\n</blockquote>\n<p>Aah OK. Yeah, if you're going to require something then you'd better let lake decide exactly which version of all its dependencies that you're using!</p>",
        "id": 569359002,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1769030622
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 569359475,
        "sender_full_name": "Bjørn Kjos-Hanssen",
        "timestamp": 1769030788
    },
    {
        "content": "<p>Perhaps it would work to not require Mathlib at all, and instead rely on transitivity since LeanCert requires Mathlib <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 569360681,
        "sender_full_name": "Bjørn Kjos-Hanssen",
        "timestamp": 1769031195
    },
    {
        "content": "<p>Yes, please do that</p>",
        "id": 569360737,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1769031213
    },
    {
        "content": "<p>This is what Kevin meant by \"<em>also</em> requiring (a different version of) Mathlib\"</p>",
        "id": 569360793,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1769031230
    },
    {
        "content": "<p>Quick question, can you please clarify the difference between kernel trust ( what lean inherently does) and compiler trust? doesn't lean just rely on its kernel for verification?</p>",
        "id": 569387983,
        "sender_full_name": "Oscar Matemb ⚛️",
        "timestamp": 1769043641
    },
    {
        "content": "<p>also, I was curious if exploration of bounds for a certain expression can be perhaps done in Lean?</p>",
        "id": 569388073,
        "sender_full_name": "Oscar Matemb ⚛️",
        "timestamp": 1769043692
    },
    {
        "content": "<p>You can instruct the kernel to trust the result of a program verified in Lean and compiled using leans code generator. This will show up as an additional axiom in the dependencies of your theorem.</p>",
        "id": 569430581,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1769070305
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"645179\">@Oscar Matemb ⚛️</span> </p>\n<p>Yes, Exploration (<a href=\"https://docs.leancert.io/discovery/\">Discovery</a>) is supported! </p>\n<p>Although I'd recommend giving the <a href=\"https://docs.leancert.io/api/solver/\">Python SDK</a> some love for discovery , recently added witness support that returns the actual point where min/max is achieved, not just the bound (beta)</p>\n<h1>Find bounds</h1>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">lc</span><span class=\"bp\">.</span><span class=\"n\">var</span><span class=\"o\">(</span><span class=\"bp\">'</span><span class=\"n\">x'</span><span class=\"o\">)</span>\n<span class=\"n\">expr</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">**</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">lc</span><span class=\"bp\">.</span><span class=\"n\">sin</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"n\">result</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">lc</span><span class=\"bp\">.</span><span class=\"n\">find_bounds</span><span class=\"o\">(</span><span class=\"n\">expr</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">'</span><span class=\"n\">x'</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)})</span>\n<span class=\"n\">print</span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"s2\">\"min ∈ {result.min_bound}\"</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"bp\">#</span><span class=\"w\"> </span><span class=\"n\">Interval</span><span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"mf\">0.23</span><span class=\"bp\">...</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">]</span>\n<span class=\"n\">print</span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"s2\">\"max ∈ {result.max_bound}\"</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"bp\">#</span><span class=\"w\"> </span><span class=\"n\">Interval</span><span class=\"o\">[</span><span class=\"mf\">4.9</span><span class=\"bp\">...</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">]</span>\n\n<span class=\"n\">Output</span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">min</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"mf\">5.0000</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"mf\">0.2325</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mf\">4.9093</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mf\">5.0000</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">f</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"mf\">0.25</span><span class=\"w\"> </span><span class=\"n\">verified</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span>\n</code></pre></div>\n<h1>Verify a specific bound</h1>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">verified</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">lc</span><span class=\"bp\">.</span><span class=\"n\">verify_bound</span><span class=\"o\">(</span><span class=\"n\">expr</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">'</span><span class=\"n\">x'</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)},</span><span class=\"w\"> </span><span class=\"n\">lower</span><span class=\"bp\">=-</span><span class=\"mf\">0.25</span><span class=\"o\">)</span>\n<span class=\"n\">print</span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"s2\">\"f(x) ≥ -0.25 verified: {verified}\"</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"bp\">#</span><span class=\"w\"> </span><span class=\"n\">True</span>\n\n<span class=\"n\">Output</span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">argmin</span><span class=\"w\"> </span><span class=\"bp\">≈</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">'</span><span class=\"n\">x'</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"mf\">0.4501953125</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 569437284,
        "sender_full_name": "Alejandro Radisic",
        "timestamp": 1769072517
    },
    {
        "content": "<p><strong>Quick update: pip package now standalone</strong></p>\n<p>The Python SDK mentioned earlier is now a proper standalone pip package:</p>\n<p><code>pip install leancert</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">leancert</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"n\">lc</span>\n<span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">lc</span><span class=\"bp\">.</span><span class=\"n\">var</span><span class=\"o\">(</span><span class=\"bp\">'</span><span class=\"n\">x'</span><span class=\"o\">)</span>\n<span class=\"n\">bounds</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">lc</span><span class=\"bp\">.</span><span class=\"n\">find_bounds</span><span class=\"o\">(</span><span class=\"n\">lc</span><span class=\"bp\">.</span><span class=\"n\">sin</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">'</span><span class=\"n\">x'</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mf\">0.1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mf\">1.0</span><span class=\"o\">)})</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"w\"> </span><span class=\"n\">Proven</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">verified</span>\n</code></pre></div>\n<p>Bundles the Lean4 verification engine (~70MB), no Lean installation or knowledge needed. Works on macOS/Linux/Windows.</p>\n<p>This is part of a larger effort to bridge formal verification to broader audiences, making Lean's rigor accessible to people who need provably correct numerics but aren't going to learn a theorem prover.</p>",
        "id": 569699682,
        "sender_full_name": "Alejandro Radisic",
        "timestamp": 1769170166
    }
]