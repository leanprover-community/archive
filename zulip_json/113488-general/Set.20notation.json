[
    {
        "content": "<p>Currently <code>{a, b}</code> is defined as <code>insert b {a}</code>, so various lemmas about insert reverse the order. E.g., <code>Sup {a, b}</code> simplifies to <code>sup b a</code> while I'd expect <code>sup a b</code>. Is there any reason to have it this way?</p>",
        "id": 188656082,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1582218011
    },
    {
        "content": "<p>From times to times I get random errors using set notations. We can do:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">variables</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"bp\">ℕ</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">}</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span> <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">}</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">}</span>\n</pre></div>\n\n\n<p>But sometimes the second variant rises an error \"function expected at\", but it's very hard to minimize. Does anyone understand the magic behind this notation? Only the last variation (which is pretty rarely used) has a clear origin using the <code>has_sep</code> class.</p>",
        "id": 193818978,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1586810607
    },
    {
        "content": "<p>The first two are parsed in C++ with hardcoded <code>set_of</code></p>",
        "id": 193820282,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1586811384
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/lean/blob/master/src/frontends/lean/brackets.cpp#L28\" title=\"https://github.com/leanprover-community/lean/blob/master/src/frontends/lean/brackets.cpp#L28\">https://github.com/leanprover-community/lean/blob/master/src/frontends/lean/brackets.cpp#L28</a></p>",
        "id": 193820395,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1586811471
    },
    {
        "content": "<p>Yes I understand that things that are not defined by Lean code are defined by C++ code. My question was not precise enough. I'd like to know whether other people see random failure with these notations and know how to fix them.</p>",
        "id": 193821997,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1586812320
    },
    {
        "content": "<p>I've never seen a failure, but it's possible that it's triggered by certain combinations of leaving things out which I might be systematically avoiding for style reasons</p>",
        "id": 193822596,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586812669
    },
    {
        "content": "<p>I am getting annoyed at the duplication around <code>set</code>, <code>finset</code>, <code>multiset</code> and <code>⊆</code>, <code>disjoint</code>, <code>∪</code>, <code>∩</code>. What do people think of a <code>has_set_notation</code> class which states that <code>s ⊆ t ↔ s ≤ t</code>, <code>s ∪ t = s ⊔ t</code>, <code>s ∩ t = s ⊓ t</code>, ... Along with Yury's proposed refactor of <code>⊆</code>, this means we can prove set notation variants of lemmas once and for all.</p>",
        "id": 277554847,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1648937730
    },
    {
        "content": "<p>Of course, it shouldn't get abused (so for example I would not want <a href=\"https://leanprover-community.github.io/mathlib_docs/find/topological_space.opens\">docs#topological_space.opens</a> to have it, because the set notation is not the simp normal form), but I feel like it's a good compromise to keep mathematician notation in the game without driving me insane.</p>",
        "id": 277554910,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1648937810
    },
    {
        "content": "<p>We could maybe even extend it to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/has_insert\">docs#has_insert</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.erase\">docs#set.erase</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.erase\">docs#finset.erase</a> (eh, disparity already <span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span>)</p>",
        "id": 277554932,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1648937873
    },
    {
        "content": "<p>I must confess there have been times when I've got annoyed at this notation and the fix I'd come up with involved simply deleting the notation on the basis that lattice notation worked fine :-) The proposed idea is probably much better than this. I don't really understand about <code>opens</code> though -- even if it's not simp normal form you're saying we can't use it?</p>",
        "id": 277557444,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1648941351
    },
    {
        "content": "<p>If we forbid <code>has_set_notation</code> for types whose simp normal form is not set notation, we can have <code>s ⊔ t = s ∪ t</code>, <code>s ⊓ t = s ∩ t</code>, etc... be polymorphic simp lemmas.</p>",
        "id": 277586432,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1648969096
    },
    {
        "content": "<p>I'm also thinking that such a class would make a <code>to_set</code> attribute moderately easy to write. It would turn all <code>⊔</code> into <code>∪</code>, <code>⊓</code>, into <code>∩</code>, ..., add <code>[has_set_notation α]</code> to all types that appeared in such expressions, change the lemma name and the proof à la <code>to_additive</code>.</p>",
        "id": 277587221,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1648969561
    },
    {
        "content": "<p>It wouldn't work work for everything, but it certainly would for the entirety of <a href=\"https://tqft.net/mathlib/order/boolean_algebra\">file#order/boolean_algebra</a>, which is somewhat the epitomy of the annoying file whose existence is crucial but underknowledged.</p>",
        "id": 277587392,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1648969649
    },
    {
        "content": "<p>Possibly, we need separate classes for different set operations. E.g., finsets have complement only in a finite type and many types have good inf but not sup (e.g., subgroup).</p>",
        "id": 278612701,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1649709149
    },
    {
        "content": "<p>Note that <code>ᶜ</code> is not a problem because there's no set-specific notation.</p>",
        "id": 278613005,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1649709301
    }
]