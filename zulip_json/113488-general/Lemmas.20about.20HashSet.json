[
    {
        "content": "<p><a href=\"https://github.com/pandaman64/lean-regex/pull/119\">In some project,</a> I'd like to use <code>HashSet</code>s and show that the program satisfies some properties. The proof boils down to the two lemmas below:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">HashSet</span>\n\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Hashable</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashSet</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">mem_union_iff</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m₁</span><span class=\"w\"> </span><span class=\"n\">m₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">m₁</span><span class=\"bp\">.</span><span class=\"n\">union</span><span class=\"w\"> </span><span class=\"n\">m₂</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">m₁</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">m₂</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">contains_toArray_iff</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">contains</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">toArray</span><span class=\"bp\">.</span><span class=\"n\">contains</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashSet</span>\n</code></pre></div>\n<p>Currently, I'm unable to show this. There seems to be a stack of data structures involved (<code>HashSet</code>, <code>HashMap</code> and <code>DHashMap</code>) which makes things harder, and I also haven't found a good way to show results about <code>.fold</code>, which both <code>.union</code> and <code>.toArray</code> use. <strong>I'd appreciate all feedback/guidance to show this!</strong> </p>\n<p>Secondly, I guess lemmas like these belong upstream in Lean itself, and they're probably on someone's to-do list. <strong>I'd be more than happy to contribute, if someone is willing to give some pointers/insights.</strong></p>",
        "id": 531617623,
        "sender_full_name": "Michiel Huttener",
        "timestamp": 1753797561
    },
    {
        "content": "<p>At the current state, <code>Std.HashSet.fold_eq_foldl_toList</code> seems useful since it allows us to use induction over lists instead of <code>HashSet</code>. I'm curious about proper ways to prove, too.</p>",
        "id": 531619562,
        "sender_full_name": "pandaman",
        "timestamp": 1753797996
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">HashSet</span>\n\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Hashable</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">EquivBEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LawfulHashable</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashSet</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">mem_union_iff</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m₁</span><span class=\"w\"> </span><span class=\"n\">m₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">m₁</span><span class=\"bp\">.</span><span class=\"n\">union</span><span class=\"w\"> </span><span class=\"n\">m₂</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">m₁</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">m₂</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">union</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">fold_eq_foldl_toList</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">mem_iff_contains</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">m₂</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">contains_toList</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">generalize</span><span class=\"w\"> </span><span class=\"n\">m₂</span><span class=\"bp\">.</span><span class=\"n\">toList</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">l</span>\n<span class=\"w\">    </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">generalizing</span><span class=\"w\"> </span><span class=\"n\">m₁</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">hd</span><span class=\"w\"> </span><span class=\"n\">tl</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ih</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BEq</span><span class=\"bp\">.</span><span class=\"n\">comm</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"n\">grind</span>\n</code></pre></div>\n<p>This solves the first lemma if you can provide the two instances I added. Without these, proofs about Hash objects arent really possible.</p>",
        "id": 531627199,
        "sender_full_name": "Johannes Tantow",
        "timestamp": 1753799854
    },
    {
        "content": "<p>The second one is more difficult as keysArray is not verified and has to be done from the basics.</p>",
        "id": 531628086,
        "sender_full_name": "Johannes Tantow",
        "timestamp": 1753800063
    },
    {
        "content": "<p>The general proccess was a bit described recently here: <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/channel/287929-mathlib4/topic/ExtTreeMap.20-.20Filter.20.2F.20MergeWith/with/531046892\">#mathlib4 &gt; ExtTreeMap - Filter / MergeWith</a></p>",
        "id": 531632177,
        "sender_full_name": "Johannes Tantow",
        "timestamp": 1753801094
    },
    {
        "content": "<p>There is already an open PR that redefines <code>union</code> to use a better implementation and gets started with the verification: <a href=\"https://github.com/leanprover/lean4/pull/7823\">lean4#7823</a>. The PR has stalled, and I expect that <span class=\"user-mention\" data-user-id=\"376152\">@Paul Lezeau</span> would be happy if you were interested in taking over that PR,  <span class=\"user-mention\" data-user-id=\"619983\">@Michiel Huttener</span>.</p>",
        "id": 531638902,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1753802726
    },
    {
        "content": "<p>Great; I'll look into it!</p>",
        "id": 531678738,
        "sender_full_name": "Michiel Huttener",
        "timestamp": 1753815302
    },
    {
        "content": "<p>The PR <a href=\"https://github.com/leanprover/lean4/pull/9685\">lean#9685</a> is currently being merged into the lean4 repo, which adds theorems about <code>toArray</code> so  you should be able to use it to prove the other theorem either in the next nightly or in a later release.</p>",
        "id": 534912332,
        "sender_full_name": "Johannes Tantow",
        "timestamp": 1755510766
    }
]