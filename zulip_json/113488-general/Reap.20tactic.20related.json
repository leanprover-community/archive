[
    {
        "content": "<p>Discussion thread for <a class=\"stream-topic\" data-stream-id=\"113486\" href=\"/#narrow/channel/113486-announce/topic/Reap.21.3A.20Yet.20another.20tactic.20for.20theorem-proving/with/536354867\">#announce &gt; Reap!: Yet another tactic for theorem-proving</a> and <a href=\"#narrow/channel/113486-announce/topic/.60reap.60.3A.20General.20neural.20tactic.20now.20public.20available\">#announce &gt; &#96;reap&#96;: General neural tactic now public available</a></p>",
        "id": 536354742,
        "sender_full_name": "Yutong Wang",
        "timestamp": 1756276310
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"657719\">@Terence Tao</span> this might be something to make a video about</p>",
        "id": 536360261,
        "sender_full_name": "Jared green",
        "timestamp": 1756279130
    },
    {
        "content": "<p>This looks really cool! I notice that in the video you provide, you have a <code>reap</code> tactic by itself that closes the proof without offering a replacement. Is this tactic deterministic and stable, and does it rely on an LLM call or internet access? I'm just wondering if when you close a proof with <code>reap</code> how likely it is to fail at some point in the future. (Of course, these concerns don't apply to the <code>reap?</code> tactic)</p>",
        "id": 536360648,
        "sender_full_name": "Niels Voss",
        "timestamp": 1756279290
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"521331\">Niels Voss</span> <a href=\"#narrow/channel/113488-general/topic/Reap.20tactic.20related/near/536360648\">said</a>:</p>\n<blockquote>\n<p>This looks really cool! I notice that in the video you provide, you have a <code>reap</code> tactic by itself that closes the proof without offering a replacement. Is this tactic deterministic and stable, and does it rely on an LLM call or internet access? I'm just wondering if when you close a proof with <code>reap</code> how likely it is to fail at some point in the future. (Of course, these concerns don't apply to the <code>reap?</code> tactic)</p>\n</blockquote>\n<p>You are right. Currently, <code>reap</code> does suffers from deterministic issue of llm generation. We are working to develop a caching system to make it at least more stable. For now, <code>reap?</code> is more transparent and is of course the better one to try</p>",
        "id": 541142864,
        "sender_full_name": "Yutong Wang",
        "timestamp": 1758689954
    },
    {
        "content": "<p>I think the readme and install instructions should clarify what the tactic actually does, and answer questions similar to what Niels asked above:</p>\n<ul>\n<li>what LLM is used, who runs it an where? (I guess it is not local.)</li>\n<li>does it work when I have no internet connection? (I guess no.)</li>\n<li>what API calls does it make?</li>\n<li>what data from my project/machine gets sent to where?</li>\n</ul>\n<p>etc.</p>\n<p>In general I would expect/like some clarification that these neural tactics are fundamentally different from those like <code>aesop</code> or <code>grind</code>.</p>",
        "id": 542275705,
        "sender_full_name": "Malvin Gattinger",
        "timestamp": 1759238741
    },
    {
        "content": "<p>Hi Malvin, thanks a lot for raising these questions — they’re very helpful and we’ll make sure the README/installation instructions clarify them. Let me try to summarize here:</p>\n<ul>\n<li>\n<p><strong>Which LLM is used / who runs it?</strong><br>\n  The backend uses our own trained model called <strong>REAL-Prover</strong>. The 7B version is open-sourced on HuggingFace (<a href=\"https://huggingface.co/FrenzyMath/REAL-Prover\">link</a>), while the hosted version we provide runs on our research cluster.</p>\n</li>\n<li>\n<p><strong>Does it require internet access?</strong><br>\n  By default, yes — the default endpoint is our hosted cluster. However, you can override this by setting <code>tacticgenerator.llm_endpoint</code> to a locally served instance of REAL-Prover. In that case, no internet connection is needed.</p>\n</li>\n<li>\n<p><strong>What API calls are made?</strong><br>\n  When you call <code>reap</code> to generate the next tactic, it sends the <em>current proof state</em> to the model endpoint you’ve configured (by default, our hosted cluster).</p>\n</li>\n<li>\n<p><strong>What data is sent?</strong><br>\n  Only the proof state at the point of the call. No file paths, user identifiers, or other project metadata are transmitted. On our side, this data is processed statelessly by the model. In other words, it remains anonymous to both the model and us.</p>\n</li>\n</ul>",
        "id": 542284778,
        "sender_full_name": "Yutong Wang",
        "timestamp": 1759240877
    },
    {
        "content": "<p>Basically, <code>reap</code> tactic is composed of neural-based premise selection and tactic generation:</p>\n<ul>\n<li>Neural-based premise selection are specially trained, so that it knows well about the semantic similarities(which defs/lemmas are more helpful to solve current state). And can get more accurate/comprehensive premises than classical one.</li>\n<li>Neural-based tactic generator learns to solve states by training on large corpus of Lean code and can generate more versatile tactics, including those termwise-like step. </li>\n</ul>\n<p>Intuitively, it may produce more human-like tactics and can push forward some harder state that classical rule-based tactics cannot.</p>",
        "id": 542289021,
        "sender_full_name": "Yutong Wang",
        "timestamp": 1759241843
    },
    {
        "content": "<p>I noticed that Reap is not yet in the Lean reservoir.<br>\nCould you add the Apache 2.0 license to it (and all it's dependencies)?</p>",
        "id": 542290913,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1759242293
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/channel/113488-general/topic/Reap.20tactic.20related/near/542290913\">said</a>:</p>\n<blockquote>\n<p>I noticed that Reap is not yet in the Lean reservoir.<br>\nCould you add the Apache 2.0 license to it (and all it's dependencies)?</p>\n</blockquote>\n<p>Thanks very much. I've added Apache 2.0 license to Reap and its dependencies. Would there be anything else I need to do to add it to reservoir?</p>",
        "id": 542293225,
        "sender_full_name": "Yutong Wang",
        "timestamp": 1759242810
    },
    {
        "content": "<p>I think not, you should satisfy all other criteria: <a href=\"https://reservoir.lean-lang.org/inclusion-criteria\">https://reservoir.lean-lang.org/inclusion-criteria</a></p>",
        "id": 542294858,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1759243197
    },
    {
        "content": "<p>I tried to play a little with <code>reap</code>, some observations:</p>\n<ul>\n<li>Enabling <code>reap</code> is super easy and convenient: just add the dependency, <code>import Reap</code> and it works. This is really nice!</li>\n<li><code>reap</code> is nondeterministic, so it's useless to keep it in your main proof script. So I think <code>reap</code> should just do what <code>reap?</code> currently does: give suggestions for replacements</li>\n<li>It seems that <code>reap</code> doesn't do any caching (if I rerun the tactic I get different results). It might be nice to reduce the number of calls on your side by doing some kind of caching (I think <code>polyrith</code> did do some caching, so maybe you can reuse their code?)</li>\n<li>It seems that <code>reap</code> often doesn't use the \"most useful\" suggestion. When I write</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">reap?</span>\n</code></pre></div>\n<p>this will usually give 2 suggestions, with the first of them solving the goal. But if I write <code>reap</code>, it will almost always just apply <code>ext</code> (the second suggestion).</p>",
        "id": 542300026,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1759244423
    },
    {
        "content": "<p><code>reap</code> will just choose the first one that compiles (with no re-ranking, I think this should be refined), by design <code>reap!</code>will try to choose one that close the goal within a single step. </p>\n<p>Cache support is important and we will also work on this. More than reduce number of api calls, it should make some request lightening fast btw.</p>\n<p>Deterministic problem is an issue. I think <code>reap?</code> and <code>reap</code> + proof search may be the answer to this issue?</p>",
        "id": 542305377,
        "sender_full_name": "Yutong Wang",
        "timestamp": 1759245759
    },
    {
        "content": "<p>Hi guys, here are some updates about <code>reap</code>:</p>\n<h3>Proof search</h3>\n<p>Proof search now available: now can use <code>reap!!</code> to initiate a proof search. This is done by taking advantages of <code>aesop</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">Order</span><span class=\"bp\">.</span><span class=\"n\">Ring</span><span class=\"bp\">.</span><span class=\"n\">Star</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Analysis</span><span class=\"bp\">.</span><span class=\"n\">Normed</span><span class=\"bp\">.</span><span class=\"n\">Ring</span><span class=\"bp\">.</span><span class=\"n\">Lemmas</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Int</span><span class=\"bp\">.</span><span class=\"n\">Star</span>\n\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Reap</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">aux</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h₀</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"c1\">-- This can be solved by `reap!!`</span>\n<span class=\"w\">  </span><span class=\"n\">reap!!</span>\n</code></pre></div>\n<p>A scoring mechanism based on log probability is implemented for better best-first search. And <a href=\"https://github.com/frenzymath/openai_client\"><code>openai_client</code></a> is therefore updated to support this feature (to capture <code>logprob</code> struct from any openai-compatible server). I believe this may help someone who is seeking this feature.</p>",
        "id": 544412590,
        "sender_full_name": "Yutong Wang",
        "timestamp": 1760286231
    },
    {
        "content": "<h3>Premise selector</h3>\n<p><code>reap</code> comes with a powerful premise selection engine, named <code>LeanSearch-PS</code>, which is trained on Mathlib and augmented corpus. Now you can access this through native <code>Lean.PremiseSelection</code> Interface:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Reap</span>\n<span class=\"c1\">-- Set `reap` as the default premise selector</span>\n<span class=\"n\">set_premise_selector</span><span class=\"w\"> </span><span class=\"n\">reapSelector</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">→*</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Subgroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hST</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">suggest_premises</span>\n</code></pre></div>\n<p>I believe one can work on this for other purpose, feeding these to <code>grind</code> or other local tactics.</p>",
        "id": 544412876,
        "sender_full_name": "Yutong Wang",
        "timestamp": 1760286477
    },
    {
        "content": "<p>logprob isn't extinct? I'm pretty sure OpenAI doesn't return logprob anymore. Do other \"OpenAI-compatible\" servers still do it?</p>",
        "id": 544412892,
        "sender_full_name": "(deleted)",
        "timestamp": 1760286485
    },
    {
        "content": "<p>In scare quotes, because there has never been a clear OpenAI API standard. And other servers almost always diverge from OpenAI in some way</p>",
        "id": 544412961,
        "sender_full_name": "(deleted)",
        "timestamp": 1760286537
    },
    {
        "content": "<p>I'm asking this question in part because I'd like to know when this feature can be useful. You can direct me to LLM APIs that return logprob</p>",
        "id": 544413216,
        "sender_full_name": "(deleted)",
        "timestamp": 1760286727
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"511228\">Huỳnh Trần Khanh</span> <a href=\"#narrow/channel/113488-general/topic/Reap.20tactic.20related/near/544412892\">said</a>:</p>\n<blockquote>\n<p>logprob isn't extinct? I'm pretty sure OpenAI doesn't return logprob anymore. Do other \"OpenAI-compatible\" servers still do it?</p>\n</blockquote>\n<p>I'm not sure. But It seems that official OpenAI API still support this <a href=\"https://platform.openai.com/docs/api-reference/chat/object#chat/object-choices-logprobs\">OpenAI Platform</a>. For my routine use case, <code>vllm</code> basically provides exactly same response format as official API.</p>",
        "id": 544413323,
        "sender_full_name": "Yutong Wang",
        "timestamp": 1760286827
    },
    {
        "content": "<p>logprobs is partially helpful in proof search, since you can estimate how confident tactic generator is towards some generated tactic, then use it as a guidance through tree search. (Of course more ideal way is to have a so-called reward model to evaluate each resulted proof state <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span> )</p>",
        "id": 544413757,
        "sender_full_name": "Yutong Wang",
        "timestamp": 1760287187
    },
    {
        "content": "<p>btw installation changed a little bit, one should always place dependency of <code>reap</code> before that of <code>mathlib</code> in <code>lakefile.toml</code> (see <a href=\"https://github.com/frenzymath/reap?tab=readme-ov-file#installation\">Readme</a> for <code>lakefile.lean</code>) to avoid  cache system collapse.</p>\n<div class=\"codehilite\" data-code-language=\"TOML\"><pre><span></span><code><span class=\"k\">[[require]]</span>\n<span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s2\">\"reap\"</span>\n<span class=\"n\">git</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s2\">\"https://github.com/frenzymath/reap.git\"</span>\n<span class=\"n\">rev</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s2\">\"main\"</span>\n\n<span class=\"k\">[[require]]</span>\n<span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s2\">\"mathlib\"</span>\n<span class=\"n\">scope</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s2\">\"leanprover-community\"</span>\n</code></pre></div>\n<p>I am still not sure why the reverse way won't work, should be related to newly added <code>aesop</code> dependency.</p>",
        "id": 544414385,
        "sender_full_name": "Yutong Wang",
        "timestamp": 1760287692
    },
    {
        "content": "<p>Your package likely depends on a different Aesop commit (recorded in <code>lake-manifest.json</code>) than Mathlib. Afaik there is currently no good way to handle this situation other than manually synchronising your deps with Mathlib.</p>",
        "id": 544414767,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1760288027
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256311\">Jannis Limperg</span> <a href=\"#narrow/channel/113488-general/topic/Reap.20tactic.20related/near/544414767\">said</a>:</p>\n<blockquote>\n<p>Your package likely depends on a different Aesop commit (recorded in <code>lake-manifest.json</code>) than Mathlib. Afaik there is currently no good way to handle this situation other than manually synchronising your deps with Mathlib.</p>\n</blockquote>\n<p>I try to keep exact </p>\n<div class=\"codehilite\" data-code-language=\"TOML\"><pre><span></span><code><span class=\"k\">[[require]]</span>\n<span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s2\">\"aesop\"</span>\n<span class=\"n\">scope</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s2\">\"leanprover-community\"</span>\n<span class=\"n\">rev</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s2\">\"master\"</span>\n</code></pre></div>\n<p>with mathlib, but it won't work. Should I directly modify <code>lake-manifest.json</code> to do the manual sync?</p>",
        "id": 544414917,
        "sender_full_name": "Yutong Wang",
        "timestamp": 1760288172
    },
    {
        "content": "<p>Yeah. Your <code>lakefile</code> fixes only a particular branch, but not a particular commit, whereas <code>lake-manifest</code> freezes both. So if you and Mathlib call <code>lake update aesop</code> at different times, you may get different commits in <code>lake-manifest</code>.</p>",
        "id": 544415136,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1760288395
    },
    {
        "content": "<p>I think this solution is kinda weird, if I need to support different mathlib release tag <code>master</code>, <code>v4.23.0</code>, <code>v4.24.0-rc1</code>, etc. Would I need to manually match <code>lake-manifest.json</code> for each release tag? This seems to make <code>lake</code> package management more confusing.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"256311\">Jannis Limperg</span> <a href=\"#narrow/channel/113488-general/topic/Reap.20tactic.20related/near/544415136\">said</a>:</p>\n<blockquote>\n<p>Yeah. Your <code>lakefile</code> fixes only a particular branch, but not a particular commit, whereas <code>lake-manifest</code> freezes both. So if you and Mathlib call <code>lake update aesop</code> at different times, you may get different commits in <code>lake-manifest</code>.</p>\n</blockquote>",
        "id": 544417865,
        "sender_full_name": "Yutong Wang",
        "timestamp": 1760291157
    },
    {
        "content": "<p>Yup. It's not a great UX, but it is what is right now.</p>",
        "id": 544419410,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1760292788
    },
    {
        "content": "<p>Here is a demo of proof search speed on some random exercises. Sometimes much faster than I expected.<br>\n<a href=\"/user_uploads/3121/EF9cs9qjb0EIS4SOkqXru10i/bandicam-2025-10-13-02-51-24-674.mp4\">demo</a></p>\n<div class=\"message_inline_image message_inline_video\"><a href=\"/user_uploads/3121/EF9cs9qjb0EIS4SOkqXru10i/bandicam-2025-10-13-02-51-24-674.mp4\" title=\"demo\"><video preload=\"metadata\" src=\"/user_uploads/3121/EF9cs9qjb0EIS4SOkqXru10i/bandicam-2025-10-13-02-51-24-674.mp4\"></video></a></div>",
        "id": 544422028,
        "sender_full_name": "Yutong Wang",
        "timestamp": 1760295667
    },
    {
        "content": "<p>Man it looks so fast. What model are you using</p>",
        "id": 544447793,
        "sender_full_name": "(deleted)",
        "timestamp": 1760325089
    },
    {
        "content": "<p>It's so extreme.</p>",
        "id": 544447901,
        "sender_full_name": "(deleted)",
        "timestamp": 1760325203
    },
    {
        "content": "<p>Ah the stock Real-Prover?</p>",
        "id": 544447972,
        "sender_full_name": "(deleted)",
        "timestamp": 1760325282
    },
    {
        "content": "<p>You're giving me a good reason to download it. Man... I'm missing out.</p>",
        "id": 544448036,
        "sender_full_name": "(deleted)",
        "timestamp": 1760325341
    },
    {
        "content": "<p>The fastest in the market, and it's freely available too. Can't be grateful enough.</p>",
        "id": 544448287,
        "sender_full_name": "(deleted)",
        "timestamp": 1760325602
    },
    {
        "content": "<p>Yeah, it is basically Real-Prover, but with a little bit data hot fix and format optimization in comparison with the vanilla one.</p>",
        "id": 544451032,
        "sender_full_name": "Yutong Wang",
        "timestamp": 1760328282
    },
    {
        "content": "<p>Are any <code>lake exe cache</code> experts or enthusiasts available to help out here?</p>\n<p><span class=\"user-mention\" data-user-id=\"699571\">@Yutong Wang</span> has prepared <a href=\"https://github.com/leanprover-community/mathlib4/pull/29953\">#29953</a>, which ideally should be preparing the oleans required for the <code>reap</code> branch mentioned above, but is failing in CI.</p>\n<p>I think the problem is visible at <a href=\"https://github.com/leanprover-community/mathlib4/actions/runs/18494458606/job/52695367601?pr=29953#step:24:7022\">https://github.com/leanprover-community/mathlib4/actions/runs/18494458606/job/52695367601?pr=29953#step:24:7022</a>, where you can see that <code>lake exe cache put</code> is packaging up all the oleans for Mathlib and its upstream dependencies, but is not doing anything with <code>Reap</code>, and I can't work out why.</p>",
        "id": 544861129,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1760491886
    },
    {
        "content": "<p>I hope that <a href=\"https://github.com/leanprover-community/mathlib4/pull/30818\">#30818</a> has now fixed this problem, and we should get oleans for a <code>reap</code>-enabled Mathlib from <a href=\"https://github.com/leanprover-community/mathlib4/pull/29953\">#29953</a> shortly.</p>",
        "id": 546780368,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1761260153
    },
    {
        "content": "<p>Mathlib will have reap soon?</p>",
        "id": 546791891,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1761268406
    },
    {
        "content": "<p>Mathlib will have a <code>reap</code> branch soon, with <code>lake exe cache get</code>, in which you can use <code>reap</code>. Whether it ever lands in master is further off.</p>",
        "id": 546799283,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1761273281
    },
    {
        "content": "<p>This is now working. Please use the following steps to get Mathlib with reap installed:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">git</span><span class=\"w\"> </span><span class=\"n\">remote</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"n\">frenzymath</span><span class=\"w\"> </span><span class=\"n\">git</span><span class=\"bp\">@</span><span class=\"n\">github</span><span class=\"bp\">.</span><span class=\"n\">com</span><span class=\"o\">:</span><span class=\"n\">frenzymath</span><span class=\"bp\">/</span><span class=\"n\">mathlib4</span><span class=\"bp\">.</span><span class=\"n\">git</span>\n<span class=\"n\">git</span><span class=\"w\"> </span><span class=\"n\">fetch</span><span class=\"w\"> </span><span class=\"n\">frenzymath</span>\n<span class=\"n\">git</span><span class=\"w\"> </span><span class=\"n\">checkout</span><span class=\"w\"> </span><span class=\"n\">reap</span>\n<span class=\"n\">lake</span><span class=\"w\"> </span><span class=\"n\">exe</span><span class=\"w\"> </span><span class=\"n\">cache</span><span class=\"w\"> </span><span class=\"n\">get</span>\n</code></pre></div>\n<p>and then try using the <code>reap</code> tactic anywhere in Mathlib.</p>\n<p>It would be really helpful to have some \"real world\" usage reports --- is <code>reap</code> useful as is? I think if we can get a few people to give it a 30 minute try on a current project inside Mathlib, and report back what they found, we may be able to talk about turning it on for everyone.</p>",
        "id": 547030583,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1761371003
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/channel/113488-general/topic/Reap.20tactic.20related/near/547030583\">said</a>:</p>\n<blockquote>\n<p>I think if we can get a few people to give it a 30 minute try on a current project inside Mathlib, and report back what they found, we may be able to talk about turning it on for everyone.</p>\n</blockquote>\n<p>Tried it now for an hour on some trivial graph theory lemmas, and I'm pretty disappointed.<br>\nIt keeps suggesting various <code>simp only [...]</code> calls which all contain lemmas already tagged with <code>simp</code>.<br>\nSometimes it closes the goal with an <code>exact</code>, but in those cases <code>exact?</code> suggests the same thing.<br>\nSo it seems pretty similar to doing <code>simp_all; exact?</code>.<br>\nThe only \"smart\" thing I saw it do so far was suggest some <code>cases</code> or <code>induction</code>, which are helpful but obvious suggestions.<br>\n<a href=\"/user_uploads/3121/BCkcjq_1WTxn77p_aYtoditL/image.png\">image.png</a><br>\nSo I think adding <code>cases</code> or <code>induction</code> on inductive structures (such as graph walks in this case) to hammers will get better results than reap.</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/BCkcjq_1WTxn77p_aYtoditL/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1170x486\" src=\"/user_uploads/thumbnail/3121/BCkcjq_1WTxn77p_aYtoditL/image.png/840x560.webp\"></a></div><p>Specific problems:</p>\n<ul>\n<li>Having both <code>reap</code> and <code>reap?</code> means that whenever I type <code>reap?</code> it performs 2 calls to the model instead of one because <code>reap</code> is a prefix of <code>reap?</code>.</li>\n<li>When I want to retry <code>reap?</code> because it says \"no suggestions\" my instinct is to delete the last character and type it again, but this again creates more uneccessary API calls.</li>\n<li>The suggestions only show the first goal a suggestion creates, which is misleading. It looks like this suggestion solved almost all of the cases, but actually it creates 3 goals and is useless.<br>\n<a href=\"/user_uploads/3121/JXlCZG9Q67FCYWaDBcaMpcr0/image.png\">image.png</a><div class=\"message_inline_image\"><a href=\"/user_uploads/3121/JXlCZG9Q67FCYWaDBcaMpcr0/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"802x286\" src=\"/user_uploads/thumbnail/3121/JXlCZG9Q67FCYWaDBcaMpcr0/image.png/840x560.webp\"></a></div></li>\n</ul>",
        "id": 547067869,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1761409203
    },
    {
        "content": "<p>Could we have the same kind of effort to have a mathlib with Canonical and LeanHammer instead?</p>",
        "id": 547124059,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1761478925
    },
    {
        "content": "<p>In the long term, would it be possible to allow users to install their own tactics like canonical or reap without requiring a new branch of Mathlib to be made and maintained for everyone?</p>",
        "id": 547141878,
        "sender_full_name": "Niels Voss",
        "timestamp": 1761495056
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"521331\">Niels Voss</span> <a href=\"#narrow/channel/113488-general/topic/Reap.20tactic.20related/near/547141878\">said</a>:</p>\n<blockquote>\n<p>In the long term, would it be possible to allow users to install their own tactics like canonical or reap without requiring a new branch of Mathlib to be made and maintained for everyone?</p>\n</blockquote>\n<p>Yes, it's long been on the agenda, but no near term plans, unfortunately.</p>",
        "id": 547169758,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1761524187
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/channel/113488-general/topic/Reap.20tactic.20related/near/547124059\">said</a>:</p>\n<blockquote>\n<p>Could we have the same kind of effort to have a mathlib with Canonical and LeanHammer instead?</p>\n</blockquote>\n<p>Sure, happy to have a go. I hadn't appreciated that there was demand for these, as I hadn't seen practically useful results. But I'm happy to hear that others are finding them useful!</p>\n<p>Could someone please review/merge <a href=\"https://github.com/leanprover-community/mathlib4/pull/30844\">#30844</a>? It is on the critical path to providing Canonical on <code>master</code>.</p>",
        "id": 547170109,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1761524563
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span>, as you'll see on the Canonical thread we're making good progress on that front.</p>\n<p>However LeanHammer is not \"mathlib ready\", mostly due to their difficulties keeping up to date with recent versions. (But it also has <em>much</em> heavier dependencies, including <code>auto</code> and <code>duper</code>, which I am highly skeptical will ever be in a state we could <code>require</code> into Mathlib.) I'm happy to help out with integration when that is resolved.</p>",
        "id": 547172436,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1761527014
    },
    {
        "content": "<p>(Further on LeanHammer, some of those dependencies still require \"precompileModules\", which doesn't really work at present.)</p>",
        "id": 547173185,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1761527723
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/channel/113488-general/topic/Reap.20tactic.20related/near/547169758\">said</a>:</p>\n<blockquote>\n<p>Yes, it's long been on the agenda, but no near term plans, unfortunately.</p>\n</blockquote>\n<p>Is there even an RFC somewhere that we can upvote? I am always a bit puzzled by the number of things mathlib \"requires\", and I’d really wish for a way to have people cherry-pick which \"development goodies\" (packages that do not contribute to actually checking a single proof, but may helps writing them) they actually want instead of coming with a bunch of \"you-might-like-it\" packages that everyone (also downstream deps) have to download, that can potentially break at releases, go unmaintained etc.</p>",
        "id": 547245958,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1761562465
    },
    {
        "content": "<p>It's a big project, sorry.</p>",
        "id": 547390738,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1761610001
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"933054\">Snir Broshi</span> <a href=\"#narrow/channel/113488-general/topic/Reap.20tactic.20related/near/547067869\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/channel/113488-general/topic/Reap.20tactic.20related/near/547030583\">said</a>:</p>\n<blockquote>\n<p>I think if we can get a few people to give it a 30 minute try on a current project inside Mathlib, and report back what they found, we may be able to talk about turning it on for everyone.</p>\n</blockquote>\n<p>Tried it now for an hour on some trivial graph theory lemmas, and I'm pretty disappointed.<br>\nIt keeps suggesting various <code>simp only [...]</code> calls which all contain lemmas already tagged with <code>simp</code>.<br>\nSometimes it closes the goal with an <code>exact</code>, but in those cases <code>exact?</code> suggests the same thing.<br>\nSo it seems pretty similar to doing <code>simp_all; exact?</code>.<br>\nThe only \"smart\" thing I saw it do so far was suggest some <code>cases</code> or <code>induction</code>, which are helpful but obvious suggestions.<br>\n<a href=\"/user_uploads/3121/BCkcjq_1WTxn77p_aYtoditL/image.png\">image.png</a><br>\nSo I think adding <code>cases</code> or <code>induction</code> on inductive structures (such as graph walks in this case) to hammers will get better results than reap.</p>\n<p>Specific problems:</p>\n<ul>\n<li>Having both <code>reap</code> and <code>reap?</code> means that whenever I type <code>reap?</code> it performs 2 calls to the model instead of one because <code>reap</code> is a prefix of <code>reap?</code>.</li>\n<li>When I want to retry <code>reap?</code> because it says \"no suggestions\" my instinct is to delete the last character and type it again, but this again creates more uneccessary API calls.</li>\n<li>The suggestions only show the first goal a suggestion creates, which is misleading. It looks like this suggestion solved almost all of the cases, but actually it creates 3 goals and is useless.<br>\n<a href=\"/user_uploads/3121/JXlCZG9Q67FCYWaDBcaMpcr0/image.png\">image.png</a></li>\n</ul>\n</blockquote>\n<p>Thanks for trying and providing these valuable feedbacks!</p>\n<p>Current reap mainly tests on algebra-related use case. I think there are indeed some conceivable performance gaps in certain domains (combinatorics, graph theory, etc). This may arise from <br>\n1) Relatively sparse coverage in mathlib4 on these topics (current reap version cutoff is <code>v4.16.0</code>). And our data augment regime (expert iteration) mainly takes in sources from general algebra related domain.<br>\n2) Tac gen system now will not consume anything other than current proof state, which means it is not aware of local theorems/premises available in current env (project). This will sacrifice some of its potential to resolve obvious states.</p>\n<p>For 1), since Lean resources about combinatorics are much more abundant than 2 years ago, <code>reap</code> could be much smarter after next iteration after taking in those resources. Meanwhile, could you try <code>reap!!</code> to conduct proof search and see if it is more useful to generate multiple tacs? </p>\n<p>For 2), we are working on ways to securely extract infos from user's local env, but it will be some trade-off for privacy (relative file paths, comments might be sent to our cluster).</p>\n<ul>\n<li><code>reap</code> and <code>reap?</code>: I think one of <code>reap</code> and <code>reap?</code> will eventually be removed for simplicity, since <code>reap</code> is not actually useful in proof writing</li>\n<li>Unnecessary API calls: We are solving this through setting up client-side and server-side cache system. Perhaps also adding a button for retrying generation will be more friendly in this case? </li>\n<li>Goal display: This is indeed misleading. <code>reap</code> should at least show types of all unsolved goals, which will not take up much spaces. I can work on this issue.</li>\n</ul>\n<p>Again these are very good feedbacks (at least we never had a chance to test <code>reap</code> on graph theory problems). We can work to get it right.</p>",
        "id": 547883577,
        "sender_full_name": "Yutong Wang",
        "timestamp": 1761815825
    }
]