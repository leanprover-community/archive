[
    {
        "content": "<p>If we look at <a href=\"https://github.com/leanprover/lean4/blob/b0fe9d6cdca82723134d61f8fe23a8c674f308b7/src/Init/Prelude.lean#L263-L266\">the definition of <code>Eq</code></a>, we see that unlike in Lean 3 it uses two indices of type <code>α</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Eq</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">refl</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Eq</span> <span class=\"n\">a</span> <span class=\"n\">a</span>\n</code></pre></div>\n<p>However, if we check the type of <code>Eq.rec</code> we see that the first index is in fact treated as if that it were a parameter:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- The type of Eq.rec</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span>\n  <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">{</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Eq</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">v</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">motive</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"n\">a</span><span class=\"o\">))</span>\n  <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Eq</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">),</span> <span class=\"n\">motive</span> <span class=\"n\">b</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">Eq.rec</span> <span class=\"n\">α</span>\n\n<span class=\"c1\">-- What we would “expect” from two indices</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span>\n  <span class=\"o\">{</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">Eq</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">v</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">motive</span> <span class=\"n\">a</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"n\">a</span><span class=\"o\">))</span>\n  <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Eq</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">),</span> <span class=\"n\">motive</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>So my question is twofold:</p>\n<ol>\n<li>I’m assuming this is a quality-of-life feature introduced in Lean 4. Is there any documentation on this — when will Lean decide to transform indices into parameters?</li>\n<li>It is trivial to show that the single-indexed recursor can be used to construct the double-indexed recursor. I assume the reverse is not possible, because otherwise Lean4 wouldn’t have introduced this feature. In that case, what would be the semantics of the hypothetically double-indexed type? Is there any mental model I can have to understand why it exists? It seems strange to me that such an object might exist which is strictly worse than another.</li>\n</ol>",
        "id": 408215886,
        "sender_full_name": "Sabrina Jewson",
        "timestamp": 1702656938
    },
    {
        "content": "<p>It is possible to construct the double indexed type, but lean's elaborator prefers to make things parameters when possible because they are generally more convenient</p>",
        "id": 408216212,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1702657042
    },
    {
        "content": "<p>The two inductives are equivalent for a suitably loose sense of equivalent</p>",
        "id": 408216480,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1702657130
    },
    {
        "content": "<p>an easy way to get the double-indexed inductive is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Eq'</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">refl</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Eq'</span> <span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">a</span>\n</code></pre></div>",
        "id": 408216996,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1702657303
    },
    {
        "content": "<p>it occurs to me that one advantage of this feature is that you can set the binder mode on the argument to <code>refl</code>, which is not something you can do when writing the parameter left of the colon</p>",
        "id": 408217468,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1702657459
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Foo</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">one</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"n\">a</span> <span class=\"mi\">1</span>\n  <span class=\"bp\">|</span> <span class=\"n\">two</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"n\">a</span> <span class=\"mi\">2</span>\n<span class=\"k\">#print</span> <span class=\"n\">Foo</span>\n<span class=\"c1\">-- inductive Foo : Nat → Nat → Prop</span>\n<span class=\"c1\">-- number of parameters: 1</span>\n<span class=\"c1\">-- constructors:</span>\n<span class=\"c1\">-- Foo.one : ∀ (a : Nat), Foo a 1</span>\n<span class=\"c1\">-- Foo.two : ∀ {a : Nat}, Foo a 2</span>\n</code></pre></div>",
        "id": 408217669,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1702657535
    },
    {
        "content": "<blockquote>\n<p>The two inductives are equivalent for a suitably loose sense of equivalent</p>\n</blockquote>\n<p>Thanks, you’re right, I didn’t try hard enough with my proof. For future reference, here is the single-indexed recursor constructed from the double-indexed inductive type:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Eq'</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">refl</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Eq'</span> <span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Eq'.rec'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span>\n  <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">{</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Eq'</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">v</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">motive</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">Eq'.refl</span> <span class=\"n\">a</span><span class=\"o\">))</span>\n  <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Eq'</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">),</span> <span class=\"n\">motive</span> <span class=\"n\">b</span> <span class=\"n\">t</span> <span class=\"o\">:=</span>\n    <span class=\"bp\">λ</span> <span class=\"o\">{</span><span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"n\">refl</span> <span class=\"o\">{</span><span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"n\">t</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">t.rec</span>\n      <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">t</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">Eq'</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">v</span><span class=\"o\">},</span> <span class=\"n\">motive</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">Eq'.refl</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"n\">b</span> <span class=\"n\">t</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">id</span><span class=\"o\">)</span>\n      <span class=\"n\">refl</span>\n</code></pre></div>",
        "id": 408220483,
        "sender_full_name": "Sabrina Jewson",
        "timestamp": 1702658531
    }
]