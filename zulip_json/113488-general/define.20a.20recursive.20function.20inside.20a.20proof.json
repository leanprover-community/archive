[
    {
        "content": "<p>I am trying to prove that in a first countable space, for every cluster point <code>x</code> of a sequence, there is a subsequence for which <code>x</code>  is a limit.</p>\n<p>I have managed to construct a decreasing sequence of neighborhoods  that form a a basis, so i can use it to construct the subsequence using the axiom of choice... but my problem is how to make sure that the indices in the subsequence are increasing.</p>\n<p>So I basically have the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">X</span><span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">X</span>\n<span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">X</span>\n<span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">X</span>\n<span class=\"n\">hf</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"bp\">⊆</span> <span class=\"bp\">⋂₀</span> <span class=\"o\">{</span><span class=\"n\">_x</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">j</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">j</span> <span class=\"bp\">=</span> <span class=\"n\">_x</span><span class=\"o\">}</span>\n<span class=\"n\">haux</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">n0</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n0</span> <span class=\"bp\">∧</span> <span class=\"n\">s</span> <span class=\"n\">n0</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"n\">n</span>\n</code></pre></div>\n<p>and I need to construct a sequence <code>k : ℕ → ℕ </code> as follows:</p>\n<ul>\n<li><code>k 0</code> should be the <code>n0</code> that is ensured to exists by haux with <code>n = 0</code></li>\n<li><code>k (succ n1)</code> should be the <code>n0</code> that exists because of haux with <code>n = k n1</code></li>\n</ul>\n<p>I am trying to define such a sequence, but apparently Lean doesn't like to define recursive functions inside a tactic proof.</p>\n<p>What is the right way to do this?</p>",
        "id": 408006092,
        "sender_full_name": "Miguel Marco",
        "timestamp": 1702573714
    },
    {
        "content": "<p>Why do you care about it being increasing in the first place?</p>",
        "id": 408006209,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1702573762
    },
    {
        "content": "<p>It is part of the definition of subsequence.</p>",
        "id": 408008491,
        "sender_full_name": "Miguel Marco",
        "timestamp": 1702574500
    },
    {
        "content": "<p>The <code>choose</code> tactic might be useful, since it can take <code>haux</code> and give you a function Nat -&gt; Nat, but you might need to transform it more.</p>",
        "id": 408008848,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702574620
    },
    {
        "content": "<p>Yes, that was my idea, but as you said, it doesn't work right away. Somehow I need the previous values of the chosing function to define the next one.</p>",
        "id": 408016044,
        "sender_full_name": "Miguel Marco",
        "timestamp": 1702577159
    },
    {
        "content": "<p>You could just use the recursor <code>Nat.rec</code> directly in the proof, or make an auxiliary definition outside the proof which takes f and <code>haux</code> as inputs and spits out the function.</p>",
        "id": 408018156,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1702577963
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"461731\">@Miguel Marco</span> this is almost surely in Mathlib already. Are you doing that as an exercise or would you be happy to get it from Mathlib?</p>",
        "id": 408026511,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1702581095
    },
    {
        "content": "<p>I am happy to get it from mathlib, but didn't find it.</p>\n<p>I mean, I am happy to get the subsequence from mathlib. The fact that cluster points are limit points of a subsquence is the exercise I want to do.</p>",
        "id": 408030379,
        "sender_full_name": "Miguel Marco",
        "timestamp": 1702582574
    },
    {
        "content": "<p>You probably want to play with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Filter.extraction_forall_of_frequently#doc\">docs#Filter.extraction_forall_of_frequently</a> and surrounding lemmas then.</p>",
        "id": 408032080,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1702582956
    },
    {
        "content": "<p>Maybe <a href=\"mailto:docs@Filter.extraction_forall_of_eventually\">docs@Filter.extraction_forall_of_eventually</a>'</p>",
        "id": 408032492,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1702583060
    },
    {
        "content": "<p>There are tons of variations in that file.</p>",
        "id": 408032528,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1702583070
    },
    {
        "content": "<p>I see... It looks like the exact variation I need is missing: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Filter.extraction_forall_of_eventually%27#doc\">docs#Filter.extraction_forall_of_eventually'</a> requires a stronger hypothesis, and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Filter.extraction_forall_of_frequently#doc\">docs#Filter.extraction_forall_of_frequently</a> , which would be the one I need (I think), has the hypothesis written in terms of filters instead of sequences.</p>\n<p>I guess I will need to do some work translating from filter language to sequences.</p>",
        "id": 408041204,
        "sender_full_name": "Miguel Marco",
        "timestamp": 1702585790
    },
    {
        "content": "<p>There should be a lemma doing the translation already. Something like Filter.frequently_atTop (only guessing the name).</p>",
        "id": 408042669,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1702586405
    },
    {
        "content": "<p>It did work, thank you!</p>\n<p>Do you think it would be worth adding the version with sequences to mathlib?</p>",
        "id": 408049025,
        "sender_full_name": "Miguel Marco",
        "timestamp": 1702589056
    }
]