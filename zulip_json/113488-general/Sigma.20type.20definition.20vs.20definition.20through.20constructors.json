[
    {
        "content": "<p>Consider these two definitions of lists of fixed length:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Vect</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">   </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vect</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">   </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Vect</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Vect</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>And consider these two definitions of <code>Fin</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">val</span><span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"w\">  </span><span class=\"n\">isLt</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LT</span><span class=\"bp\">.</span><span class=\"n\">lt</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Fin'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin'</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin'</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>It seems like there is often these two ways of defining a type: either by using a sigma type , i.e. you specify a carrier type and a list of propositions you expect to be satisfied (the first example of each case above), or by directly giving the type in terms of constructors. In both cases above we'd expect the types to be equivalent, but only in the second case there's something like computational content (i.e. you can immediately define a catamorphism with the given definition). </p>\n<p>Is there a way to specify rigorously the difference between these two sorts of definitions? Or, is there a way to state, what makes it such that the second sort of definition has computational content but both can be used in proofs?</p>",
        "id": 478561394,
        "sender_full_name": "nrs",
        "timestamp": 1729709092
    },
    {
        "content": "<p>What do you mean precisely by only the <code>inductive</code> versions having computational content? The Subtype versions have immediate computational content as well, so long as you are willing to work with List and Nat, respectively, in your folds.</p>",
        "id": 478562851,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729709603
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/113488-general/topic/Sigma.20type.20definition.20vs.20definition.20through.20constructors/near/478562851\">said</a>:</p>\n<blockquote>\n<p>What do you mean precisely by only the <code>inductive</code> versions having computational content? The Subtype versions have immediate computational content as well, so long as you are willing to work with List and Nat, respectively, in your folds.</p>\n</blockquote>\n<p>It seems to me that in order to work with the subtype versions, you need a partial function, no? I want to say there is noncomputational content because we are not explicitly given which parts of the domain the resulting partial function has values for. By this I mean: the recursor of the inductive versions immediately give a non-partial function defined over the entire domain, while in the case of the subtype definitions, any fold would be a fold over List and Nat where we wouldn't know which values don't belong to said fold unless we provide a proof for the proposition in the subtype definition</p>",
        "id": 478563654,
        "sender_full_name": "nrs",
        "timestamp": 1729709889
    },
    {
        "content": "<p>(I am not sure this makes sense I am looking to make this more precise)</p>",
        "id": 478563694,
        "sender_full_name": "nrs",
        "timestamp": 1729709903
    },
    {
        "content": "<p>I don't see any partial functions anywhere. Where are you seeing a partial function? Are you talking about <code>partial</code>?</p>",
        "id": 478563862,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1729709974
    },
    {
        "content": "<p><code>Vector \\a n</code> is a type and you can just consider functions defined on that type.</p>",
        "id": 478564222,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1729710091
    },
    {
        "content": "<p>Plus, in both <code>Vector</code> and <code>Fin</code>, the properties are <code>Decidable</code>, so there is no mystery about which values can appear.</p>",
        "id": 478564645,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729710233
    },
    {
        "content": "<p>You can define the same recursors for <code>Vector</code> and <code>Fin</code> as their <code>Vect</code> and <code>Fin'</code> counterparts (it's a good exercise)</p>",
        "id": 478564833,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729710295
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/113488-general/topic/Sigma.20type.20definition.20vs.20definition.20through.20constructors/near/478564833\">said</a>:</p>\n<blockquote>\n<p>You can define the same recursors for <code>Vector</code> and <code>Fin</code> as their <code>Vect</code> and <code>Fin'</code> counterparts (it's a good exercise)</p>\n</blockquote>\n<p>hm I will be thinking about this, thank you both for the answers</p>",
        "id": 478564956,
        "sender_full_name": "nrs",
        "timestamp": 1729710342
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/113488-general/topic/Sigma.20type.20definition.20vs.20definition.20through.20constructors/near/478564645\">said</a>:</p>\n<blockquote>\n<p>Plus, in both <code>Vector</code> and <code>Fin</code>, the properties are <code>Decidable</code>, so there is no mystery about which values can appear.</p>\n</blockquote>\n<p>it does seem however that those cases where a definition like <code>Vect</code> and <code>Fin'</code> is available is also a case where the properties are decidable, and definitions such as <code>Vect</code> and <code>Fin'</code> are not possible otherwise (this is why I referred to maybe there being something about computational content, maybe direct inductive definitions are not possible in those cases where the subtype would contain an undecidable proposition?)</p>",
        "id": 478565300,
        "sender_full_name": "nrs",
        "timestamp": 1729710465
    },
    {
        "content": "<p>If the subtype has an undecidable proposition, would it even be possible to cast it as an <code>inductive</code> of the forms you're considering?</p>",
        "id": 478565911,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729710693
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/113488-general/topic/Sigma.20type.20definition.20vs.20definition.20through.20constructors/near/478565911\">said</a>:</p>\n<blockquote>\n<p>If the subtype has an undecidable proposition, would it even be possible to cast it as an <code>inductive</code> of the forms you're considering?</p>\n</blockquote>\n<p>Right this is what I am saying, it seems to me that maybe not. But how can we formalize the difference between these two types of definitions in such a way to be able to prove this statement?</p>",
        "id": 478566109,
        "sender_full_name": "nrs",
        "timestamp": 1729710767
    },
    {
        "content": "<p>I'd guess the reason that there's this formal relationship is that both are of the form <code>{ x : T // f x = true }</code> where <code>f</code> is a function defined recursively on <code>T</code>.</p>",
        "id": 478567304,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729711234
    },
    {
        "content": "<p>It seems to me that in this case you can encode <code>f</code> into <code>T</code> to make a type <code>T'</code> with an extra <code>Bool</code> index, with those terms where the index is <code>true</code> are valid ones.</p>",
        "id": 478567407,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729711275
    },
    {
        "content": "<p>And then you can optimize this index away, at least for <code>Vect</code> and <code>Fin'</code></p>",
        "id": 478567493,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729711321
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/113488-general/topic/Sigma.20type.20definition.20vs.20definition.20through.20constructors/near/478567493\">said</a>:</p>\n<blockquote>\n<p>And then you can optimize this index away, at least for <code>Vect</code> and <code>Fin'</code></p>\n</blockquote>\n<p>Thank you very much for your answers! I will be thinking about these comments</p>",
        "id": 478567889,
        "sender_full_name": "nrs",
        "timestamp": 1729711462
    }
]