[
    {
        "content": "<p>Hey,</p>\n<p>I've seen a few people have started working on geometric group theory (mostly Cayley graphs, the word metric, Švarc–Milnor and some coarse geometry afaik). Earlier this year, I tried attacking this without much success and am now getting back to it. I would very much like to start working in a synchronized way with people tackling the same subject, and thus propose to set up some kind of coordination.</p>\n<p>Ideally, we'd have a sort of clear roadmap of what comes before what and what level of generality should be aimed for in each case, but maybe that's too early planning. A typical example of questions which I got bogged down on is: In what setting should the end space of a group be defined. In a sense, graphs are maybe not the most natural/ideal setting to define that, because the \"coarse metric\" aspect gets lost in translation, but then what is? Similar questions got in my way for Cayley graphs (e.g. don't we want to have an <code>emetric</code> space to keep things as general as possible?)<br>\nAnyway, my plans now would be to try to deal with Bass-Serre theory, since it's much more algebraic, and thus probably less prone to this problem of not knowing how to set things down.</p>\n<p>What do you think?</p>",
        "id": 290098362,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1658237317
    },
    {
        "content": "<p>Easy answer for the space of ends: this should first be defined for any topological space. Then given a generating set you get the space of ends of the corresponding Cayley graph (with edges added), and then you have to check that it does not depend on the choice of the generating set. But doing it for any topological space first is important, as this notion also shows up in the classification theorem of surfaces, for instance.</p>",
        "id": 290106561,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1658240882
    },
    {
        "content": "<p>That makes sense, though I sort of still have a problem with that, in that I have a feeling getting topology into play when talking about coarse geometry is kind of a wrong direction. As I see it, you can define a topological notion of ends, and a “graphical” one, and they agree when realizing certain well-behaved enough graphs as topological spaces, but does that mean the topological notion really is the most natural one ? Going further in this direction: When talking about ends of a group, I feel like it would be best to have a notion which is more naturally quasi-isometry invariant, or more generally, a coarser notion. Do we really need to do the topological détour, when topology really hasn't much to do with coarse geometry ? We care about large scale stuff, and topology is made for small-scale stuff, no?</p>\n<p>I know there exists a notion of “binary Higson Corona” for coarse structures that, I believe, strictly generalize that of ends of graphs. <br>\nA strategy I had in mind was then to define ends in two ways: a very general one for coarse spaces, and a very restricted one for graphs, and prove that they agree when your graph has the path metric. This would get QI-invariance for free I believe.<br>\nThis strategy brings up the question/problem of maybe directly defining a coarse structure on finitely generated groups, without the metric intermediate representation. And that's where I start to see the analysis paralysis getting closer!</p>",
        "id": 290110131,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1658242293
    },
    {
        "content": "<p>Independent question: maybe GGT people can comment on whether you want noncommutative linearly ordered groups? <a href=\"#narrow/stream/113488-general/topic/Why.20linear_ordered_ring\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why.20linear_ordered_ring</a></p>",
        "id": 290111382,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1658242768
    },
    {
        "content": "<p>It would be super cool indeed to have some Bass-Serre theory <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 290120565,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1658246288
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"466727\">@Jim Fowler</span></p>",
        "id": 290121212,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1658246496
    },
    {
        "content": "<p>I'd love to see Bass-Serre theory.</p>",
        "id": 290124595,
        "sender_full_name": "Jim Fowler",
        "timestamp": 1658247781
    },
    {
        "content": "<p>I guess one can consider <code>mul_action</code>s on graphs which are trees?</p>",
        "id": 290125037,
        "sender_full_name": "Jim Fowler",
        "timestamp": 1658247975
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"266304\">@Siddhartha Gadgil</span></p>",
        "id": 290125957,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1658248364
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466727\">Jim Fowler</span> <a href=\"#narrow/stream/113488-general/topic/Geometric.20Group.20Theory.20coordination.20.3F/near/290125037\">said</a>:</p>\n<blockquote>\n<p>I guess one can consider <code>mul_action</code>s on graphs which are trees?</p>\n</blockquote>\n<p>I think a group action on a graph should be expressed as a <code>mul_action</code> on vertices + a <code>mul_action</code> on edges + the compatibility condition between those two.</p>",
        "id": 290126599,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1658248649
    },
    {
        "content": "<p>For a lot of stuff (e.g. as defined in Lyndon-Schupp) we do not need topology associated to a graph. This matters more to me because I use lean 4 which does not yet have topology, but the principle of keeping things lighter is reasonable anyway.</p>\n<p>For example, one can define graphs and 2-complexes prove stuff like Fenchel-Nielsen theorem and even (with some work) Stalling's topological proof of Grushko's theorem defining fundamental groups and coverings in the category of combinatorial 2-complexes. Serre-Bass also fits in well here, as does ends of groups.</p>",
        "id": 290126617,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1658248655
    },
    {
        "content": "<p>The relation to topological spaces is important but parallel to GGT and \"topological methods in group theory\"</p>",
        "id": 290127029,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1658248824
    },
    {
        "content": "<p>I also think that this stuff would be more easily expressed with Serre's definition of a (multi)graph rather than the current <code>simple_graph</code>. This has been discussed <a href=\"#narrow/stream/252551-graph-theory/topic/multigraph.20definition/near/222015077\">here</a> but I don't know what this discussion became.</p>",
        "id": 290127394,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1658248966
    },
    {
        "content": "<p>To be totally honest, I planned on getting acquainted with Bass-Serre in parallel to the formalization process, and working with an ad-hoc definition of graphs (Serre's definition with sets E, V, two functions E -&gt; V and an involution on E) before trying to use most of mathlib. In a sense, stay as close to the presentation at hand. Open to changing the plan though.</p>",
        "id": 290127796,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1658249118
    },
    {
        "content": "<p>Let me plug <a href=\"https://github.com/leanprover-community/mathlib/pull/11000\">#11000</a></p>",
        "id": 290173785,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1658272787
    },
    {
        "content": "<p>I also pushed some code to <code>properties.lean</code> on the geometric-group-theory branch to (badly) define things like <code>residually</code> and </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">virtually</span> <span class=\"o\">(</span><span class=\"n\">property</span> <span class=\"o\">:</span> <span class=\"n\">group_property</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">H.index</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span> <span class=\"bp\">∧</span> <span class=\"n\">property</span> <span class=\"n\">H</span>\n</code></pre></div>\n<p>It would be nice to be able to say things like <code>virtually is_free_group</code> but <code>is_free_group</code> isn't a <code>Prop</code>.  Are there other instances in mathlib where structure or properties are transformed with adverbs like virtually, residually, etc.?</p>",
        "id": 290192159,
        "sender_full_name": "Jim Fowler",
        "timestamp": 1658290907
    },
    {
        "content": "<p>You can say <code>virtually (λ G, nonempty (is_free_group G))</code> or similar</p>",
        "id": 290198963,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1658299098
    },
    {
        "content": "<p>By the way, is it better to stick everything to a single <code>group_theory/geometric</code> folder, or should we allow messing with the hierarchy more freely? Say, defining the ends of a graph maybe should still live in <code>combinatorics/graph_theory</code>?</p>",
        "id": 290224947,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1658318172
    },
    {
        "content": "<p>For the purpose of writing stuff, I highly suggest sticking to a single place. You can then put the files in the right place when PRing.</p>",
        "id": 290225141,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1658318309
    },
    {
        "content": "<p>I added some code to <code>properties.lean</code> at <a href=\"https://github.com/leanprover-community/mathlib/blob/geometric-group-theory/src/group_theory/geometric/properties.lean#L11-L13\">https://github.com/leanprover-community/mathlib/blob/geometric-group-theory/src/group_theory/geometric/properties.lean#L11-L13</a> which includes</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">mul_equiv_respects</span> <span class=\"o\">(</span><span class=\"n\">property</span> <span class=\"o\">:</span> <span class=\"n\">group_property</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">eq_preserves</span><span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">],</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">H</span><span class=\"o\">],</span>\n<span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"bp\">≃*</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">property</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">property</span> <span class=\"n\">H</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>since I don't see any other way to ensure that a \"property of a group\" is actually a property of a group up to equivalence of groups.  I'm not super clear how lean and mathlib handle transporting things like <code>Prop</code>s across <code>equiv</code>s.  I still feel like I'm fighting against typeclass inference with the definition of <code>residually</code>.</p>",
        "id": 290269550,
        "sender_full_name": "Jim Fowler",
        "timestamp": 1658338481
    },
    {
        "content": "<p>The philosophy that mathlib adopts is that &lt;some object&gt; properties usually transfer along maps weaker than &lt;some object&gt; isomorphisms. Hence we basically never write down the iso version of the transfer, but rather the weaker one. This means that your <code>mul_equiv_respects</code> is most likely useless, as in practice you won't always have a group isomorphism at hand. Furthermore, your approach is more metatheoretical than it needs to be. Rather than reasoning about properties that transfer, you directly transfer the properties. This is justified because:</p>\n<ul>\n<li>You never talk about properties that <em>don't</em> transfer</li>\n<li>The amount of reasoning done at that level of generality is minimal, so it's innocuous redoing it in each concrete situation.</li>\n</ul>",
        "id": 290312126,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1658358746
    },
    {
        "content": "<p>But this last point might be wrong in your case. Maybe you do carry enough reasoning at the metatheoretical level that you wouldn't want to do it for each concrete property.</p>",
        "id": 290312190,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1658358817
    },
    {
        "content": "<p>When I started with lean I was utterly convinced that this mul_equiv_respects thing would be crucial in algebra and algebraic geometry, but I was very surprised to find that it didn't seem to be at all.</p>",
        "id": 290318330,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1658363643
    },
    {
        "content": "<p>Respecting isomorphisms isn't that interesting a predicate on properties, but there are other predicates that are useful in AG, and we are recently seeing <a href=\"https://github.com/leanprover-community/mathlib/pull/14944\">#14944</a>, <a href=\"https://github.com/leanprover-community/mathlib/pull/14966\">#14966</a>, and <a href=\"https://github.com/leanprover-community/mathlib/pull/15452\">#15452</a> (these involve properties of morphisms not objects though). It appears that the predicates aren't made into classes yet, and in the case of the last PR the predicate doesn't get a separate definition.</p>",
        "id": 290332268,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1658377831
    },
    {
        "content": "<p>I am implementing the type synonyms approach now.</p>",
        "id": 290359003,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1658399989
    },
    {
        "content": "<p>I will be giving a couple of lectures on something related, but am planning to start working on formalizing topological/geometric methods in Group theory. Is there any update on this. In particular, I did not see any formalization of </p>\n<ul>\n<li>Cayley Graph</li>\n<li>Graph's as normally used in Serre-Bass theory</li>\n<li>CW complexes</li>\n<li>Amalgamated free products and HNN extensions</li>\n</ul>\n<p>Am I correct that none of this is in Mathlib? <span class=\"user-mention\" data-user-id=\"303675\">@Anand Rao Tadipatri</span> <span class=\"user-mention\" data-user-id=\"329754\">@Antoine Labelle</span> <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> <span class=\"user-mention\" data-user-id=\"461830\">@Rémi Bottinelli</span> </p>\n<p>I plan to take as a target the Scott-Wall article \"Topological methods in Group Theory\". Of course collaboration is very welcome.</p>",
        "id": 369429780,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1687703940
    },
    {
        "content": "<p>Have you already checked <a href=\"https://github.com/leanprover-community/mathlib/tree/geometric-group-theory\">branch#geometric-group-theory</a> ?</p>",
        "id": 369432763,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1687704615
    },
    {
        "content": "<p>Thanks. I did not know of this. Will look at it.</p>",
        "id": 369435953,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1687705272
    },
    {
        "content": "<p>Looks like it is best to start with porting this.</p>",
        "id": 369436445,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1687705371
    },
    {
        "content": "<p>For graphs as used by Serre, there was some discussion about either going with plain quivers with an involutive inverse operation on edges, or defining a new type. I was in favour of the former, but it does involve plenty of hardship with index types (for me), which kind of makes me doubt whether it's the right way.<br>\nI made a start with Cayley graphs here: <a href=\"https://github.com/leanprover-community/mathlib/pull/18693\">!3#18693</a>, but I'm not sure there is much worth salvaging…<br>\nFinally, I had some hopes to develop combinatorial/geometric gt by leveraging groupoids, which could make things easier (most importantly Bass-Serre I thought) in the long term, and also allow some more topology more easily (pi₁ and covering spaces, van Kampen, etc).</p>",
        "id": 369571617,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1687760092
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"461830\">@Rémi Bottinelli</span> <br>\nIf there is not much in that direction, it may be easiest for me to work with a clean slate and do Bass-Serre theory topologists style (and hopefully Grushko's theorem along the way). When something is ready for PR duplication can be reduced or bridge code written.</p>\n<p>Concretely, I am starting with the following definitions:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Graph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">V</span>\n  <span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">E</span>\n  <span class=\"n\">bar_involution</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">bar</span> <span class=\"o\">(</span><span class=\"n\">bar</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">e</span>\n  <span class=\"n\">bar_no_fp</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">e</span> <span class=\"bp\">≠</span> <span class=\"n\">bar</span> <span class=\"n\">e</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Graph.τ</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">Graph</span> <span class=\"n\">V</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"n\">G.ι</span> <span class=\"o\">(</span><span class=\"n\">G.bar</span> <span class=\"n\">e</span><span class=\"o\">)</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">EdgePath</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">Graph</span> <span class=\"n\">V</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">EdgePath</span> <span class=\"n\">G</span> <span class=\"n\">v</span> <span class=\"n\">v</span>\n  <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n        <span class=\"o\">(</span><span class=\"n\">EdgePath</span> <span class=\"n\">G</span> <span class=\"n\">w</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"bp\">→</span>  <span class=\"n\">G.ι</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"n\">v</span> <span class=\"bp\">→</span> <span class=\"n\">G.τ</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"n\">w</span>  <span class=\"bp\">→</span> <span class=\"n\">EdgePath</span> <span class=\"n\">G</span> <span class=\"n\">v</span> <span class=\"n\">u</span>\n</code></pre></div>",
        "id": 369891678,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1687837398
    },
    {
        "content": "<p>Is mathlib's definition of a graph no good for you? <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph#doc\">docs#SimpleGraph</a></p>",
        "id": 369915997,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1687845133
    },
    {
        "content": "<p>Simple graphs are not good for topology. For instance we would want a circle to be a graph with 1 vertex and 1 edge, and for a free group have a single vertex and one edge for each generator.</p>",
        "id": 369921147,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1687846434
    },
    {
        "content": "<p>But a variant of the above may be better: having a structure <code>EdgeBetween</code> which includes the proofs.</p>",
        "id": 369921479,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1687846496
    },
    {
        "content": "<p>It looks like you can use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Quiver.HasInvolutiveReverse#doc\">docs#Quiver.HasInvolutiveReverse</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Quiver.Path#doc\">docs#Quiver.Path</a></p>",
        "id": 370048184,
        "sender_full_name": "David Wärn",
        "timestamp": 1687869726
    },
    {
        "content": "<p>Yeah, that's what I was refering to, and <span class=\"user-mention\" data-user-id=\"329754\">@Antoine Labelle</span> added quite a few <code>cast</code>ing lemmas to facilitate working with those. <br>\nNote also that  <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span>  has <a href=\"https://github.com/leanprover-community/mathlib/pull/16100\">!3#16100</a> for multigraphs.</p>",
        "id": 370049075,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1687869906
    },
    {
        "content": "<p>Thanks. <span class=\"user-mention\" data-user-id=\"303675\">@Anand Rao Tadipatri</span> had also mentioned the definition with Quivers and I saw that <code>EdgeBetween</code> gives exactly that.<br>\nMy first attempt will be for a demo so I will give self-contained definitions, but it seems eventually that the quiver approach is the best.</p>",
        "id": 370050055,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1687870092
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/16100\">#16100</a> is pending experimentation from Kyle in Lean 4.</p>",
        "id": 370059970,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1687871919
    },
    {
        "content": "<p>I think it's good that we have multiple ab initio attempts at proving things using different graph formalisations. As long as everyone goes into ready to make compromises, and rip out their \"favourite\" definition to replace it with something mathlib compatible later, if necessary!</p>",
        "id": 370217555,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1687903826
    },
    {
        "content": "<p>There's also something to be said about using the correct definition of a graph in each particular circumstance and then hope we can engineer bridges between all these graph theories. Let's not shoehorn things into simple graphs or quivers just because it seems like in the short term we'll have less code duplication!</p>",
        "id": 370238567,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1687912574
    },
    {
        "content": "<p>I think Siddhartha's definition looks good for its purpose, and my only quibble is that E might be better as H or D (half-edge or dart)</p>",
        "id": 370238954,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1687912704
    },
    {
        "content": "<p>I don't think there's a better definition than the one used by Siddhartha (because it's basically the only one that allows for a functorial topological realization). However, it is useful to implement other versions of graphs (such as simple graphs, quivers, etc.) and natural coercions functions to standard graphs.</p>",
        "id": 370305025,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1687936687
    },
    {
        "content": "<p>For example, Serre's book (and Bourbaki's Topologie algébrique takes the same path) starts with quivers, defines graphs as above (quiver + fixed-point-free involution on edges), defines  the graph associated with a quiver (add a reverse edge for each edge), an orientation of a graph (choose one edge between any two which are exchanged by the involution) and the associated quiver, proves that the corresponding graph is the initial one, etc.</p>",
        "id": 370305772,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1687936858
    },
    {
        "content": "<p>It was remarked in 2019 that Lean had perfectoid spaces but not graphs, which was funny at the time; one reason for this was that people only mean one thing by perfectoid spaces but they seem to mean many things by a graph. It was argued that until the applications came along, we should hold off from committing to a definition of graph, and it was certainly remarked back then that probably more than one definition would be needed. It's great to see the applications finally coming along :D</p>",
        "id": 370362096,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1687946999
    },
    {
        "content": "<p>Thanks all. Looks like the best approach is to go ahead and formalize for the next several weeks, and then reconcile if and when we have some non-trivial mathematical results. Grushko's theorem is one of my targets, small cancellation groups is another.</p>",
        "id": 370382983,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1687950416
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> We committed to a definition of a simple graph a couple years ago and have various applications in mathlib. I'd say it's great having applications that force us to branch out to more than one kind of graph (this topological multigraph)</p>",
        "id": 370404367,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1687954284
    },
    {
        "content": "<p>(We've had a need for simple digraphs for a while, but there's still an annoying dependent type issue that needs thought in that PR Yael mentioned in the interface to unify graphs and digraphs...)</p>",
        "id": 370406457,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1687954665
    },
    {
        "content": "<p>I'd love to know what some of the lean graph theory people think about <a href=\"https://github.com/apnelson1/gen_graph/blob/master/graph.lean\">https://github.com/apnelson1/gen_graph/blob/master/graph.lean</a>, a design that <span class=\"user-mention\" data-user-id=\"329425\">@Peter Nelson</span> was experimenting with in Banff</p>",
        "id": 370419777,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1687957119
    },
    {
        "content": "<p>Why should the Props about graphs be typeclases, as opposed to explicitly passed hypotheses?</p>",
        "id": 370472590,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1687965815
    },
    {
        "content": "<p>No strong reason, but it is was more or less that I was thinking about simple graphs, multigraphs etc as 'settings' rather than hypotheses.</p>",
        "id": 370613835,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1688005513
    },
    {
        "content": "<p>For instance, if proving a theorem about simple graphs with the subgraph order, you want simplicity to be invisibly preserved via typeclasses when passing to a subgraph, rather than providing an explicit proof. With something like the minor order, simplicity is something you'd need to prove.</p>",
        "id": 370614138,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1688005711
    },
    {
        "content": "<p>Also, <span class=\"user-mention\" data-user-id=\"621949\">@Alexander Byard</span>  was looking at translating the design to lean 4 (and fixing an issue with the way I defined 'pair graphs')</p>",
        "id": 370614561,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1688006031
    },
    {
        "content": "<p>That's absolutely valid. I was thinking about all of the various possible constructions that one does with graphs, like adjoining or deleting graphs, vertices, and edges, which might keep the simple/digraph/etc property. Composition of these constructions might create propeq but not defeq constructions, which might complicate TC search, even though they're all prop. I'm not sure.</p>",
        "id": 370625731,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1688012139
    },
    {
        "content": "<p>I think typeclasses to organize the different kinds of graphs is going to be mathlib's future, but I'm not sure about everything being in terms of a single universal graph type constrained by typeclasses (though I'd like mathlib to be able to support everyone's personal favorite concrete graph type).</p>\n<p>Basically, if there's a universal graph type that's being constrained, you may as well as take the next step and have typeclasses for the different fields of the different graph types, and then general theorems about graphs become theorems about types that have some collection of typeclasses (data and properties) -- all without there being any concrete graph type. The situation is somewhat similar to how homomorphisms are handled in the algebraic hierarchy.</p>",
        "id": 370684284,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1688027750
    },
    {
        "content": "<p>I thought Yaël posted a different PR, so my previous comments about it make no sense; there's also <a href=\"https://github.com/leanprover-community/mathlib4/pull/4127\">mathlib4#4127</a> (and take a look at the Graph.Classes module). It's taking a first step implementing graph classes with a similar design to what Yaël had argued for, but starting with adding just digraphs since it's clearer how to modify the simple graph API for digraphs, and there are technical challenges that crop up even here.</p>\n<p>I'll try to explain the problem better soon (or, better, solve it!) but right now this <code>Adj</code> function doesn't behave well on coercions of subgraphs to graphs, since <code>simp</code> is able to simplify subgraph expressions, which changes a type argument to a defeq but syntactically different type, and then some naturally formulated <code>simp</code> lemmas can't apply. Maybe the solution is <code>no_index</code>, which I just learned about from Zulip in the last week.</p>",
        "id": 370684332,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1688027761
    },
    {
        "content": "<p><code>no_index</code> seems hard to search for on zulip, because it gets too clever and removes the <code>no_</code>. Can you link to something for the curious?</p>",
        "id": 370740236,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1688037780
    },
    {
        "content": "<p><a href=\"#narrow/stream/287929-mathlib4/topic/simp.20for.20ModelProd/near/363844421\">https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/simp.20for.20ModelProd/near/363844421</a></p>",
        "id": 370746486,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1688038955
    },
    {
        "content": "<p>And I'm happy to see this discussion. I don't have the time/energy to push mathlib graph to be exactly the way I want them, but I think the fact that there are truly multiple notions of 'graph' (and that even in informal mathematics, no single one of them is correct) is worth paying a lot of attention to; a solution that allows for all of them is quite important. </p>\n<p>Formalizing the Robertson/Seymour graph minors structure theorem is one of the things on the horizon for me, and to do that at the right level of generality, one needs multigraphs (and probably ones with directions + decorations on the edges). But for stuff in the direct of Szemeredi's regularity lemma and the strong perfect graph theorem, multigraphs are pointless and cumbersome.   </p>\n<p>Even disregarding directions, the differences between multigraphs and simple graphs  are  maybe larger than one might imagine for the purposes of formalization. Multigraphs need a 'first-class' edge <code>Type</code>, to allow for the notion that an edge in a contracted graph is the same as the one as the one in the original graph, even when its ends are different. Thinking in a more CS way, a multigraph is basically a <code>V x E</code> zero-one matrix. </p>\n<p>On the other hand, simple graphs are often best described with just a vertex type V, together with an adjacency <code>Prop</code> on its pairs, or equivalently a symmetric <code>V x V</code> zero-one matrix. </p>\n<p>One thing to think about is where/how the complement of a graph should be defined. The complement of a multigraph is basically meaningless, but induced subgraph people take complements of simple graphs all the time. </p>\n<p>This is not to mention hypergraphs, loops, half-edges, edge and vertex labels, etc etc. Possibly a good 'data structure' underlying all graphs is a  <code>V x E</code> matrix with entries in a type with zero. Such a matrix can be used to encode all these things (simple graphs with support-two columns in <code>Fin 2</code>, directed graphs with support-two columns in  {0,1,-1},  vertex labels with support-one columns, k-uniform hypergraphs with support-k columns, etc etc). Then typeclasses and interfaces can allow people to do 'normal' graph theory of whatever flavour they want.</p>",
        "id": 370746709,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1688038998
    },
    {
        "content": "<p>While I'm on the topic... </p>\n<p>One of the things that is obviously difficult type-theory-wise is treating subgraphs (or minors) as graphs. Analogous problems happen with the matroids I've been thinking about, and I've had quite some success by leaning much more into set theory, and having a <code>Type</code> of 'potential elements' and a <code>Set</code> of 'actual elements', together with an axiom that states that the structure outside this set is trivial. The analogue for graphs would be something like the following; here I define graphs and give an example subgraph-like definition and a lemma. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Graph</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">inc</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">support_two</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">e</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">inc</span> <span class=\"n\">e</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"n\">inc</span> <span class=\"n\">e</span> <span class=\"n\">v</span> <span class=\"bp\">→</span> <span class=\"n\">inc</span> <span class=\"n\">e</span> <span class=\"n\">w</span> <span class=\"bp\">→</span> <span class=\"n\">u</span> <span class=\"bp\">=</span> <span class=\"n\">v</span> <span class=\"bp\">∨</span> <span class=\"n\">u</span> <span class=\"bp\">=</span> <span class=\"n\">w</span> <span class=\"bp\">∨</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">w</span><span class=\"o\">)</span>\n    <span class=\"c1\">-- each edge is incident with at most two vertices</span>\n  <span class=\"o\">(</span><span class=\"n\">support_subset</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">v</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">inc</span> <span class=\"n\">v</span> <span class=\"n\">e</span> <span class=\"bp\">→</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">V</span> <span class=\"bp\">∧</span> <span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"n\">E</span><span class=\"o\">)</span>\n    <span class=\"c1\">-- incidences only occur within the vertex and edge sets</span>\n\n<span class=\"c1\">-- Delete a set of vertices of a graph</span>\n<span class=\"kd\">def</span> <span class=\"n\">Graph.Delete</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">Graph</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Graph</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">where</span>\n  <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"n\">G.V</span> <span class=\"bp\">\\</span> <span class=\"n\">D</span>\n  <span class=\"n\">E</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"n\">G.E</span> <span class=\"bp\">|</span> <span class=\"bp\">∀</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">G.inc</span> <span class=\"n\">v</span> <span class=\"n\">e</span> <span class=\"bp\">→</span> <span class=\"n\">v</span> <span class=\"bp\">∉</span> <span class=\"n\">D</span><span class=\"o\">}</span>\n  <span class=\"n\">inc</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">v</span> <span class=\"n\">e</span> <span class=\"bp\">↦</span> <span class=\"n\">G.inc</span> <span class=\"n\">v</span> <span class=\"n\">e</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">G.inc</span> <span class=\"n\">w</span> <span class=\"n\">e</span> <span class=\"bp\">→</span> <span class=\"n\">w</span> <span class=\"bp\">∉</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">)</span>\n  <span class=\"n\">support_two</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c1\">--easy</span>\n  <span class=\"n\">support_subset</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c1\">--easy</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">delete_delete</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">Graph</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">D₁</span> <span class=\"n\">D₂</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">G.Delete</span> <span class=\"n\">D₁</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">Delete</span> <span class=\"n\">D₂</span> <span class=\"bp\">=</span> <span class=\"n\">G.Delete</span> <span class=\"o\">(</span><span class=\"n\">D₁</span> <span class=\"bp\">∪</span> <span class=\"n\">D₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"c1\">-- easy,  typechecks</span>\n</code></pre></div>\n<p>The advantage is that theorems like <code>delete_delete</code> actually typecheck, without any hidden coercions or special <code>subgraph</code> type. </p>\n<p>The disadvantage is that one has to explicitly keep track of the vertex and edge sets,  getting proof obligations of the form <code>v ∈ G.V</code> all the time. But I've had some success handling things like this with <code>aesop</code> and autoparams.</p>\n<p>See <a href=\"https://github.com/apnelson1/Matroid\">https://github.com/apnelson1/Matroid</a> for an example of this in action. (You don't have to understand the details; the salient point is that a matroid is, mathematically, a structure on a set, but I've defined it as a structure on a type such that there is a particular <code>Set</code> where the structure 'happens', and then proofs deal with that set explicitly where needed).</p>",
        "id": 370774602,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1688043851
    },
    {
        "content": "<p>Forgot to mention - thanks to <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span>  for suggesting this approach for matroids; it's working quite well. (I have deviated from his original suggestion slightly by discharching the trivial goals using <code>aesop</code>/autoparams rather than the <code>fact</code> system).</p>",
        "id": 370775882,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1688044068
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"266304\">Siddhartha Gadgil</span> <a href=\"#narrow/stream/113488-general/topic/Geometric.20Group.20Theory.20coordination.20.3F/near/369429780\">said</a>:</p>\n<blockquote>\n<p>I will be giving a couple of lectures on something related, but am planning to start working on formalizing topological/geometric methods in Group theory. Is there any update on this. In particular, I did not see any formalization of </p>\n<ul>\n<li>Cayley Graph</li>\n<li>Graph's as normally used in Serre-Bass theory</li>\n<li>CW complexes</li>\n<li>Amalgamated free products and HNN extensions</li>\n</ul>\n<p>Am I correct that none of this is in Mathlib? <span class=\"user-mention silent\" data-user-id=\"303675\">Anand Rao Tadipatri</span> <span class=\"user-mention silent\" data-user-id=\"329754\">Antoine Labelle</span> <span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <span class=\"user-mention silent\" data-user-id=\"461830\">Rémi Bottinelli</span> </p>\n<p>I plan to take as a target the Scott-Wall article \"Topological methods in Group Theory\". Of course collaboration is very welcome.</p>\n</blockquote>\n<p>I have a branch open for amalgamated products <a href=\"https://github.com/leanprover-community/mathlib4/pull/6803\">!4#6803</a></p>",
        "id": 387854728,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1693305571
    },
    {
        "content": "<p>Also HNN extensions and Britton's lemma <a href=\"https://github.com/leanprover-community/mathlib4/pull/6923\">!4#6923</a></p>",
        "id": 388629085,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1693618229
    },
    {
        "content": "<p>Hello. My name is David, and I'm a MMath (integrated masters degree) graduate from the University of Warwick, and I'm currently on a gap year while I'm waiting to reapply for PhDs in geometric group theory. I'm very interested in the advent of AI in mathematics and the formalization effort, and so I'm keen on learning Lean during this gap year. </p>\n<p>As it is usually advised to learn Lean by working on a project, I thought it would be best for me to ask for advice on the Zulip chat regarding what I could feasibly attempt to formalize and, if possible, any guidance in this area. From parsing through different channels, it seems that one big issue when formalizing GGT-related stuff is how graphs are defined in Lean? Why so and what has been tried so far?</p>",
        "id": 476611864,
        "sender_full_name": "David-Ștefan Georgescu",
        "timestamp": 1728830963
    },
    {
        "content": "<p>The definition of simple graph is often discussed here; I suspect that for GGT you'll need another notion (you'll need directed edges maybe?)</p>",
        "id": 476619281,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1728837288
    },
    {
        "content": "<p>There was a PR to instantiate a SimpleGraph as a special case of a Digraph. I don't know if it got merged</p>",
        "id": 476619719,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1728837620
    },
    {
        "content": "<p>There is definitely a very rudimentary simple digraph API now</p>",
        "id": 476619744,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1728837651
    }
]