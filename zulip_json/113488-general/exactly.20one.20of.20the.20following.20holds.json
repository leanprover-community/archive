[
    {
        "content": "<p>How does one canonically state theorems of the form “exactly one of the following statements is true”. One trick I can have tried is to define an inductive Type (not Prop ) in which constructors hold each of the individual props. Is this correct/ideal?</p>",
        "id": 564314899,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765994839
    },
    {
        "content": "<p>Something similar to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.TFAE#doc\">docs#List.TFAE</a> maybe?</p>",
        "id": 564315895,
        "sender_full_name": "Chris Henson",
        "timestamp": 1765995167
    },
    {
        "content": "<p>My propositions are not equivalent</p>",
        "id": 564315966,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765995196
    },
    {
        "content": "<p>Quite the opposite</p>",
        "id": 564315989,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765995201
    },
    {
        "content": "<p>If any of the propositions are true, the others are not.</p>",
        "id": 564316149,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765995257
    },
    {
        "content": "<p>And one of them is necessarily true</p>",
        "id": 564316187,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765995269
    },
    {
        "content": "<p>Yes I understand, I said <em>similar</em>. The condition would be that any proposition in the list being true implies the negation of the others.</p>",
        "id": 564316237,
        "sender_full_name": "Chris Henson",
        "timestamp": 1765995289
    },
    {
        "content": "<p>You however asked for canonical, I am not aware of an existing definition for this.</p>",
        "id": 564316647,
        "sender_full_name": "Chris Henson",
        "timestamp": 1765995444
    },
    {
        "content": "<p>I don't think there's a canonical choice, and I don't know if this is the optimal way to do it, but this would work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ExactlyOne</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ps</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">∃!</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ps</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"bp\">?.</span><span class=\"n\">getD</span><span class=\"w\"> </span><span class=\"n\">False</span>\n</code></pre></div>",
        "id": 564316944,
        "sender_full_name": "James E Hanson",
        "timestamp": 1765995553
    },
    {
        "content": "<p>I could have sworn I remember something like \"<code>EOTF</code>\" being discussed/proposed somewhere, but I can't find it... <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 564317107,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1765995606
    },
    {
        "content": "<p>There is this from 2022: <a class=\"stream-topic\" data-stream-id=\"217875\" href=\"/#narrow/channel/217875-Is-there-code-for-X.3F/topic/.22exactly.20one.20of.20the.20following.20is.20true.22/with/310835906\">#Is there code for X? &gt; \"exactly one of the following is true\"</a>, which has some ideas!</p>",
        "id": 564317409,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1765995711
    },
    {
        "content": "<p>Ah, I think I'm thinking of a discussion from the discord! It was spelled <code>EOFT</code> there, if you'd like to search—but I think you were part of that discussion anyway, so maybe you've already taken it into account. <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 564317696,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1765995826
    },
    {
        "content": "<p>My feeling is that (the lean4 version) of <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>'s suggestion in that thread above is the most similar in nature to the existing TFAE, and lets you avoid having a new inductive:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">EOTF</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">False</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">Q</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">EOTF</span><span class=\"w\"> </span><span class=\"n\">l</span>\n</code></pre></div>",
        "id": 564321251,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1765997153
    },
    {
        "content": "<p>I actually wonder if a Finvec version is better</p>",
        "id": 564332385,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766001533
    },
    {
        "content": "<p>Then we can use fin cases over the indices</p>",
        "id": 564332501,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766001570
    },
    {
        "content": "<p>The extra inductive structure from lists seems unnecessary</p>",
        "id": 564332685,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766001640
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"904624\">James E Hanson</span> <a href=\"#narrow/channel/113488-general/topic/exactly.20one.20of.20the.20following.20holds/near/564316944\">said</a>:</p>\n<blockquote>\n<p>I don't think there's a canonical choice, and I don't know if this is the optimal way to do it, but this would work:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ExactlyOne</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ps</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">∃!</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ps</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"bp\">?.</span><span class=\"n\">getD</span><span class=\"w\"> </span><span class=\"n\">False</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Why not</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ExactlyOne</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ps</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∃!</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">ps</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span>\n</code></pre></div>",
        "id": 564351635,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1766009698
    },
    {
        "content": "<p>Or generalized to support other list-ish containers:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ExactlyOne</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ps</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Membership</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∃!</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">ps</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span>\n</code></pre></div>\n<p>works with <code>List</code>/<code>Set</code>/<code>Finset</code>/<code>Multiset</code>/<code>Array</code><br>\n(doesn't generalize to finvec though)</p>",
        "id": 564351785,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1766009785
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"933054\">Snir Broshi</span> <a href=\"#narrow/channel/113488-general/topic/exactly.20one.20of.20the.20following.20holds/near/564351635\">schrieb</a>:</p>\n<blockquote>\n<p>Why not</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ExactlyOne</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ps</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∃!</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">ps</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ExactlyOne</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ps</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∃!</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">ps</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ExactlyOne</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">True</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ExactlyOne</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">mem_cons_self</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">trivial</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 564352739,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1766010317
    },
    {
        "content": "<p>This could still be suitably generalized with <code>GetElem?</code> though.</p>",
        "id": 564353168,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1766010518
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/113488-general/topic/exactly.20one.20of.20the.20following.20holds/near/564332385\">said</a>:</p>\n<blockquote>\n<p>I actually wonder if a Finvec version is better</p>\n</blockquote>\n<p>Hmm, yeah, that's interesting! It's a lot nicer for access too (<code>P i</code>); in some personal notes I have on TFAE I explore something similar, but over a general index set <code>I</code> instead of some <code>Fin n</code>. <code>Fin</code>/<code>FinVec</code> likely have some nice API around them that would actually make such a thing more practical, I imagine?</p>\n<p>So, maybe it's worth experimenting with <code>Fin.TFAE</code> (or <code>Fun.TFAE.{u} {I:Sort u} (P : I → Prop) : Prop := ∀ i j : I, P i ↔ P j</code>!). The issue of course is compositionality...maps <code>J → I</code> give us TFAE subsets very nicely, but putting TFAE's together requires dealing with <code>⊕</code> or spans. But, the <code>FinVec</code> case might conceivably have nice operations for concatenating vectors? I'm not familiar with the API.</p>",
        "id": 564364738,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1766018464
    },
    {
        "content": "<p>Finvec has nice notation though I would like to see bulleted lists for this particular use case.</p>",
        "id": 564364955,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766018638
    },
    {
        "content": "<p>Aside: In a <code>P : I → Prop</code>-centered description, <code>TFAE P</code> could be  phrased as the fact that <code>P</code> factors through the unique function <code>I → Unit</code>, while <code>EOTF P</code> expresses that the constant map <code>fun _ =&gt; True : Unit → Prop</code> factors uniquely through <code>P</code>. Though, these representations don't lend themselves to very ergonomic formalizations in Lean, as far as I know. :)</p>\n<p>Note: for symmetry, we might want to insist that <code>TFAE P</code> means that <code>P</code> factors uniquely through the unique function <code>I → Unit</code>. This is harmless when <code>I</code> is nonempty, but does conflict with Mathlib's definition when <code>I</code> is empty. Mathlib effectively drops the uniqueness and allows <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/List/TFAE.html#List.tfae_nil\"><code>List.tfae_nil</code></a>. Also, the alternative \"factors uniquely\" configurations among <code>P</code> and <code>Unit</code> are unfortunately trivial.</p>",
        "id": 564364977,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1766018657
    },
    {
        "content": "<p>Or maybe even named item lists so we get to talk about the individual hypothesis by names we pick.</p>",
        "id": 564365013,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766018686
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/113488-general/topic/exactly.20one.20of.20the.20following.20holds/near/564364955\">said</a>:</p>\n<blockquote>\n<p>Finvec has nice notation though I would like to see bulleted lists for this particular use case.</p>\n</blockquote>\n<p>I would even like to go a step further and use numbered lists with optional names! :)</p>",
        "id": 564365025,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1766018692
    },
    {
        "content": "<p>Technically a finmap can achieve this. So take a finite type (for example an inductive type with 3 no argument constructors for naming 3 hypothesis</p>",
        "id": 564365317,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766018966
    },
    {
        "content": "<p>And then, since you are only using the constructors as indices, why not just put the props with their indexing constructors. And suddenly you have the inductive type solution I mentioned above.</p>",
        "id": 564365367,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766019020
    },
    {
        "content": "<p>The example notation I've been thinking about is something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">TFAE</span>\n<span class=\"w\">  </span><span class=\"mf\">1.</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Metric</span><span class=\"bp\">.</span><span class=\"n\">sphere</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"n\">UnitNorm</span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"bp\">‖</span><span class=\"n\">z</span><span class=\"bp\">‖</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"mf\">3.</span><span class=\"w\"> </span><span class=\"bp\">‖</span><span class=\"n\">z</span><span class=\"bp\">‖</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n</code></pre></div>\n<p>but the optional naming is a bit awkward.</p>",
        "id": 564365379,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1766019035
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/113488-general/topic/exactly.20one.20of.20the.20following.20holds/near/564365367\">said</a>:</p>\n<blockquote>\n<p>And then, since you are only using the constructors as indices, why not just put the props with their indexing constructors. And suddenly you have the inductive type solution I mentioned above.</p>\n</blockquote>\n<p>I feel like that might be load-bearing \"just\". <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span> Doesn't this mean I can't have a uniform TFAE API that works across all such TFAE-like types, because each TFAE must apply to a different type which it knows nothing about? Or I need to have some kind of TFAE-API instance that I can apply with <code>deriving</code>?</p>",
        "id": 564365769,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1766019355
    },
    {
        "content": "<p>You put the api in a typeclass</p>",
        "id": 564365865,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766019437
    },
    {
        "content": "<p>Anyway, I think life is simpler without one more typeclass. Finvec fits the bill neatly</p>",
        "id": 564365908,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766019488
    },
    {
        "content": "<p>The other thing I would worry about with a typeclass-on-custom-type model is that it could make it harder to make TFAE's on the fly, mid-proof.</p>",
        "id": 564365961,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1766019532
    },
    {
        "content": "<p>I do wonder if it's worth having some way to actually store the name in the expression somehow by modifying the index type somehow; I think putting the <code>Prop</code> inside the index type might be rough, but I'm curious if we could allow naming via being a bit more flexible on our index type somehow.</p>\n<p>Another solution is metadata somewhere, but this is liable to be erased; another is asking for <code>Fin n → Prop × Name</code> and just working around that, but that jettisons many nice properties (but, it keeps the name with the <code>Prop</code> even if the index changes, which is nice); another is an extension that tries to store indices or <code>Prop</code>s locally and guides an elaborator.</p>\n<p>Every approach feels a little bit wrong, somehow...my inclination, if I had to give one, though, is that this is really an elaboration feature, and so should live in the elaborator somehow, not in the semantics of the expression.</p>",
        "id": 564366770,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1766020245
    },
    {
        "content": "<p>I think that's a nice ambition. For now I am going to go ahead with Finvecs</p>",
        "id": 564366837,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766020326
    },
    {
        "content": "<p>How about defining 'at most one is true' and 'at least one is true', as if we define singleton with exists and subsingleton?</p>",
        "id": 564368267,
        "sender_full_name": "Jihoon Hyun",
        "timestamp": 1766021632
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ExactlyOne</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">propVec</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">∃!</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">propVec</span><span class=\"w\"> </span><span class=\"n\">i</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">AtLeastOne</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">propVec</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">propVec</span><span class=\"w\"> </span><span class=\"n\">i</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">AtmostOne</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">propVec</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"n\">propVec</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">ExactlyOne</span><span class=\"w\"> </span><span class=\"n\">propVec</span>\n</code></pre></div>",
        "id": 564368451,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766021770
    },
    {
        "content": "<p>ahh it's not constructively correct</p>",
        "id": 564368573,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1766021940
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">AtmostOne</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">propVec</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">propVec</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">propVec</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">j</span>\n</code></pre></div>",
        "id": 564368626,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1766021981
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Cardinal</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ExactlyOne</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">propVec</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">(</span><span class=\"n\">propVec</span><span class=\"w\"> </span><span class=\"bp\">⁻¹'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">True</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n</code></pre></div>\n<p><span aria-label=\"sunglasses\" class=\"emoji emoji-1f60e\" role=\"img\" title=\"sunglasses\">:sunglasses:</span></p>",
        "id": 564372648,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1766025864
    },
    {
        "content": "<p>You can use <code>ExistsUnique</code> and pass it a <code>Fin n</code> indexed vector using the <code>![prop 1, prop2, prop 3]</code> notation.</p>",
        "id": 564384074,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1766035702
    },
    {
        "content": "<p>Ooh, I see that's also in Shreyas's latest message.</p>",
        "id": 564384134,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1766035751
    }
]