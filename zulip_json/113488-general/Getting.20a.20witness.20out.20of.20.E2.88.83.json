[
    {
        "content": "<p>Is my understanding correct that I can't in general get the witness out of an existential formula? I.e., it's not possible to write the function</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">getWitness</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"o\">:=</span>\n  <span class=\"c1\">-- get the x that supposedly exists</span>\n</code></pre></div>\n<p>without invoking <code>Exists.choose</code>?</p>",
        "id": 324579447,
        "sender_full_name": "Sebastian Zivota",
        "timestamp": 1675077098
    },
    {
        "content": "<p>You can use <code>obtain ⟨x, hx⟩ := h</code> if you are proving a <code>Prop</code>.</p>",
        "id": 324580191,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1675077329
    },
    {
        "content": "<p>Yes you are correct. Defining <code>getWitness</code> is equivalent to defining <code>Exists.choose</code>.</p>",
        "id": 324580228,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1675077346
    },
    {
        "content": "<p>Regarding what Riccardo said, this is what the following error is referring to:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">getWitness</span> <span class=\"o\">{</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span>\n  <span class=\"c1\">-- induction tactic failed, recursor 'Exists.dcases_on' can only eliminate into Prop</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>This is saying that you're only allowed to get a witness (using the built-in theory) if your goal is a Prop.</p>",
        "id": 324580449,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1675077407
    },
    {
        "content": "<p>I assume this is to preserve proof irrelevance? As in, I'm allowed to get the witness, but only in a context where it doesn't matter which specific value the witness has.</p>",
        "id": 324580653,
        "sender_full_name": "Sebastian Zivota",
        "timestamp": 1675077481
    },
    {
        "content": "<p>Yeah, when paired with the computation rule associated to the recursor (that <code>Exists.dcases_on (Exists.mk x h) f = f x h</code> in this case, I believe)</p>",
        "id": 324581213,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1675077654
    },
    {
        "content": "<p>In fact, <a href=\"#narrow/stream/270676-lean4/topic/magical.20witness/near/273213204\">there was temporarily a bug in Lean 4</a> where you could prove false by eliminating an existential using projection notation. The kernel was allowing you to get the witness that was in the proof term when you <em>weren't</em> eliminating to Prop.</p>",
        "id": 324581981,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1675077906
    },
    {
        "content": "<p>If you need a proof-relevant variant of <code>Exists</code>, use <code>Sigma</code>.</p>",
        "id": 324582111,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1675077952
    },
    {
        "content": "<p>There is also a way to get the witness provided you're over a fintype, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/fintype.choose\">docs#fintype.choose</a></p>",
        "id": 324595327,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1675082172
    },
    {
        "content": "<p>So this enumerates all elements of the type and checks the predicate for each? The type theorist in me is shocked and horrified.</p>",
        "id": 324597156,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1675082767
    },
    {
        "content": "<p>why so, Jannis?</p>",
        "id": 324600571,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1675083734
    },
    {
        "content": "<p>and furthermore there's also subsingleton elimination, which allows you to eliminate <del>into</del> <em>from</em> types that are syntactically a subsingleton or something along those lines</p>",
        "id": 324600719,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1675083789
    },
    {
        "content": "<p>(ctrl+f for syntactic subsingleton <a href=\"https://lean-forward.github.io/logical-verification/2018/41_notes.html\">here</a>)</p>",
        "id": 324601459,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1675083991
    },
    {
        "content": "<p>Because we have a computable thing (otherwise the predicate would not be decidable or the type would not be a fintype), then we make it a <code>Prop</code> by wrapping it in an existential (saying, roughly, 'we don't care about computation here') and then we re-introduce computation in the slowest way possible. I'm sure there are good reasons for this in the context of mathlib, it just hurts a little bit. ;)</p>",
        "id": 324614435,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1675087608
    },
    {
        "content": "<p>i think it's in some ways just done because people hate seeing <code>noncomputable</code> instinctively, even if it doesn't matter at all really</p>",
        "id": 324616975,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1675088166
    },
    {
        "content": "<p>It's saying that if someone gives you the mere proof that there's a unique element, then there's at least some way to recover that value. It's the best you can do without knowing anything else about the type or the predicate. Wouldn't you agree it's better to have it around than not having it all?</p>\n<p>Of course, given the specifics of your type and predicates, if you can use a better algorithm (and you care about runtime characteristics rather than just whether something can be computed), you should.</p>",
        "id": 324617264,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1675088229
    },
    {
        "content": "<p>I doubt that <code>fintype.choose</code> is used much in definitions. Most of the time mathlib provides definitions rather than proving existentials.</p>",
        "id": 324617938,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1675088394
    },
    {
        "content": "<p>It can also be used to avoid the axiom of choice inside of proofs, if that's something you care about doing. I'm not sure I've ever heard of anyone caring about algorithmic complexity of algorithms that appear inside of proofs yet.</p>",
        "id": 324618407,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1675088507
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/stream/113488-general/topic/Getting.20a.20witness.20out.20of.20.E2.88.83/near/324595327\">said</a>:</p>\n<blockquote>\n<p>There is also a way to get the witness provided you're over a fintype, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/fintype.choose\">docs#fintype.choose</a></p>\n</blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.find\">docs#nat.find</a> is another version for <code>nat</code> which obviously isn't a <code>fintype</code></p>",
        "id": 324618909,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1675088609
    },
    {
        "content": "<p>(<span class=\"user-mention\" data-user-id=\"256311\">@Jannis Limperg</span> And maybe you'll like that <code>nat.find</code> works by testing each natural number successively until the predicate is true <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span>)</p>",
        "id": 324619746,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1675088783
    },
    {
        "content": "<p>The reason I hit on this question in the first place is my toy axiomatization of the projective plane. One of the axioms says that for any two points there is a line containing both of them, and this allows defining the connecting line of any two points using <code>Exists.choose</code>. So the connecting line would be essentially noncomputable, even in cases where there should be no problem computing it. I'm now wondering if it wouldn't be better to take the function <code>connecting_line (p q : P) : L</code> as fundamental, as opposed to the existence statement.</p>",
        "id": 324620075,
        "sender_full_name": "Sebastian Zivota",
        "timestamp": 1675088846
    },
    {
        "content": "<p>I was actually thinking about that before. One wrinkle is that <code>connecting_line p p</code> can be any line that passes through <code>p</code>, which isn't very unique.</p>\n<p>Another solution is to keep the projective plane axiomatization the same but have a separate typeclass that provides a computable <code>connecting_line</code> that provides a witness for the existential.</p>",
        "id": 324620973,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1675089039
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113488-general/topic/Getting.20a.20witness.20out.20of.20.E2.88.83/near/324617264\">said</a>:</p>\n<blockquote>\n<p>It's saying that if someone gives you the mere proof that there's a unique element, then there's at least some way to recover that value. It's the best you can do without knowing anything else about the type or the predicate. Wouldn't you agree it's better to have it around than not having it all?</p>\n</blockquote>\n<p>Sure, I don't hate the lemma at all, it does what it can with the information provided. My question would just be why the information provided is not a <code>Sigma</code>. (And again, there may be good reasons for that.)</p>",
        "id": 324621842,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1675089237
    },
    {
        "content": "<p>What do you mean, providing a <code>Sigma</code> to the lemma?</p>",
        "id": 324622570,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1675089399
    },
    {
        "content": "<p>Like if you are working constructively, why did you make an <code>Exists</code> in the first place</p>",
        "id": 324622831,
        "sender_full_name": "Reid Barton",
        "timestamp": 1675089460
    },
    {
        "content": "<p>Maybe you have a general lemma that's not proved constructively, but in your specific circumstances you can use this lemma with <code>fintype.choose</code> to get a quick algorithm.</p>",
        "id": 324623199,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1675089536
    },
    {
        "content": "<p>By which you mean a sloooooooow algorithm.</p>",
        "id": 324623248,
        "sender_full_name": "Reid Barton",
        "timestamp": 1675089550
    },
    {
        "content": "<p>Maybe it's <code>fin 5</code> or something else of small cardinality and it's not so bad.</p>",
        "id": 324623390,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1675089588
    },
    {
        "content": "<p>Then you can probably do it faster in your head as well</p>",
        "id": 324623561,
        "sender_full_name": "Reid Barton",
        "timestamp": 1675089626
    },
    {
        "content": "<p>I remember when the odd order theorem was proved in Coq, Gonthier would talk about how the proof was purely constructive and so it gave an algorithm for finding a composition series for any group of odd order. That always seemed like a strange thing to point out.</p>",
        "id": 324623855,
        "sender_full_name": "Reid Barton",
        "timestamp": 1675089709
    },
    {
        "content": "<p>Since \"we already know the odd order theorem is true so just test every subset to see if it's a normal subgroup\" is also such an algorithm.</p>",
        "id": 324624165,
        "sender_full_name": "Reid Barton",
        "timestamp": 1675089763
    },
    {
        "content": "<p>Another thing about <code>fintype.choose</code> is that it's implementing the function from <code>Exists_unique</code> to <code>Sigma</code>, which is nice to know it exists, hence why mathlib should have it.</p>",
        "id": 324624982,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1675089814
    },
    {
        "content": "<p>Do you happen to know what sort of algorithm falls out of Gonthier's proof?</p>",
        "id": 324625236,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1675089867
    },
    {
        "content": "<p>If we're taking bets, then my bet is that it's a lot worse than Reid's suggestion, which is...already not great.</p>",
        "id": 324626875,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1675090274
    }
]