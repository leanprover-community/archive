[
    {
        "content": "<p>Hey all, the team at Morph Labs has been extremely impressed by the formalization projects (PFR, FLT-regular) that have been completed using Blueprint. That seems like the best extant solution for coordinating large-scale formalizations (cc <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>). It is also, as <span class=\"user-mention\" data-user-id=\"657719\">@Terence Tao</span> has pointed out, a promising locus for applying LLMs and proof automation. We'd like to apply our design and engineering skills to make the Blueprint experience even better and significantly lower the barrier of entry for both experienced mathematicians and formalizers to start and finish formalizations. We would love to hear from the community about ways that Blueprint could improved.</p>\n<p>From some recent discussion in the PFR stream as well as DMs, it seems like some features that people like to see include:</p>\n<ul>\n<li>Integration with GitHub issues or some other kind of issue tracking / todo item management system</li>\n<li>Automated linking and generation of dependencies instead of <code>\\uses{}</code> in the LaTeX</li>\n<li>Faster updates on the status of nodes in the blueprint (e.g. faster CI for checking updated proofs)</li>\n<li>Bidirectional integration with GitHub PRs / issues (related to the above, i.e. automatic insertion of <code>\\leanok</code>s)</li>\n<li>More expressive status indicators for blueprint nodes to indicate help wanted on e.g. informal text or formal proof</li>\n</ul>\n<p>Some features that I would be excited to see would include:</p>\n<ul>\n<li>AI-driven suggestions of informal and formal proof sketches for blueprint items which are missing either;</li>\n<li>Automated creation of blueprint scaffolding from plain LaTeX</li>\n<li>Support for Markdown and community-driven edits to individual sections of the blueprint, with a way of keeping a LaTeX source of truth in sync</li>\n<li>Automated generation of a digest of all necessary information for getting a contributor up to speed without necessarily pulling in the entire dependency graph or forcing them to jump through the LaTeX themselves.</li>\n</ul>\n<p>We're excited to expand this list and to hear what you all have to say.</p>",
        "id": 406401168,
        "sender_full_name": "Jesse Michael Han",
        "timestamp": 1701902401
    },
    {
        "content": "<p>and of course Blueprint wouldn't exist without <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span>'s amazing efforts of developing it in the first place!</p>",
        "id": 406401636,
        "sender_full_name": "Jesse Michael Han",
        "timestamp": 1701902625
    },
    {
        "content": "<p>I think there should be an explicit source of truth for the dependency tree. And I think <code>\\uses</code> is a pretty good way of doing that.<br>\nSo have automation help with suggesting new links is of course a good idea. But I would be sad to see <code>\\uses</code> disappear.</p>",
        "id": 406441254,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1701918709
    },
    {
        "content": "<blockquote>\n<p>Automated linking and generation of dependencies instead of \\uses{} in the LaTeX</p>\n</blockquote>\n<p>Not having this is an explicit very important feature of the blueprint plugin. It would be easy to collect uses of <code>\\ref</code> in the code source, but it would miss a lot of links.</p>",
        "id": 406443527,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1701919334
    },
    {
        "content": "<p>you could do both, no?</p>",
        "id": 406443705,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701919396
    },
    {
        "content": "<p>Faster updates on the status of nodes in the blueprint would be nice but this is only relevant from Scholze or Tao starts a project. For normal projects, the project speed does not require faster updates.</p>",
        "id": 406443783,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1701919417
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/CFP.3A.20improved.20Blueprint.20UX/near/406443705\">said</a>:</p>\n<blockquote>\n<p>you could do both, no?</p>\n</blockquote>\n<p>It would be very brittle if people start omitting <code>\\uses</code> because there is a <code>\\ref</code> and then later remove the <code>\\ref</code>.</p>",
        "id": 406443977,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1701919466
    },
    {
        "content": "<p>Maybe I don't have enough experience with blueprints but it seems strange that there would be a use that is not a <code>\\ref</code></p>",
        "id": 406444156,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701919522
    },
    {
        "content": "<p>is this some abstract notion of \"use\"?</p>",
        "id": 406444196,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701919534
    },
    {
        "content": "<p>I think you don't have enough experience with reading math papers.</p>",
        "id": 406444238,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1701919551
    },
    {
        "content": "<p>Sure but I'm not talking about math papers I'm talking about blueprints</p>",
        "id": 406444334,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701919570
    },
    {
        "content": "<p>It is very important that math papers can be gradually turned into blueprints.</p>",
        "id": 406444415,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1701919595
    },
    {
        "content": "<p>it still seems like this would be served by <code>\\uses</code> as an extra thing on top of <code>\\ref</code></p>",
        "id": 406444577,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701919640
    },
    {
        "content": "<p>if someone removes a <code>\\ref</code> then I guess it's not being used any more, I would not immediately assume that the link remains in the face of such a refactor</p>",
        "id": 406444771,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701919685
    },
    {
        "content": "<p>Having a script that parses <code>\\ref</code>s and suggests <code>\\uses</code> that way is certainly possible and a good idea.<br>\nBut <code>\\ref</code> and <code>\\uses</code> serve different purposes.</p>",
        "id": 406444810,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1701919699
    },
    {
        "content": "<p>You want <code>\\uses</code> when using a definition. But <code>\\ref</code> is almost never used that way.</p>",
        "id": 406444871,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1701919719
    },
    {
        "content": "<p>is it safe to say that <code>\\ref</code> is a subset of <code>\\uses</code>?</p>",
        "id": 406445015,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701919773
    },
    {
        "content": "<p>Yeah, having some tool to <em>suggest</em> <code>\\uses</code> based on <code>\\refs</code> or other contexts, but does not <em>replace</em> them, is what I had in mind also.</p>",
        "id": 406445064,
        "sender_full_name": "Terence Tao",
        "timestamp": 1701919793
    },
    {
        "content": "<p>some more formalized notion of using a definition would be useful here, like a semantic markup on the notation or so</p>",
        "id": 406445322,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701919876
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/CFP.3A.20improved.20Blueprint.20UX/near/406445015\">said</a>:</p>\n<blockquote>\n<p>is it safe to say that <code>\\ref</code> is a subset of <code>\\uses</code>?</p>\n</blockquote>\n<p>You can have forward <code>\\ref</code>s.</p>\n<p>\"We now prove a result in complex analysis. We will prove the $p$-adic analytic analogue of this in Proposition~\\ref{fancy-label}.\"</p>",
        "id": 406445355,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1701919886
    },
    {
        "content": "<p>Are blueprints ordered in dependency order?</p>",
        "id": 406445478,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701919921
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/CFP.3A.20improved.20Blueprint.20UX/near/406445015\">said</a>:</p>\n<blockquote>\n<p>is it safe to say that <code>\\ref</code> is a subset of <code>\\uses</code>?</p>\n</blockquote>\n<p>For lemmas, that would probably be the case.  For definitions... I ended up removing some \\uses leading back to core definitions (like the definition of entropy) because it that really cluttered up the dependency graph (this could in part because the dependency graph does not eliminate transitive edges).</p>",
        "id": 406445534,
        "sender_full_name": "Terence Tao",
        "timestamp": 1701919927
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/CFP.3A.20improved.20Blueprint.20UX/near/406445478\">said</a>:</p>\n<blockquote>\n<p>Are blueprints ordered in dependency order?</p>\n</blockquote>\n<p>No, in whatever order the author organizes the LaTeX</p>",
        "id": 406445578,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1701919944
    },
    {
        "content": "<p>are they acyclic?</p>",
        "id": 406445614,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701919958
    },
    {
        "content": "<p><code>\\uses</code> is. But <code>\\ref</code> doesn't have to be.</p>",
        "id": 406445643,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1701919970
    },
    {
        "content": "<p>There are no formal guarantees that the <code>\\uses</code>-graph is a DAG, atm. (<span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> correct me if I'm wrong.)</p>",
        "id": 406445741,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1701920005
    },
    {
        "content": "<p>so if you are suggesting <code>\\uses</code> based on <code>\\ref</code> you will have to break cycles somehow</p>",
        "id": 406445902,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701920046
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/CFP.3A.20improved.20Blueprint.20UX/near/406445322\">said</a>:</p>\n<blockquote>\n<p>some more formalized notion of using a definition would be useful here, like a semantic markup on the notation or so</p>\n</blockquote>\n<p>This would probably be a nice feature. But you quickly run into natural-language pretty printing issues. So I think it's great to just have a non-pretty-printing <code>\\uses</code>.</p>",
        "id": 406445938,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1701920061
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/CFP.3A.20improved.20Blueprint.20UX/near/406445902\">said</a>:</p>\n<blockquote>\n<p>so if you are suggesting <code>\\uses</code> based on <code>\\ref</code> you will have to break cycles somehow</p>\n</blockquote>\n<p>Sure, by not accepting some of the suggestions.</p>",
        "id": 406446022,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1701920088
    },
    {
        "content": "<p>well it's a bit noisy to be suggesting things that break the dag property</p>",
        "id": 406446128,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701920125
    },
    {
        "content": "<p>You could filter out all forward refs in the LaTeX ordering (possibly behind an <code>--option</code> to the suggestion tool).</p>",
        "id": 406446332,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1701920180
    },
    {
        "content": "<p>But you can also have backrefs that aren't mathematical dependencies.</p>",
        "id": 406446357,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1701920195
    },
    {
        "content": "<p>I think you will need a <code>\\notuses</code> in order to permanently reject suggestions or else they will keep coming back</p>",
        "id": 406446504,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701920246
    },
    {
        "content": "<p>That might be a good idea, yes.</p>",
        "id": 406446606,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1701920283
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113488-general/topic/CFP.3A.20improved.20Blueprint.20UX/near/406445741\">said</a>:</p>\n<blockquote>\n<p>There are no formal guarantees that the <code>\\uses</code>-graph is a DAG, atm. (<span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> correct me if I'm wrong.)</p>\n</blockquote>\n<p>This isn't checked, but it would be easy to check.</p>",
        "id": 406446626,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1701920284
    },
    {
        "content": "<p>Tbh managing the <code>\\uses</code> was not too bad to do manually.  One could imagine one way in which casual participants of a project could help out would be to find out minor issues in the blueprint such as a misplaced <code>\\uses</code>.  Having some GUI to add or remove a <code>\\uses</code> with a few mouseclicks (e.g., adding a \\use autosuggested coming from a \\ref) rather than manually editing the LaTeX code would be nice, but certainly not essential.</p>",
        "id": 406446716,
        "sender_full_name": "Terence Tao",
        "timestamp": 1701920310
    },
    {
        "content": "<p>How important is it that the code is latex + stuff rather than lean + latex or some other arrangement?</p>",
        "id": 406446861,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701920347
    },
    {
        "content": "<p>I'm a bit worried that the suggestion thing is over-engineered. I don't think that managing those <code>\\uses</code> can be a significant amount of work. Updating them when Lean name change is painful but this has nothing to do with <code>\\ref</code>.</p>",
        "id": 406446934,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1701920369
    },
    {
        "content": "<p>(embedding in lean + stuff would solve the name change issue)</p>",
        "id": 406447131,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701920417
    },
    {
        "content": "<p>I think it is important to keep LaTeX as the primary input. It allows anyone to write a blueprint.</p>",
        "id": 406447270,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1701920463
    },
    {
        "content": "<p>it could be 99% latex with some <code>#lang</code> thing at the beginning</p>",
        "id": 406447362,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701920489
    },
    {
        "content": "<p>downside is that you won't be able to directly process it with a latex tool unless you get clever with a polyglot</p>",
        "id": 406447518,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701920531
    },
    {
        "content": "<p>Mario I think you overestimate what average mathematicians can do with a computer.</p>",
        "id": 406447634,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1701920573
    },
    {
        "content": "<p>What is the workflow for writing these blueprints? Throw it in overleaf / your favorite latex editor and use a no-op macro for <code>\\uses</code>?</p>",
        "id": 406447801,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701920621
    },
    {
        "content": "<p>Yes, they come with no-op macros.</p>",
        "id": 406447909,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1701920645
    },
    {
        "content": "<p>the thing about using latex is that it seriously constrains our ability to improve the experience. I totally get the motivation, but it is a limitation</p>",
        "id": 406448180,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701920733
    },
    {
        "content": "<p>I do like that the blueprint compiles both in regular LaTeX as a printed form, and in the blueprint web page.  Particularly since I never bothered to install blueprint software on my local laptop, so it made it possible to check that the blueprint didn't have really egregious build errors without having to push to Github.</p>",
        "id": 406448183,
        "sender_full_name": "Terence Tao",
        "timestamp": 1701920735
    },
    {
        "content": "<p>not being able to check the validity of lean references is the worst part of this workflow IMO. Especially if people don't even run the blueprint software locally, it's all just down to copy paste</p>",
        "id": 406448828,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701920930
    },
    {
        "content": "<p>This limitation is a trade-off. My conjecture was that it was a good one, and the real world agrees so far.</p>",
        "id": 406448911,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1701920956
    },
    {
        "content": "<p>I think this is a good approach, but I'm not sure we have much data on the alternatives, they might be palatable too. AFAICT we're just projecting</p>",
        "id": 406449180,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701921024
    },
    {
        "content": "<p>Not being able to check validity of Lean references is a regression that happened when Utensil quickly hacked some Lean 4 support. There were no problem in Lean 3. However it did require running the blueprint locally.</p>",
        "id": 406449210,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1701921029
    },
    {
        "content": "<p>I meant for the case where you only run blueprint in CI</p>",
        "id": 406449268,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701921047
    },
    {
        "content": "<p>So maybe it's not so much the \\uses that should be moved off of the LaTeX platform, but rather the \\lean and \\leanok macros?</p>",
        "id": 406449298,
        "sender_full_name": "Terence Tao",
        "timestamp": 1701921057
    },
    {
        "content": "<p>and assuming all the bugs are fixed</p>",
        "id": 406449333,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701921067
    },
    {
        "content": "<p>Oh sure, it was caught by CI even if you don't run the blueprint locally.</p>",
        "id": 406449348,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1701921074
    },
    {
        "content": "<p>yeah but that's way too long an editing cycle</p>",
        "id": 406449401,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701921092
    },
    {
        "content": "<p>Moving the <code>\\lean</code> out of the TeX code would probably be less convenient.</p>",
        "id": 406449583,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1701921133
    },
    {
        "content": "<p>but maybe the people who are allergic to lean are willing to deal with that editing cycle since it is what they are used to?</p>",
        "id": 406449585,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701921135
    },
    {
        "content": "<p>We can check lean references even in the tex code if needed, but something has to run locally</p>",
        "id": 406449747,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701921182
    },
    {
        "content": "<p>One thing that is definitely possible if you have the Lean code and the TeX file is to check that every declaration mentioned in a <code>\\lean</code> exists. Those can be extracted without compiling the TeX code. We can even change the no-op macros used by the regular TeX compiler into something that logs the list of Lean declarations to a file (this would be more robust).</p>",
        "id": 406450031,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1701921256
    },
    {
        "content": "<p>Is it too overengineered to have a vscode extension which does the lean reference check in-editor?</p>",
        "id": 406450116,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701921284
    },
    {
        "content": "<p>of course I have no idea what editors the target audience is using</p>",
        "id": 406450213,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701921313
    },
    {
        "content": "<p>so this may not be sufficient</p>",
        "id": 406450233,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701921319
    },
    {
        "content": "<p>I need to go now, but I promise I will devote time to this around Christmas.</p>",
        "id": 406450258,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1701921325
    },
    {
        "content": "<p>If we end up having something like a github issues page for each blueprint node in order to handle comments, claims, updates, etc., this would be the logical home to store \\lean and \\leanok type information, rather than the LaTeX, I think.</p>",
        "id": 406451112,
        "sender_full_name": "Terence Tao",
        "timestamp": 1701921567
    },
    {
        "content": "<p>(assuming that the issues page can somehow store metadata)</p>",
        "id": 406451279,
        "sender_full_name": "Terence Tao",
        "timestamp": 1701921613
    },
    {
        "content": "<p>I don't think you can attach metadata in the usual sense of the word. But you can programmatically edit and parse the comments in an issue, and the topmost comment is often used to store some extra data. This is how we manage dependency chains of PRs for mathlib, for example.</p>",
        "id": 406452321,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1701921888
    },
    {
        "content": "<p>What is <code>\\leanok</code> actually doing? Does the blueprint repo have any documentation?</p>",
        "id": 406452829,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701922030
    },
    {
        "content": "<p>(I'm looking at <a href=\"https://github.com/PatrickMassot/leanblueprint\">https://github.com/PatrickMassot/leanblueprint</a>, it tells me very little about how to install it)</p>",
        "id": 406453052,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701922093
    },
    {
        "content": "<p>It changes the color of the dependency graph bubble and adds a checkmark to the blueprint printout, and I think that's about it.</p>",
        "id": 406453086,
        "sender_full_name": "Terence Tao",
        "timestamp": 1701922109
    },
    {
        "content": "<p>oh so you have to manually indicate that proofs are done?</p>",
        "id": 406453210,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701922146
    },
    {
        "content": "<p>yeah</p>",
        "id": 406453225,
        "sender_full_name": "Terence Tao",
        "timestamp": 1701922152
    },
    {
        "content": "<p>...yeah that doesn't seem necessary, CI can calculate that itself</p>",
        "id": 406453301,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701922175
    },
    {
        "content": "<p>my current understanding (wearing my CS hat) is that Blueprint is a static website generator which uses a LaTeX document as a source of truth; it calculates a color coded dependency graph, an XML render of the LaTeX document with markup controlled by macros like /leanok, and can export to PDF as well</p>",
        "id": 406453655,
        "sender_full_name": "Jesse Michael Han",
        "timestamp": 1701922292
    },
    {
        "content": "<p>\\leanok is used both for proofs and for statements.  The \\leanok flag for statements is saying that the statement of the lemma is satisfactory and not a placeholder.  That flag may be a little harder to automate, because one may have an initial spelling of the lemma in Lean that technically compiles, but might not be what one actually wants to prove</p>",
        "id": 406453889,
        "sender_full_name": "Terence Tao",
        "timestamp": 1701922351
    },
    {
        "content": "<p>you could indicate that on the lean side with something like <code>@[provisional] def foo</code></p>",
        "id": 406454361,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701922497
    },
    {
        "content": "<p>Yes, that sounds reasonable to me.</p>",
        "id": 406454606,
        "sender_full_name": "Terence Tao",
        "timestamp": 1701922564
    },
    {
        "content": "<p>One slight advantage of relying on the lean side to supply the \\leanok information is that it can possibly describe partial lean formalization in which multiple Lean lemmas are assigned to one Blueprint node, but only some of them are fully formalized at a given point in time.  The Latex \\leanok macro can only supply one boolean bit of information in this regard.</p>",
        "id": 406455183,
        "sender_full_name": "Terence Tao",
        "timestamp": 1701922750
    },
    {
        "content": "<p>even in the 1-to-1 case, we could even add a no-op tactic combinator to annotate steps with missing proofs on the Lean side, with a progress indicator (e.g. 5/8 steps discharged) updated in the blueprint node by CI</p>",
        "id": 406456513,
        "sender_full_name": "Jesse Michael Han",
        "timestamp": 1701923151
    },
    {
        "content": "<p>The social organization parts seem like they would be difficult to do in a static web site, should \"claims\" appear on the graph?</p>",
        "id": 406456686,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701923207
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/CFP.3A.20improved.20Blueprint.20UX/near/406447362\">said</a>:</p>\n<blockquote>\n<p>it could be 99% latex with some <code>#lang</code> thing at the beginning</p>\n<p>downside is that you won't be able to directly process it with a latex tool unless you get clever with a polyglot</p>\n</blockquote>\n<p>Why not have it just be 100% LaTeX and yet still processable by Lean (e.g., via a custom frotend)? For instance, Alloy can process a pure C file as a Lean file.</p>",
        "id": 406458463,
        "sender_full_name": "Mac Malone",
        "timestamp": 1701923898
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315577\">@Mac Malone</span> Because parsing LaTeX is hard. And mathematicians exploit every crazy feature/bug that LaTeX has.</p>",
        "id": 406463829,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1701926711
    },
    {
        "content": "<p>And you don't want to put restrictions on the kind of LaTeX that can be used in blueprints.</p>",
        "id": 406463847,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1701926729
    },
    {
        "content": "<p>It's dead simple to check the validity of Lean declarations, that's what <code>inv check</code> did. It can also check sorries in them, I just didn't have enough spare time to finish it. It's not a reason to switch away from the LaTeX form of blueprint that mathematicians feel more comfortable than other technical tools. The division of labor is the essential idea here.</p>\n<p>Observing the generated dep graph then modifying a <code>\\use</code>, then just regenerate the blueprint in a few seconds (locally) is dead simple too, much easier than to fire up Lean, edit some code (like stating the lemma and writing the proof referencing another lemma) and wait for some automation completes. The point is to make the blueprint to be the source of the truth (of mathematical interpretation), not the other way around. Anything checking the Lean side came later.</p>\n<p><code>\\lean</code> also has to be manually maintained, it's how to refer to a formal thing from the informal world, and it can't be automated unless we fire up LLMs to guess the correspondence, which is also over engineering.</p>\n<p><code>\\leanok</code> can be automated easily, as a bot to check the Lean side, hinted by <code>\\lean</code>in LaTeX and submit PRs to the blueprint. It doesn't need to alter the blueprint itself as well.</p>",
        "id": 406471150,
        "sender_full_name": "Utensil Song",
        "timestamp": 1701930459
    },
    {
        "content": "<p>Issues can also be created based on the nodes in the blueprint in a CI, the CI can also monitor the status of the issues, or be requested like bors comments to change the status of claims etc.</p>",
        "id": 406471700,
        "sender_full_name": "Utensil Song",
        "timestamp": 1701930649
    },
    {
        "content": "<p>Also there is actually poor correspondence between <code>\\uses</code> and <code>\\ref</code>. <code>\\uses</code> highlights the hard dependency, ignores transitive dependency, and less important dependencies, so if a <code>\\ref</code> is mentioned in the proof, it doesn't mean it should make into <code>\\uses</code>.</p>\n<p><code>ref</code> doesn't necessarily cover all <code>uses</code> too. Many proofs in blueprints are completely ignored, they might be too obvious or the author just went to the Lean code to get the work done, and the blueprint is left with an empty proof.</p>\n<p>These observations came from reading the original math paper, the formalization paper, the blueprint, and the Lean code of these real formalization projects. It's far from \"writing in the programming language called Undergraduate\", generally it's somewhat \"sloppy\" as it's informal, and it's a sketch.</p>\n<p>If a mathematician believes another mathematician has all the details, they'll be reluctant to elaborate further, and if all goes well in the Lean side, the other mathematician will never come back to ask for more details on the blueprint. (This also explain the lack of documentation of the blueprint, once everyone involved in the infra side of the formalization project got the hang of it, and it doesn't break, no one is asking for more documents on it, and everyone is busy doing the real work, and the source code in the repo is the de fecto doc, and actually <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> has written <a href=\"https://github.com/teorth/pfr/blob/master/README.md#build-the-blueprint\">a blueprint usage doc for PFR</a>, so I can simplify it a bit, but I don't think a doc PR to leanblueprint is going to help anyone immediately so I postponed improving it)</p>\n<p>That's why there is the distinction between <code>\\uses</code> and <code>\\ref</code>, and automation is only helpful to check after the fact, but that might also be annoying if mathematicians believe they have communicated the intentions clearly with the union set of both, and they don't need to be notified to make the correspondence perfect.</p>",
        "id": 406490424,
        "sender_full_name": "Utensil Song",
        "timestamp": 1701936899
    },
    {
        "content": "<p>(this was stolen from sphere-eversion!)</p>",
        "id": 406497653,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1701939540
    },
    {
        "content": "<p>I was surprised about <code>\\leanok</code> as well; before using the blueprint, I would have imagined that lean declarations were tagged with the identifier given in the blueprint, and we'd colour the graph based on whether such a tag existed and whether its proof is sorry-free. Not sure if there's good reasons to avoid that</p>",
        "id": 406507953,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1701943044
    },
    {
        "content": "<p>What do you mean exactly by \"whether the proof is sorry-free\"?</p>",
        "id": 406508193,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1701943126
    },
    {
        "content": "<p>If it's the naïve understanding of \"<code>#print axioms my_decl</code> doesn't contain <code>sorryAx</code>\", then Kevin will never get the FLT node green during his 5 years grant!</p>",
        "id": 406508334,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1701943181
    },
    {
        "content": "<p>#print axioms?</p>",
        "id": 406508351,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1701943187
    },
    {
        "content": "<p>Should it be?</p>",
        "id": 406508372,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1701943196
    },
    {
        "content": "<p>I may be misunderstanding what green is</p>",
        "id": 406508428,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1701943205
    },
    {
        "content": "<p>Well, nodes in the blueprint can go green before their prerequisites. A (lemma) node corresponds to a proof, not to the completion of everything above it.</p>",
        "id": 406508542,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1701943239
    },
    {
        "content": "<p>This happens fairly often, when a prerequisite turns out to be harder than expected, or when someone writes the corollaries of a big theorem before the big theorem itself is formalised.</p>",
        "id": 406508774,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1701943300
    },
    {
        "content": "<p>Yeah, then I misunderstood. I suppose there's no obvious way of checking that a proof is sorry-free itself but not transitively</p>",
        "id": 406508786,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1701943305
    },
    {
        "content": "<p>I believe it's metaprogrammatically possible, but certainly not as easy as <code>#print axioms</code>.</p>",
        "id": 406508922,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1701943335
    },
    {
        "content": "<p>(and note that currently the blueprint doesn't even know what Lean is!)</p>",
        "id": 406509010,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1701943361
    },
    {
        "content": "<p>Yeah, this is what was unexpected to me</p>",
        "id": 406509073,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1701943384
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113488-general/topic/CFP.3A.20improved.20Blueprint.20UX/near/406509010\">said</a>:</p>\n<blockquote>\n<p>(and note that currently the blueprint doesn't even know what Lean is!)</p>\n</blockquote>\n<p>I believe this is the way it should be. There should be no dependency on Lean for authoring the blueprint. Everything Lean should be checking or automatically (help to via PRs by bots from CI) maintaining the status synchronization from the Lean side afterward. </p>\n<p>No checking is a regression caused by me, and by then I didn't realize how important and helpful it is, but it's never technically difficult or intentionally designed this way.</p>\n<p>The Lean 3 blueprint depends on Lean to collect the declarations to point to the source code location, it will also do the checking (admittedly, only the existence of Lean proof but NOT whether it's correctly proved, that means examining whether it's directly using sorries, even run it through lean4checker /lean4lean etc. to be strict).</p>\n<p>In Patrick's Christmas (present?) version, I'll imagine this will revive, and personally I believe the dependency on Lean can be relaxed somehow, at least for a mathematician who is editing the blueprint but doesn't want to bother with the Lean side, at least locally (this is also the scaling problem on the mathematician side).</p>\n<p>In PFR, most people simply edits the blueprint, without building it to a web version locally, then commit it, waiting for the CI to finish, then examine the result on the website (which would be based on doc-gen4 from the Lean side), this workflow is not ideal, compared to the need to see the result of LaTeX authoring immediately. Some does build it locally without the hassle or time cost from Lean side, because my regressed version doesn't depend on Lean at all, and I consider it a feature and believes this is useful.</p>",
        "id": 406511501,
        "sender_full_name": "Utensil Song",
        "timestamp": 1701944267
    },
    {
        "content": "<p>This should be possible in an approach similar to the one I hallucinated too; you just wouldn't get the dependency graph</p>",
        "id": 406511959,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1701944421
    },
    {
        "content": "<p>The dependency graph purely depends on human annotated <code>\\uses</code>, not Lean.</p>",
        "id": 406512129,
        "sender_full_name": "Utensil Song",
        "timestamp": 1701944487
    },
    {
        "content": "<p>I feel like we're talking past each other, and I'm not likely to be able to work on this, so I'll just shut up now :)</p>",
        "id": 406512424,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1701944578
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113488-general/topic/CFP.3A.20improved.20Blueprint.20UX/near/406508922\">said</a>:</p>\n<blockquote>\n<p>I believe it's metaprogrammatically possible, but certainly not as easy as <code>#print axioms</code>.</p>\n</blockquote>\n<p>It's actually simpler to do this than to go transitively. It's a one liner, just find the contained constants and see if <code>sorryAx</code> is mentioned</p>",
        "id": 406513451,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701944912
    },
    {
        "content": "<p>I was definitely imagining that one would check whether the declaration itself uses sorry, looking transitively would be pointless</p>",
        "id": 406513660,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701945000
    },
    {
        "content": "<p>It's also possible to see whether a definition non-transitively uses sorry without metaprogramming: lean will throw a warning on every declaration that directly uses sorry</p>",
        "id": 406513804,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701945038
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"296911\">Utensil Song</span> <a href=\"#narrow/stream/113488-general/topic/CFP.3A.20improved.20Blueprint.20UX/near/406511501\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113488-general/topic/CFP.3A.20improved.20Blueprint.20UX/near/406509010\">said</a>:</p>\n<blockquote>\n<p>(and note that currently the blueprint doesn't even know what Lean is!)</p>\n</blockquote>\n<p>I believe this is the way it should be. There should be no dependency on Lean for authoring the blueprint. Everything Lean should be checking or automatically (help to via PRs by bots from CI) maintaining the status synchronization from the Lean side afterward. </p>\n</blockquote>\n<p>The blueprint software itself should definitely know about lean (and ideally would be implemented in lean itself), but authoring the blueprint can be done by a plain tex installation from my understanding. I don't see a need to involve python though, I can only assume this is just because it's what Patrick is used to</p>",
        "id": 406514263,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701945244
    },
    {
        "content": "<p>The color of the nodes also doesn't depend on Lean, but also human annotated <code>\\leanok</code>, but this can also be annotated by a Lean aware bot. The status of a node should be persisted in a human readable way, ideally just in the LaTeX like now (instead of some binary cache like the Python pickle in Lean 3 blueprint, or a too technical JSON manifest), so a blueprint can be built without involving Lean.</p>",
        "id": 406515834,
        "sender_full_name": "Utensil Song",
        "timestamp": 1701945787
    },
    {
        "content": "<p>why \"a blueprint can be built without involving Lean\"? Specifically, you need to use some language to implement this and I don't see why not to use lean</p>",
        "id": 406516257,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701945943
    },
    {
        "content": "<p>it can be done without building the project, sure</p>",
        "id": 406516373,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701945972
    },
    {
        "content": "<p>I do agree that if blueprint software is written in Lean, the benefit is that it's a built executable, so there would be no hassle with installing Python like now.</p>",
        "id": 406516418,
        "sender_full_name": "Utensil Song",
        "timestamp": 1701945983
    },
    {
        "content": "<p>persisting the <code>\\leanok</code>s in a json file written by CI seems like the most natural option</p>",
        "id": 406516523,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701946023
    },
    {
        "content": "<p>This has the advantage of being machine-readable and allow one to \"replay\" the dependency graph. cc <span class=\"user-mention\" data-user-id=\"321696\">@Julian Berman</span></p>",
        "id": 406516717,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1701946086
    },
    {
        "content": "<p>In order for the model to <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/Project.20completed!.20.20Thoughts.20and.20reflections.3F/near/406468197\">scale</a>, the authors of the blueprint should include some mathematicians who don't need to install Lean (or Python).</p>",
        "id": 406516881,
        "sender_full_name": "Utensil Song",
        "timestamp": 1701946151
    },
    {
        "content": "<p>they can just edit the tex</p>",
        "id": 406516934,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701946168
    },
    {
        "content": "<p>but I don't think it is unreasonable to say you need to install lean (or python) to run blueprint locally</p>",
        "id": 406517129,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701946233
    },
    {
        "content": "<p>If the status of the nodes are persistented in the Github repository, a mathematician can just get the repo, then start building and editing the blueprint with their working LaTeX installation, this would be ideal.</p>",
        "id": 406517434,
        "sender_full_name": "Utensil Song",
        "timestamp": 1701946339
    },
    {
        "content": "<p>including the dep graph</p>",
        "id": 406517483,
        "sender_full_name": "Utensil Song",
        "timestamp": 1701946355
    },
    {
        "content": "<p>is latex the one rendering the dep graph?</p>",
        "id": 406518772,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701946806
    },
    {
        "content": "<p>I thought it was just handling the mathematics content</p>",
        "id": 406518807,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701946822
    },
    {
        "content": "<p>No indeed, the rendering is done by a python script.</p>",
        "id": 406519159,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1701946924
    },
    {
        "content": "<p>I really hope we don't go the route of getting latex to do the rendering \"for the convenience of users\"</p>",
        "id": 406519900,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701947170
    },
    {
        "content": "<p>Anyway, observing the PFR project makes me believe that involving more Lean in the blueprint software, is the wrong way. At least, if Lean is indeed involved, it should not be noticeable, like installing Lean, running Lean, writing in Lean DSL, are not ideal, and should be avoided. Of course, I might be wrong (in this role play trying to take my CS hat off) and mathematicians are more resilient (I can't recall who, but one told me that they are quite resilient after the torture of LaTeX <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span> ).</p>",
        "id": 406522399,
        "sender_full_name": "Utensil Song",
        "timestamp": 1701948151
    },
    {
        "content": "<p>I'm not sure exactly how you derived that from the PFR project, everyone involved was quite adept at lean and probably significantly less so wrt python</p>",
        "id": 406522724,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701948307
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/CFP.3A.20improved.20Blueprint.20UX/near/406518772\">said</a>:</p>\n<blockquote>\n<p>is latex the one rendering the dep graph?</p>\n</blockquote>\n<p>If the dep graph is persisted, not only the node status, but also the dot file generated by graphviz (which is just a tool easily installed, no Lean or Python involved). LaTeX can render it via dot2texi, a LaTeX package, free of dependencies on Python.</p>",
        "id": 406523108,
        "sender_full_name": "Utensil Song",
        "timestamp": 1701948469
    },
    {
        "content": "<p>We should certainly lean on the strengths of the target audience, and keep things familiar, but a lot of what is being discussed is backend tech, it doesn't matter what that is written in</p>",
        "id": 406523187,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701948486
    },
    {
        "content": "<p>the frontend is currently 100% latex and that doesn't seem to be negotiable AFAICT</p>",
        "id": 406523331,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701948548
    },
    {
        "content": "<p>Yes, I'm not against about how it's implemented, only believing that authoring a blueprint should not be writing a Lean DSL.</p>",
        "id": 406523361,
        "sender_full_name": "Utensil Song",
        "timestamp": 1701948562
    },
    {
        "content": "<p>I would like to know exactly how crazy the latex actually is in practice though</p>",
        "id": 406523415,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701948596
    },
    {
        "content": "<p>I realize it can in principle be arbitrarily complex but we have a few data points now, it might be interesting to see what is actually required of the latex</p>",
        "id": 406523546,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701948636
    },
    {
        "content": "<p>Just throwing my two cents out here, I think that using Python isn't a great solution, even for backend code. While I was setting up the infrastructure for the Lean3 version of Con(NF), I found it quite difficult to get all of the Python dependencies to work properly. In particular, <code>mathlibtools</code> would only work with a version of Python that isn't available via <code>apt</code>!</p>",
        "id": 406523666,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1701948685
    },
    {
        "content": "<p>This isn't necessarily a problem with Python, of course, but I think Lean 4 tends to be better with version management.</p>",
        "id": 406523805,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1701948741
    },
    {
        "content": "<p>heh...</p>",
        "id": 406523823,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701948750
    },
    {
        "content": "<p>for some sense of \"better\"</p>",
        "id": 406523853,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701948766
    },
    {
        "content": "<p>Lean versions only break if you <code>lake update</code> them, python versions break whenever the apt maintainers decide to.</p>",
        "id": 406523940,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1701948811
    },
    {
        "content": "<p>It's at least as crazy as how the python part of leanblueprint can't handle, it partly relies on a working LaTeX installation. Also, for example, if there is something like a commutative diagram involved, it completely relies on the LaTeX package to generate the diagram.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113488-general/topic/CFP.3A.20improved.20Blueprint.20UX/near/406444415\">said</a>:</p>\n<blockquote>\n<p>It is very important that math papers can be gradually turned into blueprints.</p>\n</blockquote>",
        "id": 406524058,
        "sender_full_name": "Utensil Song",
        "timestamp": 1701948864
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"492774\">Sky Wilshaw</span> <a href=\"#narrow/stream/113488-general/topic/CFP.3A.20improved.20Blueprint.20UX/near/406523940\">said</a>:</p>\n<blockquote>\n<p>Lean versions only break if you <code>lake update</code> them, python versions break whenever the apt maintainers decide to.</p>\n</blockquote>\n<p>Weird, I can't find the Nix emoji in Zulip's list. A snowflake will have to do.</p>",
        "id": 406524132,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1701948899
    },
    {
        "content": "<p>Do commutative diagrams even get typeset properly on the HTML side?</p>",
        "id": 406524141,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1701948903
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"492774\">Sky Wilshaw</span> <a href=\"#narrow/stream/113488-general/topic/CFP.3A.20improved.20Blueprint.20UX/near/406524141\">said</a>:</p>\n<blockquote>\n<p>Do commutative diagrams even get typeset properly on the HTML side?</p>\n</blockquote>\n<p>It can, the result is a SVG diagram which renders perfectly and natively on the HTML side.</p>",
        "id": 406524477,
        "sender_full_name": "Utensil Song",
        "timestamp": 1701949074
    },
    {
        "content": "<p>Ah nice! Is this for <code>xypic</code> or <code>tikzcd</code>?</p>",
        "id": 406524619,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1701949137
    },
    {
        "content": "<p>Regarding meta-programmatically checking whether a theorem is <code>sorry</code>-free, I have written a <a href=\"https://github.com/YaelDillies/LeanBlueprint/blob/mathlibtools/LeanBlueprint/Basic.lean\">short script</a> on <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span>'s fork of <code>LeanBlueprint</code> to extract the declarations from a file together with their line numbers and whether they contain a <code>sorry</code>. This uses <code>InfoTree</code>s and is loosely based on <code>LeanInk</code>. </p>\n<p>The main limitation of this code is that it operates on individual files, while the blueprint requires information about specific constants in the environment; but maybe with some caching it wouldn't be too inefficient to find the file containing a declaration using <code>Environment.getModuleIdxFor?</code>and then run this script on it.</p>",
        "id": 406524835,
        "sender_full_name": "Anand Rao Tadipatri",
        "timestamp": 1701949235
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"492774\">Sky Wilshaw</span> <a href=\"#narrow/stream/113488-general/topic/CFP.3A.20improved.20Blueprint.20UX/near/406523805\">said</a>:</p>\n<blockquote>\n<p>This isn't necessarily a problem with Python, of course, but I think Lean 4 tends to be better with version management.</p>\n</blockquote>\n<p>Lean is less stable on version management, especially when the latest Mathlib is involved, which is essential for formalization projects. That's one of the reasons I was voicing out in <a href=\"#narrow/stream/270676-lean4/topic/Deprecation.20without.20explanations\">this (long) thread</a>.</p>",
        "id": 406524848,
        "sender_full_name": "Utensil Song",
        "timestamp": 1701949241
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"492774\">Sky Wilshaw</span> <a href=\"#narrow/stream/113488-general/topic/CFP.3A.20improved.20Blueprint.20UX/near/406524619\">said</a>:</p>\n<blockquote>\n<p>Ah nice! Is this for <code>xypic</code> or <code>tikzcd</code>?</p>\n</blockquote>\n<p>Yes. leanblueprint (and its backbone plastex) uses LaTeX to generate a PDF of the diagram (no matter how crazy in LaTeX), covert it to SVG, then display it in the web version.</p>",
        "id": 406525063,
        "sender_full_name": "Utensil Song",
        "timestamp": 1701949332
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303675\">Anand Rao Tadipatri</span> <a href=\"#narrow/stream/113488-general/topic/CFP.3A.20improved.20Blueprint.20UX/near/406524835\">said</a>:</p>\n<blockquote>\n<p>Regarding meta-programmatically checking whether a theorem is <code>sorry</code>-free, I have written a <a href=\"https://github.com/YaelDillies/LeanBlueprint/blob/mathlibtools/LeanBlueprint/Basic.lean\">short script</a> on <span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span>'s fork of <code>LeanBlueprint</code> to extract the declarations from a file together with their line numbers and whether they contain a <code>sorry</code>. This uses <code>InfoTree</code>s and is loosely based on <code>LeanInk</code>. </p>\n<p>The main limitation of this code is that it operates on individual files, while the blueprint requires information about specific constants in the environment; but maybe with some caching it wouldn't be too inefficient to find the file containing a declaration using <code>Environment.getModuleIdxFor?</code>and then run this script on it.</p>\n</blockquote>\n<p>In principle, it's rather easy in Lean meta programming to collect things from the environment, all the way down to the imported dependencies, beyond the one file limit. I had an attempt earlier and it's feasible. Lean experts already involved in PFR can certainly make one more elegantly. Also it doesn't need to depend on the now less maintained <code>LeanInk</code>, it's also feasible that doesn't require the caching idea.</p>",
        "id": 406526289,
        "sender_full_name": "Utensil Song",
        "timestamp": 1701949825
    },
    {
        "content": "<p>This information is already available to Lean when one opens a Lean file in VS Code, so one should expect these information collected in a few seconds (unlike how long it takes doc-gen4 to run, it did much much more), provided that the Mathlib cache (olean files) is available.</p>",
        "id": 406527476,
        "sender_full_name": "Utensil Song",
        "timestamp": 1701950345
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"296911\">Utensil Song</span> <a href=\"#narrow/stream/113488-general/topic/CFP.3A.20improved.20Blueprint.20UX/near/406524848\">said</a>:</p>\n<blockquote>\n<p>Lean is less stable on version management, especially when the latest Mathlib is involved, which is essential for formalization projects.</p>\n</blockquote>\n<p>I hope that this won't be as big of a problem when only <code>Std</code> is involved.</p>",
        "id": 406527815,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1701950466
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"296911\">Utensil Song</span> <a href=\"#narrow/stream/113488-general/topic/CFP.3A.20improved.20Blueprint.20UX/near/406526289\">said</a>:</p>\n<blockquote>\n<p>In principle, it's rather easy in Lean meta programming to collect things from the environment, all the way down to the imported dependencies, beyond the one file limit. I had an attempt earlier and it's feasible. Lean experts already involved in PFR can certainly make one more elegantly. Also it doesn't need to depend on the now less maintained <code>LeanInk</code>, it's also feasible that doesn't require the caching idea.</p>\n</blockquote>\n<p>For extracting the line numbers and file positions of declarations, the information contained in the environment may not be enough (but I could be wrong). I would like to avoid the caching idea as well and have something more direct. </p>\n<p>As you mention, the relevant information is available in the VS Code session (for example, Ctrl+Click-ing on definitions uses file position information), so there may be a quick way of accessing that. It may be possible to extract details about declarations in imported dependencies through the <code>InfoTree</code>, since that is where a lot of the information about a document generated during elaboration is stored, but I'm not aware of a way.</p>",
        "id": 406533383,
        "sender_full_name": "Anand Rao Tadipatri",
        "timestamp": 1701952442
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303675\">Anand Rao Tadipatri</span> <a href=\"#narrow/stream/113488-general/topic/CFP.3A.20improved.20Blueprint.20UX/near/406533383\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"296911\">Utensil Song</span> <a href=\"#narrow/stream/113488-general/topic/CFP.3A.20improved.20Blueprint.20UX/near/406526289\">said</a>:</p>\n<blockquote>\n<p>In principle, it's rather easy in Lean meta programming to collect things from the environment, all the way down to the imported dependencies, beyond the one file limit. I had an attempt earlier and it's feasible. Lean experts already involved in PFR can certainly make one more elegantly. Also it doesn't need to depend on the now less maintained <code>LeanInk</code>, it's also feasible that doesn't require the caching idea.</p>\n</blockquote>\n<p>For extracting the line numbers and file positions of declarations, the information contained in the environment may not be enough (but I could be wrong). I would like to avoid the caching idea as well and have something more direct. </p>\n<p>As you mention, the relevant information is available in the VS Code session (for example, Ctrl+Click-ing on definitions uses file position information), so there may be a quick way of accessing that. It may be possible to extract details about declarations in imported dependencies through the <code>InfoTree</code>, since that is where a lot of the information about a document generated during elaboration is stored, but I'm not aware of a way.</p>\n</blockquote>\n<p>Some more information related was discussed in <a href=\"#narrow/stream/270676-lean4/topic/get.20filename.20.2B.20pos\">this thread</a>. Note that olean contains the code position and the module name of the file, but not the file name since it's platform specific, and determined by lake not lean. Also there are naming differences between the directory name, the Github repo name, and the package name, which is a pain point. From the thread, you can see it's very much feasible.</p>\n<p>But right now I'm only happily waiting for Patrick's Christmas present package <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 406534623,
        "sender_full_name": "Utensil Song",
        "timestamp": 1701952943
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"492774\">Sky Wilshaw</span> <a href=\"#narrow/stream/113488-general/topic/CFP.3A.20improved.20Blueprint.20UX/near/406523666\">said</a>:</p>\n<blockquote>\n<p>Just throwing my two cents out here, I think that using Python isn't a great solution, even for backend code. While I was setting up the infrastructure for the Lean3 version of Con(NF), I found it quite difficult to get all of the Python dependencies to work properly. In particular, <code>mathlibtools</code> would only work with a version of Python that isn't available via <code>apt</code>!</p>\n</blockquote>\n<p>I want to repeat once more that it is extremely unlikely that Python will be replaced for the backend work. Turning LaTeX into HTML is very non-trivial. And PlasTeX is an awesome solution for that.</p>",
        "id": 406544006,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1701956379
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/CFP.3A.20improved.20Blueprint.20UX/near/406523415\">said</a>:</p>\n<blockquote>\n<p>I would like to know exactly how crazy the latex actually is in practice though</p>\n</blockquote>\n<p>Our current blueprints have probably been pretty mild. But mathematicians typically load lots of custom macros. And when you add diagrams into the mix, it gets nasty quickly.</p>",
        "id": 406544155,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1701956422
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/CFP.3A.20improved.20Blueprint.20UX/near/406522724\">said</a>:</p>\n<blockquote>\n<p>I'm not sure exactly how you derived that from the PFR project, everyone involved was quite adept at lean and probably significantly less so wrt python</p>\n</blockquote>\n<p>To be clear, because that's probably the upper limit of the count of Lean experts can work on a formalization project concurrently on earth. And yes, they are adept at proving with Lean, how many are they good at writing Lean tactics? How many are they good at writing Lean for general programming? Particularly handling issues that involve Lean internals and Lake internals? Now divide this number by the formalization project counts to meet the goal \"formalizing math research in real time\" (with tooling support requests coming from them). That's why the model doesn't <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/Project.20completed!.20.20Thoughts.20and.20reflections.3F/near/406468197\">scale</a>, yet.</p>\n<p>This is why I reach the conclusion that the less Lean in the tooling for the blueprint, the better, at least this is true for the status quo of Lean at general programming. I know a dozen of programming languages, and Lean (as a general purpose programming) is a few levels more difficult to master (or get things done due to the lack of packages in this regard) than a dead simple and ecosystem-rich programming language like Python. (Not that I'm upvoting for Python, just comparing the complexity level of learning, at least in the midterm. In the long run, Lean choice is going to be better, but does it need to happen now?)</p>",
        "id": 406546035,
        "sender_full_name": "Utensil Song",
        "timestamp": 1701957021
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113488-general/topic/CFP.3A.20improved.20Blueprint.20UX/near/406444415\">said</a>:</p>\n<blockquote>\n<p>It is very important that math papers can be gradually turned into blueprints.</p>\n</blockquote>\n<p>I just want to say that when I started working on the blueprint, I first wrote it from scratch (or more precisely, from an extremely bare bones template that <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> provided with like three dummy lemmas), consulting the original paper but writing things out again by hand, but about halfway through I realized that I could cut and paste (and then edit) large portions of the actual paper to create the blueprint, which was much faster.  One could imagine eventually having some AI tool to take a random paper in LaTeX and make a first pass at chopping it up into a blueprint; with enough tools to edit dependency graphs in ways that don't require manually moving around dozens of \\uses, this could potentially be faster still than the cut and paste method.</p>",
        "id": 406584699,
        "sender_full_name": "Terence Tao",
        "timestamp": 1701968326
    },
    {
        "content": "<p>One other thought: for high profile projects especially, I imagine there will be a large number of casual participants who may not be motivated enough to download lean, github, etc. and make a formal Lean contribution, but they could still help with for instance pointing out a typo in the dependency graph or blueprint.  Having a mechanism in the blueprint for casual users to make these suggestions, and have administrators be able to easily act on them, would be helpful and also be a way to broaden participation and exploit the \"long tail\" of such projects.  This may well be better than trying to develop overengineered automated tools to do this sort of minor blueprint maintainance.  It's possible that the proposal of having a github issues page for each node already goes a long way towards doing this.</p>",
        "id": 406594617,
        "sender_full_name": "Terence Tao",
        "timestamp": 1701972135
    },
    {
        "content": "<p>Another thought in the same vein: it might be nice to also have support for MWE Lean requests that are self-contained enough to place in the Lean playground rather than in the full Github repository, again so that casual participants may be able to contribute.  A recent organically emerging example of this was in <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/Balog-Szemer.C3.A9di-Gowers/near/405989888\">https://leanprover.zulipchat.com/#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/Balog-Szemer.C3.A9di-Gowers/near/405989888</a> when I needed one simple self-contained lemma as part of filling in the final sorry to PFR, and <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span>  was able to supply it in a few minutes. (See also <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/Balog-Szemer.C3.A9di-Gowers/near/405690547\">https://leanprover.zulipchat.com/#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/Balog-Szemer.C3.A9di-Gowers/near/405690547</a> for a significantly larger, but still self contained, lemma that required quite a bit more effort to fill, but could still be done completely independently of the rest of the PFR project.)  But perhaps again the issues page already handles this, if it is easy to support MWEs within the comment system of an issue page.</p>",
        "id": 406599148,
        "sender_full_name": "Terence Tao",
        "timestamp": 1701973902
    },
    {
        "content": "<p>Agreed that problems that don't require the context of the repo are much easier to jump in and do on short notice</p>",
        "id": 406714704,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1702025534
    },
    {
        "content": "<p>I think there is a lake request in here too <span class=\"user-mention\" data-user-id=\"315577\">@Mac Malone</span> : imagine if someone could have a MWE example which just contains <code>import PFR.Foo</code> and I paste this into my project (which is not PFR related) and it just gets the project data and makes it work (possibly with a prompt but not more than that)? That would be a true portable MWE</p>",
        "id": 406715259,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1702025766
    },
    {
        "content": "<p>(I'm aware there are many blockers to such a thing working, but it sounds like a good flow to me)</p>",
        "id": 406715393,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1702025824
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/CFP.3A.20improved.20Blueprint.20UX/near/406715259\">said</a>:</p>\n<blockquote>\n<p>I think there is a lake request in here too <span class=\"user-mention silent\" data-user-id=\"315577\">Mac Malone</span> : imagine if someone could have a MWE example which just contains <code>import PFR.Foo</code> and I paste this into my project (which is not PFR related) and it just gets the project data and makes it work (possibly with a prompt but not more than that)? That would be a true portable MWE</p>\n</blockquote>\n<p>I don't know if this is way too resource hungry to be realistic, but another option is to somehow attach a custom Lean playground to each formalization project that has access to the master build and can <code>import</code> from it just as easily as from Mathlib.  (Such a playground could then also have additional features to integrate it with the blueprint / Github issues page, so that if a casual contributor manages to complete a MWE in the local playground, they could automatically send it back for review to the page issuing that MWE with a click of a button.)</p>",
        "id": 406789319,
        "sender_full_name": "Terence Tao",
        "timestamp": 1702051486
    },
    {
        "content": "<p>With such a framework, one could also automatically convert an entire node formalization request (i.e., proving the full proposition(s) related to a Blueprint node) to a MWE: by following a link from that node, the contributor would be sent to the custom playground in which the proposition to be proven is stated as an <code>example</code> with a <code>sorry</code> (with all relevant prior <code>import</code>, <code>variable</code>, <code>def</code>, <code>abbrev</code>, <code>open</code>, etc. context added automatically; with a more intelligent system, one might also include (or maybe just <code>#check</code>) explicit versions of all the propositions that this node <code>\\uses</code>), and the contributor can then try to prove it using whatever <code>import</code>s from the project and from Mathlib as they deem fit.  (One trivially handle this task by importing the file containing the original sorried proposition and just <code>exact</code> that proposition, or by importing more advanced results that rely on the proposition, so some human review (or some fancy linter) may be needed to avoid frivolous circular logic submissions.)</p>",
        "id": 406791471,
        "sender_full_name": "Terence Tao",
        "timestamp": 1702052038
    },
    {
        "content": "<p>I think this is essentially what you already get with gitpod, but maybe someone knows what additional work would be needed to have the right cache available</p>",
        "id": 406851255,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1702076288
    },
    {
        "content": "<p>One issue with gitpod is that it takes several minutes to be up and running.</p>",
        "id": 406852339,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1702076938
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/CFP.3A.20improved.20Blueprint.20UX/near/406852339\">said</a>:</p>\n<blockquote>\n<p>One issue with gitpod is that it takes several minutes to be up and running.</p>\n</blockquote>\n<p>The PFR project front page <a href=\"https://teorth.github.io/pfr/\">https://teorth.github.io/pfr/</a> ostensibly has a gitpod button in it, but I have not yet been able to get it to work.</p>",
        "id": 406855187,
        "sender_full_name": "Terence Tao",
        "timestamp": 1702078331
    },
    {
        "content": "<p>It seems that proposals so far fall into 4 categories:</p>\n<h2>1. Authoring and organizing the informal part of the blueprint better</h2>\n<p>For example, with the help of LLMs to chop a math paper into nodes in a blueprint, possibly annotate the nodes with dependencies hinted be <code>\\ref</code> or the text, the resulting dep graph could be making too much connections, so an algorithm can eliminate some of these edges, particularly the transitive ones (like <code>\\uses{A} % ,B, C }</code> so mathematicians can do less copy-pasting but focusing on elaborate on necessary details, adding intermediate lemmas, and organize the dep graph etc. Preferably this can be done incrementally as there might be more than one math paper involved, it would be ideal to add a new paper without messing up existing blueprint. This is where natural language comprehension and generation technologies like LLMs shine, together with some deterministic algorithms. </p>\n<p>This part is preferably based on the original vision by Patrick, and reuse most of the current implantation in Python/LaTeX. In the long run (but ROI-wise not now), they can be all rewritten in Lean, and it's very feasible, e.g. Lean can have an FFI binding to tectonic written in Rust which has great compatibility with existing LaTeX paper no matter how crazy the LaTeX might be, and it aims to have a Web output, but it hasn't got to a point that can mirror Web and PDF so well like plastex (the base of leanblueprint) did so far. The AI part of the implementation can also be done in Python or C++ that also binds to Lean via FFI, like LeanInfer did.</p>",
        "id": 406882755,
        "sender_full_name": "Utensil Song",
        "timestamp": 1702094799
    },
    {
        "content": "<h2>2. General project management</h2>\n<p>There could be an issue of each of the blueprint nodes, to track the claims, milestones, tags etc. And it will also <a href=\"#narrow/stream/113488-general/topic/CFP.3A.20improved.20Blueprint.20UX/near/406594617\">allow casual participants to make suggestions</a>.</p>\n<p>This part can be implemented by Github issues, Github actions, bots, Github projects, and has tight integration of the existing workflow around the Github repo. The bot makes use of the metadata leanblueprint deduced from the LaTeX source, raise these issues, track their status, and reflect them in to the dep graph, possibly with extra metadata persistence that the bot is allowed to commit into the repo automatically or via PRs if we wish to keep it simple as the statistically generated Web pages that can be easily hosted on Github Pages or test locally.</p>",
        "id": 406882830,
        "sender_full_name": "Utensil Song",
        "timestamp": 1702094874
    },
    {
        "content": "<h2>3. Automatically check and sync Lean status back to blueprint</h2>\n<p>This will need to check whether Lean has the statement declaration, has a proof without sorry, passes strict checking by lean4check/lean4lean or external checkers etc. and sync the state back to blueprint.</p>\n<p>This part could be mostly written in Lean via meta-programming, and reuse the syncing mechanisms in 2. I still prefer this part to be organized as PRs as humans should decide whether a node actually turns green (maybe there are issues of the proof, or there should be more <code>\\uses</code> etc.), but this can also be done automatically like described in 2.</p>\n<p>I wish to emphasize the importance of that this information is stored in the repo as human readable and editable files, instead of binary data or technical format stored on some servers or databases, this will make the blueprint reproducible by anyone who has the code, without the need to access anything hosted on Github or any other servers. This is how a digitalized and formalized piece of Math can be kept in a long period of time.</p>",
        "id": 406882852,
        "sender_full_name": "Utensil Song",
        "timestamp": 1702094883
    },
    {
        "content": "<h2>4. How to break things down on the Lean side into MWEs and make casual participants can jump in to help</h2>\n<p>This is actually quite essential. Gitpod or Codespaces still takes too long to fire up. A MWE and a link to working on it on <a href=\"http://live.lean-lang.org\">live.lean-lang.org</a> is instant. This makes contributions and discussion more efficient to a new level. The idea of making <a href=\"http://live.lean-lang.org\">live.lean-lang.org</a> to be able to import from ongoing formalization projects is feasible, at least this works for a limited amount of formalization projects, like the long running FLT project.</p>\n<p>Extracting a not necessarily too minimal MWE with the help of Lean meta-programming is also feasible. We already have things like <code>extract_goal </code>, imagine a <code>help</code> tactic, which collects everything needed from the environment, delaborate it into a MWE with a wide import like <code>import Mathlib</code> + <code>import PFR</code> but minimal code for that specific goal.</p>\n<p>One can further imagine that extracting a need of tactics, like giving a few example proofs, then Lean can automatically make an MWE, so a tactic expert can start developing one with the MWE as test cases. It's quite important to develop tactics to a specific math area , just like <code>ring</code>, <code>field_simp</code> etc. but they are just for undergraduate level abstract algebra, imagine a tactic called <code>sheaf</code> or <code>cat</code> or something less general, they can be as easy as just <code>aesop</code> plus some rulesets but greatly helpful to proof authoring and reproduce the efficient informal reasoning logic flow (although it might be less friendly to, say, a graduate student to drill down to the machinery of the proof).  Developing tactics with the help from LLMs is one more thing to imagine, it would be nice to have more training towards this direction.</p>",
        "id": 406882879,
        "sender_full_name": "Utensil Song",
        "timestamp": 1702094884
    },
    {
        "content": "<p>(disclaimer: unfortunately I can only volunteer to do a tiny fraction of all these due to the limitation of my Lean time, just discussing the possible big picture, feasibility, and some personal take on them here).</p>",
        "id": 406885333,
        "sender_full_name": "Utensil Song",
        "timestamp": 1702096649
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 406947399,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1702134274
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/stream/113488-general/topic/CFP.3A.20improved.20Blueprint.20UX/near/406855187\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/CFP.3A.20improved.20Blueprint.20UX/near/406852339\">said</a>:</p>\n<blockquote>\n<p>One issue with gitpod is that it takes several minutes to be up and running.</p>\n</blockquote>\n<p>The PFR project front page <a href=\"https://teorth.github.io/pfr/\">https://teorth.github.io/pfr/</a> ostensibly has a gitpod button in it, but I have not yet been able to get it to work.</p>\n</blockquote>\n<p>It works for me in gitpod, although the link for the gitpod button at <a href=\"https://teorth.github.io/pfr/\">https://teorth.github.io/pfr/</a> needs to be  <code>https://gitpod.io/#https://github.com/teorth/pfr</code> rather than the current link to the github repo itself!</p>",
        "id": 406957611,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1702142974
    },
    {
        "content": "<p>The link in the project page is incorrect, but the one in README is correct, and works for me (for Lean, not blueprint):</p>\n<p><a href=\"/user_uploads/3121/j8dsXb5blM275UFwA7rh6HEb/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/j8dsXb5blM275UFwA7rh6HEb/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/j8dsXb5blM275UFwA7rh6HEb/image.png\"></a></div>",
        "id": 406959249,
        "sender_full_name": "Utensil Song",
        "timestamp": 1702144571
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"296911\">Utensil Song</span> <a href=\"#narrow/stream/113488-general/topic/CFP.3A.20improved.20Blueprint.20UX/near/406959249\">said</a>:</p>\n<blockquote>\n<p>The link in the project page is incorrect, but the one in README is correct, and works for me (for Lean, not blueprint):</p>\n<p><a href=\"/user_uploads/3121/j8dsXb5blM275UFwA7rh6HEb/image.png\">image.png</a></p>\n</blockquote>\n<p>OK, hopefully it is fixed now.</p>\n<p>As a separate (and rather easy) feature request - I wonder if there is a way to add an additional coloring to the dependency graph (maybe some sort of \"really green\") that indicates not only that a node has been locally formalized, but that all of the nodes it depends on transitively are also formalized?  Right now for instance we are adding a few extensions to the PFR project, which has temporarily uglified our <a href=\"https://teorth.github.io/pfr/blueprint/dep_graph_document.html\">dependency graph</a>, but it would be nice to tell at a glance that the original result PFR is still completely proven (or at least, that blueprint thinks that it is).</p>",
        "id": 406975136,
        "sender_full_name": "Terence Tao",
        "timestamp": 1702158355
    },
    {
        "content": "<p>Another issue is that all nodes with <code>'</code> in their name are not responding to clicks (i.e. showing the statement in an overlay at the top).</p>",
        "id": 407017870,
        "sender_full_name": "Utensil Song",
        "timestamp": 1702189985
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/stream/113488-general/topic/CFP.3A.20improved.20Blueprint.20UX/near/406975136\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"296911\">Utensil Song</span> <a href=\"#narrow/stream/113488-general/topic/CFP.3A.20improved.20Blueprint.20UX/near/406959249\">said</a>:</p>\n<blockquote>\n<p>The link in the project page is incorrect, but the one in README is correct, and works for me (for Lean, not blueprint):</p>\n<p><a href=\"/user_uploads/3121/j8dsXb5blM275UFwA7rh6HEb/image.png\">image.png</a></p>\n</blockquote>\n<p>OK, hopefully it is fixed now.</p>\n<p>As a separate (and rather easy) feature request - I wonder if there is a way to add an additional coloring to the dependency graph (maybe some sort of \"really green\") that indicates not only that a node has been locally formalized, but that all of the nodes it depends on transitively are also formalized?  Right now for instance we are adding a few extensions to the PFR project, which has temporarily uglified our <a href=\"https://teorth.github.io/pfr/blueprint/dep_graph_document.html\">dependency graph</a>, but it would be nice to tell at a glance that the original result PFR is still completely proven (or at least, that blueprint thinks that it is).</p>\n</blockquote>\n<p>as a slightly fancier thing on top, use opacity to show what fraction of the transitive deps are formalized?</p>",
        "id": 407021014,
        "sender_full_name": "Alok Singh (S1'17)",
        "timestamp": 1702192671
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/stream/113488-general/topic/CFP.3A.20improved.20Blueprint.20UX/near/406975136\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"296911\">Utensil Song</span> <a href=\"#narrow/stream/113488-general/topic/CFP.3A.20improved.20Blueprint.20UX/near/406959249\">said</a>:</p>\n<blockquote>\n<p>The link in the project page is incorrect, but the one in README is correct, and works for me (for Lean, not blueprint):</p>\n<p><a href=\"/user_uploads/3121/j8dsXb5blM275UFwA7rh6HEb/image.png\">image.png</a></p>\n</blockquote>\n<p>OK, hopefully it is fixed now.</p>\n<p>As a separate (and rather easy) feature request - I wonder if there is a way to add an additional coloring to the dependency graph (maybe some sort of \"really green\") that indicates not only that a node has been locally formalized, but that all of the nodes it depends on transitively are also formalized?  Right now for instance we are adding a few extensions to the PFR project, which has temporarily uglified our <a href=\"https://teorth.github.io/pfr/blueprint/dep_graph_document.html\">dependency graph</a>, but it would be nice to tell at a glance that the original result PFR is still completely proven (or at least, that blueprint thinks that it is).</p>\n</blockquote>\n<p>Filed as part of <a href=\"https://github.com/PatrickMassot/leanblueprint/pull/9\">PatrickMassot/leanblueprint#9</a> .</p>",
        "id": 407022491,
        "sender_full_name": "Utensil Song",
        "timestamp": 1702193856
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"296911\">Utensil Song</span> <a href=\"#narrow/stream/113488-general/topic/CFP.3A.20improved.20Blueprint.20UX/near/407022491\">said</a>:</p>\n<blockquote>\n<p>Filed as part of <a href=\"https://github.com/PatrickMassot/leanblueprint/pull/9\">PatrickMassot/leanblueprint#9</a> .</p>\n</blockquote>\n<p>I'm a little confused by \"temporarily uglified\". <code>pfr</code> is very green, both boarder and background:</p>\n<p><a href=\"/user_uploads/3121/jGqgQ8y2xJz90cQEHHqlN52W/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/jGqgQ8y2xJz90cQEHHqlN52W/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/jGqgQ8y2xJz90cQEHHqlN52W/image.png\"></a></div><p>Only <code>pfr'</code> is having a green border, and a blue background (because at least <code>entropy-pfr'</code> is not ready), which seems to be working as intended:</p>\n<p><a href=\"/user_uploads/3121/WMpC_ndP8R814uGsNXs0U8DA/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/WMpC_ndP8R814uGsNXs0U8DA/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/WMpC_ndP8R814uGsNXs0U8DA/image.png\"></a></div><p>How exactly is a more green node defined? (You may refer to other definitions in <a href=\"https://github.com/PatrickMassot/leanblueprint/pull/9\">PatrickMassot/leanblueprint#9</a> or the Legend of dep graph (click on top-left corner).</p>",
        "id": 407023208,
        "sender_full_name": "Utensil Song",
        "timestamp": 1702194488
    },
    {
        "content": "<ol>\n<li>I hope blueprint remains fully open source. This also means that, like now, the possibility of self hosting remains. </li>\n<li>The dependency graph is currently a  static pdf. It would be nice if it were web based. That's to say one could customise the UI of the graph to focus on various nodes or types of nodes by clicking on them or ticking off checkboxes. This might also allow a 3D layout and allow nodes to be pushed into the background if the user doesn't wish to see them.</li>\n</ol>",
        "id": 407057256,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1702208410
    },
    {
        "content": "<p>What do you mean by static pdf? <a href=\"https://teorth.github.io/pfr/blueprint/dep_graph_document.html\">https://teorth.github.io/pfr/blueprint/dep_graph_document.html</a></p>",
        "id": 407057945,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1702208625
    },
    {
        "content": "<p>Yes, it's web-based and interactive. Actually, I was planning to make it available to the PDF too (but it seems to be a much less needed use case).</p>\n<p>Focusing on specific types of nodes or some sort of filtering is feasible. Just need to see what are the exact frequent use cases because there are so many ways to do it.</p>\n<p>One feature that's already available is that it supports displaying the dep graph by sections, so it would have less nodes on each graph. One can always write a summary section to get the big picture and navigate to the graphs of separate sections to check the local dependencies.</p>",
        "id": 407059558,
        "sender_full_name": "Utensil Song",
        "timestamp": 1702209104
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/113488-general/topic/CFP.3A.20improved.20Blueprint.20UX/near/407057256\">said</a>:</p>\n<blockquote>\n<ol>\n<li>I hope blueprint remains fully open source. This also means that, like now, the possibility of self hosting remains. </li>\n</ol>\n</blockquote>\n<p>Same hope here, especially if Morph Labs have enhanced it significantly (like, most of that have been discussed here become a reality) .</p>",
        "id": 407061421,
        "sender_full_name": "Utensil Song",
        "timestamp": 1702209610
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"296911\">Utensil Song</span> <a href=\"#narrow/stream/113488-general/topic/CFP.3A.20improved.20Blueprint.20UX/near/407059558\">said</a>:</p>\n<blockquote>\n<p>Focusing on specific types of nodes or some sort of filtering is feasible. Just need to see what are the exact frequent use cases because there are so many ways to do it.</p>\n</blockquote>\n<p>Suppose I click on a node, it would be nice to see only the dependencies of that node in focus and foregrounded (to avoid the convoluted arcs of the graph) while other nodes get pushed to the background and get de-emphasised</p>",
        "id": 407063093,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1702210723
    },
    {
        "content": "<p>Another improvement would be the way the initial rendering of the graph works. Currently one sees the entire graph with all the nodes in it with teeny tiny bits of text. It is really hard to tell where to even begin navigating through it. Ideally the top level theorem should be front and center and in reasonable font size, with dependencies less focussed and placed behind. If required, a 2D layout like the current one could be shown as well.</p>",
        "id": 407063475,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1702210988
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/113488-general/topic/CFP.3A.20improved.20Blueprint.20UX/near/407063093\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"296911\">Utensil Song</span> <a href=\"#narrow/stream/113488-general/topic/CFP.3A.20improved.20Blueprint.20UX/near/407059558\">said</a>:</p>\n<blockquote>\n<p>Focusing on specific types of nodes or some sort of filtering is feasible. Just need to see what are the exact frequent use cases because there are so many ways to do it.</p>\n</blockquote>\n<p>Suppose I click on a node, it would be nice to see only the dependencies of that node in focus and foregrounded (to avoid the convoluted arcs of the graph) while other nodes get pushed to the background and get de-emphasised</p>\n</blockquote>\n<p>This reminds me of <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> 's <a href=\"https://eric-wieser.github.io/mathlib-import-graph/?highlight=mathlib:linear_algebra.clifford_algebra.basic\">mathlib-import-graph</a> which has dynamic layout and supports highlight/de-highlight etc. which used <a href=\"https://www.sigmajs.org/\">sigmajs</a>.</p>",
        "id": 407065596,
        "sender_full_name": "Utensil Song",
        "timestamp": 1702212507
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/113488-general/topic/CFP.3A.20improved.20Blueprint.20UX/near/407063475\">said</a>:</p>\n<blockquote>\n<p>Another improvement would be the way the initial rendering of the graph works. Currently one sees the entire graph with all the nodes in it with teeny tiny bits of text. It is really hard to tell where to even begin navigating through it. Ideally the top level theorem should be front and center and in reasonable font size, with dependencies less focussed and placed behind. If required, a 2D layout like the current one could be shown as well.</p>\n</blockquote>\n<p>There is already a solution to that: having several graphs, just like in LTE. In the PFR case the extension should have gotten a new chapter in the blueprint and their own graph. There is simply nothing you can do to get a huge graph where you can read labels, unless you force all your user to have 50in screen.</p>",
        "id": 407082927,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1702224658
    },
    {
        "content": "<p>The problem with the multiple graphs solution is that you lose the dependencies that go across several graphs. I would much prefer to be able to filter out nodes on a single graph.</p>",
        "id": 407083060,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1702224755
    },
    {
        "content": "<p>What filtering? In the case at hand, all extension would still depend on PFR, right?</p>",
        "id": 407083115,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1702224819
    },
    {
        "content": "<p>Well typically you could have one toggle for each chapter. If you turn one of the chapters off, all relevant nodes disappear.</p>",
        "id": 407083347,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1702224925
    },
    {
        "content": "<p>A naïve implementation of that would create <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">2^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6644em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span> dependency graphs, where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> is the number of chapters, but hopefully we don't need to see all possible filterings ever.</p>",
        "id": 407083517,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1702225006
    },
    {
        "content": "<p>or rather, collapse into a node representing that chapter</p>",
        "id": 407083682,
        "sender_full_name": "Utensil Song",
        "timestamp": 1702225149
    },
    {
        "content": "<p>That could also work.</p>",
        "id": 407083711,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1702225199
    },
    {
        "content": "<p>It's very feasible, and I've seen many ones like that, but they always feel less stable (re-layout when some nodes are gone), and sometimes dizzy to navigate. Personal preference is that the author could organize things into sections for the readers, so drilling down become natural.</p>",
        "id": 407084020,
        "sender_full_name": "Utensil Song",
        "timestamp": 1702225463
    },
    {
        "content": "<p>Wait, what blueprints have you seen that work like that?</p>",
        "id": 407084200,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1702225639
    },
    {
        "content": "<p>Is there a way to get the raw dependency data of the pfr project in json format?</p>",
        "id": 407085037,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1702226434
    },
    {
        "content": "<p>Many such dependency graphs. Once auto generated without human intervention, it's usually messy for more than dozens of nodes. It only gets better if some higher level hierarchy organize them. There is one (messy) example up there, the sigmajs one.</p>",
        "id": 407085042,
        "sender_full_name": "Utensil Song",
        "timestamp": 1702226444
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/113488-general/topic/CFP.3A.20improved.20Blueprint.20UX/near/407085037\">said</a>:</p>\n<blockquote>\n<p>Is there a way to get the raw dependency data of the pfr project in json format?</p>\n</blockquote>\n<p>It can be done within a blink of the eye from the command line: <a href=\"https://stackoverflow.com/a/51443514/200764\">https://stackoverflow.com/a/51443514/200764</a> if you know where to look for the dot source code for the dep graph (hint: the bottom).</p>\n<p>The blueprint can in principle provide this JSON by default, so people can render it to their liking.</p>",
        "id": 407085249,
        "sender_full_name": "Utensil Song",
        "timestamp": 1702226651
    }
]