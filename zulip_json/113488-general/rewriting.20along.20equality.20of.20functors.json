[
    {
        "content": "<p>Is there a minimal example demonstrating that rewriting along equality of functors is not a good idea?</p>",
        "id": 353993761,
        "sender_full_name": "Sina",
        "timestamp": 1682702765
    },
    {
        "content": "<p>The problem is not really whether you want to do it or not: most of the time, you just cannot do it!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.CategoryTheory.Functor.Category</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">CategoryTheory</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"n\">D</span> <span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Category</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Category</span> <span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Category</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">⥤</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"bp\">⥤</span> <span class=\"n\">E</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"bp\">⋙</span> <span class=\"n\">H</span> <span class=\"bp\">=</span> <span class=\"n\">G</span> <span class=\"bp\">⋙</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsIso</span> <span class=\"o\">(</span><span class=\"n\">H.map</span> <span class=\"o\">(</span><span class=\"n\">F.map</span> <span class=\"n\">f</span><span class=\"o\">))]</span> <span class=\"o\">:</span>\n    <span class=\"n\">IsIso</span> <span class=\"o\">(</span><span class=\"n\">H.map</span> <span class=\"o\">(</span><span class=\"n\">G.map</span> <span class=\"n\">f</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Functor.comp_map</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"c1\">-- tactic 'rewrite' failed, motive is not type correct</span>\n  <span class=\"n\">dsimp</span>\n  <span class=\"n\">infer_instance</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">CategoryTheory</span>\n</code></pre></div>\n<p>Most of the time, if we can work with the data of functors isomorphisms rather than relying on equalities, it is generally advisable to do so: many functors are defined only up to a unique isomorphisms, so that it is not mathematically meaningful to use equalities of functors. However, some arguably meaningful equalities of functors do appear sometimes: for example, I have used this in 1) <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/Localization/Predicate.html\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/Localization/Predicate.html</a> and 2) in the proof of the Dold-Kan equivalence. For 1), I just do not see how I could have done it without using the equalities of functors that are part of the universal property of a localized category. For 2), I found it was more convenient to do some <code>rw</code> in equalities of functors rather than showing all the constructions could be transported by isomorphisms.</p>",
        "id": 354100497,
        "sender_full_name": "Joël Riou",
        "timestamp": 1682727234
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span>  I guess i don't understand, from the type-theoretic perspective, why sometimes <code>rw</code> along equality of functors work and sometimes it does not?</p>",
        "id": 358323538,
        "sender_full_name": "Sina",
        "timestamp": 1684101441
    },
    {
        "content": "<p>One issue from a type-theoretic perspective is that equality is defined as an inductive type, and the theorem that if <code>x=y</code> then <code>P(x)=P(y)</code> (called the \"principle of substitution\" by logicians) is the axiom of recursion for equality in Lean, and in particular it's an axiom, so when checking that a diagram commutes you can't just \"unravel everything\", because you run into something for which there is no definition and which you can't \"evaluate\" or \"unfold\". A consequence of this is that if <code>a = b</code> are integers, but the proof isn't <code>refl</code>, and if <code>M(n)</code> is an abelian group attached to each integer, then <code>M(a)=M(b)</code> but the proof isn't <code>refl</code> and involves an axiom which turns out to be hard to work with. Given a term of type M(a) you can't just coerce it to having type M(b) for example, because coercions will only work for definitional equality. The way we address this is by instead of trying to make the equality work, we use an isomorphism <code>M(a) \\iso M(b)</code> and prove theorems about this isomorphism instead. Equality of terms is fine but equality of types is problematic in dependent type theory. Equality of functors involves a lot of equality of types and if the proof isn't refl then you get this problem all over the place.</p>",
        "id": 358324082,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1684101859
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/rewriting.20along.20equality.20of.20functors/near/358324082\">said</a>:</p>\n<blockquote>\n<p>One issue from a type-theoretic perspective is that equality is defined as an inductive type, and the theorem that if <code>x=y</code> then <code>P(x)=P(y)</code> (called the \"principle of explosion\" by logicians) is the axiom of recursion for equality in Lean, and in particular it's an axiom, so when checking that a diagram commutes you can't just \"unravel everything\", because you run into something for which there is no definition and which you can't \"evaluate\" or \"unfold\". A consequence of this is that if <code>a = b</code> are integers, but the proof isn't <code>refl</code>, and if <code>M(n)</code> is an abelian group attached to each integer, then <code>M(a)=M(b)</code> but the proof isn't <code>refl</code> and involves an axiom which turns out to be hard to work with. Given a term of type M(a) you can't just coerce it to having type M(b) for example, because coercions will only work for definitional equality. The way we address this is by instead of trying to make the equality work, we use an isomorphism <code>M(a) \\iso M(b)</code> and prove theorems about this isomorphism instead. Equality of terms is fine but equality of types is problematic in dependent type theory. Equality of functors involves a lot of equality of types and if the proof isn't refl then you get this problem all over the place.</p>\n</blockquote>\n<p>Thanks, this is helpful! I guess, like your example of groups indexed by integers, this is about the <strong>dependently-typed</strong> structure of categories, say as opposed to the situation with groups and group homomorphisms, since to check equality of functors F and G, Lean needs to construct a proof of <code>Ff = Gf</code> for any morphism <code>f : X -&gt; Y</code>  but, a priori, <code>Ff</code> and <code>Gf</code> are terms of two different types which are not necessarily definitionally equal. That is why, in most cases <code>rw</code> fails for equality of functors.</p>",
        "id": 358325330,
        "sender_full_name": "Sina",
        "timestamp": 1684103151
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/rewriting.20along.20equality.20of.20functors/near/358324082\">said</a>:</p>\n<blockquote>\n<p>the theorem that if <code>x=y</code> then <code>P(x)=P(y)</code> (called the \"principle of explosion\" by logicians)</p>\n</blockquote>\n<p>I think that property would be called equality congruence, or the substitution property of equality. The principle of explosion is <code>False -&gt; P</code> (or <code>P -&gt; not P -&gt; Q</code> depending on the foundations)</p>",
        "id": 358345907,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684116052
    },
    {
        "content": "<p>Thanks! Fixed -- sorry for spreading misinformation.</p>",
        "id": 358378350,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1684135979
    }
]