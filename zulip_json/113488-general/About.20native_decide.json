[
    {
        "content": "<p>I just discovered <code>native_decide</code> (before was doing the same using an elab <code>evalExpr</code>).<br>\nI've almost created a kernel verified automated proof for a decidable equivalence, but meanwhile i'm using <code>native_decide</code> and it's nice to have this option while working on the formal proof. </p>\n<p>And so, i have two questions.</p>\n<ul>\n<li>i see that <code>native_decide</code> is not allowed in mathlib. So i guess it's considered harmful even if not trying to exploit the already identified hacks people have found ?</li>\n<li>i'm curious if there could be a subset of lean (that prevents using the already discovered hacks) that could be activated through a flag to have a more trusted <code>native_decide</code> ?</li>\n</ul>",
        "id": 538076582,
        "sender_full_name": "Alfredo Moreira-Rosa",
        "timestamp": 1757249235
    },
    {
        "content": "<p>Yeah native_decide can be used to hack Lean, so all uses of native_decide are banned.</p>",
        "id": 538079923,
        "sender_full_name": "(deleted)",
        "timestamp": 1757252184
    },
    {
        "content": "<p>I think it is hard to define the boundary of \"subset without known hacks\" (or rather, the boundary is already decided: things without native_decide vs with native_decide).</p>",
        "id": 538079941,
        "sender_full_name": "Weiyi Wang",
        "timestamp": 1757252196
    },
    {
        "content": "<p>Currently, there is no version of native_decide that is less hackable, so we have to make do with decide. Even though there are things that can't be solved with decide.</p>",
        "id": 538079972,
        "sender_full_name": "(deleted)",
        "timestamp": 1757252223
    },
    {
        "content": "<p>Yi is right.</p>",
        "id": 538080034,
        "sender_full_name": "(deleted)",
        "timestamp": 1757252268
    },
    {
        "content": "<p>But don't despair! simp might be magical enough to do what you need</p>",
        "id": 538080097,
        "sender_full_name": "(deleted)",
        "timestamp": 1757252314
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"873350\">Weiyi Wang</span> <a href=\"#narrow/channel/113488-general/topic/About.20native_decide/near/538079941\">said</a>:</p>\n<blockquote>\n<p>I think it is hard to define the boundary of \"subset without known hacks\" (or rather, the boundary is already decided: things without native_decide vs with native_decide).</p>\n</blockquote>\n<p>That's a bit too pessimistic. If you e.g. have a system for proof by reflection where you control all the code that actually gets executed within the <code>native_decide</code> call and only the input is under control of the attacker things can very much turn out to be fine.</p>",
        "id": 538080134,
        "sender_full_name": "Henrik B√∂ving",
        "timestamp": 1757252346
    },
    {
        "content": "<p>yes, i'm halfway through my automated proof, exactly using <code>simp</code> and custom <code>simpsets</code> , so in the mean time i just make lean show a warning message  when it's used :<br>\n<a href=\"/user_uploads/3121/82xlV0NogmUGDrEuPsh5ePpH/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/82xlV0NogmUGDrEuPsh5ePpH/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"837x206\" src=\"/user_uploads/thumbnail/3121/82xlV0NogmUGDrEuPsh5ePpH/image.png/840x560.webp\"></a></div>",
        "id": 538080178,
        "sender_full_name": "Alfredo Moreira-Rosa",
        "timestamp": 1757252371
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik B√∂ving</span> <a href=\"#narrow/channel/113488-general/topic/About.20native_decide/near/538080134\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"873350\">Weiyi Wang</span> <a href=\"#narrow/channel/113488-general/topic/About.20native_decide/near/538079941\">said</a>:</p>\n<blockquote>\n<p>I think it is hard to define the boundary of \"subset without known hacks\" (or rather, the boundary is already decided: things without native_decide vs with native_decide).</p>\n</blockquote>\n<p>That's a bit too pessimistic. If you e.g. have a system for proof by reflection where you control all the code that actually gets executed within the <code>native_decide</code> call and only the input is under control of the attacker things can very much turn out to be fine.</p>\n</blockquote>\n<p>I agree with you when I use <code>native_decide</code>in my personal project. If I were to put the position of a mathlib maintainer, I would be more pessimistic: the idea that \"mathlib could be wrong because of native_decide\" is contagious, even if it isn't true</p>",
        "id": 538080441,
        "sender_full_name": "Weiyi Wang",
        "timestamp": 1757252598
    },
    {
        "content": "<p>(I realized I posted this in the context of mathlib because OP mentioned it. But I agree with you if we are talking about projects in general)</p>",
        "id": 538080590,
        "sender_full_name": "Weiyi Wang",
        "timestamp": 1757252722
    },
    {
        "content": "<p>Just finished my automated proof! no more <code>native_decide</code>, it served me well :)<br>\n<a href=\"/user_uploads/3121/q2RpMoQRONlUhxBo-_wSYfKt/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/q2RpMoQRONlUhxBo-_wSYfKt/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"831x196\" src=\"/user_uploads/thumbnail/3121/q2RpMoQRONlUhxBo-_wSYfKt/image.png/840x560.webp\"></a></div>",
        "id": 538096450,
        "sender_full_name": "Alfredo Moreira-Rosa",
        "timestamp": 1757268660
    },
    {
        "content": "<p>But it's about 10 times slower <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 538096601,
        "sender_full_name": "Alfredo Moreira-Rosa",
        "timestamp": 1757268831
    },
    {
        "content": "<p>(off-topic, but i believe \"kinetic\" is the word you're looking for)</p>",
        "id": 538136747,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1757310420
    },
    {
        "content": "<p>Yes, I'm french, we have our own words <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 538138889,
        "sender_full_name": "Alfredo Moreira-Rosa",
        "timestamp": 1757311608
    },
    {
        "content": "<p>For completeness, there is <code>decide +kernel</code> which is more powerful than <code>decide</code> but trusted.</p>",
        "id": 538201958,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1757331867
    },
    {
        "content": "<p>So an alternative question, is <code>decide +kernel</code> considered an ok proof ?</p>",
        "id": 539746417,
        "sender_full_name": "Alfredo Moreira-Rosa",
        "timestamp": 1758022951
    },
    {
        "content": "<p>an example for a dimensional analysis check :</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">not_e_equal_mc_dim_check</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">WithDim</span><span class=\"w\"> </span><span class=\"n\">Dimension</span><span class=\"bp\">.</span><span class=\"n\">Energy</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">WithDim</span><span class=\"w\"> </span><span class=\"n\">Dimension</span><span class=\"bp\">.</span><span class=\"n\">Mass</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">   </span><span class=\"bp\">¬¨</span><span class=\"w\"> </span><span class=\"n\">ùíü</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\">  </span><span class=\"n\">ùíü</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simp_dim</span>\n<span class=\"w\">    </span><span class=\"n\">decide</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"n\">kernel</span>\n</code></pre></div>",
        "id": 539747298,
        "sender_full_name": "Alfredo Moreira-Rosa",
        "timestamp": 1758023236
    },
    {
        "content": "<p>does this generate terms that an external checker can check ?</p>",
        "id": 539747797,
        "sender_full_name": "Alfredo Moreira-Rosa",
        "timestamp": 1758023397
    },
    {
        "content": "<p>It should do, the kernel is the bit that external checkers implement</p>",
        "id": 539747974,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1758023448
    },
    {
        "content": "<p>Both <code>decide</code> and <code>decide +kernel</code> for a goal <code>t</code> is the same as doing <code>of_decide_eq_true (id (Eq.refl true) : decide t = true)</code>; the only difference is that <code>+kernel</code> sends the term to the kernel for checking immediately.</p>\n<p>If you use <code>show_term</code>, you'll see something like <code>not_e_equal_mc_dim_check._proof_1_1</code>. The way <code>decide +kernel</code> works is that it wraps up this <code>of_decide_eq_true</code> proof as an auxiliary theorem and sends it to the kernel for checking. Without <code>+kernel</code>, it will additionally use the elaborator typechecker.</p>\n<p>The <code>decide +kernel</code> tactic is nearly always faster than <code>decide</code> if it succeeds. If it fails, <code>decide</code> is potentially faster (it respects definition transparency, so might unfold less). Since <code>decide</code> is frequently attempted in automation, for example the <code>trivial</code> tactic, so failing fast is important.</p>",
        "id": 539912423,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1758070114
    }
]