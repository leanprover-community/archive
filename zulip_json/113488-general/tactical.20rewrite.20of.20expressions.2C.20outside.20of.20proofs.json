[
    {
        "content": "<p>Still playing with collaltz, and doing what I've seen maths people do on youtube when they don't understand a problem and creating a number system for it. Turns out that it's \"almost\" binary written backwards. Anyhoo ... to make a long story short I have this fragment:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- a collatz numeral, decomposed into odd and even components</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">ColN</span> <span class=\"n\">where</span>\n    <span class=\"bp\">|</span> <span class=\"n\">zero</span>      <span class=\"o\">:</span> <span class=\"n\">ColN</span>                <span class=\"c1\">-- zero, also leading zero</span>\n    <span class=\"bp\">|</span> <span class=\"n\">of_even</span>   <span class=\"o\">:</span> <span class=\"n\">ColN</span> <span class=\"bp\">→</span> <span class=\"n\">ColN</span>   <span class=\"c1\">-- the even number that is twice the previous</span>\n    <span class=\"bp\">|</span> <span class=\"n\">of_odd</span>    <span class=\"o\">:</span> <span class=\"n\">ColN</span> <span class=\"bp\">→</span> <span class=\"n\">ColN</span>   <span class=\"c1\">-- the odd number that is one more than twice the previous</span>\n\n<span class=\"c1\">-- Evaluation at 0 recovers the natural number equivalent to the faux binary representation.</span>\n<span class=\"kd\">def</span> <span class=\"n\">ColN.eval</span> <span class=\"o\">(</span><span class=\"n\">cn</span><span class=\"o\">:</span> <span class=\"n\">ColN</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">cn</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"n\">ColN.zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"n\">ColN.of_even</span> <span class=\"n\">cm</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">ColN.eval</span> <span class=\"n\">cm</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">ColN.of_odd</span> <span class=\"n\">cm</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">ColN.eval</span> <span class=\"n\">cm</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"k\">#reduce</span> <span class=\"n\">ColN.eval</span> <span class=\"o\">(</span><span class=\"n\">ColN.of_even</span> <span class=\"bp\">$</span> <span class=\"n\">ColN.of_odd</span> <span class=\"n\">ColN.zero</span><span class=\"o\">)</span> <span class=\"mi\">0</span> <span class=\"c1\">-- 2</span>\n<span class=\"k\">#reduce</span> <span class=\"n\">ColN.eval</span> <span class=\"o\">(</span><span class=\"n\">ColN.of_even</span> <span class=\"bp\">$</span> <span class=\"n\">ColN.of_odd</span> <span class=\"n\">ColN.zero</span><span class=\"o\">)</span> <span class=\"mi\">1</span> <span class=\"c1\">-- 6</span>\n<span class=\"k\">#reduce</span> <span class=\"n\">ColN.eval</span> <span class=\"o\">(</span><span class=\"n\">ColN.of_even</span> <span class=\"bp\">$</span> <span class=\"n\">ColN.of_odd</span> <span class=\"n\">ColN.zero</span><span class=\"o\">)</span> <span class=\"mi\">2</span> <span class=\"c1\">-- 10</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">):</span> <span class=\"o\">(</span><span class=\"n\">ColN.eval</span> <span class=\"o\">(</span><span class=\"n\">ColN.of_even</span> <span class=\"bp\">$</span> <span class=\"n\">ColN.of_odd</span> <span class=\"n\">ColN.zero</span><span class=\"o\">)</span> <span class=\"bp\">$</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">repeat</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">ColN.eval</span><span class=\"o\">]</span>\n    <span class=\"n\">ring</span>\n\n<span class=\"k\">#reduce</span> <span class=\"n\">ColN.eval</span> <span class=\"o\">(</span><span class=\"n\">ColN.of_even</span> <span class=\"bp\">$</span> <span class=\"n\">ColN.of_odd</span> <span class=\"n\">ColN.zero</span><span class=\"o\">)</span> <span class=\"c1\">-- some ungodly eldritch terror</span>\n</code></pre></div>\n<p>Clearly, rewriting <code>ColN.eval</code> and applying <code>ring</code> can simplify down my number to 4n+2, but is there a way to use this directly to automatically simplify the horrific lambda expression to <code>λn, 4*n+2</code> outside of a proof and without having the target expression already written out? I guess I'm asking how to use tactics to rewrite/simplify code. I won't typically know the target equation and also don't really want to need to work it out on paper.</p>",
        "id": 392402248,
        "sender_full_name": "Matthew Pocock",
        "timestamp": 1695333874
    },
    {
        "content": "<p>If you add the following lemmas, <code>simp</code> will prove your <code>repeat rw [ColN.eval]</code> expression.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">eval_zero</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ColN.eval</span> <span class=\"n\">ColN.zero</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">eval_of_even</span> <span class=\"o\">(</span><span class=\"n\">cn</span> <span class=\"o\">:</span> <span class=\"n\">ColN</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ColN.of_even</span> <span class=\"n\">cn</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">eval</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">cn.eval</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">eval_of_odd</span> <span class=\"o\">(</span><span class=\"n\">cn</span> <span class=\"o\">:</span> <span class=\"n\">ColN</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ColN.of_odd</span> <span class=\"n\">cn</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">eval</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">cn.eval</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 392402737,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1695334211
    },
    {
        "content": "<p>I did slightly change this line:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">|</span> <span class=\"n\">ColN.of_odd</span> <span class=\"n\">cm</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">ColN.eval</span> <span class=\"n\">cm</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>  <span class=\"c1\">-- not 1 + 2 * (ColN.eval cm n)</span>\n</code></pre></div>\n<p>just because it's normally better style to add one on the right in Lean. That's just because natural addition is defined by recursion on the right.</p>",
        "id": 392402804,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1695334276
    },
    {
        "content": "<p>You can write your own tactic to do that \"simp then ring\" process:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">macro</span> <span class=\"s2\">\"eval_coln\"</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">eval_zero</span><span class=\"o\">,</span> <span class=\"n\">eval_of_even</span><span class=\"o\">,</span> <span class=\"n\">eval_of_odd</span><span class=\"o\">]</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">ring_nf</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>then the proof becomes</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">):</span> <span class=\"o\">(</span><span class=\"n\">ColN.eval</span> <span class=\"o\">(</span><span class=\"n\">ColN.of_even</span> <span class=\"bp\">$</span> <span class=\"n\">ColN.of_odd</span> <span class=\"n\">ColN.zero</span><span class=\"o\">)</span> <span class=\"bp\">$</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">by</span> <span class=\"n\">eval_coln</span>\n</code></pre></div>",
        "id": 392403129,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1695334477
    },
    {
        "content": "<p>It does a bit more than just evaluate <code>ColN.eval</code> expressions though - the <code>ring_nf</code> in the macro will try to turn all ring expressions in your goal into a normal form.</p>",
        "id": 392403223,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1695334550
    },
    {
        "content": "<p>It's less readable to use a custom tactic though, so I think it's probably only better if you're using it lots.</p>",
        "id": 392403312,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1695334593
    },
    {
        "content": "<p>Thanks. I've tidied up my definitions. But my question isn't really about the <code>example</code> but the <code>#reduce</code>. I really want something that will eat my nasty <code>#reduce ColN.eval ...</code> expression and convince reduce to print out the equivalent of <code>λn, 4*n+2</code> instead of the mess it currently does.</p>",
        "id": 392403470,
        "sender_full_name": "Matthew Pocock",
        "timestamp": 1695334695
    },
    {
        "content": "<p>Ah, I see. In this case, we can change the simp lemmas to this form:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">eval_zero</span> <span class=\"o\">:</span> <span class=\"n\">ColN.eval</span> <span class=\"n\">ColN.zero</span> <span class=\"bp\">=</span> <span class=\"n\">id</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">eval_of_even</span> <span class=\"o\">(</span><span class=\"n\">cn</span> <span class=\"o\">:</span> <span class=\"n\">ColN</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ColN.of_even</span> <span class=\"n\">cn</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">eval</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">cn.eval</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">eval_of_odd</span> <span class=\"o\">(</span><span class=\"n\">cn</span> <span class=\"o\">:</span> <span class=\"n\">ColN</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ColN.of_odd</span> <span class=\"n\">cn</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">eval</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">cn.eval</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 392403708,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1695334822
    },
    {
        "content": "<p>Note that the LHS and RHS of each lemma is now a function. For example, <code>eval_of_even</code> says that the function <code>(ColN.of_even cn).eval</code> is <code>2 *</code> the function <code>cn.eval</code>. Scalar multiplication on functions is defined \"pointwise\", so <code>(2 * f) x = 2 * (f x)</code>.</p>",
        "id": 392403811,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1695334891
    },
    {
        "content": "<p>Then, calling <code>simp</code> on <code>ColN.eval (ColN.of_even $ ColN.of_odd ColN.zero)</code> gives <code>2 * (2 * id + 1)</code>. I wonder if we can make this any better.</p>",
        "id": 392403947,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1695334962
    },
    {
        "content": "<p>If we write the simp lemmas in this form:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">eval_zero</span> <span class=\"o\">:</span> <span class=\"n\">ColN.eval</span> <span class=\"n\">ColN.zero</span> <span class=\"bp\">=</span> <span class=\"n\">id</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">eval_of_even</span> <span class=\"o\">(</span><span class=\"n\">cn</span> <span class=\"o\">:</span> <span class=\"n\">ColN</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ColN.of_even</span> <span class=\"n\">cn</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">eval</span> <span class=\"bp\">=</span> <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">cn.eval</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">eval_of_odd</span> <span class=\"o\">(</span><span class=\"n\">cn</span> <span class=\"o\">:</span> <span class=\"n\">ColN</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ColN.of_odd</span> <span class=\"n\">cn</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">eval</span> <span class=\"bp\">=</span> <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">cn.eval</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>it introduces lambda abstractions as needed. Then <code>simp</code>ing <code>ColN.eval (ColN.of_even $ ColN.of_odd ColN.zero)</code> gives <code>fun n =&gt; 2 * (2 * n + 1))</code>. The issue with this is that <code>ring</code> is a bit worse when there's a <code>fun</code> in the way.</p>",
        "id": 392404390,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1695335215
    },
    {
        "content": "<p>I've done it manually for now:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/--!</span>\n<span class=\"sd\">This evaluates a `ColN` to a pair, ⟨m, c⟩ that can be used as in `m*x+c` to recover the equation of the colaltz number.</span>\n<span class=\"sd\">Unlike `ColN.eval`, it does not produce a nested lambda structure, but instead keeps everything flat.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">def</span> <span class=\"n\">ColN.eval_p</span> <span class=\"o\">(</span><span class=\"n\">cn</span><span class=\"o\">:</span> <span class=\"n\">ColN</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">×</span><span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">cn</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"n\">ColN.zero</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">⟩</span>\n<span class=\"bp\">|</span> <span class=\"n\">ColN.of_even</span> <span class=\"n\">cm</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"o\">⟨</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">cm.eval_p</span>\n    <span class=\"o\">⟨</span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">c</span><span class=\"o\">⟩</span>\n<span class=\"bp\">|</span> <span class=\"n\">ColN.of_odd</span> <span class=\"n\">cm</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"o\">⟨</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">cm.eval_p</span>\n    <span class=\"o\">⟨</span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">⟩</span>\n\n<span class=\"sd\">/--!</span>\n<span class=\"sd\">Evaluate a `ColN` using the parameterisation calculated by `ColN.eval_p`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">def</span> <span class=\"n\">ColN.eval_p_n</span> <span class=\"o\">(</span><span class=\"n\">cn</span><span class=\"o\">:</span> <span class=\"n\">ColN</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n    <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">cn.eval_p</span>\n    <span class=\"n\">m</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">c</span>\n</code></pre></div>\n<p>Perhaps writing in out manually is how we're supposed to do things. I still wonder if there's a way to encourage tactics to rewrite code, outside of trying to satisfy a proof.</p>",
        "id": 392408721,
        "sender_full_name": "Matthew Pocock",
        "timestamp": 1695337949
    },
    {
        "content": "<p>This is probably a good idea. Of course, you can also write <code>simp</code> lemmas to simplify these kinds of expressions, and the simplifier will have an easier job if things are parameters instead of inside lambdas. Incidentally, I think you can get away with splitting <code>eval_p</code> into two functions - one for the left output and one for the right. It might make manipulation a bit easier (but you may need more lemmas).</p>",
        "id": 392411124,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1695339491
    },
    {
        "content": "<p>Yeah. I can certainly do that. But what I really want to do is take  a value like <code>ColN.eval (ColN.of_even $ ColN.of_odd ColN.zero)</code>, and where <code>#reduce</code> currently prints out a complex lambda, be able to apply a tactic to that <em>expression</em> to reduce it to the simple one. So, to invent syntax.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#reduce</span> <span class=\"o\">{</span><span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">ring_nf</span><span class=\"o\">}</span> <span class=\"n\">ColN.eval</span> <span class=\"o\">(</span><span class=\"n\">ColN.of_even</span> <span class=\"bp\">$</span> <span class=\"n\">ColN.of_odd</span> <span class=\"n\">ColN.zero</span><span class=\"o\">)</span> <span class=\"c1\">-- displays `fun x =&gt; 4 * x + 2`</span>\n</code></pre></div>",
        "id": 392411996,
        "sender_full_name": "Matthew Pocock",
        "timestamp": 1695340110
    },
    {
        "content": "<p>You can see what would happen if you applied tactics to expressions by just putting them in a proof state:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ring</span>\n<span class=\"c1\">-- x: ℕ</span>\n<span class=\"c1\">-- ⊢ 2 = x</span>\n</code></pre></div>\n<p>I put the <code>x</code> in there to make the goal false, this stops the tactics from automatically solving the goal for me.</p>",
        "id": 392412265,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1695340289
    },
    {
        "content": "<p>There's probably a better way to do this though.</p>",
        "id": 392412279,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1695340298
    },
    {
        "content": "<p>I don't think most tactics really know how to act on \"bare\" terms (of types in <code>Type</code> not <code>Prop</code>).</p>",
        "id": 392412621,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1695340497
    },
    {
        "content": "<p>Yeah tactic mode is for proving theorems, not constructing data in general. Some tactics can make awful terms but because they're supposed to be proofs it doesn't matter</p>",
        "id": 392444513,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1695361965
    },
    {
        "content": "<p>I don't recommend using it for anything but exploration, but there's a <code>reduce</code> tactic that does what <code>#reduce</code> does.</p>",
        "id": 392475560,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1695374229
    },
    {
        "content": "<p>Thanks. I was hoping that I could convince the tactic system to do code optimizations, to rewrite verbose and inefficient execution paths into better ones. But seems the machinery isn't keen on that :D I realise the proofs themselves are a nightmare, but it's the target expression that I'm interested in tidying as an optimized expression equivalent to my original one. The proof doesn't matter to me. Just the rewritten term.</p>",
        "id": 392483436,
        "sender_full_name": "Matthew Pocock",
        "timestamp": 1695376792
    },
    {
        "content": "<p>I'll chalk it up as a \"not ever intended to work\"</p>",
        "id": 392483583,
        "sender_full_name": "Matthew Pocock",
        "timestamp": 1695376827
    },
    {
        "content": "<p>Rewriting terms like this, for reduction purposes, is what norm_num and expression based \"calculators\" do. You could write a custom tactic or elaborator for your specific use case.</p>",
        "id": 392498044,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1695382117
    },
    {
        "content": "<p>Were you thinking of something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean.Meta.Tactic.Simp</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.RunCmd</span>\n<span class=\"kn\">import</span> <span class=\"n\">Std.Tactic.TryThis</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">pretty</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Elab.TermElabM</span> <span class=\"n\">Format</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">s</span> <span class=\"bp\">←</span> <span class=\"n\">Std.Tactic.TryThis.delabToRefinableSyntax</span> <span class=\"n\">e</span>\n    <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"bp\">←</span> <span class=\"n\">PrettyPrinter.ppCategory</span> <span class=\"bp\">`</span><span class=\"n\">term</span> <span class=\"n\">s</span>\n    <span class=\"n\">pure</span> <span class=\"n\">f</span>\n\n<span class=\"n\">elab</span> <span class=\"s2\">\"simp_expr \"</span> <span class=\"n\">e</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Lean.Elab.Command.liftTermElabM</span> <span class=\"bp\">$</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">expr</span> <span class=\"bp\">←</span> <span class=\"n\">Lean.Elab.Term.elabTerm</span> <span class=\"n\">e</span> <span class=\"n\">none</span>\n    <span class=\"k\">let</span> <span class=\"n\">ctxt</span> <span class=\"bp\">←</span>  <span class=\"n\">Lean.Meta.Simp.Context.mkDefault</span>\n    <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">Lean.Meta.simp</span> <span class=\"n\">expr</span> <span class=\"n\">ctxt</span>\n    <span class=\"n\">logInfo</span> <span class=\"bp\">$</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"Before simplifying:</span><span class=\"se\">\\n</span><span class=\"s2\">{← pretty expr}</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span> <span class=\"bp\">++</span>\n              <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"After simplifying:</span><span class=\"se\">\\n</span><span class=\"s2\">{← pretty r.expr}\"</span>\n    <span class=\"c1\">-- Std.Tactic.TryThis.addTermSuggestion e r.expr</span>\n\n<span class=\"n\">simp_expr</span> <span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"o\">())</span>\n</code></pre></div>\n<p>This prints</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Before</span> <span class=\"n\">simplifying</span><span class=\"o\">:</span>\n<span class=\"n\">id</span> <span class=\"o\">()</span>\n<span class=\"n\">After</span> <span class=\"n\">simplifying</span><span class=\"o\">:</span>\n<span class=\"o\">()</span>\n</code></pre></div>",
        "id": 392552315,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1695398265
    },
    {
        "content": "<p>(I was actually pondering to (ab)use the simplifier like that for a little experiment of mine. I don’t see why it shouldn’t work.)</p>",
        "id": 392552501,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1695398310
    },
    {
        "content": "<p>In mathlib3 there was a <code>simp_result</code> tactic combinator that simplified the results of other tactics before assigning them. But as far as I know it wasn't ported yet</p>",
        "id": 392553054,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1695398463
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/stream/113488-general/topic/tactical.20rewrite.20of.20expressions.2C.20outside.20of.20proofs/near/392552315\">said</a>:</p>\n<blockquote>\n<p>Were you thinking of something like this:</p>\n</blockquote>\n<p>Yes, that's a lot more like what I was thinking of. Thanks.</p>",
        "id": 392580702,
        "sender_full_name": "Matthew Pocock",
        "timestamp": 1695407959
    },
    {
        "content": "<p>Isn't that the <code>#simp</code> command?</p>",
        "id": 392590010,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695412003
    },
    {
        "content": "<p>It seems that for what I wanted to do, it doesn’t quite work: I was hoping to (ab)use the <code>simp</code> machinery as a convenient way to perform recursive term rewrites to <code>Expr</code>. But my expressions are sometimes Prop, and then <code>simp</code> will simply say “done” because two proofs are definitionally equal. Too bad.</p>",
        "id": 392590027,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1695412010
    },
    {
        "content": "<blockquote>\n<p>Isn't that the #simp command?</p>\n</blockquote>\n<p>Indeed! Didn’t even know about that :-)</p>",
        "id": 392590337,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1695412138
    },
    {
        "content": "<p>I assume this <code>#simp</code> doesn’t seem to do do anything because the expression is already a <code>Prop</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.Conv</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.Meta.Tactic.simp</span> <span class=\"n\">true</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.Meta.Tactic.simp.heads</span> <span class=\"n\">true</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.Debug.Meta.Tactic.simp</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">other_eq_self</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"n\">eq_self</span> <span class=\"n\">a</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">other_eq_self_eq_eq_self</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">other_eq_self</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">eq_self</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"bp\">#</span><span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">other_eq_self_eq_eq_self</span><span class=\"o\">]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">other_eq_self</span> <span class=\"n\">True</span>\n</code></pre></div>\n<p>Ah, here it is, from the core of <code>simp</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">simp</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"n\">Result</span> <span class=\"o\">:=</span> <span class=\"n\">withIncRecDepth</span> <span class=\"k\">do</span>\n  <span class=\"n\">checkMaxHeartbeats</span> <span class=\"s2\">\"simp\"</span>\n  <span class=\"k\">let</span> <span class=\"n\">cfg</span> <span class=\"bp\">←</span> <span class=\"n\">getConfig</span>\n  <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">isProof</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"k\">then</span>\n    <span class=\"n\">return</span> <span class=\"o\">{</span> <span class=\"n\">expr</span> <span class=\"o\">:=</span> <span class=\"n\">e</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>So no chance using <code>simp</code> to rewrite proof terms :-)</p>",
        "id": 392591692,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1695412645
    },
    {
        "content": "<p>I'm have not read carefully this thread so I'm not sure if I'm relevant with this but I have macro <code>term rewrite_by conv</code> that rewrite term by conv tactic.</p>\n<p>For example</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"mi\">42</span><span class=\"o\">)</span> <span class=\"n\">rewrite_by</span> <span class=\"n\">simp</span>\n</code></pre></div>\n<p>prints <code>42 : Nat</code>.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>code</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean.Parser.Tactic.Conv</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean.Elab.Tactic.Conv</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Elab</span> <span class=\"n\">Term</span> <span class=\"n\">Meta</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">elabConvRewrite</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">stx</span> <span class=\"o\">:</span> <span class=\"n\">TSyntax</span> <span class=\"bp\">`</span><span class=\"n\">conv</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">TermElabM</span> <span class=\"o\">(</span><span class=\"n\">Expr</span> <span class=\"bp\">×</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">rhs</span><span class=\"o\">,</span> <span class=\"n\">eq</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">mkConvGoalFor</span> <span class=\"n\">e</span>\n\n  <span class=\"k\">let</span> <span class=\"n\">goals</span> <span class=\"bp\">←</span> <span class=\"n\">Tactic.run</span> <span class=\"n\">eq.mvarId</span><span class=\"bp\">!</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">lhsNew</span><span class=\"o\">,</span> <span class=\"n\">proof</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">convert</span> <span class=\"n\">e</span> <span class=\"o\">(</span><span class=\"n\">Tactic.evalTactic</span> <span class=\"n\">stx</span><span class=\"o\">)</span>\n    <span class=\"n\">updateLhs</span> <span class=\"n\">lhsNew</span> <span class=\"n\">proof</span>\n    <span class=\"n\">return</span> <span class=\"o\">()</span>\n\n  <span class=\"k\">if</span> <span class=\"n\">goals.length</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span>\n    <span class=\"n\">throwError</span> <span class=\"s2\">\"this is a bug in rewriteByConv\"</span>\n\n  <span class=\"k\">if</span> <span class=\"n\">goals.length</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">1</span> <span class=\"k\">then</span>\n    <span class=\"n\">throwError</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"error in `rewriteByConv`, unsolved goals {← goals.mapM (fun g =&gt; do ppExpr (← g.getType))}\"</span>\n\n  <span class=\"o\">(</span><span class=\"n\">goals.get</span><span class=\"bp\">!</span> <span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">refl</span>\n\n  <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">instantiateMVars</span> <span class=\"n\">rhs</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">instantiateMVars</span> <span class=\"n\">eq</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">rewriteByConv</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">stx</span> <span class=\"o\">:</span> <span class=\"n\">TSyntax</span> <span class=\"bp\">`</span><span class=\"n\">conv</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"o\">(</span><span class=\"n\">Expr</span> <span class=\"bp\">×</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">r</span><span class=\"o\">,</span><span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"o\">(</span><span class=\"n\">elabConvRewrite</span> <span class=\"n\">e</span> <span class=\"n\">stx</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">run</span> <span class=\"o\">{}</span> <span class=\"o\">{}</span>\n  <span class=\"n\">return</span> <span class=\"n\">r</span>\n\n<span class=\"n\">syntax</span><span class=\"o\">:</span><span class=\"mi\">1</span> <span class=\"n\">term</span> <span class=\"s2\">\"rewrite_by\"</span> <span class=\"n\">convSeq</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n\n<span class=\"n\">elab_rules</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"n\">rewrite_by</span> <span class=\"bp\">$</span><span class=\"n\">rw</span><span class=\"o\">:</span><span class=\"n\">convSeq</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">x</span> <span class=\"bp\">←</span> <span class=\"n\">elabTerm</span> <span class=\"n\">x</span> <span class=\"n\">none</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">x'</span><span class=\"o\">,</span><span class=\"n\">_eq</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">elabConvRewrite</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">conv</span><span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">rw</span><span class=\"o\">)))</span>\n  <span class=\"n\">return</span> <span class=\"n\">x'</span>\n</code></pre></div>\n</div></div>",
        "id": 392614139,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1695424101
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"645990\">Matthew Pocock</span> <a href=\"#narrow/stream/113488-general/topic/tactical.20rewrite.20of.20expressions.2C.20outside.20of.20proofs/near/392483436\">said</a>:</p>\n<blockquote>\n<p>Thanks. I was hoping that I could convince the tactic system to do code optimizations, to rewrite verbose and inefficient execution paths into better ones. But seems the machinery isn't keen on that :D I realise the proofs themselves are a nightmare, but it's the target expression that I'm interested in tidying as an optimized expression equivalent to my original one. The proof doesn't matter to me. Just the rewritten term.</p>\n</blockquote>\n<p>I'm definitely using Lean for this purpose. I had to modify the simplifier a bit but doing this kind of stuff is totally possible.</p>\n<p>I'm planning on modifying the simplifier even more such that it handles let bindings a bit better and I will add an option to turn off proof generation such that on massive programs is runs reasonably fast.</p>",
        "id": 392614703,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1695424472
    },
    {
        "content": "<p>An example of code optimization, I have conv tactic <a href=\"https://github.com/lecopivo/SciLean/blob/master/SciLean/Tactic/LetNormalize.lean\"><code>let_normalize</code></a> that cleans up let bindings and moves them out of lambdas if possible</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">let</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n      <span class=\"k\">let</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">a</span>\n      <span class=\"k\">let</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span>\n      <span class=\"n\">a</span><span class=\"bp\">+</span><span class=\"n\">b</span><span class=\"bp\">+</span><span class=\"n\">c</span><span class=\"o\">)</span>\n    <span class=\"n\">rewrite_by</span>\n      <span class=\"n\">let_normalize</span>\n</code></pre></div>\n<p>prints</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"k\">let</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"bp\">;</span>\n  <span class=\"k\">let</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">a</span><span class=\"bp\">;</span>\n  <span class=\"k\">fun</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"k\">let</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"bp\">;</span>\n  <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span>\n</code></pre></div>",
        "id": 392615315,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1695424878
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span> mathlib has a <code>lift_lets</code> tactic, but I don't recall a conv version yet. There are conv tactics at least for reduce, whnf, projection unfolding, and a few others.</p>",
        "id": 392686722,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1695469941
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"470149\">@Joachim Breitner</span> You might be interested in the elementwise attribute in mathlib (look in the category theory folder in the tactic folder). It uses a function to simp the lhs and rhs independently when generating a lemma statement.</p>",
        "id": 392687153,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1695470090
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span> That looks interesting. It works for me in some simple examples. I tried to capture the rewritten form inside a def, but failed.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">ColN</span> <span class=\"n\">where</span>\n    <span class=\"bp\">|</span> <span class=\"n\">zero</span>      <span class=\"o\">:</span> <span class=\"n\">ColN</span>\n    <span class=\"bp\">|</span> <span class=\"n\">even_of</span>   <span class=\"o\">:</span> <span class=\"n\">ColN</span> <span class=\"bp\">→</span> <span class=\"n\">ColN</span>\n    <span class=\"bp\">|</span> <span class=\"n\">odd_of</span>    <span class=\"o\">:</span> <span class=\"n\">ColN</span> <span class=\"bp\">→</span> <span class=\"n\">ColN</span>\n<span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">def</span> <span class=\"n\">ColN.eval</span> <span class=\"o\">(</span><span class=\"n\">cn</span><span class=\"o\">:</span> <span class=\"n\">ColN</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">cn</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"n\">ColN.zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"n\">ColN.even_of</span> <span class=\"n\">cm</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">ColN.eval</span> <span class=\"n\">cm</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">ColN.odd_of</span> <span class=\"n\">cm</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">ColN.eval</span> <span class=\"n\">cm</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">z10</span> <span class=\"o\">:=</span> <span class=\"n\">ColN.even_of</span> <span class=\"bp\">$</span> <span class=\"n\">ColN.odd_of</span> <span class=\"n\">ColN.zero</span>\n\n<span class=\"k\">#reduce</span> <span class=\"n\">z10.eval</span> <span class=\"c1\">-- bleutch!</span>\n<span class=\"k\">#check</span> <span class=\"n\">z10.eval</span> <span class=\"n\">rewrite_by</span> <span class=\"n\">simp</span> <span class=\"bp\">;</span> <span class=\"n\">ring</span> <span class=\"c1\">-- gives 2+n*4, which is exactly what we would want :)</span>\n\n<span class=\"c1\">-- try to capture the rewritten form</span>\n<span class=\"kd\">def</span> <span class=\"n\">z10eval</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">z10.eval</span> <span class=\"n\">rewrite_by</span> <span class=\"n\">simp</span> <span class=\"bp\">;</span> <span class=\"n\">ring</span><span class=\"o\">)</span>\n\n<span class=\"k\">#reduce</span> <span class=\"n\">z10eval</span> <span class=\"c1\">-- bleuch again!</span>\n<span class=\"k\">#check</span> <span class=\"n\">z10eval</span>\n</code></pre></div>",
        "id": 392702241,
        "sender_full_name": "Matthew Pocock",
        "timestamp": 1695477280
    },
    {
        "content": "<p>You should not use <code>#reduce z10eval</code>, calling <code>#reduce fun n =&gt; 2 + n * 4</code> gives you the same result as you are reducing through multiplication on Nat. To see the value of <code>z10eval</code> do <code>#print z10eval</code> and you get </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">z10eval</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"mi\">4</span>\n</code></pre></div>\n<p>as desired, you can also play with it using <code>rewrite_by</code> as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span>\n  <span class=\"n\">z10eval</span>\n  <span class=\"n\">rewrite_by</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">z10eval</span>\n</code></pre></div>",
        "id": 393819069,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1695943676
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113488-general/topic/tactical.20rewrite.20of.20expressions.2C.20outside.20of.20proofs/near/392686722\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"346070\">Tomas Skrivan</span> mathlib has a <code>lift_lets</code> tactic, but I don't recall a conv version yet. There are conv tactics at least for reduce, whnf, projection unfolding, and a few others.</p>\n</blockquote>\n<p>Nice! Much cleaner implementation then mine. For my use case I need few more reductions like splitting <code>let a := (x,y); f a</code> into <code>let a1 := x; let a2 := y; f (a1,a2)</code> but that should be easy to adopt.</p>",
        "id": 393820853,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1695944926
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> Ideally I would like <code>lift_lets</code> simplifications happen when I run simplifier, any idea what would be the easiest way to do this?</p>",
        "id": 393821510,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1695945426
    },
    {
        "content": "<p>I have lots of simp rules that create nested let bindings or let bindings like <code>let a := (x, 0)</code> which I want to split and eliminate the zero.</p>",
        "id": 393821643,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1695945546
    }
]