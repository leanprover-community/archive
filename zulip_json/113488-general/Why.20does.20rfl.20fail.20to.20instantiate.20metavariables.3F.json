[
    {
        "content": "<p>Can someone explain <a href=\"https://proofassistants.stackexchange.com/questions/5107/constructing-values-by-refinement-in-lean-how-to-tell-lean-to-instantiate-meta\">this error</a> to me?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">construct_by_refinement</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"bp\">⟨?</span><span class=\"n\">result</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">pf</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">pf</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>What's the right way to construct metavariables and later instantiate them with tactics?</p>",
        "id": 524973607,
        "sender_full_name": "Jason Gross",
        "timestamp": 1750391256
    },
    {
        "content": "<p>When you create meta-variables using <code>?name</code>, they are synthetic-opaque, i.e. defeq will <em>never</em> assign them. Non synthetic-opaque meta-variables are created by <code>_</code> but that won't work here, the <code>constructor</code> tactic also creates non-synthetic-opaque meta-variables though so that's what you can use.</p>",
        "id": 524985481,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1750401657
    },
    {
        "content": "<p>Thanks!  Why doesn't <code>_</code> work?</p>",
        "id": 524985538,
        "sender_full_name": "Jason Gross",
        "timestamp": 1750401704
    },
    {
        "content": "<p>Because <code>refine</code> expects all non-synthetic-opaque metavariables to be assigned</p>",
        "id": 525029909,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1750420965
    },
    {
        "content": "<p><code>apply</code> doesn't have that restriction but also doesn't use the goal type so you need:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">construct_by_refinement</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⟨_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">pf</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">pf</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 525030042,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1750421019
    },
    {
        "content": "<p>This <code>apply</code> is not ideal IMO. But the version I came up with is also not ideal:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">construct_by_refinement</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">run_tac</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">mkFreshExprMVar</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">userName</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"ss\">`result</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"bp\">⟨?</span><span class=\"n\">result</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">?_⟩</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>I hope someone else can chime in with the proper way to do this.</p>",
        "id": 525039764,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1750424870
    },
    {
        "content": "<p>This seems to work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">construct_by_refinement</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Exists</span><span class=\"bp\">.</span><span class=\"n\">intro</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 525062306,
        "sender_full_name": "Dan Velleman",
        "timestamp": 1750433120
    },
    {
        "content": "<p>Yeah, right, <code>constructor</code>, or <code>apply Exists.intro</code> works. I just wanted to demonstrate how <code>refine</code> and <code>apply</code> differ in handling metavariables</p>",
        "id": 525062631,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1750433229
    },
    {
        "content": "<p>Doing something like <code>apply ConstructorName</code> or <code>constructor</code> is also not ideal, because you may want to explicitly say which parameters of the constructor you want to specify ahead of time, and which should be determined later after some unification. So IMO there should be some way to do it with <code>refine</code> (or at least with <code>refine</code>-like syntax)</p>",
        "id": 525063395,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1750433498
    },
    {
        "content": "<p>Hmm at that point you could probably just specify them before though; having metavariables float around is less than ideal -- I even thought at some point that that was a bug in <code>apply</code> (putting the goal for the proof first) and decided to use <code>refine</code> instead for this reason (I've since understood it more but still)</p>",
        "id": 525064475,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1750433882
    },
    {
        "content": "<p>also, <code>apply Exists.intro _ ?prf</code>?</p>",
        "id": 525064578,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1750433916
    },
    {
        "content": "<p>Here's a workaround:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">construct_by_refinement</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"bp\">⟨?</span><span class=\"n\">result</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">pf</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">pf</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>The <code>refine</code> tactic turns on a feature to assign synthetic opaque metavariables. (No one is expected to know this. Consider this to be a hack.) By the way, <code>apply</code>'s current behavior is more-or-less a bug, so that's a hack too.</p>\n<p>This is a usability problem that comes up frequently with existentials. Sometimes you want to let the value follow from the proof rather than vice versa.</p>\n<p>I think it's possible that at some point we might have \"synthetic semiopaque metavariables\", and either <code>_</code> would work here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">construct_by_refinement</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"bp\">⟨_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">pf</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">pf</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>or you'd write <code>??</code>, or some other sigil:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">construct_by_refinement</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"bp\">⟨??</span><span class=\"n\">result</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">pf</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">pf</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>This \"synthetic opaque\" concept is to help address issues where goals would go missing in counterintuitive ways, plus they need to be handled differently internally to make sure that they remain assignable in tactics. The design is also meant to prevent people from writing \"swiss cheese proofs\", with holes in all the types, since they tend to be less maintainable.</p>\n<p>Something that would help get semiopaque metavariables into Lean is a collection of case studies demonstrating it would be a useful proof organization device.</p>",
        "id": 525069583,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750435986
    },
    {
        "content": "<p>Would it make sense to have something like the following for now?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Batteries</span><span class=\"bp\">.</span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Elab</span>\n\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"unifying\"</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"w\"> </span><span class=\"n\">tacs</span><span class=\"o\">:</span><span class=\"n\">tacticSeq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">commitIfNoEx</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mvarid</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">decl</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getMCtx</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">decls</span><span class=\"bp\">.</span><span class=\"n\">toArray</span><span class=\"bp\">.</span><span class=\"n\">find?</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">decl</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">        </span><span class=\"n\">decl</span><span class=\"bp\">.</span><span class=\"n\">userName</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"bp\">.</span><span class=\"n\">getId</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">throwError</span><span class=\"w\"> </span><span class=\"s2\">\"Couldn't find mvar named {id}\"</span>\n<span class=\"w\">    </span><span class=\"n\">modifyMCtx</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">mctx</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">mctx</span><span class=\"bp\">.</span><span class=\"n\">setMVarKind</span><span class=\"w\"> </span><span class=\"n\">mvarid</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">natural</span>\n<span class=\"w\">    </span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">evalTacticSeq</span><span class=\"w\"> </span><span class=\"n\">tacs</span>\n<span class=\"w\">    </span><span class=\"n\">modifyMCtx</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">mctx</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">mctx</span><span class=\"bp\">.</span><span class=\"n\">setMVarKind</span><span class=\"w\"> </span><span class=\"n\">mvarid</span><span class=\"w\"> </span><span class=\"n\">decl</span><span class=\"bp\">.</span><span class=\"n\">kind</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">construct_by_refinement</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"bp\">⟨?</span><span class=\"n\">result</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">pf</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"n\">unifying</span><span class=\"w\"> </span><span class=\"n\">result</span>\n<span class=\"w\">    </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">pf</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 525111670,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1750459383
    }
]