[
    {
        "content": "<p>I'm thinking about adding a section to <a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/channel/113488-general/topic/Documenting.20lean.20pitfalls.3A.20feedback.20requested/with/520155520\">#general &gt; Documenting lean pitfalls: feedback requested</a>  about using tactics outside of theorem. Can someone remind me if it is considered acceptable to:</p>\n<ol>\n<li>Use tactics to produce terms of arbitrary types, when constraining the list of tactics to \"simple\" tactics like <code>apply</code>, <code>have</code>, and <code>infer_instance</code>?</li>\n<li>Use tactics to produce terms of non-definitional subsingletons, such as <code>Decidable</code>, <code>Fintype</code>, and <code>Squash</code>/<code>Trunc</code>?</li>\n<li>Use tactics to produce <em>noncomputable</em> terms of non-definitional subsingletons?</li>\n<li>Use tactics to produce <del>terms of type <code>Prop</code></del> proofs of terms of type <code>Prop</code>, but inside of a <code>def</code> instead of a <code>theorem</code>? These aren't particularly common, but they do exist, like <code>Acc.inv</code>.</li>\n<li>Use tactics inside a <code>def</code> to construct something that is part data, part proof (e.g. an element of a subtype)?</li>\n</ol>",
        "id": 524091933,
        "sender_full_name": "Niels Voss",
        "timestamp": 1749941701
    },
    {
        "content": "<p>But why would you prefer using tactics over terms in the first place?</p>",
        "id": 524092180,
        "sender_full_name": "suhr",
        "timestamp": 1749942072
    },
    {
        "content": "<p>I personally use <code>refine</code> where I provide all the data, and then use <code>?_</code> for any argument that is a proof. For a minimised example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Itself</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">me</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">Itself</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">?_⟩</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"c1\">-- insert very long proof</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">add_zero</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">add_comm</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Other people are probably in better positions than me to answer your questions, but I will try nevertheless (feel free to treat these as just my opinion and wait for another answer):</p>\n<ol>\n<li><code>apply</code>, <code>exact</code>, and <code>refine</code> are fine, and other tactics require more caution.</li>\n<li><del>it is fine for <code>Decidable</code> and <code>Fintype</code> because terms of those types are never unfolded. In other words, those terms are \"irrelevant\" (in the technical sense like \"proof irrelevance\")</del> (edit: see following discussion)</li>\n<li>whether it's noncomputable or not isn't the issue, the issue is whether those definitions will ever be unfolded and reasoned about.</li>\n<li>I'm not sure how you can produce a term of type <code>Prop</code> inside a theorem in the first place. But I would argue that one should still keep tactics to a minimum just like defining any other term of any data types.</li>\n<li>see my example above.</li>\n</ol>",
        "id": 524092224,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749942157
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/113488-general/topic/When.20is.20it.20acceptable.20to.20use.20tactics.20outside.20of.20theorems.3F/near/524092224\">said</a>:</p>\n<blockquote>\n<ol start=\"2\">\n<li>it is fine for <code>Decidable</code> and <code>Fintype</code> because terms of those types are never unfolded. In other words, those terms are \"irrelevant\" (in the technical sense like \"proof irrelevance\")</li>\n</ol>\n</blockquote>\n<p>unfolding these instances is precisely how <code>decide</code> works</p>",
        "id": 524092237,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1749942183
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"394485\">suhr</span> <a href=\"#narrow/channel/113488-general/topic/When.20is.20it.20acceptable.20to.20use.20tactics.20outside.20of.20theorems.3F/near/524092180\">said</a>:</p>\n<blockquote>\n<p>But why would you prefer using tactics over terms in the first place?</p>\n</blockquote>\n<p>Well <a href=\"https://github.com/leanprover-community/mathlib4/pull/5\">#5</a> is done all the time in mathlib, but for the other ones, I'm not completely sure. A common pattern in mathlib (maybe this isn't the case anymore) is to use <code>by classical; exact ...</code> when defining something</p>",
        "id": 524092262,
        "sender_full_name": "Niels Voss",
        "timestamp": 1749942220
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"521331\">Niels Voss</span> <a href=\"#narrow/channel/113488-general/topic/When.20is.20it.20acceptable.20to.20use.20tactics.20outside.20of.20theorems.3F/near/524091933\">said</a>:</p>\n<blockquote>\n<ol start=\"4\">\n<li>Use tactics to produce terms of type <code>Prop</code>,</li>\n</ol>\n</blockquote>\n<p>Do you really mean a term <code>?P : Prop</code>, and not a term <code>?h : P</code> where <code>P : Prop</code>?</p>",
        "id": 524092272,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1749942238
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/113488-general/topic/When.20is.20it.20acceptable.20to.20use.20tactics.20outside.20of.20theorems.3F/near/524092237\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/113488-general/topic/When.20is.20it.20acceptable.20to.20use.20tactics.20outside.20of.20theorems.3F/near/524092224\">said</a>:</p>\n<blockquote>\n<ol start=\"2\">\n<li>it is fine for <code>Decidable</code> and <code>Fintype</code> because terms of those types are never unfolded. In other words, those terms are \"irrelevant\" (in the technical sense like \"proof irrelevance\")</li>\n</ol>\n</blockquote>\n<p>unfolding these instances is precisely how <code>decide</code> works</p>\n</blockquote>\n<p>Does <code>decide</code> fail if there are complicated terms using Eq.mpr (aka the triangle)?</p>",
        "id": 524092286,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749942259
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/113488-general/topic/When.20is.20it.20acceptable.20to.20use.20tactics.20outside.20of.20theorems.3F/near/524092272\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"521331\">Niels Voss</span> <a href=\"#narrow/channel/113488-general/topic/When.20is.20it.20acceptable.20to.20use.20tactics.20outside.20of.20theorems.3F/near/524091933\">said</a>:</p>\n<blockquote>\n<ol start=\"4\">\n<li>Use tactics to produce terms of type <code>Prop</code>,</li>\n</ol>\n</blockquote>\n<p>Do you really mean a term <code>?P : Prop</code>, and not a term <code>?h : P</code> where <code>P : Prop</code>?</p>\n</blockquote>\n<p>Oops, you're right, I meant proofs of propositions</p>",
        "id": 524092305,
        "sender_full_name": "Niels Voss",
        "timestamp": 1749942285
    },
    {
        "content": "<p>proofs of prositions shouldn't be <code>def</code>, right?</p>",
        "id": 524092312,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749942299
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"521331\">Niels Voss</span> <a href=\"#narrow/channel/113488-general/topic/When.20is.20it.20acceptable.20to.20use.20tactics.20outside.20of.20theorems.3F/near/524092262\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"394485\">suhr</span> <a href=\"#narrow/channel/113488-general/topic/When.20is.20it.20acceptable.20to.20use.20tactics.20outside.20of.20theorems.3F/near/524092180\">said</a>:</p>\n<blockquote>\n<p>But why would you prefer using tactics over terms in the first place?</p>\n</blockquote>\n<p>Well <a href=\"https://github.com/leanprover-community/mathlib4/pull/5\">#5</a> is done all the time in mathlib, but for the other ones, I'm not completely sure. A common pattern in mathlib (maybe this isn't the case anymore) is to use <code>by classical; exact ...</code> when defining something</p>\n</blockquote>\n<p>I think I personally have been doing <code>open Classical in</code> for this case</p>",
        "id": 524092328,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749942321
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span>, that's certainly the fear. Either way, \"are never unfolded\" is definitely wrong in your statement, so I encourage you to replace it with a new one about \"Eq.mpr doesn't actually matter\" if you can convince yourself this is true.</p>",
        "id": 524092348,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1749942342
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/113488-general/topic/When.20is.20it.20acceptable.20to.20use.20tactics.20outside.20of.20theorems.3F/near/524092224\">said</a>:</p>\n<blockquote>\n<p>I personally use <code>refine</code> where I provide all the data, and then use <code>?_</code> for any argument that is a proof. For a minimised example:</p>\n</blockquote>\n<p>This is certainly safe, though in my opinion it's not great style. Mainly this style is compelling when the use is actually <code>refine ⟨n, ?_, ?_, ?_, ?_, ?_⟩ &lt;;&gt; simp</code> or similar.</p>",
        "id": 524092405,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1749942428
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/113488-general/topic/When.20is.20it.20acceptable.20to.20use.20tactics.20outside.20of.20theorems.3F/near/524092312\">said</a>:</p>\n<blockquote>\n<p>proofs of prositions shouldn't be <code>def</code>, right?</p>\n</blockquote>\n<p>They need to be <code>def</code>s in certain rare situations, because <code>theorem</code> is kind of like <code>opaque</code> and prevents you from unfolding them.</p>",
        "id": 524092406,
        "sender_full_name": "Niels Voss",
        "timestamp": 1749942430
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/113488-general/topic/When.20is.20it.20acceptable.20to.20use.20tactics.20outside.20of.20theorems.3F/near/524092405\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/113488-general/topic/When.20is.20it.20acceptable.20to.20use.20tactics.20outside.20of.20theorems.3F/near/524092224\">said</a>:</p>\n<blockquote>\n<p>I personally use <code>refine</code> where I provide all the data, and then use <code>?_</code> for any argument that is a proof. For a minimised example:</p>\n</blockquote>\n<p>This is certainly safe, though in my opinion it's not great style. Mainly this style is compelling when the use is actually <code>refine ⟨n, ?_, ?_, ?_, ?_, ?_⟩ &lt;;&gt; simp</code> or similar.</p>\n</blockquote>\n<p>Is the actual term produced by <code>refine</code> considered part of <code>refine</code>'s public interface, or does the public interface only include what subgoals goals it generates?</p>",
        "id": 524092472,
        "sender_full_name": "Niels Voss",
        "timestamp": 1749942533
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/113488-general/topic/When.20is.20it.20acceptable.20to.20use.20tactics.20outside.20of.20theorems.3F/near/524092348\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span>, that's certainly the fear. Either way, \"are never unfolded\" is definitely wrong in your statement, so I encourage you to replace it with a new one about \"Eq.mpr doesn't actually matter\" if you can convince yourself this is true.</p>\n</blockquote>\n<p>I have strucken out \\#2</p>",
        "id": 524092473,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749942535
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"521331\">Niels Voss</span> <a href=\"#narrow/channel/113488-general/topic/When.20is.20it.20acceptable.20to.20use.20tactics.20outside.20of.20theorems.3F/near/524092406\">said</a>:</p>\n<blockquote>\n<p>They need to be <code>def</code>s in certain rare situations, because <code>theorem</code> is kind of like <code>opaque</code> and prevents you from unfolding them.</p>\n</blockquote>\n<p>I wonder with the recent changes to well-founded recursion if this is actually still something that matters.</p>",
        "id": 524092517,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1749942607
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"521331\">Niels Voss</span> <a href=\"#narrow/channel/113488-general/topic/When.20is.20it.20acceptable.20to.20use.20tactics.20outside.20of.20theorems.3F/near/524091933\">said</a>:</p>\n<blockquote>\n<ol start=\"3\">\n<li>Use tactics to produce <em>noncomputable</em> terms of non-definitional subsingletons?</li>\n</ol>\n</blockquote>\n<p>This used to be very common as <code>by classical exact term</code>, but an alternate spelling is <code>open scoped classical in term</code> which avoids tactics.</p>",
        "id": 524092540,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1749942663
    },
    {
        "content": "<p>Personally, my rule of thumb is that you don't want anyone to have to see a 'bare' cast, i.e. <code>▸</code> or <code>_root_.cast</code> or an <code>Eq.mp</code>/<code>Eq.mpr</code>, because when you generate such with tactics you are almost always throwing away important type information without which the expanded definition cannot be reduced in the wild. </p>\n<p>I'll use tactics primarily to help me manage elaboration order and the like, so that I have to type out fewer explicit type annotations. </p>\n<p>Also, anyone checking this thread should be aware of the <code>by?</code> command, which works like <code>by</code> but then gives you a <code>Try this</code> with an attempt at producing a term equivalent to your tactic. Best used with <code>set_option pp.proofs true</code> so that it doesn't throw away proofs necessary to produce your term, and it doesn't do the same elaboration-order-manipulation that the corresponding tactics do so it doesn't <em>always</em> work, but it's a good thing to try before leaving a tactic-created-term in your final result.</p>",
        "id": 524160875,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1750028876
    },
    {
        "content": "<p>I think this isn't mentioned yet: it should be acceptable to use specific tactics to defer evaluation (usually for default parameters), such as in <code>by exact decl_name%</code>, <code>by volume_tac</code>.</p>",
        "id": 524365868,
        "sender_full_name": "Thomas Zhu",
        "timestamp": 1750131688
    },
    {
        "content": "<p>another reason to use tactics in definitions is simply for formatting reasons; I find it easier to lay out an expression with nesting in weird places using a sequence of calls to <code>refine</code> instead of working out how to do the indentation for the term mode \"proof\". But I would restrict such usage to things like <code>refine</code>, <code>apply</code>, <code>exact</code> and <code>constructor</code>, and avoid <code>rw</code>, <code>simp</code> or any other high power tactics, at least until you have reduced the goal to something in a <code>Prop</code>.</p>",
        "id": 524803152,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1750295942
    },
    {
        "content": "<p>I would say that Kenny's <a href=\"#narrow/channel/113488-general/topic/When.20is.20it.20acceptable.20to.20use.20tactics.20outside.20of.20theorems.3F/near/524092224\">example</a> is a case of this. You could certainly write <code>⟨n, by ...⟩</code> but the hanging <code>⟩</code> is just much more awkward to format if the <code>...</code> is a long proof</p>",
        "id": 524803429,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1750296345
    },
    {
        "content": "<p>Mario's point above is strong. I myself have started to push people towards the following style:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bar</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">data1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">data2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">proof1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">proof2</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">proof1</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">proof2</span>\n</code></pre></div>",
        "id": 524824369,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1750315922
    },
    {
        "content": "<p>I'd probably prefer <code>.mk n &lt;| by</code> for Kenny's example</p>",
        "id": 524866924,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1750333279
    },
    {
        "content": "<p>Or <code>where</code> notation, which also solves the trailing <code>}</code> issue</p>",
        "id": 524866966,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1750333294
    },
    {
        "content": "<p>Sorry, I meant to give an example with a non-standard constructor:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bar</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">nonStandardMk</span><span class=\"w\"> </span><span class=\"n\">data1</span><span class=\"w\"> </span><span class=\"n\">data2</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">proof1</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">proof2</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">proof1</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">proof2</span>\n</code></pre></div>",
        "id": 524867399,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1750333499
    },
    {
        "content": "<p>... the point being that <code>where</code> notation only applies to the standard constructor</p>",
        "id": 524867443,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1750333517
    },
    {
        "content": "<p>I thought Eric meant</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Itself</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">me</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">Itself</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">prf</span><span class=\"bp\">⟩</span>\n<span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"n\">prf</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"c1\">-- insert very long proof</span>\n<span class=\"w\">       </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">add_zero</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">add_comm</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 524871578,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1750334995
    },
    {
        "content": "<p>wait, u can do that?</p>",
        "id": 524875013,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750336067
    },
    {
        "content": "<p>This is where I need a list of \"lean syntax you probably don't know yet\"</p>",
        "id": 524882778,
        "sender_full_name": "Weiyi Wang",
        "timestamp": 1750338606
    },
    {
        "content": "<p>I did not mean that, but I should have</p>",
        "id": 524902834,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1750344877
    },
    {
        "content": "<p>Though I think that makes <code>prf</code> a def not a theorem, which flags the linter?</p>",
        "id": 524902865,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1750344892
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306577\">Matthew Ballard</span> <a href=\"#narrow/channel/113488-general/topic/When.20is.20it.20acceptable.20to.20use.20tactics.20outside.20of.20theorems.3F/near/524871578\">said</a>:</p>\n<blockquote>\n<p>I thought Eric meant</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Itself</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">me</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">Itself</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">prf</span><span class=\"bp\">⟩</span>\n<span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"n\">prf</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"c1\">-- insert very long proof</span>\n<span class=\"w\">       </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">add_zero</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">add_comm</span><span class=\"o\">]</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I think this will introduce a <code>me.prf</code> in the global context, which is not good I think.</p>",
        "id": 524906469,
        "sender_full_name": "Jz Pan",
        "timestamp": 1750346106
    },
    {
        "content": "<p>I've thought that named arguments were a reasonable compromise.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bar</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">.</span><span class=\"n\">nonStandardMk</span><span class=\"w\"> </span><span class=\"n\">data1</span><span class=\"w\"> </span><span class=\"n\">data2</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">commociative</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"n\">tac1</span>\n<span class=\"w\">      </span><span class=\"n\">tac2</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">ramitated</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"n\">tac1</span>\n<span class=\"w\">      </span><span class=\"n\">tac2</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>It's not as sleek as <code>where</code> for structures, but to me it seems more structured than using <code>refine</code>.</p>",
        "id": 524906659,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750346176
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/113488-general/topic/When.20is.20it.20acceptable.20to.20use.20tactics.20outside.20of.20theorems.3F/near/524902865\">said</a>:</p>\n<blockquote>\n<p>Though I think that makes <code>prf</code> a def not a theorem, which flags the linter?</p>\n</blockquote>\n<p><code>whatsnew</code> reports <code>theorem me.prf</code></p>",
        "id": 524914988,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1750349183
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"366779\">Jz Pan</span> <a href=\"#narrow/channel/113488-general/topic/When.20is.20it.20acceptable.20to.20use.20tactics.20outside.20of.20theorems.3F/near/524906469\">said</a>:</p>\n<blockquote>\n<p>I think this will introduce a <code>me.prf</code> in the global context, which is not good I think.</p>\n</blockquote>\n<p>Actually this might help avoid unfolding the proofs.</p>",
        "id": 524915196,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1750349261
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/113488-general/topic/When.20is.20it.20acceptable.20to.20use.20tactics.20outside.20of.20theorems.3F/near/524875013\">said</a>:</p>\n<blockquote>\n<p>wait, u can do that?</p>\n</blockquote>\n<p>Yes, but <code>where</code> has limitations compared to <code>refine</code>.</p>",
        "id": 524915276,
        "sender_full_name": "suhr",
        "timestamp": 1750349285
    },
    {
        "content": "<p>Given all the discussion above, is there a consensus on whether:</p>\n<ol>\n<li>The terms generated by <code>exact</code>, <code>refine</code>, <code>construct</code>, <code>intro</code>, <code>let</code>, and <code>apply</code> is to be considered part of the tactic's public interface?</li>\n<li>The terms generated by advanced tactics like <code>rw</code>, <code>simp</code>, and <code>aesop</code> are considered part of the tactic's public interface?</li>\n</ol>\n<p>It seems to me that the answer to 1. is yes and 2. is no, but where do we draw the line between \"simple\" and \"complex\" tactics?</p>",
        "id": 524923442,
        "sender_full_name": "Niels Voss",
        "timestamp": 1750352872
    },
    {
        "content": "<p>I think it's just that some tactics are \"term\" tactics:</p>\n<ul>\n<li><code>exact</code> and <code>refine</code> literally produce exactly what you give it with maybe some subgoals (emulating</li>\n<li><code>apply</code> is basically function application</li>\n<li><code>constructor</code> is also function application or, well, structure instance notation</li>\n<li><code>intro</code> is basically lambda abstraction</li>\n<li><code>let</code> and <code>have</code> are, well, <code>let</code> and <code>have</code></li>\n<li><code>by_cases</code> is if-then-else</li>\n<li><code>match</code> is a <code>match</code> expression</li>\n<li><code>induction</code> is recursor application</li>\n<li><code>infer_instance</code> is <code>inferInstance</code></li>\n<li><code>sorry</code> is <code>sorry</code></li>\n</ul>\n<p>Other tactics are more trying to do something specific to goal (e.g. solve it or rewrite something) instead of being tied to a term and should therefore be avoided for definitions.</p>",
        "id": 524929497,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1750356123
    },
    {
        "content": "<p>I worry about saying that <em>any</em> tactic has any guarantee about what terms they produce.</p>\n<p>For example, <code>intro</code> also has a feature to do pattern matching. It's currently implemented with a <code>match</code> term, but is that in the interface? What if <code>intro</code> gains <code>rfl</code> patterns? Then that means <code>intro</code> can effectively wrap terms in rewrites, which is one of the main goals of avoiding <code>rw</code> and <code>simp</code>.</p>\n<p>The <code>induction</code> tactic does make use of the recursor, but maybe one day it will have some capacity for dependent elimination like <code>cases</code>, which people periodically ask for? That introduces rewrites. Furthermore, using <code>induction</code> means your definition won't have equation lemmas for each induction case.</p>\n<p>The <code>by_cases</code> is if-then-else, but it's free to pull in <code>Classical</code>. Even the <code>if _ then _ else _</code> tactic will do this.</p>\n<p>That all said, it's hard to imagine that <code>exact</code>/<code>refine</code>/<code>apply</code> will ever do anything except use the term you provide it. (I've been kicking around an idea to make <code>apply t</code> be something like <code>refine apply% t</code>, so that it's even more nothing out of the ordinary.)</p>\n<p>I'm focusing on rewrites here because those are what tend to make tactic-defined definitions fail to have good definitional equality properties.</p>",
        "id": 524931470,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750357217
    }
]