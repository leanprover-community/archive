[
    {
        "content": "<p>I wrote the following proof (in <a href=\"https://github.com/YaelDillies/Toric/blob/be838b226bb00b97bbde4a75c99d2e07fd56fec3/Toric/GroupScheme/YonedaCommMon.lean\">https://github.com/YaelDillies/Toric/blob/be838b226bb00b97bbde4a75c99d2e07fd56fec3/Toric/GroupScheme/YonedaCommMon.lean</a>)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Monoidal</span><span class=\"bp\">.</span><span class=\"n\">Yoneda</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Monoidal</span><span class=\"bp\">.</span><span class=\"n\">CommMon_</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"w\"> </span><span class=\"n\">ChosenFiniteProducts</span><span class=\"w\"> </span><span class=\"n\">MonoidalCategory</span><span class=\"w\"> </span><span class=\"n\">Mon_Class</span><span class=\"w\"> </span><span class=\"n\">Opposite</span>\n\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">u</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ChosenFiniteProducts</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">IsCommMon</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Mon_Class</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">mul_comm'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β_</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">aesop_cat</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">IsCommMon</span><span class=\"bp\">.</span><span class=\"n\">ofRepresentableBy</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"bp\">ᵒᵖ</span><span class=\"w\"> </span><span class=\"bp\">⥤</span><span class=\"w\"> </span><span class=\"n\">CommMonCat</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">})</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">⋙</span><span class=\"w\"> </span><span class=\"n\">forget</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">RepresentableBy</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">letI</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Mon_ClassOfRepresentableBy</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">⋙</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">forget₂</span><span class=\"w\"> </span><span class=\"n\">CommMonCat</span><span class=\"w\"> </span><span class=\"n\">MonCat</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">    </span><span class=\"n\">IsCommMon</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">letI</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Mon_ClassOfRepresentableBy</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">⋙</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">forget₂</span><span class=\"w\"> </span><span class=\"n\">CommMonCat</span><span class=\"w\"> </span><span class=\"n\">MonCat</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"bp\">⟨?_⟩</span>\n<span class=\"w\">  </span><span class=\"n\">change</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"bp\">.</span><span class=\"n\">homEquiv</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"bp\">.</span><span class=\"n\">homEquiv</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"bp\">.</span><span class=\"n\">homEquiv</span><span class=\"bp\">.</span><span class=\"n\">injective</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">α</span><span class=\"bp\">.</span><span class=\"n\">homEquiv_comp</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">apply_symm_apply</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">comp_map</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ConcreteCategory</span><span class=\"bp\">.</span><span class=\"n\">forget_map_eq_coe</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">map_mul</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">ConcreteCategory</span><span class=\"bp\">.</span><span class=\"n\">forget_map_eq_coe</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">comp_map</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">erw?</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"bp\">.</span><span class=\"n\">homEquiv_comp</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Currently the erw can't be replaced because <code>(F ⋙ forget CommMonCat)</code> and <code>((F ⋙ forget₂ CommMonCat MonCat) ⋙ forget MonCat)</code> are not syntactically equal. Is there a good way to systematically deal with this?</p>",
        "id": 503521920,
        "sender_full_name": "Michał Mrugała",
        "timestamp": 1741182902
    },
    {
        "content": "<p>Can you make this a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> ?</p>",
        "id": 503524885,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1741183525
    },
    {
        "content": "<p>Changed the original message to a mwe</p>",
        "id": 503540959,
        "sender_full_name": "Michał Mrugała",
        "timestamp": 1741186856
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span>  (<span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span>'s suggestion)</p>",
        "id": 503600571,
        "sender_full_name": "Michał Mrugała",
        "timestamp": 1741199582
    },
    {
        "content": "<p>Equality of functors is evil so the principled way to do it would be to write down the natural isomorphism I guess :-/</p>",
        "id": 503600896,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1741199669
    },
    {
        "content": "<p>Thanks for the CC! I'm not sure if there is currently an easy way to solve this. But I'm away from the computer for a couple hours so can't test it...</p>",
        "id": 503601014,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1741199701
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113488-general/topic/Getting.20rid.20of.20erw/near/503600896\">said</a>:</p>\n<blockquote>\n<p>Equality of functors is evil so the principled way to do it would be to write down the natural isomorphism I guess :-/</p>\n</blockquote>\n<p>They are defeq, but rw isn't smart enough to see through it.</p>",
        "id": 503601165,
        "sender_full_name": "Michał Mrugała",
        "timestamp": 1741199738
    },
    {
        "content": "<p>Yes that's what <code>erw</code> does, there are various levels of defeq and <code>erw</code> blasts through more. You used <code>change</code> before, you could just use it again. But you might want to ask how you ended up needing equality of functors in the first place.</p>",
        "id": 503601615,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1741199846
    },
    {
        "content": "<p>If you just write the whole goal instead of including holes in <code>change</code> then it will work.<br>\n(i.e. <code>change (β_ X X).hom ≫ α.homEquiv.symm (α.homEquiv (fst X X) * α.homEquiv (snd X X)) = α.homEquiv.symm (α.homEquiv (fst X X) * α.homEquiv (snd X X))</code>)</p>",
        "id": 503647941,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1741213901
    },
    {
        "content": "<p>Thanks this works! I still don't fully understand this fix though.</p>",
        "id": 503649074,
        "sender_full_name": "Michał Mrugała",
        "timestamp": 1741214313
    },
    {
        "content": "<p><code>change X</code> just checks that the goal is defeq to X and then changes the goal to X and proves this is valid with rfl</p>",
        "id": 503655070,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1741216914
    },
    {
        "content": "<p>So it's a very powerful way to do arbitrary definitional rewrites in the goal.</p>",
        "id": 503655154,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1741216947
    },
    {
        "content": "<p>What confuses me in this case is that the part we need to change (forgetful functor vs composition of forgetful functors) is not mentioned explicitly anywhere when using <code>change</code>. I don't know how lean makes the choice.</p>",
        "id": 503660516,
        "sender_full_name": "Michał Mrugała",
        "timestamp": 1741218715
    },
    {
        "content": "<p>If X is defeq to Y then f(X) is defeq to f(Y). Is this what's confusing you?</p>",
        "id": 503665782,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1741221024
    },
    {
        "content": "<p>Lean is not making any decisions itself, if the goal is Y then Lean knows Y, and if you write <code>change X</code> then Lean knows X too, so all it has to do is to check that X and Y are defeq.</p>",
        "id": 503665882,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1741221091
    }
]