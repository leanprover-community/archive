[
    {
        "content": "<p>I'm translating the proofs in Linear Algebra Done Right into Lean. I'm looking for early feedback on example 1.4 that complex multiplication is commutative.<br>\n<a href=\"/user_uploads/3121/tPwNhm_rkYLqti6V1IpgNAd7/ComplexCommutative.jpg\">ComplexCommutative.jpg</a> </p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/tPwNhm_rkYLqti6V1IpgNAd7/ComplexCommutative.jpg\" title=\"ComplexCommutative.jpg\"><img src=\"/user_uploads/3121/tPwNhm_rkYLqti6V1IpgNAd7/ComplexCommutative.jpg\"></a></div><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.complex.basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">complex</span>\n\n<span class=\"c1\">-- 1.4 Example \"Show that αβ = βα for all α, β ∈ ℂ\"</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">*</span> <span class=\"n\">β</span> <span class=\"bp\">=</span> <span class=\"n\">β</span> <span class=\"bp\">*</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">α</span> <span class=\"k\">in</span>\n  <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">d</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">β</span> <span class=\"k\">in</span>\n  <span class=\"k\">calc</span>\n    <span class=\"o\">(</span><span class=\"n\">complex.mk</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">complex.mk</span> <span class=\"n\">c</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">d</span><span class=\"bp\">*</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mk_eq_add_mul_I</span><span class=\"o\">,</span> <span class=\"n\">mk_eq_add_mul_I</span><span class=\"o\">]</span>\n        <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">-</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">d</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"n\">ext</span><span class=\"bp\">;</span> <span class=\"n\">simp</span>\n        <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">-</span> <span class=\"n\">d</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">d</span> <span class=\"bp\">*</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"n\">ext</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">mul_comm</span><span class=\"o\">,</span> <span class=\"n\">add_comm</span><span class=\"o\">]</span>\n        <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">complex.mk</span> <span class=\"n\">c</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">complex.mk</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">ext</span><span class=\"bp\">;</span> <span class=\"n\">simp</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>Is this the style that is expected?  Any suggestions or improvements?</p>",
        "id": 343208474,
        "sender_full_name": "Martin C. Martin",
        "timestamp": 1679340222
    },
    {
        "content": "<p>Here's a simpler proof <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">*</span> <span class=\"n\">β</span> <span class=\"bp\">=</span> <span class=\"n\">β</span> <span class=\"bp\">*</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">mul_comm</span> <span class=\"n\">α</span> <span class=\"n\">β</span>\n</code></pre></div>\n<p>Or</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">*</span> <span class=\"n\">β</span> <span class=\"bp\">=</span> <span class=\"n\">β</span> <span class=\"bp\">*</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">ring</span>\n</code></pre></div>\n<p>What's the right sort of proof depends on what you're trying to do here.  I guess one comment I'd give is that using <code>let</code> to destruct arguments like that isn't so common (and I'm not actually sure there's any guarantee there's any relationship between <code>a, b, c, d</code> and <code>α, β</code> in general.</p>",
        "id": 343211491,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1679341208
    },
    {
        "content": "<p>If you want to compare to mathlib's proof, it's essentially</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">*</span> <span class=\"n\">β</span> <span class=\"bp\">=</span> <span class=\"n\">β</span> <span class=\"bp\">*</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n    <span class=\"n\">ring</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n    <span class=\"n\">ring</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>or <code>by ext; simp; ring</code> for short. I extracted this from the commutative ring instance for the complex numbers <a href=\"https://github.com/leanprover-community/mathlib/blob/290a7ba01fbcab1b64757bdaa270d28f4dcede35/src/data/complex/basic.lean#L205\">https://github.com/leanprover-community/mathlib/blob/290a7ba01fbcab1b64757bdaa270d28f4dcede35/src/data/complex/basic.lean#L205</a></p>",
        "id": 343212045,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1679341393
    },
    {
        "content": "<p>If you like your style with an explicit calculation, you can consider the following version, which handles destructuring in a way that should be more reliable</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">*</span> <span class=\"n\">β</span> <span class=\"bp\">=</span> <span class=\"n\">β</span> <span class=\"bp\">*</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">α</span><span class=\"o\">,</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">d</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">β</span><span class=\"o\">,</span>\n  <span class=\"k\">calc</span>\n    <span class=\"o\">(</span><span class=\"n\">complex.mk</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">complex.mk</span> <span class=\"n\">c</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">d</span><span class=\"bp\">*</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mk_eq_add_mul_I</span><span class=\"o\">,</span> <span class=\"n\">mk_eq_add_mul_I</span><span class=\"o\">]</span>\n        <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">-</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">d</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"n\">ext</span><span class=\"bp\">;</span> <span class=\"n\">simp</span>\n        <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">-</span> <span class=\"n\">d</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">d</span> <span class=\"bp\">*</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"n\">ext</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">mul_comm</span><span class=\"o\">,</span> <span class=\"n\">add_comm</span><span class=\"o\">]</span>\n        <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">complex.mk</span> <span class=\"n\">c</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">complex.mk</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">ext</span><span class=\"bp\">;</span> <span class=\"n\">simp</span><span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 343212658,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1679341578
    },
    {
        "content": "<p>The goal is a good question.  I'm trying to translate the proof in the book, which I put in the image, into Lean as directly as possible.  The proof in the book is aimed at people who are rusty with manipulating complex numbers, and so explicitly writes out alpha as (a+bi), etc.</p>\n<p>As I understand it, the goal of translating a textbook into Lean is to be a kind of Rosetta stone; for people who know the textbook but not Lean, it lets them see how something familiar can be translated into Lean.</p>\n<p>If that's the goal, what's the write way to translate the snippet in the JPEG above?</p>",
        "id": 343213284,
        "sender_full_name": "Martin C. Martin",
        "timestamp": 1679341801
    },
    {
        "content": "<p>I think the \"right\" translation, that shows how you'd normally prove this, is this proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">*</span> <span class=\"n\">β</span> <span class=\"bp\">=</span> <span class=\"n\">β</span> <span class=\"bp\">*</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n    <span class=\"n\">ring</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n    <span class=\"n\">ring</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 343213604,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1679341903
    },
    {
        "content": "<p>It's not exactly the same, but it has the same spirit. You have to step through it with an IDE to understand the proof though, but that's like most Lean proofs.</p>\n<p>You could be more specific with which lemmas are being used by <code>simp</code> if you want (using <code>squeeze_simp</code> to obtain them).</p>",
        "id": 343213901,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1679341989
    },
    {
        "content": "<p>The main difference is that the original proof says \"to show two complex numbers are the same, we can represent everything in sight in rectangular coordinates and do some algebraic manipulations\" and this one says \"to show two complex numbers are the same, we can compare the real and imaginary parts separately\"</p>",
        "id": 343214185,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1679342093
    },
    {
        "content": "<p>Re rosetta's stone, it'd be nice to also have <code>by ring</code> or  <code>mul_comm α β</code>, since that's pointing out how you'd make use of commutativity in practice.</p>",
        "id": 343214967,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1679342348
    },
    {
        "content": "<p>For what it's worth, I define the complex numbers and prove that they are a ring in the first level of the complex number game here <a href=\"https://github.com/ImperialCollegeLondon/complex-number-game/blob/master/src/complex/Level_00_basic.lean\">https://github.com/ImperialCollegeLondon/complex-number-game/blob/master/src/complex/Level_00_basic.lean</a></p>",
        "id": 343240092,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1679352143
    },
    {
        "content": "<p>If you want to use <code>calc</code> here then the right approach is to first prove an induction principle for <code>complex</code> saying that you can check things on complex numbers of the form <code>a + b * I</code>. Then use it twice to reduce to the middle part of your calculation.</p>",
        "id": 343271050,
        "sender_full_name": "Reid Barton",
        "timestamp": 1679371900
    },
    {
        "content": "<p>So it seems the preferred approach for a \"Rosetta Stone\" translation of a textbook, following Kevin's complex number game, as well as TPIL and MIL, is to define concepts we need, like complex number, vector, linear map, matrix, etc.  The prove basic properties of them.  Once that's done, we can retire our custom definitions and use the mathlib definitions.  Sound good?</p>",
        "id": 343336438,
        "sender_full_name": "Martin C. Martin",
        "timestamp": 1679396386
    },
    {
        "content": "<blockquote>\n<p>a \"Rosetta Stone\" translation of a textbook</p>\n</blockquote>\n<p>I think there are two different interpretations of this; do you want a rosetta stone for proof strategies, or just for mathematical results?</p>",
        "id": 343337703,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1679396752
    },
    {
        "content": "<p>The second approach would just be <code>example {α β : ℂ} : α * β = β * α := mul_comm α β</code></p>",
        "id": 343338028,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1679396852
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/Linear.20Algebra.20Done.20Right.2C.20Complex.20mul_comm/near/343337703\">said</a>:</p>\n<blockquote>\n<p>do you want a rosetta stone for proof strategies, or just for mathematical results?</p>\n</blockquote>\n<p>This is really a question for this community.  For context, I want to contribute something, and someday contribute to mathlib.  As a first project, it <a href=\"#narrow/stream/113489-new-members/topic/What.20should.20I.20contribute.20to.20mathlib.3F\">was suggested</a> that I translate Axler's book.  So what would the community find most useful?</p>\n<p>Personally, the second approach seems less useful. Just naming the existing result doesn't really show the reader how they might prove something that isn't already in mathlib.  But I'll wait for others to chime in.</p>",
        "id": 343342848,
        "sender_full_name": "Martin C. Martin",
        "timestamp": 1679398157
    },
    {
        "content": "<p>I've been using the second approach <a href=\"https://github.com/eric-wieser/lean-matrix-cookbook\">here</a> as a means to spotting gaps in mathlib. But certainly that's not a real textbook, so a different approach for Axler is totally reasonable.</p>",
        "id": 343343284,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1679398289
    },
    {
        "content": "<p>When faced with a choice between two valid approaches, why not choose both? You can show a calc style proof that doesn't rely on any instances on the complexes, and right below it, an example with an \"idiomatic\" proof relying on the comm_ring complex instance.</p>",
        "id": 343343371,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1679398314
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"348963\">@Martin C. Martin</span> \"build then throw away\" was my conclusion too. For example, I make the naturals in the natural number game, when making the integers from the naturals I switch to Lean's naturals because all the infrastructure is already there. You can see how long it takes to make infrastructure in lean: for example it takes ages to get a working theory of &lt;= in the natural number game, and in the complex number game I have to spend a lot of time setting up extensionality lemmas, proving basic simp lemmas with refl etc. It takes a huge amount of time to make a robust object in lean and it's rather tedious, especially when many of the proofs are just refl and you have to make simp work. This is not really mathematics. So I definitely agree with you -- assume built in stuff, define new stuff yourself (groups are a great example, I make them in the group theory game) and then immediately throw them away in the next chapter and use Lean's inbuilt version.</p>",
        "id": 343348019,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1679399625
    },
    {
        "content": "<p>I've made the naturals, integers, groups, filters, and the complexes all \"from scratch\" and in each case I mean \"using lean's version of everything I need even if I've made it myself before\"</p>",
        "id": 343348432,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1679399739
    },
    {
        "content": "<p>You're welcome to use any of this stuff or be inspired by it and I don't need credit.</p>",
        "id": 343348607,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1679399783
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> .  I'm trying something along those lines.  I thought I'd give it a try without <code>ext</code> for a simple case, but I'm struggling with how to apply the definition of multiplication, or coercion, here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">complex</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">re</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">im</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">notation</span> <span class=\"bp\">`</span><span class=\"n\">ℂ</span><span class=\"bp\">`</span> <span class=\"o\">:=</span> <span class=\"n\">complex</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">complex</span>\n\n<span class=\"sd\">/-- The imaginary unit. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">⟩</span>\n\n<span class=\"c1\">-- if a ∈ ℝ, we identify a + 0I with the real number a.</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe</span> <span class=\"n\">ℝ</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">⟩⟩</span>\n\n<span class=\"c1\">-- instance : has_add ℂ := ⟨λ z w, ⟨z.re + w.re, z.im + w.im⟩⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mul</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">z.re</span> <span class=\"bp\">*</span> <span class=\"n\">w.re</span> <span class=\"bp\">-</span> <span class=\"n\">z.im</span> <span class=\"bp\">*</span> <span class=\"n\">w.im</span><span class=\"o\">,</span> <span class=\"n\">z.re</span> <span class=\"bp\">*</span> <span class=\"n\">w.im</span> <span class=\"bp\">+</span> <span class=\"n\">z.im</span> <span class=\"bp\">*</span> <span class=\"n\">w.re</span><span class=\"o\">⟩</span>\n<span class=\"c1\">-- Notation '*' for multiplication.</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_mul</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">mul</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">I_mul_I</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">*</span> <span class=\"n\">I</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">I</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">I</span><span class=\"o\">,</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>I tried <code>rw mul</code>, <code>simp</code> and <code>refl</code> in place of <code>sorry</code>, but nothing works.  How can I get it to rewrite using <code>mul</code>, and expand the coercion on the RHS?</p>",
        "id": 343467756,
        "sender_full_name": "Martin C. Martin",
        "timestamp": 1679417455
    },
    {
        "content": "<p>You can first add a lemma</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">mul_def</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">z</span> <span class=\"bp\">*</span> <span class=\"n\">w</span> <span class=\"bp\">=</span> <span class=\"o\">⟨</span><span class=\"n\">z.re</span> <span class=\"bp\">*</span> <span class=\"n\">w.re</span> <span class=\"bp\">-</span> <span class=\"n\">z.im</span> <span class=\"bp\">*</span> <span class=\"n\">w.im</span><span class=\"o\">,</span> <span class=\"n\">z.re</span> <span class=\"bp\">*</span> <span class=\"n\">w.im</span> <span class=\"bp\">+</span> <span class=\"n\">z.im</span> <span class=\"bp\">*</span> <span class=\"n\">w.re</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>and then <code>rw [mul_def]</code> in <code>I_mul_I</code></p>",
        "id": 343468232,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1679417556
    },
    {
        "content": "<p>Thanks!  Although looking closer, <code>cases I,</code> isn't doing what I thought.  <code>I</code> is replaced with <code>{re := re, im := im}</code>, I don't know where the 0 and 1 went.</p>",
        "id": 343471493,
        "sender_full_name": "Martin C. Martin",
        "timestamp": 1679418358
    },
    {
        "content": "<p>You want <code>rw I</code> not <code>cases I</code></p>",
        "id": 343472314,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1679418548
    },
    {
        "content": "<p><code>cases h : I</code> prevents lean forgetting the details too, but that's not very useful to you here</p>",
        "id": 343472458,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1679418589
    },
    {
        "content": "<p>You saw that I have an entire sheet on <code>I</code> right? The reason <code>simp</code> isn't doing anything for you is because you have made a new structure now you have to train the simplifier on how to work with it. Hence the gazillion simp lemmas in the first sheet, all of which are imported in the second sheet where we deal with I</p>",
        "id": 343489606,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1679423132
    },
    {
        "content": "<p>This is exactly why it's a PITA to make new mathematical objects from first principles -- <code>simp</code> won't work until you've made all the simp lemmas, <code>ring</code> won't work until you've proved all the ring axioms etc etc</p>",
        "id": 343489827,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1679423200
    },
    {
        "content": "<p>You're working with <code>I</code> but I proved a gazillion boring things before I even started on <code>I</code></p>",
        "id": 343490063,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1679423269
    },
    {
        "content": "<p>Thanks again <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> .  I was more wondering how to invoke the definition of a <code>has_mul</code>, I thought there might be some way to do it without having to have a parallel theorem like <code>mul_def</code>.  I was hoping <code>refl</code> or <code>dsimp</code> would expand it, or maybe <code>rw (*)</code>.  I noticed in your complex numbers game, you define the function <code>mul</code>, although now that I look, you only ever use it in the definition of <code>has_mul</code>.</p>\n<p>mathlib doesn't have a separate <code>mul_def</code> that it gives to the simplifier, but I think it just breaks everything into real and imaginary parts and goes from there.  Which makes sense, it's a great way to leverage existing abilities on N, Z, and R.</p>",
        "id": 343493306,
        "sender_full_name": "Martin C. Martin",
        "timestamp": 1679424273
    },
    {
        "content": "<p><code>dsimp [(*)]</code> usually works</p>",
        "id": 343494176,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1679424550
    },
    {
        "content": "<p>But that's rarely useful, since it unfolds all the multiplications, not just the one you wanted</p>",
        "id": 343494223,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1679424563
    },
    {
        "content": "<p>I define <code>mul</code> and then I define <code>has_mul</code> and then I prove lots of API about <code>*</code>, which is the \"canonical form\" or \"simp normal form\" for <code>mul</code>.</p>",
        "id": 343501422,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1679426814
    },
    {
        "content": "<p>It's interesting that mathlib doesn't have <code>mul_def</code>, but instead separate theorems for the real and imaginary parts:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">mul_re</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"bp\">*</span> <span class=\"n\">w</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"bp\">=</span> <span class=\"n\">z.re</span> <span class=\"bp\">*</span> <span class=\"n\">w.re</span> <span class=\"bp\">-</span> <span class=\"n\">z.im</span> <span class=\"bp\">*</span> <span class=\"n\">w.im</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">mul_im</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"bp\">*</span> <span class=\"n\">w</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">im</span> <span class=\"bp\">=</span> <span class=\"n\">z.re</span> <span class=\"bp\">*</span> <span class=\"n\">w.im</span> <span class=\"bp\">+</span> <span class=\"n\">z.im</span> <span class=\"bp\">*</span> <span class=\"n\">w.re</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 343762484,
        "sender_full_name": "Martin C. Martin",
        "timestamp": 1679511663
    },
    {
        "content": "<p>Mathlib has decreed that <code>complex.mk</code> is unmathematical, and therefore that basically no lemmas should exist about it</p>",
        "id": 343762603,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1679511706
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"348963\">Martin C. Martin</span> <a href=\"#narrow/stream/113488-general/topic/Linear.20Algebra.20Done.20Right.2C.20Complex.20mul_comm/near/343208474\">said</a>:</p>\n<blockquote>\n<p>I'm translating the proofs in Linear Algebra Done Right into Lean. I'm looking for early feedback on example 1.4 that complex multiplication is commutative.<br>\n<a href=\"/user_uploads/3121/tPwNhm_rkYLqti6V1IpgNAd7/ComplexCommutative.jpg\">ComplexCommutative.jpg</a> </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.complex.basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">complex</span>\n\n<span class=\"c1\">-- 1.4 Example \"Show that αβ = βα for all α, β ∈ ℂ\"</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">*</span> <span class=\"n\">β</span> <span class=\"bp\">=</span> <span class=\"n\">β</span> <span class=\"bp\">*</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">α</span> <span class=\"k\">in</span>\n  <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">d</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">β</span> <span class=\"k\">in</span>\n  <span class=\"k\">calc</span>\n    <span class=\"o\">(</span><span class=\"n\">complex.mk</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">complex.mk</span> <span class=\"n\">c</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">d</span><span class=\"bp\">*</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mk_eq_add_mul_I</span><span class=\"o\">,</span> <span class=\"n\">mk_eq_add_mul_I</span><span class=\"o\">]</span>\n        <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">-</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">d</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"n\">ext</span><span class=\"bp\">;</span> <span class=\"n\">simp</span>\n        <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">-</span> <span class=\"n\">d</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">d</span> <span class=\"bp\">*</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"n\">ext</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">mul_comm</span><span class=\"o\">,</span> <span class=\"n\">add_comm</span><span class=\"o\">]</span>\n        <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">complex.mk</span> <span class=\"n\">c</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">complex.mk</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">ext</span><span class=\"bp\">;</span> <span class=\"n\">simp</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>Is this the style that is expected?  Any suggestions or improvements?</p>\n</blockquote>\n<p>The proof that's wanted is that scalar multiplication on a vector space is commutative, right?</p>",
        "id": 343805245,
        "sender_full_name": "Arien Malec",
        "timestamp": 1679528651
    },
    {
        "content": "<p>I don't have the same edition, but in the edition I have the field axioms are taken for granted, and our interest is in proofs of the properties of vector spaces.</p>",
        "id": 343805519,
        "sender_full_name": "Arien Malec",
        "timestamp": 1679528810
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"542196\">Arien Malec</span> <a href=\"#narrow/stream/113488-general/topic/Linear.20Algebra.20Done.20Right.2C.20Complex.20mul_comm/near/343805245\">said</a>:</p>\n<blockquote>\n<p>The proof that's wanted is that scalar multiplication on a vector space is commutative, right?</p>\n</blockquote>\n<p>It's actually the commutativity of complex multiplication</p>",
        "id": 343805734,
        "sender_full_name": "Pedro Sánchez Terraf",
        "timestamp": 1679528913
    },
    {
        "content": "<p>I think 3rd ed goes a bit slower than 2nd ed :-) It's confusing, because it's also given as an axiom...</p>",
        "id": 343806174,
        "sender_full_name": "Arien Malec",
        "timestamp": 1679529198
    },
    {
        "content": "<p>I take that back -- in 2nd ed Axler has us use the definition of complex numbers of the reals to re-prove field axioms, so yeah, all of <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> CNG.</p>\n<p>Again, the basic pedagogical issue with recapitulating proofs in Mathlib is that it's hard to get just the axioms you want, without all the machinery that you need to prove. In addition, in Linear Algebra, rather than vector spaces over fields (which Axler uses to simplify) we need to build machinery for Modules &amp; Submodules if we want to actually use Mathlib later on...</p>",
        "id": 343807093,
        "sender_full_name": "Arien Malec",
        "timestamp": 1679529807
    },
    {
        "content": "<p>Which I suspect is confusing for the intended audience....</p>",
        "id": 343807297,
        "sender_full_name": "Arien Malec",
        "timestamp": 1679529924
    },
    {
        "content": "<p>I suspect that building the machinery for even the first chapter ad hoc before replacing it with Mathlib is going to be a major chore, since we want modules &amp; submodules &amp; the fields they are defined over and sums and direct sums, each of which have a bunch of Mathlib machinery behind it....</p>",
        "id": 343808584,
        "sender_full_name": "Arien Malec",
        "timestamp": 1679531040
    },
    {
        "content": "<p>A vision I have for a mathlib-formalized textbook is that you avoid all these issues by <em>not</em> defining anything from scratch. When something new is defined in the textbook, you explain how to write down that concept in Lean (potentially with some auxiliary definitions if the concept doesn't match up perfectly), and then for proofs you use pre-existing mathlib proofs as much as possible. The purpose of this exercise would be to show someone who already knows the math what the mathlib equivalent is.</p>",
        "id": 343808820,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1679531229
    },
    {
        "content": "<p>cf <a href=\"https://github.com/leanprover-community/mathlib/pull/13911\">#13911</a> (and perhaps someone could hit merge?)</p>",
        "id": 343808959,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1679531349
    },
    {
        "content": "<p>Every time I think about this, I'm impressed by how much work went into Mathlib in the first place, as well as how well done NNG and CNG are (thanks <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> )...</p>",
        "id": 343809329,
        "sender_full_name": "Arien Malec",
        "timestamp": 1679531665
    },
    {
        "content": "<p>What's the basic Mathlib machinery for something like:</p>\n<p>\"Is the set of all vectors ${(x_1, x_2, x_3, x_4)} \\in F^4 | x_1 + 2x_2 + 3x_4 = 0}$ a subspace of F^4\"</p>",
        "id": 343810688,
        "sender_full_name": "Arien Malec",
        "timestamp": 1679532842
    },
    {
        "content": "<p>I'd translate that into \"is it true that there exists a subspace W of F^4 such that W = ... that set ...\", where there's a coercion to <code>Set</code> here for <code>W</code>.</p>",
        "id": 343810817,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1679532945
    },
    {
        "content": "<p>Which I'd show by constructing a <code>submodule</code> and showing in the construction the three required proofs?</p>",
        "id": 343811079,
        "sender_full_name": "Arien Malec",
        "timestamp": 1679533128
    },
    {
        "content": "<p>For this problem, I'd use the fact it's a kernel of a linear map, so no need for the three proofs.</p>",
        "id": 343811129,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1679533172
    },
    {
        "content": "<p>But, yeah, you could also give a construction using the <code>submodule</code> constructor too.</p>",
        "id": 343811172,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1679533204
    },
    {
        "content": "<p>We haven't gotten to null spaces yet though :-)</p>",
        "id": 343811198,
        "sender_full_name": "Arien Malec",
        "timestamp": 1679533210
    },
    {
        "content": "<p>Could you also skip to talking about <code>span</code> and ask whether <code>coe (span S) = S</code>?</p>",
        "id": 343811271,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1679533312
    },
    {
        "content": "<p>Span, linear independence, basis and dimension are all chapter 2.</p>",
        "id": 343814120,
        "sender_full_name": "Arien Malec",
        "timestamp": 1679535992
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113488-general/topic/Linear.20Algebra.20Done.20Right.2C.20Complex.20mul_comm/near/343808820\">said</a>:</p>\n<blockquote>\n<p>When something new is defined in the textbook, you explain how to write down that concept in Lean ..., and then for proofs you use pre-existing mathlib proofs as much as possible. The purpose of this exercise would be to show someone who already knows the math what the mathlib equivalent is.</p>\n</blockquote>\n<p>By \"use pre-existing mathlib proofs\", do you mean just invoking the existing mathlib theorem, e.g. <code>:= mul_comm z w</code>, or do you mean copying the mathlib proof into the formalized textbook, so they can see how these things are proven?</p>\n<p>I can see it either way.  The first way is a kind of index into mathlib theorems.  The second way shows how to do proofs in this area.</p>",
        "id": 343944361,
        "sender_full_name": "Martin C. Martin",
        "timestamp": 1679570203
    },
    {
        "content": "<p>With <code> has_coe ℝ ℂ</code> and an <code>@[simp]</code> lemma, <code>example : ( (5 : ℝ) : ℂ).re = 5 := by simp</code> works just fine.  But to get <code>example : ( 5 : ℂ).re = 5 := by simp</code> working, I need <code>@[simp] lemma bit0_re (z : ℂ) : (bit0 z).re = bit0 z.re</code> and similarly for <code>bit1</code>.  What are these, and what do they have to do with coercing ℕ  to ℂ?  Also, presumably there's already a coercion from  ℕ to ℝ, I guess Lean/mathlib doesn't automatically compose that with my shiny new <code>has_coe ℝ ℂ</code> to make my example work, without the <code>bit0/1</code> stuff?</p>",
        "id": 343949826,
        "sender_full_name": "Martin C. Martin",
        "timestamp": 1679571694
    },
    {
        "content": "<p>The bit things are how numerals are represented in lean 3: 5 is bit1 bit0 bit0 (if I counted right)</p>",
        "id": 343950211,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1679571816
    },
    {
        "content": "<p>And those are not enough to get, <code>example {n : ℕ} : (n  : ℂ).re = n := sorry</code> working.</p>",
        "id": 343950388,
        "sender_full_name": "Martin C. Martin",
        "timestamp": 1679571846
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113488-general/topic/Linear.20Algebra.20Done.20Right.2C.20Complex.20mul_comm/near/343808820\">said</a>:</p>\n<blockquote>\n<p>A vision I have for a mathlib-formalized textbook is that you avoid all these issues by <em>not</em> defining anything from scratch. </p>\n</blockquote>\n<p>That's another route I've experimented with. In my Lean UG course last year I defined e.g. groups and subgroups by rolling my own. But this year I decided to just use Lean's definitions for most things. The course material became a lot more \"overviewy\" as a result, for example the last three lectures <a href=\"https://github.com/ImperialCollegeLondon/formalising-mathematics-2023/tree/main/src/section19algebraic_number_theory\">here</a> <a href=\"https://github.com/ImperialCollegeLondon/formalising-mathematics-2023/tree/main/src/section20representation_theory\">here</a> and <a href=\"https://github.com/ImperialCollegeLondon/formalising-mathematics-2023/tree/main/src/section21galois_theory\">here</a> just ended up being overviews of algebraic number theory, representation theory and Galois theory in mathlib with essentially no proofs at all.</p>",
        "id": 344003354,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1679582945
    }
]