[
    {
        "content": "<p>Discussion thread for <a class=\"stream-topic\" data-stream-id=\"113486\" href=\"/#narrow/channel/113486-announce/topic/Lean.20Kernel.20Arena/with/568861061\">#announce &gt; Lean Kernel Arena</a></p>",
        "id": 568861124,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1768847661
    },
    {
        "content": "<p>Is it necessary to use <code>nix develop</code> to run the tests locally?</p>",
        "id": 568871004,
        "sender_full_name": "James E Hanson",
        "timestamp": 1768850958
    },
    {
        "content": "<p>No, you can install the python dependencies any other way.</p>\n<p>Or, if your goal is to test your own checkers, you can download the tarball that's linked from the front page. It contains the built tests.</p>",
        "id": 568874176,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1768851813
    },
    {
        "content": "<p>I figured out what the issue was. I needed to set <code>perf_event_paranoid</code> lower.</p>",
        "id": 568875115,
        "sender_full_name": "James E Hanson",
        "timestamp": 1768852074
    },
    {
        "content": "<p>It looks like the one false positive being reported for Nanoda is that it accepts non-propositional theorem declarations. Is this really that important from a soundness perspective? My understanding is that at the level of type checking, the difference between a definition and a theorem is essentially cosmetic.</p>",
        "id": 568875665,
        "sender_full_name": "James E Hanson",
        "timestamp": 1768852220
    },
    {
        "content": "<p>It's borderline of course - you cannot prove false with it. On the other hand it is an invariant checked by the official kernel (and also lean4lean). So in the interest of compatibility, and with not much more to rely on for a specification than the official kernel, it'd say it's probably best if checkers agree on these cosmetic things.</p>\n<p>If Chris Bailey has reasons to not implement this check I can also add a test label and opt his checker out, so that it doesn't look red. These things are still settling, hence the “under construction” label. The other red tests are also just temporary things.</p>",
        "id": 568876515,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1768852465
    },
    {
        "content": "<p>I expect we'll encounter more corner cases where it's unclear if some behavior of the official kernel is just an implementation choice, or part of the checker contract, and hopefully we'll learn something useful from them.</p>",
        "id": 568876986,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1768852598
    },
    {
        "content": "<p>I just want to say that I think this is a great effort! I've been interested in writing a checker for a while now and think this will be a helpful and motivating resource. I've also been working a bit on a somewhat \"beginner friendly\" blog post about the kernel, ZFC equiconsistency, etc. and this is great to point to as a unified location for these external checkers.</p>",
        "id": 568878879,
        "sender_full_name": "Chris Henson",
        "timestamp": 1768853124
    },
    {
        "content": "<p>I have implemented the non-propositional theorem check. Some other odds and ends I have locally for the json move are an <code>unsafe_permit_all_axioms</code> config option which was discussed elsewhere as a \"nice to have\" for this kind of application, a more harsh restriction on duplicate names, which James Hanson brought up in another thread, and a config option <code>pp_axioms</code> that defaults to true, and pretty-prints the used axioms at the end of type checking.</p>",
        "id": 568882024,
        "sender_full_name": "Chris Bailey",
        "timestamp": 1768853955
    },
    {
        "content": "<p>What is the input to these kernels?  Lean code (pre-compiled)?  oleans?  Exported proofs?  I ask, because we know some input forms are more susceptible to hacks.</p>",
        "id": 569117755,
        "sender_full_name": "Jason Rute",
        "timestamp": 1768939534
    },
    {
        "content": "<p>Also, as Comparator becomes more mature (and more needed as vibe coded proofs become common), it would be useful to make a version of this site which also focuses on the Comparator interface (with a challenge file).  Then one could add SafeVerify to the list, Comparator with different external checkers (when that is available), and lean4checker (to highlight that there are a lot of things that lean4checker doesn't check like axioms, environment hacks, and changes to the code like removing the theorem you want to prove).  Then you can also add other sorts of Lean hacks and bugs to the tests, such as all those used in the Comparator/safe verify tests, the ones <span class=\"user-mention\" data-user-id=\"904624\">@James E Hanson</span> recently uncovered (which don't effect Comparator, but do effect SafeVerify), and maybe even attempted hacks which attempt to change files on the file system.</p>",
        "id": 569119065,
        "sender_full_name": "Jason Rute",
        "timestamp": 1768939978
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"115715\">Jason Rute</span> <a href=\"#narrow/channel/113488-general/topic/Lean.20Kernel.20Arena/near/569117755\">schrieb</a>:</p>\n<blockquote>\n<p>What is the input to these kernels?  Lean code (pre-compiled)?  oleans?  Exported proofs?  I ask, because we know some input forms are more susceptible to hacks.</p>\n</blockquote>\n<p>Exported proofs, in the new JSON based format that safely encodes strings.</p>",
        "id": 569123248,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1768941466
    },
    {
        "content": "<p>For now the arena will focus on checkers. A nice safe walled garden where all you have to worry about whether a certain text file with an exported is proof is good or bad. It's only one puzzle piece in the overall story, but I think it help to keep separate concerns separate.</p>",
        "id": 569123626,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1768941608
    },
    {
        "content": "<p>I think it is very reasonable to start with exported proofs and external checkers. It seems like it would be very hard to piece apart into a similar benchmark the trust apportioned to oleans or proof export that is assumed for all but the most adversarial of input.</p>",
        "id": 569128931,
        "sender_full_name": "Chris Henson",
        "timestamp": 1768943644
    },
    {
        "content": "<p>Incidentally, why is Nanoda almost twice as fast as the Lean kernel at checking Mathlib?</p>",
        "id": 569160101,
        "sender_full_name": "James E Hanson",
        "timestamp": 1768962115
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"904624\">James E Hanson</span> <a href=\"#narrow/channel/113488-general/topic/Lean.20Kernel.20Arena/near/569160101\">said</a>:</p>\n<blockquote>\n<p>Incidentally, why is Nanoda almost twice as fast as the Lean kernel at checking Mathlib?</p>\n</blockquote>\n<p>It only has to do this one thing, so it's able to get away with more spartan data structures and memory management strategies. I think using deBruijn levels instead of unique identifiers for free variables also helps with caching in some spots but that's more speculative.</p>",
        "id": 569175774,
        "sender_full_name": "Chris Bailey",
        "timestamp": 1768974096
    },
    {
        "content": "<p>Or maybe Chris is just a great programmer :-)</p>",
        "id": 569183054,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1768978825
    },
    {
        "content": "<h1>Kernel Arena Update</h1>\n<p>Allow me to share some updates on the kernel arena at <a href=\"https://arena.lean-lang.org/\">https://arena.lean-lang.org/</a></p>\n<p>The Arena now sports 5 separate checkers:</p>\n<ul>\n<li>The official kernel (in various versions)</li>\n<li><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>’s <a href=\"https://github.com/digama0/lean4lean/\">lean4lean</a></li>\n<li><span class=\"user-mention\" data-user-id=\"228466\">@Chris Bailey</span>’s <a href=\"https://github.com/ammkrn/nanoda_lib\">nanoda</a></li>\n<li>A naive kernel implementation in Lean by me, the <a href=\"https://github.com/nomeata/lean-mini-kernel/\"><code>mini-kernel</code></a></li>\n<li>A WIP kernel in Python by <span class=\"user-mention\" data-user-id=\"321696\">@Julian Berman</span>  called <a href=\"https://github.com/Julian/rpylean/\"><code>rpylean</code></a></li>\n</ul>\n<p>The first three are serious, complete kernel implementations that correctly pass all the tests on the arena (not all at the same time, though, see below).</p>\n<p>The kernel arena also comes with a <a href=\"https://github.com/leanprover/lean-kernel-arena/blob/master/tutorial/Tutorial.lean\">the Kernel Tutorial Tests</a>, a sequence of small test inputs (both good and bad) that exercise some aspects of a checker. The idea is that if you want to write a checker and don’t know where to start, just follow these tests in sequence and expand/fix your implementation to get the next one green. I have created <a href=\"https://arena.lean-lang.org/tutorial/\">a Verso-based rendering of these tests for easy inspection</a> (<span class=\"user-mention\" data-user-id=\"321696\">@Julian Berman</span>  may currently be most interested in this).</p>\n<p>Writing these checks has already helped to uncover and fix issues in the two external checkers.</p>\n<p>The <a href=\"https://github.com/nomeata/lean-mini-kernel/\">mini kernel</a> does not support all of lean, but for the fragment it supports it should be sound. It probably isn’t, so if you enjoy breaking things, please do find the holes in this, as every hole here is a missing test case in the tutorial. If you find one, I’ll owe you a drink at the next lean event! (I know that I am not checking for duplicate declarations yet, as that is a bit tricky with the way the test files are generated. Besides that I made some implementation choices there that are “risky”, and just because I can’t exploit it yet doesn’t mean you cannot; see the README)</p>\n<p>Currently the arena runs all checkers on all tests in one go to update the page. Takes 6h (on a rather weak virtual machine). I manually run that when something interesting has changed, not on every commit, though.</p>\n<p>Two issues so far:</p>\n<ul>\n<li>\n<p>At some point I had everything on versions that lean4lean liked, but when I bumped some tests to get fixes in a proof that makes nanoda accept it, lean4lean started to stumble again (hence the “declined” tests), presumably until that Lean version gets released and lean4lean adjusted.</p>\n<p>I expect things to start to settle, though. I hope that once we have a stable release that works with all checkers, we can update at a more sensible pace (e.g. to the next stable release as soon as all checkers had time to adjust, if needed).</p>\n</li>\n<li>\n<p>The specification for external checkers is not clear. Is it simply the official kernel, including all possible incompletenesses or other strange corner case behavior? How should we treat tests where a different result is also reasonable, in some way? For example <span class=\"user-mention\" data-user-id=\"432410\">@Arthur Adjedj</span>  has <a href=\"https://github.com/leanprover/lean4/pull/12636\">proposed</a> some clean-ups to the kernel, and it would be nice to test that on the arena. One option is to somehow add a label to the test that this is testing an “alternative world”, and tally/present such tests differently.</p>\n</li>\n</ul>",
        "id": 575802318,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1772033459
    },
    {
        "content": "<p>Oh wow. That Verso page is great! I was indeed getting very tired of using my mental compiler to understand <code>bad_def</code>s already! Thank you for all your work Joachim it's been super helpful! (And to <span class=\"user-mention\" data-user-id=\"228466\">@Chris Bailey</span> and everyone of course too)</p>",
        "id": 575802858,
        "sender_full_name": "Julian Berman",
        "timestamp": 1772033590
    },
    {
        "content": "<p>Incredible! Question: IIUC the tests are JSONs exported by <code>lean4export</code>, which are the input to the checker. Is it possible to browse these JSONs in the Verso rendering, or do we call <code>lean4export</code> manually, or did I misunderstand something?</p>",
        "id": 575806750,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1772034588
    },
    {
        "content": "<p>Joachim, you only need to use <a href=\"https://github.com/leanprover-community/mathlib4/pull/35732\">#35732</a> to get more candidates for your arena!</p>",
        "id": 575820917,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1772037885
    },
    {
        "content": "<p>I wanted to mention that is appreciated that you have recently added CSLib as one of the tests. Space was limited for a short paper format, but I made sure to briefly mention it in <a href=\"https://www.arxiv.org/abs/2602.15078\">https://www.arxiv.org/abs/2602.15078</a> :)</p>",
        "id": 575824301,
        "sender_full_name": "Chris Henson",
        "timestamp": 1772038712
    },
    {
        "content": "<p>I have started working on my own checker using the new OxCaml compiler, though I think I'll be a bit slow in finding time to getting it very feature complete. I am using it as positive reinforcement for completing other work I've been procrastinating on  <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 575824350,
        "sender_full_name": "Chris Henson",
        "timestamp": 1772038725
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"933054\">Snir Broshi</span> <a href=\"#narrow/channel/113488-general/topic/Lean.20Kernel.20Arena/near/575806750\">schrieb</a>:</p>\n<blockquote>\n<p>Is it possible to browse these JSONs in the Verso rendering,</p>\n</blockquote>\n<p>That's what you are looking at, the rendering tools reads these exports.</p>",
        "id": 575827601,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1772039508
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/channel/113488-general/topic/Lean.20Kernel.20Arena/near/575820917\">schrieb</a>:</p>\n<blockquote>\n<p>Joachim, you only need to use <a href=\"https://github.com/leanprover-community/mathlib4/pull/35732\">#35732</a> to get more candidates for your arena!</p>\n</blockquote>\n<p>Once thats merged and mathlib bumped on the arena, it'll be kernels checking kernels.</p>",
        "id": 575827945,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1772039592
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/channel/113488-general/topic/Lean.20Kernel.20Arena/near/575827601\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"933054\">Snir Broshi</span> <a href=\"#narrow/channel/113488-general/topic/Lean.20Kernel.20Arena/near/575806750\">schrieb</a>:</p>\n<blockquote>\n<p>Is it possible to browse these JSONs in the Verso rendering,</p>\n</blockquote>\n<p>That's what you are looking at, the rendering tools reads these exports.</p>\n</blockquote>\n<p>But I want to see the JSONs on the website, it currently shows Lean code only</p>",
        "id": 575861442,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1772050378
    },
    {
        "content": "<p>Ah, you want raw JSON! Currently you can download <a href=\"https://arena.lean-lang.org/lean-arena-tests.tar.gz\">https://arena.lean-lang.org/lean-arena-tests.tar.gz</a>. I guess it wouldn’t be too hard to keep the json files in the web output and link them from the various places, not sure how much interest there is – once you have written your parser you likely don’t care much about the  JSON any more.</p>",
        "id": 575882781,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1772058125
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"933054\">Snir Broshi</span> <a href=\"#narrow/channel/113488-general/topic/Lean.20Kernel.20Arena/near/575806750\">said</a>:</p>\n<blockquote>\n<p>Incredible! Question: IIUC the tests are JSONs exported by <code>lean4export</code>, which are the input to the checker. Is it possible to browse these JSONs in the Verso rendering, or do we call <code>lean4export</code> manually, or did I misunderstand something?</p>\n</blockquote>\n<p>The export JSON format is not very human-readable. Every syntactic node in every expression has its own entry and entries refer to each other by number rather than by name.</p>",
        "id": 575895004,
        "sender_full_name": "James E Hanson",
        "timestamp": 1772062918
    },
    {
        "content": "<p>For example, <a href=\"https://github.com/leanprover/lean4export/blob/master/examples/Nat.add_succ.ndjson\">the exported version of <code>Nat.add_succ</code></a> is 572 lines long and I believe this essentially just contains the same information as the theorem declaration</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">defeq</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">add_succ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>and the reduced proof term</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">PUnit</span><span class=\"bp\">.</span><span class=\"n\">unit</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">n_ih</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n_ih</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n_ih</span><span class=\"bp\">⟩</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">succ</span>\n</code></pre></div>",
        "id": 575895419,
        "sender_full_name": "James E Hanson",
        "timestamp": 1772063110
    },
    {
        "content": "<p>And all declarations that are used in the transitive closure of constants</p>",
        "id": 575895501,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1772063149
    },
    {
        "content": "<p>Right, but there aren't that many for <code>Nat.add_succ</code>, right?</p>",
        "id": 575895734,
        "sender_full_name": "James E Hanson",
        "timestamp": 1772063257
    },
    {
        "content": "<p>The only user-level things I'm seeing are constants related to <code>Nat</code>, <code>Eq</code>, <code>HAdd</code>, <code>Add</code>, <code>PUnit</code>, and <code>PProd</code>.</p>",
        "id": 575896070,
        "sender_full_name": "James E Hanson",
        "timestamp": 1772063410
    },
    {
        "content": "<p>Oh I guess there's also <code>Nat</code>'s <code>Add</code> instance, <code>instAddNat</code>.</p>",
        "id": 575896290,
        "sender_full_name": "James E Hanson",
        "timestamp": 1772063529
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/channel/113488-general/topic/Lean.20Kernel.20Arena/near/575882781\">said</a>:</p>\n<blockquote>\n<p>not sure how much interest there is – once you have written your parser you likely don’t care much about the  JSON any more.</p>\n</blockquote>\n<p>Oh so kernels <em>are meant to write parsers</em>, that's what I misunderstood, thanks!<br>\nI thought the point was to write minimalistic <em>checkers</em> only, that take in an <code>Expr</code> as JSON and type-check it.<br>\nRequiring a parser is raising the bar quite high, no?<br>\nAre there tests for just the parser part?</p>\n<p>(I agree that technically the parser could be considered as part of the trusted codebase, since it could change the meaning of theorems)</p>",
        "id": 575902660,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1772066788
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"933054\">Snir Broshi</span> <a href=\"#narrow/channel/113488-general/topic/Lean.20Kernel.20Arena/near/575902660\">said</a>:</p>\n<blockquote>\n<p>Requiring a parser is raising the bar quite high, no?<br>\nAre there tests for just the parser part?</p>\n</blockquote>\n<p>I think Joachim is just talking about parsing the JSON itself.</p>",
        "id": 575913488,
        "sender_full_name": "James E Hanson",
        "timestamp": 1772071067
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"904624\">James E Hanson</span> <a href=\"#narrow/channel/113488-general/topic/Lean.20Kernel.20Arena/near/575913488\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"933054\">Snir Broshi</span> <a href=\"#narrow/channel/113488-general/topic/Lean.20Kernel.20Arena/near/575902660\">said</a>:</p>\n<blockquote>\n<p>Requiring a parser is raising the bar quite high, no?<br>\nAre there tests for just the parser part?</p>\n</blockquote>\n<p>I think Joachim is just talking about parsing the JSON itself.</p>\n</blockquote>\n<p>I'm confused, are you sure? They said \"once you have written your parser you likely don’t care much about the JSON any more\" which doesn't seem to fit, unless you consider the in-memory tree structure of JSON to not be JSON, and only consider the serialized form as JSON. But then the tests should still display the parts you do care about, which is the tree structure, and to display that you have to serialize it back to a JSON string, so we're back to caring about JSON. So you've confused me.</p>\n<p>My point is- whatever you have to parse, whether it is Lean or JSON (or whatever you call a \"parsed\" JSON, even though I think that distinction is impossible), that should be on the website. After all, the point of the website is to display tests for the checker.<br>\nIf the kernels only have to parse JSON and not Lean, since it isn't super readable then perhaps a side-by-side view of Lean &amp; JSON is a good solution?</p>",
        "id": 575918412,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1772073460
    },
    {
        "content": "<p>I am assuming you take an off the shelf JSON parser which takes the raw bytes and returns a generic structured representation of JSON objects. Then you start from there and parse that into your checkers's representation of expressions and declarations. I wager that the raw textual JSON isn't that interesting once this translation is written. And if it is, just get the tarball and look in there</p>",
        "id": 575943792,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1772088523
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/channel/113488-general/topic/Lean.20Kernel.20Arena/near/575943792\">said</a>:</p>\n<blockquote>\n<p>I wager that the raw textual JSON isn't that interesting once this translation is written.</p>\n</blockquote>\n<p>But that's the input to the checker! How do you expect someone to implement a checker if you don't show them the input? How would I even write the translation without seeing the input?<br>\nYou created this beautiful website but it seems like one still has to download the tarball and browse it to implement a checker, ignoring the website.</p>",
        "id": 576012271,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1772109719
    },
    {
        "content": "<p>My assumption is that if someone actually writes a checker, they want to run it, so they need the JSON files locally anyways, so viewing them in the browser isn't that useful. Once the parser is done, however, and you start implementing features, you no longer care about the raw JSON but the expressions they encode, and it is very useful to see them in a human-readable format.</p>\n<p>Also, someone who is not developing a checker but wants to understand what a test is about likely only cares about the declarations , and not the raw export encoding, so they also benefit from the nice view.</p>",
        "id": 576017234,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1772111063
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"933054\">Snir Broshi</span> <a href=\"#narrow/channel/113488-general/topic/Lean.20Kernel.20Arena/near/576012271\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/channel/113488-general/topic/Lean.20Kernel.20Arena/near/575943792\">said</a>:</p>\n<blockquote>\n<p>I wager that the raw textual JSON isn't that interesting once this translation is written.</p>\n</blockquote>\n<p>But that's the input to the checker! How do you expect someone to implement a checker if you don't show them the input? How would I even write the translation without seeing the input?</p>\n</blockquote>\n<p>There's a spec: <a href=\"https://github.com/leanprover/lean4export/blob/master/format_ndjson.md\">https://github.com/leanprover/lean4export/blob/master/format_ndjson.md</a></p>",
        "id": 576019695,
        "sender_full_name": "Chris Bailey",
        "timestamp": 1772111726
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/channel/113488-general/topic/Lean.20Kernel.20Arena/near/576017234\">said</a>:</p>\n<blockquote>\n<p>My assumption is that if someone actually writes a checker, they want to run it, so they need the JSON files locally anyways, so viewing them in the browser isn't that useful.</p>\n</blockquote>\n<p>I'm considering writing a checker (which is why I'm following this thread), and I find the website pretty but not helpful at the moment. I'm not sure if that contradicts your assumption (since I might realize later that you're right and the JSONs are not useful), but it's a datapoint.</p>",
        "id": 576019893,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1772111784
    },
    {
        "content": "<p>The main advantage of the website vs local files is that it can place the JSON and Lean side-by-side.</p>",
        "id": 576020962,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1772112096
    },
    {
        "content": "<p>I’m sorry to hear that it is not useful to you.</p>",
        "id": 576024051,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1772112901
    },
    {
        "content": "<p>Snir I think when you start writing one the parser is all you see and it's hard to get off the ground. I will say my experience does match that once the parser is written (or in our case me and <span class=\"user-mention\" data-user-id=\"753178\">@Aaron Hill</span> have written and rewritten it <em>4</em> times now) that then we stop looking at all at the JSON, it's too long and noisy for a human, and mostly look at our own domain objects (our re-representations of Lean <code>Expr</code> and things)</p>",
        "id": 576364472,
        "sender_full_name": "Julian Berman",
        "timestamp": 1772234211
    }
]