[
    {
        "content": "<p>Recursors are primitive in the Lean kernel, and <code>match</code> syntax and recursive function definitions are elaborated down to recursors. For code generation, the original definitions of recursive functions are kept with the name <code>foo._unsafe_rec</code> and compiled as regular recursive functions in C/LLVM, and the <code>match</code> syntax desugared to <code>casesOn</code> becomes a primitive <code>match</code> construct in LCNF/IR.</p>\n<p>Is there an existing way to translate recursors into a definition with <code>casesOn</code> and recursion? Something like (the <code>_unsafe_rec</code> version of) this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">natRec</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">zero</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">natRec</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>It would of course be relatively easy to automate for simple inductive types like <code>Nat</code>, but I would rather avoid writing automation for the fully general case (with mutual/nested inductives, and possibly other fancy features) if this is already handled somewhere.</p>\n<p>From a logical point of view this is of course quite pointless, but I'm interested in compiling recursors (which are currently not supported, apart from a handful of hardcoded exceptions).</p>",
        "id": 522727413,
        "sender_full_name": "Simon Dima",
        "timestamp": 1749197597
    },
    {
        "content": "<p>Are you looking for <code>compile_inductive</code>?</p>",
        "id": 522743174,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1749203582
    },
    {
        "content": "<p>Yes, thanks! (<a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Util/CompileInductive.html\">link for future reference</a>)</p>",
        "id": 522752942,
        "sender_full_name": "Simon Dima",
        "timestamp": 1749207503
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"893179\">Simon Dima</span> has marked this topic as resolved.</p>",
        "id": 522752971,
        "sender_full_name": "Notification Bot",
        "timestamp": 1749207512
    }
]