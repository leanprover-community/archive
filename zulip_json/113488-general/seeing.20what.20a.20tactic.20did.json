[
    {
        "content": "<p>In the vs code view, it highlights parts of things touched by a tactic like simp, but I can't see  way to see what the tactic actually did. Presumably simp or ring or whatever actually constructed some expression, which perform a series of rewrites. Is it possible to visualise these rewrites and/or the proofs that it used within the right-hand pannel?</p>",
        "id": 390067516,
        "sender_full_name": "Matthew Pocock",
        "timestamp": 1694296690
    },
    {
        "content": "<p>Do you know about <code>show_term</code>?</p>",
        "id": 390067574,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1694296785
    },
    {
        "content": "<p>You can use <code>show_term [tactic]</code> and it will display the term that the tactic created.  However, as soon as there are rewrites, the output is fairly cluttered and rarely useful.</p>",
        "id": 390067578,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1694296789
    },
    {
        "content": "<p>If you know what lemma you are looking for, <code>show_term</code> on some tactics can help.  Specifically with <code>simp</code>, I would say that <code>simp?</code> is far superior to <code>show_term</code> and almost never worse.</p>",
        "id": 390067692,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1694296862
    },
    {
        "content": "<p>Both <code>simp</code> and <code>ring</code> will produce disgusting terms -- they are high-powered tactics. <code>simp</code> is doing lots of <code>rw</code>, and <code>rw</code> is doing very clever application of <code>Eq.rec</code> with some appropriate motive. <code>ring</code> is much worse, it puts everything into some \"Horner normal form\": the actual term underlying a proof of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>+</mo><mi>y</mi><msup><mo stretchy=\"false\">)</mo><mn>2</mn></msup><mo>=</mo><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>2</mn><mi>x</mi><mi>y</mi><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">(x+y)^2=x^2+2xy+y^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8974em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8389em;vertical-align:-0.1944em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">x</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0085em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span> is too big to post in Zulip.</p>",
        "id": 390067786,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694296941
    },
    {
        "content": "<p>Also, the idea of <code>show_term</code> is that you could replace the tactic with the given term, but, except for the most transparent tactics, the round-tripping almost never works.</p>",
        "id": 390067793,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1694296950
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">+</span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"bp\">=</span><span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">x</span><span class=\"bp\">*</span><span class=\"n\">y</span><span class=\"bp\">+</span><span class=\"n\">y</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">show_term</span> <span class=\"n\">ring</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">Try this: exact Mathlib.Tactic.Ring.of_eq</span>\n<span class=\"cm\">  (Mathlib.Tactic.Ring.pow_congr</span>\n<span class=\"cm\">    (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf x) (Mathlib.Tactic.Ring.atom_pf y)</span>\n<span class=\"cm\">      (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * Nat.rawCast 1)</span>\n<span class=\"cm\">        (Mathlib.Tactic.Ring.add_pf_zero_add (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))</span>\n<span class=\"cm\">    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))</span>\n<span class=\"cm\">    (Mathlib.Tactic.Ring.pow_add</span>\n<span class=\"cm\">      (Mathlib.Tactic.Ring.pow_nat (Mathlib.Tactic.Ring.coeff_one 2)</span>\n<span class=\"cm\">        (Mathlib.Tactic.Ring.pow_one_cast (x ^ Nat.rawCast 1 * Nat.rawCast 1 + (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))</span>\n<span class=\"cm\">        (Mathlib.Tactic.Ring.pow_bit0</span>\n<span class=\"cm\">          (Mathlib.Tactic.Ring.pow_one (x ^ Nat.rawCast 1 * Nat.rawCast 1 + (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))</span>\n<span class=\"cm\">          (Mathlib.Tactic.Ring.add_mul</span>\n<span class=\"cm\">            (Mathlib.Tactic.Ring.mul_add</span>\n<span class=\"cm\">              (Mathlib.Tactic.Ring.mul_pp_pf_overlap x</span>\n<span class=\"cm\">                (Mathlib.Meta.NormNum.IsNat.to_raw_eq</span>\n<span class=\"cm\">                  (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)</span>\n<span class=\"cm\">                    (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))</span>\n<span class=\"cm\">                (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))</span>\n<span class=\"cm\">              (Mathlib.Tactic.Ring.mul_add</span>\n<span class=\"cm\">                (Mathlib.Tactic.Ring.mul_pf_left x (Nat.rawCast 1)</span>\n<span class=\"cm\">                  (Mathlib.Tactic.Ring.mul_pf_right y (Nat.rawCast 1) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))</span>\n<span class=\"cm\">                (Mathlib.Tactic.Ring.mul_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1))</span>\n<span class=\"cm\">                (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * (y ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))</span>\n<span class=\"cm\">              (Mathlib.Tactic.Ring.add_pf_add_gt (x ^ Nat.rawCast 1 * (y ^ Nat.rawCast 1 * Nat.rawCast 1))</span>\n<span class=\"cm\">                (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))</span>\n<span class=\"cm\">            (Mathlib.Tactic.Ring.add_mul</span>\n<span class=\"cm\">              (Mathlib.Tactic.Ring.mul_add</span>\n<span class=\"cm\">                (Mathlib.Tactic.Ring.mul_pf_right x (Nat.rawCast 1)</span>\n<span class=\"cm\">                  (Mathlib.Tactic.Ring.mul_pf_left y (Nat.rawCast 1) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))</span>\n<span class=\"cm\">                (Mathlib.Tactic.Ring.mul_add</span>\n<span class=\"cm\">                  (Mathlib.Tactic.Ring.mul_pp_pf_overlap y</span>\n<span class=\"cm\">                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq</span>\n<span class=\"cm\">                      (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)</span>\n<span class=\"cm\">                        (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))</span>\n<span class=\"cm\">                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))</span>\n<span class=\"cm\">                  (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1))</span>\n<span class=\"cm\">                  (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))</span>\n<span class=\"cm\">                (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * (y ^ Nat.rawCast 1 * Nat.rawCast 1))</span>\n<span class=\"cm\">[90 or so more lines omitted]</span>\n</code></pre></div>",
        "id": 390067809,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694296980
    },
    {
        "content": "<p>OK, so yeah the tactic-generated code I'm looking at is horrific. It may be informative if it could display a list, or a tree of transformed terms?</p>",
        "id": 390067894,
        "sender_full_name": "Matthew Pocock",
        "timestamp": 1694297066
    },
    {
        "content": "<p>I'm not sure that this tree of transformed terms is ever generated by Lean.</p>",
        "id": 390067912,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694297106
    },
    {
        "content": "<p>I doubt that even that would be much more helpful: proof terms found automatically tend to be really unwieldy.</p>",
        "id": 390067913,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1694297107
    },
    {
        "content": "<p>These tactics are not written with readable proof terms in mind. The reason is: what do you care as a human about how a computer is proving <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>+</mo><mi>y</mi><msup><mo stretchy=\"false\">)</mo><mn>2</mn></msup><mo>=</mo><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>2</mn><mi>x</mi><mi>y</mi><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">(x+y)^2=x^2+2xy+y^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8974em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8389em;vertical-align:-0.1944em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">x</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0085em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span>? The paper proof is obvious, it doesn't matter what the machine is doing.</p>",
        "id": 390068008,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694297206
    },
    {
        "content": "<p>Also, keep in mind that probably also the actual target that you are looking at pretty-printed is probably completely unusable, if you inspect it with <code>set_option pp.all true</code>.</p>",
        "id": 390068013,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1694297208
    },
    {
        "content": "<p>That's a little sad - I was hoping to learn something about how to construct proofs by looking at them.</p>",
        "id": 390068042,
        "sender_full_name": "Matthew Pocock",
        "timestamp": 1694297255
    },
    {
        "content": "<p>To me, looking at proof terms seems the wrong way to approach the problem...</p>",
        "id": 390068096,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1694297285
    },
    {
        "content": "<p>Even a simple thing like changing an x to a y in the middle of a complex term under the hypothesis that x=y will be some horrific thing in Lean's type theory. The way to construct a proof of anything other than the most trivial thing is to use tactics. The underlying type theory is just an implementation detail.</p>",
        "id": 390068118,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694297325
    },
    {
        "content": "<p>If you look at the term-mode proofs in mathlib, you will find that they are typically really short, and often you can see that their equivalent tactic-mode was a chain of <code>intro</code> and <code>refine</code>.</p>",
        "id": 390068259,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1694297518
    },
    {
        "content": "<p>The important thing is to have some kind of understanding that the type theory <em>is capable of</em> doing the mathematical \"move\" that you want to do. How it's doing it is only of interest if you are researching the foundations. For example it's useful to understand that the <code>rw</code> tactic can in theory exist, by examining the type of <code>Eq.rec</code> and seeing that it does precisely the concept of \"substituting in\". And it's useful to understand that you can compose tactics; this corresponds to composing functions. But looking at the details is like writing some python code, compiling to C or assembly, and then looking at the C/assembly code and expecting to get some insight into \"how python works\".</p>",
        "id": 390068346,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694297589
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/seeing.20what.20a.20tactic.20did/near/390068346\">said</a>:</p>\n<blockquote>\n<p>But looking at the details is like writing some python code, compiling to C or assembly, and then looking at the C/assembly code and expecting to get some insight into \"how python works\".</p>\n</blockquote>\n<p>I feel personally called out -- I have spent literally months doing this Rust to assembly.</p>",
        "id": 390068448,
        "sender_full_name": "Matthew Pocock",
        "timestamp": 1694297721
    },
    {
        "content": "<p>... and what was the conclusion?</p>",
        "id": 390068512,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1694297782
    },
    {
        "content": "<p>Heh, well whether you want to look at the actual term probably depends on what your interests are. I'm a mathematician with no interest in foundations; I once took a class which taught me they existed, and I convinced myself that they were strong enough to be able to do the mathematics I was interested in, and then I never looked back. Here's two ways of understanding how <code>simp</code> is doing something really simple:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">0</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">0</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">show_term</span> <span class=\"n\">simp</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">Try this: exact of_eq_true</span>\n<span class=\"cm\">  (Eq.trans</span>\n<span class=\"cm\">    (congrFun</span>\n<span class=\"cm\">      (congrArg Eq</span>\n<span class=\"cm\">        (Eq.trans (congr (congrArg HAdd.hAdd (Eq.trans (congrArg (HAdd.hAdd x) (mul_one 0)) (add_zero x))) (mul_one 0))</span>\n<span class=\"cm\">          (add_zero x)))</span>\n<span class=\"cm\">      x)</span>\n<span class=\"cm\">    (eq_self x))</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">0</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">0</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"bp\">?</span>\n<span class=\"c1\">-- Try this: simp only [mul_one, add_zero]</span>\n</code></pre></div>\n<p>and the second one is helpful (\"oh, I see that actually continually rewriting those lemmas will work\") but the first one just looks like a bunch of random noise to me and gives me much less information, other than the fact that I knew already which is that primitive operations like <code>Eq.trans</code> can be used to put arguments together etc.</p>",
        "id": 390068558,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694297854
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/113488-general/topic/seeing.20what.20a.20tactic.20did/near/390068512\">said</a>:</p>\n<blockquote>\n<p>... and what was the conclusion?</p>\n</blockquote>\n<p>It's a bit OT here, but I learned that modern x86 family chips are exceedingly good at referring to data by pointer, especially if you can limit gotos, so much so that I could often get a 30-50% speed improvement not caching values in a register. I think it gives the chip more freedom to compile it down from the assembly to whatever the chip actually does, and frees up its data fetch pipeline.</p>",
        "id": 390068640,
        "sender_full_name": "Matthew Pocock",
        "timestamp": 1694297932
    },
    {
        "content": "<p>Ok, without knowing anything about Rust or assembly, is it fair to summarize that you learned more about assembly than about Rust?  I would say that exploring proof terms would gain you a knowledge of terms, not of proofs.</p>",
        "id": 390068740,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1694298055
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/113488-general/topic/seeing.20what.20a.20tactic.20did/near/390068740\">said</a>:</p>\n<blockquote>\n<p>Ok, without knowing anything about Rust or assembly, is it fair to summarize that you learned more about assembly than about Rust?  I would say that exploring proof terms would gain you a knowledge of terms, not of proofs.</p>\n</blockquote>\n<p>That's probably fair -- I was learning how to write highly speed-optimized rust but yes, I learned mainly about what modern CPUs like to eat. I'm only a week old in lean, so the difference between terms and proofs and tactics is still a bit hazy to me in practice.</p>",
        "id": 390068823,
        "sender_full_name": "Matthew Pocock",
        "timestamp": 1694298149
    },
    {
        "content": "<p>I think that this thread shows you really clearly what the difference is. A proof is a mathematical idea, mathematically trivial proofs can be realised directly as terms but the moment you're doing anything nontrivial you can use tactics to manipulate and generate terms in ways where the underlying concepts are human-understandable but the terms themselves might be pretty nasty in the actual type theory.</p>",
        "id": 390068962,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694298334
    },
    {
        "content": "<p>I would say that looking at one or two layers inside can be beneficial, so knowing <em>something</em> about proof terms can be helpful for constructing proofs.  However, looking very deeply inside them will likely not give too much understanding of higher level arguments.  Maybe it is a little like trying to read a poem, where you only have access to the coordinates of the pixels that make up its words: the information is there, but it is presented in a very inconvenient way!</p>",
        "id": 390069016,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1694298365
    },
    {
        "content": "<p>You might find the first few chapters of <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/\">#tpil</a> of interest. This goes through a whole bunch of mathematically completely trivial stuff showing how to make terms corresponding to the proofs.</p>",
        "id": 390069042,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694298414
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/seeing.20what.20a.20tactic.20did/near/390069042\">said</a>:</p>\n<blockquote>\n<p>You might find the first few chapters of <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/\">#tpil</a> of interest.</p>\n</blockquote>\n<p>Yeah - I did that book on Wednesday/Thursday. The exercise were really fun.</p>",
        "id": 390069156,
        "sender_full_name": "Matthew Pocock",
        "timestamp": 1694298543
    },
    {
        "content": "<p>People with a computer science background tend to really appreciate Theorem Proving In Lean. I was kind of intrigued by it, writing these spaghetti terms to prove things like associativity of \\and -- and then I got to the chapter about tactics and was like \"wtf? why didn't they tell me this before? I've been wasting my time!\". The natural number game is written for mathematicians, and it doesn't explain terms at all, I just start by introducing tactics right from the start, and it's basically impossible to exit tactic mode in that game. I think my vehemently anti-term opinion just comes from the fact that I know that for any mathemtical question I'm interested in, the underlying term for a proof will be incomprehensible to a human so why bother even looking at it. But if you are only interested in trivial statements (perhaps because you are interested in implementation details) then perhaps the terms will be more enlightening.</p>",
        "id": 390069364,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694298752
    },
    {
        "content": "<p>I totally get the cultural difference. At the moment I'm just wasting time playing with the collatz conjecture to keep my brain active, and I quickly realised that without some mechanical assistance that I couldn't trust myself. I am definitely not a mathematician.</p>",
        "id": 390069505,
        "sender_full_name": "Matthew Pocock",
        "timestamp": 1694298939
    },
    {
        "content": "<p>More philosophically, if I am formalising a mathematical proof in Lean then I <em>already understand the proof</em> (if I didn't know how to prove it then I certainly wouldn't be trying to figure it out using Lean -- I'd be using pencil and paper). Tactics are a far more appropriate language for translating the mathematical argument in my head into a Lean proof, and the term can't teach me anything because I already understand the proof and the term is probably gobbledegook anyway.</p>",
        "id": 390069513,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694298946
    },
    {
        "content": "<p>My understanding is that there are people using homotopy type theory provers who really do use ITPs as an experimental tool for research, perhaps because the questions they're interested in involve keeping track of higher types (i.e. infinity groupoids) and then the ITP does actually help with keeping track of what's going on. But for classical mathematics of the type we're developing in mathlib, paper and pencil is still king, and will remain so for a while I think.</p>",
        "id": 390069682,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694299114
    },
    {
        "content": "<p>I'm actually hoping that mathlib eventually gets good enough that it can indeed be used for real-time research, not just when you're done understanding the math. Certainly when I'm writing some god-awful 100 page analytic number theory paper with 30 parameters that need to be carefully balanced at the end for it all to work out, I wish there was a more robust mechanism for keeping it all straight than merely relying on my brain and reams of paper...</p>",
        "id": 390069921,
        "sender_full_name": "Alex Kontorovich",
        "timestamp": 1694299365
    },
    {
        "content": "<p>Maybe at some point in the future there will be a crossover; I would not like to conjecture when it will happen, and it might happen at different times for different subject areas in mathematics.</p>",
        "id": 390069949,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694299417
    },
    {
        "content": "<p>What does it mean for it to help you do research rather than to document what you've already researched? Is it that it offers suggestions about what you could explore next? Or visualisation tools? I don't really know.</p>",
        "id": 390070243,
        "sender_full_name": "Matthew Pocock",
        "timestamp": 1694299689
    },
    {
        "content": "<p>Mind, I don't really know what research is in maths. I'm a biologist.</p>",
        "id": 390070262,
        "sender_full_name": "Matthew Pocock",
        "timestamp": 1694299716
    },
    {
        "content": "<p>I recently found myself getting confused by a strange idea I had relating to the random oracle model (the random oracle model is a technique in cryptography  which assumes a particular function being used in a cryptographic protocol is drawn uniformly at random from the space of all functions of a given type). I eventually resorted to trying to work it out in lean notation (even though I was writing in a google doc). I wonder if I would have had more success actually using a lean environment.</p>",
        "id": 390070272,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1694299729
    },
    {
        "content": "<p>In this case, the issue was that there were two instantiations of the ROM at play, and I hoped that explicitly writing down what functions were calling what would help me keep track of the distinctions.</p>",
        "id": 390070372,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1694299816
    },
    {
        "content": "<p>I have also found lean helpful for understanding Löb's theorem in the past.</p>",
        "id": 390070500,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1694299955
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/seeing.20what.20a.20tactic.20did/near/390069949\">said</a>:</p>\n<blockquote>\n<p>Maybe at some point in the future there will be a crossover; I would not like to conjecture when it will happen, and it might happen at different times for different subject areas in mathematics.</p>\n</blockquote>\n<p>I agree with this and with the sentiment that this crossover will probably come sooner for field more closely related to logic.</p>",
        "id": 390070810,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1694300329
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"252920\">@Alex Kontorovich</span> without any more information about specifics, it seems to me like you might actually be able to have Lean help you with that task. At least, you could outline parts of the proof with <code>sorry</code> and axiomatize things we don't have in mathlib. You could verify select portions of the proof. It would be the same as a full formalization, but it could help you with organization and keeping track of balancing quantities. On the other hand, perhaps I'm just misunderstanding your actual situation and it's not really feasible.</p>",
        "id": 390072928,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1694302427
    },
    {
        "content": "<p>I thought I saw someone demo a tactic that synthesizes <code>calc</code> proofs from simp (or from rw or proof terms)? Or maybe I was dreaming, but maybe it's possible, at least for common cases?</p>",
        "id": 390075177,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1694304459
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"645990\">Matthew Pocock</span> <a href=\"#narrow/stream/113488-general/topic/seeing.20what.20a.20tactic.20did/near/390068823\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/113488-general/topic/seeing.20what.20a.20tactic.20did/near/390068740\">said</a>:</p>\n<blockquote>\n<p>Ok, without knowing anything about Rust or assembly, is it fair to summarize that you learned more about assembly than about Rust?  I would say that exploring proof terms would gain you a knowledge of terms, not of proofs.</p>\n</blockquote>\n<p>That's probably fair -- I was learning how to write highly speed-optimized rust but yes, I learned mainly about what modern CPUs like to eat. I'm only a week old in lean, so the difference between terms and proofs and tactics is still a bit hazy to me in practice.</p>\n</blockquote>\n<p>Tactics are the things that you use to produce a certificate (in the form of a term) that you have indeed a proof of something. The reason that both tactics and terms exist is because we want Lean to have a minimal piece of software (the kernel) that only has to check these certificates in order to verify that you indeed have a proof. This is useful because we can extend the tools that produce these terms with arbitrary algorithms without having to trust them as we have a minimal core to check their output. If you wish to understand how the proof terms are generated it is much more useful to read the implementation of the tactics than the proof terms themselves. That said meta programming is a rather advanced topic so you might want to get comfortable with Lean as a theorem prover and programming language before venturing that way.</p>",
        "id": 390075285,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1694304523
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/seeing.20what.20a.20tactic.20did/near/390069682\">said</a>:</p>\n<blockquote>\n<p>My understanding is that there are people using homotopy type theory provers who really do use ITPs as an experimental tool for research, perhaps because the questions they're interested in involve keeping track of higher types (i.e. infinity groupoids) and then the ITP does actually help with keeping track of what's going on. But for classical mathematics of the type we're developing in mathlib, paper and pencil is still king, and will remain so for a while I think.</p>\n</blockquote>\n<p>I've read that Emily Riehl is using rzk (<a href=\"https://github.com/rzk-lang/rzk\">https://github.com/rzk-lang/rzk</a>) for her research although rzk seems very custom tailored to a specific mathematical field (as far as I can tell as an outsider to both rzk and non-functional-programming-category-theory) as opposed to Lean/mathlib</p>",
        "id": 390075602,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1694304760
    },
    {
        "content": "<p>Right but she is doing mathematics where the basic object out of which everything is built is the infinity groupoid (which mathematicians struggled with a definition of for decades), whereas in mathlib the basic object is the set level type (which is trivial to understand -- it's just a collection of terms).</p>",
        "id": 390076246,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694305193
    },
    {
        "content": "<p>Once you have decided that the basic object of study is this fantastically complicated thing, then the kinds of questions you want to think about change completely, e.g. groups are boring and arguably not even the right objects to study, because group theory does not play well with this higher type structure; a group is a set-level object.</p>",
        "id": 390076489,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694305348
    },
    {
        "content": "<p>so all the questions you have now involve morphisms and morphisms between morphisms and morphisms between these things and... , and now you can imagine that having a theorem prover keeping track of all this infinite amount of data is really useful! Because every object looks like this.</p>",
        "id": 390076572,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694305415
    },
    {
        "content": "<p>You could say that the fact that <code>x = y</code> is a subsingleton in Lean means that Lean's types are \"lower types\" whereas in a univalent theory (where this is not the case) you study \"higher types\" and things get super-complicated very quickly.</p>",
        "id": 390076858,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694305591
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/seeing.20what.20a.20tactic.20did/near/390068008\">said</a>:</p>\n<blockquote>\n<p>These tactics are not written with readable proof terms in mind. The reason is: what do you care as a human about how a computer is proving <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>+</mo><mi>y</mi><msup><mo stretchy=\"false\">)</mo><mn>2</mn></msup><mo>=</mo><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>2</mn><mi>x</mi><mi>y</mi><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">(x+y)^2=x^2+2xy+y^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8974em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8389em;vertical-align:-0.1944em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">x</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0085em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span>? The paper proof is obvious, it doesn't matter what the machine is doing.</p>\n</blockquote>\n<p>Actually, it may surprise you to know that <code>ring</code> is designed to produce readable (or at least straightforward) proof terms. The thing is, it's not the proof expression itself you should be reading but rather the sequence of subgoals produced, i.e. using <code>#explode</code> to view the proof. (You might also need to use some notations to hide things like <code>rawCast</code> which would normally be displayed as just <code>↑</code>.)</p>",
        "id": 390172958,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694372218
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"645990\">Matthew Pocock</span> <a href=\"#narrow/stream/113488-general/topic/seeing.20what.20a.20tactic.20did/near/390068823\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/113488-general/topic/seeing.20what.20a.20tactic.20did/near/390068740\">said</a>:</p>\n<blockquote>\n<p>Ok, without knowing anything about Rust or assembly, is it fair to summarize that you learned more about assembly than about Rust?  I would say that exploring proof terms would gain you a knowledge of terms, not of proofs.</p>\n</blockquote>\n<p>That's probably fair -- I was learning how to write highly speed-optimized rust but yes, I learned mainly about what modern CPUs like to eat. I'm only a week old in lean, so the difference between terms and proofs and tactics is still a bit hazy to me in practice.</p>\n</blockquote>\n<p>Put another way, <code>ring</code> is designed to produce terms that the kernel likes to eat. This means it has very simple defeq problems (essentially syntactic only), a minimum of rewriting steps like <code>Eq.trans</code> or <code>congrFun</code> like you see in <code>simp</code>, and yet it does not optimize the names of lemmas because these are stored once and reused as many times as necessary, so they are essentially free (although big namespaced names contribute a lot to the \"busy-ness\" of the output of <code>ring</code>; opening the relevant namespace helps a lot)</p>",
        "id": 390173350,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694372493
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/seeing.20what.20a.20tactic.20did/near/390172958\">said</a>:</p>\n<blockquote>\n<p>but rather the sequence of subgoals produced, i.e. using <code>#explode</code> to view the proof. </p>\n</blockquote>\n<p>I think <code>#explode</code> may have been what I was hoping for all-along :D Thank you for this.</p>",
        "id": 390174186,
        "sender_full_name": "Matthew Pocock",
        "timestamp": 1694373114
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/113488-general/topic/seeing.20what.20a.20tactic.20did/near/390072928\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"252920\">Alex Kontorovich</span> without any more information about specifics, it seems to me like you might actually be able to have Lean help you with that task. At least, you could outline parts of the proof with <code>sorry</code> and axiomatize things we don't have in mathlib. You could verify select portions of the proof. It would be the same as a full formalization, but it could help you with organization and keeping track of balancing quantities. On the other hand, perhaps I'm just misunderstanding your actual situation and it's not really feasible.</p>\n</blockquote>\n<p>Indeed, I had a student look into formalizing the \"formalizable\" parts of a recent (long) paper of mine, with <code>sorry</code>s at the parts that involved objects not in mathlib; but for now, even that is still too hard and we gave up. Once that's possible without too much difficulty, I can foresee being able to write such little lemmata up as I work, so I don't have to go back and recheck if it's really true, in the process of scrambling to some other part of the proof...</p>",
        "id": 390214043,
        "sender_full_name": "Alex Kontorovich",
        "timestamp": 1694395146
    },
    {
        "content": "<p>Here's a cleaned up version of Kevin's example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Mathlib.Tactic.Ring</span>\n<span class=\"kn\">open</span> <span class=\"n\">Meta.NormNum</span> <span class=\"n\">Lean</span> <span class=\"n\">PrettyPrinter.Delaborator</span> <span class=\"n\">SubExpr</span>\n<span class=\"kd\">@[delab app.Nat.rawCast]</span>\n<span class=\"kd\">def</span> <span class=\"n\">delabNatCast</span> <span class=\"o\">:</span> <span class=\"n\">Delab</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">getExpr</span>\n  <span class=\"n\">guard</span> <span class=\"bp\">$</span> <span class=\"n\">e.isAppOfArity'</span> <span class=\"bp\">``</span><span class=\"n\">Nat.rawCast</span> <span class=\"mi\">3</span>\n  <span class=\"n\">withNaryArg</span> <span class=\"mi\">2</span> <span class=\"n\">delab</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">T</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">):</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">+</span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"bp\">=</span><span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">x</span><span class=\"bp\">*</span><span class=\"n\">y</span><span class=\"bp\">+</span><span class=\"n\">y</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">ring</span>\n<span class=\"bp\">#</span><span class=\"n\">explode</span> <span class=\"n\">T</span>\n</code></pre></div>",
        "id": 390301876,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694436044
    }
]