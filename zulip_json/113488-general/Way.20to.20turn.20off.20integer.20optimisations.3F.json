[
    {
        "content": "<p>In Lean 4, I'm told things like large integer multiplications are not written in Lean, but are \"optimised\" by using some un-verified big-integer library otherwise it would make Lean far too slow.</p>\n<p>Ideally we would like Lean kernel to be written in Lean and self-verified. But I think that is not the case at the moment. And even if it was the hardware it is running on is not verified so at some level down the line we just have to go with trust.   (In some universe every time a FLT proof is verified a random neutrino flies into the circuits and flips a bit - but I digress....). </p>\n<p>As a compromise, is there some way to turn off the big-integer library optimisations, and so all large integer calculations are fully verified within Lean? </p>\n<p>Are there other parts of Lean that have been optimised with unverified code? And do these have slower but verifiable alternatives? I assume lists and list-like structures have back end optimisations.</p>\n<p>A good choice would be to use the fast optimisations for day-to-day working. But then to turn them off and use slower verifiable Lean code for a final proof check.</p>\n<p>(On the alternative point of view are there more Lean objects that could be sped up with a faster unverified backend option for day-to-day work?)</p>",
        "id": 537671298,
        "sender_full_name": "Mr Proof",
        "timestamp": 1756992097
    },
    {
        "content": "<p>Well, the only functions that are evaluated in optimized form in the kernel are:<br>\n<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.succ#doc\">docs#Nat.succ</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.add#doc\">docs#Nat.add</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.sub#doc\">docs#Nat.sub</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.mul#doc\">docs#Nat.mul</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.pow#doc\">docs#Nat.pow</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.gcd#doc\">docs#Nat.gcd</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.mod#doc\">docs#Nat.mod</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.div#doc\">docs#Nat.div</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.beq#doc\">docs#Nat.beq</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.ble#doc\">docs#Nat.ble</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.land#doc\">docs#Nat.land</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.lor#doc\">docs#Nat.lor</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.xor#doc\">docs#Nat.xor</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.shiftLeft#doc\">docs#Nat.shiftLeft</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.shiftRight#doc\">docs#Nat.shiftRight</a>.<br>\nUsually these rely on GMP and we're pretty sure that we can trust GMP; if you don't think so, you can use external type checkers.</p>",
        "id": 537673369,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1756992660
    },
    {
        "content": "<p>You can always use <a href=\"https://github.com/digama0/lean4lean/\">https://github.com/digama0/lean4lean/</a> <del>, which has none of those optimizations you mentioned enabled.</del> (no, it does)</p>",
        "id": 537673389,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1756992664
    },
    {
        "content": "<p>That's not quite true, see <a href=\"https://github.com/digama0/lean4lean/blob/d74ab2e5bd37537807c157128a292ee7bb4736fb/Lean4Lean/TypeChecker.lean#L408-L432\">https://github.com/digama0/lean4lean/blob/d74ab2e5bd37537807c157128a292ee7bb4736fb/Lean4Lean/TypeChecker.lean#L408-L432</a> which uses the same big-int optimizations</p>",
        "id": 537673832,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1756992782
    },
    {
        "content": "<p>Oh, by calling it back to the runtime itself? Shoot! Ok.</p>",
        "id": 537674426,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1756992943
    },
    {
        "content": "<p>Would it be fair to say that \"GMP is correct\" is in fact an axiom of Lean? Or to put it another way, if there was some flaw in the GMP implementation, would we be able to prove <code>False</code> without using <code>native_decide</code>?</p>",
        "id": 537701862,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1757000360
    },
    {
        "content": "<p>You might be able to prove false to the builtin Lean kernel but since there can in principle exist arbitrary re-implementations of Lean that do not make use of GMP those kernels could still detect that fraud attempt (assuming their implementation doesn't happen to suffer from the same bug e.g. because someone copied GMP code into another library).</p>",
        "id": 537702580,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1757000565
    },
    {
        "content": "<p>For example the nanoda re-implementation uses the <code>num-bigint</code> crate which is completely written in Rust so at least it has no direct code share with GMP.</p>",
        "id": 537702970,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1757000669
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"873547\">Robin Arnez</span> <a href=\"#narrow/channel/113488-general/topic/Way.20to.20turn.20off.20integer.20optimisations.3F/near/537673369\">said</a>:</p>\n<blockquote>\n<p>Well, the only functions that are evaluated in optimized form in the kernel are:<br>\n<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.succ#doc\">docs#Nat.succ</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.add#doc\">docs#Nat.add</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.sub#doc\">docs#Nat.sub</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.mul#doc\">docs#Nat.mul</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.pow#doc\">docs#Nat.pow</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.gcd#doc\">docs#Nat.gcd</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.mod#doc\">docs#Nat.mod</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.div#doc\">docs#Nat.div</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.beq#doc\">docs#Nat.beq</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.ble#doc\">docs#Nat.ble</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.land#doc\">docs#Nat.land</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.lor#doc\">docs#Nat.lor</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.xor#doc\">docs#Nat.xor</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.shiftLeft#doc\">docs#Nat.shiftLeft</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.shiftRight#doc\">docs#Nat.shiftRight</a>.<br>\nUsually these rely on GMP and we're pretty sure that we can trust GMP; if you don't think so, you can use external type checkers.</p>\n</blockquote>\n<p>That surprised me that there would be no optimised alternatives for lists/arrays/tensor-arrays etc. (Is this true?) These could also be optimised on the GPU. And so make Lean a language for neural networks and graphics. (Fully backed up with slower verified alternatives). I think Agda and Indris have optimised lists. And indeed do most variants of LISP.</p>\n<p><a href=\"https://lean-lang.org/doc/reference/latest/Basic-Types/Arrays/\">Here it says Arrays are optimised</a>: </p>\n<p>I fully trust GMP, I think you can't be a purist in these matters I suppose!</p>",
        "id": 537715036,
        "sender_full_name": "Mr Proof",
        "timestamp": 1757004744
    },
    {
        "content": "<p>Just to clarify: array indexing is optimized at runtime (to make O(1) array indexing possible) but not in the kernel/type checker (where array indexing is O(n))</p>",
        "id": 537715870,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1757005055
    },
    {
        "content": "<p>And if we take your idea of fast but not so reliable vs slow but reliable that's basically the difference between <code>native_decide</code> / <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.trustCompiler#doc\">docs#Lean.trustCompiler</a> (fast because it can use the Lean compiler and runtime but quite simple to break) and regular <code>decide</code> (slow because it goes through the type checker / kernel but very reliable).</p>",
        "id": 537716902,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1757005432
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"873547\">Robin Arnez</span> <a href=\"#narrow/channel/113488-general/topic/Way.20to.20turn.20off.20integer.20optimisations.3F/near/537673369\">said</a>:</p>\n<blockquote>\n<p>Well, the only functions that are evaluated in optimized form in the kernel are:<br>\n<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.succ#doc\">docs#Nat.succ</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.add#doc\">docs#Nat.add</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.sub#doc\">docs#Nat.sub</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.mul#doc\">docs#Nat.mul</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.pow#doc\">docs#Nat.pow</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.gcd#doc\">docs#Nat.gcd</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.mod#doc\">docs#Nat.mod</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.div#doc\">docs#Nat.div</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.beq#doc\">docs#Nat.beq</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.ble#doc\">docs#Nat.ble</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.land#doc\">docs#Nat.land</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.lor#doc\">docs#Nat.lor</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.xor#doc\">docs#Nat.xor</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.shiftLeft#doc\">docs#Nat.shiftLeft</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.shiftRight#doc\">docs#Nat.shiftRight</a>.<br>\nUsually these rely on GMP and we're pretty sure that we can trust GMP; if you don't think so, you can use external type checkers.</p>\n</blockquote>\n<p>Most of these contain an explicit message in the docstring that they're optimised in the kernel, but Nat.div doesn't. Is there something I can check to generate/confirm the list?</p>",
        "id": 553990786,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1762392274
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.reduceNat%3F#doc\">docs#Lean.Meta.reduceNat?</a></p>",
        "id": 553990879,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1762392335
    },
    {
        "content": "<p>has a list of elaborator-optimized functions</p>",
        "id": 553990898,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1762392352
    },
    {
        "content": "<p>Hmm, is that the same as the kernel-optimized functions? That would surprise me</p>",
        "id": 553991014,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1762392420
    },
    {
        "content": "<p>the kernel list seems to be <a href=\"https://github.com/leanprover/lean4/blob/ae86c18ac19cee9bdf4e63cde2c11694e3217b70/src/kernel/type_checker.cpp#L600\">here</a></p>",
        "id": 553991149,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1762392508
    },
    {
        "content": "<p>they're in a different order but it's all the same functions</p>",
        "id": 553991253,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1762392581
    },
    {
        "content": "<p>That's the one I wanted, thanks!</p>",
        "id": 553991267,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1762392593
    },
    {
        "content": "<p>The earlier one isn't getting called for kernel reduction (in particular in my application), eg</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">myFunc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">add</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">isDefEq</span><span class=\"bp\">.</span><span class=\"n\">whnf</span><span class=\"bp\">.</span><span class=\"n\">reduceBinOp</span><span class=\"w\"> </span><span class=\"n\">true</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">myFunc</span><span class=\"w\"> </span><span class=\"mi\">2304920</span><span class=\"w\"> </span><span class=\"mi\">109108</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2414028</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">decide</span><span class=\"w\"> </span><span class=\"c1\">-- reduces in the elaborator, then kernel, so has a trace</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">myFunc</span><span class=\"w\"> </span><span class=\"mi\">2304920</span><span class=\"w\"> </span><span class=\"mi\">109108</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2414028</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">decide</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"n\">kernel</span><span class=\"w\"> </span><span class=\"c1\">-- reduces only in the kernel, so has no trace</span>\n</code></pre></div>",
        "id": 553991303,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1762392614
    }
]