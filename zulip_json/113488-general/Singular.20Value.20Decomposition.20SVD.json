[
    {
        "content": "<p>Hello everyone,</p>\n<p>So I just finished an attempt at proving that there exists a Singular Value Decomposition (SVD) for complex matrices. The code is on <a href=\"https://github.com/MohanadAhmed/lean-mhnd-linear-algebra/blob/1a12dd47255e5fd4e38151d986924aed139eb5ea/src/svd_run2.lean#L300\">Github</a>. It is still very inefficient (takes about 1 minute for lean to go through). I am hoping to take another run at it in a more structured manner, and then hopefully port it to lean4/mathlib4 (once I learn enough lean4/mathlib4). </p>\n<p>I thought I would share it with the community first, see any thoughts on how to structure it better and make it more useful. In its current form the main statement is basically:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">svd_decompose</span><span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">r</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">r</span> <span class=\"bp\">=</span> <span class=\"n\">A.rank</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span>\n  <span class=\"o\">(</span><span class=\"n\">U</span><span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">r</span> <span class=\"bp\">⊕</span> <span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">-</span> <span class=\"n\">r</span><span class=\"o\">))</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">Q</span><span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">r</span> <span class=\"bp\">⊕</span> <span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">-</span> <span class=\"n\">r</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">r</span> <span class=\"bp\">⊕</span> <span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">r</span><span class=\"o\">))</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">V</span><span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">r</span> <span class=\"bp\">⊕</span> <span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">r</span><span class=\"o\">))</span> <span class=\"n\">ℂ</span><span class=\"o\">),</span>\n    <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"n\">U</span><span class=\"bp\">⬝</span><span class=\"o\">(</span><span class=\"n\">Q.map</span> <span class=\"n\">RηC</span><span class=\"o\">)</span><span class=\"bp\">⬝</span><span class=\"n\">V</span><span class=\"bp\">ᴴ</span> <span class=\"bp\">∧</span> <span class=\"c\">/-</span><span class=\"cm\"> [1] SVD Statement -/</span>\n    <span class=\"n\">V</span><span class=\"bp\">⬝</span><span class=\"n\">V</span><span class=\"bp\">ᴴ</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">∧</span> <span class=\"c\">/-</span><span class=\"cm\"> [2] SVD Right Eigenvectors are orthogonoal-/</span>\n    <span class=\"n\">U</span><span class=\"bp\">⬝</span><span class=\"n\">U</span><span class=\"bp\">ᴴ</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">∧</span><span class=\"c\">/-</span><span class=\"cm\"> [3] SVD Left Eigenvectors are orthogonoal-/</span>\n    <span class=\"n\">U</span><span class=\"bp\">ᴴ⬝</span><span class=\"n\">U</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">∧</span> <span class=\"c\">/-</span><span class=\"cm\"> [4] Orthogonality [3] the other way around -/</span>\n    <span class=\"n\">V</span><span class=\"bp\">ᴴ⬝</span><span class=\"n\">V</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">∧</span> <span class=\"c\">/-</span><span class=\"cm\"> [5] Orthogonality [2] the other way around -/</span>\n<span class=\"n\">Q.to_blocks₁₂</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">∧</span> <span class=\"n\">Q.to_blocks₂₁</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">∧</span>  <span class=\"n\">Q.to_blocks₂₂</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"c\">/-</span><span class=\"cm\"> [6] Off diagonal blocks are zero -/</span>\n     <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">i</span> <span class=\"bp\">≠</span> <span class=\"n\">j</span> <span class=\"bp\">→</span> <span class=\"n\">Q.to_blocks₁₁</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">Q.to_blocks₁₁</span> <span class=\"n\">i</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"c\">/-</span><span class=\"cm\"> [7] Singular values (Non-zero) are positive and sitting in a diagonal matrix -/</span>\n      <span class=\"o\">:=</span> <span class=\"c\">/-</span><span class=\"cm\"> rest of proof here -/</span>\n</code></pre></div>\n<ol>\n<li>\n<p>My main thought was, SVD will be used as a block in another proof. The above lemma says: \"give me the SVD decomposition with its properties\". Any suggestions for a better API for SVD?</p>\n</li>\n<li>\n<p>The proof is also currently for complex matrices but will probably not be very difficult to modify to include the reals. The eigendecomposition (on which SVD rests )is based on the file <code>linear_algebra.matrix.spectrum</code> which works for <code>is_R_or_C</code>.  Are there any other cases that are worth paying attention to? </p>\n</li>\n</ol>\n<p>Any other thoughts or suggestions are also welcome!</p>",
        "id": 367391648,
        "sender_full_name": "MohanadAhmed",
        "timestamp": 1687097010
    },
    {
        "content": "<p>A programmer might answer your point 1 as: write a <code>def</code> which builds the SVD, and then separately prove that your <code>def</code> satisfies the properties of the SVD. That way you can obtain the SVD without having to extract some specific part of an existential statement. For the first example of this pattern which GitHub search gave me, see e.g. the definition of Cantor normal form of ordinals (<a href=\"https://github.com/leanprover-community/mathlib4/blob/6a12e9c90cfa8b8026aeb23b4aeb80737ae1f940/Mathlib/SetTheory/Ordinal/CantorNormalForm.lean#L78\">https://github.com/leanprover-community/mathlib4/blob/6a12e9c90cfa8b8026aeb23b4aeb80737ae1f940/Mathlib/SetTheory/Ordinal/CantorNormalForm.lean#L78</a>), which defines the CNF without any properties, and then goes on to prove in many small chunks that this actually is a normal form.</p>",
        "id": 367394132,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1687097701
    },
    {
        "content": "<p>So two questions:</p>\n<ol>\n<li>\n<p>What is preferable about this pattern compared to other methods? It seems it is quite common in mathlib, for example in <a href=\"https://leanprover-community.github.io/mathlib_docs/find/linear_algebra.matrix.spectrum\">docs#linear_algebra.matrix.spectrum</a> the eigenvalues of a hermitian are treated in this way.</p>\n</li>\n<li>\n<p>How do you work with the inference system to make sure lean understands you are always referring to the same matrix all the time. I was trying to mockup the suggestion you made above. I defined the three matrices U, Q, V and then wanted to state the 7 properties of SVD above sorried out. It seems I cannot convince lean to infer the matrix A in the 2nd lemma below. Any thoughts on how to write this one out in the shortest / idiomatic way?</p>\n</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.matrix.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.matrix.notation</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.complex.basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">matrix</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">matrix</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">svd</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">RηC</span> <span class=\"o\">:=</span> <span class=\"n\">algebra_map</span> <span class=\"n\">ℝ</span> <span class=\"n\">ℂ</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">def</span> <span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">def</span> <span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">svd_eq</span><span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"n\">svd.U</span><span class=\"bp\">⬝</span><span class=\"o\">(</span><span class=\"n\">svd.Q.map</span> <span class=\"n\">RηC</span><span class=\"o\">)</span><span class=\"bp\">⬝</span><span class=\"n\">svd.V</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c\">/-</span><span class=\"cm\"> This one works out -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">right_conj_transpose_eigenvector_mul</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">svd.V</span><span class=\"bp\">ᴴ</span><span class=\"o\">)</span> <span class=\"bp\">⬝</span> <span class=\"n\">svd.V</span>   <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c\">/-</span><span class=\"cm\"> Does not typecheck -/</span>\n\n<span class=\"c1\">-- More lemmas about the U, Q, V matrices should be here</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">svd</span>\n</code></pre></div>",
        "id": 367408955,
        "sender_full_name": "MohanadAhmed",
        "timestamp": 1687101879
    },
    {
        "content": "<p>I think you need to fake a dependency on <code>A</code> in <code>V U Q</code>, or else use <code>include A</code>, because as written lean will assume <code>V</code> doesn't depend on <code>A</code></p>",
        "id": 367427351,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687107582
    },
    {
        "content": "<p>this issue is mostly an artifact of filling the definitions by <code>sorry</code> instead of the real thing (which presumably refers to <code>A</code>)</p>",
        "id": 367427507,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687107620
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Singular.20Value.20Decomposition.20SVD/near/367427351\">said</a>:</p>\n<blockquote>\n<p>I think you need to fake a dependency on <code>A</code> in <code>V U Q</code>, or else use <code>include A</code>, because as written lean will assume <code>V</code> doesn't depend on <code>A</code></p>\n</blockquote>\n<p>So I tried what I understood from your first suggestion (about fake dependency). The A is not recognized inside the <code>V</code> defintion. Any thoughts on what I am missing?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.matrix.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.matrix.notation</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.complex.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra.matrix.pos_def</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra.matrix.spectrum</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">matrix</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">matrix</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">svd</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">RηC</span> <span class=\"o\">:=</span> <span class=\"n\">algebra_map</span> <span class=\"n\">ℝ</span> <span class=\"n\">ℂ</span>\n<span class=\"c1\">-- include A</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">eigs</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">is_hermitian_transpose_mul_self</span> <span class=\"n\">A</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">eigenvalues</span><span class=\"o\">,</span> <span class=\"c\">/-</span><span class=\"cm\"> Unknown identifier A-/</span>\n  <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">diagonal</span> <span class=\"n\">eigs</span><span class=\"o\">),</span>\n<span class=\"kd\">end</span>\n<span class=\"kd\">def</span> <span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">def</span> <span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">svd_eq</span><span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"n\">svd.U</span><span class=\"bp\">⬝</span><span class=\"o\">(</span><span class=\"n\">svd.Q.map</span> <span class=\"n\">RηC</span><span class=\"o\">)</span><span class=\"bp\">⬝</span><span class=\"n\">svd.V</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">right_conj_transpose_eigenvector_mul</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">svd.V</span><span class=\"bp\">ᴴ</span><span class=\"o\">)</span> <span class=\"bp\">⬝</span> <span class=\"n\">svd.V</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c\">/-</span><span class=\"cm\"> Still does not typecheck-/</span>\n\n<span class=\"c1\">-- More lemmas about the U, Q, V matrices should be here</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">svd</span>\n</code></pre></div>",
        "id": 367440064,
        "sender_full_name": "MohanadAhmed",
        "timestamp": 1687112471
    },
    {
        "content": "<p>if you do it inside <code>begin ... end</code> it will have already decided that <code>A</code> is not part of the definition</p>",
        "id": 367440497,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687112638
    },
    {
        "content": "<p>so you have to use <code>include</code> or put the <code>let</code> outside <code>begin ... end</code></p>",
        "id": 367440578,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687112660
    },
    {
        "content": "<p>So you mean it must be part of the signature?</p>",
        "id": 367440779,
        "sender_full_name": "MohanadAhmed",
        "timestamp": 1687112760
    },
    {
        "content": "<p>yes, that will also work</p>",
        "id": 367440888,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687112785
    },
    {
        "content": "<p>in general <code>variable</code> declarations are only included in definitions when they are used</p>",
        "id": 367441052,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687112836
    },
    {
        "content": "<p>So if there is not <code>begin</code> <code>end</code> but I just a direct term, will that work?</p>",
        "id": 367441154,
        "sender_full_name": "MohanadAhmed",
        "timestamp": 1687112873
    },
    {
        "content": "<p>yes</p>",
        "id": 367441169,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687112878
    },
    {
        "content": "<p>I guess not! Just tried it and now both <code>svd_eq</code> and <code>right_conj_transpose_eigenvector_mul</code> do not typecheck!!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.matrix.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.matrix.notation</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.complex.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra.matrix.pos_def</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra.matrix.spectrum</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">matrix</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">matrix</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">svd</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">RηC</span> <span class=\"o\">:=</span> <span class=\"n\">algebra_map</span> <span class=\"n\">ℝ</span> <span class=\"n\">ℂ</span>\n<span class=\"c1\">-- include A</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span>\n<span class=\"o\">((</span><span class=\"n\">matrix.diagonal</span> <span class=\"o\">(</span><span class=\"n\">is_hermitian_transpose_mul_self</span> <span class=\"n\">A</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">eigenvalues</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">RηC</span><span class=\"o\">)</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span>\n<span class=\"o\">((</span><span class=\"n\">matrix.diagonal</span> <span class=\"o\">(</span><span class=\"n\">is_hermitian_mul_conj_transpose_self</span> <span class=\"n\">A</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">eigenvalues</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">RηC</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">A.map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">,</span> <span class=\"n\">x.re</span><span class=\"o\">))</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">Now this one does not typecheck as well-/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">svd_eq</span><span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"n\">svd.U</span><span class=\"bp\">⬝</span><span class=\"o\">(</span><span class=\"n\">svd.Q.map</span> <span class=\"n\">RηC</span><span class=\"o\">)</span><span class=\"bp\">⬝</span><span class=\"n\">svd.V</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"c\">/-</span><span class=\"cm\"> Still does not typecheck-/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">right_conj_transpose_eigenvector_mul</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">svd.V</span><span class=\"bp\">ᴴ</span><span class=\"o\">)</span> <span class=\"bp\">⬝</span> <span class=\"n\">svd.V</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- More lemmas about the U, Q, V matrices should be here</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">svd</span>\n</code></pre></div>",
        "id": 367442070,
        "sender_full_name": "MohanadAhmed",
        "timestamp": 1687113219
    },
    {
        "content": "<p>right, that's the other part, <code>svd.V</code> and <code>svd.Q</code> are functions, you need to apply them to <code>A</code></p>",
        "id": 367442527,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687113424
    },
    {
        "content": "<p>so <code>svd_eq</code> would be something like <code>A = svd.U A ⬝ (svd.Q A).map RηC ⬝ svd.V A</code></p>",
        "id": 367442641,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687113476
    },
    {
        "content": "<p>OK I see! so I will always be mentioning A. <br>\nIs there a way to make <code>svd</code> act like the <code>is_hermitian</code> <a href=\"https://leanprover-community.github.io/mathlib_docs/find/matrix.is_hermitian.eigenvalues\">docs#matrix.is_hermitian.eigenvalues</a> where the hypothesis (hA: is_hermitian A) allows you to write <code>hA.eigenvalues</code> and<code>hA.eigenvector_matrix</code> and so on?</p>",
        "id": 367444912,
        "sender_full_name": "MohanadAhmed",
        "timestamp": 1687114474
    },
    {
        "content": "<p>if you put it in the namespace of <code>A</code>'s type you can write it as <code>A.V</code> and <code>A.Q</code> etc, although the name <code>matrix.V</code> is kind of vague</p>",
        "id": 367445050,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687114535
    },
    {
        "content": "<p>Another approach (which more closely matches things like numpy etc) would be to have<code>matrix.svd (A : matrix (fin n) (fin n) ℂ) : matrix.svd_parts</code> where <code>structure svd_parts := (V : _) (U : _) (Q : _)</code></p>",
        "id": 367458491,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1687121491
    },
    {
        "content": "<p>hello</p>",
        "id": 367483870,
        "sender_full_name": "cvlvxi",
        "timestamp": 1687138165
    }
]