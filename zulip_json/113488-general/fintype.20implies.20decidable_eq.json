[
    {
        "content": "<p>It seems to me that <code>fintype A</code> shoud imply <code>decidable_eq A</code> but there doesn't seem to be such a proof in the mathlib. Why is this?</p>",
        "id": 328499615,
        "sender_full_name": "Thorsten Altenkirch",
        "timestamp": 1676648214
    },
    {
        "content": "<p>Here's an indirect reason why not: <a href=\"https://leanprover-community.github.io/mathlib_docs/find/Prop.fintype\">docs#Prop.fintype</a></p>\n<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> has commented about how mathlib's fintype is strange in this way.</p>",
        "id": 328500141,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1676648344
    },
    {
        "content": "<p>For example, you need decidable equality to get <a href=\"https://leanprover-community.github.io/mathlib_docs/find/fintype.trunc_equiv_fin\">docs#fintype.trunc_equiv_fin</a>, and having such an equivalence would imply decidable equality.</p>",
        "id": 328500855,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1676648529
    },
    {
        "content": "<p>You can use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/classical.dec_eq\">docs#classical.dec_eq</a></p>",
        "id": 328503800,
        "sender_full_name": "David Renshaw",
        "timestamp": 1676649330
    },
    {
        "content": "<p><code>fintype</code> is neither truly classical or truly constructive, so in some sense it's a good fit for nobody.</p>",
        "id": 328507479,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1676650209
    },
    {
        "content": "<p>I don't know what you mean by \"truly constructive\"</p>",
        "id": 328507989,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1676650349
    },
    {
        "content": "<p>It's just maybe not the same meaning of <code>fintype</code> as some constructivists would use</p>",
        "id": 328508029,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1676650361
    },
    {
        "content": "<p>If you want _that_ meaning, it's <code>[fintype X] [decidable_eq X]</code></p>",
        "id": 328508080,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1676650375
    },
    {
        "content": "<p>Just like <code>[semiring R] [add_comm_monoid M] [module R M]</code> is not the meaning of \"module\" that most mathematicians use; if you want <em>that</em> meaning, you write <code>[ring R] [add_comm_group M] [module R M]</code></p>",
        "id": 328508260,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1676650424
    },
    {
        "content": "<p>It's more like... not any of the meanings of \"finite\" that constructivists use</p>",
        "id": 328509472,
        "sender_full_name": "Reid Barton",
        "timestamp": 1676650720
    },
    {
        "content": "<p>I think it's fair to say that it's not not what you want out of a constructive <code>fintype</code> <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 328512304,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1676651448
    },
    {
        "content": "<p>Actually from <code>fintype</code> I think you can prove the propositional version of decidable equality. So it's Lean's Prop vs data distinction getting in the way.</p>",
        "id": 328513851,
        "sender_full_name": "Reid Barton",
        "timestamp": 1676651847
    },
    {
        "content": "<p>How would that proof go?</p>",
        "id": 328514273,
        "sender_full_name": "David Renshaw",
        "timestamp": 1676651960
    },
    {
        "content": "<p>So you have a list of elements of your type that is known to contain every element (in the <code>list.mem</code> sense) with no duplicates. So now you take your two elements <code>x</code> and <code>y</code> that you want to compare for equality. From the <code>list.mem</code> hypothesis, each one is either equal to the first element of the list or contained in the rest of the list.<br>\nIf they are both the first element, then of course they are equal. If only one is the first element, then they are distinct (because the list has no duplicates).<br>\nOtherwise, recurse on the rest of the list.</p>",
        "id": 328514824,
        "sender_full_name": "Reid Barton",
        "timestamp": 1676652103
    },
    {
        "content": "<p>You get the original list by doing cases on the quotient <code>multiset</code>, since the conclusion is a proposition.</p>",
        "id": 328514947,
        "sender_full_name": "Reid Barton",
        "timestamp": 1676652126
    },
    {
        "content": "<blockquote>\n<p>propositional version of decidable equality.</p>\n</blockquote>\n<p>that would have the same staetment as <a href=\"https://leanprover-community.github.io/mathlib_docs/find/decidable.eq_or_ne\">docs#decidable.eq_or_ne</a> (but obviously without the <code>decidable_eq</code> argument), right?</p>",
        "id": 328522632,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1676654183
    },
    {
        "content": "<p>so specifically <code>{a} [fintype a] (x y : a) : x = y ∨ x ≠ y</code>? with the axiom list empty?</p>",
        "id": 328524880,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1676654804
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"k\">have</span> <span class=\"n\">hx</span> <span class=\"o\">:=</span> <span class=\"n\">fintype.complete</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">hy</span> <span class=\"o\">:=</span> <span class=\"n\">fintype.complete</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">finset.mem_val</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">multiset.mem_to_list</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n  <span class=\"n\">induction</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">fintype.elems</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val.to_list</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>seems to be the intended proof, but then <code>ih : (fintype.elems a).val.to_list = tl → x = y ∨ x ≠ y</code> which is clear nonsense</p>",
        "id": 328526702,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1676655335
    },
    {
        "content": "<p>Well no LEM/choice anyways, no promises about other axioms</p>",
        "id": 328526838,
        "sender_full_name": "Reid Barton",
        "timestamp": 1676655370
    },
    {
        "content": "<p>Can you give the mwe so that I can try your proof, <span class=\"user-mention\" data-user-id=\"284160\">@Eric Rodriguez</span>?</p>",
        "id": 328527519,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1676655552
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.fintype.basic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">a</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"bp\">∨</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">hx</span> <span class=\"o\">:=</span> <span class=\"n\">fintype.complete</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">hy</span> <span class=\"o\">:=</span> <span class=\"n\">fintype.complete</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">finset.mem_val</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">multiset.mem_to_list</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n  <span class=\"n\">induction</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">fintype.elems</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val.to_list</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 328527632,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1676655587
    },
    {
        "content": "<p>You will need to figure out the exact induction hypothesis</p>",
        "id": 328527813,
        "sender_full_name": "Reid Barton",
        "timestamp": 1676655628
    },
    {
        "content": "<p>If <code>a</code> is <code>Prop</code> and <code>x</code> is <code>True</code>, isn't this example basically stating the law of excluded middle?</p>",
        "id": 328528372,
        "sender_full_name": "David Renshaw",
        "timestamp": 1676655788
    },
    {
        "content": "<p>If you have <code>fintype Prop</code>.</p>",
        "id": 328528446,
        "sender_full_name": "Reid Barton",
        "timestamp": 1676655812
    },
    {
        "content": "<p>Which isn't true, constructively</p>",
        "id": 328528467,
        "sender_full_name": "Reid Barton",
        "timestamp": 1676655820
    },
    {
        "content": "<p>Ah, I think the correct way to do it is to prove the lemma for a general list <code>l</code> and just apply it in this specific case</p>",
        "id": 328531803,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1676656850
    },
    {
        "content": "<p>Well, some nodup list.</p>",
        "id": 328531987,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1676656906
    },
    {
        "content": "<p>I think lists are a distraction</p>",
        "id": 328532316,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1676656996
    },
    {
        "content": "<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Using the generalize tactic</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.fintype.basic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">a</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"bp\">∨</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">hx</span> <span class=\"o\">:=</span> <span class=\"n\">fintype.complete</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">hy</span> <span class=\"o\">:=</span> <span class=\"n\">fintype.complete</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n  <span class=\"n\">revert</span> <span class=\"n\">hx</span> <span class=\"n\">hy</span><span class=\"o\">,</span>\n  <span class=\"n\">generalize</span> <span class=\"o\">:</span> <span class=\"n\">fintype.elems</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span> <span class=\"n\">hx</span> <span class=\"n\">hy</span><span class=\"o\">,</span>\n  <span class=\"n\">induction</span> <span class=\"n\">s</span> <span class=\"n\">using</span> <span class=\"n\">finset.cons_induction_on</span> <span class=\"k\">with</span> <span class=\"n\">z</span> <span class=\"n\">s</span> <span class=\"n\">hz</span> <span class=\"n\">ih</span> <span class=\"n\">generalizing</span> <span class=\"n\">hx</span> <span class=\"n\">hy</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">hx</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp_rw</span> <span class=\"n\">finset.mem_cons</span> <span class=\"n\">at</span> <span class=\"n\">hx</span> <span class=\"n\">hy</span><span class=\"o\">,</span>\n    <span class=\"n\">obtain</span> <span class=\"n\">rfl</span> <span class=\"bp\">|</span> <span class=\"n\">hy</span> <span class=\"o\">:=</span> <span class=\"n\">hy</span><span class=\"bp\">;</span> <span class=\"n\">obtain</span> <span class=\"n\">rfl</span> <span class=\"bp\">|</span> <span class=\"n\">hx</span> <span class=\"o\">:=</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">right</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">ne_of_mem_of_not_mem</span> <span class=\"n\">hx</span> <span class=\"n\">hz</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">right</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">ne_of_mem_of_not_mem</span> <span class=\"n\">hy</span> <span class=\"n\">hz</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">ih</span> <span class=\"n\">hx</span> <span class=\"n\">hy</span><span class=\"o\">}</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n</div></div>",
        "id": 328532337,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1676657000
    },
    {
        "content": "<p>Or more concisely</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.fintype.basic</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">finset.eq_or_ne_of_mem</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hy</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"bp\">∨</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">s</span> <span class=\"n\">using</span> <span class=\"n\">finset.cons_induction_on</span> <span class=\"k\">with</span> <span class=\"n\">z</span> <span class=\"n\">s</span> <span class=\"n\">hz</span> <span class=\"n\">ih</span> <span class=\"n\">generalizing</span> <span class=\"n\">hx</span> <span class=\"n\">hy</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">hx</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp_rw</span> <span class=\"n\">finset.mem_cons</span> <span class=\"n\">at</span> <span class=\"n\">hx</span> <span class=\"n\">hy</span><span class=\"o\">,</span>\n    <span class=\"n\">obtain</span> <span class=\"n\">rfl</span> <span class=\"bp\">|</span> <span class=\"n\">hy</span> <span class=\"o\">:=</span> <span class=\"n\">hy</span><span class=\"bp\">;</span> <span class=\"n\">obtain</span> <span class=\"n\">rfl</span> <span class=\"bp\">|</span> <span class=\"n\">hx</span> <span class=\"o\">:=</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">right</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">ne_of_mem_of_not_mem</span> <span class=\"n\">hx</span> <span class=\"n\">hz</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">right</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">ne_of_mem_of_not_mem</span> <span class=\"n\">hy</span> <span class=\"n\">hz</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">ih</span> <span class=\"n\">hx</span> <span class=\"n\">hy</span><span class=\"o\">}</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">fintype.eq_or_ne</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">a</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"bp\">∨</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n<span class=\"n\">finset.eq_or_ne_of_mem</span> <span class=\"o\">(</span><span class=\"n\">fintype.complete</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fintype.complete</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"k\">#print</span> <span class=\"kd\">axioms</span> <span class=\"n\">fintype.eq_or_ne</span>\n</code></pre></div>",
        "id": 328534548,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1676657663
    },
    {
        "content": "<p>Sorry. I didn't read all the responses. FinType means that for every element you have a proof that it appears in a finite set (ie a finite multiset without repetitions). The proof gives you a unique position for any element, and equality of positions is decidable. Hence equality of elements is decidable. Indeed the definition of FinType is equivalent to saying that there is an isomorphism of A with an initial segment of Nat. </p>\n<p>However, I don't know wether strict Prop gets in your way here. Maybe the definition of FinType needs to be changed by replacing the exists with a Sigma. Being a FinType is not a proposition but a structure.</p>",
        "id": 328836383,
        "sender_full_name": "Thorsten Altenkirch",
        "timestamp": 1676825853
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271218\">Thorsten Altenkirch</span> <a href=\"#narrow/stream/113488-general/topic/fintype.20implies.20decidable_eq/near/328836383\">said</a>:</p>\n<blockquote>\n<p>FinType means that for every element you have a proof that it appears in a finite set (ie a finite multiset without repetitions).</p>\n</blockquote>\n<p>Yes</p>\n<blockquote>\n<p>The proof gives you a unique position for any element</p>\n</blockquote>\n<p>No, there is no concept of position in a finite set.</p>",
        "id": 328836924,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1676826018
    },
    {
        "content": "<p>A fintype is a structure, and it carries the list of elements in the type, but one of the components is the assertion that every element is in the list, and this is not a data-carrying assertion. For example if the list is <code>[a, b]</code> then we have <code>∀ x, x = a ∨ x = b</code> but not <code>∀ x, x = a ⊕ x = b</code>. You can't use a proof of an 'or' to construct an actual boolean telling you which side of the 'or' is true.</p>",
        "id": 328838315,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1676826560
    },
    {
        "content": "<blockquote>\n<p>Maybe the definition of FinType needs to be changed by replacing the exists with a Sigma</p>\n</blockquote>\n<p>Note that the \"need\" here, if there is one at all, is purely cosmetic. You can get exactly the behavior you want by writing <code>[fintype X] [decidable_eq X]</code>.</p>",
        "id": 328838470,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1676826628
    },
    {
        "content": "<p>(and this <code>decidable_eq X</code> instance supplied directly by typeclass inference will almost certainly be better than the one based on <code>fintype X</code>, which is linear in the best case and would in most cases involve O(n) equality comparisons)</p>",
        "id": 328839356,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1676827094
    },
    {
        "content": "<p>In most cases when this kind of diamond situation arises we would bake the weaker typeclass as a field or parent of the stronger one, i.e. <code>class fintype X extends decidable_eq X</code>, so we would not be using this theorem in the first place, it would just be true by fiat</p>",
        "id": 328839643,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1676827227
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271218\">@Thorsten Altenkirch</span> Just to elaborate upon the indirect reason I gave earlier, with mathlib's <code>fintype</code> you can construct <code>fintype Prop</code> (that's <a href=\"https://leanprover-community.github.io/mathlib_docs/find/Prop.fintype\">docs#Prop.fintype</a>) since the underlying list <code>[false, true]</code> represents the finite set of elements by Lean's axioms and choice. If you could get a computable <code>decidable_eq</code> out of this, then you'd get that every proposition is decidable.</p>\n<p>The other definition I mentioned, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/fintype.trunc_equiv_fin\">docs#fintype.trunc_equiv_fin</a>, is the existence (via <code>trunc</code>) of an isomorphism with an initial segment with Nat that you mention, but it requires <code>decidable_eq</code>.</p>",
        "id": 328841513,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1676828043
    },
    {
        "content": "<p>I'm ignorant of some terminology here: what does \"strict Prop\" mean?</p>",
        "id": 328841896,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1676828225
    },
    {
        "content": "<p>I think it refers to Coq's <code>SProp</code>, which IIRC is Lean's <code>Prop</code>.</p>",
        "id": 328842041,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1676828287
    },
    {
        "content": "<p>I think \"strict Prop\" means any two proofs of a Prop are equal (aka proof irrelevance). I think it's separate from propext, but let me note that if you use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/psum\">docs#psum</a> (which isn't Prop) instead of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/or\">docs#or</a> to define list membership, then you lose access to propext and will have to use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/trunc\">docs#trunc</a> in order to pass list membership down to multiset membership.</p>",
        "id": 328847133,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1676831038
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/fintype.20implies.20decidable_eq/near/328836924\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"271218\">Thorsten Altenkirch</span> <a href=\"#narrow/stream/113488-general/topic/fintype.20implies.20decidable_eq/near/328836383\">said</a>:</p>\n<blockquote>\n<p>FinType means that for every element you have a proof that it appears in a finite set (ie a finite multiset without repetitions).</p>\n</blockquote>\n<p>Yes</p>\n<blockquote>\n<p>The proof gives you a unique position for any element</p>\n</blockquote>\n<p>No, there is no concept of position in a finite set.</p>\n</blockquote>\n<p>And how do you define that an element occurs in a fintype. Ok, I suppose the problem is that you define this as a strict Prop. If you define it as a type this gives you a unique position.</p>\n<p>This just confirms my suspicion that classical logic is the consequence of reducing everything to propositions.</p>",
        "id": 328942741,
        "sender_full_name": "Thorsten Altenkirch",
        "timestamp": 1676888644
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113488-general/topic/fintype.20implies.20decidable_eq/near/328841513\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"271218\">Thorsten Altenkirch</span> Just to elaborate upon the indirect reason I gave earlier, with mathlib's <code>fintype</code> you can construct <code>fintype Prop</code> (that's <a href=\"https://leanprover-community.github.io/mathlib_docs/find/Prop.fintype\">docs#Prop.fintype</a>) since the underlying list <code>[false, true]</code> represents the finite set of elements by Lean's axioms and choice. If you could get a computable <code>decidable_eq</code> out of this, then you'd get that every proposition is decidable.</p>\n<p>The other definition I mentioned, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/fintype.trunc_equiv_fin\">docs#fintype.trunc_equiv_fin</a>, is the existence (via <code>trunc</code>) of an isomorphism with an initial segment with Nat that you mention, but it requires <code>decidable_eq</code>.</p>\n</blockquote>\n<p>It is the definition of Prop in Lean 3+ where any two proofs of a proposition are definitionally equal. I think I may have started this with my 1999 LICS paper. In HoTT we use HProp, a proposition is a type with at most one element. In many situations strict Props are more convenient but they don't support important principles such as unique choice which holds in any topos and is provable in HoTT.</p>",
        "id": 328943416,
        "sender_full_name": "Thorsten Altenkirch",
        "timestamp": 1676888811
    },
    {
        "content": "<p>You might be looking for <a href=\"https://leanprover-community.github.io/mathlib_docs/find/fin_enum\">docs#fin_enum</a>, which does give you a unique index for each element</p>",
        "id": 328946037,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1676889532
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113488-general/topic/fintype.20implies.20decidable_eq/near/328841513\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"271218\">Thorsten Altenkirch</span> Just to elaborate upon the indirect reason I gave earlier, with mathlib's <code>fintype</code> you can construct <code>fintype Prop</code> (that's <a href=\"https://leanprover-community.github.io/mathlib_docs/find/Prop.fintype\">docs#Prop.fintype</a>) since the underlying list <code>[false, true]</code> represents the finite set of elements by Lean's axioms and choice. If you could get a computable <code>decidable_eq</code> out of this, then you'd get that every proposition is decidable.</p>\n<p>The other definition I mentioned, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/fintype.trunc_equiv_fin\">docs#fintype.trunc_equiv_fin</a>, is the existence (via <code>trunc</code>) of an isomorphism with an initial segment with Nat that you mention, but it requires <code>decidable_eq</code>.</p>\n</blockquote>\n<p>To respond to the first part: One can use Lean without exploiting non-classical principles. Or has this been outlawed?</p>",
        "id": 328981818,
        "sender_full_name": "Thorsten Altenkirch",
        "timestamp": 1676900118
    },
    {
        "content": "<p>What do you mean by \"without exploiting non-classical principles\"? That sounds like it means \"by only exploiting classical principles\", ie <em>only</em> using<code>classical.choice</code>!</p>",
        "id": 328982251,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1676900256
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271218\">@Thorsten Altenkirch</span> I was hoping to address your original question: \"there doesn't seem to be such a proof in the mathlib. Why is this?\" That seems to me to be a concrete question about mathlib's <code>fintype A</code> and <code>decidable_eq A</code>, but I'm gathering that you're actually asking a counterfactual about why mathlib isn't designed in a different way?</p>\n<p>With classical vs constructive math, I think there's also a third option that we seem to care more about here, which is Lean's computability, i.e., whether there exists a program that's able to compute the value in question while allowing one to rely on classical correctness proofs.</p>\n<p>The <code>Prop.fintype</code> instance is computable in this sense. If you could compute a <code>decidable_eq</code> instance from a <code>fintype</code> instance in a Lean-computable way, then you'd get a Lean-computable decision procedure for every proposition (but we know there can't be such a program!)</p>\n<p>Of course, if you embrace classical proofs and don't care about Lean computability, mathlib has <a href=\"https://leanprover-community.github.io/mathlib_docs/find/classical.dec_eq\">docs#classical.dec_eq</a> as <span class=\"user-mention\" data-user-id=\"243791\">@David Renshaw</span> pointed out, and you don't need a <code>fintype</code> instance for that.</p>",
        "id": 328988952,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1676902125
    },
    {
        "content": "<p>I wasn't intending to ask a general question about mathlib. It just seems to me that if I can constructively prove that A is a fintype then I can also constructively prove that it has a decidable equality. However, it seems that this implication isn't constructively provable in Lean.</p>\n<p>I think constructive and classical Mathematics can live happily next to each other if there is some respect for each other. Forcing everything to be classical for no good reason isn't very respectful.</p>",
        "id": 328996303,
        "sender_full_name": "Thorsten Altenkirch",
        "timestamp": 1676903800
    },
    {
        "content": "<p>One of the main reasons we are classical even when they constructive proof is basically the same as the classical one, is because there are a lot of type class diamonds caused by different ways of proving decidability. This means that rewrites end up failing when there there is a different proof of decidability of the same proposition in the lemma I am using to rewrite and the goal. For example, if I had an instance saying fintypes had decidable equality, then there would be two ways of proving decidable equality of <code>α ⊕ β</code> when α and β are fintypes. One would be via the fact that the sum of fintype is a fintype and the other because the sum of two types with decidable eqaulity has decidable equality.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.fintype.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">logic.equiv.fin</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">fintype2</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span> <span class=\"n\">trunc_fin_equiv</span> <span class=\"o\">:</span> <span class=\"n\">trunc</span> <span class=\"o\">(</span><span class=\"bp\">Σ</span>  <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">≃</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">subsingleton</span> <span class=\"o\">(</span><span class=\"n\">fintype2</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">x</span><span class=\"bp\">;</span> <span class=\"n\">cases</span> <span class=\"n\">y</span><span class=\"bp\">;</span> <span class=\"n\">congr</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">fintype2.decidable_eq</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype2</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">decidable_eq</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"k\">show</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">),</span> <span class=\"k\">from</span>\n  <span class=\"n\">trunc.rec_on_subsingleton</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">fintype2.trunc_fin_equiv</span> <span class=\"n\">α</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">decidable_of_iff</span> <span class=\"o\">(</span><span class=\"n\">e.2.symm</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">e.2.symm</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">))</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">sum.fintype2</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype2</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype2</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">fintype2</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">⊕</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">trunc.rec_on_subsingleton</span>\n  <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">fintype2.trunc_fin_equiv</span> <span class=\"n\">α</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">$</span>\n  <span class=\"n\">trunc.rec_on_subsingleton</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">fintype2.trunc_fin_equiv</span> <span class=\"n\">β</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">eβ</span> <span class=\"n\">eα</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">trunc.mk</span> <span class=\"bp\">$</span>\n        <span class=\"o\">⟨</span><span class=\"n\">eα.1</span> <span class=\"bp\">+</span> <span class=\"n\">eβ.1</span><span class=\"o\">,</span> <span class=\"n\">fin_sum_fin_equiv.symm.trans</span>\n          <span class=\"o\">(</span><span class=\"n\">equiv.sum_congr</span> <span class=\"n\">eα.2</span> <span class=\"n\">eβ.2</span><span class=\"o\">)⟩⟩)</span>\n\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype2</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype2</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"bp\">@</span><span class=\"n\">fintype2.decidable_eq</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">⊕</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"bp\">@</span><span class=\"n\">sum.decidable_eq</span> <span class=\"n\">α</span> <span class=\"n\">_</span> <span class=\"n\">β</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">--fails</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>\n</code></pre></div>",
        "id": 329004011,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1676905647
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271218\">@Thorsten Altenkirch</span> <a href=\"#narrow/stream/113488-general/topic/fintype.20implies.20decidable_eq/near/328996303\">said</a>:</p>\n<blockquote>\n<p>I wasn't intending to ask a general question about mathlib. It just seems to me that if I can constructively prove that A is a fintype then I can also constructively prove that it has a decidable equality.</p>\n</blockquote>\n<p>I think the spelling of \"constructively a fintype\" the you're looking for <a href=\"#narrow/stream/113488-general/topic/fintype.20implies.20decidable_eq/near/328946037\">is <code>fin_enum</code></a>.</p>",
        "id": 329004281,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1676905721
    },
    {
        "content": "<p>No. Being a \"fintype\" constructively is still a proposition (hProp). <code>fin_enum</code> is extra data.</p>",
        "id": 329004649,
        "sender_full_name": "Reid Barton",
        "timestamp": 1676905804
    },
    {
        "content": "<p>It would be <code>trunc (fin_enum A)</code>.</p>",
        "id": 329004865,
        "sender_full_name": "Reid Barton",
        "timestamp": 1676905859
    },
    {
        "content": "<p>This is a very good reason to remain classical in my opinion. It's not much fun battling around these diamonds and we really don't learn very much by battling these diamonds. I think we could be persuaded to remain constructive in many places if type theorists came up with some solution to this diamond problem, although I think any solution would necessarily give up some other nice properties of type checking. We're even thinking of making <code>fintype</code> a strict <code>Prop</code> to get rid of these problems.</p>",
        "id": 329004939,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1676905868
    },
    {
        "content": "<p>What would the point of a <code>Prop</code>ed <code>fintype</code> be given that <code>finite</code> exists (not a rethorical question)?</p>",
        "id": 329006259,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1676906183
    },
    {
        "content": "<p>I think <span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span>' claim is that it was considered to remove <code>fintype</code> entirely and only use <code>finite</code>. Personally I don't think we should do this, but it has certainly been discussed.</p>",
        "id": 329006644,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1676906283
    },
    {
        "content": "<p>I'd pose the question in the other direction; what would be the point in a <code>[constructive_fintype X]</code> given we have <code>[fintype X] [decidable_eq X]</code>?</p>\n<p><span class=\"user-mention silent\" data-user-id=\"271218\">Thorsten Altenkirch</span> <a href=\"#narrow/stream/113488-general/topic/fintype.20implies.20decidable_eq/near/328996303\">said</a>:</p>\n<blockquote>\n<p>Forcing everything to be classical for no good reason isn't very respectful.</p>\n</blockquote>\n<p>I don't think that this applies to requiring a longer spelling.</p>",
        "id": 329007333,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1676906466
    },
    {
        "content": "<p>Ok so the suggestion is that I replace <code>fintype</code> by <code>fin_enum</code>? Is there a proof to show that <code>fin_enum</code> entails <code>decidable_eq</code>.<br>\nOk another option is to define <code>constructive_fintype</code> in the way suggested by <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> In this case I would remark that the current definition of <code>fintype</code> is a bit of an overkill. Instead of referring to a multiset with no duplicates one could just use a list. I thought that the current definition of <code>fintype</code> is just so that we always have <code>decidable_eq</code>.</p>",
        "id": 329389302,
        "sender_full_name": "Thorsten Altenkirch",
        "timestamp": 1677061853
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/fin_enum\">docs#fin_enum</a> indicates that <code>decidable_eq \\alpha</code> is in fact a field of the <code>fin_enum</code> class.<br>\nThis is surprising because my intuition would be that you could derive decidable eq by sending elements through the mapping and using the decidable_eq on <code>fin</code>. Is there a reason why that field has to be there?</p>",
        "id": 329421381,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1677070807
    },
    {
        "content": "<p>Yes, it's for the same reason that <code>pow</code> is a field of <code>monoid</code> even though you can derive it from <code>one</code> and <code>mul</code>. <a href=\"#narrow/stream/113488-general/topic/fintype.20implies.20decidable_eq/near/328839643\">Mario already alluded to that above</a>.</p>",
        "id": 329422297,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1677071067
    },
    {
        "content": "<blockquote>\n<p>Instead of referring to a multiset with no duplicates one could just use a list.</p>\n</blockquote>\n<p>If you do this, then there are two different ways to say that <code>bool</code> is finite; <code>[tt, ff]</code> or <code>[ff, tt]</code>. Using a multiset with no duplicates makes these  two ways equal, but using a list does not.</p>",
        "id": 329422574,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1677071146
    }
]