[
    {
        "content": "<p>In PhysLean there is currently a large definition consisting of a lot of instances of a given data type satisfying certain conditions (related to something in string theory). See the link below:</p>\n<ul>\n<li><a href=\"https://github.com/HEPLean/PhysLean/blob/master/PhysLean/StringTheory/FTheory/SU5U1/Charges/PhenoConstrained/Elems/Basic.lean\">https://github.com/HEPLean/PhysLean/blob/master/PhysLean/StringTheory/FTheory/SU5U1/Charges/PhenoConstrained/Elems/Basic.lean</a></li>\n</ul>\n<p>I am slightly worried about the potential consequences that having such a large definition might have long term. Are there any which spring to mind, which means things like this should be avoided? The quantity being defined appears in a fair number of lemmas, if that makes a difference.</p>",
        "id": 522323840,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1749033605
    },
    {
        "content": "<p>I don't think there is really any problem with long definitions, as long as the definition itself compiles fine, and cannot naturally be broken in smaller parts.<br>\nYou could consider making it an <code>@[irreducible] def</code> (or even stronger, an <code>irreducible_def</code>), so that Lean will never unfold it, without you explicitly specifying that you want it to be unfolded.</p>",
        "id": 522324952,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1749033907
    },
    {
        "content": "<p>Largely, the problems will come down to readability and ... reducibility has a technical meaning in Lean, let's say \"separability\" instead. </p>\n<p>Basically, when you do proofs with that definition, are you ever going to have to take it apart and inspect its pieces, or will you basically always be working with it as an opaque object? If the former, then doing so with a definition that big will be incredibly obnoxious and you should endeavor to split it up; if the latter, then there's probably no real harm, though as Floris suggests <code>irreducible_def</code> may be warranted.</p>",
        "id": 522325221,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1749033982
    },
    {
        "content": "<p>Ok, many thanks both! I think it has the potential to give a <code>Stack overflow</code> error if it gets too big, but this is fine since at least it tells me something is wrong. </p>\n<p>The sorts of proofs it appears in are of the form: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">isComplete_of_mem_nonPhenoConstrainedCharge_nextToNearestNeighbor</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">nonPhenoConstrainedCharges</span><span class=\"w\"> </span><span class=\"n\">nextToNearestNeighbor</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toMultiset</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">IsComplete</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">decide</span>\n</code></pre></div>\n<p>basically running over all elements and testing them for a condition. I'm making sure that these don't go over the heatbeat count limit so they are 'safe' in that sense. </p>\n<p>I'll mess around wtih making things irreducible. Thanks again.</p>",
        "id": 522326293,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1749034282
    }
]