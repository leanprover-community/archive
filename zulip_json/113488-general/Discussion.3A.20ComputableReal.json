[
    {
        "content": "<p>Making a thread for <a href=\"https://github.com/Timeroot/ComputableReal\">ComputableReal</a>, in case anyone has questions about it. :)</p>",
        "id": 499057614,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1739293725
    },
    {
        "content": "<p>This is very cool -- could you write a little about the representation you're using?</p>",
        "id": 499071177,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1739297778
    },
    {
        "content": "<p>Nice! It looks like you're using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=NonemptyInterval#doc\">docs#NonemptyInterval</a>, which makes me feel a bit proud <span aria-label=\"blush\" class=\"emoji emoji-1f60a\" role=\"img\" title=\"blush\">:blush:</span></p>",
        "id": 499071987,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1739298098
    },
    {
        "content": "<p>Your instance <a href=\"https://github.com/Timeroot/ComputableReal/tree/main/ComputableReal#L16-L22\">here</a> duplicates <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>'s instance from <a href=\"https://github.com/leanprover-community/mathlib4/pull/20636\">#20636</a>. Would you be interested in getting the PR over the line?</p>",
        "id": 499072092,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1739298125
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110596\">@Rob Lewis</span> I just finished writing a Readme that I hope helps: <a href=\"https://github.com/Timeroot/ComputableReal/blob/main/README.md\">https://github.com/Timeroot/ComputableReal/blob/main/README.md</a></p>",
        "id": 499073012,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1739298444
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> : Sure! I tried proving that multiplication was associative, though, and it kind of blew up. Just a whole lot of different cases and not an obvious easy way to clean things up. So I don't know how easy getting the <code>Semiring</code> instance on intervals would be.</p>",
        "id": 499073377,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1739298572
    },
    {
        "content": "<p>As a good practice, I’d also include a license, probably Apache to match the ecosystem</p>",
        "id": 499074885,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1739299069
    },
    {
        "content": "<p>I know nothing about this sort of thing, but would it be possible to make <code>decide</code> work? I can't use theorems which are only proved using <code>native_decide</code> because it's easy to prove <code>False</code> using it.</p>",
        "id": 499079925,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1739300799
    },
    {
        "content": "<p>Yes, it should be! Right now there are a couple of 'bad decidability instances' in Mathlib that don't play well decide (but native_decide isn't so picky), but that should be a pretty quick PR.</p>",
        "id": 499080234,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1739300912
    },
    {
        "content": "<p>No promises that it will be particularly efficient. The code was written to be efficient when compiled, but I have no idea how decide will do with it.</p>",
        "id": 499080404,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1739300994
    },
    {
        "content": "<blockquote>\n<p>But most real numbers of interest can be computed.</p>\n</blockquote>\n<p>In my line of work, many <em>natural</em> numbers of interest cannot be computed! They are \"the number of solutions to this polynomial equation\" and there are no known (provably correct) algorithms for answering questions such as this. For example there are certainly only finitely many rational solutions to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>x</mi><mn>4</mn></msup><mo>+</mo><msup><mi>y</mi><mn>4</mn></msup><mo>=</mo><mn>17</mn></mrow><annotation encoding=\"application/x-tex\">x^4+y^4=17</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8974em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">4</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0085em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">4</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">17</span></span></span></span> by a deep theorem of Faltings, but figuring out how many there are is a very different game.</p>",
        "id": 499082517,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1739301761
    },
    {
        "content": "<p>I am trying to test this out (this was a goal I needed for Carleson a few weeks ago), but I am getting the following error message</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">ComputableReal</span><span class=\"bp\">.</span><span class=\"n\">ComputableRSeq</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">ComputableReal</span><span class=\"bp\">.</span><span class=\"n\">ComputableReal</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">ComputableReal</span><span class=\"bp\">.</span><span class=\"n\">IsComputable</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">ComputableReal</span><span class=\"bp\">.</span><span class=\"n\">SpecialFunctions</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">sqrt</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"c1\">--true inequality, good</span>\n<span class=\"w\">  </span><span class=\"n\">native_decide</span><span class=\"w\"> </span><span class=\"c1\">-- works</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">geom_estimate_constant_le_two</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">native_decide</span><span class=\"w\"> </span><span class=\"c1\">-- failed to compile definition, consider marking it as 'noncomputable' because it depends on 'Real.instDivInvMonoid', and it does not have executable code</span>\n</code></pre></div>",
        "id": 499083556,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1739302095
    },
    {
        "content": "<p>I would say that all those real numbers can be computed, but we simply don't know how! Certainly for any natural number, there's an algorithm that computes it. That might feel pedantic, but I do think that's the standard meaning of \"computable number\" as it shows up in complexity theory.</p>\n<p>I understand your intent, though... like there's some function that takes certain integer data (like coefficients of some polynomial equation) and gives you a natural number (the number of solutions) that are not known to be computable. And in some cases, of course, is known not to be computable.</p>",
        "id": 499083564,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1739302099
    },
    {
        "content": "<p>Ah, perhaps negative powers simply aren't supported yet? (A more careful reading of the README on my part tells me this is the case)</p>",
        "id": 499083650,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1739302140
    },
    {
        "content": "<p>Bolton: rational powers aren't supported at the moment. :/ But negative integers are</p>",
        "id": 499083696,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1739302157
    },
    {
        "content": "<p>If that's what computed means then is it possible to give <em>any</em> example of a real number which can't be computed in that sense?</p>",
        "id": 499083787,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1739302197
    },
    {
        "content": "<p>Sure, like Chaitin's constant. The existence of an algorithm that computes a convergent sequence of bounds on that constant, would necessarily also give you an algorithm to solve the halting problem.</p>",
        "id": 499084063,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1739302300
    },
    {
        "content": "<p>Regardless of the feature set, this is awesome! I have wanted something like this since at least 2021. Are you accepting contributions?</p>",
        "id": 499084906,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1739302631
    },
    {
        "content": "<p>Gladly! <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 499084953,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1739302650
    },
    {
        "content": "<p>Is replacing mathlib's Real with your version a viable option in the longer term?</p>",
        "id": 499088212,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739303884
    },
    {
        "content": "<p>(if I understand correctly, instead of storing one cauchy sequence, you store two where one is pointwise less than or equal the other?)</p>",
        "id": 499088395,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739303961
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113488-general/topic/Discussion.3A.20ComputableReal/near/499083787\">said</a>:</p>\n<blockquote>\n<p>If that's what computed means then is it possible to give <em>any</em> example of a real number which can't be computed in that sense?</p>\n</blockquote>\n<p>yes. since there are countably many possible computations, and uncountably many reals, there must be uncountably many that aren't represented by a computation.</p>",
        "id": 499088480,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1739303999
    },
    {
        "content": "<p>When I first saw this I found it a bit unbelievable, since it seems to claim that real number equality is decidable by reduction to computable reals, but equality of computable reals is also undecidable. Turns out the trick is that it's not actually a decision procedure, there is a way to trick the compiler into compiling a nonterminating function for the decision procedure and thereby getting a lean-computable <code>Decidable</code> instance which isn't a decision procedure</p>",
        "id": 499088798,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739304092
    },
    {
        "content": "<p>But I agree with Eric, we should make this the actual definition of reals, because it will allow us to make lots of things computable which is otherwise a bit of a pain to work around and a new keyword to learn about</p>",
        "id": 499088952,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739304155
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/113488-general/topic/Discussion.3A.20ComputableReal/near/499088395\">said</a>:</p>\n<blockquote>\n<p>(if I understand correctly, instead of storing one cauchy sequence, you store two where one is pointwise less than or equal the other?)</p>\n</blockquote>\n<p>Almost - just being pointwise less isn't enough (indeed I made that mistake at first), the lower bounds need to be less than the point they converge to. For instance, a sequence of lower bounds on pi couldn't include 3.2, even if the upper bound at that point in the sequence was 3.5.</p>",
        "id": 499088965,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1739304162
    },
    {
        "content": "<p>It should be possible to require that the sequences are monotonic</p>",
        "id": 499089059,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739304206
    },
    {
        "content": "<p>Do your sequences have a modulus of convergence?</p>",
        "id": 499089127,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739304237
    },
    {
        "content": "<p>I'm inclined to think they should</p>",
        "id": 499089194,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739304247
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Discussion.3A.20ComputableReal/near/499088798\">said</a>:</p>\n<blockquote>\n<p>When I first saw this I found it a bit unbelievable, since it seems to claim that real number equality is decidable by reduction to computable reals, but equality of computable reals is also undecidable. Turns out the trick is that it's not actually a decision procedure, there is a way to trick the compiler into compiling a nonterminating function for the decision procedure and thereby getting a lean-computable <code>Decidable</code> instance which isn't a decision procedure</p>\n</blockquote>\n<p>I guess this is an argument for the semidecision procedures discussed elsewhere?</p>",
        "id": 499089306,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739304299
    },
    {
        "content": "<p>I think that wouldn't help here</p>",
        "id": 499089361,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739304319
    },
    {
        "content": "<p>you can't ever return <code>none</code> from functions that observe the cauchy sequences because it will usually have to depend on the details of the sequence, so it won't be stable under the quotient</p>",
        "id": 499089540,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739304381
    },
    {
        "content": "<p>Yeah, you can require monotonicity, and you can also make a sort of wrapper to turn any non-monotonic form into a monotonic form by just keeping the best bound found so far. The reason I didn't do this in this package was</p>\n<ul>\n<li>If you require monotonicity, then you also to prove that the sequences are monotonic at each step, and that's a considerable extra burden</li>\n<li>If you don't require it, but do the wrapping, then you get a nonnegligble extra computational overhead ... unless you're careful+smart about how you store that running bound.</li>\n</ul>",
        "id": 499089569,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1739304396
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/113488-general/topic/Discussion.3A.20ComputableReal/near/499088952\">said</a>:</p>\n<blockquote>\n<p>But I agree with Eric, we should make this the actual definition of reals, because it will allow us to make lots of things computable which is otherwise a bit of a pain to work around and a new keyword to learn about</p>\n</blockquote>\n<p>I'm surprised to hear you both say this! Personally I don't think it's very viable or useful to replace Mathlib's Real with this in the long term. It's possible in principle - one can classically prove that \"all reals are computable\", in the same way that \"all propositions are <code>Decidable</code>\" - but I don't know what it would get you, really. I also think that, architecturally, _first_ defining reals (so that you have the nice existence and topology and theory of them) and _then_ talking about which ones can be computed, works out better.</p>",
        "id": 499089855,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1739304496
    },
    {
        "content": "<p>If you have a fixed rate of convergence, I think you can get away with just having one sequence instead of two</p>",
        "id": 499089909,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739304516
    },
    {
        "content": "<p>and you get monotonicity for free</p>",
        "id": 499089963,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739304535
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113488-general/topic/Discussion.3A.20ComputableReal/near/499083787\">said</a>:</p>\n<blockquote>\n<p>If that's what computed means then is it possible to give <em>any</em> example of a real number which can't be computed in that sense?</p>\n</blockquote>\n<p>looking into it a bit, <a href=\"https://en.wikipedia.org/wiki/Chaitin%27s_constant\">Chaitin's constant</a> is one among several \"concrete\" examples of noncomputable reals</p>",
        "id": 499090191,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1739304608
    },
    {
        "content": "<p>Yeah, I definitely don't want to have a requirement on rate of convergence, since there are some computable functions that don't \"naturally\" have fast convergence -- so then you need something where you accelerate the sequence (I think that's the technical term for it) to get the desired rate</p>",
        "id": 499090197,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1739304611
    },
    {
        "content": "<p>that is, it's a sequence of integers <code>a : Nat -&gt; Int</code> such that <code>x * 2^n</code> is within <code>1</code> of <code>a n</code></p>",
        "id": 499090208,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739304615
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"448405\">Alex Meiburg</span> <a href=\"#narrow/channel/113488-general/topic/Discussion.3A.20ComputableReal/near/499090197\">said</a>:</p>\n<blockquote>\n<p>Yeah, I definitely don't want to have a requirement on rate of convergence, since there are some computable functions that don't \"naturally\" have fast convergence -- so then you need something where you accelerate the sequence (I think that's the technical term for it) to get the desired rate</p>\n</blockquote>\n<p>This is another trivial wrapper operation, like the monotonicity one you mentioned</p>",
        "id": 499090289,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739304648
    },
    {
        "content": "<p>Just to be clear: this definition does not give computable reals, it gives all reals. The computable reals are the ones where you can write down the definition of the real number without using <code>noncomputable</code> (assuming you don't cheat)</p>",
        "id": 499090726,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739304810
    },
    {
        "content": "<p>Yes, maybe I should make that more clear in the Readme, that it doesn't let you actually prove computability or anything.</p>",
        "id": 499090793,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1739304841
    },
    {
        "content": "<p>So it would work out fine as a replacement for mathlib reals, at least from the perspective of provable theorems</p>",
        "id": 499090808,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739304843
    },
    {
        "content": "<p>and I do like the idea that you can do computations on reals and run <code>#eval</code> and get an answer that isn't useless</p>",
        "id": 499090901,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739304882
    },
    {
        "content": "<p>I think there's a natural sort of tension between \"definition of reals that lets you prove theorems easily\" and \"definition of reals that lets you compute things quickly\". Of course with enough theorems, you can reproduce the current <code>Real</code> API 100%, so the first point would become moot. So I'm still skeptical</p>",
        "id": 499091322,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1739305047
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/channel/113488-general/topic/Discussion.3A.20ComputableReal/near/499088480\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113488-general/topic/Discussion.3A.20ComputableReal/near/499083787\">said</a>:</p>\n<blockquote>\n<p>If that's what computed means then is it possible to give <em>any</em> example of a real number which can't be computed in that sense?</p>\n</blockquote>\n<p>yes. since there are countably many possible computations, and uncountably many reals, there must be uncountably many that aren't represented by a computation.</p>\n</blockquote>\n<p>I'm well aware that there must <em>exist</em> noncomputable reals, I'm just saying that when you're talking about a specific real number rather than a generic one (I'm interpreting a \"real number of interest\" as \"not an arbitrary real number\") then somehow it <em>must</em> be computable by your definition, because the very fact that you're talking about it means that it's somehow been uniquely expressed in your system.</p>",
        "id": 499091483,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1739305110
    },
    {
        "content": "<p>I think that's the notion of \"definable real\", which is a countable strict superset of the computable reals.</p>",
        "id": 499091612,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1739305169
    },
    {
        "content": "<p>that's not true. see above mentioned \"Chaitin's constant\"</p>",
        "id": 499091671,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1739305193
    },
    {
        "content": "<p>also, numbers like \"the real number whose binary representation encodes the solution to the halting problem\" and variants</p>",
        "id": 499091793,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1739305235
    },
    {
        "content": "<p>those are definitely definable, but not computable</p>",
        "id": 499091848,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1739305260
    },
    {
        "content": "<p>An implementation of computable reals in Common Lisp can be found <a href=\"https://github.com/stylewarning/computable-reals\">here</a> (this is based on code I wrote a long time ago...). From the README:</p>\n<blockquote>\n<p>Computable real numbers <code>x</code> are interpreted as (potentially) infinite fractions in base 2 that are specified through a rule for computation of an integer <code>a</code> with <code>|(2^k)*x - a| &lt;= 1</code> for any <code>k&gt;=0</code>.</p>\n</blockquote>\n<p>This is quite close to what Mario wrote above. (This is, of course, a bit off-topic here, but may provide some inspiration.)</p>",
        "id": 499095903,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1739307040
    },
    {
        "content": "<p>I'm not sure I would say it is off topic! Formalization is at least 70% imitation of things that have been done before in a different way</p>",
        "id": 499096571,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739307333
    },
    {
        "content": "<p>I think there is also a <a href=\"https://hackage.haskell.org/package/exact-real\">computable reals library in haskell</a> somewhere, it's probably worth reviewing existing libraries if we want to find a good representation</p>",
        "id": 499096845,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739307435
    },
    {
        "content": "<p>There's a long line of research into computable representations of the reals and no obvious \"best\" option, it really depends on your applications. My memory is that Cauchy sequences with a fixed modulus of convergence are a compromise that allow for a little computation in practice, without <em>horribly</em> complicating your proofs.</p>",
        "id": 499097753,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1739307761
    },
    {
        "content": "<p>I'm no expert here, but there are pointers to a bunch of different approaches in the <a href=\"https://www.cirm-math.fr/ProgWeebly/Renc1508/Abstracts1508.pdf\">proceedings of a CIRM meeting</a> I went to ages ago.</p>",
        "id": 499097903,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1739307822
    },
    {
        "content": "<p>One nice thing that the decidability trick adds to the equation is the ability to actually get digit representations out of the quotient, so this would eliminate the need for our <code>unsafe</code> <code>Repr Real</code> instance</p>",
        "id": 499098066,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739307870
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113488-general/topic/Discussion.3A.20ComputableReal/near/499079925\">said</a>:</p>\n<blockquote>\n<p>I know nothing about this sort of thing, but would it be possible to make <code>decide</code> work? I can't use theorems which are only proved using <code>native_decide</code> because it's easy to prove <code>False</code> using it.</p>\n</blockquote>\n<p>Hmm, maybe not so easy. I thought it was a bad decidability instance -- it wasn't, my mistake. I think the actual issue is that <code>ComputableRSeq.sign</code> is (by necessity) a <code>partial</code> def. It seems that <code>decide</code> and <code>decide +kernel</code> won't look inside those. The docs say,</p>\n<blockquote>\n<p><code>Decidable</code> instances defined by well-founded recursion might not work because evaluating them requires reducing proofs.</p>\n</blockquote>\n<p>which hadn't clicked for me before <code>partial</code> isn't well-founded recursion. Well, it's not-well-founded recursion, which I suppose makes it strictly worse!</p>",
        "id": 499098167,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1739307912
    },
    {
        "content": "<p>You are right, this trick will not work in the kernel. However, you can still do proofs using it using a slightly different interface, which takes a fuel amount as input and produces a maybe-proof, and if the fuel is high enough then you get your proof (and a tactic can hide the details of that)</p>",
        "id": 499098706,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739308126
    },
    {
        "content": "<p>that was always how I wanted the <code>approx</code> tactic to work</p>",
        "id": 499098742,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739308141
    },
    {
        "content": "<p>Discussion on encoding possibly-non-terminating computations in an optimal way is happening here: <a class=\"stream-topic\" data-stream-id=\"217875\" href=\"/#narrow/channel/217875-Is-there-code-for-X.3F/topic/Divergence.20monad\">#Is there code for X? &gt; Divergence monad</a></p>",
        "id": 499102959,
        "sender_full_name": "Niels Voss",
        "timestamp": 1739309978
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/113488-general/topic/Discussion.3A.20ComputableReal/near/499088212\">said</a>:</p>\n<blockquote>\n<p>Is replacing mathlib's Real with your version a viable option in the longer term?</p>\n</blockquote>\n<p>This is the current design in Coq, and generally the philosophy of Bishop's mathematics. By just adding excluded middle, one obtains the classical results.</p>",
        "id": 499178003,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1739350447
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"448405\">@Alex Meiburg</span> I'm curious how your timings compare to the ones we obtained in MathClasses(<a href=\"https://math-classes.github.io/\">https://math-classes.github.io/</a>). Specifically: <a href=\"https://lmcs.episciences.org/958\">https://lmcs.episciences.org/958</a><br>\nIs this was 12 years ago, you should get a good speed-up due to Moore's law.</p>",
        "id": 499178892,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1739350722
    },
    {
        "content": "<p>I'm happy to see someone's working on this! (I was thinking about this topic a lot, but never started it.)<br>\nThe fastest non-lean library I know which computes reals is <a href=\"https://github.com/fbrausse/iRRAM\">iRRAM</a>. Maybe one can compare or get an idea from this library?<br>\nAlso some reference: <a href=\"https://link.springer.com/book/10.1007/978-3-642-56999-9\">Computable Analysis: An Introduction</a></p>",
        "id": 499181086,
        "sender_full_name": "Jihoon Hyun",
        "timestamp": 1739351447
    },
    {
        "content": "<p>We tried to explain some of the issues with real computation and non-computable numbers <a href=\"https://www.cambridge.org/core/services/aop-cambridge-core/content/view/1B0646044D6107F20A3834149E257748/S0960129506005834a.pdf/div-class-title-constructive-analysis-types-and-exact-real-numbers-div.pdf\">here</a></p>",
        "id": 499182287,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1739351829
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"574112\">@Jihoon Hyun</span> the main observation in iRRAM is that one does forward computation. One tries single precision interval arithmetic. If this in not good enough, one starts over with double precision. The usual Cauchy representation computes backwards.</p>",
        "id": 499182659,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1739351934
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"574112\">@Jihoon Hyun</span> Competition between the various systems:<br>\n<a href=\"https://www.cs.ru.nl/~freek/pubs/comp_rep.pdf\">https://www.cs.ru.nl/~freek/pubs/comp_rep.pdf</a></p>",
        "id": 499183068,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1739352075
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"448405\">@Alex Meiburg</span> You should be able to get a substantial speed boost by using dyadic rationals. (at least that was the case for us).</p>\n<p>Your approach using an IsComputable type class seems similar that <a href=\"https://jfr.unibo.it/article/view/1411\">computing with classical reals</a> in Coq.</p>",
        "id": 499183901,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1739352334
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/113488-general/topic/Discussion.3A.20ComputableReal/near/499098706\">said</a>:</p>\n<blockquote>\n<p>You are right, this trick will not work in the kernel. However, you can still do proofs using it using a slightly different interface, which takes a fuel amount as input and produces a maybe-proof, and if the fuel is high enough then you get your proof (and a tactic can hide the details of that)</p>\n</blockquote>\n<p>I thought about this some more. Yeah, doing it with a tactic is always one way to go about it, but I am quite keen on making this work with <code>decide</code> in particular since then it's part of this nice system. I think it can be made to work with fuel in this kind of way -- something like (getting of pseudocode-y here)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">--Partial decidable statements: you may or may not get a decidable witness out</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">PDecidable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Decicdable</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">PDecidableLE</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PDecidableLE</span><span class=\"w\"> </span><span class=\"n\">ComputableReal</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">   </span><span class=\"n\">checkSignWithFuel</span><span class=\"w\"> </span><span class=\"mi\">100000</span><span class=\"w\"> </span><span class=\"c1\">--gives `some Decidable` if we successfully proved/disproved it, otherwise `none`</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">Decidable_of_PDecidable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">pd</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PDecidable</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Decidable</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">   </span><span class=\"bp\">@</span><span class=\"n\">decidable_of_iff</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"bp\">.</span><span class=\"n\">isSome</span><span class=\"w\"> </span><span class=\"n\">pd</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">dite_eq_ite</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ite_self</span><span class=\"o\">])</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">instDecidableDite</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">dT</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">dE</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">propDecidable</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>So then when <code>decide</code> runs, it will first evaluate the <code>PDecidable</code> with the given fuel, if it works and gets <code>some</code> Decidable then it uses that, otherwise it falls back to <code>Classical.propDecidable</code> and then gives up and fails. I tried this out on some toy examples, this seems to work with decide just fine!</p>",
        "id": 499705264,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1739530484
    },
    {
        "content": "<p>Of course it <em>doesn't</em> work with native_decide, since that requires everything to be computable at compile-time, and Classical.propDecidable isn't. And because there is no complete decision procedure for reals, you can't have an instance that works both with decide and native_decide.</p>\n<p>I think making each of these decidability instances a separate scoped instance is a good solution then. (I also, in general, think that it should be scoped anyway, because having a not-necessarily-terminating instance \"running wild\" does make me a bit uncomfortable.)</p>",
        "id": 499705736,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1739530599
    },
    {
        "content": "<p>So then it would be something like</p>\n<div class=\"codehilite\" data-code-language=\"open\"><pre><span></span><code>theorem : .... := by\n   decide\n</code></pre></div>\n<p>and</p>\n<div class=\"codehilite\" data-code-language=\"open\"><pre><span></span><code>theorem : .... := by\n   native_decide\n</code></pre></div>\n<p>and they should both work.</p>",
        "id": 499705915,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1739530645
    },
    {
        "content": "<p>Just a thought, but could you replace the <code>Classical.propDecidable</code> in your instance with a <code>partial def</code>? From the perspective of the kernel, <code>partial def</code> is pretty similar to something produced by choice, but it lets the compiler keep going.</p>",
        "id": 499814558,
        "sender_full_name": "Niels Voss",
        "timestamp": 1739562092
    },
    {
        "content": "<p>You would use <code>Classical.propDecidable</code> to prove that such a decidability instance actually exists (since <code>partial def</code> needs a Nonempty instance) but you don't need to mark anything <code>noncomputable</code></p>",
        "id": 499814826,
        "sender_full_name": "Niels Voss",
        "timestamp": 1739562214
    },
    {
        "content": "<p>That's true, I could do that! Or in other words, just make the <code>native_decide</code> instance be the fallback.</p>",
        "id": 499829791,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1739567173
    },
    {
        "content": "<p>Then <code>decide</code> will use up the fuel, and if it hasn't determined an answer, hit the partial def and quit. But native_decide will be free to use the partial def and keep going arbitrarily long (at the slight expense of redoing the first <code>fuel</code> many steps of the process, maybe)</p>",
        "id": 499830077,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1739567285
    },
    {
        "content": "<p>it won't quit at the partial def, it will loop</p>",
        "id": 499830198,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739567337
    },
    {
        "content": "<p>Why would it loop? decide sees an opaque def and gets stuck</p>",
        "id": 499830418,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1739567424
    },
    {
        "content": "<p>right, sorry for the confusion. So here's a toy version of your program then:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">findTrue</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Decidable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">isTrue</span><span class=\"w\"> </span><span class=\"bp\">⟨_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">findTrue</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">findTrueWithFuel</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Decidable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">findTrue</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">fuel</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">isTrue</span><span class=\"w\"> </span><span class=\"bp\">⟨_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">findTrueWithFuel</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">fuel</span>\n</code></pre></div>",
        "id": 499831246,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739567755
    },
    {
        "content": "<p>and the latter function works in both the kernel and the compiler if you give it enough fuel</p>",
        "id": 499831385,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739567803
    },
    {
        "content": "<p>Yeah, I think that's an accurate picture</p>",
        "id": 499831473,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1739567843
    },
    {
        "content": "<p>and of course a good compiler should notice that the function can only ever return <code>isTrue</code> and compile it to just return true <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 499831712,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739567956
    },
    {
        "content": "<p>Haha, in the toy example, yes. :) But in my case it can return true or false. (If the lower and upper bounds are both equal to 0 at some point, then we know the true real value is zero, and so can we prove equality.)</p>",
        "id": 499831977,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1739568048
    },
    {
        "content": "<p>Wait, if the compiler would make it return true instead of entering an infinite loop, wouldn't that make it easy to prove <code>False</code> with <code>native_decide</code> by taking a sequence of all falses and showing it must be true at some point?</p>",
        "id": 499834428,
        "sender_full_name": "Niels Voss",
        "timestamp": 1739568917
    },
    {
        "content": "<p>infinite loops are UB in C, which allows for some very powerful (or unsound, depending on who you ask) optimizations</p>",
        "id": 499853024,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739576986
    },
    {
        "content": "<p>and lean compiles to C, so...</p>",
        "id": 499853112,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739577014
    },
    {
        "content": "<p>Good news, it does not seem to let you use native_decide to prove False .... at the moment. (I agree, it seems tenuous, like a slight change in compiler could mess it up.) Bad news: you can write fine code with no sorries and then running #eval throws an <code>unreachable code</code> error.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">isZeroOne</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">true</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">isZeroOne</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">decZeroOne</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Decidable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">decidable_of_iff</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">isZeroOne</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[(</span><span class=\"n\">isZeroOne</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"bp\">⟩</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">decZeroOne</span><span class=\"w\"> </span><span class=\"c1\">--unreachable code</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">zero_is_one</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"c1\">-- native_decide --hangs</span>\n</code></pre></div>\n<p>(Tried this in Lean4 web, live)</p>",
        "id": 499853575,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1739577275
    },
    {
        "content": "<p>GCC gets close, but does not seem to perform the optimization I was hoping to see.</p>\n<p>lean:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"n\">b</span>\n</code></pre></div>\n<p>C:</p>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"kt\">uint8_t</span><span class=\"w\"> </span><span class=\"nf\">l_foo</span><span class=\"p\">(</span><span class=\"kt\">uint8_t</span><span class=\"w\"> </span><span class=\"n\">x_1</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"nl\">_start</span><span class=\"p\">:</span>\n<span class=\"p\">{</span>\n<span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">x_1</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n<span class=\"k\">goto</span><span class=\"w\"> </span><span class=\"n\">_start</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n<span class=\"k\">else</span>\n<span class=\"p\">{</span>\n<span class=\"kt\">uint8_t</span><span class=\"w\"> </span><span class=\"n\">x_3</span><span class=\"p\">;</span>\n<span class=\"n\">x_3</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span>\n<span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">x_3</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>GCC -O2:</p>\n<div class=\"codehilite\" data-code-language=\"GAS\"><pre><span></span><code><span class=\"nl\">l_foo:</span>\n<span class=\"w\">        </span><span class=\"nf\">cbz</span><span class=\"w\">     </span><span class=\"no\">r0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"no\">.L3</span>\n<span class=\"w\">        </span><span class=\"nf\">movs</span><span class=\"w\">    </span><span class=\"no\">r0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">#1</span>\n<span class=\"w\">        </span><span class=\"nf\">bx</span><span class=\"w\">      </span><span class=\"no\">lr</span>\n<span class=\"nl\">.L3:</span>\n<span class=\"w\">        </span><span class=\"nf\">b</span><span class=\"w\">       </span><span class=\"no\">.L3</span>\n</code></pre></div>\n<p>The last two lines are the infinite loop. It got optimized to <code>if b then true else loop()</code> while I was hoping it would just be <code>true</code>, which should be legal per the C spec</p>",
        "id": 499854819,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739577897
    },
    {
        "content": "<p>If you use <code>#eval</code> is the compiler being invoked, or does it use some other sort of code runner? I thought I read somewhere that there were a couple different ways to run Lean code, but maybe I'm misremembering.</p>\n<p>As for the C code, maybe try turning up to max compiler optimizations to see if it performs the loop optimization then?</p>",
        "id": 499855007,
        "sender_full_name": "Niels Voss",
        "timestamp": 1739577986
    },
    {
        "content": "<p><code>#eval</code> uses the lean compiler pipeline as far as generating optimized IR, then runs the interpreter</p>",
        "id": 499855058,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739578018
    },
    {
        "content": "<p>above I'm showing the result of compilation to C, which you won't be running if you use <code>#eval</code></p>",
        "id": 499855104,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739578037
    },
    {
        "content": "<p>the lean compiler is actually quite conservative around partial defs because it has been hit in the past by bugs exactly like the ones we're talking about</p>",
        "id": 499855196,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739578083
    },
    {
        "content": "<p>Alex Meiburg <a href=\"#narrow/stream/113488-general/topic/Discussion.3A.20ComputableReal/near/499853575\">said</a>:</p>\n<blockquote>\n<p>Good news, it does not seem to let you use native_decide to prove False .... at the moment. (I agree, it seems tenuous, like a slight change in compiler could mess it up.) Bad news: you can write fine code with no sorries and then running #eval throws an <code>unreachable code</code> error.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">isZeroOne</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">true</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">isZeroOne</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">decZeroOne</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Decidable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">decidable_of_iff</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">isZeroOne</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[(</span><span class=\"n\">isZeroOne</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"bp\">⟩</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">decZeroOne</span><span class=\"w\"> </span><span class=\"c1\">--unreachable code</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">zero_is_one</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"c1\">-- native_decide --hangs</span>\n</code></pre></div>\n<p>(Tried this in Lean4 web, live)</p>\n</blockquote>\n<p>From the docstring of <code>lcUnreachable</code>:</p>\n<p>Executing this expression to actually synthesize a value of type α causes <strong>immediate undefined behavior</strong>, and the compiler does take advantage of this to optimize the code assuming that it is not called. If it is not optimized out, it is likely to appear as a print message saying \"unreachable code\", but this behavior is not guaranteed or stable in any way.</p>",
        "id": 499855276,
        "sender_full_name": "Niels Voss",
        "timestamp": 1739578117
    },
    {
        "content": "<p>So unfortunately, it is indeed UB</p>",
        "id": 499855332,
        "sender_full_name": "Niels Voss",
        "timestamp": 1739578147
    },
    {
        "content": "<p>I wrote that line :)</p>",
        "id": 499855355,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739578159
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/113488-general/topic/Discussion.3A.20ComputableReal/near/499855196\">said</a>:</p>\n<blockquote>\n<p>the lean compiler is actually quite conservative around partial defs because it has been hit in the past by bugs exactly like the ones we're talking about</p>\n</blockquote>\n<p>but I suspect this is not good enough because it generates infinite loops without any operations in them in generated C code, so the C compiler that runs on this will not necessarily be similarly conservative</p>",
        "id": 499855523,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739578232
    },
    {
        "content": "<p>but it seems Alex found a bug in the lean compiler anyway</p>",
        "id": 499855585,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739578271
    },
    {
        "content": "<p>I'm more than slightly proud of this. :)</p>",
        "id": 499855837,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1739578439
    },
    {
        "content": "<p>I am just now realizing how even the slightest mistake in an @implemented_by clause (which I think you or someone else called a \"compiler axiom\") can lead to UB. I always knew it could cause the proof semantics to mismatch the program semantics, but I didn't realize it could lead to UB</p>",
        "id": 499855893,
        "sender_full_name": "Niels Voss",
        "timestamp": 1739578447
    },
    {
        "content": "<p>I probably should have known though because unwrapping a <code>Part</code> can lead to UB, as discussed in the other thread linked above</p>",
        "id": 499855984,
        "sender_full_name": "Niels Voss",
        "timestamp": 1739578510
    },
    {
        "content": "<p>here's an easy example of UB from any kind of divergence between compiler semantics and proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">liarImp</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"kd\">@[</span><span class=\"n\">implemented_by</span><span class=\"w\"> </span><span class=\"n\">liarImp</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">liar</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">false</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">][</span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">liar</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"mi\">1000</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- 727562280</span>\n</code></pre></div>",
        "id": 499856159,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739578602
    },
    {
        "content": "<p>Is this related to <code>Array</code> being defined outside Lean? Does it still cause UB for <code>List</code>?</p>",
        "id": 499856670,
        "sender_full_name": "Niels Voss",
        "timestamp": 1739578896
    },
    {
        "content": "<p>it manifests differently, but both are UB</p>",
        "id": 499856700,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739578920
    },
    {
        "content": "<p>Array makes it easy to do arbitrary buffer overruns</p>",
        "id": 499856781,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739578944
    },
    {
        "content": "<p>with <code>List</code> you unwrap an option that isn't an option resulting in a pointer dereference of something that isn't a pointer</p>",
        "id": 499856829,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739578972
    },
    {
        "content": "<p>which you can also weaponize with some ingenuity</p>",
        "id": 499856841,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739578984
    },
    {
        "content": "<p>Those both require implemented_by or unsafe calls, right?</p>",
        "id": 499857064,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1739579121
    },
    {
        "content": "<p>or compiler bugs</p>",
        "id": 499857599,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739579421
    },
    {
        "content": "<p>Right haha</p>",
        "id": 499857629,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1739579442
    },
    {
        "content": "<p>anything leading to some decidable property which evaluates to true and is provably false</p>",
        "id": 499857641,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739579450
    },
    {
        "content": "<p>not having any such thing is a really strong constraint on lean code, it means for example that you can't convert a Float to a UInt64 without masking out nans</p>",
        "id": 499857864,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739579561
    },
    {
        "content": "<p>Infinite loops are UB in C++. The forward progress guarantees in C are much weaker than in C++ (only for iteration statements whose condition is not a constant expression, not for loops with goto or with constant true controlling the infinite loop).</p>",
        "id": 499879514,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1739593262
    },
    {
        "content": "<p>You're right. If I compile the same code as C++ instead of C the loop disappears:</p>\n<div class=\"codehilite\" data-code-language=\"GAS\"><pre><span></span><code><span class=\"nl\">_Z5l_fooh:</span>\n<span class=\"w\">        </span><span class=\"nf\">movs</span><span class=\"w\">    </span><span class=\"no\">r0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">#1</span>\n<span class=\"w\">        </span><span class=\"nf\">bx</span><span class=\"w\">      </span><span class=\"no\">lr</span>\n</code></pre></div>\n<p>this is just <code>return true</code></p>",
        "id": 499917567,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739629016
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 500847050,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1740048296
    },
    {
        "content": "<p>I just learned that Mathlib already has a <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Order/Estimator.html\">Estimator</a> for doing something very similar, while caching some data.</p>\n<p>Perhaps some day it would be nice to rewrite this to use that, which would definitely allow for some significant runtime improvements.</p>",
        "id": 511544963,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1744337356
    },
    {
        "content": "<p><code>Estimator</code> is very specialized for its use case inside <code>rw_search</code>, and it's unclear that it's a good design (mine!) for general purpose use.</p>",
        "id": 511547942,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1744339201
    },
    {
        "content": "<p>Well, it is pretty much exactly (up to any Lean-specific idioms I do or don't know) the design I had imagined for a while: a value, and (in particular) a Thunk for improving it, with kind of a black box as to how much it improves.</p>\n<p>But, don't worry, I won't be attempting to use it any time soon. :) I'm working on getting <code>log</code> supported, and that's giving me quite a time already.</p>",
        "id": 511548942,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1744339861
    },
    {
        "content": "<p>And always a zillion other things..</p>",
        "id": 511549014,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1744339914
    }
]