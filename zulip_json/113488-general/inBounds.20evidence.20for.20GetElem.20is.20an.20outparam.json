[
    {
        "content": "<p>why is <code>inBounds</code> evidence an outParam?</p>\n<p><a href=\"https://lean-lang.org/functional_programming_in_lean/type-classes/indexing.html#overloading-indexing\">https://lean-lang.org/functional_programming_in_lean/type-classes/indexing.html#overloading-indexing</a></p>",
        "id": 467935088,
        "sender_full_name": "Quinn",
        "timestamp": 1725558642
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span><span class=\"w\"> </span><span class=\"n\">GetElem</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">coll</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">idx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">item</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">inBounds</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">coll</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">idx</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">getElem</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">coll</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">idx</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">inBounds</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">item</span>\n</code></pre></div>",
        "id": 467935143,
        "sender_full_name": "Quinn",
        "timestamp": 1725558655
    },
    {
        "content": "<blockquote>\n<p>The element type and the evidence function are both output parameters. <code>GetElem</code> has a single method, <code>getElem</code>, which takes a collection value, an index value, and evidence that the index is in bounds as arguments, and returns an element:</p>\n</blockquote>",
        "id": 467936262,
        "sender_full_name": "Quinn",
        "timestamp": 1725558863
    },
    {
        "content": "<p>I think of the evidence as an input.</p>",
        "id": 467936331,
        "sender_full_name": "Quinn",
        "timestamp": 1725558883
    },
    {
        "content": "<p>It's the <em>type</em> of the evidence that is an outparam, not the evidence itself (which is the <code>inbounds c i</code> argument to the <code>getElem</code> field).</p>",
        "id": 468010591,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1725581361
    },
    {
        "content": "<p>So the function that returns the evidence is an output? It's still not clicking for me</p>",
        "id": 468010849,
        "sender_full_name": "Quinn",
        "timestamp": 1725581433
    },
    {
        "content": "<p>I get how the outParam annotation helps with type inference later</p>",
        "id": 468010937,
        "sender_full_name": "Quinn",
        "timestamp": 1725581454
    },
    {
        "content": "<p>Notice the value of <code>inBounds c i</code> is a <code>Prop</code>, not data.</p>",
        "id": 468011189,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1725581505
    },
    {
        "content": "<p>Given a container and an index type, the following are outputs: </p>\n<ul>\n<li>the type of elements in the container</li>\n<li>the predicate saying that an index is valid</li>\n</ul>\n<p>E.g., for <code>List a</code> and <code>Nat</code> the outparams are <code>a</code> and <code>fun l k =&gt; k \\le l.length</code>.</p>",
        "id": 468062591,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1725597471
    },
    {
        "content": "<p>This means that there should be no two instances with the same collection type and the same index type that ask to prove different properties of the index in <code>L[n]'(hn)</code></p>",
        "id": 468063153,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1725597645
    },
    {
        "content": "<p>i think i get it, ish. the type of the evidence is an outParam, but the evidence is still an input</p>",
        "id": 468264161,
        "sender_full_name": "Quinn",
        "timestamp": 1725648189
    },
    {
        "content": "<p>but it doesn't output a tuple (type_of_evidence, elem). it outputs a function type_of_evidence -&gt; elem</p>",
        "id": 468264340,
        "sender_full_name": "Quinn",
        "timestamp": 1725648234
    },
    {
        "content": "<p>maybe outParam is just \"anything that's late enough in left to right evaluation that the metavariable typer might get stuck\", and doesn't actually refer to \"output\"</p>",
        "id": 468264501,
        "sender_full_name": "Quinn",
        "timestamp": 1725648278
    },
    {
        "content": "<p>It means that typeclass search will be happy to search for <code>GetElem (List α) Nat ?a ?b</code> with unknown <code>?a</code> and <code>?b</code>. Also, it means that instances should be written so that <code>coll</code> and <code>idx</code> uniquely define <code>item</code> and <code>inBounds</code>.</p>",
        "id": 468294744,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1725659392
    }
]