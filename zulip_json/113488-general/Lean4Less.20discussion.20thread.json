[
    {
        "content": "<p>Discussion thread for the <a href=\"#narrow/channel/113486-announce/topic/Lean4Less.3A.20Translating.20Lean.20to.20smaller.20theories/near/493281701\">Lean4Less</a> announcement</p>",
        "id": 493281891,
        "sender_full_name": "Rish Vaishnav",
        "timestamp": 1736754604
    },
    {
        "content": "<p>Interesting! Is def-eq proof irrelevance the only axiom within scope, or are there plans to expand this project to e.g. proving things without choice or LEM?</p>",
        "id": 493351602,
        "sender_full_name": "Violeta HernÃ¡ndez",
        "timestamp": 1736774976
    },
    {
        "content": "<p>It's limited to eliminating definitional equalities, that is, equalities that are checked by the kernel and do not normally require proof. And in the process, it <em>introduces</em> axioms, like the <code>prfIrrel</code> axiom above (which is definitionally true in Lean). It builds the proof in parallel to normal kernel typechecking, and it doesn't do anything more intelligent, like trying to get around using proof irrelevance when it doesn't have to use it. So it's not applicable to translating proofs to evade the use of certain things like the axiom of choice or the excluded middle property. I do have plans to soon extend it to eliminate other defeqs, like struct and function eta for example (there's just a little bit more I need to parameterize first in order to try that out)</p>",
        "id": 493353657,
        "sender_full_name": "Rish Vaishnav",
        "timestamp": 1736775524
    },
    {
        "content": "<p>I should probably mention that I called the translation \"Lean4Less\" in the sense of \"Lean for a smaller kernel\", it's not at all a translation that tries to reduce the size of Lean terms, the translated terms will only get bigger (much bigger, in some cases)</p>",
        "id": 493380196,
        "sender_full_name": "Rish Vaishnav",
        "timestamp": 1736782228
    },
    {
        "content": "<p>You mention you were discussing implementing an extTT-to-intTT translation. Has anyone picked up work on that?</p>",
        "id": 522156442,
        "sender_full_name": "Max Nowak ğŸ‰",
        "timestamp": 1748964778
    },
    {
        "content": "<p>Iâ€™ve started work on a ground-up kernel rewrite of Lean to allow for user-defined extensional rewrite rules/undirected defeqs, and have a few small examples working. In it, Iâ€™ve replaced Leanâ€™s C++ kernel with the Lean4Lean implementation to make modifications easier. I was going more in the direction of having extensionality as a built-in feature of Lean, with an after-the-fact translation to the original theory via Lean4Less that would be isolated to Mathlib CI, for example (as opposed to a real-time translation on the user side). But thereâ€™s still a lot more work to be done to make it more efficient and scalable. </p>\n<p>Unfortunately I havenâ€™t had much time for it lately between PhD work and other more recent ambitions. I do certainly plan to get back to it eventually however! If anyone wants to try to hack around with it in the meantime, Iâ€™d be happy to provide more details.</p>",
        "id": 522160268,
        "sender_full_name": "Rish Vaishnav",
        "timestamp": 1748965664
    },
    {
        "content": "<p>My Lean4Less paper is now <a href=\"https://inria.hal.science/hal-05310102\">available on HAL</a>! It will also appear in the proceedings of the ICTAC 2025 conference, which I attended last week: here are <a href=\"https://rish987.github.io/files/lean4less_slides.pdf\">the slides</a>. Also, there are many more details on the implementation of Lean4Less to come in my PhD thesis, which should be available by February of next year (if everything goes as planned). If you have any questions about the paper, feel free to ask them here (or DM me).</p>",
        "id": 561915781,
        "sender_full_name": "Rish Vaishnav",
        "timestamp": 1764863823
    },
    {
        "content": "<p>This is really cool! One thing I've dreamed about for a long time is if we could translate Lean terms into a topos (indeed this was part of my motivation for <a href=\"https://github.com/b-mehta/topos\">the topos project</a>, but it ended up defining grothendieck toposes and getting used for condensed maths instead!), and the conceptual part which I didn't know how to solve was how to translate Lean's structure defeqs into being explicit rewrites. It looks to me like you've solved that problem? <br>\nTo be much more concrete, is it now feasible to do the following?<br>\nGiven a fully polymorphic, constructive definition eg</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">myFunc</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">Ã—</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">â†¦</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>which uses (for now) only the type constructors Prod and non-dependent pi; convert it into a morphism in an arbitrary cartesian closed category? And then, can we automatically derive equalities in the category which correspond to this theorem?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">myFunc</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">Ã—</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">â†¦</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">myPi</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">Ã—</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">â†¦</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"m\">1</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">myPair</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">Ã—</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">myFunc</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">â†¦</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">myPi_myPair</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">myPi</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">myPair</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>(perhaps this one would be axiomatic, but would be something like <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.prod.lift_fst\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.prod.lift_fst</a>)</p>\n<p>Of course eventually this should be extended to more type constructors, I just wanted a small one for the sake of example.</p>",
        "id": 561924413,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1764865838
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"128280\">@ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’</span></p>",
        "id": 561924634,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1764865894
    },
    {
        "content": "<p>I was doing something with this</p>",
        "id": 561924919,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764865965
    },
    {
        "content": "<p><a href=\"#narrow/channel/287929-mathlib4/topic/Constructing.20morphisms.20in.20a.20cartesian.20closed.20category/near/504227246\">https://leanprover.zulipchat.com/#narrow/channel/287929-mathlib4/topic/Constructing.20morphisms.20in.20a.20cartesian.20closed.20category/near/504227246</a></p>",
        "id": 561925086,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764866014
    },
    {
        "content": "<p>I'm also working on a tactic that's complete for equality of parallel morphisms in a free ccc</p>",
        "id": 561925208,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764866052
    },
    {
        "content": "<p>Right, constructing the morphisms isn't too bad, but converting the proofs is the more interesting part, in particular because we go from a <code>rfl</code> proof to a propositional, non-definitional equality, and it looks like Rish's setup is now able to do this? <br>\nNote also that CCC is just the test case, ideally we should be able to interpret in any category with enough structure, so eg convert the natural number game automatically into a topos with NNO, and convert any fully polymorphic constructive proof in mathlib into a topos, and convert any proof in mathlib into a category satisfying ETCS.</p>",
        "id": 561926569,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1764866394
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/channel/113488-general/topic/Lean4Less.20discussion.20thread/near/561924634\">said</a>:</p>\n<blockquote>\n<p>cc <span class=\"user-mention silent\" data-user-id=\"128280\">ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’</span></p>\n</blockquote>\n<p>I remember discussing this exact thing with him back in 2019! How time flies :)</p>",
        "id": 561926665,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1764866420
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> <a href=\"#narrow/channel/113488-general/topic/Lean4Less.20discussion.20thread/near/561924413\">said</a>:</p>\n<blockquote>\n<p>the conceptual part which I didn't know how to solve was how to translate Lean's structure defeqs into being explicit rewrites</p>\n</blockquote>\n<p>Not sure I totally grasped everything, but if your goal is to make Lean's specialized defeqs for structs (struct eta, struct-like reduction, projections) explicit, then that would certainly be within scope, however the translation is not currently set up to do this (though it can already eliminate struct-like reduction). For instance, if you want to make explicit the proof of some theorem <code>X</code> utilizing projection reduction in its typing (like in <code>myPi_myPair</code>), making use of an axiom characterizing the projection reduction:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">proj_eq</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>\n<p>then that should be feasible for the translation, if you were to generate such axioms for each of the projections of every structure type.</p>\n<p>On the other hand, if your objective is rather to make types that are not exactly structs but \"similar enough\" to structs behave more like structs in terms of the defeqs that are applicable to them, you could feasibly extend Lean4Less to translate from a larger class of defeqs that includes the one that you are targeting. If you replaced the type <code>A Ã— B</code> in the theorem <code>X</code> with some non-struct type <code>T</code>, but are still able to prove the equivalent of <code>proj_eq</code> for <code>T</code>, you could feasibly clue the extended Lean4Less translation in on this fact, telling it to generate a proof of <code>X</code> as if this property was definitional, and achieve a translation identical in structure to the translated proof of the version of <code>X</code> which used <code>A Ã— B</code>, but which uses the new theorem in place of <code>proj_eq</code>.</p>\n<p>Is that somewhat along the lines of what you were asking about?</p>",
        "id": 561934941,
        "sender_full_name": "Rish Vaishnav",
        "timestamp": 1764868556
    },
    {
        "content": "<p>It is, and that's very helpful context, thanks! I'll take a closer look at the paper and implementation</p>",
        "id": 561967711,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1764879694
    },
    {
        "content": "<p>I replied to the ping in <a href=\"#narrow/channel/116395-maths/topic/Categorical.20logic.20in.20Lean.3F.20.28algebraic.20theories.2C.20etc.2E.29/near/562049115\">a different thread</a> in order not to hijack this one. </p>\n<p><span class=\"user-mention\" data-user-id=\"373814\">@Rish Vaishnav</span> I am excited about the potential of this to implement Nuprl/Istari-style equality reflection as a custom proof mode! Or Agda-style custom <code>REWRITE</code> rules. I share the caution you express in</p>\n<blockquote>\n<p>The output of ett-to-itt will likely be unacceptably large because it is directly derived from a formalization that makes an only very limited attempt at optimizing the output size </p>\n</blockquote>\n<p>because in SynthLean we have also found term sizes to be an important (and often overlooked) usability consideration. But I think there is hope: IIRC the translation comes with a metatheorem saying that any statement that is definable in ITT and provable in ETT also has an ITT proof. Now when the statement is a proof-irrelevant <code>Prop</code>, we might not care so much about how ugly the translated ITT proof is. There is still a performance consideration, but that seems more surmountable than having users manually wrangle with proof-relevant translation outputs.</p>\n<p>EDIT: Oh, just realized that part is talking about a different, hypothetical translation extracted from a formalization. I should actually read the paper <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> Comment above still applies, though: performance will always remain a concern.</p>",
        "id": 562108543,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1764943619
    },
    {
        "content": "<p>Yes, indeed there are issues with scaling, some of which may not be entirely avoidable (like the \"transport hell\" problem). This is part of the reason why I am rather partial to the approach of extending the kernel itself to allow for user-defined defeqs/custom rewrites and eta rules like they have in Andromeda. This obviously would require a larger kernel, so we would have to make sure things remain efficient in the common cases (I think Lean's discrimination trees would be useful for narrowing down possibly applicable user-defined rules, but have yet to look into this further).</p>\n<p>And then there's the issue of trust, as larger kernels are more likely to contain bugs that could affect consistency. However, trust could be largely recovered if we can show that the translation is correct, as well as verify the extended kernel w.r.t. the metatheory (see Appendix F and slides 24 - 27).</p>",
        "id": 562168405,
        "sender_full_name": "Rish Vaishnav",
        "timestamp": 1764962144
    }
]