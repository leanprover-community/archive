[
    {
        "content": "<p>I'm trying to make an infinite, lazy stream of constant values:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">MyStream</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">inf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">MyStream</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyStream</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">constStream</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyStream</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">MyStream</span><span class=\"bp\">.</span><span class=\"n\">inf</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">()</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">constStream</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Lean rejects this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">fail</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"n\">termination</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">constStream</span>\n</code></pre></div>\n<p>I've tried some variants but I fail to get this right.  Any suggestions?</p>",
        "id": 517291189,
        "sender_full_name": "Mark Christiaens",
        "timestamp": 1746907248
    },
    {
        "content": "<p>Lean doesn't allow infinite recursion, and you can't create \"infinite objects\" using just inductive types. What you need is a <em>coinductive</em> type and a <em>corecursive</em> function. Lean's kernel doesn't support such types directly, but they can be modeled using functions. For infinite streams, see <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Stream%27#doc\">docs#Stream'</a>.</p>",
        "id": 517292763,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1746908618
    },
    {
        "content": "<p>You can add <code>partial</code> to <code>constStream</code> (as long as you don't care about proving stuff). Also, <code>MLList</code> works well as a monadic lazy list (<code>import Batteries.Data.MLList.Basic</code>, again, forget about proving stuff).</p>",
        "id": 517292832,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1746908664
    },
    {
        "content": "<p>If you <em>do</em> care about proving things, then <code>Nat -&gt; α</code> (under the mathlib alias <code>Stream'</code>). However note that that gets rid of good performance</p>",
        "id": 517292881,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1746908742
    },
    {
        "content": "<p>Another alternative would be to make the state of the stream explicit and to carry around a transition function on the state type:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span><span class=\"w\"> </span><span class=\"n\">MyStream</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"w\">  </span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">state</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">σ</span>\n<span class=\"w\">  </span><span class=\"n\">nextInternal</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">σ</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">MyStream.next</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyStream</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyStream</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">s.nextInternal</span><span class=\"w\"> </span><span class=\"n\">s.state</span>\n<span class=\"w\">  </span><span class=\"o\">⟨</span><span class=\"n\">s.σ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">s.nextInternal</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">constStream</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyStream</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">PUnit</span>\n<span class=\"w\">  </span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"n\">state</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">unit</span>\n<span class=\"w\">  </span><span class=\"n\">nextInternal</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">unit</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>This way you get relatively efficient streams that you can actually prove things about. You can think of it as a bundled version of the <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Stream#doc\">docs#Stream</a> typeclass together with its state type.</p>\n<p>(Note that <code>constStream</code> is stateless, so it doesn't use any state, but sigma is there to accomodate cases where your stream does have some state.)</p>\n<p>The main downside of this approach is that <code>MyStream α</code> lives in <code>Type (u + 1)</code>, not <code>Type u</code> like <code>α</code>. If you can live with that and are fine with having to explicitly provide some state type and transition function when creating a stream, this might be an option.</p>",
        "id": 517339221,
        "sender_full_name": "Paul Reichert",
        "timestamp": 1746952200
    },
    {
        "content": "<p>Making the state explicit works! Thanks.  </p>\n<p>Could you explain a bit more about why this does work and my attempt did not?  </p>\n<p>Maybe first about my attempt.  My reasoning was this.  In Lean, I cannot make types that would have infinite terms (since it's a strict language).  So, let's make a type that holds one value and a way to continue generating more values from that.  That will require 2 fields: a value and function.  Seems fine to me.  Also, it's not \"infinite recursion\": the function that is embedded is not executed until I fetch another value.  Seems fine to me too.  </p>\n<p>So it seems that Lean is fundamentally not happy with me using the _type_ recursively.  Is that because it would break the proof system?  </p>\n<p>I tried making my function <code>partial</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">MyStream</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">inf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">MyStream</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyStream</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"w\">  </span><span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">constStream</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyStream</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"n\">MyStream</span><span class=\"bp\">.</span><span class=\"n\">inf</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">()</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">constStream</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>But then Lean4 complains about:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">failed</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">compile</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">partial'</span><span class=\"w\"> </span><span class=\"n\">definition</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">Attempt2</span><span class=\"bp\">.</span><span class=\"n\">constStream'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">could</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">prove</span><span class=\"w\"> </span><span class=\"n\">that</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">MyStream</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">nonempty</span><span class=\"bp\">.</span>\n</code></pre></div>\n<p>So then I thought, let's try to convince Lean that this type is nonempty.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Inhabited</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]:</span><span class=\"w\"> </span><span class=\"n\">Inhabited</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MyStream</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">default</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">inf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">default</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">()</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">default</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Lean doesn't like that:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">failed</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">synthesize</span>\n<span class=\"w\">  </span><span class=\"n\">Inhabited</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MyStream</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>From a logical point of view, that kind of makes sense to me.  I'm trying to convince Lean that my type is nonempty through a circular reasoning.  That indeed is nonsense.</p>\n<p>So I guess that my question is whether I'm right in thinking that the fundamental problem is that I cannot prove the nonemptiness?  </p>\n<p>And a related question, how come the solution with the explicit state field doesn't suffer this nonemptiness faith?</p>\n<p>As another data point, I've added a <code>nil</code> constructor to <code>MyStream</code>.  So <code>MyStream</code> is definitely inhabited.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">MyStream</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">inf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">MyStream</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyStream</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span>\n<span class=\"w\">  </span><span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Inhabited</span>\n\n<span class=\"w\">  </span><span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">constStream</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyStream</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"n\">MyStream</span><span class=\"bp\">.</span><span class=\"n\">inf</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">()</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">constStream</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>This does compile.  From this I conclude that using <code>MyStream</code> inside the definition of <code>MyStream</code> is allowed but it messes with termination checking (hence the need for the <code>partial</code> keyword).</p>\n<p>So, I guess I'm a bit confused about what I'm fighting against here.  Is it recursive types, nonemptiness, or the need for a higher universe?</p>",
        "id": 517361887,
        "sender_full_name": "Mark Christiaens",
        "timestamp": 1746970768
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"611195\">Mark Christiaens</span> <a href=\"#narrow/channel/113488-general/topic/Infinite.2C.20lazy.20stream/near/517361887\">said</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">MyStream</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">inf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">MyStream</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyStream</span><span class=\"w\"> </span><span class=\"n\">α</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>This type is actually empty</p>",
        "id": 517363633,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746972201
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Logic</span><span class=\"bp\">.</span><span class=\"n\">IsEmpty</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">MyStream</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">inf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">MyStream</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyStream</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsEmpty</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MyStream</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">MyStream</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"o\">()</span>\n</code></pre></div>",
        "id": 517363808,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746972319
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"611195\">Mark Christiaens</span> <a href=\"#narrow/channel/113488-general/topic/Infinite.2C.20lazy.20stream/near/517361887\">said</a>:</p>\n<blockquote>\n<p>So, I guess I'm a bit confused about what I'm fighting against here.  Is it recursive types, nonemptiness, or the need for a higher universe?</p>\n</blockquote>\n<p>When you write down your inductive definition for <code>MyStream</code>, <code>MyStream</code>as a type is a type such that:</p>\n<ul>\n<li>there is a function <code>MyStream.inf : {α} -&gt; (a : α) (t : Unit -&gt; MyStream α) : MyStream α</code>,</li>\n<li><code>MyStream.inf</code> is injective in the sense that each pair <code>(a, t)</code> produces a different element in <code>MyStream α</code> (\"no confusion\"),</li>\n<li>and (since <code>inf</code> is the only constructor available,) every element of <code>MyStream α</code> can be obtained from <code>MyStream.inf</code> -- in other words, <code>MyStream.inf</code> is surjective.</li>\n</ul>\n<p>In a somewhat hand-wavy way, this is a fixpoint equation for the type <code>MyStream α</code>, but most importantly, it defines <code>MyStream</code> with reference to itself. Such \"impredicative\" definitions are tricky because it's neither clear that such a type <code>MyStream α</code> exists nor that it is unique in any way.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>some examples for fixpoint problems</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>In general, a fixpoint of a function <code>F</code> is some <code>x</code> such that <code>F x = x</code>.</p>\n<ul>\n<li>If <code>F : Nat -&gt; Nat, F x := x</code>, then every <code>x : Nat</code> is a fixpoint, so there's no unique fixpoint.</li>\n<li>If <code>F : Nat -&gt; Nat, F x := x + 1</code>, then there is no fixpoint because <code>F x = x</code> is always false.</li>\n</ul>\n<p>In the case of inductive types, we are considering fixpoints of <em>types</em>, not <em>numbers</em>, but the basic problem is the same.</p>\n</div></div>\n<p>For inductive types that are allowed in Lean, there doesn't need to be a unique fixpoint, but there always <em>exists</em> one, and in face, there even exists a <em>smallest</em> fixpoint. Let's see what this means in practice.</p>\n<p>Consider your original definition of <code>MyStream</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span><span class=\"w\"> </span><span class=\"n\">MyStream</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">inf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">MyStream</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyStream</span><span class=\"w\"> </span><span class=\"n\">α</span>\n</code></pre></div>\n<p>I claim that the empty type (<code>False</code>) satisfies our fixpoint conditions:</p>\n<ul>\n<li><code>MyStream.inf : {α} -&gt; (a : α) -&gt; (t : Unit -&gt; False) -&gt; False</code> is easy to construct as <code>inf a t := t ()</code>. (This is more or less what Aaron did to show that <code>MyStream</code> is empty.)</li>\n<li><code>MyStream.inf</code> is bijective, since there are no pairs <code>(a, t)</code> and there are no elements <code>x : False</code>, in both cases because <code>False</code> is empty.</li>\n</ul>\n<p>However, the fixpoint solution you apparently hoped for is that of infinite streams. To see that it also satisfies the fixpoint conditions, let's model it (inefficiently) as <code>MyStream α := Nat -&gt; α</code>:</p>\n<p>First, define:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">MyStream.inf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">()</span><span class=\"w\"> </span><span class=\"n\">m</span>\n</code></pre></div>\n<p>Also in this case, <code>inf</code> is bijective! So the fixpoint equation implied by the definition isn't unique.</p>\n<p>In order to make <code>MyStream</code> well-defined, inductive types in Lean are always the <em>smallest</em> possible fixpoint -- in this case, the empty type. Note that Lean is totally capable to construct coinductive types \"by hand\", for example as <code>Nat -&gt; α</code>, and there doesn't seem to be anything about Lean's type theory that would make coinductive types impossible. However, in practice, Lean lacks built-in support for them in analogy to inductive types and it can sometimes be hard to construct them in an efficient and convenient way.</p>\n<p>The higher universe is also just an artifact of practical limitations: From the type theory perspective, <code>Nat -&gt; α</code> is a perfectly valid model of your coinductive type, it's just not efficient. In contrast, my construction is more efficient but requires a universe bump. Right now there doesn't seem to be a way to achieve both goals at once (except for the case of coinductive predicates!).</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>relation to termination conditions</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>I think that the termination requirement that you walked into ensures that the constructed element is actually contained in your inductive (smallest-fixpoint) type.</p>\n<p>For simplicity, let's first consider <code>Nat</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n</code></pre></div>\n<p>Since <code>Nat</code> is the smallest possible fixpoint, we need to be stingy with regard to elements of <code>Nat</code> -- only those elements that <em>must</em> exist are allowed.</p>\n<ol>\n<li>Using the first constructor, <code>0 = Nat.nil</code> definitely exists.</li>\n<li>Using the second constructor and (1.), <code>1 = Nat.succ 0</code> definitely exists.</li>\n<li>Using the second constructor and (2.), <code>2 = Nat.succ 1</code> definitely exists.</li>\n<li>...</li>\n</ol>\n<p>The important thing to note is that \"circular reasoning\" isn't allowed: (3.) cannot refer to (3.) itself, it can only refer to (2.). Otherwise, we could say (perhaps a bit hand-wavy, but this is the idea):</p>\n<p>(inf) Using the second constructor and (inf), <code>\\inf = Nat.succ \\inf</code> definitely exists.</p>\n<p>But <code>Nat</code> definitely should not contain infinity since it's the smallest-possible fixpoint. Hence we also need to forbid the following definition, which is similar to your <code>constStream</code> definition:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">infiniteNat</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Nat.succ</span><span class=\"w\"> </span><span class=\"n\">infinite_nat</span>\n</code></pre></div>\n<p>The termination checker tries to find a \"termination measure\" that strictly decreases with every recursive call <em>and</em> that is well-founded: There's no infinite decreasing sequence w.r.t. the termination measure. This decreasing condition can be thought to ensure that we never construct an element of an inductive type in a circular way like with <code>infiniteNat</code> and (inf). But you can also think of this check as a termination check: Since the well-founded termination measure decreases with every recursive call, the recursion must end after finitely many steps.</p>\n</div></div>\n<p>&lt;/wall of text&gt;</p>\n<p>I hope this was readable and helps a bit to understand the fundamental problem with defining <code>MyStream</code> as an inductive type.</p>",
        "id": 517379107,
        "sender_full_name": "Paul Reichert",
        "timestamp": 1746983373
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"611195\">Mark Christiaens</span> <a href=\"#narrow/channel/113488-general/topic/Infinite.2C.20lazy.20stream/near/517361887\">said</a>:</p>\n<blockquote>\n<p>Also, it's not \"infinite recursion\": the function that is embedded is not executed until I fetch another value.  Seems fine to me too.</p>\n</blockquote>\n<p>When you define a function <code>foo</code> recursively, i.e., referring to <code>foo</code> in its own body, the definition is valid only if, in each recursive call, the arguments passed to <code>foo</code> decrease in some sense.</p>\n<p>In your definition above, <code>constStream a</code> \"calls\" <code>constStream a</code>, which is not allowed. I'm putting \"call\" in quotes here because it has nothing to do with the actual computation; it's just a syntactic thing here.</p>",
        "id": 517381398,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1746985318
    },
    {
        "content": "<p><code>partial</code> and nonemptiness are a completely different matter here. The <code>partial</code> keyword is used when we don't want to prove anything about the function being defined—we only need to use it for computations. When <code>partial</code> is used, Lean only requires a proof that the target type of the function is inhabited, because no function can exist with an empty target type (since such a function would immediately lead to a contradiction, allowing one to prove <code>False</code>). Then function becomes opaque from a logical point of view: you can use it in computations, but you can't reason about it or prove properties of it within Lean's logic.</p>",
        "id": 517382237,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1746986001
    }
]