[
    {
        "content": "<p>how would you suggest aesop to disccharge the current goal into 2 new goals using cases with pattern matching? ie<br>\n<code>cases x with | =&gt; | =&gt; </code></p>",
        "id": 490790063,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1735142674
    },
    {
        "content": "<p>So does pantograph support doing tree search on proofs that involve pattern matching? Like what would happen if you try to a trace a theorem with the following tactic.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n</code></pre></div>",
        "id": 490790864,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1735143493
    },
    {
        "content": "<p>This particular issue has come up many times.  I brought it up when Lean 4 was under development.  I think mathlib has a one line tactic which does this and this is what I assume Lean Dojo, LLMLean, and ABEL are likely to suggest.  Another approach suggested by Daniel Selsam was to use <code>cases x with | =&gt; _? | =&gt; _?</code> or something like that (I’m forgetting the  correct syntax). It’s ugly but it works, and he showed how you can decompose Lean proofs into this form when collecting data. I don’t know how AlphaProof handles this because I thought they did have a number of nested proofs.  I’d be curious.  Also, in the long term the way DeepSeek-Prover v1.5 and others do it where they don’t consider a proof to be automic tactics but just text where you have certain break points (or so I understand it), might be a better approach in the end.  It would work equally well on term proofs and writing code in general.</p>",
        "id": 490790913,
        "sender_full_name": "Jason Rute",
        "timestamp": 1735143558
    },
    {
        "content": "<p>so at each step it predicts a template that it needs to fill in later?</p>",
        "id": 490791028,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1735143674
    },
    {
        "content": "<p>What is “it”?  I mentioned many approaches.</p>",
        "id": 490791039,
        "sender_full_name": "Jason Rute",
        "timestamp": 1735143699
    },
    {
        "content": "<p>The approach suggested by Selsam is a valid Lean tactic (when I get the syntax correct) that introduces goals for each <code>_?</code>.  You could just leave it like that.  It looks ugly, but it isn’t wrong.  I would think of the DeepSeek-Prover v1.5 approach more like text generation where they fix a proof at the first place it breaks.  But it is all a matter of perspective and you could think of some of these approaches including the common mathlib tactics tactics as making “templates”.</p>",
        "id": 490791313,
        "sender_full_name": "Jason Rute",
        "timestamp": 1735143969
    },
    {
        "content": "<p>sorry, I meant deepseek prover</p>",
        "id": 490791355,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1735144027
    },
    {
        "content": "<p>so if it reached a goal state where it wanted to use cases, would it just spit out</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n</code></pre></div>\n<p>which would give the tree search algorithms two errors, which it then treats like goals?</p>",
        "id": 490791449,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1735144102
    },
    {
        "content": "<p>Like I said, if you use the mathlib version of cases it does this.  Or if you use the Selsam approach, it also does this.   Or in the DeepSeek MCTs case if you generate a whole proof and the second case breaks then you just fix the second case leaving the rest the same.  None are exactly templates but have the same effect.</p>",
        "id": 490791593,
        "sender_full_name": "Jason Rute",
        "timestamp": 1735144214
    },
    {
        "content": "<p>I’m on my phone so I can’t give specific examples.</p>",
        "id": 490791675,
        "sender_full_name": "Jason Rute",
        "timestamp": 1735144309
    },
    {
        "content": "<p>so the deepseek llm takes the previous partial proof and all the error messages and outputs an entirely new version of the same proof. So for example if the previous proof was</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n</code></pre></div>\n<p>it's output would be</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">linarith</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n</code></pre></div>\n<p>that is it doesnt just predict modifications, but rewrites the entire proof again at each search step?</p>",
        "id": 490792394,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1735144979
    },
    {
        "content": "<p>also for the selsam approach, would that mean you need to preprocess all the lean proofs/programs and replace all of the pattern matching code with holes?</p>",
        "id": 490792713,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1735145266
    },
    {
        "content": "<p>for the selsam approach would each tactic have the option to assigned \"linearizer\" function that is capable of converting a the tactic application into it's corresponding hole command version</p>",
        "id": 490792841,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1735145356
    },
    {
        "content": "<p>Just to be clear <em>none</em> of the approaches I mentioned literally output</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n</code></pre></div>\n<p>The DeepSeek approach I think write a full proof and then fixes it at the first error keeping the rest of the proof the same.  I don’t quite understand what they would do if, say, the first case errored but the second case worked.  <span class=\"user-mention\" data-user-id=\"481527\">@Huajian Xin</span>?</p>\n<p>As for the Selsam approach,  that tactic I wrote is a valid tactic (if I got the syntax right) that behaves just like mathlib’s version of cases.  It is a single tactic which changes the current goal into two subgoals.  End of story.  The advantage is that you can take a real instance of the nested cases tactic in Lean and decompose it into multiple atomic tactics instead of one super tactic, where the first tactic is `cases x with | =&gt; _? | =&gt; _?.  (If this is still confusing, maybe we should wait until tomorrow when I have my computer to write you some code showing what I mean.)</p>",
        "id": 490794814,
        "sender_full_name": "Jason Rute",
        "timestamp": 1735147215
    },
    {
        "content": "<p>kk thx</p>",
        "id": 490795194,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1735147565
    },
    {
        "content": "<p>I moved the conversation with <span class=\"user-mention\" data-user-id=\"676310\">@Frederick Pu</span> here from <a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/channel/113488-general/topic/What.20do.20you.20hope.20AI.20can.20help.20you.20achieve.20with.20Lean.20in.202025.3F\">#general &gt; What do you hope AI can help you achieve with Lean in 2025?</a></p>",
        "id": 490875540,
        "sender_full_name": "Jason Rute",
        "timestamp": 1735217768
    },
    {
        "content": "<p>Here is my longer response.  Say you have a theorem of this form in your library you are extracting data from.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"n\">hl</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hl</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"n\">hr</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hr</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>I don't exactly know how all the data extraction libraries do it, but possibly it you could get the following three proofstate goal pairs:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n<span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span>\n\n<span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"n\">hl</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hl</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"n\">hr</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hr</span><span class=\"o\">]</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n<span class=\"n\">hl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span>\n\n<span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hl</span><span class=\"o\">]</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n<span class=\"n\">hr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span>\n\n<span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hr</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Notice the first proofstate-tactic is the full case tactic including all subtactics.  Some libraries may not record that one that since there are more atomic tactics inside.</p>",
        "id": 490878164,
        "sender_full_name": "Jason Rute",
        "timestamp": 1735219504
    },
    {
        "content": "<p>Now for an AI that works by predicting one tactic at a time and records data as above, I think it would end up predicting the following in a setting like this:</p>\n<ul>\n<li>Either it would predict the full long nested tactic <code>cases h with | inl hl =&gt; rw [hl] | inr hr =&gt; rw [hr]</code> which could possibly have errors since it is so long, or</li>\n<li>it would predict a variant with <code>cases'</code>, something like <code>cases' h with hl hr</code>,  since that is more common in Mathlib.</li>\n</ul>",
        "id": 490878180,
        "sender_full_name": "Jason Rute",
        "timestamp": 1735219512
    },
    {
        "content": "<p>Neither is great, since it isn't capturing an atomic tactic which covers just the case split.  It is either getting lucky since there are similar tactics in mathlib which are atomic or it is just predicting the full nested tactic, but that is long and more error prone.</p>",
        "id": 490878186,
        "sender_full_name": "Jason Rute",
        "timestamp": 1735219519
    },
    {
        "content": "<p>So Daniel Selsam in a conversation from many years ago (<a class=\"stream-topic\" data-stream-id=\"219941\" href=\"/#narrow/channel/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20gym.20for.20Lean.204\">#Machine Learning for Theorem Proving &gt; Lean gym for Lean 4</a>) showed that is it possible to break up the above proof automatically into the following while recording (and the method is applicable to anytime you have tactics inside tactics).</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"n\">hl</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"n\">hr</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n<span class=\"w\">  </span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hl</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hr</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>I don't think any of the public recording libraries do this, and it leads to slightly ugly proofs.  (I suppose one could predict a proof in this form, but then use metaprogramming to get rid of the <code>?_</code> in the final result, although I don't know if it would fully work in practice.)</p>",
        "id": 490878192,
        "sender_full_name": "Jason Rute",
        "timestamp": 1735219528
    },
    {
        "content": "<p>I think DeepSeek-Prover v1 and other whole proof generation methods just train on whole proofs and predict whole proofs, so again the prediction might be something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"n\">hl</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hl</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"n\">hr</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n</code></pre></div>\n<p>This is great if it works since the model can use full Lean tactic syntax, but again their may be errors in some parts of the proof (as there is in my example with <code>simp</code>).  DeepSeek-Prover v1.5 as well as many other theorem provers for Isabelle and Coq (Lyra, PALM, Cobblestone) try to repair the proof where it is broken.  I think for the above proof that would mean just replacing <code>simp</code> with a different proof using the goal at that point in the proof.  I'm not sure about if the proof was broken in multiple places.  For example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"n\">hl</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\">  </span><span class=\"c1\">--broken</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"n\">hr</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\">  </span><span class=\"c1\">--broken</span>\n</code></pre></div>\n<p>I'm pretty sure CobbleStone would separately fix both <code>simp</code> instances independently.  I don't know about DeepSeek-Prover v1.5.  Would it try to fix each <code>simp</code> independently, or just start generating text at the location of the first broken <code>simp</code>, or just start over at the location of <code>cases ...</code>?  <span class=\"user-mention\" data-user-id=\"481527\">@Huajian Xin</span>?  (This is my same question above, but hopefully stated more clearly.)</p>",
        "id": 490878204,
        "sender_full_name": "Jason Rute",
        "timestamp": 1735219537
    },
    {
        "content": "<blockquote>\n<p>possible to break up the above proof automatically into the following while recording </p>\n</blockquote>\n<p>Just to demonstrate that this is indeed possible, I'll point out that <a href=\"https://github.com/dwrensha/animate-lean-proofs\"><code>animate-lean-proofs</code></a> automatically decomposes compound tactics:<br>\n<a href=\"/user_uploads/3121/jQGnunJh8-tVNaAst_qjEOWV/example.gif\">example.gif</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/jQGnunJh8-tVNaAst_qjEOWV/example.gif\" title=\"example.gif\"><img data-animated=\"true\" data-original-dimensions=\"640x360\" src=\"/user_uploads/thumbnail/3121/jQGnunJh8-tVNaAst_qjEOWV/example.gif/840x560-anim.webp\"></a></div>",
        "id": 490881570,
        "sender_full_name": "David Renshaw",
        "timestamp": 1735221636
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243791\">@David Renshaw</span> can you give a pointer to the code that does this decomposition?</p>",
        "id": 490882243,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1735222095
    },
    {
        "content": "<p>It happens <a href=\"https://github.com/dwrensha/animate-lean-proofs/blob/97210062385be21aac86dd64f2e6b29d51cb8ea8/Animate.lean#L385-L390\">here</a>.</p>",
        "id": 490882450,
        "sender_full_name": "David Renshaw",
        "timestamp": 1735222209
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 490882480,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1735222230
    },
    {
        "content": "<p>You know the syntax span of the current tactic step, and you can compute the syntax spans of its children, so you can then subtract them.</p>",
        "id": 490882491,
        "sender_full_name": "David Renshaw",
        "timestamp": 1735222243
    },
    {
        "content": "<p>Note that not every compound tactic permits <code>?_</code> contents</p>",
        "id": 490883843,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1735223116
    },
    {
        "content": "<p>Yeah, I think my code might be somewhat sloppy about whether the <code>?_</code> is replacing something in term mode or in tactic mode.</p>",
        "id": 490884052,
        "sender_full_name": "David Renshaw",
        "timestamp": 1735223260
    },
    {
        "content": "<p>Also, I'm willing to massage proofs a bit before passing them to my tool.</p>",
        "id": 490884140,
        "sender_full_name": "David Renshaw",
        "timestamp": 1735223304
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> can you give an example of a tactic you specifically have in mind?</p>",
        "id": 490884282,
        "sender_full_name": "David Renshaw",
        "timestamp": 1735223394
    },
    {
        "content": "<p>what abotu something like all_goals?</p>",
        "id": 490886346,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1735224771
    },
    {
        "content": "<p>what's CobbleStone?</p>",
        "id": 490886976,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1735225210
    },
    {
        "content": "<p>i wonder how aesop deals with pattern matching, does it just use the non pattern matching version of cases?</p>",
        "id": 490887370,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1735225512
    },
    {
        "content": "<p>at the end of the day, i think there needs to be a way for each tactic to say how it wants to be traced (maybe using an attribute tag like @[trace_rule]). since lean as <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  said there is no way to truly distinguish between macros and tactics.</p>",
        "id": 490887705,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1735225767
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"676310\">@Frederick Pu</span> You can find a Cobblestone (an AI theorem prover for Roqc/Coq) discussed on the Roqc/Coq Zulip here: <a href=\"https://coq.zulipchat.com/#narrow/stream/252087-Machine-learning-and-automation/topic/Cobblestone/near/479935600\">https://coq.zulipchat.com/#narrow/stream/252087-Machine-learning-and-automation/topic/Cobblestone/near/479935600</a>.  There are also other relevant papers in that channel.</p>",
        "id": 490891118,
        "sender_full_name": "Jason Rute",
        "timestamp": 1735228122
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"676310\">Frederick Pu</span> <a href=\"#narrow/channel/113488-general/topic/Decomposing.20pattern.20matching.20tactics.20for.20AI/near/490887705\">said</a>:</p>\n<blockquote>\n<p>at the end of the day, i think there needs to be a way for each tactic to say how it wants to be traced (maybe using an attribute tag like @[trace_rule]). since lean as <span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span>  said there is no way to truly distinguish between macros and tactics.</p>\n</blockquote>\n<p>actually on second thought it would probably be better do that at the syntax level for example we could have</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"n\">inductionAlt</span><span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ppDedent</span><span class=\"o\">(</span><span class=\"n\">ppLine</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">inductionAltLHS</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"s2\">\" =&gt; \"</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">tracePoint</span><span class=\"w\"> </span><span class=\"bp\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"n\">hole</span><span class=\"w\"> </span><span class=\"bp\">&lt;|&gt;</span><span class=\"w\"> </span><span class=\"n\">syntheticHole</span><span class=\"w\"> </span><span class=\"bp\">&lt;|&gt;</span><span class=\"w\"> </span><span class=\"n\">tacticSeq</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>where <code>tracePoint</code> is just a dummy parser that reduces to the empty string. (pls excuse if the syntax is slightly wrong, but I hope my general point makes sense)</p>",
        "id": 490894306,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1735230432
    },
    {
        "content": "<p>this would provide a more general way of doing what <span class=\"user-mention\" data-user-id=\"230999\">@Daniel Selsam</span>  did: <a href=\"https://github.com/dselsam/lean4/commit/f577b4c6e64b0f823ac91b7c67eef6b30f3862cf\">https://github.com/dselsam/lean4/commit/f577b4c6e64b0f823ac91b7c67eef6b30f3862cf</a></p>",
        "id": 490896256,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1735231915
    },
    {
        "content": "<p>although it will probably require changing how the syntax command works. since Syntax is basically an opaque type as of now. maybe we have a secondary syntax command <code>syntaxTrace</code> that's used to make the traced version of the syntax that way we don't need to build everything off of a custom fork of lean4 just to get the correct tracing properties</p>",
        "id": 490896513,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1735232082
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243791\">David Renshaw</span> <a href=\"#narrow/stream/113488-general/topic/Decomposing.20pattern.20matching.20tactics.20for.20AI/near/490884282\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> can you give an example of a tactic you specifically have in mind?</p>\n</blockquote>\n<p>I think things like <code>ring &lt;;&gt; (simp; ?_)</code> and maybe  <code>next x y =&gt; ?_</code>.</p>",
        "id": 490897176,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1735232612
    },
    {
        "content": "<p>if we can get aesop to generate holed tactics based on input strings, would we be able to replace the rmax search algorithm used in deepseek prover with a lean metaprogram? Since rmax search seems to be best first search.</p>",
        "id": 491916354,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1736032199
    }
]