[
    {
        "content": "<p>I can't make progress with the following goals, maybe I am missing something to reason with strings. Any idea? </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"mi\">5</span> <span class=\"n\">goals</span>\n<span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">i.δ</span><span class=\"o\">,</span>\n<span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"bp\">∅</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"bp\">∅</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">n</span> <span class=\"bp\">∈</span> <span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">}</span>\n\n<span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">i.δ</span><span class=\"o\">,</span>\n<span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">ir</span> <span class=\"o\">{</span><span class=\"n\">id</span> <span class=\"o\">:=</span> <span class=\"s2\">\"hasChild\"</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"bp\">∅</span>\n<span class=\"bp\">⊢</span> <span class=\"bp\">¬</span><span class=\"s2\">\"hasChild\"</span> <span class=\"bp\">=</span> <span class=\"s2\">\"hasChild\"</span>\n\n<span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">i.δ</span><span class=\"o\">,</span>\n<span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">ir</span> <span class=\"o\">{</span><span class=\"n\">id</span> <span class=\"o\">:=</span> <span class=\"s2\">\"hasChild\"</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">ic</span> <span class=\"o\">{</span><span class=\"n\">id</span> <span class=\"o\">:=</span> <span class=\"s2\">\"man\"</span><span class=\"o\">}</span>\n<span class=\"bp\">⊢</span> <span class=\"bp\">¬</span><span class=\"s2\">\"man\"</span> <span class=\"bp\">=</span> <span class=\"s2\">\"woman\"</span>\n\n<span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">i.δ</span><span class=\"o\">,</span>\n<span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">ir</span> <span class=\"o\">{</span><span class=\"n\">id</span> <span class=\"o\">:=</span> <span class=\"s2\">\"hasChild\"</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">ic</span> <span class=\"o\">{</span><span class=\"n\">id</span> <span class=\"o\">:=</span> <span class=\"s2\">\"man\"</span><span class=\"o\">}</span>\n<span class=\"bp\">⊢</span> <span class=\"bp\">¬</span><span class=\"s2\">\"man\"</span> <span class=\"bp\">=</span> <span class=\"s2\">\"man\"</span><span class=\"n\">a</span>\n\n<span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">i.δ</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">n</span> <span class=\"bp\">∈</span> <span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">n</span> <span class=\"bp\">∈</span> <span class=\"n\">interp</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">Every</span> <span class=\"o\">(</span><span class=\"n\">Role.Atomic</span> <span class=\"o\">{</span><span class=\"n\">id</span> <span class=\"o\">:=</span> <span class=\"s2\">\"hasChild\"</span><span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"n\">Atomic</span> <span class=\"o\">{</span><span class=\"n\">id</span> <span class=\"o\">:=</span> <span class=\"s2\">\"man\"</span><span class=\"o\">}))</span>\n</code></pre></div>\n<p>I am trying to formalize the basic idea of the interpretation of a description logic called ALC. Complete code at <a href=\"https://github.com/arademaker/alc-lean/blob/master/src/alc.lean#L100\">https://github.com/arademaker/alc-lean/blob/master/src/alc.lean#L100</a></p>",
        "id": 225832166,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1612962163
    },
    {
        "content": "<p><code>dec_trivial</code> will prove things like <code>¬\"man\" = \"woman\"</code>. Unless you're redefined negation, I hope you can't prove <code>¬\"hasChild\" = \"hasChild\"</code>!</p>",
        "id": 225840621,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1612966280
    },
    {
        "content": "<p><code>h1</code> before that goal looks like it could provide <code>b ∈ ∅</code> which is false, so it may be provable after all.</p>",
        "id": 225843128,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1612967232
    },
    {
        "content": "<p>I changed my code for using inductive types instead of strings. With this new formalization, I made some progress. But I am now in a situation that may suggest the interpretation of concepts should be changed... My current open goal is below. It is clear that for n=1 and b=2, hypothesis h1 is true. I can even instantiate h1 to h2 with the right number. But now I have a true hypothesis that doesn't depend on the <code>n=1</code>... </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span>\n<span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"o\">{(</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">)}</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"o\">{</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">4</span><span class=\"o\">},</span>\n<span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"o\">{(</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">)}</span> <span class=\"bp\">→</span> <span class=\"mi\">2</span> <span class=\"bp\">∈</span> <span class=\"o\">{</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">4</span><span class=\"o\">}</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span>\n</code></pre></div>\n<p><a href=\"https://github.com/arademaker/alc-lean/blob/master/src/alc.lean#L106\">https://github.com/arademaker/alc-lean/blob/master/src/alc.lean#L106</a> is the open goal. Another question is how <code>finish</code> magically solves the goal below in <a href=\"https://github.com/arademaker/alc-lean/blob/master/src/alc.lean#L117\">https://github.com/arademaker/alc-lean/blob/master/src/alc.lean#L117</a></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">n</span> <span class=\"n\">n2</span> <span class=\"o\">:</span> <span class=\"n\">i.δ</span><span class=\"o\">,</span>\n<span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n<span class=\"n\">hb</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span> <span class=\"bp\">∧</span> <span class=\"n\">n2</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span><span class=\"o\">,</span>\n<span class=\"n\">hb1</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">false</span>\n</code></pre></div>",
        "id": 225852213,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1612970781
    },
    {
        "content": "<p>Your second question can be answered with <code>show_term</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">false</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">show_term</span> <span class=\"o\">{</span><span class=\"n\">finish</span><span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 225856128,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1612972320
    },
    {
        "content": "<p>Looking at that messy output, it turns out that <code>exact nat.one_ne_bit0 _ h</code> is the short proof (<a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.one_ne_bit0\">docs#nat.one_ne_bit0</a>)</p>",
        "id": 225856343,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1612972399
    },
    {
        "content": "<p>Thank you <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> , but quite unnatural, right?</p>",
        "id": 225857816,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1612972874
    },
    {
        "content": "<p>Well, you could also prove it by repeatedly subtracting until you have succ_ne_zero. as:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">nat.succ_ne_zero</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">nat.succ_injective</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n</code></pre></div>\n<p>I'm not sure what you mean by unnatural.</p>",
        "id": 225858253,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1612972949
    },
    {
        "content": "<p>For your first question: <code>h2</code> is trivially true and the goal isn't provable, e.g. evaluate it at <code>n = 3</code>. For your second question: <code>norm_num at hb1</code></p>",
        "id": 225860637,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1612973490
    },
    {
        "content": "<p>Also, <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>?</p>",
        "id": 225862742,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612973953
    },
    {
        "content": "<p>oh there's a link at the end</p>",
        "id": 225862921,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612973984
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span>\n  <span class=\"n\">interp</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">Every</span> <span class=\"o\">(</span><span class=\"n\">Role.Atomic</span> <span class=\"n\">ar.hasChild</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Concept.Atomic</span> <span class=\"n\">ac.man</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"o\">({</span><span class=\"mi\">4</span><span class=\"o\">}</span><span class=\"bp\">ᶜ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">interp</span><span class=\"o\">,</span> <span class=\"n\">r_interp</span><span class=\"o\">,</span> <span class=\"n\">ir</span><span class=\"o\">],</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"n\">H</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">H</span> <span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"n\">revert</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n    <span class=\"n\">norm_num</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"n\">h</span> <span class=\"n\">_</span> <span class=\"o\">(⟨</span><span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span><span class=\"bp\">|</span><span class=\"o\">⟨</span><span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩),</span> <span class=\"o\">{</span><span class=\"n\">norm_num</span><span class=\"o\">},</span>\n    <span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"n\">rfl</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 225865497,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612974592
    },
    {
        "content": "<p>However this probably isn't the theorem you wanted to prove</p>",
        "id": 225865726,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612974642
    },
    {
        "content": "<p>but I don't know enough about your description logic to suggest fixes</p>",
        "id": 225865845,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612974670
    },
    {
        "content": "<p>Also you have too many things marked <code>reducible</code>. None of those definitions should be reducible; definitions by pattern matching should never be reducible</p>",
        "id": 225866428,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612974807
    },
    {
        "content": "<blockquote>\n<p>None of those definitions should be reducible; definitions by pattern matching should never be reducible</p>\n</blockquote>\n<p>Why's that?</p>",
        "id": 225867602,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1612975176
    },
    {
        "content": "<p>Because the only thing it can reduce to is an equation compiler mess</p>",
        "id": 225867660,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612975194
    },
    {
        "content": "<p>Actually, looking at your definitions, it seems like this result is correct: <code>Every hasChild man</code> seems to mean the collection of all people such that every child of theirs is a man, and since the men are <code>2,4</code>, the women are <code>1,3</code> and <code>2</code> is a child of <code>1</code> and <code>3</code> a child of <code>4</code>, the only person for which the predicate fails is <code>4</code> (all the nonbinaries at &gt;4 have no children so the concept is also satisfied for them)</p>",
        "id": 225868145,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612975324
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> I don't understand the <code>bit0</code>, I didn't find any documentation about it. Besides that, it seems that the fact that 1=4 is also should not depend on a bit representation of naturals. In other words, the second proof you suggest  is entirely in the level of abstraction that I would expect: naturals, successor, the fact that succ is injective etc. </p>\n<p>BTW, what is <code>succ.inj</code> in the theorem <code>succ_injective</code>? I didn't find the definition of it (go to definition didn't find it).  But yes, thank you so much for helping me to make sense of this (now obvious!) proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">false</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n <span class=\"c1\">-- if succ 0 = succ 3 then 0 = 3 because succ is injective</span>\n <span class=\"k\">have</span> <span class=\"n\">h1</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">nat.succ_injective</span> <span class=\"n\">h</span><span class=\"o\">),</span>\n <span class=\"n\">apply</span> <span class=\"n\">nat.succ_ne_zero</span> <span class=\"n\">_</span> <span class=\"n\">h1.symm</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 225868964,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1612975608
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/bit0\">docs#bit0</a> has a \"&gt; equations\" toggle you can expand</p>",
        "id": 225869243,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1612975674
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/reasoning.20with.20strings/near/225867660\">said</a>:</p>\n<blockquote>\n<p>Because the only thing it can reduce to is an equation compiler mess</p>\n</blockquote>\n<p>Is this really true?  I still remember the time when unification produced brec_on, but this has been fixed a long long time ago now.</p>",
        "id": 225869362,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1612975692
    },
    {
        "content": "<p><code>succ.inj</code> is autogenerated - all inductive type constructors are axiomatically injective (I think?)</p>",
        "id": 225869449,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1612975721
    },
    {
        "content": "<blockquote>\n<p>it seems that the fact that 1=4 is also should not depend on a bit representation of naturals.</p>\n</blockquote>\n<p>Lean is proof-irrelevant - facts are never dependent on how you choose to prove them</p>",
        "id": 225869605,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1612975763
    },
    {
        "content": "<p>But if you choose to prove equality of naturals using bit0/bit1 instead of zero/succ, you only need <code>log2 n</code> steps instead of <code>n</code> steps to do so</p>",
        "id": 225869797,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1612975813
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110043\">Gabriel Ebner</span> <a href=\"#narrow/stream/113488-general/topic/reasoning.20with.20strings/near/225869362\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/reasoning.20with.20strings/near/225867660\">said</a>:</p>\n<blockquote>\n<p>Because the only thing it can reduce to is an equation compiler mess</p>\n</blockquote>\n<p>Is this really true?  I still remember the time when unification produced brec_on, but this has been fixed a long long time ago now.</p>\n</blockquote>\n<p>Not really, it seems that lean will just ignore the <code>@[reducible]</code> marker in this case instead of providing a brec_on</p>",
        "id": 225870581,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612976094
    },
    {
        "content": "<p>my point is mostly that the annotation does not make any sense</p>",
        "id": 225870663,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612976126
    },
    {
        "content": "<p>I will reiterate <span class=\"user-mention silent\" data-user-id=\"110596\">Rob Lewis</span> 's point that the correct way to prove <code>1 != 4</code> is <code>norm_num</code>. it handles all this bit0 stuff for you and doesn't suffer from any exponential time issues like <code>dec_trivial</code></p>",
        "id": 225870901,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612976222
    },
    {
        "content": "<p>Yes you can prove it directly using <code>nat.one_ne_bit0</code> but that's just what norm_num uses under the hood, users shouldn't need to interact with numerals on this level of abstraction</p>",
        "id": 225871195,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612976335
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/reasoning.20with.20strings/near/225869797\">said</a>:</p>\n<blockquote>\n<p>But if you choose to prove equality of naturals using bit0/bit1 instead of zero/succ, you only need <code>log2 n</code> steps instead of <code>n</code> steps to do so</p>\n</blockquote>\n<p>Interesting, I saw the equations, but still, they don't make sense for me. Maybe I am missing the context. How/Why/When they are used.</p>",
        "id": 225874441,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1612977622
    },
    {
        "content": "<p>It's expensive to express numerals in a unary system: <code>4 = 1 + 1 + 1 + 1</code>. It is more efficient to say that <del><code>4 = bit0 (bit1 0)</code></del> <code>4 = bit0 (bit0 1)</code></p>",
        "id": 225874536,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1612977665
    },
    {
        "content": "<p>Imagine having to prove that <code>35 \\ne 31</code>, you'd have to undo 30 <code>succ</code> to show that these terms are not the same.</p>",
        "id": 225874807,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1612977773
    },
    {
        "content": "<p>Nice! I got it <span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> ...  So bit0 is define for all types instances of <code>has_add</code>.  bit0 is the double of a value. the name <code>bit0</code> is not obvious.</p>",
        "id": 225875389,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1612978014
    },
    {
        "content": "<p>This is implicit in what others have said above but I didn't see it stated explicitly in this thread: numerals like <code>4</code> in Lean are just notation for things built out of <code>bit0</code> and <code>bit1</code> from <code>0</code> and <code>1</code> (which Lean gets from the <code>has_zero</code> and <code>has_one</code> typeclasses):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">set_option</span> <span class=\"n\">pp.numerals</span> <span class=\"n\">false</span>\n<span class=\"k\">#check</span> <span class=\"mi\">4</span> <span class=\"c1\">-- bit0 (bit0 has_one.one) : ℕ</span>\n</code></pre></div>",
        "id": 225875484,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1612978061
    },
    {
        "content": "<p>I think of it is <code>4</code> is <code>100</code> in binary, so read right to left, it is <code>bit0 (bit0 1)</code></p>",
        "id": 225875488,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1612978063
    },
    {
        "content": "<p>The point is that if you have a term written with <code>bit0</code> and <code>bit1</code>, like <code>bit1 $ bit0 $ bit1 $ bit0 $ bit0 1</code> then when you read it backwards you get the binary representation of the value, in this case <code>0b100101</code></p>",
        "id": 225875573,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612978091
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/reasoning.20with.20strings/near/225871195\">said</a>:</p>\n<blockquote>\n<p>Yes you can prove it directly using <code>nat.one_ne_bit0</code> but that's just what norm_num uses under the hood, users shouldn't need to interact with numerals on this level of abstraction</p>\n</blockquote>\n<p>That was my point above. The level of abstraction is important. It doesn't make sense having to deal with bit representation to prove that 1=4 is false.  What about <code>finish</code>. Does it calls <code>norm_num</code>? Or I should really use <code>norm_num</code>?</p>",
        "id": 225875711,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1612978155
    },
    {
        "content": "<p>Now, what's brutal is that the default cast in Lean of anything that has addition to <code>nat</code> is unary! There is a better <code>nat.bin_cast</code>. But unless the thing you're adding has nice properties (<code>add_monoid</code> or a subset of them depending on what you're adding), it's not provable that <code>nat.cast x = nat.bin_cast x</code></p>",
        "id": 225875719,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1612978157
    },
    {
        "content": "<p>That doesn't really matter though unless you use <code>#eval</code> on <code>nat.cast</code></p>",
        "id": 225875919,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612978227
    },
    {
        "content": "<p>You can prove <code>(nat.cast 37 : real) = 37</code> in log n theorem applications</p>",
        "id": 225876009,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612978263
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/reasoning.20with.20strings/near/225875919\">said</a>:</p>\n<blockquote>\n<p>That doesn't really matter though unless you use <code>#eval</code> on <code>nat.cast</code></p>\n</blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib/pull/5462#discussion_r553226279\">https://github.com/leanprover-community/mathlib/pull/5462#discussion_r553226279</a></p>",
        "id": 225876020,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1612978264
    },
    {
        "content": "<p>Which is a form of evaluation of <code>nat.cast</code>.</p>",
        "id": 225876068,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1612978283
    },
    {
        "content": "<p>yes, like I said</p>",
        "id": 225876083,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612978290
    },
    {
        "content": "<p>don't evaluate <code>nat.cast</code> in the VM</p>",
        "id": 225876103,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612978301
    },
    {
        "content": "<p>but you can use it to prove things</p>",
        "id": 225876143,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612978313
    },
    {
        "content": "<p>In the PR you linked though, you are parsing decimal strings, so the obvious approach would be to look for 0-9 and evaluate <code>10*n+a</code>  for each digit</p>",
        "id": 225876439,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612978407
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123965\">Bryan Gin-ge Chen</span> <a href=\"#narrow/stream/113488-general/topic/reasoning.20with.20strings/near/225875484\">said</a>:</p>\n<blockquote>\n<p>This is implicit in what others have said above but I didn't see it stated explicitly in this thread: numerals like <code>4</code> in Lean are just notation for things built out of <code>bit0</code> and <code>bit1</code> from <code>0</code> and <code>1</code> (which Lean gets from the <code>has_zero</code> and <code>has_one</code> typeclasses):</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">set_option</span> <span class=\"n\">pp.numerals</span> <span class=\"n\">false</span>\n<span class=\"k\">#check</span> <span class=\"mi\">4</span> <span class=\"c1\">-- bit0 (bit0 has_one.one) : ℕ</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I see now, but they are not defined over 1 and 0 only, which was my initial difficulty. <code>bit0 1</code> reduces to 2 and <code>reduce bit0 2</code> reduces to 4, certainly because 2 first reduces to <code>bit0 1</code> then <code>bit0 2</code> is <code>bit0 $ bit0 1</code>..</p>\n<p>BTW, in Emacs and Lean 3 (last version). The option you gave me shows <code>nat.zero.succ.succ</code> for <code>bit0 1</code>.</p>",
        "id": 225877043,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1612978658
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/reasoning.20with.20strings/near/225868145\">said</a>:</p>\n<blockquote>\n<p>Actually, looking at your definitions, it seems like this result is correct: <code>Every hasChild man</code> seems to mean the collection of all people such that every child of theirs is a man, and since the men are <code>2,4</code>, the women are <code>1,3</code> and <code>2</code> is a child of <code>1</code> and <code>3</code> a child of <code>4</code>, the only person for which the predicate fails is <code>4</code> (all the nonbinaries at &gt;4 have no children so the concept is also satisfied for them)</p>\n</blockquote>\n<p>Hi <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> , Indeed, this is the right interpretation of description logic. At the end of my file, I point to <a href=\"https://arxiv.org/pdf/1201.4089v3.pdf\">https://arxiv.org/pdf/1201.4089v3.pdf</a>, a good introduction to the language. Basically, the interpretation of <code>forall R.C</code> means  {x | all I(R)-successors of x are in I(C)}. I believe my formalization capture this in <a href=\"https://github.com/arademaker/alc-lean/blob/master/src/alc.lean#L53-L54\">https://github.com/arademaker/alc-lean/blob/master/src/alc.lean#L53-L54</a>. But I may be missing something in the translations of sets to propositions.</p>",
        "id": 225879006,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1612979347
    },
    {
        "content": "<p>So then the only problem was in your statement of the theorem: that example doesn't evaluate to <code>{1}</code>, it evaluates to <code>{4}^c</code></p>",
        "id": 225879332,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612979456
    },
    {
        "content": "<p>No, the only one that has ALL fillers of type Man is {1}</p>",
        "id": 225879474,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1612979520
    },
    {
        "content": "<p>That's not true though</p>",
        "id": 225879580,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612979547
    },
    {
        "content": "<p>2 also has that property, because 2 has no children</p>",
        "id": 225879630,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612979569
    },
    {
        "content": "<p>see also <a href=\"https://en.wikipedia.org/wiki/Vacuous_truth\">https://en.wikipedia.org/wiki/Vacuous_truth</a></p>",
        "id": 225879731,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612979610
    },
    {
        "content": "<p>Oh.. you are right. I got it.</p>",
        "id": 225879763,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1612979625
    },
    {
        "content": "<p>You should try replacing <code>Every</code> with <code>Some</code> and prove that it evaluates to <code>{1}</code></p>",
        "id": 225880004,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612979706
    },
    {
        "content": "<p>So <code>Every hasChild Man</code> should evaluate to {1,2,3}. sorry, as you said above, the complement of {4}.</p>",
        "id": 225880210,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1612979774
    },
    {
        "content": "<p>Thank you <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> , that was so obvious that I am  embarrassed! </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span>\n <span class=\"n\">interp</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">Some</span> <span class=\"o\">(</span><span class=\"n\">Role.Atomic</span> <span class=\"n\">ar.hasChild</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Concept.Atomic</span> <span class=\"n\">ac.man</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"o\">({</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n <span class=\"n\">ext</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n <span class=\"n\">apply</span> <span class=\"n\">iff.intro</span><span class=\"o\">,</span>\n <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">h1</span><span class=\"o\">,</span>\n   <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">interp</span><span class=\"o\">,</span><span class=\"n\">r_interp</span><span class=\"o\">,</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h1</span><span class=\"o\">,</span>\n   <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">ic</span><span class=\"o\">,</span><span class=\"n\">ir</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h1</span><span class=\"o\">,</span>\n   <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n   <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"n\">exists.elim</span> <span class=\"n\">h1</span><span class=\"o\">),</span>\n   <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n   <span class=\"n\">finish</span><span class=\"o\">,</span>\n <span class=\"o\">},</span>\n\n <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">h1</span><span class=\"o\">,</span>\n   <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">interp</span><span class=\"o\">,</span><span class=\"n\">r_interp</span><span class=\"o\">,</span><span class=\"n\">i</span><span class=\"o\">],</span>\n   <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">ic</span><span class=\"o\">,</span><span class=\"n\">ir</span><span class=\"o\">],</span>\n   <span class=\"n\">norm_num</span> <span class=\"n\">at</span> <span class=\"n\">h1</span><span class=\"o\">,</span>\n   <span class=\"n\">rw</span> <span class=\"n\">h1</span><span class=\"o\">,</span>\n   <span class=\"n\">apply</span> <span class=\"n\">exists.intro</span> <span class=\"mi\">2</span><span class=\"o\">,</span>\n   <span class=\"n\">finish</span><span class=\"o\">,</span>\n <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 225882024,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1612980492
    },
    {
        "content": "<p>you should start the proof off with <code>simp [interp, r_interp, ir],</code> like I did, it makes the rest of the proof a lot easier</p>",
        "id": 225882202,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612980580
    },
    {
        "content": "<p>Thank you, yes, it makes sense. The finish in the first branch is doing a lot of work (i saw with <code>show_term{ finish }</code>). I am always curious about how to the steps explicit.</p>",
        "id": 225883976,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1612981396
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> , your proof above didn't work for me. I need to change the first branch to </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">h2</span> <span class=\"o\">:=</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span>\n    <span class=\"n\">revert</span> <span class=\"n\">h2</span><span class=\"o\">,</span>\n    <span class=\"n\">finish</span><span class=\"o\">,</span>\n  <span class=\"o\">}</span>\n</code></pre></div>\n<p>The second branch uses <code>rintro</code>, creating the goals with terms like <code>(1.add 0).succ</code>. I can't even reduce these terms with <code>#reduce</code>... </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"mi\">2</span> <span class=\"n\">goals</span>\n<span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">∈</span> <span class=\"o\">{</span><span class=\"mi\">4</span><span class=\"o\">}</span><span class=\"bp\">ᶜ</span><span class=\"o\">,</span>\n<span class=\"n\">ᾰ</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"n\">add</span> <span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">)</span>\n<span class=\"bp\">⊢</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"n\">add</span> <span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"bp\">∈</span> <span class=\"o\">{</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">4</span><span class=\"o\">}</span>\n\n<span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"n\">add</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"n\">add</span> <span class=\"mi\">0</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"bp\">∈</span> <span class=\"o\">{</span><span class=\"mi\">4</span><span class=\"o\">}</span><span class=\"bp\">ᶜ</span><span class=\"o\">,</span>\n<span class=\"n\">ᾰ</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"n\">add</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"n\">add</span> <span class=\"mi\">0</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"n\">add</span> <span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"o\">{(</span><span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">)}</span>\n<span class=\"bp\">⊢</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"n\">add</span> <span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"bp\">∈</span> <span class=\"o\">{</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">4</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 225908498,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1612991454
    },
    {
        "content": "<p>You used this proof exactly as written?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span>\n  <span class=\"n\">interp</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">Every</span> <span class=\"o\">(</span><span class=\"n\">Role.Atomic</span> <span class=\"n\">ar.hasChild</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Concept.Atomic</span> <span class=\"n\">ac.man</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"o\">({</span><span class=\"mi\">4</span><span class=\"o\">}</span><span class=\"bp\">ᶜ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">interp</span><span class=\"o\">,</span> <span class=\"n\">r_interp</span><span class=\"o\">,</span> <span class=\"n\">ir</span><span class=\"o\">],</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"n\">H</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">H</span> <span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"n\">revert</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n    <span class=\"n\">norm_num</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"n\">h</span> <span class=\"n\">_</span> <span class=\"o\">(⟨</span><span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span><span class=\"bp\">|</span><span class=\"o\">⟨</span><span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩),</span> <span class=\"o\">{</span><span class=\"n\">norm_num</span><span class=\"o\">},</span>\n    <span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"n\">rfl</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 225908702,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612991533
    },
    {
        "content": "<p>The goals shouldn't look anything like that</p>",
        "id": 225908734,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612991547
    },
    {
        "content": "<p>What does your version look like</p>",
        "id": 225908871,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612991632
    },
    {
        "content": "<p>I am getting the error in <code>H 3</code> with 3 in red underline.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"n\">type</span> <span class=\"kd\">class</span> <span class=\"kd\">instance</span> <span class=\"n\">for</span>\n<span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">i.δ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">i.atom_R</span> <span class=\"n\">ar.hasChild</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">i.atom_C</span> <span class=\"n\">ac.man</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">has_one</span> <span class=\"n\">i.δ</span>\n<span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">i.δ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">i.atom_R</span> <span class=\"n\">ar.hasChild</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">i.atom_C</span> <span class=\"n\">ac.man</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">false</span>\n</code></pre></div>",
        "id": 225909354,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1612991859
    },
    {
        "content": "<p>Ah, it's probably because you removed the <code>@[reducible]</code> on <code>i</code></p>",
        "id": 225909636,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612991999
    },
    {
        "content": "<p>Here's a version that works even if <code>i</code> is not reducible</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span>\n  <span class=\"n\">interp</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">Every</span> <span class=\"o\">(</span><span class=\"n\">Role.Atomic</span> <span class=\"n\">ar.hasChild</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Concept.Atomic</span> <span class=\"n\">ac.man</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"o\">({</span><span class=\"mi\">4</span><span class=\"o\">}</span><span class=\"bp\">ᶜ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">interp</span><span class=\"o\">],</span>\n  <span class=\"n\">ext</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">r_interp</span><span class=\"o\">,</span> <span class=\"n\">ir</span><span class=\"o\">],</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"n\">H</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">H</span> <span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"n\">revert</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n    <span class=\"n\">norm_num</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"n\">h</span> <span class=\"n\">_</span> <span class=\"o\">(⟨</span><span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span><span class=\"bp\">|</span><span class=\"o\">⟨</span><span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩),</span> <span class=\"o\">{</span><span class=\"n\">norm_num</span><span class=\"o\">},</span>\n    <span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"n\">rfl</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 225909855,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612992087
    },
    {
        "content": "<p>thank you. yes I have removed the <code>@[reducible]</code>! It is all clear now.</p>",
        "id": 225914095,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1612993810
    }
]