[
    {
        "content": "<p>I have been struggling with type class inference lately. The two main issues are<br>\n(1) The error <code>maximum class-instance resolution depth has been reached</code><br>\n(2) In some cases (which are hard to reproduce in minimal examples) I get incredibly long elaboration times (10-30 seconds for a single definition), and I suspect this is completely caused by type class inference (the eventual error I often get is that the type-class max depth is reached).</p>\n<p>Problem 1 can be easily solved by setting the <code>class.instance_max_depth</code> option higher. Problem 2 makes this solution for problem 1 not that attractive, if type class inference then takes even longer.</p>\n<p>I have some concrete and some open-ended questions:<br>\nQ.1 What does <code>instance_max_depth</code> exactly mean? Does it mean the depth/height of the search tree, or the total number of instances in the solution? For example, in the following example I have to set the depth to 125, with 124 it fails:</p>\n<div class=\"codehilite\"><pre><span></span>import ring_theory.algebra linear_algebra.tensor_product\n\nvariables {R : Type*} [comm_ring R]\nvariables {M : Type*} {N : Type*} [ring M] [ring N]\nvariables [algebra R M] [algebra R N]\n\nlocal notation M ` ⊗[`:100 R `] ` N:100 := tensor_product R M N\n\nnamespace tensor_product\nset_option class.instance_max_depth 125\n\nprotected def mul : M ⊗[R] N →ₗ[R] M ⊗[R] N →ₗ[R] M ⊗[R] N :=\nbegin\n  refine tensor_product.lift ⟨λ m, ⟨λ n, _, _, _⟩, _, _⟩,\n  all_goals { sorry }\nend\n</pre></div>\n\n\n<p>Q.2 Does the option <code>trace.class_instances</code> show the complete trace or does Lean/VSCode truncate the trace somewhere? In traces where I get the max-depth reached error, the highest depth I can find is typically <code>(11)</code> or <code>(12)</code><br>\nQ.3 In the trace, I see the same type class search over and over again (in a single definition). Is the caching of type class instances failing me, or is something else going on?<br>\nQ.4 What are type-class best practices? Do I want to add instances to short-circuit the type class inference? For example, in the example above, if I add the following local instances I don't have to increase the max depth at all:</p>\n<div class=\"codehilite\"><pre><span></span>protected def add_comm_group&#39; : add_comm_group (M ⊗[R] N) := by apply_instance\nprotected def module&#39; : module R (M ⊗[R] N) := by apply_instance\nlocal attribute [instance, priority 2000] tensor_product.add_comm_group&#39; tensor_product.module&#39;\nprotected def lmap_add_comm_group : add_comm_group (M ⊗[R] N →ₗ[R] M ⊗[R] N) := by apply_instance\nprotected def lmap_module : module R (M ⊗[R] N →ₗ[R] M ⊗[R] N) := by apply_instance\nlocal attribute [instance, priority 2000]\n  tensor_product.lmap_add_comm_group tensor_product.lmap_module\n</pre></div>\n\n\n<p>Are there other tips/tricks to keep type-class inference happy/under control?</p>",
        "id": 158624456,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1550246246
    },
    {
        "content": "<p>PS: The reason for the example in Q.1 is that I'm surprised I would need to go to depth 100+.</p>",
        "id": 158653876,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1550268398
    },
    {
        "content": "<p>I just had another problem with type class inference. <br>\nI have an instance (with <code>pp.all true</code>):</p>\n<div class=\"codehilite\"><pre><span></span>_inst_3 : @is_ring_hom.{u_1 u_2} α β (@comm_ring.to_ring.{u_1} α _inst_1) (@comm_ring.to_ring.{u_2} β _inst_2) f\n</pre></div>\n\n\n<p>But the trace shows that this instance does not unify with its own type, even with <code>pp.all</code> true.</p>\n<div class=\"codehilite\"><pre><span></span>[class_instances] (0) ?x_9 : @is_ring_hom.{u_1 u_2} α β (@comm_ring.to_ring.{u_1} α _inst_1) (@comm_ring.to_ring.{u_2} β _inst_2) f := _inst_3\nfailed is_def_eq\n</pre></div>\n\n\n<p>The error occurs here:<br>\n<a href=\"https://github.com/fpvandoorn/formalabstracts/blob/is_ring_hom/src/ring_theory/basic.lean#L28\" target=\"_blank\" title=\"https://github.com/fpvandoorn/formalabstracts/blob/is_ring_hom/src/ring_theory/basic.lean#L28\">https://github.com/fpvandoorn/formalabstracts/blob/is_ring_hom/src/ring_theory/basic.lean#L28</a></p>",
        "id": 158653999,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1550268488
    }
]