[
    {
        "content": "<p>I just published a new chapter in Mathematics in Lean: <a href=\"https://leanprover-community.github.io/mathematics_in_lean/C09_Linear_Algebra.html\">Linear algebra</a>. As usual comments are very welcome, both from beginners and from more advanced users. And PRs fixing typos are very welcome (I have a new baby cat at home who <em>loves</em> keyboard walking).</p>",
        "id": 473043528,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1727425069
    },
    {
        "content": "<p>Regarding \"(this is somehow an implementation accident).\", perhaps a comment about how this is satisfied automatically in the common case of indexing by <code>Nat</code> is worthwhile?</p>",
        "id": 473116319,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727445079
    },
    {
        "content": "<p>I think</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">⊔</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">span_eq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">span_eq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"bp\">.</span><span class=\"n\">span_union</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"bp\">.</span><span class=\"n\">span_induction</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>would be better-written as</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">⊔</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">span_eq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">span_eq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"bp\">.</span><span class=\"n\">span_union</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"bp\">.</span><span class=\"n\">span_induction'</span>\n</code></pre></div>\n<p>or</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">⊔</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">span_eq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">span_eq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"bp\">.</span><span class=\"n\">span_union</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"bp\">.</span><span class=\"n\">span_induction'</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mem</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"n\">hy</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">smul</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>and the </p>\n<blockquote>\n<p>As usual with such lemmas, Lean sometimes needs help to figure out the predicate we are interested in.</p>\n</blockquote>\n<p>is really \"as usual <em>when using <code>apply</code> instead of <code>induction</code></em> with such lemmas\"</p>",
        "id": 473117266,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727445318
    },
    {
        "content": "<blockquote>\n<p>but we still have that, for any two bases of the same vector space, there is a bijection between the types indexing those bases</p>\n</blockquote>\n<p>Is it worth mentioning this result by (lean) name?</p>",
        "id": 473118937,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727445734
    },
    {
        "content": "<p>(But I should say generally this looks excellent, thanks!)</p>",
        "id": 473119072,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727445773
    },
    {
        "content": "<p>Thanks for your suggestions Eric! I am puzzled by the span induction thing. Of course I tried using the induction tactic. But this is not enough. You need to switch from <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Submodule.span_induction#doc\">docs#Submodule.span_induction</a> to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Submodule.span_induction%27#doc\">docs#Submodule.span_induction'</a> as you did. And this makes no sense to me. Do you understand what happens?</p>",
        "id": 473120867,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1727446242
    },
    {
        "content": "<p>In particular it is <em>not</em> really “as usual <em>when using <code>apply</code> instead of <code>induction</code></em> with such lemmas”.</p>",
        "id": 473121067,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1727446305
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113488-general/topic/Linear.20algebra.20in.20MIL/near/473120867\">said</a>:</p>\n<blockquote>\n<p>I am puzzled by the span induction thing. Of course I tried using the induction tactic. But this is not enough. You need to switch from <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Submodule.span_induction#doc\">docs#Submodule.span_induction</a> to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Submodule.span_induction%27#doc\">docs#Submodule.span_induction'</a> as you did. And this makes no sense to me. Do you understand what happens?</p>\n</blockquote>\n<p>Yes, the problem is that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Submodule.span_induction#doc\">docs#Submodule.span_induction</a> is not an induction principle as it does not index the result with the thing that you are inducting on. Arguably we should just replace all these unprimed principles with the primed ones</p>",
        "id": 473131960,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727449545
    },
    {
        "content": "<p>That is, it's crucial that the conclusion of the induction principle is <code>p x hx</code> and not <code>p x</code>, else you are not actually inducting on <code>hx</code>.</p>",
        "id": 473132195,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727449598
    },
    {
        "content": "<p>Ok, that makes sense. So the issue is indeed not with <code>apply</code> vs <code>induction</code>, it is with calling <code>whatever_induction</code> something that does not have the correct shape.</p>",
        "id": 473133172,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1727449908
    },
    {
        "content": "<p>It would be nice to try to replace <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Submodule.span_induction#doc\">docs#Submodule.span_induction</a>  with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Submodule.span_induction%27#doc\">docs#Submodule.span_induction'</a> everywhere. But I really don’t have time for this now.</p>",
        "id": 473133402,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1727449970
    },
    {
        "content": "<p>Once again, you're running into something I also didn't have time for; I got as far as adding a lot of the primed versions, but never made it to replacing the unprimed ones.</p>",
        "id": 473133785,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727450097
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113488-general/topic/Linear.20algebra.20in.20MIL/near/473133172\">said</a>:</p>\n<blockquote>\n<p>Ok, that makes sense. So the issue is indeed not with <code>apply</code> vs <code>induction</code>, it is with calling <code>whatever_induction</code> something that does not have the correct shape.</p>\n</blockquote>\n<p>If you start with the one that has the right shape, I believe <code>apply</code> will still fail. <code>apply</code> pretty much always fails on anything tagged <code>@[elab_as_elim]</code>, I think.</p>",
        "id": 473133901,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727450137
    },
    {
        "content": "<p>Sure. But there is no point saying <code>apply</code> is bad and <code>induction</code> should be used if <code>induction</code> fails just as much. That’s why I stuck to <code>apply</code> which is simpler.</p>",
        "id": 473134428,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1727450284
    },
    {
        "content": "<p>Sorry Patrick, I swear I didn't carefully plan to make your new chapter immediately outdated, but today is the day I finally had the energy to rename <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FiniteDimensional.finrank#doc\">docs#FiniteDimensional.finrank</a> (a long unclear name in a soon-to-be-obsolete namespace) to <code>Module.finrank</code> (a short snappy name close to its sibling <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Module.rank#doc\">docs#Module.rank</a>). See <a href=\"https://github.com/leanprover-community/mathlib4/pull/17192\">#17192</a>.</p>",
        "id": 473143614,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1727452221
    },
    {
        "content": "<p>There is no problem at all, this is normal MIL maintenance.</p>",
        "id": 473145271,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1727452488
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113488-general/topic/Linear.20algebra.20in.20MIL/near/473134428\">said</a>:</p>\n<blockquote>\n<p>Sure. But there is no point saying <code>apply</code> is bad and <code>induction</code> should be used if <code>induction</code> fails just as much. That’s why I stuck to <code>apply</code> which is simpler.</p>\n</blockquote>\n<p><code>refine</code> is the compromise between the two; I believe it can correctly guess the motive for either lemma, if provided enough <code>?_</code>s</p>",
        "id": 473149572,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727453259
    },
    {
        "content": "<p>Indeed it can in this case.</p>",
        "id": 473150005,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1727453372
    },
    {
        "content": "<p>But explaining this isn’t super appealing…</p>",
        "id": 473150083,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1727453395
    },
    {
        "content": "<p>Maybe I can just entice <span class=\"user-mention\" data-user-id=\"556875\">@Pietro Monticone</span> to replace the unprimed induction lemmas with the primed ones in Mathlib or MIL? <span aria-label=\"stuck out tongue wink\" class=\"emoji emoji-1f61c\" role=\"img\" title=\"stuck out tongue wink\">:stuck_out_tongue_wink:</span> He seems to have a penchant for this kind of thing.</p>",
        "id": 473181884,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1727461514
    },
    {
        "content": "<p>Please don’t tempt Pietro, it’s already embarrassing how much work he does for us.</p>",
        "id": 473183439,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1727461965
    },
    {
        "content": "<p>A quick related question: are algorithms like Gaussian elimination to calculate ranks, solve equations etc implemented? I did not see them mentioned here.</p>",
        "id": 473418626,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1727591548
    },
    {
        "content": "<p>Not in Mathlib. There is always the same issue with such algorithms. Do you want them to be implemented in a way that makes them nice to prove properties about or do you want them to be actually usable? I think having both with the same code is (at least currently) impossible. So if you want both you need to implement both and then prove they compute the same thing. This is a lot of work.</p>",
        "id": 473435771,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1727605293
    },
    {
        "content": "<p>That being said, I would already be happy to have a version that is provably correct but not efficient.</p>",
        "id": 473435785,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1727605316
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113488-general/topic/Linear.20algebra.20in.20MIL/near/473435771\">said</a>:</p>\n<blockquote>\n<p>Not in Mathlib. There is always the same issue with such algorithms. Do you want them to be implemented in a way that makes them nice to prove properties about or do you want them to be actually usable? I think having both with the same code is (at least currently) impossible. So if you want both you need to implement both and then prove they compute the same thing. This is a lot of work.</p>\n</blockquote>\n<p>Verifying high perf code in Lean is totally possible but it definitely requires someone rather capable with both programming and proving in Lean. For example <code>bv_decide</code> has an efficiently implemented graph data structure and a couple of caches based on our <code>Std.HashMap</code> etc. that are all verified and yet never show up for more than a couple dozen ms at worst in our profiles.</p>",
        "id": 473436209,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1727605660
    },
    {
        "content": "<p>I should be more explicit. This is in the context of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Matrix#doc\">docs#Matrix</a> which a type synonym for a function type. When you write <code>!![1, 2; 3, 4] : Matrix (Fin 2) (Fin 2) ℕ</code>, you could think you built something like a size 4 Array of natural number. But this is really in <code>Fin 2 → Fin 2 → ℕ</code>. Of course I am completely incompetent in numerical analysis and high performance programming. But my understanding is there is no way to do anything efficient with this data  structure. So, I think the current status is you would need an efficient <code>Array</code>-based implementation and then some glue with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Matrix#doc\">docs#Matrix</a> (and this is not even considering the important case of sparse matrices where <code>Array</code> is not the best choice).</p>",
        "id": 473436658,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1727605986
    },
    {
        "content": "<p>And then my “(at least currently)” is a vague allusion to a future where Lean would automatically translate between the <code>Fin n → Fin m → α</code> implementation and an <code>Array</code>-based implementation without user input.</p>",
        "id": 473436736,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1727606076
    },
    {
        "content": "<p>Thanks. I will target these as possible projects and/or examples in my course beginning in January. Not an array based implementation but hopefully correct and proved correct.</p>",
        "id": 473440049,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1727608977
    },
    {
        "content": "<p>The problem is that it's not really clear what having a provably correct but unusably slow algorithm actually buys you. :-)</p>\n<p>The thing that it <em>might</em> buy you is a cheap way to prove a fast algorithm correct: now you just need to compare the extensional behaviour of the fast algorithm with the slow algorithm, rather than directly checking the spec on the fast algorithm. However achieving this payoff nearly always requires designing the fast (for execution) and slow (for verification) algorithms in tandem.</p>",
        "id": 473440207,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1727609120
    },
    {
        "content": "<p>Yes, this is what I tried to explain.</p>",
        "id": 473440502,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1727609371
    },
    {
        "content": "<p>But we can still argue that coding the naive version and proving it correct is math formalization since it gives Lean the same explanation we give to students in math courses.</p>",
        "id": 473440575,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1727609410
    },
    {
        "content": "<p>There are even linear algebra courses which try to use these algorithm to prove as many things as possible, replacing abstract arguments about abstract vector spaces.</p>",
        "id": 473440615,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1727609448
    },
    {
        "content": "<p>I would guess that for modest sized matrices slow algorithms are fast enough in practice. So linear equations coming from human mathematics say may be solvable.</p>",
        "id": 473444232,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1727612513
    }
]