[
    {
        "content": "<p>I'm trying to create a Lean library that does something similar to <a href=\"https://github.com/ott-lang/ott\">ott</a> by using Lean's metaprogramming features to embed an ott-like DSL. I've managed to create commands for defining metavariables and non-terminals (with elaborations to inductive datatypes and syntax definitions), and I'm currently trying to figure out how to create something similar to the <code>defns</code>/<code>defn</code> syntax from ott, which defines judgements through inference rules.</p>\n<p>The issue is that a <code>defn</code>-like command will need to allow the user to define syntax for the judgement (for example the syntax <code>G \" |- \" e \" : \" t</code> could be used for a simple typing judgement, where G, e, and t are non-terminals for environment, expression, and type that have already been defined) and then make use of that syntax within the same command, since the conclusion of each inference rule should use the judgement's syntax. Does anyone have recommendations about how I should do this? My current thought is that I'd need to define a custom <code>ParserFn</code> which parses things dynamically based on its interpretation of the user-provided judgement syntax, but this seems less than ideal since I'd have to duplicate a lot of the code that already exists inside <code>toParserDescr</code> (since that function returns a term for a <code>ParserDescr</code> or <code>TrailingParserDescr</code> instead of a <code>ParserFn</code> value that can be used immediately).</p>\n<p>The one easier (but less elegant) alternative that I've considered is having two separate commands, one which defines the syntax for the judgement, then a second which specifies the inference rule. Then I could just use <code>toParserDescr</code> when elaborating the first command and I wouldn't have this problem, but it would be much nicer to be able to make them a single command, since then you wouldn't have to repeat any information in both to link the two.</p>\n<p>Let me know if anything I've said needs clarification! Thanks for any help/suggestions!</p>",
        "id": 454652359,
        "sender_full_name": "Matthew Toohey",
        "timestamp": 1722193773
    },
    {
        "content": "<p>I think your evaluation of the status quo is exactly right. How I want to solve this for <code>inductive</code> (and Verso) is by allowing commands to do their own additional parsing, but currently they can neither read nor write the parser state</p>",
        "id": 454654058,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1722194351
    },
    {
        "content": "<p>That's unfortunate, thanks for confirming though! Maybe I'll go with the easier approach for now, and if what you've suggested becomes possible at some point I can switch things to use that then.</p>",
        "id": 454655589,
        "sender_full_name": "Matthew Toohey",
        "timestamp": 1722194787
    }
]