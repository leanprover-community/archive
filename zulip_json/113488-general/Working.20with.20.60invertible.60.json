[
    {
        "content": "<p>Does anyone have any tips for working with <code>invertible</code>? I always find it really awkward to prove even the most basic facts, such as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.invertible</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- `1 + ⅟x` is invertible if `x + 1` is -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">invertible_one_add_inv_of</span> <span class=\"o\">[</span><span class=\"n\">invertible</span> <span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">invertible</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">invertible</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"bp\">⅟</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"n\">invertible</span> <span class=\"o\">((</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"bp\">⅟</span><span class=\"n\">x</span><span class=\"o\">),</span>\n  <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"n\">this.copy</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">add_one_mul</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">mul_inv_of_self</span><span class=\"o\">],</span> <span class=\"o\">},</span>\n  <span class=\"n\">letI</span> <span class=\"o\">:</span> <span class=\"n\">invertible</span> <span class=\"o\">((</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"bp\">⅟</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">invertible_mul</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"o\">((</span><span class=\"n\">unit_of_invertible</span> <span class=\"o\">((</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"bp\">⅟</span><span class=\"n\">x</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">copy</span> <span class=\"n\">_</span> <span class=\"n\">rfl</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"bp\">⅟</span><span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">invertible</span><span class=\"o\">,</span>\n  <span class=\"n\">dsimp</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">inv_of_mul</span><span class=\"o\">,</span> <span class=\"n\">inv_of_inv_of</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">one_add_inv_of</span> <span class=\"o\">[</span><span class=\"n\">invertible</span> <span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">invertible</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"n\">invertible</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"bp\">⅟</span><span class=\"n\">x</span><span class=\"o\">)]</span> <span class=\"o\">:</span>\n  <span class=\"bp\">⅟</span><span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"bp\">⅟</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"bp\">*⅟</span><span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">letI</span> <span class=\"o\">:=</span> <span class=\"n\">invertible_one_add_inv_of</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">convert</span> <span class=\"o\">(</span><span class=\"n\">rfl</span> <span class=\"o\">:</span> <span class=\"bp\">⅟</span><span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"bp\">⅟</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Going further and showing <code>invertible (⅟x + 1) ≃ invertible (1 + x)</code> (proof: it's just multiplication by the unit <code>units_of_invertible x</code>) is even more annoying</p>",
        "id": 362437784,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685535148
    },
    {
        "content": "<p>Yeah type classes make things hard <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 362438709,
        "sender_full_name": "Reid Barton",
        "timestamp": 1685535363
    },
    {
        "content": "<p>A slightly better statement might be</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- `1 + u` is invertible if `u + 1` is -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">units.invertible_one_add_inv_of</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"bp\">ˣ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">invertible</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">invertible</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"bp\">↑</span><span class=\"n\">u</span><span class=\"bp\">⁻¹</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"n\">invertible</span> <span class=\"o\">((</span><span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"bp\">↑</span><span class=\"n\">u</span><span class=\"bp\">⁻¹</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">),</span>\n  <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"n\">this.copy</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">add_one_mul</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">),</span> <span class=\"n\">units.mul_inv</span><span class=\"o\">],</span> <span class=\"o\">},</span>\n  <span class=\"n\">letI</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">u</span><span class=\"bp\">⁻¹</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">invertible</span><span class=\"o\">,</span>\n  <span class=\"n\">letI</span> <span class=\"o\">:</span> <span class=\"n\">invertible</span> <span class=\"o\">((</span><span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"bp\">↑</span><span class=\"n\">u</span><span class=\"bp\">⁻¹</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">invertible_mul</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"o\">((</span><span class=\"n\">unit_of_invertible</span> <span class=\"o\">((</span><span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"bp\">↑</span><span class=\"n\">u</span><span class=\"bp\">⁻¹</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">copy</span> <span class=\"n\">_</span> <span class=\"n\">rfl</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">*</span> <span class=\"bp\">⅟</span><span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">invertible</span><span class=\"o\">,</span>\n  <span class=\"n\">dsimp</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">inv_of_mul</span><span class=\"o\">,</span> <span class=\"n\">inv_of_units</span><span class=\"o\">,</span> <span class=\"n\">inv_inv</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">units.one_add_inv_of</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"bp\">ˣ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">invertible</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"n\">invertible</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"bp\">↑</span><span class=\"n\">u</span><span class=\"bp\">⁻¹</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)]</span> <span class=\"o\">:</span>\n  <span class=\"bp\">⅟</span><span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"bp\">↑</span><span class=\"n\">u</span><span class=\"bp\">⁻¹</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">u</span><span class=\"bp\">*⅟</span><span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">letI</span> <span class=\"o\">:=</span> <span class=\"n\">u.invertible_one_add_inv_of</span><span class=\"o\">,</span>\n  <span class=\"n\">convert</span> <span class=\"o\">(</span><span class=\"n\">rfl</span> <span class=\"o\">:</span> <span class=\"bp\">⅟</span><span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"bp\">↑</span><span class=\"n\">u</span><span class=\"bp\">⁻¹</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>but I don't see an obvious trick to help the proof</p>",
        "id": 362438962,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685535431
    },
    {
        "content": "<p>I believe the recommendation is to work in <code>units</code> and only at the last stage convert back to <code>invertible</code>. Since <code>units</code> has much more API, would that help here?</p>",
        "id": 362442993,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1685536380
    },
    {
        "content": "<p>If I work with units, I need a hypothesis <code>u2 = u + 1</code></p>",
        "id": 362444617,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685536785
    },
    {
        "content": "<p>So my statement becomes something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"bp\">↑</span><span class=\"n\">u2</span> <span class=\"bp\">=</span> <span class=\"bp\">↑</span><span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"bp\">↑</span><span class=\"n\">u3</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"bp\">↑</span><span class=\"n\">u</span><span class=\"bp\">⁻¹</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">↑</span><span class=\"n\">u3</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">=</span> <span class=\"bp\">↑</span><span class=\"n\">u</span> <span class=\"bp\">*</span> <span class=\"bp\">↑</span><span class=\"n\">u2</span><span class=\"bp\">⁻¹</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>which no longer resembles <code>⅟(1 + ↑u⁻¹ : R) = u*⅟(u + 1) </code> at all!</p>",
        "id": 362445065,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685536896
    },
    {
        "content": "<p>I see, and <code>is_unit</code> is not good if you want it to be computable.</p>",
        "id": 362446039,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1685537117
    },
    {
        "content": "<p>That woul make the goal be <code>↑hu3.unit⁻¹ = ↑u * hu2.unit⁻¹</code> which seems almost as bad!</p>",
        "id": 362446975,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685537342
    },
    {
        "content": "<p>I guess you could prove it about <code>ring.inverse</code>; but then you need to separately prove that <code>is_unit</code> for the RHS implies <code>is_unit</code> for the LHS</p>",
        "id": 362447120,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685537381
    },
    {
        "content": "<p>The <a href=\"https://github.com/leanprover-community/mathlib/blob/12a85fac627bea918960da036049d611b1a3ee43/src/linear_algebra/matrix/nonsingular_inverse.lean#L457-L516\">code around <code>diagonal_invertible</code></a> gives a demonstration of how <code>invertible</code> can be somewhat useful</p>",
        "id": 362447408,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685537447
    },
    {
        "content": "<p>In that it gives us <code>is_unit (diagonal v) ↔ is_unit v </code> and <code>(diagonal v)⁻¹ = diagonal (ring.inverse v)</code> mostly at the same time, without having to repeat the same algebra</p>",
        "id": 362447574,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685537492
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/18849\">#18849</a> is a somewhat nastier example</p>",
        "id": 362447906,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685537555
    },
    {
        "content": "<p>Not sure if you like this better:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">invertible_one_add_inv_of</span> <span class=\"o\">[</span><span class=\"n\">invertible</span> <span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">invertible</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">invertible</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"bp\">⅟</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"bp\">*⅟</span><span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span><span class=\"bp\">;</span> <span class=\"n\">nontriviality</span> <span class=\"n\">R</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"o\">(</span><span class=\"n\">unit_of_invertible</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">⁻¹.</span><span class=\"n\">mul_right_inj</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"o\">(</span><span class=\"n\">unit_of_invertible</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mul_left_inj</span><span class=\"o\">],</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">coe_unit_of_invertible</span><span class=\"o\">,</span> <span class=\"n\">mul_one</span><span class=\"o\">,</span> <span class=\"n\">inv_of_mul_self</span><span class=\"o\">,</span> <span class=\"n\">coe_inv_unit_of_invertible</span><span class=\"o\">],</span>\n    <span class=\"k\">calc</span> <span class=\"bp\">⅟</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"bp\">⅟</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"bp\">⅟</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"bp\">*</span> <span class=\"n\">x</span>\n        <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">⅟</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"bp\">⅟</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"bp\">⅟</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"n\">noncomm_ring</span>\n    <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">mul_assoc</span><span class=\"o\">,</span> <span class=\"n\">add_mul</span><span class=\"o\">],</span>\n    <span class=\"n\">simp</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 362449738,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1685537952
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.invertible</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- `1 + ⅟x` is invertible if `x + 1` is -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">invertible_one_add_inv_of</span> <span class=\"o\">[</span><span class=\"n\">invertible</span> <span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">invertible</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">invertible</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"bp\">⅟</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">convert</span> <span class=\"n\">invertible_mul</span> <span class=\"o\">(</span><span class=\"bp\">⅟</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">),</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">mul_add</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 362452713,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1685538603
    },
    {
        "content": "<p>It doesn't count unless you also prove <code>⅟(1 + ⅟x) = x*⅟(x + 1)</code></p>",
        "id": 362453662,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685538817
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">one_add_inv_of</span> <span class=\"o\">[</span><span class=\"n\">invertible</span> <span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">invertible</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"n\">invertible</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"bp\">⅟</span><span class=\"n\">x</span><span class=\"o\">)]</span> <span class=\"o\">:</span>\n  <span class=\"bp\">⅟</span><span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"bp\">⅟</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"bp\">*⅟</span><span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"n\">inv_of_eq_right_inv</span><span class=\"o\">,</span>\n  <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">add_mul</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">mul_inv_of_self</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">),</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 362455835,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1685539326
    },
    {
        "content": "<p>a.k.a. \"these things follow formally from properties of inverses\"</p>",
        "id": 362457479,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1685539708
    },
    {
        "content": "<p>I guess this works here because the proof is trivial in both cases, but in general you end up proving pretty much the same thing in the first and second declaration</p>",
        "id": 362458113,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685539848
    },
    {
        "content": "<p>Since we are discussing this, and since I have fought a bit with <code>invertible</code>, can I ask why being in <code>Type</code> rather than in <code>Prop</code>makes \"computation easier\"? Also, it seems to me tat the sentence in the doc \"The intent of the typeclass is to provide a way to write e.g.  ⅟2 in a ring like ℤ[1/2] where some inverses exist but there is no general ⁻¹ operator;\" is a bit strange. <code>is_unit</code> does not need this inverse operator neither, is it an old piece of doc?</p>",
        "id": 362458390,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1685539909
    },
    {
        "content": "<p>I think the point is that <code>invertible</code> actually carries around the inverse, even though mathematically this is daft because it's unique so you can just use classical.some</p>",
        "id": 362458610,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1685539948
    },
    {
        "content": "<p>You never need to know what the inverse actually is in the calculations above, you are just formally using the fact that 1/x * x = 1</p>",
        "id": 362458776,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1685539979
    },
    {
        "content": "<p>Ah, I see.</p>",
        "id": 362458808,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1685539982
    },
    {
        "content": "<p>The benefit of carrying around the inverse is that you can prove it has an inverse, <em>and what that inverse is</em> all at once</p>",
        "id": 362458909,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685540005
    },
    {
        "content": "<p>OK ok, I see, it makes sense. And concerning the doc, do you agree that it is somewhat strange?</p>",
        "id": 362459044,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1685540038
    },
    {
        "content": "<p><code>is_unit</code> doesn't actually give you the inverse; are you thinking of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/ring.inverse\">docs#ring.inverse</a> or <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_unit.unit\">docs#is_unit.unit</a>?</p>",
        "id": 362459195,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685540064
    },
    {
        "content": "<p>At first reading one would imagine that <code>unit</code> or <code>is_unit</code> need an <code>has_inv</code> instance, but this is not the case.</p>",
        "id": 362459197,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1685540064
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/Working.20with.20.60invertible.60/near/362459195\">said</a>:</p>\n<blockquote>\n<p><code>is_unit</code> doesn't actually give you the inverse; are you thinking of <code>ring.inverse</code>?</p>\n</blockquote>\n<p>Well, as <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> said it gives it through <code>some</code>, because it gives you a term of <code>units M</code></p>",
        "id": 362459448,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1685540123
    },
    {
        "content": "<p>Right, that's <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_unit.unit\">docs#is_unit.unit</a></p>",
        "id": 362459500,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685540133
    },
    {
        "content": "<p>The doc looks fine to me: what's the problem? <code>classical.some</code> + <code>is_unit</code> is arguably more inconvenient than <code>invertible</code>, just like we don't have an axiom in group theory in Lean saying \"there exists an identity element\", we have a field of the structure saying \"this is the identity element\".</p>",
        "id": 362459593,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1685540153
    },
    {
        "content": "<p>Please don't use <code>classical.some</code> with <code>is_unit</code>, that's what  <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_unit.unit\">docs#is_unit.unit</a> is for! (edit: the latter has a nicer defeq that means you don't need <code>some_spec</code>)</p>",
        "id": 362459724,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685540177
    },
    {
        "content": "<p>Agreed, I simply want to say that <code>is_unit</code>seems to carry the inverse as well, because terms in <code>units M</code> do.</p>",
        "id": 362459972,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1685540232
    },
    {
        "content": "<p>Eric, it seems to me like the solution to this:<br>\n<span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/Working.20with.20.60invertible.60/near/362458113\">said</a>:</p>\n<blockquote>\n<p>I guess this works here because the proof is trivial in both cases, but in general you end up proving pretty much the same thing in the first and second declaration</p>\n</blockquote>\n<p>might be something like an <code>invertible.copy_inv</code> where you provide an inverse and the proofs, and then another another inverse which you prove is equal to the first, then you put the second one as the data in the instance. Of course, you wouldn't actually be copying an existing <code>invertible</code> since its a class not a structure, but this seems like it addresses your \"doing the same computation twice\" complaint.</p>",
        "id": 362460726,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1685540399
    },
    {
        "content": "<p>(Maybe <code>copy_inv</code> is a bad name)</p>",
        "id": 362460930,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1685540434
    },
    {
        "content": "<p>Yes, I was leaning towards that too; indeed, that's why my proof goes through <code>units.copy</code> which was a way of doing that without writing more API</p>",
        "id": 362460974,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685540447
    },
    {
        "content": "<p>Meh, I think this is a reasonable constructor to have for <code>invertible</code>.</p>",
        "id": 362461120,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1685540486
    },
    {
        "content": "<p>Maybe <a href=\"https://leanprover-community.github.io/mathlib_docs/find/invertible.copy\">docs#invertible.copy</a> is useless and should instead be the version you describe</p>",
        "id": 362461141,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685540491
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/Working.20with.20.60invertible.60/near/362459593\">said</a>:</p>\n<blockquote>\n<p>The doc looks fine to me: what's the problem? <code>classical.some</code> + <code>is_unit</code> is arguably more inconvenient than <code>invertible</code>, just like we don't have an axiom in group theory in Lean saying \"there exists an identity element\", we have a field of the structure saying \"this is the identity element\".</p>\n</blockquote>\n<p>My problem with the doc is probably that it makes no reference to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/ring.inverse\">docs#ring.inverse</a> and it is therefore difficult to find a way through the several definitions (<code>invertible</code>, <code>is_unit</code>, <code>unit</code>, <code>inverse</code>, etc...)</p>",
        "id": 362461172,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1685540497
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"300245\">@Filippo A. E. Nuccio</span>, don't forget <code>matrix.has_inv</code> which is equal to <code>ring.inverse</code> everywhere but not defeq!</p>",
        "id": 362461304,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685540523
    },
    {
        "content": "<p>I don't think <code>invertible.copy</code> is useless. That allows you to transfer an invertible instance from one element to another, while preserving the inverse. The <code>copy_inv</code> proposal is different (because you aren't already given an <code>invertible</code> instance).</p>",
        "id": 362461482,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1685540573
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span>, do you mean this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- This is defined such that `⅟y = yi` -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">invertible.more_copy</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">invertible</span> <span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hxy</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">yi</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hyi</span> <span class=\"o\">:</span> <span class=\"n\">yi</span> <span class=\"bp\">=</span> <span class=\"bp\">⅟</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">invertible</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n<span class=\"o\">((</span><span class=\"n\">unit_of_invertible</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">copy</span> <span class=\"n\">_</span> <span class=\"n\">hxy</span> <span class=\"n\">yi</span> <span class=\"n\">hyi</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">invertible</span>\n</code></pre></div>",
        "id": 362462306,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685540752
    },
    {
        "content": "<p>There is also a nice <a href=\"https://leanprover-community.github.io/mathlib_docs/find/mv_power_series.inv.aux\">docs#mv_power_series.inv.aux</a> that always creates an auxiliary (mv) power series depending of an element of the coefficient ring, and whenever this elements happens to be the inverse of the constant terms it really gives the inverse of the power series <span aria-label=\"eyes\" class=\"emoji emoji-1f440\" role=\"img\" title=\"eyes\">:eyes:</span></p>",
        "id": 362462344,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1685540761
    },
    {
        "content": "<p>That's not what I meant, but maybe it would be handy if the existing <a href=\"https://leanprover-community.github.io/mathlib_docs/find/invertible.copy\">docs#invertible.copy</a> were changed to that (I'm not sure). What I meant was this (untested):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- This is defined so that `⅟x = xi'`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">invertible.mk_inv</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">xi</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">xi'</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">xi</span> <span class=\"bp\">=</span> <span class=\"n\">xi'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hx_mul_inv</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">xi</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hx_inv_mul</span> <span class=\"o\">:</span> <span class=\"n\">xi</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">invertible</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"n\">xi'</span><span class=\"o\">,</span> <span class=\"n\">hx</span> <span class=\"bp\">▸</span> <span class=\"n\">hx_mul_inv</span><span class=\"o\">,</span> <span class=\"n\">hx</span> <span class=\"bp\">▸</span> <span class=\"n\">hx_inv_mul</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>But maybe I have misunderstood your original complaint?</p>",
        "id": 362464530,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1685541233
    },
    {
        "content": "<p>I think that would be more convenient with <code>x</code>,<code>xi</code>, and the two <code>hx</code>s bundled... Which essentially gives you what I suggest above!</p>",
        "id": 363918235,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686038689
    },
    {
        "content": "<p>One thing I realized today is that <code>invertible</code> doesn't follow a pattern we've established elsewhere:</p>\n<table>\n<thead>\n<tr>\n<th>Existence</th>\n<th>Explicit existence</th>\n<th>sometimes-junk value</th>\n<th>never-junk value</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>summable f</code></td>\n<td><code>has_sum f a</code></td>\n<td><code>tsum f</code></td>\n<td>-</td>\n</tr>\n<tr>\n<td><code>differentiable f</code></td>\n<td><code>has_deriv_at f f ' a</code></td>\n<td><code>deriv f a</code></td>\n<td>-</td>\n</tr>\n<tr>\n<td><code>is_unit x</code></td>\n<td><code>invertible x</code></td>\n<td><code>ring.inverse x</code></td>\n<td><code>⅟x</code> (<code>inv_of</code>)</td>\n</tr>\n</tbody>\n</table>\n<p>Where the last row is the clear odd-one-out</p>",
        "id": 363924808,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686040220
    },
    {
        "content": "<p>Frankly I've found both <code>has_sum</code> and <code>inv_of</code> pretty irritating; the former forces you to use <code>convert</code> all the time when the <code>a</code> term is wrong, while the latter has equalities that you can rewrite but you have to build a bunch of typeclasses up front to use it.</p>",
        "id": 363926120,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686040455
    },
    {
        "content": "<p><code>has_sum</code> is super-useful in teaching, especially before you've proved the theorem that says that a series has at most one sum.</p>",
        "id": 363932078,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1686041975
    },
    {
        "content": "<p>Oh I completely agree it's way better than not having it at all!</p>",
        "id": 363935912,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686042960
    },
    {
        "content": "<p>My comment is more that the design constraints feel the same in both places, yet we've come up with two different solutions; is there a hybrid that is better than both?</p>",
        "id": 363936551,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686043119
    },
    {
        "content": "<p>I guess another example of \"never junk value\" would be the division function which demands a proof that the denominator is nonzero, and we don't have that either AFAIK.</p>",
        "id": 363992105,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1686055751
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/divp\">docs#divp</a>?</p>",
        "id": 363993417,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1686056018
    },
    {
        "content": "<p>About <code>has_sum</code>/<code>has_deriv_at</code>/...: should we add <code>congr_right</code> lemmas like <code>has_sum f x -&gt; x = y -&gt; has_sum f y</code> to avoid <code>convert</code>?</p>",
        "id": 363996045,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686056581
    },
    {
        "content": "<p>Talking of \"existence vs. explicit existence\", I've often wondered whether the integration library might benefit from introducing <code>has_integral f μ a</code>, analogous to <code>has_sum f a</code>.</p>",
        "id": 364004042,
        "sender_full_name": "David Loeffler",
        "timestamp": 1686058180
    },
    {
        "content": "<p>I'm coming to the conclusion that what we probably want is a <code>has_inverse x x_inv</code> proposition; the reason we don't have it already is probably that it's mostly useless in commutative setting where you can just write <code>x * x_inv = 1</code></p>",
        "id": 364566365,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686231755
    },
    {
        "content": "<p>I think you're right. I ran into this kind of headache on the way to proving the Gelfand formula for the spectral radius, but at the time I didn't recognize that this missing API was the problem. I think I got around it by defining a new <code>Units</code> term and then using that, but the details are a bit murky.</p>",
        "id": 364572809,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1686233019
    },
    {
        "content": "<p>Should we introduce something between <code>DivInvMonoid</code> (fixed) and <code>DivisionMonoid</code> instead assuming just <code>∀ a b, a * b = 1 → b * a = 1 → a⁻¹ = b</code>?</p>",
        "id": 364594065,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686236682
    },
    {
        "content": "<p>And use <code>a⁻¹</code> everywhere?</p>",
        "id": 364594138,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686236696
    },
    {
        "content": "<p>I think we'd want has_inverse first</p>",
        "id": 364594511,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686236759
    },
    {
        "content": "<p>What is a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=DIvInvMonoid#doc\">docs4#DIvInvMonoid</a> ?</p>",
        "id": 364594513,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1686236759
    },
    {
        "content": "<p>It's a monoid with the obvious link between div and inv and <del>nothing else</del> integer powers</p>",
        "id": 364594797,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686236805
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=DivInvMonoid#doc\">docs4#DivInvMonoid</a></p>",
        "id": 364594900,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686236826
    },
    {
        "content": "<p>Another approach is to add this axiom to <code>DivInvMonoid</code>.</p>",
        "id": 364596353,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686237100
    },
    {
        "content": "<p>I guess, this is true in all instances.</p>",
        "id": 364596428,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686237111
    },
    {
        "content": "<p>We already had this discussion, and the upshot is that it's not so obvious.</p>",
        "id": 364604843,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1686238583
    },
    {
        "content": "<p>Could you give a link (or an example), please?</p>",
        "id": 364609509,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686239601
    },
    {
        "content": "<p>Were n*n matrices a problem?</p>",
        "id": 364689978,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1686263075
    },
    {
        "content": "<p>What's wrong with matrices? The <code>Inv.inv</code> (with any reasonable definition) agrees with <code>Unit.val</code>/<code>Unit.inv</code>.</p>",
        "id": 364692516,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686264209
    },
    {
        "content": "<p>Yury, I suspect the answer is that your generalization can't actually be used in many existing lemmas because it doesn't specify the junk value for non-invertible elements</p>",
        "id": 364695343,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686265687
    },
    {
        "content": "<p>But it can be used in all lemmas that only deal with invertible elements (e.g., smoothness of <code>Ring.inverse</code>).</p>",
        "id": 364702685,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686270278
    },
    {
        "content": "<p>I sketched some of the basic theory of the left inverse implies right inverse typeclass here <a href=\"https://github.com/leanprover-community/mathlib/pull/11376\">https://github.com/leanprover-community/mathlib/pull/11376</a> but it is quite old!</p>",
        "id": 365066806,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1686389772
    }
]