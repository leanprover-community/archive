[
    {
        "content": "<p>How would one go about formalizing something like this?<br>\n<a href=\"/user_uploads/3121/S8CblpoIWncIZ01uvuWsQk0M/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/S8CblpoIWncIZ01uvuWsQk0M/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/S8CblpoIWncIZ01uvuWsQk0M/image.png\"></a></div><p>I am following Introduction to Homotopy Type Theory by Egbert Rijke (<a href=\"https://arxiv.org/abs/2212.11082\">https://arxiv.org/abs/2212.11082</a>) and in it they suggest that \"The more ambitious student may even try to formalize the solutions of some of the exercises in a computer proof assistant.\" I wonder how this is done, since I want to try and learn Lean by reading the book and trying to formalize the exercises.</p>\n<p>Lean already uses dependent types, but trying something like this does not work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">A'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span>\n\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">eq</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">A'</span>\n\n<span class=\"kn\">example</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">eq</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I thought maybe instead I need to define dependent types inside Lean (e.g. create types for the Context, Judgements, write axioms for the inference rules), but this did not feel right. For example, nowhere do I define that future types that I add may depend only on the previously added elements. I also have no clue how to actually make the axioms work.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Context</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">empty</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">comma</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Î“</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Context</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">element</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Value</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">type</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Judgement</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Î“</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Context</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">equal_types</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Î“</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Context</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">element</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Î“</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Context</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Value</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">equal_elements</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Î“</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Context</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Value</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Value</span><span class=\"o\">)</span>\n\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Î“</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Context</span><span class=\"o\">)</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xâ‚</span><span class=\"w\"> </span><span class=\"n\">xâ‚‚</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Value</span><span class=\"o\">)</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Aâ‚</span><span class=\"w\"> </span><span class=\"n\">Aâ‚‚</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">formationâ‚</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Judgement</span><span class=\"bp\">.</span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Context</span><span class=\"bp\">.</span><span class=\"n\">comma</span><span class=\"w\"> </span><span class=\"n\">Î“</span><span class=\"w\"> </span><span class=\"n\">xâ‚</span><span class=\"w\"> </span><span class=\"n\">Aâ‚</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">Aâ‚‚</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Judgement</span><span class=\"bp\">.</span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">Î“</span><span class=\"w\"> </span><span class=\"n\">Aâ‚</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I would appreciate some help with how to get started with formalizing dependent type theory for the purpose of verifying my solutions to exercises in the book.</p>",
        "id": 448960908,
        "sender_full_name": "Viliam Vadocz",
        "timestamp": 1720045583
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"692539\">Viliam Vadocz</span> <a href=\"#narrow/stream/113488-general/topic/Formalizing.20Dependent.20Type.20Theory/near/448960908\">said</a>:</p>\n<blockquote>\n<p>Lean already uses dependent types, but trying something like this does not work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">A'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span>\n\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">eq</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">A'</span>\n\n<span class=\"kn\">example</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">eq</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n</blockquote>\n<p>This definitely works, you just have the syntax a bit off.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">A'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">eq</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">A'</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">â†</span><span class=\"w\"> </span><span class=\"n\">eq</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>\n<p>But you are right that this is somewhat of a cheat, and a proper formalization would need to define contexts and all the rest.</p>",
        "id": 448961953,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1720046079
    },
    {
        "content": "<p>Here's a basic formalization of the four judgments you mention:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Ty</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nat</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Context</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">empty</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">comma</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Î“</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Context</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">element</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">type</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ty</span><span class=\"o\">)</span>\n\n<span class=\"kn\">mutual</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">IsType</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Context</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Ty</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nat</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Î“</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsType</span><span class=\"w\"> </span><span class=\"n\">Î“</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">nat</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">HasType</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Context</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Ty</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Î“</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HasType</span><span class=\"w\"> </span><span class=\"n\">Î“</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">nat</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">conv</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Î“</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">A'</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TyEq</span><span class=\"w\"> </span><span class=\"n\">Î“</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">A'</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">HasType</span><span class=\"w\"> </span><span class=\"n\">Î“</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">HasType</span><span class=\"w\"> </span><span class=\"n\">Î“</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">A'</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">TyEq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Context</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Ty</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Ty</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Î“</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TyEq</span><span class=\"w\"> </span><span class=\"n\">Î“</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">A</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">TermEq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Context</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Î“</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TermEq</span><span class=\"w\"> </span><span class=\"n\">Î“</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n<p>The axiom in question is the <code>HasType.conv</code> constructor.</p>",
        "id": 448962917,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1720046495
    },
    {
        "content": "<p>Another thing to mention is that some of the exercises in Egbert's book will presumably need the axioms of HoTT, which Lean does not support. So it might be more workable to use Cubical Agda, for example, as the proof assistant in which you formalize your solutions.</p>",
        "id": 448963142,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1720046601
    },
    {
        "content": "<p>Have you worked much with formalizations of the simply typed lambda calculus before? If not, I would personally start there, using resources like this <a href=\"https://softwarefoundations.cis.upenn.edu/plf-current/Stlc.html\">Software Foundations chapter</a> and <a href=\"https://plfa.github.io/Lambda/\">Part 2 of Programming Language Foundations in Agda</a> as examples. These take two approaches that are a good starting point for formalizing a lambda calculus. Then once that feels comfortable, go back and add the dependent type aspect.</p>",
        "id": 448963196,
        "sender_full_name": "Chris Henson",
        "timestamp": 1720046634
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Formalizing.20Dependent.20Type.20Theory/near/448961953\">said</a>:</p>\n<blockquote>\n<p>This definitely works, you just have the syntax a bit off.</p>\n</blockquote>\n<p>Wow, nice to see that I was not too far off.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Formalizing.20Dependent.20Type.20Theory/near/448962917\">said</a>:</p>\n<blockquote>\n<p>Here's a basic formalization of the four judgments you mention</p>\n</blockquote>\n<p>Did you just come up with this or is this already predefined in some library?</p>",
        "id": 448963259,
        "sender_full_name": "Viliam Vadocz",
        "timestamp": 1720046647
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"128280\">Wojciech Nawrocki</span> <a href=\"#narrow/stream/113488-general/topic/Formalizing.20Dependent.20Type.20Theory/near/448963142\">said</a>:</p>\n<blockquote>\n<p>Another thing to mention is that some of the exercises in Egbert's book will presumably need the axioms of HoTT, which Lean does not support. So it might be more workable to use Cubical Agda, for example, as the proof assistant in which you formalize your solutions.</p>\n</blockquote>\n<p>Even if we define the context, judgements, etc. ourselves like <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> did above?</p>",
        "id": 448963332,
        "sender_full_name": "Viliam Vadocz",
        "timestamp": 1720046695
    },
    {
        "content": "<p><a href=\"https://github.com/sinhp/groupoid_model_in_lean4/blob/6775721c4fbcb65f9fc5d16d3413f94a9a566d87/GroupoidModel/TypeTheory.lean#L69-L80\">This</a> is a WIP formalization of a somewhat toy dependent type theory (with a very non-toy semantic interpretation), and <a href=\"https://github.com/digama0/lean4lean/blob/c534f13d8d25f5e1891b6d18cc76b601ee87aa66/Lean4Lean/Theory/Typing/Basic.lean#L17-L55\">this</a> is a formalization of lean's type theory judgment, which is probably way overkill for solving homework questions but should give you some hints at how this kind of thing can scale up</p>",
        "id": 448963421,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1720046736
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"692539\">Viliam Vadocz</span> <a href=\"#narrow/stream/113488-general/topic/Formalizing.20Dependent.20Type.20Theory/near/448963259\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Formalizing.20Dependent.20Type.20Theory/near/448962917\">said</a>:</p>\n<blockquote>\n<p>Here's a basic formalization of the four judgments you mention</p>\n</blockquote>\n<p>Did you just come up with this or is this already predefined in some library?</p>\n</blockquote>\n<p>I just made it up, guided by the two DTT formalizations I just mentioned</p>",
        "id": 448963577,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1720046777
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"692539\">Viliam Vadocz</span> <a href=\"#narrow/stream/113488-general/topic/Formalizing.20Dependent.20Type.20Theory/near/448963332\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"128280\">Wojciech Nawrocki</span> <a href=\"#narrow/stream/113488-general/topic/Formalizing.20Dependent.20Type.20Theory/near/448963142\">said</a>:</p>\n<blockquote>\n<p>Another thing to mention is that some of the exercises in Egbert's book will presumably need the axioms of HoTT, which Lean does not support. So it might be more workable to use Cubical Agda, for example, as the proof assistant in which you formalize your solutions.</p>\n</blockquote>\n<p>Even if we define the context, judgements, etc. ourselves like <span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> did above?</p>\n</blockquote>\n<p>That would be a bit like first defining ZFC before learning to do arithmetic. It's not really the point, unless you are very interested in foundational details. Proof assistants such as Cubical Agda or agda-unimath already give you all the tools you need to prove things in HoTT, and using those is almost certainly what Egbert means by that sentence. In particular, you shouldn't have to first <em>define</em> HoTT by defining contexts, judgments, the language of types, etc.</p>",
        "id": 448963740,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1720046868
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"687698\">Chris Henson</span> <a href=\"#narrow/stream/113488-general/topic/Formalizing.20Dependent.20Type.20Theory/near/448963196\">said</a>:</p>\n<blockquote>\n<p>Have you worked much with formalizations of the simply typed lambda calculus before?</p>\n</blockquote>\n<p>I have not. I have started learning Lean a few months ago by reading the <em>Theorem Proving in Lean 4</em> book, but I have not have much practice, so I thought that while I read this other book I might as well get some practice.</p>",
        "id": 448963858,
        "sender_full_name": "Viliam Vadocz",
        "timestamp": 1720046925
    },
    {
        "content": "<p>I strongly agree with Wojciech, formalizing DTT is not a beginner level project</p>",
        "id": 448963927,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1720046965
    },
    {
        "content": "<p>Using it can be</p>",
        "id": 448963946,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1720046976
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Formalizing.20Dependent.20Type.20Theory/near/448963946\">said</a>:</p>\n<blockquote>\n<p>Using it can be</p>\n</blockquote>\n<p>By that you mean the first approach by using the dependent type system built into Lean?</p>",
        "id": 448964222,
        "sender_full_name": "Viliam Vadocz",
        "timestamp": 1720047096
    },
    {
        "content": "<p>At least up until you need HoTT axioms, you can do this kind of investigation in lean, using something similar to the first code block I gave. But note that if you want to handle defeq correctly, it's not actually a hypothesis you can have, it's something the proof assistant figures out on its own.</p>",
        "id": 448964242,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1720047110
    },
    {
        "content": "<p>The conversion rule is how this typechecks for example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>\n<p>because <code>|- (fun x : Type =&gt; x) Nat â‰¡ Nat</code></p>",
        "id": 448964391,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1720047170
    },
    {
        "content": "<p>I also agree with Mario and Wojciech about this being a tough beginning project. I consider myself an advanced beginner (I've been using various proof assistants for a couple years) and am just now feeling comfortable working on formalizing some lambda calculi. It is certainly not impossible and I recommend the resources I linked above, but there are many tricky details.</p>",
        "id": 448964870,
        "sender_full_name": "Chris Henson",
        "timestamp": 1720047457
    },
    {
        "content": "<p>In past projects I have found that trying something difficult early on is helpful in motivating future learning. It gives a goal which frames what I read in the future. All becomes a tool to chip away at the mountain.</p>\n<p>I would prefer to practice with what the book is teaching, which is doing the derivations myself. I'll see how far I get using Mario's example above, and if I get stuck, I will try Chris's recommendation of formalizing a simply typed lambda calculus.</p>",
        "id": 448965672,
        "sender_full_name": "Viliam Vadocz",
        "timestamp": 1720047806
    },
    {
        "content": "<p>Thanks for the quick and insightful replies everyone.</p>",
        "id": 448965816,
        "sender_full_name": "Viliam Vadocz",
        "timestamp": 1720047878
    }
]