[
    {
        "content": "<p>I'd like to make a pitch for WebAssembly support, mostly in the context of education. This is kind of a thought-dump, so I'm very happy to hear additions and counterpoints:)</p>\n<p>In general the point of these use cases is: Being able to do as much as possible with as little threshold as possible. In particular avoiding installation is a big deal for teachers; supposing about 10% of students will have some sort of installation issue, this automatically occupies a chunk of valuable class time.  (Note that I appreciate how smooth the Lean installation process is, students just have a) wacky machines and b) varied ability in following instructions). In particular, drive-by usage of Lean in courses could get a boost if installation is not necessary. (i.e. use in a logic course as an optional project)</p>\n<p>Some use cases that would be enabled by a Webassembly build, in order of estimated technical effort required:</p>\n<ol>\n<li><a href=\"http://vscode.dev\">vscode.dev</a> with a Lean WebExtension: This would enable using Lean without installing anything,  code and cache would still be stored on the users file system.</li>\n<li>Client-side (and customizable) <a href=\"http://live.lean-lang.org\">live.lean-lang.org</a>. This would enable courses where a more light-weight experience is desirable. Client-side is important because then bigger courses won't put undue burden on <a href=\"http://live.lean-lang.org\">live.lean-lang.org</a>. Customizable is important to enable teachers to setup environments for exercises (In particular, I'm thinking of Verbose Lean here).</li>\n<li>Interactive text-books. I'm thinking along the lines of the <a href=\"http://sites.math.rutgers.edu/~alexk/TestRealAnalysis.html\">test</a> that <span class=\"user-mention\" data-user-id=\"252920\">@Alex Kontorovich</span> created recently. This test uses <a href=\"http://live.lean-lang.org\">live.lean-lang.org</a>, which I think is fine for a test, but (in my opinion) does not quite suffice in general for the reasons mentioned above. </li>\n</ol>\n<p>Technical notes on each of these:</p>\n<ol>\n<li>This would require slight adaptations to the VSCode extension: Any node-exclusive API's can't be in the imports of the WebExtension.</li>\n<li>The currently ongoing improvements to the cache are likely needed to achieve this: The cache is no longer on disk, and having a 5Gish mathlib cache in the browser is not ideal. I also think we would want to set this up in a way that teachers could roll their own version relatively easily.</li>\n<li>I think the way to go here is to integrate with a Verso Genre. Verso does all the elaboration at compile time, but I'm not really how this could be combined. Again, the caching is an issue here if you want to use mathlib.</li>\n</ol>\n<p>Use case 1 is also something that we're currently pushing towards with <a href=\"https://impermeable.github.io/\">Waterproof</a> in the context of Rocq. Use cases 1 and 3 are the ones that are personally on my long-term TODO-list, but if others wanted to pick this up I would be very happy. (Actually getting (Verbose) Lean supported in Waterproof is one of the things that has my personal priority).</p>\n<p>In general, I have no clue how stable and performant the webassembly build was to begin with, if anyone has experiences with this, I'd love to hear them.<br>\n<span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span> <a href=\"https://github.com/leanprover/lean4/pull/6424\">lean4#6424</a> (temporarily) disabled the CI builds for webassembly, do you know what would be needed to bring them back?</p>",
        "id": 524847205,
        "sender_full_name": "Pim Otte",
        "timestamp": 1750324996
    },
    {
        "content": "<p>Very interesting proposal. I believe Lean 4 has never properly supported WebAssembly. And having WebAssembly support is a good first step towards my lockdown mode proposal.</p>",
        "id": 524848791,
        "sender_full_name": "(deleted)",
        "timestamp": 1750325646
    },
    {
        "content": "<p>Lean 4 is currently dependent on mmap and linking precompiled Lean binaries <span aria-label=\"eyes\" class=\"emoji emoji-1f440\" role=\"img\" title=\"eyes\">:eyes:</span> so out of the box Lean doesn't even function properly when compiled to WebAssembly.</p>",
        "id": 524848965,
        "sender_full_name": "(deleted)",
        "timestamp": 1750325734
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"470149\">@Joachim Breitner</span>, who has a lot of ideas about wasm/lean (although maybe more about formalizing wasm in lean then running lean in wasm)</p>",
        "id": 524850262,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1750326249
    },
    {
        "content": "<p>My understanding was that there used to be a wasm build but it was ridiculously heavy after the move to mmapped oleans and it was very impractical compared to lean 3 days</p>",
        "id": 524903815,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1750345205
    },
    {
        "content": "<p>This came up before recently, and there are unfortunately very serious technical challenges. For example lean loads the <code>.olean</code> files using mmap for efficient start-up time, which is something that Wasm doesn’t support yet. Then there is the 4GB memory restriction of Wasm, which is not going to be enough to load a decent project like mathlib. So I’m not very optimistic (and it’s certainly not just a matter of compiling to a different platform)</p>",
        "id": 524903931,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1750345238
    },
    {
        "content": "<p>I would really love if lean could get its memory footprint down to sane levels though</p>",
        "id": 524904089,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1750345290
    },
    {
        "content": "<p>maybe the module stuff will help with this?</p>",
        "id": 524904135,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1750345311
    },
    {
        "content": "<p>reminder that mathlib in lean 3 was only around 200 MB and it has only ~tripled since then</p>",
        "id": 524904371,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1750345388
    },
    {
        "content": "<p>the fact that it is in the multiple gigabyte regime is entirely because of lean storage design decisions, not mathlib being big</p>",
        "id": 524904519,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1750345437
    },
    {
        "content": "<p>I think it would be perfectly acceptable to aim for \"a lot smaller than mathlib\"-projects for these use cases. I think projects dependent on mathlib are the more common use case, and as I understand it, the caching improvements involve an olean split, so that would also mean needing to load less into memory, right? (I'm not really sure what the module stuff is, is that related to this?)</p>\n<p>Then I think the open question would be if pre-loading all the \"slim\" oleans into memory would be acceptable (or we really need mmap support). If it ends up being 600MB, that seems doable. For interactive books it might be a little bit heavy if every page needs it, but then you could do a single-page html style book.</p>",
        "id": 524908004,
        "sender_full_name": "Pim Otte",
        "timestamp": 1750346702
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/113488-general/topic/Pitch.20for.20Webassembly.20support.20.28and.20follow-up.20projects.29/near/524904135\">schrieb</a>:</p>\n<blockquote>\n<p>maybe the module stuff will help with this?</p>\n</blockquote>\n<p>It certainly will; the oleans to load will be ~half the size. Maybe even less.</p>",
        "id": 524924788,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1750353524
    },
    {
        "content": "<p>My radical mind says we can use SQLite instead of mmaping olean files...</p>",
        "id": 524927429,
        "sender_full_name": "(deleted)",
        "timestamp": 1750354935
    },
    {
        "content": "<p>That does mean we have to say goodbye to the compacted heap region and move to a more relational model</p>",
        "id": 524927820,
        "sender_full_name": "(deleted)",
        "timestamp": 1750355194
    },
    {
        "content": "<p>I would definitely support something like that. Maybe not sqlite directly, but rather something along the lines of mmapping .ltar files instead, which despite being compressed can still be traversed as a read only data structure, which is just fine for a lot of applications like instantiating level variables during definitional unfolding of something in the environment</p>",
        "id": 524928055,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1750355344
    },
    {
        "content": "<p>the thing one has to get away from is the assumption that the thing in memory is already a valid <code>lean_object</code></p>",
        "id": 524928134,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1750355394
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"519269\">@Pim Otte</span> for making this pitch, I'm very interested in a Lean/WASM port too.</p>\n<p>A couple of questions:</p>\n<blockquote>\n<p>lean storage design decisions</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> , do you have any additional pointers regarding the challenges here?</p>\n<blockquote>\n<p>lean loads the <code>.olean</code> files using mmap for efficient start-up time</p>\n</blockquote>\n<p>I guess allowing a \"copy\" mode would be possible, and while indeed performance would be impacted, I understand that <code>.olean</code> files are patched after mmaping anyways?</p>\n<p>What other challenges would be there? Modern WASIX / Rust WASM toolchain, while not standard, support a large number of extensions and libuv, so (from the bench, and obviating library size), trying a WASM build shouldn't be too far?</p>",
        "id": 528532290,
        "sender_full_name": "Emilio Jesús Gallego Arias",
        "timestamp": 1752416091
    },
    {
        "content": "<p>You mentioned WASIX... Unfortunately the company promoting WASIX doesn't have a very good reputation.</p>",
        "id": 528543030,
        "sender_full_name": "(deleted)",
        "timestamp": 1752426297
    },
    {
        "content": "<p>I'm not sure whether this has anything to do with the technical merits of WASIX.</p>",
        "id": 528543065,
        "sender_full_name": "(deleted)",
        "timestamp": 1752426329
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110154\">Emilio Jesús Gallego Arias</span> <a href=\"#narrow/channel/113488-general/topic/Pitch.20for.20Webassembly.20support.20.28and.20follow-up.20projects.29/near/528532290\">said</a>:</p>\n<blockquote>\n<p>I guess allowing a \"copy\" mode would be possible, and while indeed performance would be impacted, I understand that <code>.olean</code> files are patched after mmaping anyways?</p>\n</blockquote>\n<p>They are only patched if they cannot be placed in their requested location, which is a random 64 bit address and therefore vanishingly unlikely to collide with any other mapped oleans even when you have many thousands or even millions</p>",
        "id": 528567143,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1752451465
    },
    {
        "content": "<p>unfortunately this trick just doesn't work in WASM's 32-bit address space</p>",
        "id": 528567161,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1752451489
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/113488-general/topic/Pitch.20for.20Webassembly.20support.20.28and.20follow-up.20projects.29/near/528567161\">said</a>:</p>\n<blockquote>\n<p>unfortunately this trick just doesn't work in WASM's 32-bit address space</p>\n</blockquote>\n<p>Hasn't memory64 support already landed on chrome?</p>",
        "id": 528569338,
        "sender_full_name": "Tristan Figueroa-Reid",
        "timestamp": 1752454142
    },
    {
        "content": "<p><a href=\"https://webassembly.org/features/#table-row-memory64\">It's available on both Chrome and Firefox.</a></p>",
        "id": 528569381,
        "sender_full_name": "Tristan Figueroa-Reid",
        "timestamp": 1752454208
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110154\">Emilio Jesús Gallego Arias</span> <a href=\"#narrow/channel/113488-general/topic/Pitch.20for.20Webassembly.20support.20.28and.20follow-up.20projects.29/near/528532290\">said</a>:</p>\n<blockquote>\n<p>What other challenges would be there? Modern WASIX / Rust WASM toolchain, while not standard, support a large number of extensions and libuv, so (from the bench, and obviating library size), trying a WASM build shouldn't be too far?</p>\n</blockquote>\n<p>I would be surprised if unofficial extensions are necessary to run essential parts of lean4. If they are, I would be against such a port. I would guess that WASM's family of stage 4 &amp; 5 proposals are enough.</p>",
        "id": 528569569,
        "sender_full_name": "Tristan Figueroa-Reid",
        "timestamp": 1752454509
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"519269\">Pim Otte</span> <a href=\"#narrow/channel/113488-general/topic/Pitch.20for.20Webassembly.20support.20.28and.20follow-up.20projects.29/near/524847205\">said</a>:</p>\n<blockquote>\n<ol>\n<li><a href=\"http://vscode.dev\">vscode.dev</a> with a Lean WebExtension: This would enable using Lean without installing anything,  code and cache would still be stored on the users file system.</li>\n<li>Client-side (and customizable) <a href=\"http://live.lean-lang.org\">live.lean-lang.org</a>. This would enable courses where a more light-weight experience is desirable. Client-side is important because then bigger courses won't put undue burden on <a href=\"http://live.lean-lang.org\">live.lean-lang.org</a>. Customizable is important to enable teachers to setup environments for exercises (In particular, I'm thinking of Verbose Lean here).</li>\n</ol>\n</blockquote>\n<p>I don't think these would be particularly useful cases unless cache was improved. The current <code>lean4web</code> way is the best way to do this, unless I'm unaware of any stressors being placed on the lean web server.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"519269\">Pim Otte</span> <a href=\"#narrow/channel/113488-general/topic/Pitch.20for.20Webassembly.20support.20.28and.20follow-up.20projects.29/near/524847205\">said</a>:</p>\n<blockquote>\n<ol start=\"3\">\n<li>Interactive text-books. I'm thinking along the lines of the <a href=\"http://sites.math.rutgers.edu/~alexk/TestRealAnalysis.html\">test</a> that <span class=\"user-mention silent\" data-user-id=\"252920\">Alex Kontorovich</span> created recently. This test uses <a href=\"http://live.lean-lang.org\">live.lean-lang.org</a>, which I think is fine for a test, but (in my opinion) does not quite suffice in general for the reasons mentioned above. </li>\n</ol>\n</blockquote>\n<p>This is something that has more motivation. Embedded applications of lean4 into sites that do <em>not</em> use mathlib seem very exciting. For example, this seems quite nice to have for some of the lean4 games.</p>",
        "id": 528570462,
        "sender_full_name": "Tristan Figueroa-Reid",
        "timestamp": 1752455051
    }
]