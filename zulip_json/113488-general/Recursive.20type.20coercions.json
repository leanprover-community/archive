[
    {
        "content": "<p>I would like to apply type coercion to the arguments of types to get the following to typecheck for a custom wrapper type, assuming there already is a type coercion from A to B:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">examp</span><span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">value</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Wrapper</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Wrapper</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">value</span>\n</code></pre></div>\n<p>I can write a Coe instance </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">mapping</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Coe</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]:</span><span class=\"w\"> </span><span class=\"n\">Coe</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Wrapper</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Wrapper</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>but this will only work some of the time, as there seem to be many variations of the Coe typeclass and this only matches one of them.  Is there a good more general way to define these sort of recursive type coercions? </p>\n<p>I also noticed that these kinds of type conversions seem to exist for some build in types, but not for others. I can for instance convert <code>List Nat</code> to <code>List Int</code>, but not <code>Set Nat</code> to <code>Set Int</code>. I would at least expect something in the direction of </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">mapping</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Coe</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]:</span><span class=\"w\"> </span><span class=\"n\">Coe</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">image</span><span class=\"w\"> </span><span class=\"n\">mapping</span><span class=\"bp\">.</span><span class=\"n\">coe</span>\n</code></pre></div>\n<p>to already be part of the Set library. Things like </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">unioncast</span><span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">value</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">):</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">∪</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">value</span>\n</code></pre></div>\n<p>also do not work by default. Is there a reason for this? Should I be doing this in the first place?</p>",
        "id": 511120098,
        "sender_full_name": "Gijs van Cuyck",
        "timestamp": 1744190221
    },
    {
        "content": "<p>For future reference, the type Coercion from <code>List Nat</code> to <code>List Int</code> Uses <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Coe.html#Lean.Internal.coeM\">Lean.Internal.coeM</a> trough its monad instance. coeM is not currently recursively applicable, so that is why casting <code>List (List Nat)</code> to  <code>List (List Int)</code> does not work. This does not work for <code>Set</code> as the <code>Set</code> Monad instance is <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Set/Functor.html#Set.monad\">hidden by default</a>.</p>\n<p>I ended up defining my own recursive coercions as required. They work, but use internal classes not mean for user implementation, so there might still be reasons unknown to me that make this a bad idea. The high priority is an attempt to make type inference choose this option always when applicable, but I don't know enough about the inference system to be sure if that is  what is actually happening.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"sd\">/-- Converts Set a into Set b, assuming there already is a conversion from a to b.</span>\n<span class=\"sd\">    This is implemented trough an interal Coe class not meant for user implementation, which is a red flag.</span>\n<span class=\"sd\">    However, this way it is generally recursively applicable, while this does not seem possible with just the normal Coe classes.-/</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">priority</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">high</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"n\">coeSetRecInst</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">mapping</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CoeHTCT</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">]:</span><span class=\"w\"> </span><span class=\"n\">CoeHTCT</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">image</span><span class=\"w\"> </span><span class=\"n\">mapping</span><span class=\"bp\">.</span><span class=\"n\">coe</span>\n</code></pre></div>",
        "id": 525676595,
        "sender_full_name": "Gijs van Cuyck",
        "timestamp": 1750845552
    }
]