[
    {
        "content": "<p>Autoformalization is getting better. My impression is that most maintainers are kind of horrified at the idea of letting AI write mathlib. But what exactly is the problem with this?</p>\n<p>There are a gazillion things about elliptic curves which I will need for FLT, and progress is slow. On the other hand I can imagine that current AI tools are now kind-of good enough that we could tell a carefully-chosen collection of them to develop theory X in Lean (e.g. \"the Tate curve\", a part of the theory of elliptic curves, which is well-documented in the literature) and the output would be some really poorly-written Lean code with the following properties:</p>\n<ul>\n<li>Proofs which are 10x as long as they would be if expertly-written;</li>\n<li>Intermediate and unnecessary definitions with no API;</li>\n<li>lemmas which definitely should not be in mathlib because they should be inlined;</li>\n<li>proofs which would be hard to maintain;</li>\n</ul>\n<p>but perhaps also</p>\n<ul>\n<li>sorry-free proof of the main theorem.</li>\n</ul>\n<p>Say then that we make a fork of mathlib where we simply add these proofs, let AI maintain it, let AI bump it, and let AI add more and more poorly-written Lean code to it.</p>\n<p>What then happens to this library in the long term? How does it collapse, if it collapses at all? Assume that there is enough funding to keep the AI tools running.</p>\n<p>Basically my impression is that lots of people think that this is a bad idea but I am realising that I don't have a coherent argument as to why. I am well aware that mathlib has an extremely high bar for code review but I am unclear as to how important this fact has been in mathlib's success and, more importantly, how important it will remain going forwards.</p>\n<p>I am expecting to be firmly put in my place here!</p>",
        "id": 571882431,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1770203898
    },
    {
        "content": "<p>After playing with Claude code for this valence formula experiment I am doing, I am starting to think that something like this could be made (I thought it would be called methlib instead <span aria-label=\"rolling on the floor laughing\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rolling on the floor laughing\">:rolling_on_the_floor_laughing:</span> ). I've not yet tried asking claude to bump a repo, but I think it could probably do it, but it might take longer and longer as it has to clean up more and more slop. I think the interesting thing here is can we get AI to clean up code to get us 50 or 60% of the way to mathlib standards. I think that would help a lot in keeping a sloplib updated with mathlib.</p>",
        "id": 571885082,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1770204789
    },
    {
        "content": "<p>Let's take the experiment further, and only allow for AI reviews of the PRs to sloplib (or was this part of the \"let AI maintain it\"?)</p>",
        "id": 571885132,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1770204810
    },
    {
        "content": "<p>The other thing that might be interesting is that we could probably brute force a big chunk of maths into lean, so it could also work as a testing ground for mathlib, say a mathlib beta, where we just test out definitions/infrastructure and see how it goes (with the AI doing everything quickly) and we then look at whats useful and put that into mathlib.</p>",
        "id": 571885589,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1770204960
    },
    {
        "content": "<p>I assume such a repository would quickly need a lot of beefy machines for compilation, since Mathlib already has the 10 Hoskinson runners, and this approach would result in huge files.</p>",
        "id": 571886266,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1770205177
    },
    {
        "content": "<p>Aha so one objection to this plan is cost. If we drop our standards and rely on machines to keep everything afloat then it might quickly start costing a lot of money, and compile times will probably go through the roof (I've seen plenty of machines writing <code>set_option maxHeartbeats 100000000</code>). But there are huge amounts of money in this area right now so maybe this can be solved.</p>",
        "id": 571888445,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1770205918
    },
    {
        "content": "<p>If half the work on a mathlib PR comes after opening the PR, then \"50 or 60% of the way to mathlib standards\" should mean \"at the level of a mathlib PR that's just been opened, before it's gone through review\".</p>",
        "id": 571888541,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1770205957
    },
    {
        "content": "<p>What is the value of a poorly written unreadable and unmaintainable sorry-free proof? Do you have doubts as to whether the statements are correct or not?</p>",
        "id": 571888616,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1770205989
    },
    {
        "content": "<p>Of course another objection is \"but mathlib is about finding the right abstractions and the art of developing them\" and I'm well aware of this, but if the goal is just to get AI proving new theorems in all domains then maybe we can ignore this side of things -- after all I've seen some terribly-written human papers proving great theorems.</p>",
        "id": 571888815,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1770206048
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/571888616\">said</a>:</p>\n<blockquote>\n<p>What is the value of a poorly written unreadable and unmaintainable sorry-free proof? Do you have doubts as to whether the statements are correct or not?</p>\n</blockquote>\n<p>It's part of the route towards poorly-written but sorry-free AI proofs of new theorems which humans can't do and that current mathlib can't even state because it moves too slowly.</p>",
        "id": 571888917,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1770206092
    },
    {
        "content": "<p>I suspect \"10x as long\" applies at multiple levels. The individual <code>by</code> blocks are 10x as long, there are 10x as many intermediate lemmas and definitions as are actually needed, lack of appropriate structure and generality means larger pieces at various different levels keep getting duplicated 10x times in slightly different variants. If so, it would be <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>10</mn><mi>n</mi></msup><mo>√ó</mo></mrow><annotation encoding=\"application/x-tex\">10^n\\times</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7477em;vertical-align:-0.0833em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mord\">√ó</span></span></span></span> as long for proofs of depth <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>.</p>",
        "id": 571889084,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1770206152
    },
    {
        "content": "<p>As a start we could create m/leanprover on <span aria-label=\"lobster\" class=\"emoji emoji-1f99e\" role=\"img\" title=\"lobster\">:lobster:</span> moltbook and post a \"complete this sorry\" challenge for all the AIs out there, crowdsourcing AI compute</p>",
        "id": 571889091,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1770206154
    },
    {
        "content": "<p>I am not suggesting that this actually happens -- I am just trying to get a better understanding of why it shouldn't happen.</p>\n<p>The naive argument which led to the question is: \"AI is solving Erdos problems in Lean, AI can't solve problems in the Langlands program in Lean because we can't state them, AI could probably accelerate the path towards stating them, but what is the cost of this?\"</p>",
        "id": 571893530,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1770207584
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/571882431\">said</a>:</p>\n<blockquote>\n<p>What then happens to this library in the long term? How does it collapse, if it collapses at all? Assume that there is enough funding to keep the AI tools running.</p>\n</blockquote>\n<p>IMHO if this does collapse, it won't be for technical reasons, but because the various AI companies out there might not want to work with one another as nicely as the human contributors to mathlib do with one another. It will probably devolve into each company having their own private copy of such a repo, especially once there is some big prize (proof of big open problem) coming in sight. But one could argue that this is already exactly what is happening, because every repo being worked on by an AI company already includes mathlib as a dependency and so it already satisfies the criteria for a 'sloplib' of sorts. But this is just my speculation.</p>",
        "id": 571893552,
        "sender_full_name": "Bryan Wang",
        "timestamp": 1770207591
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"934803\">Bryan Wang</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/571893552\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/571882431\">said</a>:</p>\n<blockquote>\n<p>What then happens to this library in the long term? How does it collapse, if it collapses at all? Assume that there is enough funding to keep the AI tools running.</p>\n</blockquote>\n<p>IMHO if this does collapse, it won't be for technical reasons, but because the various AI companies out there might not want to work with one another as nicely as the human contributors to mathlib do with one another. It will probably devolve into each company having their own private copy of such a repo, especially once there is some big prize (proof of big open problem) coming in sight. But one could argue that this is already exactly what is happening, because every repo being worked on by an AI company already includes mathlib as a dependency and so it already satisfies the criteria for a 'sloplib' of sorts. But this is just my speculation.</p>\n</blockquote>\n<p>It depends I guess, if you are using commercial AI tools on an open source project , and not some sort of sponsorship, then it likely cannot happen that way.</p>",
        "id": 571894124,
        "sender_full_name": "Yan Yablonovskiy üá∫üá¶",
        "timestamp": 1770207775
    },
    {
        "content": "<p>That's true, but the big issue raised above was cost, that's why I began thinking in this direction.</p>",
        "id": 571894934,
        "sender_full_name": "Bryan Wang",
        "timestamp": 1770208026
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/571888815\">said</a>:</p>\n<blockquote>\n<p>but if the goal is just to get AI proving new theorems in all domains then maybe we can ignore this side of things -- <strong>after all I've seen some terribly-written human papers proving great theorems.</strong></p>\n</blockquote>\n<p>Would you be opposed to an AI written math journal, that would take sloplib lean discoveries and disambiguate them into natural language?</p>",
        "id": 571895281,
        "sender_full_name": "Yan Yablonovskiy üá∫üá¶",
        "timestamp": 1770208117
    },
    {
        "content": "<p>There should be lots of ways for AI to accelerate stating things other than building a sloplib. For example, AI could probably help with many of the more mechanical parts of PR review for mathlib (that aren't mechanical enough to turn into linters) and so reduce the amount of time maintainers need to spend on those when doing reviews for mathlib. People have written extremely detailed instructions to AIs on <a href=\"https://github.com/masoncl/review-prompts\">Linux kernel patch review</a>, why shouldn't we have similarly detailed instructions on reviewing mathlib changes and a service that does such reviews on PRs (automatically, or when requested)?</p>",
        "id": 571899627,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1770209375
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/571893530\">said</a>:</p>\n<blockquote>\n<p>AI can't solve problems in the Langlands program in Lean because we can't state them</p>\n</blockquote>\n<p>Ignoring for a moment engineering and communication issues of AI generated tactics, my view is that while we can rely on generated proofs from the viewpoint of proof irrelevance there remains an inherently human judgement when it comes to definitions actually corresponding to the appropriate informal math. In general I'm skeptical of AI producing useful definitions the further you drift away from existing material in Mathlib, but even if they are successful there is a required diligence in human review that I feel exceeds that required for proofs. The question to me seems to be if this shifting of work is still a net benefit.</p>",
        "id": 571899784,
        "sender_full_name": "Chris Henson",
        "timestamp": 1770209424
    },
    {
        "content": "<p>Yes, important definitions need to be human-verified but this would not be particuarly time-costly.</p>",
        "id": 571900189,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1770209535
    },
    {
        "content": "<p>Is there a risk that a sloplib would harm mathlib by stopping people contributing to it? One could imagine the situation where something exists in sloplib and no one can be bothered to put in the effort to bring it up to mathlib's standards. Conversely, if people did spend the time cleaning up some sloplib, then they might not get proper recognition as \"this was already done by an AI in sloplib\".</p>",
        "id": 571900925,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1770209740
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/571900189\">said</a>:</p>\n<blockquote>\n<p>Yes, important definitions need to be human-verified but this would not be particuarly time-costly.</p>\n</blockquote>\n<p>I guess my intuition differs here, as I imagine this as costly. Anytime I see definitions where I know AI was involved, I spend a significant amount of effort confirming whether it corresponds to the informal version. (I also mostly look at CS and not math, so maybe some divergence here).</p>",
        "id": 571902729,
        "sender_full_name": "Chris Henson",
        "timestamp": 1770210162
    },
    {
        "content": "<p>I haven't read all the messages above, and that will have to wait for morning, but this nevertheless seems like a good time to advertise the <a href=\"https://github.com/merely-true/merely-true\">merely-true</a> repository that Johan and I thought about late last year, but never launched.</p>",
        "id": 571904944,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1770210787
    },
    {
        "content": "<p>I unfortunately don't have a lot of time to write all my thoughts on the subject, but I would like to quickly make a few points before disappearing from the discussion.</p>\n<blockquote>\n<p>There are a gazillion things about elliptic curves which I will need for FLT, and progress is slow. </p>\n</blockquote>\n<p>As a thought experiment, would that be the case if we had just a portion of the financial, human an technical power of AI companies? Of course we can't do much about this (except being grateful that we did, in fact, get a significant amount of money as well, and try to show that we can make better use of it than dumping it on AI). Basically, my claim is that, if your utilitarian goal is \"mathematical progress\" (whatever that means), AI is overall a bad investment of society's financial, environmental, and human resources.</p>",
        "id": 571904946,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1770210788
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  a point to note with getting AI to formalize definitions further away from what we know is the loss of human skill in understanding what definitions are useful.</p>",
        "id": 571906354,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770211153
    },
    {
        "content": "<p>Even among the most AI enthusiasts, I don't think anyone seriously suggested having AI design standard programming libraries, and I don't see how that would be different for Mathlib. This ties into the fact that Mathlib is not the AFP. In fact, I have trouble imagining that AI would be able to prove anything without the careful API design in Mathlib, and as we increase complexity of the objects involved, I would imagine AI gets in trouble when trying to use its own API (of course this can be counteracted by writing the statements in advance, but then you might as well write a lot of the proofs)</p>",
        "id": 571906405,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1770211168
    },
    {
        "content": "<p>When you have worked in area X, then in a small open neighbourhood of X, you might be skilled at identifying and debugging good definitions. The further one goes from X, the less insight one has to fix a mess created by AI.</p>",
        "id": 571906647,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770211225
    },
    {
        "content": "<p>I have a negative data point to contribute. I recently tried to guide codex (GPT-5.2) to formalize the fischer-lynch-patterson theorem. This is fairly famous and known as the impossibility of consensus result. I followed a \"vibe coding and prompting only\" approach to see how far it works.</p>",
        "id": 571906861,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770211283
    },
    {
        "content": "<p>The initial set up and definitions went smoothly and I even got reasonable API lemmas</p>",
        "id": 571906948,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770211305
    },
    {
        "content": "<p>And then at some point the AI started messing the formalization of informal proofs. First it tried to add ridiculously strong assumptions to important internal lemmas. Then as I pointed out what it was doing, it started pushing these lemmas higher or changing definitions.</p>",
        "id": 571907131,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770211360
    },
    {
        "content": "<p>By the end of the experiment, the AI was unable to even debug a simple issue (that it was calling <code>rcases</code> on an implication whose consequent could be destructed).</p>",
        "id": 571907251,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770211395
    },
    {
        "content": "<p>and it was blatantly lying about fixing it and going into an infinite loop. and of course the AI couldn't prove the top level theorems because it was getting stuck in a deep rabbit hole of strong assumptions in lower level theorems that it simply couldn't prove. It left me with a big mess that  I haven't bothered cleaning up since.</p>",
        "id": 571907381,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770211417
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"268315\">Anatole Dedecker</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/571906405\">said</a>:</p>\n<blockquote>\n<p>In fact, I have trouble imagining that AI would be able to prove anything without the careful API design in Mathlib</p>\n</blockquote>\n<p>Yes, so do I, and the question I am asking is whether my imagination is just being limited by prior experience (which may not be a guide to future performance) and a desire not to be knocked out of my comfort zone. We are seeing AI writing multi-thousand-line Lean developments now and I'm wondering at what point sloplib becomes a viable tool for accelerating progress in AI theorem proving, and indeed whether we are at that point already. I'm sure that plenty of AI-lovers who know nothing about mathlib's design would just claim that of course we are already there today, but I don't really care about what those people think. Conversely I'm sure that many mathlib-devotees would say that this could never work because we know what worked in the past and it was nothing like what I am proposing. But I am trying to understand better what will probably fail if someone had a big bag of money and chose to gamble with it in this way, given recent advances in AI proving and the desire of people to get AI to prove new theorems beyond Erdos problems.</p>",
        "id": 571908239,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1770211638
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/571907381\">said</a>:</p>\n<blockquote>\n<p>the AI couldn't prove the top level theorems because it was getting stuck</p>\n</blockquote>\n<p>How do you know that the fix isn't \"pay more money for a better AI\"?</p>",
        "id": 571908469,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1770211688
    },
    {
        "content": "<p>(please also assume it will break if you touch it --- at this point I've run it twice, ever)</p>",
        "id": 571909826,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1770211972
    },
    {
        "content": "<p>If resources are not a problem then we should probably try to run vampire or some other SMT solver too. I wonder how grind would work if we could throw masses of CPU power at it.</p>",
        "id": 571910694,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770212148
    },
    {
        "content": "<p>One thing I have noticed in a few of these big autoformalization attempts in TCS (that haven't been brought up on this Zulip)  is that they don't exactly prove what they claim on paper. They use super-specialized definitions and then work when they stick close to mathlib content. This can lead to the AFP-problem mentioned above : A jungle of poorly linked definitions and theorems.</p>",
        "id": 571911262,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770212282
    },
    {
        "content": "<p>and once you have this messy jungle and AI starts learning from them, there may very well be diminishing returns from AI. After all the messy jungle will have more voluminous data than mathlib. It's basically the same story as AI learning art from other AI.</p>",
        "id": 571911622,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770212372
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/571908469\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/571907381\">said</a>:</p>\n<blockquote>\n<p>the AI couldn't prove the top level theorems because it was getting stuck</p>\n</blockquote>\n<p>How do you know that the fix isn't \"pay more money for a better AI\"?</p>\n</blockquote>\n<p>That seems hard (and expensive) to disprove conclusively</p>",
        "id": 571917855,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1770213642
    },
    {
        "content": "<p>One of the annoying things about programming nowadays‚Äîoutside of Lean‚Äîis that people are capable of writing code much faster than reviewing it, and this seems like a similar problem to having AI write mathematics in Lean. Albeit, I guess if there is a target theorem, then I suppose this does not matter as much.</p>\n<p>In the past, I noticed that a lot of AI produced Lean code was much more focused on the proof of a single main result with little discretion given to the utility of intermediatory results and formalizations. I think that autoformalization should be just as concerned about building a library than just proving a single thing. </p>\n<p>To that end, I want to run a study on how to effectively write definitions and theorems in Mathlib, and then use that as a prompting template for AI. I think that in the past most of the focus was on proofs, and now we should be more fixated on how to get AI to produce Mathlib-ready definitions and theorems.</p>\n<p>I think this is also why there have been no large conjectures proven yet by AI, even though it could be feasible with current tools: there is a much stronger fixation on individual proofs than there is on ‚Äútheory building‚Äù, or what we would call ‚ÄúAPI design‚Äù in Lean.</p>",
        "id": 571922846,
        "sender_full_name": "Justin Asher",
        "timestamp": 1770214789
    },
    {
        "content": "<p>In the current agentic framework, the best results occur when context bloat is properly managed and tools are targeted and well scoped. </p>\n<p>Giant slop proofs actively degrade the former (not to mention the increased overhead of actually running Lean). One can convincingly argue that AI will get better at formal math if it is incentivized toward tigher, more idiomatic code in proofs. </p>\n<p>I think much better use of AI would be curating tactic-specs (perhaps domain specific), based both on natural language arguments and repeated patterns in libraries, and creating test suites for those potential tactics. Then set some models loose on those plus have people develop them.  This would provide better tools. </p>\n<p>Plan mode seems to be underutilized for design questions also. </p>\n<p>Things also go a longer way when domain experts generate the context for things like skills.</p>",
        "id": 571928194,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1770216063
    },
    {
        "content": "<p>Another issue that I just thought of while waiting for a Lean file to load: what if sloplib gets so big/inefficient that it can no longer fit on the average mathematician's personal computer, much less work properly or be able to do anything with it? Would it still gain traction among the wider mathematical community? At least with current AI-generated proofs, they can all be inspected on one's personal computer. But if AI-maintained sloplib is allowed to grow unchecked, this may no longer be the case.</p>",
        "id": 571928683,
        "sender_full_name": "Bryan Wang",
        "timestamp": 1770216187
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306577\">Matthew Ballard</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/571928194\">said</a>:</p>\n<blockquote>\n<p>the best results occur when context bloat is properly managed and tools are targeted and well scoped</p>\n</blockquote>\n<p>I think using subagents effectively can help a lot here.</p>",
        "id": 571929196,
        "sender_full_name": "Justin Asher",
        "timestamp": 1770216322
    },
    {
        "content": "<p>I've had success in using AI to optimize rate-limiting code paths in complex C++ code bases without deteriorating of the agent. The \"trick\" I've used is to make sure that there are more work products during the engineering loop -- it should write a log describing its attempts and where it succeeded/failed. This way it is able to offload its context management onto disk and not have to just hold it in the provider's API/model memory. It also helps for the human-in-the-loop re-guiding.</p>\n<p>So for a mathematical context on autoformalization, I think the loop should spend more time writing non-lean code. It should write to disk/file what section/sentence it is focusing on, and what it tried.</p>\n<p>I haven't tried Aristotle, but from what I've seen in copied output, the comments it leaves are very nice. But we have lost the \"Thinking\" output that could have been relevant on the next go around on some other relevant section.</p>\n<p>Said differently, when we approach each task in isolation, you lose the benefit of the learning of the 1000s of failures and the context around it.</p>",
        "id": 571929508,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1770216395
    },
    {
        "content": "<p>For me, subagents <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>‚äÇ</mo></mrow><annotation encoding=\"application/x-tex\">\\subset</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mrel\">‚äÇ</span></span></span></span> tools but I recognize that the latter has a precise meaning in, eg claude code.</p>",
        "id": 571930077,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1770216531
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"266253\">Joseph Myers</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/571899627\">said</a>:</p>\n<blockquote>\n<p>why shouldn't we have similarly detailed instructions on reviewing mathlib changes and a service that does such reviews on PRs (automatically, or when requested)?</p>\n</blockquote>\n<p>I just created a repository to consolidate work in this area, if anyone wants to contribute.</p>\n<p><a href=\"https://github.com/justincasher/lean-prompts\">https://github.com/justincasher/lean-prompts</a></p>",
        "id": 571931371,
        "sender_full_name": "Justin Asher",
        "timestamp": 1770216810
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/571907381\">said</a>:</p>\n<blockquote>\n<p>and it was blatantly lying about fixing it and going into an infinite loop. and of course the AI couldn't prove the top level theorems because it was getting stuck in a deep rabbit hole of strong assumptions in lower level theorems that it simply couldn't prove. It left me with a big mess that  I haven't bothered cleaning up since.</p>\n</blockquote>\n<p>Here's the repo if anyone wants to finish it (or use AI to finish it). I vibe coded this entire thing in &lt; 3 hours late in in night, and stopped when GPT stopped being helpful. I am not guaranteeing its correctness.  Vibe coded with a lot of prompt-based guidance provided by me to catch and fix mistakes. <br>\n<a href=\"https://github.com/Shreyas4991/Vibe-Code-Experiment-Consensus\">https://github.com/Shreyas4991/Vibe-Code-Experiment-Consensus</a></p>",
        "id": 571941942,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770219060
    },
    {
        "content": "<p>I think if you're calling something sloplib, you already know the problem with it.</p>",
        "id": 571952993,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1770221539
    },
    {
        "content": "<p>I don't rule out that AI can write high-quality code. Having been experimenting with Claude Code recently, it's seriously powerful in what it can do. But it seems to do a <em>lot</em> better with a human guiding and steering it.</p>",
        "id": 571953193,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1770221586
    },
    {
        "content": "<p>Fundamentally, the question is \"do you care about what is after the := in a theorem\". I get the sense that some people don't (as long as it isn't a sorry). I do, I think. I think one can meaningfully talk about \"good quality\" proofs.</p>",
        "id": 571953368,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1770221634
    },
    {
        "content": "<p>Moreover, someone needs to review AI definitions etc. very carefully to make sure they haven't allowed for holes, and on the frontier I would expect a lot of definitions work. Effective API design is hard - I think AI can assist with it but I don't think it can do it by itself.</p>",
        "id": 571953540,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1770221680
    },
    {
        "content": "<p>I think Mathlib should not only contain many proofs - it should contain well-engineered proofs that are systematic and logically constructed and it should contain useful sets of theorems that provide a sensible API surface on which to build more things.</p>",
        "id": 571953705,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1770221721
    },
    {
        "content": "<p>Arguably it doesn't achieve this right now.</p>",
        "id": 571953746,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1770221732
    },
    {
        "content": "<p>Also I have to say the cost seems maybe prohibitive, especially longer term. We cannot rely on all this money sloshing around currently to remain in place. It's nice that it's there - I am very glad for the philanthrophy that has existed.</p>",
        "id": 571953908,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1770221776
    },
    {
        "content": "<p>I realise I'm echoing a lot of what people have said above. I will say something that I have said before: the mathlib community's notion of theory building as API design is an interesting and semi-novel one. Obviously the observation that programs = proofs is not new, something something Church Turing. But actually an observation that someone made to me recently - at a Lean meetup, from someone interested in Lean but who was a trained software engineer - is that all this talk of API design is mirroring discussions that happen in software engineering. I think it's genuinely interesting that actually it turns out that not only do programs = proof, but software engineering = proof engineering = effective mathematical theory-building.</p>",
        "id": 571954583,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1770221959
    },
    {
        "content": "<p>I think you lose sight of this, which I continue to think is one of the real gems of this endeavour and that I have yet to see nicely written up in the literature, if you farm out things wholesale to AI. You'll just end up in the position we are now with pen and paper proofs, where verifying them is in some cases infeasible.</p>",
        "id": 571954885,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1770222025
    },
    {
        "content": "<p>Incidentally using Opus 4.5 (admittedly relatively naively - I am only just learning to use subagents etc. properly) with Claude Code Pro, I get &lt;1hour of work every four hours out of it.</p>",
        "id": 571956031,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1770222304
    },
    {
        "content": "<p>And any more than that is way outside my price range</p>",
        "id": 571956090,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1770222318
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/571953705\">said</a>:</p>\n<blockquote>\n<p>I think Mathlib should not only contain many proofs - it should contain well-engineered proofs that are systematic and logically constructed and it should contain useful sets of theorems that provide a sensible API surface on which to build more things.</p>\n</blockquote>\n<p>I think mathlib is doing two distinct jobs. First, it is a repository where we strive to prove the cleanest theorems using the right abstractions. And then it is a repository where AI companies can build on it and e.g. formalize solutions to Erdos problems and maybe solve new problems in other areas of mathematics.</p>\n<p>From the perspective of striving to be a beautiful thing, of course we should keep it a beautiful thing. But from the perspective of trying to get AI to do new mathematics so we can figure out what's true, one really could argue that we don't care about what's after the <code>:=</code> in a proof. </p>\n<p>My question is not about \"why do we care about beautiful proofs\", it is \"what are the likely practical consequences if we sacrifice beauty for 10x more rapid growth, and rely on AI and money to solve the obvious problems such as longer compile times and more difficulty in refactoring\". </p>\n<p>In other words why <em>do</em> you think that mathlib should contain well-engineered proofs? If a mathlib-powered AI tells me new things about the strong Birch and Swinnerton-Dyer conjecture because we accelerated mathlib sloppily to the point where it can understand the statement, isn't this a win?</p>",
        "id": 571972071,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1770226614
    },
    {
        "content": "<p>what are the things we do when formalizing a mathematical statement?</p>\n<ol>\n<li>check if it's already in the library. if not,</li>\n<li>think of what the main definitions should look like</li>\n<li>try some API lemmas to see if we got the definitions right. if not,</li>\n<li>refactor definitions until they feel usable.</li>\n<li>start proving the lemmas, building up to the main theorem. refactor definitions/API as necessary.</li>\n<li>Look over the whole formalization; is it in the right generality? did we end up not using assumptions we thought were necessary? refactor accordingly</li>\n<li>Golf. Extract abstractions, start over.</li>\n<li>PR, get feedback, refactor, etc.<br>\nWhich of these things is something AI can't eventually get good at? We could start with one AI populating sloplib/methlib/merely-true, and have a \"golf\" agent go through and clean it up, and an \"abstractify\" agent clean up the structure, and a \"mathlibify\" agent resynthesize everything and put it in the right file and with the right  theorem name, etc etc etc. Everything I've seen so far is pointing to such a future...</li>\n</ol>",
        "id": 571972296,
        "sender_full_name": "Alex Kontorovich",
        "timestamp": 1770226680
    },
    {
        "content": "<p>The technical debt question is real, sloplib as is will surely hit computation limits. But if the cleaning bots do their jobs, it should be no worse (in fact, possibly better...) than current mathilb.</p>",
        "id": 571972571,
        "sender_full_name": "Alex Kontorovich",
        "timestamp": 1770226773
    },
    {
        "content": "<p>Then there's the question of getting the definitions/ theorem statements wrong. I had a long discussion with Christian Szegedy about this (see <a href=\"https://arxiv.org/abs/2510.15924\">https://arxiv.org/abs/2510.15924</a>), and his argument is: \"Math is robust\". That is, we human mathematicians, with all of our faults and errors, manage, <strong>in the long run</strong> to error-correct, because our first pass at definitions didn't do what it was supposed to and led to contradictions and wasn't general enough, etc etc. We already do our own mathematical error correction through the creation of more math. So why can't AI do the same? If it gets the definition of <code>Group</code> wrong, it'll hit snags, and it'll eventually try a refactor (just like us)... Same with theorem statements - theorems prove things for a reason. If theorems fail to be useful in consequences where they're expected, then they're the wrong theorems, and need to be refactored. So he says: don't worry if the first versions are wrong; in the long run, the AI will correct itself, just like we do.</p>",
        "id": 571973408,
        "sender_full_name": "Alex Kontorovich",
        "timestamp": 1770227060
    },
    {
        "content": "<p>I just talked to Alex about this on a call (Alex as I'm sure you can guess I asked this question precisely because I was thinking about what to say at the talk I just gave) and one thing that came out of the discussion is that one could actually try this experiment with a repo downstream. Idea: you take some theory you want (e.g. we need the theory of the Tate curve for FLT), you feed in the relevant sections of Silverman's books on elliptic curves and say \"please formalize these\", and if autoformalization is good and cheap enough then you end up with a repo containing a sorry-free proof of the main result I need, unreadable horrible code, and then you just get an AI to bump now and again, maybe humans tinker with the main definitions to make them good, and then an AI or a human slowly PRs the proofs to mathlib and I sorry the corresponding theorems in FLT and say we have slop proofs and they're not fit for human consumption. </p>\n<p>What I'm trying to understand is the risks of allowing AI slop anywhere near a hopefully-respectable project.</p>",
        "id": 571973697,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1770227148
    },
    {
        "content": "<p>In a sense, PNT+ is already running that experiment. Here's a sample page of closed PRs. <br>\n<a href=\"/user_uploads/3121/SMGXmD-r3_uEsRwQss4lSvBR/image.png\">image.png</a><br>\nWe label which are contributed by AI (and which AI), and which fix (human) misformalizations. This is exactly the workflow I envisioned after the DeepMind visit to IAS last May. (Now that Codex and the like are coming online and getting better, agentic workflows will just take off like mad...)</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/SMGXmD-r3_uEsRwQss4lSvBR/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"790x949\" src=\"/user_uploads/thumbnail/3121/SMGXmD-r3_uEsRwQss4lSvBR/image.png/840x560.webp\"></a></div>",
        "id": 571974537,
        "sender_full_name": "Alex Kontorovich",
        "timestamp": 1770227447
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/571973697\">said</a>:</p>\n<blockquote>\n<p>I just talked to Alex about this on a call (Alex as I'm sure you can guess I asked this question precisely because I was thinking about what to say at the talk I just gave) and one thing that came out of the discussion is that one could actually try this experiment with a repo downstream. Idea: you take some theory you want (e.g. we need the theory of the Tate curve for FLT), you feed in the relevant sections of Silverman's books on elliptic curves and say \"please formalize these\", and if autoformalization is good and cheap enough then you end up with a repo containing a sorry-free proof of the main result I need, unreadable horrible code, and then you just get an AI to bump now and again, maybe humans tinker with the main definitions to make them good, and then an AI or a human slowly PRs the proofs to mathlib and I sorry the corresponding theorems in FLT and say we have slop proofs and they're not fit for human consumption. </p>\n<p>What I'm trying to understand is the risks of allowing AI slop anywhere near a hopefully-respectable project.</p>\n</blockquote>\n<p>You will get an AFP like web of formalisations consisting of many variants of definitions of the same concept  and spend a lot of time figuring out what libraries to use and what ‚Äúsubtly different definitions‚Äù you want to avoid using. The added challenge is  now you need to do this on an industrial scale.  And you can‚Äôt trust AI to do this correctly for you.</p>",
        "id": 571975141,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770227671
    },
    {
        "content": "<p>Math may be robust. But formalisations are brittle. This why proof repair, AI-driven or otherwise, remains an active research topic.</p>",
        "id": 571975192,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770227687
    },
    {
        "content": "<p>Also AI is far more capable of dropping you down into a deep pit of despair inside a proof as autoformalizing a proof.  A state of despair that  it cannot get you out of. It‚Äôs just that AI companies and even users are not advertising their failures as enthusiastically as their successes.</p>",
        "id": 571976059,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770227996
    },
    {
        "content": "<p>And as Wrenna points out, what is the use of formalisation if being sloppy is fine? We could very well manage that on pen and paper, with all its  disadvantages.</p>",
        "id": 571976409,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770228112
    },
    {
        "content": "<p>I would imagine most of these AI induced bottlenecks will be resolved in the next year or so. I think things are moving quickly. </p>\n<p>Just last summer we were using compiler loops with LLM calls, and now you can hook up Claude Code to some MCP tools and make decent progress.</p>",
        "id": 571976556,
        "sender_full_name": "Justin Asher",
        "timestamp": 1770228157
    },
    {
        "content": "<p>I keep hearing these claims with zero solid evidence. Just advertisements of successes.</p>",
        "id": 571976721,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770228202
    },
    {
        "content": "<p>An AI is trustworthy when it can be rigorously reasoned about by humans, I.e by rigorous theory and verification, neither of which exists yet. Until then it is not.</p>",
        "id": 571976796,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770228230
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"252920\">Alex Kontorovich</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/571972571\">said</a>:</p>\n<blockquote>\n<p>The technical debt question is real, sloplib as is will surely hit computation limits. But if the cleaning bots do their jobs, it should be no worse (in fact, possibly better...) than current mathilb.</p>\n</blockquote>\n<p>\"I have discovered a truly marvelous proof of this theorem, which your computer is too narrow to contain.\" ;)</p>",
        "id": 571984452,
        "sender_full_name": "Bryan Wang",
        "timestamp": 1770230537
    },
    {
        "content": "<p>&lt;puts mathlib maintainer hat on&gt; I think that <code>finite_abs_eval_lt_of_degree_lt</code> should be deduced from the claim that if one function is little-o of another one then the smaller one only beats the bigger one on a bounded set rather than grinding it out in the specific case of polynomials as Aristotle has seemed to have done, so yes I would say there was an element of slop about it; it is not clear to me that you engaged your brain in thinking about the mathlib way to prove that lemma; you just took the AI output and attempted to golf the argument rather than asking if this was the right argument. In particular the lemma could have been broken down into some nice intermediate steps rather than that one 30-line proof. But this is off-topic.&lt;removes hat&gt;</p>",
        "id": 571988978,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1770232051
    },
    {
        "content": "<p>Actually this is very on topic. It‚Äôs the perfect illustration of issues that can arise even with experienced and exceptionally good contributors using AI. Because if AI spits out a huge detailed proof, then not everyone is likely to have the time or give the proof the birds-eye-view analysis of the math  that  you gave.</p>",
        "id": 571993320,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770233554
    },
    {
        "content": "<p>Depending on the size of the proof (like the tens of thousands of lines you mentioned in the beginning), it might not even be feasible.</p>",
        "id": 571993840,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770233758
    },
    {
        "content": "<p>I have noticed that one of the prime issues with AI-generated proofs is that they are too long. This seems likely to be an artifact of AI systems not being trained with the goal of short proofs in mind, and is a source of a lot of their other issues, like unmaintainability. Simply asking AI to \"factor out have statements into separate lemmas\" often improves readability, and improves the usability of code as a library in a way that is not necessary when all you want is any proof of a single theorem. So I think \"sloplib\" like concepts would do well to emphasize refactoring proofs to be shorter and more split-up.</p>",
        "id": 571994184,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1770233861
    },
    {
        "content": "<p>It's off-topic because with my maintainer hat on I'm pointing out that the code could be split into smaller pieces but what I'm arguing in this thread is that maybe AI is sufficiently good at grinding out proofs that we simply don't need to care about this sort of issue any more. <em>If</em> all we want is a formal verification that a theorem is true (which would be the case if for example we were thinking only about a tool for refereeing maths papers) then who cares about the art of proof?</p>",
        "id": 572003552,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1770237071
    },
    {
        "content": "<p>surely we want to be sure the method of proof used on paper is also what happens in the verification? It seems to me that simply checking \"the AI proves this too\" doesn't seem to help much in that regard, no?</p>",
        "id": 572004040,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1770237268
    },
    {
        "content": "<p>I think that already a tool which says \"the main theorems are true\" would have a terrific practical impact on mathematicians.</p>",
        "id": 572004172,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1770237317
    },
    {
        "content": "<blockquote>\n<p>maybe AI is sufficiently good at grinding out proofs that we simply don't need to care about this sort of issue any more.¬†<em>If</em>¬†all we want is a formal verification that a theorem is true (which would be the case if for example we were thinking only about a tool for refereeing maths papers) then who cares about the art of proof?</p>\n</blockquote>\n<p>based on what I've skimmed from mathematicians reflecting on status of Mathlib, PNT+, sometimes they're very surprised when an intermediate lemma that is critical for some larger proof isn't readily available. So if we rely on big theorem, great, but we probably rely on BigTheorem+ which means having properly accessible/discoverable intermediate results that the professional mathematician is implicitly relying on to be available when they thing about BigTheory.</p>",
        "id": 572004471,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1770237428
    },
    {
        "content": "<p>I am not yet ready to use AI to do global software package optimization. It too eagerly does local optima of one off scripts,, because that is effective and achieves the goal of the task at hand. And in general, we're not great at getting across an overarching vision and breaking it down into a coherent and consistent set of tasks.</p>",
        "id": 572004660,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1770237505
    },
    {
        "content": "<p>Here's another way of looking at it. There's that time at the end of a long (weeks or months) formalisation when you may no longer care about mathlib-standard code, you just put your head down and go for it. I'm just saying that maybe we could \"put our heads down\", get the remaining 1000 or so definitions needed in order to state all the big new theorems in all areas of mathematics (I suspect we need less than 1000 if Annals is anything to go by) and then say \"yay AI let's go, Lean now understands every mathematical question that humans can ask, so now go prove some\". Right now we're not going to get to this point for several years at least but I'm arguing that we could be there in several months with sloplib.</p>",
        "id": 572005007,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1770237615
    },
    {
        "content": "<p>I get it. You're saying, go as fast as possible to the top down approach. That will give a path and vision to what we actually need to factor out.</p>",
        "id": 572005215,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1770237694
    },
    {
        "content": "<p>We are seeing AIs that can prove theorems about objects defined in Mathlib, where the definition comes with nicely designed API. I'm curious about how much of that capability remains if we are talking about a theorem that depends on several definitions that were AI generated in a sloppy way, with slop-API and whatever generality the AI used at that point.</p>",
        "id": 572005972,
        "sender_full_name": "R√©my Degenne",
        "timestamp": 1770237941
    },
    {
        "content": "<p>I'd be happiest if the AI library was only adding new theorems about existing (Mathlib) definitions. Ideally if public definitions were forbidden. Then we also wouldn't have to worry about missing API.</p>",
        "id": 572006417,
        "sender_full_name": "Martin Dvo≈ô√°k",
        "timestamp": 1770238131
    },
    {
        "content": "<p>It seems like the main point here is we need more research into how to effectively autoformalize definitions, because we have largely solved proving things in Lean using AI when given enough structure.</p>",
        "id": 572006904,
        "sender_full_name": "Justin Asher",
        "timestamp": 1770238327
    },
    {
        "content": "<p>My personal opinion is that we shouldn't autoformalize definitions at all.</p>",
        "id": 572007065,
        "sender_full_name": "Martin Dvo≈ô√°k",
        "timestamp": 1770238386
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/572005007\">said</a>:</p>\n<blockquote>\n<p>I'm just saying that maybe we could \"put our heads down\", get the remaining 1000 or so definitions needed in order to state all the big new theorems in all areas of mathematics (I suspect we need less than 1000 if Annals is anything to go by) and then say \"yay AI let's go, Lean now understands every mathematical question that humans can ask, so now go prove some\".</p>\n</blockquote>\n<p>I think this idea makes a lot of sense. I have thought about something like this in these terms: The <a href=\"https://reservoir.lean-lang.org/packages?sort=stars\">most starred repository on reservoir</a> is mathlib, which is only for theorems we know are true and have sorry-free proofs of. We also have a repository in formal-conjectures which is the fifth-most starred on reservoir (I might put it as the second most-starred out of repos accepting generally any field of math) which is for conjectures we don't know are true, and therefore can only be <code>sorry</code>s. It feels like there should be a middle ground library for theorems we know are true, but don't have sorry free proofs of. Not least because these are the main theorems where today's AI could help us (proofs of various Eros problems notwithstanding).</p>",
        "id": 572007379,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1770238484
    },
    {
        "content": "<p>But that's exactly the repo I'm making with my RenPhil money -- formal statements of recent Annals papers. It's just not public yet because it's not big enough to be interesting. The main bottleneck is missing definitions.</p>",
        "id": 572010184,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1770239466
    },
    {
        "content": "<p>Well, I guess I think that your RenPhil project sounds great and I think and hope it will be a big success!</p>\n<p>I think the only difference between your description of this project and what I usually envision when I think about a project like this is that I am not really familiar with Annals or big academic math journals in general, so I think more along the lines of \"statements of theorems in the <a href=\"https://1000-plus.github.io/\">1000+ theorems list</a>\" than \"statements in the annals\".</p>",
        "id": 572012561,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1770240345
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/572003552\">said</a>:</p>\n<blockquote>\n<p><em>If</em> all we want is a formal verification that a theorem is true (which would be the case if for example we were thinking only about a tool for refereeing maths papers) then who cares about the art of proof?</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> , you and a couple of others were the ones from whom I learnt that there are more uses for formalisation than verification. I don‚Äôt have the specific link right now. </p>\n<p><span class=\"user-mention silent\" data-user-id=\"350992\">R√©my Degenne</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/572005972\">said</a>:</p>\n<blockquote>\n<p>We are seeing AIs that can prove theorems about objects defined in Mathlib, where the definition comes with nicely designed API. I'm curious about how much of that capability remains if we are talking about a theorem that depends on several definitions that were AI generated in a sloppy way, with slop-API and whatever generality the AI used at that point.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"350992\">@R√©my Degenne</span> : see an example in the repository I posted above. The tldr is, it is terrible.</p>",
        "id": 572014638,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770241035
    },
    {
        "content": "<p>Here it is: <a href=\"#narrow/channel/113488-general/topic/sloplib/near/571941942\">https://leanprover.zulipchat.com/#narrow/channel/113488-general/topic/sloplib/near/571941942</a></p>\n<p>The theorem is bog-standard in the area. GPT could even give a good explanation of the proof upto some detail informally</p>",
        "id": 572014954,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770241129
    },
    {
        "content": "<p>But the further it went away from library level stuff , the more messed up the formalisation became. I never intended to publish this repo because it was a one-off experiment. But I think it‚Äôs a great example of how things work at the moment.</p>",
        "id": 572015184,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770241208
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/572005007\">said</a>:</p>\n<blockquote>\n<p>I'm arguing that we could be there in several months with sloplib.</p>\n</blockquote>\n<p>I find that hard to believe. In differential geometry, finding the right Lean definitions is the hardest part of the work. I wouldn't want to imagine AI winging one. There is a bottleneck in \"this code is almost done, clean it up and chop it into nice PRs\" (and there used to be one of \"get the code reviewed\", that has improved), not in \"let's write more code that's not ready yet\".</p>",
        "id": 572015334,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1770241261
    },
    {
        "content": "<p>Here is a tiny argument 'in favour' of some form of 'sloplib': one of the biggest advantages of mathlib is its centrality, which ensures compatibility and coherence. <strong>Assuming that people are going to produce the same amount of AI-generated Lean code with or without 'sloplib' anyway</strong>, it would be much better to put everything one central repo (which also tracks mathlib as much as possible), rather than ending up with lots of different AI-generated repos which are all drifting further and further apart from one another and from mathlib.</p>",
        "id": 572015436,
        "sender_full_name": "Bryan Wang",
        "timestamp": 1770241296
    },
    {
        "content": "<p>Even if AI could prove the theorem I stated  tomorrow, let‚Äôs say it gave a 10000 line proof. Given the variability in AI performance, would you feel comfortable asking it to refactor the proof knowing fully well that it could mess things up again?</p>",
        "id": 572015572,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770241353
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"934803\">Bryan Wang</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/572015436\">said</a>:</p>\n<blockquote>\n<p>Here is a tiny argument 'in favour' of some form of 'sloplib': one of the biggest advantages of mathlib is its centrality, which ensures compatibility and coherence. <strong>Assuming that people are going to produce the same amount of AI-generated Lean code with or without 'sloplib' anyway</strong>, it would be much better to put everything one central repo (which also tracks mathlib as much as possible), rather than ending up with lots of different AI-generated repos which are all drifting further and further apart from one another and from mathlib.</p>\n</blockquote>\n<p>The central repo idea works when code is entered into it following certain standards and after a certain level of review and effort to make it all work together. It doesn‚Äôt work when these elements become infeasible.</p>",
        "id": 572015761,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770241416
    },
    {
        "content": "<p>Yeah, the advantage of mathlib as a monolithic library lies in there being a single formalism for \"real numbers\" or \"group\" or whatever - it's not a given that a centralized AI-generated library would achieve that (and that's as generous a phrasing I can come up with)</p>",
        "id": 572016599,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1770241734
    },
    {
        "content": "<p>One way or the other, creating sloplib as an experiment will teach us something, and it may potentially have a huge payoff.</p>",
        "id": 572017556,
        "sender_full_name": "Martin Dvo≈ô√°k",
        "timestamp": 1770242151
    },
    {
        "content": "<p>I guess the main question is the opportunity cost - would or could the money and effort going into this library be better used for something else</p>",
        "id": 572018619,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1770242565
    },
    {
        "content": "<p>As long as they make it clear that it is sloplib. I wonder how this will influence AI training.</p>",
        "id": 572018636,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770242575
    },
    {
        "content": "<p>For additional context this just landed yesterday:</p>\n<p><a href=\"https://arxiv.org/abs/2602.03837\">https://arxiv.org/abs/2602.03837</a></p>\n<p>In the future directions section there is talk of autoformalisation pipelines. Many of the authors are famous TCS researchers who aren‚Äôt actively into formalisation. We are about to see sloplib x 100, because very few people have worked with lean and understand what trusting lean means.</p>",
        "id": 572018934,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770242695
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/572015761\">said</a>:</p>\n<blockquote>\n<p>The central repo idea works when code is entered into it following certain standards and after a certain level of review and effort to make it all work together. It doesn‚Äôt work when these elements become infeasible.</p>\n</blockquote>\n<p>I guess that was the idea behind Kevin's original question (if I read correctly): </p>\n<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/571882431\">said</a>:</p>\n<blockquote>\n<p>What then happens to this library in the long term? How does it collapse, if it collapses at all? Assume that there is enough funding to keep the AI tools running.</p>\n</blockquote>\n<p>In other words, it could well collapse, but why not try? And my point above was that I realised it could well be worse if people are going to use AI to write Lean <em>anyway</em>, but without any sort of effort to make it all come together in the long run. We are going to have all sorts of 'hit-and-run' AI projects where some piece of maths X is formalised in some AI-generated repo somewhere, and that kills the interest in actually formalising X properly because 'it's already done and so I won't get proper credit for it', but the stuff in that repo never actually makes it anywhere useful and just dies over time. If this happens to sufficiently many X it could have a much worse impact on formal maths than 'sloplib' would.</p>",
        "id": 572019069,
        "sender_full_name": "Bryan Wang",
        "timestamp": 1770242754
    },
    {
        "content": "<p>In a way 'sloplib' is just choosing between the lesser of two evils..</p>",
        "id": 572019359,
        "sender_full_name": "Bryan Wang",
        "timestamp": 1770242870
    },
    {
        "content": "<p>It is not the lesser of two evils. It‚Äôs the same evil with a brand name slapped on it  that will give it more credibility than it deserves in the short run.</p>",
        "id": 572019896,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770243088
    },
    {
        "content": "<p>Btw I should say that I'm personally still not too optimistic about the idea of 'sloplib'. But if the name remains as 'sloplib' (or is remembered as such) then it might not be that much of a credible brand name <span aria-label=\"stuck out tongue\" class=\"emoji emoji-1f61b\" role=\"img\" title=\"stuck out tongue\">:stuck_out_tongue:</span></p>",
        "id": 572021912,
        "sender_full_name": "Bryan Wang",
        "timestamp": 1770243839
    },
    {
        "content": "<p>Let's just use <a href=\"https://github.com/merely-true/merely-true\">https://github.com/merely-true/merely-true</a></p>",
        "id": 572023802,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1770244591
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/572014638\">said</a>:</p>\n<blockquote>\n<p>@Kevin Buzzard , you and a couple of others were the ones from whom I learnt that there are more uses for formalisation than verification.</p>\n</blockquote>\n<p>Yes absolutely. And this question is about \"why don't we forget some of those for now\" so your comment is kind of irrelevant. The question is about the thought experiment which involves forgetting this fact.</p>",
        "id": 572026948,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1770245974
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"634338\">Michael Rothgang</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/572015334\">said</a>:</p>\n<blockquote>\n<p>In differential geometry, finding the right Lean definitions is the hardest part of the work.</p>\n</blockquote>\n<p>Can you think of a super-annoying definition in diff geom which we don't have, and then perhaps someone can ask an AI to come up with a definition, so we can test the hypothesis that AI is no help in solving this hard problem?</p>",
        "id": 572027102,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1770246030
    },
    {
        "content": "<p>Okay that‚Äôs fair. But even in that thought universe there are several reasons to avoid sloplib which I and others  have listed above. Even if those engineering catastrophes don‚Äôt concern you, consider that sloplib is likely to grow much faster than mathlib and that‚Äôs going to train the next generation of AI models.</p>",
        "id": 572027273,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770246098
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/572018619\">said</a>:</p>\n<blockquote>\n<p>I guess the main question is the opportunity cost - would or could the money and effort going into this library be better used for something else</p>\n</blockquote>\n<p>Right. Which is why my question isn't \"who will give me money to do this stupid experiment\", it is \"can people please explain to me why this stupid experiment is doomed to failure? What are the probable failure points?\"</p>",
        "id": 572027288,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1770246105
    },
    {
        "content": "<p>Already an Isabelle person mentioned to me that models output lean code inside Isabelle because of the training data.</p>",
        "id": 572027434,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770246168
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/572023802\">said</a>:</p>\n<blockquote>\n<p>Let's just use <a href=\"https://github.com/merely-true/merely-true\">https://github.com/merely-true/merely-true</a></p>\n</blockquote>\n<p>Oh so you are 4 months ahead of me!</p>",
        "id": 572027479,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1770246186
    },
    {
        "content": "<p>That indicates the importance of both data quantity and quality.</p>",
        "id": 572027486,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770246187
    },
    {
        "content": "<p>OK great so perhaps a next step here is that <span class=\"user-mention\" data-user-id=\"634338\">@Michael Rothgang</span> proposes some really annoying definitions in differential geometry, or perhaps I propose the definition of automorphic reprentation over a connected reductive group in Langlands, and then we watch AI fail to come up with definitions?</p>\n<p>What's the easiest way to ask an AI to formalize the definition of a connected reductive group over a field? That's a place to start. If AI can't do this without serious help then one of the main motivations of sloplib (accelerate formalization of definitions) is dead in the water.</p>",
        "id": 572027989,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1770246407
    },
    {
        "content": "<p>If it gives a reasonable definition of connected reductive group then the next question is automorphic form for a connected reductive group over a number field (and this is much harder).</p>",
        "id": 572028068,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1770246449
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>, how about you write three different prompts.</p>\n<ol>\n<li>Just a couple of sentences saying the scope of what you want defined, but without explanation.</li>\n<li>That, plus some references to (ideally publicly available, but PDFs are fine too) standard explanations of that material.</li>\n<li>A couple of paragraphs of explanation (in prose) of how you would like it done.</li>\n</ol>\n<p>I'm happy to then let loose Aristotle / Claude (with/without custom lean skills) / Codex on those prompts and show you what we get.</p>",
        "id": 572028689,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1770246734
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/572028689\">said</a>:</p>\n<blockquote>\n<p>show you what we get</p>\n</blockquote>\n<p>Could you also show the rest of us? :D I think the results of this experiment would be super interesting to see, for many people!</p>",
        "id": 572031667,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1770248326
    },
    {
        "content": "<p>Of course! :-)</p>",
        "id": 572031720,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1770248364
    },
    {
        "content": "<p>I'd rather we had the money that would be invested into sloplib compute, instead invested into Mathlib review (ie paying more experts to maintain the library). However that's not a decision I (or indeed anyone here, I believe?) can actually take - it's up to the big tech companies and billionaires that fund us, and they usually (not always) prefer the AI approach.</p>",
        "id": 572034315,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1770249690
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"252920\">Alex Kontorovich</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/571972296\">said</a>:</p>\n<blockquote>\n<p>what are the things we do when formalizing a mathematical statement?</p>\n<ol>\n<li>check if it's already in the library. if not,</li>\n<li>think of what the main definitions should look like</li>\n<li>try some API lemmas to see if we got the definitions right. if not,</li>\n<li>refactor definitions until they feel usable.</li>\n<li>start proving the lemmas, building up to the main theorem. refactor definitions/API as necessary.</li>\n<li>Look over the whole formalization; is it in the right generality? did we end up not using assumptions we thought were necessary? refactor accordingly</li>\n<li>Golf. Extract abstractions, start over.</li>\n<li>PR, get feedback, refactor, etc.<br>\nWhich of these things is something AI can't eventually get good at? We could start with one AI populating sloplib/methlib/merely-true, and have a \"golf\" agent go through and clean it up, and an \"abstractify\" agent clean up the structure, and a \"mathlibify\" agent resynthesize everything and put it in the right file and with the right  theorem name, etc etc etc. Everything I've seen so far is pointing to such a future...</li>\n</ol>\n</blockquote>\n<p>For whatever reason, more AI developers seem more interested in making AIs that prove things than in making AIs that do all these other software engineering pieces needed for good mathlib contributions. (Some ability to prove things, at least on a small scale and guided by an informal proof, is necessary as part of being able to do the rest of the above, but far from sufficient to get an AI contributing directly to mathlib.)</p>",
        "id": 572034985,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1770250012
    },
    {
        "content": "<p>I am basically living inside this scenario right now. I'm sure the code I created with a structure of cross-inferencing AIs is far from optimized, but it works with no shortcuts and that's for me is the beauty of it.</p>",
        "id": 572039671,
        "sender_full_name": "Luca Casagrande",
        "timestamp": 1770252832
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"1023388\">Luca Casagrande</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/572039671\">said</a>:</p>\n<blockquote>\n<p>I am basically living inside this scenario right now. I'm sure the code I created with a structure of cross-inferencing AIs is far from optimized, but it works with no shortcuts and that's for me is the beauty of it.</p>\n</blockquote>\n<p>And indeed, I just suspended your account for a day for posting AI slop (an announcement about an AI-written repository with unpackaged Lean files, which I've junked)!</p>",
        "id": 572040589,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1770253503
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"282271\">Bolton Bailey</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/572007379\">said</a>:</p>\n<blockquote>\n<p>We also have a repository in formal-conjectures which is the fifth-most starred on reservoir (I might put it as the second most-starred out of repos accepting generally any field of math) which is for conjectures we don't know are true, and therefore can only be <code>sorry</code>s. It feels like there should be a middle ground library for theorems we know are true, but don't have sorry free proofs of. Not least because these are the main theorems where today's AI could help us (proofs of various Eros problems notwithstanding).</p>\n</blockquote>\n<p>Formal Conjectures not only contains open problems, but also currently 588 statements of research problems which are solved. Most of these with a sorry-proof. We include those either because they are variants of open problems, or part of a problem collections, or in some cases were still open when added to the repo, but got solved in the meantime. <br>\nWe don't want to include proofs for these especially if it is thousands of lines of AI-generated code, because of the maintenance burden. However, <span class=\"user-mention\" data-user-id=\"376152\">@Paul Lezeau</span> added  a mechanism to point to those proofs <a href=\"https://github.com/google-deepmind/formal-conjectures/pull/1851\">FC#1851</a>.</p>",
        "id": 572083444,
        "sender_full_name": "Moritz Firsching",
        "timestamp": 1770279309
    },
    {
        "content": "<p>Another reason we include solved variants: they are potentially good tests for the unsolved variants</p>",
        "id": 572084705,
        "sender_full_name": "Moritz Firsching",
        "timestamp": 1770279805
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/572027989\">said</a>:</p>\n<blockquote>\n<p>What's the easiest way to ask an AI to formalize the definition of a connected reductive group over a field? </p>\n</blockquote>\n<p>My procedure for this is first asking Gemini for the verbal definition with the condition that it is close to the research literature (you need Grounding for this, of course), and second a variation of this prompt: \"Which definitions or structures are missing in lean4 mathlib in order to state the above definition in lean4 (just stating)?\"</p>\n<p>What I got with the above was a detailed list of what's missing (available on request). The summary:</p>\n<blockquote>\n<p>To write the definition today, you would first need to define (or locate on a development branch) the following structures which are not in the main¬†Mathlib¬†library:</p>\n<ul>\n<li>\n<p>structure LinearAlgebraicGroup (k : Type*) [Field k]¬†(extending Affine Scheme + Group).</p>\n</li>\n<li>\n<p>def IsUnipotent (G : LinearAlgebraicGroup k) : Prop¬†(requiring representation theory or matrix embeddings).</p>\n</li>\n<li>\n<p>def unipotent_radical (G : LinearAlgebraicGroup k) : LinearAlgebraicGroup k.</p>\n</li>\n<li>\n<p>def IsReductive (G : LinearAlgebraicGroup k) : Prop := (unipotent_radical (base_change G (algebraic_closure k))).is_trivial.</p>\n</li>\n</ul>\n</blockquote>",
        "id": 572085011,
        "sender_full_name": "Ralf Stephan",
        "timestamp": 1770279906
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/572028689\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span>, how about you write three different prompts...</p>\n<ol start=\"3\">\n<li>A couple of paragraphs of explanation (in prose) of how you would like it done.</li>\n</ol>\n</blockquote>\n<p>Well that's the thing -- I don't know how I would like it done. </p>\n<p>One thing's for sure -- a connected reductive group over a field is not a group. It's either a group variety (or a group scheme, although historically these things were well-understood before schemes because they're smooth and of finite type over a field so one can get away with Weil's machinery, which of course we don't have because we only have Grothendieck's machinery), or it's a Hopf algebra (because it's an affine group variety over a field so everything can be done on the level of K-algebras). So already there is a huge design decision: should the basic object secretly be a Hopf algebra or a scheme.</p>\n<p>This is as far as I got when I tried to do it with Andrew Yang sitting next to me a couple fo weeks ago (for connected reductive groups over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Q</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Q}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8556em;vertical-align:-0.1667em;\"></span><span class=\"mord mathbb\">Q</span></span></span></span> although it's obvious how to generalise):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"w\"> </span><span class=\"n\">AlgebraicGeometry</span>\n\n<span class=\"c1\">-- let G be an affine group scheme of finite type over ‚Ñö</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Scheme</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">œÜ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Spec</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">CommRingCat</span><span class=\"bp\">.</span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">‚Ñö</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">GrpObj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Over</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">œÜ</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsAffine</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LocallyOfFiniteType</span><span class=\"w\"> </span><span class=\"n\">œÜ</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- can't say \"geometrically connected\" until a PR is merged</span>\n\n<span class=\"c1\">-- can't make the Hopf algebra until stuff from Toric is merged</span>\n</code></pre></div>\n<p>and that was for \"connected affine algebraic group of finite type over a field\" if we go down the scheme route. Then there's the question of how to say \"reductive\" . I asked Brian Conrad and his response was</p>\n<blockquote>\n<p>Note that the \"there exists‚Äã a completely reducible rep with finite kernel\" definition<br>\nis no good over imperfect fields: if k‚Äô/k is purely inseparable of<br>\ndegree p = char(k) &gt; 0 then the Weil restriction G = R_{k‚Äô/k}(GL_1)<br>\nacting on the affine space R_{k‚Äô/k}(G_a) = A^p_k is a faithful<br>\nirreducible linear representation (though not absolutely irreducible),<br>\nso completely reducible, but G is not reductive (it is pseudo-reductive,<br>\nbut that‚Äôs a separate can of worms).</p>\n<p>So what is the best definition that works over all fields?<br>\n I think the only good definition, treating all fields<br>\n on equal footing, is the one in Borel‚Äôs book: that<br>\n G is k-smooth and the unipotent radical of G_{kbar} is<br>\n trivial.</p>\n<p>Writing this, I realize you may be unhappy since you don‚Äôt<br>\nwant to have to first formalize the notion of unipotent<br>\nradical (you can‚Äôt object to bringing in kbar, just as<br>\nwell perfect closure if you wish, since that is needed<br>\nto circumvent the issue in the example above).  But you don‚Äôt:<br>\nyou could just say ‚ÄúG_{kbar} has no nontrivial smooth<br>\nconnected unipotent normal closed k-subgroup‚Äù and thereby<br>\npostpone formalizing ‚Äúk-unipotent radical‚Äù until later.  :)</p>\n<p>On ‚Äúclosed k-subgroup‚Äù: I was thinking we are limiting ourselves<br>\nto the affine case (and thereby in my head invoked the fact that a monomorphism<br>\nbetween affine group schemes of finite type over a field is always a closed immersion).</p>\n<p>What's the correct definition of a unipotent subgroup?</p>\n<p>Here are some equivalent notions (some equivalences proved in Raynaud‚Äôs expose on<br>\nunipotence in SGA3) for a group scheme G over a field k:</p>\n<p>(i) G admits an isomorphism onto a closed k-subgroup scheme of the k-group U_n of<br>\nstrictly upper-triangular nxn matrices in GL_n (i.e., 1‚Äôs on diagonal) for some n</p>\n<p>(i‚Äô) Same as (i) for G_{kbar}</p>\n<p>(ii) Every k-homomorphism G ‚Äî&gt; GL_n factors through U_n after some GL_n(k)-conjugation</p>\n<p>(iii) G admits a finite composition series by closed k-subgroup schemes (each normal<br>\nin the next) for which each of the successive quotients is a closed k-subgroup scheme<br>\nof G_a</p>\n<p>(iii‚Äô) For char(k) = p &gt; 0, same as (iii) for G_{kbar} but the successive quotients<br>\nare each among {alpha_p, Z/pZ, or G_a}.</p>\n<p>(iv) For G <em>smooth</em>, there is tthe condition from Borel‚Äôs book that everything in<br>\nG(kbar) is unipotent (meaning that under some homomorphism closed immersion G ‚Äî&gt; GL_n<br>\nover kbar the image on kbar-points consists entirely of unipotent matrices, or<br>\n equivalently under all kbar-homomorphism G ‚Äî&gt; GL_n not necessarily with trivial<br>\n kernel; equivalence proved in Borel‚Äôs book).</p>\n<p>The official definition in SGA3 is (iii), but if you‚Äôre only going to focus on<br>\n unipotence for smooth affine k-groups then (iv) may be more convenient to get<br>\n going (though it is useful even for the study of smooth G that we have these<br>\n equivalences allowing non-smooth cases, such as for work with non-smooth kernels).</p>\n<p>Remark:  Unlike for tori, there is <em>no</em> good notion of ‚Äúunipotence‚Äù over a base<br>\nthat isn‚Äôt a field (or rather, a product of finitely many fields).  It‚Äôs a bit of<br>\na miracle that for parabolic subgroup schemes P of reductive group schemes over<br>\na general base S there <em>is</em> a good relative notion of R_u(P) that has a variety<br>\nof desired properties; this is discussed in my expository article on reductive<br>\ngroup schemes.  It‚Äôs also a miracle that there is a good notion of ‚Äútorus‚Äù over<br>\na general base (with multiple equivalent characterizations)...</p>\n</blockquote>\n<p>Note that this is the easy part: the hard part is automorphic forms for these objects.</p>\n<p>I read all this stuff now and I am immediately thinking \"clearly AI is not yet ready for this\". I am now fearing that if we keep going with this experiment then I'll have to review a bunch of slop to see if it correctly conforms to the definition and I'll be thinking \"well it would have been easier just to write it myself\" even though maybe I'm wrong because I keep not writing it myself.</p>",
        "id": 572087219,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1770280551
    },
    {
        "content": "<p>I asked cheapo Claude to write me a definition and it came up with <a href=\"https://gist.github.com/kbuzzard/dc7f3f41af331b8c9ba0bdf063934a6d\">https://gist.github.com/kbuzzard/dc7f3f41af331b8c9ba0bdf063934a6d</a> which uses Hopf algebras but completely skips the unipotent radical part (i.e. doesn't even try).</p>",
        "id": 572088067,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1770280829
    },
    {
        "content": "<p>I need to think about my FLT lecture for a few hours now but perhaps it's worth splitting off the connected reductive group challenge into its own thread. Now I've thought a bit more about this I've realised that Michael Rothgang's comment is very pertinent -- sometimes for really complicated definitions it's not at all clear how best to formalise them. Several times in my life I have attempted to solve this by \"just having a go\" -- for example it took us 3 attempts to get schemes right and 3 attempts to get group cohomology right and all the earlier failed attempts in each case were projects done by Imperial students which basically boiled down to me experimenting with design decisions, looking at what was problematic, and rerouting based on student feedback.</p>",
        "id": 572092041,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1770282044
    },
    {
        "content": "<p>The discussion of the PR is off topic here. Please move that discussion to the github page or to the PR reviews channel.<br>\n(edit for confused future readers: the discussion I mentioned has been moved)</p>",
        "id": 572092859,
        "sender_full_name": "R√©my Degenne",
        "timestamp": 1770282276
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/571972071\">said</a>:</p>\n<blockquote>\n<p>In other words why <em>do</em> you think that mathlib should contain well-engineered proofs? If a mathlib-powered AI tells me new things about the strong Birch and Swinnerton-Dyer conjecture because we accelerated mathlib sloppily to the point where it can understand the statement, isn't this a win?</p>\n</blockquote>\n<p>Beautiful things good. But I am not a working mathematician so perhaps I have a different perspective on this. I do find proofs more meaningful when they are well-structured.</p>",
        "id": 572095277,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1770282997
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"780541\">Justin Asher</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/571976556\">said</a>:</p>\n<blockquote>\n<p>I would imagine most of these AI induced bottlenecks will be resolved in the next year or so. I think things are moving quickly. </p>\n<p>Just last summer we were using compiler loops with LLM calls, and now you can hook up Claude Code to some MCP tools and make decent progress.</p>\n</blockquote>\n<p>If you've got the money for it. I don't.</p>",
        "id": 572095428,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1770283037
    },
    {
        "content": "<p>Software is, well, malleable. Just because a theorem is first added with a messy and unreadable proof it doesn't mean it needs to freeze there. Humans can improve it. Or machines, even <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>\n<p>To me, a layman who barely knows basic group theory, the problem of machines doing math is convergence. Is the machine doing things that interest us, humans? If the direction is driven by humans, that's a solved case. I'm just not convinced of fully autonomous machines writing mathematics on their own.</p>",
        "id": 572120208,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1770290233
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/572027273\">said</a>:</p>\n<blockquote>\n<p>Okay that‚Äôs fair. But even in that thought universe there are several reasons to avoid sloplib which I and others  have listed above. Even if those engineering catastrophes don‚Äôt concern you, consider that sloplib is likely to grow much faster than mathlib and that‚Äôs going to train the next generation of AI models.</p>\n</blockquote>\n<p>Not necessarily. A good curation of training data would suppress it.</p>",
        "id": 572128019,
        "sender_full_name": "Michal Buran",
        "timestamp": 1770292566
    },
    {
        "content": "<p>Let me add my two cents here, from the perspective of a different subject: Physics and with regard to the project PhysLean. Sorry if I am just adding noise and painting a bike shed.</p>\n<p>Given the much earlier stage of this endeavour compared to Mathlib, I've often thought about whether it would be possible for a (not-community motivated) AI company to just spend a bunch of money to reproduce what is in PhysLean and overtake the human-centric community effort. Here I've come to the similar conclusions as others above, but with a physicists coating: </p>\n<p>Lean is not verifying the physics context of results, it is not verifying \"yes this really corresponds to quantum mechanics in the real world\", it is not verifying that what is written is main-stream-physics, it is not verifying whether a result is useful or interesting to the community (also true in maths), it is not verifying whether a given definition is intuitive to humans, or is easy to use .... etc. Lean verifies the mathematical context of the results, and this is really it. The rest of the this all needs to be verified by something other than Lean - and to me in a world where we are writing Lean code for humans, the only way we can do this is via human input and human verification.</p>\n<p>I personally am starting to care less about whether \"this result from physics (or maths) has been formalised\" - and more about \"how have you formalised this\", \"what design choices did you make\", \"what can we learn from your formalisation\", \"how has it been designed to be used by others\", \"how does it fit in with other formalisations\". These are questions I feel a sloplib would not answer.</p>",
        "id": 572128398,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1770292686
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/571904944\">said</a>:</p>\n<blockquote>\n<p>I haven't read all the messages above, and that will have to wait for morning, but this nevertheless seems like a good time to advertise the <a href=\"https://github.com/merely-true/merely-true\">merely-true</a> repository that Johan and I thought about late last year, but never launched.</p>\n</blockquote>\n<p>Have you considered resurrecting it?</p>",
        "id": 572129838,
        "sender_full_name": "Michal Buran",
        "timestamp": 1770293037
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/572027989\">said</a>:</p>\n<blockquote>\n<p>What's the easiest way to ask an AI to formalize the definition of a connected reductive group over a field?</p>\n</blockquote>\n<p>I tried this using a Claude Code setup I have on my computer, which utilizes the LeanExplore MCP tooling.</p>\n<p>I got the following file:</p>\n<p><a href=\"https://live.lean-lang.org/#codez=PQWgUAwg9gDgngJwJYHMAWAXABACgMYCUWATAAzECsAdFgIIA29Wy6GAzswKZucIBunACZUwAJU71OAQx6CsAVwB2g3nRhS8aTiSqks9JHk6KeWGVhVs8yAEZCsSRVgxasAMySSsAGQCSEAFEAOQBlAJFaeRcoBDYALh8kAQAFBCgBACFjTTAQYDAkAFsYGOwAWSkXAxswMFAAQjAAYixoRUVOPAx7cUF5LqTtAHE0+RgOdNUpLAAxJAlBWoAVNCQODy8VDw6OF21FKAwkKCcoNzMsPBOOrvsEIX6jgSwUUZgsSYQLjwWAGjAbPJPIJHCgFO83GlCs5XG4oIwoAB3UGXNBSRwfc5bRxII4neK1ACMNAAVCTRKhMJcoIUoH1JGSPgIvtMABKwc5SegoTg2BBSMDEUkkkLyGwgK60+mcMkJaZsMVS+ReGD3Hj8ew2OAw7RXDR4xRgADMwtobm22i5PL56LwLzesouksKUUqgyw7JgnO5vP5MMqDg4bFphzQZmUmPcOO6zjgME4YAALMK2jduoJGVJzY5LT6bYZ7VAxgkTtpEWgoKZVUVtGx410EPJoWtqe1OumwNQsGTvDmpAh6Nr7n0BgJHZxmdrtrjOCAQYVjGxjooudSlV4W1ceIU1kUYJIwFgjzgJ7xtQrxZK6crtGiONMr9K1/vOAvFBgCGAAGwp67tu4PKO2ivEWMCOg+f63IIvz6H2A5DoBTyWtmHRmHm/IFiBYy1E0LQVHshRungq5XO+nAAB4YLUtBOFmFqFmMWBWFoC5MlMa4uhgbrPMgihggABgA1vxgY6kxUisS4KLmAKzqukhHocmh1p+p8WBCfxNArLqlScCgMTamcXCqtwxhcQaEycrRKEJlh7zMa+2j8UMWAALxYCE9Z0CJLacAAjkCfBcmZzhQGJxHdPpCCGecLBUvxtD8RKNLXpIbAiGAtCtmm9hWr6toMe8zkiWp0w/PQcgaaJZLDo8gyMkg5x7AoihICU3TvmA/IgsRTBGc5AD6ADegmACDAAC+Pm7MgfBIFyNC+E4mj9vqvBrEcdoAF68FAMFSRwvkBUkwXvqFYBkgYHT9lwI5PLicDjpOUatd0c41iYy6rvcJk8O+bonKJkovt0g5dYBSA2F4ODbruxSSAQC1OCUS4Kct/K3MgbAbTBl3SF8tWjvdolY8gXSgyTJw8l8LhSE4BN3Rg2o4FqWBBFIKCVFIADkuxaDEr4wRBbZQbBV3wTddUCGAdkOEtaLo90mMbep7wAHxYKQU0XBgMTyGwCO1AA6toevaM1uPXfTSRE2jq3IJt/1OFo9wweWhhhiggy87qMT3F0YAHAasuoitGPrQW21pOGcjTAutOgm4yq4BTfG8EQgfLsHPIdPy9AZbhWC+HDjl/UHgfcEb2jqPyC6K0g21rql3BYCz/EANohK+SC8WCEAALpYG3GRzeh0yiK0fcifyezU2iTjNbS9zS8YvCru3tCCII0CFIUZQnFASByP3g970+4/H230B5TaIQYI2XRYOfk9aasHCLvIar+lRzUJZv2+7/vQ+IlaaVVPjeHyJguKKCMBMJw/EIDAPuBYNaAg5CQhpGJfincdw934mAEB6kGAqSkCJZEUl56uH4sPa+/IRIk0eB/Tggs+AHxBHxC4IIJInDkOWYw6kEGiQFPAmkhQKR8VIbiMM0x+KejcEQ/KdC74MKQTgXhSDHAqHjMoEKjgsa0yMFwNg8IojLjANsQQHBf5bxEXvA4QDo7qTAZIESLhRjoFlkDN0kMq6VDQPrfOLRxBuF4NkCu50T6eA6DBEk8j8x2hGKBNgJI+5tx3PQDoZBCQAHY+7hLbobXSCAKym2iYtO+14BgAx1nQGyWAEmMRCJoRySSUmIkKcUnghIACcWSum5JJIPAAUrTDA21FDRPED9MyjtLJ0FHgWep4xkltwAFYjLGWQUgRpcl5FqAcaBNIYCum8UxdspiwCwD4UsRcMRUgVKomAJQgxYgmywHwLAiJagNCwLhQJlJsCPhvBMZkFwbAj2IVgXZYAeCVKcNvJutQgrICkCcnA48EhLDjCbIgl8RHYO7iiUQuSkVzVRRALAGKsVvJxfinuE9B7UNHo/CeXyQAgDoMwf5jcnz0K6IwtiLI4GiCSmCmh0iEEZSynFAFKUnwtlpupYVIB1xOTKCJfyQIYDxh4ZIp0UB9SZ34oAQeAKVYDKFgQASYSAHSCNuRKzVYEAOlEtqB4IOhW6Ngbg4Aoj1GwIxeA5oM21AQq4TyuIGEZi/FsLZmpXAQH7bAGcAZnDAAAIm+mqaZQcjIKrojmQqTEmmsSwV5CVKbIX5DwPQGQHAKSsHhU+HA5rKXxg+Tije1id62NYWagebcnHaHHmUAeaiExHlAOy7S1IDUA0IkVE1CRzXWudfap1dqJXlsPFO2FprF02rtea1dLrN3jtaPq31UB/XcXugkfiOATUOocIIIggAMIiwCa9yOBD6OqwIAFOAX1vpEjgdcYVmrVovQGmICMN1Hh9X6ilm7jzXJMLctIt0qBgbtIO1orQX1Wq3QaKgCAkNGK+OS59eG9Tbtcgho8p6xW33vhgKgkplRUHoMRmI9ryP4dMWOtlj8uUhpelya96lP1yAfYAVuB/3vtwNCQAZYRYGhA+wkBBNLQepKGgalGg5xBo1fUeDHHjMaLC9NjHGvjmu4zpzOH6LN3LQ4UQSzLzWiARm4Aw7xCS1GMEfWVN5WX1B+QXUUl5/NpQ3dCs5ANQv1oC2AElKKvBDXRVgTFLb5DjUHv/WlhLiX9lJcl8lzbtB8Cyx3LudKL6MohU/BLBWkvaCGk2tLVLETlfbf/LtX6h0nybi53ttbMBxa8OfHtrL2VZQvCqlWJVOSctYNym8jitbTDJBeZKKqGpNVcDZk4YBZ2WJgBA6pzUijs20EZGNtMTiGFXI4StetDXvAfeSwAVYQrtaOp3ZWxC5sFi+F7QOB3gJFCzNwdRAEh3JB9Ro8gAAIiU1gQAEERYBgP8WjAm62A5M9OpwaKKXuTc7gYr7kIBEGhEjmjR5exiwqDAQjtMeS4BwGDpuVALyMxbTABGRGbmkc/HUfjk7I5hWm/1+VTExSbbZxuvY/Nmz/bFCNzgA0bCHFNb4RXNhle4HRYTogOASc4dwIAUqJTWs7PmayH7ktSbscOUxHaBCiboQIiQeFubxUAXIUVXhwB4Bid5ui8WMsCB6PEuYoHxFCDkHrOgaIvclHgovqLAIuBre6wANHzEYAcqsC8Flo0AYYR5fEtiLUKYVByL13EvB56vIpOSl016WTblZy5VvL9fCtNeK61ltZX3cd/YdV8F+VmX9wmxy6V/CkqAq8PxNV1USRbhr3uBkAzGpYFPNFSXYWZt3nwc+SQb4uI7423PzgCQ4RfG3+eKXF/Zt7WdtoCi617zQvv4D9Sfk6H9DDDTbAfid4QAFKIsA/I3IsBAASomAQjCAKwEAGSiMAiAk3b7CtKtX1P7avHcWvTgHXRtZvNrNtP+GxQBOQXrPtfrQdRPWjW1f5HXMbXrKHNId4EdTdV/LGNgAaNYbefcAaC8B/PTDHBHEHDyRUSgs1GCTXXPfrQ3AnY3d4C1KnLAQAYCIkDQcxDLcyhJCtc8CjcyckDAByIkwMOSYHeD8mzz82LzXwTEFyC1+RqXojFUwjeA4Ar2iycDNAtCIUWUnxom7BJFzVQicLtDskZFKijAWHUmEmJnrEanmDkBZlxA4CuBiDYV0i6hRASn4ldlWE0EEQ4nkndA0hAFkWUjHwAOJhDBcAcSMmnBjE504AyknVjTVBKGUBRBlgclYhbGLU6G8kFgjCSMuF0iihimMgzVLmXDYAKDfiOiCkkFOlO12xGIMkjGnyyOl2lHSg3V5QwH5U8JzG8LeFwGcxKwUBxTmEiMEmHWf2PSF12ygFSMcF0kUi9DKJtBoF2Rg0eIQEEDETBDOPkE3Tbl0QwH/n+NNXBO9R+L+NBGoJBMgViT9ASCROmGcxSN+P+PhNBNkVRNNVxKZXRJhKxOBNBLmBek4Bb1NVRKoHJJnCpKJNSJJKPARKxhCCqLDBRNHioHZMeOqMZMxLhNqEqDvghiiG0FZKgSMAHgOI6CONAioFBKhPYVlM4HlLGEVMRNHk3VVPVPpxxI5DxN1O5EWU1KxjpO6CpONJQFNNBN5NDERQa0b1OL71b0HkuIqiwGuMn2aJhOeJjDpWzWskcPmRCOOIl1FW5I3VBP0SBxchRJsj1K9MhywBqzH2cyGBMyZJRDiHckcGCQQEWj0WgRsJPT8MCNzGIWcNAiX1IhygzA3x2yrmQFYjrHbEbGhCMiSLAAxLSIDJRAlzrP/DkB1hKHoCgE9l6iYnUCMBoACDmJOgwEHCfx9ieJXG6AyPYTvCwAOB3JOFFNmnuxUGKEODMm2N2UrWrQcMOJNLeCoE11TGHNwHjOvLlNvJrMEhTOhw+VuO+OFnTE8g0G0ASEfKgkAoMRwFSBrE8nbKbDqSzMFL4gFzLODLzWCPzWKiXwtnFitjHEbK30nDMWjFnHnEXE+iYGnwfzUiGN7P9O0FKLFUDB7MrFX2LgSFv1302OW2zWehnDejfCXBOBIi/ykEEB3HYEPyBmP2mTP0/xVQykWhDgVjWixgjh2ifyjVmMCkXNCnUiGBEjsBRFwoTBwGaieXahCm6juz6nOEGhGgmi1gPJHig0UuRlxHdFtjDlUrwH+GwolkJkZmJlFLJnPHKVTgQE+LQKvOtNNM1xpzxkHF6EljjOpMTPfMYk/NNW/NYO+KsOLgGjOAGjqM4AABF3pBKVwmBBDaMEd8DASiCO1ChFke0+snxnNyD+1aTiKvTxsMcWShswSv8MyELYT2Eh10c+qHyWLsDrC8C9dkzic5DMzez/iiAygLDXy1T0qYB897DQL0x/KFI7JXD8hBdJt/ChyRZjLCowiQUyp5hPSqp5VUKgjQzCowAKiWw1dqjLqDqCFsKY9jKFK5ZQ465vLU91KYRNKt8FyFjsAljdR0ClwpzE1ThORmL/yAJbp3R0KZZoYOTsonyKz80uiExajuqGifyWKWo2pTzTorKpy1JQM3rK1Kx+Vo0ZpnLIroUlE+UkF9qhAkqgJmqcAXSqT5ALiHq5Brit9KJfMOAYrjjnMcrB5uDIIDqEgdZFaFSprMbBBsS2B4r+xErEJ3RNaoBtaNS4q4ITbsaBBcl8EMBRTAQYxJTYyXV1bBbTaBBbS2ABbFgjx/ahakJfajb4Jg7BgLCwAgA\">Formalization of the definition of a reductive group over a field</a></p>\n<p>It seems like there is (natural) difficulty. How does this look? Any clear problems with the way Claude approached this? Would this be fixable via better prompting or self-improvement loops?</p>",
        "id": 572156565,
        "sender_full_name": "Justin Asher",
        "timestamp": 1770300095
    },
    {
        "content": "<p>I see that it went for a stronger definition. I think that in order to build up things properly Claude would need a bit more structure from us.</p>",
        "id": 572157647,
        "sender_full_name": "Justin Asher",
        "timestamp": 1770300347
    },
    {
        "content": "<p>To that end, we should autoformalize the Stacks Project. <span aria-label=\"smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 572158571,
        "sender_full_name": "Justin Asher",
        "timestamp": 1770300582
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"653351\">Joseph Tooby-Smith</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/572128398\">said</a>:</p>\n<blockquote>\n<p>I personally am starting to care less about whether \"this result from physics (or maths) has been formalised\" - and more about \"how have you formalised this\", \"what design choices did you make\", \"what can we learn from your formalisation\", \"how has it been designed to be used by others\", \"how does it fit in with other formalisations\". These are questions I feel a sloplib would not answer.</p>\n</blockquote>\n<p>Yes, I agree with this. Recently in Iris-Lean recently there has been a person who has been speeding far ahead of the main porting effort by just asking AI to do it. Genuinely not to deride them or anything (I mean if they are really getting something out of this endeavor then godspeed) but the <a href=\"https://github.com/leanprover-community/iris-lean/pull/149\">code</a> is extremely poor. They are are starting from a full implementation in a very similar proof assistant and their code is like 10x longer. For comparison, the human written parts of Iris-Lean are approximately as complex as the Rocq version. </p>\n<p>What I find especially interesting is that this person did the AI porting process in stages, so their later PR's depend on the earlier (AI-generated) PR's. While some of the early stages look not that bad, the later ones all end up having these huge proof terms everywhere... I'm not even really sure the library is human usable in that state. It's an interesting experiment in what happens when you just let these AI's do their thing with presumably very little supervision, though I can tell you that I will be redoing this AI code myself instead of trying to fix the slop version.</p>",
        "id": 572166958,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1770302519
    },
    {
        "content": "<p>Kevin, I think there are a number of reasons that sloplib is a bad idea.</p>\n<ol>\n<li>It lacks <em>purpose</em>.</li>\n</ol>\n<p>I'm sure you've read it, but I encourage you to reread <a href=\"https://www.imo.universite-paris-saclay.fr/~patrick.massot/files/exposition/why_formalize.pdf\">Why formalize mathematics?</a>. A sloplib repo would <em>only</em> tick the first box there: checking, and even that, it could be argued, it wouldn't be doing terribly well, as mathematicians still have to vet the definitions. It doesn't satisfy the other reasons listed therein to formalize mathematics, namely:</p>\n<ul>\n<li><em>explaining and learning</em>: because digging into slop is a hindrance to both</li>\n<li><em>teaching</em>: when you get into ridiculous goal states that are nigh on impossible to read because the machine doesn't care, that's of no use in the mind of a student</li>\n<li><em>creating</em>: I'll just quote Patrick directly</li>\n</ul>\n<blockquote>\n<p>This clear thinking is part of the creation process but it can also become part of the end result.<br>\nIndeed, formalized mathematics encourage, or even sometimes require, <em>powerful abstractions.</em></p>\n</blockquote>\n<p>I think it's clear that sloplib would be doing quite that opposite of requiring or encouraging powerful abstractions.</p>\n<ul>\n<li><em>collaborating and having fun</em>: making an AI do this is the opposite of human activity.</li>\n</ul>\n<ol start=\"2\">\n<li>It's <em>costly</em>.</li>\n</ol>\n<p>You might argue that AI companies have tons of money to throw around, and, while that seems to be true for the moment, it seems like a terrible idea to make any of our progress in mathematics dependent upon such a large influx of cash. In fact, I think we should celebrate the fact that mathematics is one of the least expensive disciplines in terms of the cost society pays to fund our profession. Moreover, I'll note that I think there is no reason to encourage wasteful spending by <em>anyone</em>, not only AI companies, especially as, at least in the US, our government has thrown tremendous money at them. So, at least in part, it's a waste of my money as a taxpayer (or, perhaps, it's a waste of the money of future generations who will suffer because of our insane spending habits at the moment). Of course, you could also argue here that it's an environmental hazard, but I won't make that a key point here since it applies more generally to any extremely computationally intensive endeavor (e.g., bitcoin), and I don't think it's necessarily the key point here.</p>\n<ol start=\"3\">\n<li>It doesn't encourage <em>library design</em>.</li>\n</ol>\n<p>This is akin to the fact that it doesn't encourage powerful abstractions, but it's slightly different. When designing a library, as you well know, it's essential to do a number of things.</p>\n<ul>\n<li>choose the <em>right</em> generality: abstractions that are too general require too much glue code to be reasonably useful, and the number of lemmas true in that generality is lower. Concepts that are too narrow don't apply in enough situations and lead to code duplication or frustration when one formalization doesn't apply in another situation, even though it reasonably could do so.</li>\n<li>prioritize <em>usability</em>: writing something the <em>compiles</em> is at least an order of magnitude off from writing something that is <em>readable</em>, which is an order of magnitude off from writing something that is <em>maintainable</em>, which is an order of magnitude off from writing something that is <em>usable</em> for future endeavours.</li>\n<li>make it <em>disocverable</em> and <em>searchable</em>: arguably this is one of the weakest aspects of Mathlib as it currently stands, but we continually strive to improve this. I'll also note that this is the one place where Patrick explicitly mentioned that artificial intelligence (likely envisioned in a very different form than what we see today, given that it was last updated in 2021) may be useful to us. For me personally, I never use it for that, as Loogle generally provides me a much better searching experience.</li>\n</ul>\n<p>I'll allow myself a digression into a personal matter. A few years ago, I decided to switch the focus of my career from proving new things about operator algebras to formalizing mathematics. Why? Well it certainly wasn't because I was bored. I did it because I thought my life's work would be of more use to the profession developing (even foundational) material in my field in Lean. Of course, that's not to say I don't enjoy it, I do, but I seriously considered my motivation before embarking on it.</p>\n<ol start=\"4\">\n<li>I think it will be <em>unsuccessful</em>.</li>\n</ol>\n<p>The obvious retort to this is \"you never know until you try.\" While true in the strictest sense, I think there have been plenty of points raised upstream to doubt the likelihood of success. Moreover, given that this point is in fact less important than the aforementioned ones, I think that there's no reason to even bother.</p>\n<p>Call me a luddite if you want, but that's my two cents.</p>",
        "id": 572201424,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1770310089
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/572201424\">said</a>:</p>\n<blockquote>\n<p>A sloplib repo would <em>only</em> tick the first box there: checking, and even that, it could be argued, it wouldn't be doing terribly well, as mathematicians still have to vet the definitions.</p>\n</blockquote>\n<p>My two cents:</p>\n<ul>\n<li>Even if it is only the first box, it is a very important box! Just knowing that something is true can be a huge deal.</li>\n<li>Mathematicians wouldn't have to vet the definitions if, as I keep suggesting, creating public definitions was banned (only adding more theorems about Mathlib definitions would be in the scope of the library).</li>\n</ul>",
        "id": 572210027,
        "sender_full_name": "Martin Dvo≈ô√°k",
        "timestamp": 1770312346
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvo≈ô√°k</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/572210027\">said</a>:</p>\n<blockquote>\n<ul>\n<li>Mathematicians wouldn't have to vet the definitions if, as I keep suggesting, creating public definitions was banned (only adding more theorems about Mathlib definitions would be in the scope of the library).</li>\n</ul>\n</blockquote>\n<p>You can't get too far with that.</p>",
        "id": 572210407,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1770312452
    },
    {
        "content": "<p>Also Kevin is explicitly talking about definitions.</p>",
        "id": 572210488,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770312477
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/572210407\">said</a>:</p>\n<blockquote>\n<p>You can't get too far with that.</p>\n</blockquote>\n<p>True, but it would still give me a library that I could import and obtain <code>exact?</code> on steroids.</p>",
        "id": 572210686,
        "sender_full_name": "Martin Dvo≈ô√°k",
        "timestamp": 1770312534
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/572201424\">said</a>:</p>\n<blockquote>\n<ol start=\"2\">\n<li>It's <em>costly</em>.</li>\n</ol>\n</blockquote>\n<p>I think these things are relatively cheap to run. I am not sure where this is coming from. Much cheaper than the cost of formalizing things by hand.</p>",
        "id": 572218764,
        "sender_full_name": "Justin Asher",
        "timestamp": 1770315144
    },
    {
        "content": "<p>I'm definitely not calling you a luddite Jireh! As I say, I completely expected to be shot down; I asked because I wanted to get my head straight about this matter. I think you (as ever) have written down some very coherent thoughts!</p>\n<p>I think that my question has morphed into the following two questions:</p>\n<p>1) What if we <em>only</em> wanted a AI tool which could check that papers were correct, forget all the other visions of mathlib. Would a sloplib approach work here? At what point should be drop what we're doing and race to the AI tool? Do we really need to make the O(1000) missing definitions in mathlib first?</p>\n<p>Perhaps a reasonable comment here is that even for a paper where all the concepts are in mathlib already, current AI tools are probably not able to check it, so we could wait for this problem to be solved first (by people like Math Inc) and by that point maybe we'll have all the missing definitions I'm fretting about.</p>\n<p>2) Michael's comment made me realise that I know full well one of the problems here -- some definitions are hard. I think this is worth splitting out into a new thread; independent of the discussion here one could ask if AI tools could make definitions and I think we have a couple of interesting candidates.</p>",
        "id": 572224048,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1770316848
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/572224048\">said</a>:</p>\n<blockquote>\n<p>independent of the discussion here one could ask if AI tools could make definitions and I think we have a couple of interesting candidates.</p>\n</blockquote>\n<p>Yes, we should do this. This is very important.</p>",
        "id": 572225307,
        "sender_full_name": "Justin Asher",
        "timestamp": 1770317283
    },
    {
        "content": "<p>I actually think \"an AI tool which could check that papers were correct\" would actually drive <em>more</em> interest among mathematicians towards the kind of standards for Lean code that mathlib aspires towards. Mathematicians prioritise beauty and elegance, and if the default way of doing mathematics becomes \"produce some Lean code to show you are correct\" then I think mathematicians will actually want to produce beautiful and elegant Lean code for their theorems rather than have their work turned into AI-slop Lean code. But this is just my personal feeling and different people will certainly have different thoughts. (Also, note this is orthogonal to the question of whether AI can eventually produce 'mathlib-standard' Lean code, which is always a possibility.)</p>",
        "id": 572226342,
        "sender_full_name": "Bryan Wang",
        "timestamp": 1770317626
    },
    {
        "content": "<p>Here is the discussion for AI Lean definitions:</p>\n<p><a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/channel/113488-general/topic/AI.20Lean.20definitions/with/572226311\">#general &gt; AI Lean definitions</a></p>",
        "id": 572226438,
        "sender_full_name": "Justin Asher",
        "timestamp": 1770317666
    },
    {
        "content": "<p>I agree with most of the critics here, I don't think this is a good way to develop a large new library of formalized mathematics. However, I'm all in favor of small-scale experiments.</p>\n<p>Imagine that Aristotle (or another AI tool) just has an option/button to PR successful results to <a href=\"https://github.com/merely-true/merely-true\">merely-true</a>. Hardly any extra compute will be spent, and we get some public AI proofs. </p>\n<p>I expect that CI will be quite cheap: even though every file might be slow to compile, I expect that most contributions just add 1 (or a few) new files, not touching existing files, and that the import hierarchy will be almost completely flat. Therefore, besides bumping Mathlib, compute is just checking the results added by only that PR. And there will be no linting.</p>\n<p>I also want to highlight the most genius rule from the <code>merely-true</code> repository:</p>\n<blockquote>\n<p>Each time Mathlib moves to a new Lean toolchain, we will [...] <em>delete all files which no longer compile!</em></p>\n</blockquote>\n<p>I think this is actually very interesting:</p>\n<ul>\n<li>Most AI-generated files using existing capabilities will be removed: they are not at all robust, and will fail compilation on every Mathlib bump</li>\n<li>Maybe some kind of AI proof is more robust, or maybe some AI tool is able to write more robust proofs, and perhaps we can learn something from that</li>\n<li>Maybe someone will develop a fix-errors-after-bumping-mathlib-tool, which could be useful elsewhere!</li>\n<li>Maybe someone will write a cleanup-AI-proofs-tool, which could also be very useful. </li>\n<li>A repository like this could give these AI tools a benchmark: fixing deleted proofs, cleaning up existing or deleted proofs.</li>\n<li>Or very possibly someone will just write something reprompts an AI tool to formalize deleted results from scratch, which would be less useful.</li>\n</ul>",
        "id": 572227862,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1770318046
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/572224048\">said</a>:</p>\n<blockquote>\n<p>1) What if we <em>only</em> wanted a AI tool which could check that papers were correct, forget all the other visions of mathlib. Would a sloplib approach work here?</p>\n</blockquote>\n<p>I imagine that we'd get a bunch of files worth of (purported) lean code, but with many hours of human effort required to suss out whether the lean matches the paper closely enough to be useful</p>",
        "id": 572230702,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1770318996
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"653351\">Joseph Tooby-Smith</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/572128398\">said</a>:</p>\n<blockquote>\n<p>I personally am starting to care less about whether \"this result from physics (or maths) has been formalised\" - and more about \"how have you formalised this\", \"what design choices did you make\", \"what can we learn from your formalisation\", \"how has it been designed to be used by others\", \"how does it fit in with other formalisations\". These are questions I feel a sloplib would not answer.</p>\n</blockquote>\n<p>This fits in with my views of the 100-theorems and 1000-plus lists: (a) they should be more nuanced in the information they present rather than mainly presenting things as a binary formalized/not-formalized, and (b) there should be a very clear division between \"formalized in an integrated and reusable way (in mathlib, or failing that the mathlib archive)\" - which implies the underlying theory / lemmas are available for reuse, and indeed such lemmas may well be of more use than the final result - and \"may or may not be formalized, but not in mathlib / the mathlib archive\".</p>\n<p>(This is not to say that's the <em>only</em> information to present in those lists. The existence of a lower-quality formalization may well be useful information to people interested in the result, even if they have the completely reimplement it to get something reusable for their purposes. Where unlisted formalizations exist, they ought to be mentioned on those lists in some form, just clearly distinguished from fully integrated and reusable ones.)</p>",
        "id": 572271685,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1770336647
    },
    {
        "content": "<p>There's been discussion about technical concerns, but I'm worried about messaging: What message does this send about Lean and formalization to the broader mathematical community?</p>\n<p>One of my concerns is that using a repository of AI generated theorems that are unreadable to humans will push people away from wanting to learn about formalization efforts. Imagine if someone's first impression of Lean was a block of code that they cannot read and no one can explain to them. There is nothing for that person to engage with and I think you'll have a hard time convincing them of the value of formalization.</p>\n<p>Another issue is that using that kind of work is implicitly saying that \"correct\" is the same as \"compiles in Lean\". My problem here is not with Lean, but that the concept of \"correct\" in mathematics is a community based definition. What I mean is that we don't call a theorem proved or a problem solved when one person believes they have a proof - they need to convince the mathematical community that it is true. For this reason, I think the answer to </p>\n<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/572224048\">said</a>:</p>\n<blockquote>\n<p>1) What if we <em>only</em> wanted a AI tool which could check that papers were correct, forget all the other visions of mathlib. Would a sloplib approach work here?</p>\n</blockquote>\n<p>is no, regardless of the ability to generate a proof. For example, what happens when the AI generates an incomprehensible proof that says that a paper is incorrect? You may believe the generated proof, but will the author? I'd argue that proof irrelevance is a technical concept and not a mathematical one, because in practice we very much do care about the quality of a proof and being able to read it, because that is exactly how we can learn from it and use it.</p>",
        "id": 572319503,
        "sender_full_name": "Daniel Morrison",
        "timestamp": 1770367057
    },
    {
        "content": "<p>And the same problem exists even when the computer verifies that a theorem is correct: proving that a theorem is true doesn't imply that the proof provided in the paper is correct.</p>",
        "id": 572320314,
        "sender_full_name": "Gregory Wickham",
        "timestamp": 1770367318
    },
    {
        "content": "<blockquote>\n<p>For example, what happens when the AI generates an incomprehensible proof that says that a paper is incorrect? You may believe the generated proof, but will the author?</p>\n</blockquote>\n<p>What happens when the paper is also incomprehensible, and the author insists nobody understands because they are \"profoundly ignorant\"? <span aria-label=\"smirk\" class=\"emoji emoji-1f60f\" role=\"img\" title=\"smirk\">:smirk:</span></p>",
        "id": 572338322,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1770372905
    },
    {
        "content": "<p>Just two comments to add on the many:</p>\n<ul>\n<li>One risk is that sloplib would become like facebook of lean, a place where people drop anything and where we all end up wasting a lot of time out of curiosity; time which would be more profitably spent elsewhere. Without an ultimate goal/standard I fear none will have necessary friction and the incentive to sculpt their formalizations until they fulfill the minimal requirements of meaningfulness outlined by <span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> .</li>\n<li>While obvioous, I think the optimal approach to accelerate formalisation (if I understood correctly the main practical problem which motivates this discussion) would be to channel the same funds that would be apparently ready for purely agentic systems, into many more (synchronized) well thought projects run by motivated humans, which leverage AI but in a principled way; but this doesn't seem aligned with the current marketing of most AI companies which seem to depict agents as replacements rather than extensions/power-up.</li>\n</ul>",
        "id": 572357078,
        "sender_full_name": "Matteo Cipollina",
        "timestamp": 1770378731
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvo≈ô√°k</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/572210027\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/572201424\">said</a>:</p>\n<blockquote>\n<p>A sloplib repo would <em>only</em> tick the first box there: checking, and even that, it could be argued, it wouldn't be doing terribly well, as mathematicians still have to vet the definitions.</p>\n</blockquote>\n<p>My two cents:</p>\n<ul>\n<li>Even if it is only the first box, it is a very important box! Just knowing that something is true can be a huge deal.</li>\n</ul>\n</blockquote>\n<p>I second here, the first box is already a huge deal.</p>\n<p>I had a number of coffee talks over the last few weeks where I was pitching an optimistic view \"In a decade, at TCS conference we will mandate a Lean proof along the submission. People will generate such a proof automatically from a sufficiently detailed written manuscript in natural language.\" People were generally super excited about it. This would unclog the current reviewing system in TCS, which is way overloaded. In particular, it will solve the problem of 50-pages hastily written appendix proof that looks ok-ish, but nobody will verify it in the time frame of reviewing for top TCS conferences.</p>",
        "id": 572364301,
        "sender_full_name": "Marcin Pilipczuk",
        "timestamp": 1770381001
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"972923\">Marcin Pilipczuk</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/572364301\">said</a>:</p>\n<blockquote>\n<p>... \"In a decade, at TCS conference we will mandate a Lean proof along the submission. People will generate such a proof automatically from a sufficiently detailed written manuscript in natural language.\" People were generally super excited about it. This would unclog the current reviewing system in TCS, which is way overloaded...</p>\n</blockquote>\n<p>But are you sure the consequence of this is not going to be that instead of been able to get an expert in area A to review the review a paper on A, you instead need someone who is an expert on A <strong>and in Lean</strong> to check that the autoformalization does what it says it does and as someone above (sorry I can't find the message) said make sure the proof matches that in the paper? It seems to me this will limit the pool of potential reviewers</p>",
        "id": 572371741,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1770383194
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"972923\">@Marcin Pilipczuk</span> : This is something I have thought about as well. I have reviewed for a lot of distributed algorithms conferences. My feeling is that a large part of the mess comes from us repeating ourselves in these papers and definitions being ever so slightly inconsistent across papers. In our field, we should definitely not create a jungle of formalisations. We need to unify the field under definitions that we all agree on and make it clear where differences lie.</p>",
        "id": 572376260,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770384582
    },
    {
        "content": "<p>One reason (among others) that some of us started distributed graph algorithms formalisation is that some of us discovered that when people are talking about \"the XYZ model\" there are actually a dozen different XYZs which are different in relevant ways.</p>",
        "id": 572376524,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770384660
    },
    {
        "content": "<p>We already on the path to Github become sloplib <a href=\"https://newsletter.semianalysis.com/p/claude-code-is-the-inflection-point\">https://newsletter.semianalysis.com/p/claude-code-is-the-inflection-point</a> and this doesn't count the people who want to hide AI authorship.</p>",
        "id": 572377190,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1770384843
    },
    {
        "content": "<p>disclaimer: I tried to read the whole thread, but I may have missed key relevant posts, I am sorry if I didn't acknowledge you for making similar points!</p>\n<p>I have spent the past couple of months investing serious deliberate practice into perfecting a claude code/lean workflow. I think I have it pretty much dialled in. On a good day I get 2K LOC lean code (with a single claude max subscription). Is it good quality? I confess I don't feel qualified to judge. </p>\n<p>I have multiple motivations: So far I have been using lean to formalise LLM-generated physics/math questions because I just don't trust LLMs. For various reasons I have been formalising operator algebras (GNS theorem etc.), Jordan algebras and tensor categories.</p>\n<p>I never considered submitting PRs to mathlib. Instead I have been collecting my various experiments in my own monorepo: It is completely clear to me that it would be indecent to inflict my growing codebase on human reviewers. The numbers don't add up.</p>\n<p>I guess, if LLM-assisted code gen takes off (and there are reasons to think frontier AI labs might be interested in doing this), we will simply witness a cambrian explosion of repos like mine.</p>\n<p>But that is ok, right? I guess the way I have been thinking of mathlib as analogous to the linux kernel: a massive coordinated and carefully curated effort to create a robust infrastructure that lays the foundation for vast numbers of creations built on top. Does that resonate?</p>\n<p>[EDIT: BTW you guys are <em>amazing</em>! Mathlib is an extraordinary awesome creation!]</p>",
        "id": 572389013,
        "sender_full_name": "Tobias J. Osborne",
        "timestamp": 1770387726
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/572376260\">said</a>:</p>\n<blockquote>\n<p>In our field, we should definitely not create a jungle of formalisations. We need to unify the field under definitions that we all agree on and make it clear where differences lie.</p>\n</blockquote>\n<p>This problem is not unique to CS, but I think it is a bit more pronounced because to an extent we are more inclined to fundamentally want to compare different formalizations that do not always have an easily recognizable or ergonomic abstraction. Doing formalization abstracted over something as fundamental as binding for instance (as in <a href=\"https://github.com/dunnl/tealeaves\">Tealeaves</a>) is in the realm of active research.</p>",
        "id": 572389138,
        "sender_full_name": "Chris Henson",
        "timestamp": 1770387754
    },
    {
        "content": "<p>LOC are a very bad measure of quality here</p>",
        "id": 572391518,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1770388310
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"1024525\">Tobias J. Osborne</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/572389013\">said</a>:</p>\n<blockquote>\n<p>I guess the way I have been thinking of mathlib as analogous to the linux kernel: a massive coordinated and carefully curated effort to create a robust infrastructure that lays the foundation for vast numbers of creations built on top. Does that resonate?</p>\n</blockquote>\n<p>Idk, I think there's a fundamental difference.</p>\n<p>An OS kernel tries to solve a known set of well-defined problems. If one's able to use their hardware appropriately, that's pretty much it.</p>\n<p>Mathematics, at least to me, is more like an open world with no clearly specified finality. So we'd like it to build up (indefinitely?). But two different definitions of <code>Nat</code> won't ever match in Lean, so the build up goal can't be achieved if definitions branch off, even if isomorphically and functionally equivalent.</p>",
        "id": 572394699,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1770389144
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"451983\">Arthur Paulino</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/572394699\">said</a>:</p>\n<blockquote>\n<p>Mathematics, at least to me, is more like an open world with no clearly specified finality. So we'd like it to build up (indefinitely?). But two different definitions of <code>Nat</code> won't ever match in Lean, so the build up goal can't be achieved if definitions branch off, even if isomorphically and functionally equivalent.</p>\n</blockquote>\n<p>many thanks for your comment! I am trying to orient myself and activities hopefully in a way that aligns with the mission and vision of lean community. (I certainly don't want to become a bad actor!) If I understand it correctly, the proliferation of individual repos each building their own little incompatible versions of mathlib would be counterproductive? I do take your point. How would you advise that I, and similar persons (I know of several well-known physicists mathematicians doing similar things as me), should proceed? I have been leaving my repos as open so far. I am genuinely unsure.</p>",
        "id": 572397325,
        "sender_full_name": "Tobias J. Osborne",
        "timestamp": 1770389781
    },
    {
        "content": "<blockquote>\n<p>An OS kernel tries to solve a known set of well-defined problems. If one's able to use their hardware appropriately, that's pretty much it.</p>\n</blockquote>\n<p>Saying that \"using the hardware appropriately\" is well defined when all mainstream kernels have random <code>sleep</code>s in their NIC drivers because nobody actually understands why the hardware does things is a bit of a stretch I think :P</p>",
        "id": 572397585,
        "sender_full_name": "Henrik B√∂ving",
        "timestamp": 1770389840
    },
    {
        "content": "<p>As I like to joke, any day where Lean lets me forget that hardware actually physically exists is a success. Godspeed to those doing hardware verification <span aria-label=\"saluting face\" class=\"emoji emoji-1fae1\" role=\"img\" title=\"saluting face\">:saluting_face:</span></p>",
        "id": 572398877,
        "sender_full_name": "Chris Henson",
        "timestamp": 1770390145
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik B√∂ving</span> I said that the goal is clear, not that the solution is already here <span aria-label=\"joy cat\" class=\"emoji emoji-1f639\" role=\"img\" title=\"joy cat\">:joy_cat:</span></p>\n<p>Also, whether or not drivers are considered as part of the \"kernel\" depends on the architecture as well as on the definition of \"kernel\" itself. But that's a whole other topic!</p>\n<p><span class=\"user-mention\" data-user-id=\"1024525\">@Tobias J. Osborne</span> no need to interrupt your learning journey! Lean is a free and open source system. You're not obliged, in any sense, to use it in order to build up a common math lib.</p>\n<p>It's <span aria-label=\"100\" class=\"emoji emoji-1f4af\" role=\"img\" title=\"100\">:100:</span> okay to spin up isolated repos, as long as you're not expecting your work to be integrated in a ecosystem without extra effort (i.e. rewriting theorems in terms of other definitions).</p>\n<p>Note: I don't speak for the community! I speak as a simple individual user of Lean</p>",
        "id": 572401002,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1770390640
    },
    {
        "content": "<p>I think that trying to answer the question ‚Äúwould <code>sloplib</code> work‚Äù is too easy, and instead we should be trying to answer the question ‚Äúwould <code>sloplib</code> work, and if not, what would?‚Äù. It seems clear that AI has much to offer mathematics and formalisation. The AI crowd know this but they don‚Äôt really know what to offer us, and it‚Äôs up to us to ask. Two obvious tools are</p>\n<ol>\n<li>A <em>fast</em>, <em>powerful</em> hammer tactic </li>\n<li>A reliable autoformaliser</li>\n</ol>\n<p>What else could we request? What other experiments could we run? If <code>sloplib</code> is not the right experiment what would be?</p>\n<p>Over the last few years, time and time again AI has shown itself more capable than many assumed. Probably already today there are ways it can help us that we don‚Äôt know about. If <code>sloplib</code> is not the right experiment to run to try to figure these out, what is?</p>",
        "id": 572550907,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1770483757
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/571882431\">said</a>:</p>\n<blockquote>\n<p>Basically my impression is that lots of people think that this is a bad idea but I am realising that I don't have a coherent argument as to why. I am well aware that mathlib has an extremely high bar for code review but I am unclear as to how important this fact has been in mathlib's success and, more importantly, how important it will remain going forwards.</p>\n</blockquote>\n<p>My position here is quite similar to <span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> 's but mostly adressing the question \"is there a <em>risk</em>, and if yes which one, in <code>sloplib</code>?\". I belive that the very high risk is to lose common knowledge on how to build a library of formalised mathematics (so, I'm not speaking about <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> 's point that by formalising one learns better mathematics, although I certainly share his point: I'm really thinking on learning how to formalise it). This common knowledge is \"a thing\"  that it is very hard to value, because it is shared, spread at different levels in different places, and certainly non quantifiable. But I would argue that it is one of the strongest assest of Mathlib, even beyond the 2M LOC or the great theorems we have here; and extremely fragile at the same time, because here we all took the same path that was climbing the steep ladder of getting to know Mathlib and learning a great deal from the endevour. The advantage of the high bar we have is that we're creating, albeit indirectly and not as our primary focus, a <em>school</em> on how to formalise mathematics, and this would be endangered by <code>sloplib</code>. The big problem is that once the school is gone, and with it the milion of small seeds of knowledge that are spread in hundreds of users, it will be very hard to come back because there won't be a \"steep ladder\" to climb any more.</p>",
        "id": 572563804,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1770494654
    },
    {
        "content": "<p>I think a \"clean-up AI\" would be really valuable. Getting a PR of mine from \"code is sorry-free\" to \"ready for a PR\" is a substantial amount of work, which is often a useful exercise (think about good abstractions/intermediate lemmas, etc.) and at the same time more tedium than perhaps necessary. Getting help with that (and be it \"move this single lemma to the right place\"; \"now repeat with that lemma\") would be beneficial.</p>",
        "id": 572568364,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1770499751
    },
    {
        "content": "<p>I‚Äôm sorry I‚Äôm very late to the party, I was traveling, advertising Lean and then catching up with administration. I think all this discussion about feasibility of sloplib is completely missing the point. I don‚Äôt mind assuming, for the sake of discussion, that one day AI could become capable of writing a better Mathlib than what humans can do. Let us even assume (this is really becoming pure science fiction for the sake of a philosophical discussion) that it can do that without destroying our planet and funding fascist states. Then we‚Äôre talking about an horrifying dystopia, and I think we should stop and think about why we‚Äôre doing that. Here I‚Äôm not talking about software verification or any other real world use of Lean. I‚Äôm talking about utterly useless fundamental mathematics such as the Langlands program or symplectic topology. Why are we doing that? We‚Äôre doing that because it gives immense intellectual pleasure to human beings to slowly understand those areas and communicate their understanding to other human beings, and participate in building something that is so much bigger than any individual mathematician and does not harm anybody. Formalization of those areas of mathematics is simply a new added direction in that story. It adds more ways to enjoy this pleasure. One can argue endlessly about how much new understanding we get. But I think the impact on the feeling of building something together is really undeniable. And I conjecture it‚Äôs the main motivation of all mathematicians here who converted a lot of their research time from traditional math to formalized math. Mathlib is the first project where I feel I have 650 collaborators, beating my previous highscore by a factor of 200. And it allowed me to have meaningful mathematical discussions with experts such as Kevin or Johan who are very far away from my corner of maths. Can anyone tell why I should dream of having AI destroy all that? Do we want to live our mathematical life in <a href=\"https://assets.newsie.social/media_attachments/files/116/013/035/609/022/920/original/f04277ee5ca87e06.jpg\">https://assets.newsie.social/media_attachments/files/116/013/035/609/022/920/original/f04277ee5ca87e06.jpg</a> (drawing by Tjeerd Royaards).</p>\n<div class=\"message_inline_image\"><a href=\"https://assets.newsie.social/media_attachments/files/116/013/035/609/022/920/original/f04277ee5ca87e06.jpg\"><img src=\"https://uploads.zulipusercontent.net/c534d47b94e87bd311b54582801fbee222daffe5/68747470733a2f2f6173736574732e6e65777369652e736f6369616c2f6d656469615f6174746163686d656e74732f66696c65732f3131362f3031332f3033352f3630392f3032322f3932302f6f726967696e616c2f663034323737656535636138376530362e6a7067\"></a></div>",
        "id": 572653959,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1770588091
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/572653959\">said</a>:</p>\n<blockquote>\n<p>Here I‚Äôm not talking about software verification or any other real world use of Lean. I‚Äôm talking about utterly useless fundamental mathematics...</p>\n</blockquote>\n<p>Even though I work primarily on CSLib, count me entirely in this camp. Earlier today we had some discussion about the AI porting of fundamental CS from other proof assistants. I think some might question for instance my recent Lean Together talk on formalizing lambda calculi as something that was done 20 years ago in other proof assistants and could be done with AI much faster than I have progressed. But completely in line with what Patrick says, this completely misses the point. Even if AI could <em>idiomatically</em> match such porting (and I am very doubtful...) it completely misses that formalization is just as much a social and personal intellectual activity, and understanding is something that fundamentally cannot be automated. When I first ran into Lean 3, I loved it so much that I eventually quit my (much better paying!) finance job to do a PhD and have loved the experience that Lean has provided me in interacting with this community. I think that that even if AI managed to produce some mangled version of the work I've done in CSLib the last few months, it would not be able to explore this space of what Lean has to offer formal metatheory with the same nuance or grant the understanding that careful study of fundamental material has provided me, and it certainly couldn't automate these years of my life.</p>",
        "id": 572655985,
        "sender_full_name": "Chris Henson",
        "timestamp": 1770590554
    },
    {
        "content": "<p>On the contrary to <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> , I am often sad to see such an anti-AI sentiment. We have super-human chess engines for over than 25 years. Did chess stop being human intellectual endeavor that players find fulfilling? Did it stop people from studying chess and socializing around it?</p>\n<p>One of the ways I futuristically promote Lean is as follows</p>\n<blockquote>\n<p>AI is getting better in understanding programming languages. It is quite plausible that in the future, it will be able to reason and code better than people, so standard math papers and programming languages become obsolete. We will need a rich precise language so that we can \"talk\" with it. To understand its results, and to have guarantees about what it is doing. Lean has the potential to become such language.</p>\n</blockquote>\n<p>If we get to such point (and yes, it is sci-fi for now. For me, AI solving IMO was sci-fi 5 years ago), anyone who works on Lean now could feel satisfaction in the future of having their part of contribution to the ultimate AI system that can eventually encompass mathematics, programming, and natural sciences. I understand I cannot force someone to stop worrying about the future but I think a positive vision should be also heard.</p>",
        "id": 572660752,
        "sender_full_name": "Mirek Ol≈°√°k",
        "timestamp": 1770595746
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek Ol≈°√°k</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/572660752\">said</a>:</p>\n<blockquote>\n<p>Did chess stop being human intellectual endeavor that players find fulfilling? Did it stop people from studying chess and socializing around it?</p>\n</blockquote>\n<p>For a game, if bots play better than me I can choose not to play against them and have fun playing against humans.</p>\n<p>For an endeavor that has clear goals that can be completed, if a bot comes around and completes it better than I can I'm not going to say \"okay let's uncheck the checkbox to let me enjoy completing it myself\".</p>\n<p>(and the fact that the amount of goals is potentially endless doesn't solve the issue)<br>\n(btw I don't necessarily identify with Patrick's sentiment, but I disagree with the chess analogy)</p>",
        "id": 572661462,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1770596567
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek Ol≈°√°k</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/572660752\">said</a>:</p>\n<blockquote>\n<p>On the contrary to <span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> , I am often sad to see such an anti-AI sentiment. We have super-human chess engines for over than 25 years. Did chess stop being human intellectual endeavor that players find fulfilling? Did it stop people from studying chess and socializing around it?</p>\n<p>One of the ways I futuristically promote Lean is as follows</p>\n<blockquote>\n<p>AI is getting better in understanding programming languages. It is quite plausible that in the future, it will be able to reason and code better than people, so standard math papers and programming languages become obsolete. We will need a rich precise language so that we can \"talk\" with it. To understand its results, and to have guarantees about what it is doing. Lean has the potential to become such language.</p>\n</blockquote>\n<p>If we get to such point (and yes, it is sci-fi for now. For me, AI solving IMO was sci-fi 5 years ago), anyone who works on Lean now could feel satisfaction in the future of having their part of contribution to the ultimate AI system that can eventually encompass mathematics, programming, and natural sciences. I understand I cannot force someone to stop worry about the future but I think a positive vision should be also heard.</p>\n</blockquote>\n<p>Chess is explicitly funded as a sport i.e. as a form of entertainment with the full understanding that it is socially beneficial, but there are no immediate returns. Sciences are funded by public institutions with expectations of returns</p>",
        "id": 572663235,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770598271
    },
    {
        "content": "<p>So this comparison is pointless</p>",
        "id": 572663246,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770598278
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/572663235\">said</a>:</p>\n<blockquote>\n<p>Chess is explicitly funded as a sport i.e. as a form of entertainment with the full understanding that it is socially beneficial, but there are no immediate returns. Sciences are funded by public institutions with expectations of returns</p>\n</blockquote>\n<p>I am sorry but this feels like some inconsistency here. On one hand, you are saying that there are expectations of returns, on the other hand, Patrick was talking about \"useless math\". So choose one.</p>\n<ul>\n<li>(a) You do it because you think it can be eventually good for something. Then we should be glad if AI brings more of this good to the society.</li>\n<li>(b) You do it because you enjoy it, as a form of game, or art. Then the analogy with chess is appropriate.</li>\n</ul>",
        "id": 572663570,
        "sender_full_name": "Mirek Ol≈°√°k",
        "timestamp": 1770598611
    },
    {
        "content": "<p>It is not inconsistent if you understand that different institutions and people have different reasons for valuing an activity, and those who hold the purse strings often have to be pleased and satisfied w.r.t their reasons.</p>",
        "id": 572663613,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770598666
    },
    {
        "content": "<p>If you want more success with promoting AI, you need to address the social problems of our current setup of funding intellectual activity <strong>first</strong> . Secondly, at a technicaly level, AI needs to automate basic tasks like farming, mining, transportation, laundry, and dishwashing. What's that saying \"I want AI to do my dishes and my laundry...\". Making breathtaking claims about how AI is going to solve a fun and intellectual task is not going to win you accolades</p>",
        "id": 572664055,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770598972
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/572664055\">said</a>:</p>\n<blockquote>\n<p>If you want more success with promoting AI</p>\n</blockquote>\n<p>I don't need success with promoting AI -- AI future is now rather an undeniable reality. Just a single sample point, vast majority of students of computer science here in Czechia has chosen AI as their specialization.</p>\n<p>I am rather promoting Lean as something that fits into the AI future <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 572665277,
        "sender_full_name": "Mirek Ol≈°√°k",
        "timestamp": 1770600039
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek Ol≈°√°k</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/572663570\">said</a>:</p>\n<blockquote>\n<ul>\n<li>(a) You do it because you think it can be eventually good for something. Then we should be glad if AI brings more of this good to the society.</li>\n<li>(b) You do it because you enjoy it, as a form of game, or art. Then the analogy with chess is appropriate.</li>\n</ul>\n</blockquote>\n<p>I can imagine some potential nuance about these points:</p>\n<ul>\n<li>Mathematics has a complex state of affairs regarding the interplay of theory and application. These are not clearly delineated cases where you can conclude that producing more of a good to society through applications can be separated from areas where AI involvement may be questioned.</li>\n<li>Humans made the decision to continue playing chess, with use of chess engines relegated to very specific roles as supplemental tools. In formal mathematics there are similarly a variety of modes of use for AI that need to be individually compared to make a proper comparison. The exact methods and the changing nature of AI is an important consideration in forming a analogy here.</li>\n</ul>",
        "id": 572665518,
        "sender_full_name": "Chris Henson",
        "timestamp": 1770600283
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek Ol≈°√°k</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/572663570\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/572663235\">said</a>:</p>\n<blockquote>\n<p>Chess is explicitly funded as a sport i.e. as a form of entertainment with the full understanding that it is socially beneficial, but there are no immediate returns. Sciences are funded by public institutions with expectations of returns</p>\n</blockquote>\n<p>I am sorry but this feels like some inconsistency here. On one hand, you are saying that there are expectations of returns, on the other hand, Patrick was talking about \"useless math\". So choose one.</p>\n<ul>\n<li>(a) You do it because you think it can be eventually good for something. Then we should be glad if AI brings more of this good to the society.</li>\n<li>(b) You do it because you enjoy it, as a form of game, or art. Then the analogy with chess is appropriate.</li>\n</ul>\n</blockquote>\n<p>There are more gamified elements of math , math competitions are plenty, and you can talk more about an analogy to chess there. Math research , this analogy breaks down I think even if a similarity is  ‚Äúpeople do it for enjoyment‚Äù . </p>\n<p>‚ÄúUseless‚Äù math is a misnomer , it‚Äôs just a way to say it‚Äôs hard to find direct application that leads to returns in the current framework. It is very hard to delineate as theoretical math has been a source of many discoveries seemingly useless at the time and finding rich applications later. In fact AI likely wouldn‚Äôt exist in its state now without such endeavours a long time ago.  So it‚Äôs more like ‚Äúcapitalistic/societal applications pending‚Äù math ( assuming we are talking about math of some depth and novelty ).</p>\n<p>I think it may be off topic but I‚Äôd be curious as to what the students that pick AI as their specialisation would actually end up doing day to day at work after graduating , under the premise AI is so good it can do Mathlib and math/coding better than humans?</p>",
        "id": 572681550,
        "sender_full_name": "Yan Yablonovskiy üá∫üá¶",
        "timestamp": 1770613607
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/572227862\">said</a>:</p>\n<blockquote>\n<p>I also want to highlight the most genius rule from the <code>merely-true</code> repository:</p>\n<blockquote>\n<p>Each time Mathlib moves to a new Lean toolchain, we will [...] <em>delete all files which no longer compile!</em></p>\n</blockquote>\n<p>I think this is actually very interesting:</p>\n<ul>\n<li>Most AI-generated files using existing capabilities will be removed: they are not at all robust, and will fail compilation on every Mathlib bump</li>\n</ul>\n</blockquote>\n<p>You have missed the possibility of cryptographically certified proofs tied to specific compiler+mathlib versions. Or would you argue that a proof loses its validity just because the mathlib version changed?</p>\n<p>First attempts to implement it:</p>\n<ul>\n<li><a href=\"https://github.com/argumentcomputer/ix\">https://github.com/argumentcomputer/ix</a></li>\n<li><a href=\"https://doi.org/10.13140/RG.2.2.35512.81920\">https://doi.org/10.13140/RG.2.2.35512.81920</a></li>\n</ul>",
        "id": 572704832,
        "sender_full_name": "Ralf Stephan",
        "timestamp": 1770625398
    },
    {
        "content": "<p>(message redacted by author)</p>",
        "id": 573063467,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1770735063
    },
    {
        "content": "<p>I (and perhaps others) have expressed elsewhere on this zulip that as soon as one is able to fully automate pure mathematics, by which I mean maths that has no immediate applications in the foreseeable future, <em>a lot of that 'cultural prestige' will be lost instantly</em> (edit: referring to the previous message which is now removed). So while I agree that such endeavours may be scientifically interesting in their own right, I personally struggle to see any long-term sustainability down this path of automating pure mathematics, and one has to be clear about what our long-term goals are (compared to, say, the long-term goals of AI companies). I would very, very much love to be proven wrong however. </p>\n<p>Maybe the next step is to create AI that can find real-world applications of previously useless mathematics, but I think this is even more far-fetched than what anyone is discussing right now.</p>",
        "id": 573076181,
        "sender_full_name": "Bryan Wang",
        "timestamp": 1770737965
    },
    {
        "content": "<p>(message redacted by author)</p>",
        "id": 573145203,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1770755895
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"934803\">Bryan Wang</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/573076181\">said</a>:</p>\n<blockquote>\n<p>I (and perhaps others) have expressed elsewhere on this zulip that as soon as one is able to fully automate pure mathematics, by which I mean maths that has no immediate applications in the foreseeable future, <em>a lot of that 'cultural prestige' will be lost instantly</em> (edit: referring to the previous message which is now removed). So while I agree that such endeavours may be scientifically interesting in their own right, I personally struggle to see any long-term sustainability down this path of automating pure mathematics, and one has to be clear about what our long-term goals are (compared to, say, the long-term goals of AI companies). I would very, very much love to be proven wrong however. </p>\n<p>Maybe the next step is to create AI that can find real-world applications of previously useless mathematics, but I think this is even more far-fetched than what anyone is discussing right now.</p>\n</blockquote>\n<p>Since this was raised here let me make a bold conjecture about what can happen: a lot of scientific/engineering problems which are mathematical in nature are instead approached using numerics, simulations, heuristics etc because the mathematics is too hard. If AI+Lean increases the power of mathematics then theorems can replace simulations in many domains, and theorems have many advantages.</p>",
        "id": 573507119,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1770899271
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"266304\">@Siddhartha Gadgil</span> you know PDEs far better than me but I think you would agree that most  non linear PDEs that engineers use don‚Äôt have closed form solutions. So they turn to linearisation or simulations.  I‚Äôll give you an example. There is this numerical tool called spice. It takes in transistor models and simulates entire circuits in analog. Each transistor has 3-digit numbers of parameters. A circuit may have hundreds or even thousand of such transistors working in concert. If we could ‚Äúprove‚Äù or ‚Äúdeduce‚Äù even a power series solution (let alone closed form) for the behaviour of such circuits, would it yield any meaningful insights that a simulation couldn‚Äôt?</p>",
        "id": 573572974,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770915098
    },
    {
        "content": "<p>At that scale would such solutions even be computationally better than numerical solutions?</p>",
        "id": 573573191,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770915163
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"466334\">@Shreyas Srinivas</span>, I think that is straw-manning Siddhartha's point.</p>",
        "id": 573636922,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1770939112
    },
    {
        "content": "<p>To clarify it is not the cases where numerics works perfectly well that I am talking about but the cases (above the critical exponent) where they don't and for mathematically well understood reasons. These include fluid dynamics to predict turbulence and weather and the equations for plasmas to control fusion. People in the field also know these issues and do manage to work around in many intelligent ways. But they are seeking more robust solutions (many fluid mechanics people are talking of using AI to relate scales, to cope with the effect of small scales on larger ones).</p>\n<p>What I am talking about is not a \"power series solution\" or something like that  but <em>theory</em>. For instance, an effective finite-time existence and regularity result for solutions; results about the nature of singularities and entropies/energies that determine these; effective <em>controllability</em> results (these say that boundary conditions can be varied to determine trajectories) etc. Such a theory, if possible, will certainly be of value.</p>\n<p>The broader point is that there is a concern (and there should be) that problems that are important and difficult but possible today will become easy, and so lose their role in terms of purpose/prestige. But one should expect that the same technology will mean that things that are important but beyond our abilities today become feasible. So the scope of mathematics need not shrink but can shift (and may even expand). To me this is the great promise of Lean+AI.</p>",
        "id": 573647074,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1770946140
    },
    {
        "content": "<p>Okay I see what you mean. But this only works in a world where those with resources believe mathematics has more to offer and is worth funding. We appear to be in a world where those with resources believe AI will ‚Äúsolve mathematics‚Äù and human mathematicians will be obsolete. That‚Äôs the kind of scenario depicted in Patrick‚Äôs comic. This is not a hypothetical. We are seeing funding agencies already push limited grant money towards AI and away from other areas of study.</p>",
        "id": 573647396,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770946381
    },
    {
        "content": "<p>This is me being a mathematician, proving an existence theorem and declaring my job done <span aria-label=\"smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"smile\">:smile:</span> </p>\n<p>I agree there are economic, social, political factors here which I am not addressing  - not because they are not important, but because they are so big that they will drown out the more limited scientific point I am making. But to only partially address these - one needs to only convince those controlling <em>some</em> of the resources of the continued utility of mathematics (and the world has things like the Simons foundation and Renaissance Philanthropy for example). But to convince even some of the continued utility of mathematics as AI doing maths becomes powerful one should have some vision of <em>how</em> mathematics is going to continue to be useful. I laid out one such vision, and perhaps others will have a much better one. But betting on AI not crossing some thresholds is risky.</p>\n<p>But what I said is to me mainly simply a personal guide.</p>",
        "id": 573649489,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1770947908
    },
    {
        "content": "<p>I completely agree but I also think a lot of these discussions will look wildly different depending on subfield!</p>",
        "id": 573650183,
        "sender_full_name": "Bryan Wang",
        "timestamp": 1770948330
    },
    {
        "content": "<p>I'm not a mathlib maintainer, just someone learning Lean by formalizing basic complex number identities.</p>\n<p>I see a gap between:</p>\n<ul>\n<li>\n<p>Writing¬†<code>simp</code>¬†and hoping it works, and</p>\n</li>\n<li>\n<p>Writing a clear¬†<code>calc</code>¬†proof where every step is justified.</p>\n</li>\n</ul>\n<p>When I do the second, I¬†<em>understand</em>¬†the theorem. When I do the first, I just pass the tactic.</p>\n<p>If mathlib becomes a pile of AI-generated proofs that no human really understands, I'm not sure even an AI could maintain it long term. Because to fix broken code, you need to understand what it was supposed to do ‚Äî and that's exactly what these bloated, non-idiomatic proofs hide.</p>\n<p>So yes, AI can write fast. But if it writes code that even it doesn't¬†<em>comprehend</em>, we're just accelerating toward unmaintainability.</p>",
        "id": 573654534,
        "sender_full_name": "Soltani Mehrez",
        "timestamp": 1770951421
    },
    {
        "content": "<p>I just wanted to point out that the <a href=\"https://github.com/teorth/equational_theories\">Equational Theories Project</a> is, in some sense, an existing example of a \"sloplib\".  We proved 22 million implications or anti-implications between over 4000 equational laws in Lean (well, technically, we only formalized about 600,000 of these in Lean, the rest can be deduced by transitive closure).  Almost all of these implications are \"AI slop\" in that they are proven by (good old-fashioned) AI such as automated theorem provers, or by using computer-generated counterexamples found mainly by brute force.  Only a very small number of the proved implications yield any human insight in their proofs.  It would have been totally infeasible to complete this project without such heavy reliance on some sort of AI.</p>\n<p>My view is that this type of \"slop-powered\" projects can enable a complementary style of mathematics to traditional styles, analogously to how experiment can complement theory in the physical sciences.  Much as we would not want empirical experiment to substitute for theory, it would be ill-advised to use mass generation of uninterpretable AI proofs for any traditional math research project, but I think there is a role for such tools in exploratory, experimental mathematics of a type which was almost non-existent before the AI era (where I also include good old-fashioned AI as a type of AI in addition to modern LLM-powered tools).</p>",
        "id": 573670254,
        "sender_full_name": "Terence Tao",
        "timestamp": 1770962046
    },
    {
        "content": "<p>I think the discussion has meandered in two directions</p>\n<ol>\n<li>Should we use AI for formalisations?</li>\n<li>Should we collect them in a mathlib style lib. Would it be feasible, useful, and not really detrimental to the purposes as well as uses of formalisation.</li>\n</ol>",
        "id": 573670550,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770962302
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/573670254\">said</a>:</p>\n<blockquote>\n<p>I just wanted to point out that the <a href=\"https://github.com/teorth/equational_theories\">Equational Theories Project</a> is, in some sense, an existing example of a \"sloplib\".  We proved 22 million implications or anti-implications between over 4000 equational laws in Lean (well, technically, we only formalized about 600,000 of these in Lean, the rest can be deduced by transitive closure).  Almost all of these implications are \"AI slop\" in that they are proven by (good old-fashioned) AI such as automated theorem provers, or by using computer-generated counterexamples found mainly by brute force.  Only a very small number of the proved implications yield any human insight in their proofs.  It would have been totally infeasible to complete this project without such heavy reliance on some sort of AI.</p>\n</blockquote>\n<p>I think more careful language could be used here.  While there is a certain degree of expertise present in automated theorem proving or in clever uses of (I am guessing) pruned brute force, I would refrain from calling these things Artificial Intelligence.  I think the more general description of 'machine-assisted' is better, and that one should keep track of the nuances involved in the kind of assistance rendered by the machine, be it faster number-crunching, text-processing, random searching, or guided sentence generation (read as suggestion for proof completion).</p>\n<p>Terry is entitled to categorize his (and his collaborators') own work as he wishes.  However, I would call the ETP output a database of curated equational proofs much of which were programmatically generated once enough theory was developed and expertise gathered to decide which programs to use to generate parts of the database.  In particular, some thought and care were put into the shape and form and size of the database entries. Kevin Buzzard's thought experiment is a programmatically generated collection of (recipes for) proof terms and expressions of types that might be interpreted as theorems in some  form of logic which is not curated and not guided by much (if any) protocol or design beyond the essential framework dictated by the Lean system.  </p>\n<p>More importantly, one can look at the ETP and the accompanying documentation and come to some understanding and mastery of the material, and replicate the results and explain them to someone else.<br>\nThis is quite unlike a sloplib,  in which one would have a collection of statements that are asserted to be true, and one is given a not very straightforward way of running a verification machine. Further, a sloplib entry may well be incomprehensible to every human, including the designers of the sloplib system, and the entry could only be digitally copied (not replicated or its proof confirmed by a different process), and definitely not understood nor be able to be explained to someone else.</p>\n<p>I see the ETP database and documentation as being useful for future research. I see sloplib as useful for suggesting theorems that might be true and possibly provable by humans, but (to exaggerate Kevin's thought experiment some) in an inscrutable and humanly unverifiable form.  Perhaps Kevin can again explain why this idea of sloplib would be useful; I am not seeing it.</p>",
        "id": 573674787,
        "sender_full_name": "J. J. Issai (project started by GRP)",
        "timestamp": 1770965312
    },
    {
        "content": "<p>My view on this:</p>\n<ul>\n<li>The name <em>merely true</em> perfectly captures the nature of the library.</li>\n<li>It is up to each person whether or not knowing that something is merely true is of value. I feel it violates the <em>spirit of Lean</em> (which I expand on that below) if people try to say others should find no value in things being merely true, or to actively discourage the building of such libraries.</li>\n<li>Mathlib has always had high standards for its code. As of now, AI completely fails these. So obviously it cannot be accepted. Whether or not <strong>higher</strong> standards should be applied to AI can be debated, but applying lower standards is daft.</li>\n<li>What I mean by <em>spirit of Lean</em>:  when explaining Lean to programmers, I emphasize that the spirit of Lean is to <em>enable</em> but not <em>compel</em>. We can prove correctness or simply not prove it. We can prove terminatioin or simply bypass this using <code>partial</code>. This is in contrast some other functional programming communities, which while actually enabling less safety than Lean make it clear that something is really wrong with you if you do terrible things like running a monadic value. Indeed calling things <code>run</code> and not <code>runUnsafe</code> is part of the difference.</li>\n</ul>",
        "id": 573679481,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1770967694
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"930113\">J. J. Issai (project started by GRP)</span> <a href=\"#narrow/channel/113488-general/topic/sloplib/near/573674787\">said</a>:</p>\n<blockquote>\n<p>I think more careful language could be used here.  While there is a certain degree of expertise present in automated theorem proving or in clever uses of (I am guessing) pruned brute force, I would refrain from calling these things Artificial Intelligence.  I think the more general description of 'machine-assisted' is better, and that one should keep track of the nuances involved in the kind of assistance rendered by the machine, be it faster number-crunching, text-processing, random searching, or guided sentence generation (read as suggestion for proof completion).</p>\n</blockquote>\n<p>Fair point - for ETP, while each individual machine-generated proof was only barely human-readable and does not provide much human insight, there was also a record of a human directing that generation through writing automated scripts, discussing in the Zulip, etc..  The analogue for the sloplib would be if the AI-generated proofs were not generated by completely autonomous AI agents, but through AI prompted by humans, with the prompts themselves (as well as AI chain of thought, etc.) being made openly available as part of the sloplib documentation, and perhaps discussed by human participants in the project in a suitable project forum.  This may be an intermediate point on the tradeoff between pure scale and interpretability that may offer more value than a project optimized only for scale.</p>",
        "id": 573682412,
        "sender_full_name": "Terence Tao",
        "timestamp": 1770968963
    },
    {
        "content": "<p>Since the original question was \"what would <em>go wrong</em> with sloplib\", here's my view, that I don't think has been articulated exactly here yet:</p>\n<p><strong>The outcome would be very mostly boring, mostly because of bad definitions.</strong></p>\n<p>In the context of mathlib development, a \"bad\" definition typically means one that will be unnecessarily limiting the scope of a theory, or is very awkward to work with. Because we're implicitly ruling out the case of a definition that actually is just stupid or doesn't correspond to any informal math at all. But with the standard of \"anything an AI submits that compiles\" there will very soon be nonsense in there like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">greatestTwinPrime</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">‚àÉ</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">‚àß</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"bp\">.</span><span class=\"n\">IsPrime</span>\n</code></pre></div>\n<p>or whatever. And then the next AI will come along and \"build\" on this and make further nonsense. And in general I think this will quickly lead to 'context poisoning' where AIs that see a bunch of crappy low-effort definitions in context are more likely to do so themselves. In the end, it's possible that an interesting theorem gets proved, but I think significant fractions of math will get 'doomed' exponentially quickly as these bad definitions compound.</p>\n<p>I think a sloplib experiment could be interesting, in the setting of \"no code standards for API / useful lemmas / picking the <em>best</em> definitions\", but I think that human auditing to check the definitions are at least <em>meaningful</em> would be a necessary precondition to the experiment going anywhere fun.</p>",
        "id": 574009699,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1771192419
    }
]