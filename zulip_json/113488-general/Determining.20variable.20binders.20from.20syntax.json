[
    {
        "content": "<p>Given a <code>variable</code> command, can I determine the inner binder names from a syntax linter? I can get a syntax node of <code>explicitBinder</code> kind, but don't see how to parse out the binder names...</p>\n<p>I tried something like the following (minimised):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Batteries</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">Lint</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Command</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">badVariableLinter</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Linter</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">withSetOptionIn</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">MonadState</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">messages</span><span class=\"bp\">.</span><span class=\"n\">hasErrors</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"n\">return</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">Syntax</span><span class=\"bp\">.</span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"ss\">``Lean.Parser.Command.variable</span><span class=\"w\"> </span><span class=\"n\">args</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">binders</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">args</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">getBinders</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">flatten</span>\n<span class=\"w\">      </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"ss\">``Lean.Parser.Term.implicitBinder</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"ss\">``Lean.Parser.Term.explicitBinder</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">contains</span><span class=\"w\"> </span><span class=\"n\">kind</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">        </span><span class=\"n\">binders</span><span class=\"bp\">.</span><span class=\"n\">push</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">fargs</span>\n<span class=\"w\">      </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">binders</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">        </span><span class=\"c1\">-- How to get the list of binder names in b?</span>\n</code></pre></div>\n<p>More generally, (how) could I obtain the parsed binders from <code>Term.explicitBinder</code> or <code>Term.implicitBinder</code>? If I just print <code>b</code>, the information is there, but I'm missing how to extract it...</p>\n<p>Context: I'm trying to write a syntax linter for <code>variable</code> commands which update how a variable is bound and declare new variables at the same time.</p>",
        "id": 455421827,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1722442826
    },
    {
        "content": "<p>More generally: is there a way to print the actual syntax for some Lean code? Using something like <code>`Linter.logLint linter.badVariable stx s!\"arguments are {args}\"</code> pretty-prints the syntax; I would like to see the internal structure.<br>\n<span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> You mentioned some <code>inspect</code> command a few times. Where can I find that? (The API docs don't mention any such method.)</p>",
        "id": 455422555,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1722442958
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> It seems you tried something similar in <a href=\"https://github.com/leanprover-community/mathlib4/pull/14675\">#14675</a>, but switched to a different approach? Did you manage to solve the problem I'm worrying about?</p>",
        "id": 455427828,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1722443883
    },
    {
        "content": "<p>Can you give an example of what you would like?  E.g. with</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>you would like <code>a, b, c</code>?  Or <code>explicit, implicit, implicit</code>?</p>",
        "id": 455435942,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1722445698
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"634338\">Michael Rothgang</span> <a href=\"#narrow/stream/113488-general/topic/Determining.20variable.20binders.20from.20syntax/near/455427828\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> It seems you tried something similar in <a href=\"https://github.com/leanprover-community/mathlib4/pull/14675\">#14675</a>, but switched to a different approach? Did you manage to solve the problem I'm worrying about?</p>\n</blockquote>\n<p>I simply started with something else, since I wanted to wait for the new variable mechanism before continuing.</p>\n<p>I would still like to make \"dependent\" typeclass variables flagged by a linter, but I was not sure whether the adaptation to the new variable command and this linter would have stepped on each other's toes (and I guess that they would!).</p>",
        "id": 455438469,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1722446358
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"634338\">Michael Rothgang</span> <a href=\"#narrow/stream/113488-general/topic/Determining.20variable.20binders.20from.20syntax/near/455422555\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> You mentioned some <code>inspect</code> command a few times. Where can I find that? (The API docs don't mention any such method.)</p>\n</blockquote>\n<p><code>inspect</code> is a command that I defined to print the tree structure of some syntax.  Using <code>dbg_trace stx</code> gives you some idea of what the tree structure looks like.</p>",
        "id": 455438848,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1722446436
    },
    {
        "content": "<p>Johan suggested upgrading <code>inspect</code> to a clickable interface and PRing it, but I have not gotten around to it.</p>",
        "id": 455438940,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1722446467
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/113488-general/topic/Determining.20variable.20binders.20from.20syntax/near/455435942\">said</a>:</p>\n<blockquote>\n<p>Can you give an example of what you would like?  E.g. with</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>you would like <code>a, b, c</code>?  Or <code>explicit, implicit, implicit</code>?</p>\n</blockquote>\n<p>Ultimately, I am interested in a list of items (name, withType): for <code>variable (a) (b : Nat)</code> this would say <code>(a, false), (b, true)</code>.</p>",
        "id": 455439821,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1722446648
    },
    {
        "content": "<p>FWIW, I <a href=\"#narrow/stream/270676-lean4/topic/lean4.234814.2C.20new.20variable.20command\">asked</a> about this linter and the new variables command - and my impression was that this linter is still desirable.</p>",
        "id": 455440219,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1722446728
    },
    {
        "content": "<p>Is this close to what you wanted?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">getNamesWithType</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">stx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Syntax</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Syntax</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"ss\">``Lean.Parser.Term.implicitBinder</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"ss\">``Lean.Parser.Term.explicitBinder</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">contains</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"bp\">.</span><span class=\"n\">getKind</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"n\">stx</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">getArgs</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">][</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">!=</span><span class=\"w\"> </span><span class=\"n\">default</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[]</span>\n\n<span class=\"n\">run_cmd</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">stxs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">bracketedBinder</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)),</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">bracketedBinder</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)),</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">bracketedBinder</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">})]</span>\n<span class=\"w\">  </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">stxs</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"s2\">\"{getNamesWithType stx.raw}\"</span>\n</code></pre></div>",
        "id": 455442728,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1722447185
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"634338\">Michael Rothgang</span> <a href=\"#narrow/stream/113488-general/topic/Determining.20variable.20binders.20from.20syntax/near/455440219\">said</a>:</p>\n<blockquote>\n<p>FWIW, I <a href=\"#narrow/stream/270676-lean4/topic/lean4.234814.2C.20new.20variable.20command\">asked</a> about this linter and the new variables command - and my impression was that this linter is still desirable.</p>\n</blockquote>\n<p>I was thinking of a different linter: the one that I had in mind would complain if you have <code>[Mul R] [Ring R]</code> since <code>Mul</code> is implied by <code>Ring</code>.</p>",
        "id": 455443050,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1722447248
    },
    {
        "content": "<p>This is the one that you linked to above, I think.</p>",
        "id": 455443129,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1722447263
    },
    {
        "content": "<p>Indeed, I was using your PR as inspiration for how to work with variables syntactically.</p>",
        "id": 455443318,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1722447300
    },
    {
        "content": "<p>Ah, no, the one above is yet another one!  The one above, <a href=\"https://github.com/leanprover-community/mathlib4/pull/14675\">#14675</a>, is one that complains when <code>variable (a : Nat)</code> is available and you type <code>example (a : Nat) ...</code>.</p>",
        "id": 455443521,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1722447343
    },
    {
        "content": "<p>In some sense, that linter tries to maximize the use of the <code>variable</code>s in scope.  I agree with the sentiment that this is not so great: it is better to be more explicit about assumptions!</p>",
        "id": 455444011,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1722447431
    },
    {
        "content": "<p>I think that the \"implied typeclass\" linter does produce better code, but that one will step on the new variable mechanism.</p>",
        "id": 455444169,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1722447471
    },
    {
        "content": "<p>So, I withheld from developing and adapting mathlib to it until the variable wave washes out.</p>",
        "id": 455444346,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1722447492
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/113488-general/topic/Determining.20variable.20binders.20from.20syntax/near/455442728\">said</a>:</p>\n<blockquote>\n<p>Is this close to what you wanted?</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">getNamesWithType</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">stx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Syntax</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Syntax</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"ss\">``Lean.Parser.Term.implicitBinder</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"ss\">``Lean.Parser.Term.explicitBinder</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">contains</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"bp\">.</span><span class=\"n\">getKind</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"n\">stx</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">getArgs</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">][</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"n\">default</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[]</span>\n\n<span class=\"n\">run_cmd</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">stxs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">bracketedBinder</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)),</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">bracketedBinder</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)),</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">bracketedBinder</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">})]</span>\n<span class=\"w\">  </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">stxs</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"s2\">\"{getNamesWithType stx.raw}\"</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Yes, it is - thanks a lot! (I actually want to invert the booleans, but that is easy to do.)</p>",
        "id": 455446504,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1722447930
    },
    {
        "content": "<p>Yes, I noticed it and I have already edited the command above!</p>",
        "id": 455446604,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1722447952
    },
    {
        "content": "<p>Make sure not to invert them twice!  (The original was indeed the opposite of what you wanted.)</p>",
        "id": 455446751,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1722447973
    },
    {
        "content": "<p>Also, note that <code>(a := 0)</code> is a valid binder and the code above treats it as \"no type provided\".</p>",
        "id": 455446942,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1722448008
    },
    {
        "content": "<p>Whether or not this is what you want, I do not know!</p>",
        "id": 455446983,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1722448016
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/113488-general/topic/Determining.20variable.20binders.20from.20syntax/near/455446983\">said</a>:</p>\n<blockquote>\n<p>Whether or not this is what you want, I do not know!</p>\n</blockquote>\n<p>Good point; I am not sure yet either. I'll think about it!</p>",
        "id": 455448080,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1722448250
    },
    {
        "content": "<p>Btw, if you want to see a lot of raw binder action, checkout the fully unpolished <a href=\"https://github.com/leanprover-community/mathlib4/pull/15213\">#15213</a>.</p>",
        "id": 455448196,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1722448281
    },
    {
        "content": "<p>I don't think you should be parsing binders yourself like this. Take a look at the implementation of <code>variable</code> in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Elab.Command.elabVariable#doc\">docs#Lean.Elab.Command.elabVariable</a></p>\n<p>There's <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Elab.Command.getBracketedBinderIds#doc\">docs#Lean.Elab.Command.getBracketedBinderIds</a> for example to get the ids from each binder. Potentially you could even elaborate the binders using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Elab.Term.elabBinders#doc\">docs#Lean.Elab.Term.elabBinders</a> to get the full list with their types, which includes implicit/explicit/etc.</p>",
        "id": 455466655,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1722454151
    },
    {
        "content": "<p>Thanks, that looks really helpful. I'll take a closer look!</p>",
        "id": 455470718,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1722455328
    }
]