[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> <span class=\"user-mention\" data-user-id=\"240862\">@Oliver Nash</span> we have non assoc rings now? How about algebras?</p>",
        "id": 256258075,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1633445092
    },
    {
        "content": "<p>Yes, though it's not quite as pretty as it might be. E.g., we have  <a href=\"https://leanprover-community.github.io/mathlib_docs/find/non_assoc_semiring\">docs#non_assoc_semiring</a> but no <code>non_assoc_ring</code>.</p>",
        "id": 256258505,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1633445216
    },
    {
        "content": "<p>The question about algebra is: do we have a structure that cover both the <a href=\"https://leanprover-community.github.io/mathlib_docs/find/algebra\">docs#algebra</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/lie_algebra\">docs#lie_algebra</a>?</p>",
        "id": 256258884,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1633445328
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113488-general/topic/Undergraduate.20math.20list/near/256258075\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <span class=\"user-mention silent\" data-user-id=\"240862\">Oliver Nash</span> we have non assoc rings now? How about algebras?</p>\n</blockquote>\n<p>Also since our bundled <code>algebra</code> class is (unfortunately) still stuck in the (unital) associative world, the following is how to declare a non-assoc algebra:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">non_assoc_semiring</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_scalar_tower</span> <span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">smul_comm_class</span> <span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 256259092,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1633445400
    },
    {
        "content": "<p>Oliver, this has a unit, right? It doesn't happen so often for Lie algebras.</p>",
        "id": 256259323,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1633445465
    },
    {
        "content": "<p>Yes, that has a unit. There is a flavour without a unit. You just write <code>non_unital_non_assoc_semiring A</code>.</p>",
        "id": 256259388,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1633445481
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113488-general/topic/Undergraduate.20math.20list/near/256258884\">said</a>:</p>\n<blockquote>\n<p>The question about algebra is: do we have a structure that cover both the <a href=\"https://leanprover-community.github.io/mathlib_docs/find/algebra\">docs#algebra</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/lie_algebra\">docs#lie_algebra</a>?</p>\n</blockquote>\n<p>Sort of. Since Lie algebras use the <code>has_bracket</code> typeclass and rings use the <code>has_mul</code> typeclass, it's not quite so simple. I believe the only place where we connect these two worlds is in the construction of the free Lie algebra as a quotient of the free non-unital, non-associative algebra.</p>\n<p>E.g., here a <code>has_mul</code> is turned into a <code>has_bracket</code>: <a href=\"https://github.com/leanprover-community/mathlib/blob/5926f103c66a17a60eafc1aaec387d9db85a21ad/src/algebra/lie/free.lean#L115\">https://github.com/leanprover-community/mathlib/blob/5926f103c66a17a60eafc1aaec387d9db85a21ad/src/algebra/lie/free.lean#L115</a></p>",
        "id": 256260498,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1633445796
    },
    {
        "content": "<p>Oliver, the question is whether you can write a def that takes a lie algebra structure and outputs a <code>non_unital_non_assoc_semiring</code></p>",
        "id": 256260939,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1633445935
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113488-general/topic/Undergraduate.20math.20list/near/256260939\">said</a>:</p>\n<blockquote>\n<p>Oliver, the question is whether you can write a def that takes a lie algebra structure and outputs a <code>non_unital_non_assoc_semiring</code></p>\n</blockquote>\n<p>Should we have <code>bracketive</code>/<code>unbracketive</code> to match <code>multiplicative</code>/<code>additive</code>? One translates between <code>+</code> and <code>*</code>, the other between lie brackets and <code>*</code>.</p>",
        "id": 256261505,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1633446111
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113488-general/topic/Undergraduate.20math.20list.20.28algebras.29/near/256260939\">said</a>:</p>\n<blockquote>\n<p>Oliver, the question is whether you can write a def that takes a lie algebra structure and outputs a <code>non_unital_non_assoc_semiring</code></p>\n</blockquote>\n<p>I see, well we can do this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.lie.basic</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span> <span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">lie_ring</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">lie_ring.to_non_unital_non_assoc_semiring</span> <span class=\"o\">:</span> <span class=\"n\">non_unital_non_assoc_semiring</span> <span class=\"n\">L</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">mul</span>           <span class=\"o\">:=</span> <span class=\"n\">has_bracket.bracket</span><span class=\"o\">,</span>\n  <span class=\"n\">left_distrib</span>  <span class=\"o\">:=</span> <span class=\"n\">lie_add</span><span class=\"o\">,</span>\n  <span class=\"n\">right_distrib</span> <span class=\"o\">:=</span> <span class=\"n\">add_lie</span><span class=\"o\">,</span>\n  <span class=\"n\">zero_mul</span>      <span class=\"o\">:=</span> <span class=\"n\">zero_lie</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_zero</span>      <span class=\"o\">:=</span> <span class=\"n\">lie_zero</span><span class=\"o\">,</span>\n  <span class=\"bp\">..</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">apply_instance</span> <span class=\"o\">:</span> <span class=\"n\">add_comm_group</span> <span class=\"n\">L</span><span class=\"o\">),</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 256262488,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1633446459
    },
    {
        "content": "<p>And if we had also assumed <code>lie_algebra R L</code> (for a <code>comm_ring R</code>) we could define the relevant <code>is_scalar_tower</code> and <code>smul_comm_class</code> classes.</p>",
        "id": 256262745,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1633446543
    },
    {
        "content": "<p>Where does the <code>has_scalar R L</code> instance come from?</p>",
        "id": 256262833,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1633446572
    },
    {
        "content": "<p>From <code>lie_algebra.to_module</code></p>",
        "id": 256262991,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1633446612
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/lie_algebra.to_module\">docs#lie_algebra.to_module</a></p>",
        "id": 256263285,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1633446708
    },
    {
        "content": "<p>Oh I was getting confused by <code>lie_ring_module</code> which has a different sort of action, never mind</p>",
        "id": 256263561,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1633446789
    },
    {
        "content": "<p>Oh, but actually you have a point, we need a <code>has_scalar L L</code>.</p>",
        "id": 256263681,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1633446825
    },
    {
        "content": "<p>Which I guess would come from <code>lie_ring.to_non_unital_non_assoc_semiring</code> via <code>has_mul.to_has_scalar</code> if we set things up right.</p>",
        "id": 256263786,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1633446845
    },
    {
        "content": "<p>Oh wow, someone took the trouble to sort the conversations in different topics</p>",
        "id": 256266194,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1633447570
    },
    {
        "content": "<p>What is the conclusion then? Do you have a fully working instance?</p>",
        "id": 256266239,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1633447588
    },
    {
        "content": "<p>No but I could create one. It would be a type synonym and 3/4 associated instances on it. I can create and PR it if you would like but it is not very likely to be used.</p>",
        "id": 256266398,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1633447643
    },
    {
        "content": "<p>I'd be more inclined to do it if we \"fixed\" our <code>algebra</code> class.</p>",
        "id": 256266471,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1633447673
    },
    {
        "content": "<p>Of course, very easy and won't do any harm.</p>",
        "id": 256266476,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1633447674
    },
    {
        "content": "<p>I don't think it necessarily needs to be PRed, but clarifying this would be nice</p>",
        "id": 256266588,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1633447700
    },
    {
        "content": "<p>What do you mean by fixing here?</p>",
        "id": 256266613,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1633447711
    },
    {
        "content": "<p>Changing its definition so that it does not require the underlying \"ring\" to be unital and associative.</p>",
        "id": 256266755,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1633447770
    },
    {
        "content": "<p>There was an old branch where Scott and I made a brief attempt to do this and more recently there is this: <a href=\"https://github.com/leanprover-community/mathlib/commit/dcbed292a23994dfddf70d8262a4defb3103e968#diff-7fa8b94b14c549770d3cddb5a015c4c6029e40e3cd5161d574d9b9f5e7cdff1bR54\">https://github.com/leanprover-community/mathlib/commit/dcbed292a23994dfddf70d8262a4defb3103e968#diff-7fa8b94b14c549770d3cddb5a015c4c6029e40e3cd5161d574d9b9f5e7cdff1bR54</a></p>",
        "id": 256266802,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1633447787
    },
    {
        "content": "<p>Ok, that's a big refactor.</p>",
        "id": 256266814,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1633447792
    },
    {
        "content": "<p>Yep</p>",
        "id": 256266842,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1633447801
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113488-general/topic/Undergraduate.20math.20list.20.28algebras.29/near/256266588\">said</a>:</p>\n<blockquote>\n<p>I don't think it necessarily needs to be PRed, but clarifying this would be nice</p>\n</blockquote>\n<p>I'll paste a complete version here later today.</p>",
        "id": 256266971,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1633447835
    },
    {
        "content": "<p>The following should illustrate how to do this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.lie.basic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">lie_ring.to_has_mul</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">L</span>\n\n<span class=\"kn\">local</span> <span class=\"kd\">notation</span> <span class=\"n\">L</span> <span class=\"bp\">`⋆`</span> <span class=\"o\">:=</span> <span class=\"n\">lie_ring.to_has_mul</span> <span class=\"n\">L</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">lie_ring</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">lie_algebra</span> <span class=\"n\">R</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">non_unital_non_assoc_semiring</span> <span class=\"o\">(</span><span class=\"n\">L</span><span class=\"bp\">⋆</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">mul</span>           <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">has_bracket.bracket</span> <span class=\"n\">L</span> <span class=\"n\">L</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">left_distrib</span>  <span class=\"o\">:=</span> <span class=\"n\">lie_add</span><span class=\"o\">,</span>\n  <span class=\"n\">right_distrib</span> <span class=\"o\">:=</span> <span class=\"n\">add_lie</span><span class=\"o\">,</span>\n  <span class=\"n\">zero_mul</span>      <span class=\"o\">:=</span> <span class=\"n\">zero_lie</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_zero</span>      <span class=\"o\">:=</span> <span class=\"n\">lie_zero</span><span class=\"o\">,</span>\n  <span class=\"bp\">..</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">apply_instance</span> <span class=\"o\">:</span> <span class=\"n\">add_comm_group</span> <span class=\"n\">L</span><span class=\"o\">),</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">L</span><span class=\"bp\">⋆</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">lie_algebra.to_module</span> <span class=\"n\">R</span> <span class=\"n\">L</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">is_scalar_tower</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">L</span><span class=\"bp\">⋆</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">L</span><span class=\"bp\">⋆</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">smul_lie</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">smul_comm_class</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">L</span><span class=\"bp\">⋆</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">L</span><span class=\"bp\">⋆</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">t</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">lie_smul</span> <span class=\"n\">R</span> <span class=\"n\">L</span> <span class=\"n\">L</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">t</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 256273357,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1633450067
    },
    {
        "content": "<p>Tidied up <span aria-label=\"point up\" class=\"emoji emoji-1f446\" role=\"img\" title=\"point up\">:point_up:</span> slightly. LMK if you want anything else.</p>",
        "id": 256280807,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1633452993
    },
    {
        "content": "<p><code>with_mul</code> is probably a better name than <code>to_has_mul</code>.</p>",
        "id": 256283221,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1633453919
    },
    {
        "content": "<p>It still feels weird that we don't have a plain <code>non_unital_non_associative_algebra R A</code>. People coming to mathlib and asking where are algebras will have a very hard time understanding the answer</p>",
        "id": 256289451,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1633456413
    },
    {
        "content": "<p>If we do that we face the <a href=\"https://leanprover-community.github.io/mathlib_docs/find/domain\">docs#domain</a> problem, where either:</p>\n<ul>\n<li>Lots of lemmas get stated about <code>domain</code> that don't actually require all of <code>ring</code>, <code>nontrivial</code>, and <code>no_zero_divisors</code></li>\n<li>No lemmas actually use <code>domain</code>, which means it's not really pedagogically useful</li>\n</ul>\n<p>And to make matters worse, typeclass inference can't promote <code>ring R</code> <code>nontrivial R</code> <code>no_zero_divisors R</code> into <code>integral_domain</code> even though they mean the same thing</p>",
        "id": 256289977,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1633456597
    },
    {
        "content": "<p>I think that last problem goes away in lean4</p>",
        "id": 256292819,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1633457547
    },
    {
        "content": "<p>I guess we could just define it like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/subspace\">docs#subspace</a> but not use it?</p>",
        "id": 256292843,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1633457558
    },
    {
        "content": "<p>(i thought we did that for <code>vector_space</code> too but I guess not)</p>",
        "id": 256292952,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1633457600
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113488-general/topic/Undergraduate.20math.20list.20.28algebras.29/near/256289451\">said</a>:</p>\n<blockquote>\n<p>It still feels weird that we don't have a plain <code>non_unital_non_associative_algebra R A</code>. People coming to mathlib and asking where are algebras will have a very hard time understanding the answer</p>\n</blockquote>\n<p>Understanding the answer will be just as hard as understanding why we have <code>group</code> and <code>add_group</code>. And just as hard as why we can't use <code>∘</code> to denote multiplication in endomorphism rings.</p>",
        "id": 256302075,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1633461158
    },
    {
        "content": "<p>I disagree, this is not the same order of magnitude.</p>",
        "id": 256302370,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1633461267
    },
    {
        "content": "<p>Hmm, ok, I agree that such algebras could exist. Do you agree that Lie algebras wouldn't be instances?</p>",
        "id": 256303055,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1633461530
    },
    {
        "content": "<p>I've never used such algebras, apart from Lie algebras.</p>",
        "id": 256303164,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1633461576
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> Does the \"<code>module R A</code> + <code>is_scalar_tower R A A</code> + <code>smul_comm_class R A A</code>\" definition work in this case?</p>",
        "id": 256303554,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1633461728
    },
    {
        "content": "<p>If yes, then we can go with <a href=\"https://github.com/leanprover-community/mathlib/tree/redefine-algebra\">branch#redefine-algebra</a> and use very weak typeclass assumptions in the definition.</p>",
        "id": 256303621,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1633461760
    },
    {
        "content": "<p>Johan, did you intend to write \"Lie algebras would be instances\"?</p>",
        "id": 256304125,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1633461989
    },
    {
        "content": "<p>I'm talking about <a href=\"https://en.wikipedia.org/wiki/Non-associative_algebra\">https://en.wikipedia.org/wiki/Non-associative_algebra</a> which does include Lie algebras and mathlib algebras as special cases</p>",
        "id": 256304207,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1633462020
    },
    {
        "content": "<p>(although wikipedia insists the base ring is a field for some mysterious reason)</p>",
        "id": 256304253,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1633462037
    },
    {
        "content": "<p>No. I meant \"would not\".</p>\n<p>I think it is more useful that every associative algebra gives a Lie algebra, via the commutator bracket, then the fact that the Lie algebra can be viewed as a non-assoc multiplication.<br>\nHaving both as instances would give two non-propeq multiplications on every assoc algebra.</p>",
        "id": 256304387,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1633462086
    },
    {
        "content": "<p>But we can have a type tag that turns a Lie algebra into a (non-assoc) algebra.</p>",
        "id": 256304601,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1633462182
    },
    {
        "content": "<p>Then we restate all facts in terms of Lie brackets.</p>",
        "id": 256304627,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1633462194
    },
    {
        "content": "<p>Yury, yes I think this collection of type classes work</p>",
        "id": 256304879,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1633462278
    },
    {
        "content": "<p>And it is equivalent to the standard definition in case of <code>semiring A</code>.</p>",
        "id": 256304950,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1633462311
    },
    {
        "content": "<p>Johan, we don't have to have instances of this, I only suggest that people who want to formalize stuff about algebras can find a way to express this without searching Zulip for this thread.</p>",
        "id": 256305042,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1633462337
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> This <span aria-label=\"up\" class=\"emoji emoji-2b06\" role=\"img\" title=\"up\">:up:</span> is another reason to remove <code>algebra_map</code> from the definition of <code>algebra</code>.</p>",
        "id": 256305141,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1633462391
    },
    {
        "content": "<p>I certainly don't want our currently supported algebras to become harder to use because of this definition.</p>",
        "id": 256305208,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1633462422
    },
    {
        "content": "<p>I think we can simply put the definition somewhere and not use it.</p>",
        "id": 256305278,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1633462443
    },
    {
        "content": "<p>Ok, then I fully agree with you.</p>",
        "id": 256306023,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1633462752
    },
    {
        "content": "<p>Earlier, I suggested the same retractor as a way to get rid of some TC diamonds.</p>",
        "id": 256306815,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1633463076
    },
    {
        "content": "<p>We only lose some definitional equalities for <code>algebra_map</code>, nothing more.</p>",
        "id": 256306934,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1633463128
    },
    {
        "content": "<p>And we can reuse instances about scalar towers in definitions of algebras.</p>",
        "id": 256307038,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1633463167
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113488-general/topic/Undergraduate.20math.20list.20.28algebras.29/near/256305042\">said</a>:</p>\n<blockquote>\n<p>Johan, we don't have to have instances of this, I only suggest that people who want to formalize stuff about algebras can find a way to express this without searching Zulip for this thread.</p>\n</blockquote>\n<p>I think a better solution to this is to curate a note explaining how maths-speak translates to mathlib-speak. Typically, an explanation of how to declare a vector space or an algebra.</p>",
        "id": 256311534,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1633464796
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/10221\">#10221</a> improves the docstring of <code>algebra</code> a little, which somewhat helps here.</p>",
        "id": 260670195,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636384496
    },
    {
        "content": "<p>for vector spaces I think we came up with a really nice idea involving either notation or reducible defs, I can't remember, it was something Anne and I talked about months ago and then I never did anything about.</p>",
        "id": 260676207,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636386954
    }
]