[
    {
        "content": "<p>I wanted to learn more about the options for Declarative Lean (e.g. like Isar or controlled natural language or Cezar <a href=\"https://kluedo.ub.uni-kl.de/frontdoor/deliver/index/docId/2100/file/B-065.pdf\" title=\"https://kluedo.ub.uni-kl.de/frontdoor/deliver/index/docId/2100/file/B-065.pdf\">https://kluedo.ub.uni-kl.de/frontdoor/deliver/index/docId/2100/file/B-065.pdf</a>). Any pointers? Does this exist for Lean?</p>",
        "id": 196667754,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1588785676
    },
    {
        "content": "<p>Everything I see when skimming this pdf is already possible with the tactics we have.</p>",
        "id": 196669584,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1588786364
    },
    {
        "content": "<p>You don't need anything new , you only need to restrict to a subset of what is available</p>",
        "id": 196669690,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1588786401
    },
    {
        "content": "<p>If you want to enforce using only this subset then you can have a dedicated tactic mode where you only copy the subset you want to enforce</p>",
        "id": 196669837,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1588786466
    },
    {
        "content": "<p>For instance you can read the discussion at <a href=\"#narrow/stream/113488-general/topic/Proposal.3A.20.60fix.20x.60.20for.20.60assume.20x.60\" title=\"#narrow/stream/113488-general/topic/Proposal.3A.20.60fix.20x.60.20for.20.60assume.20x.60\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proposal.3A.20.60fix.20x.60.20for.20.60assume.20x.60</a>. It will contains a lot of noise from your point of view, but also interesting things for you.</p>",
        "id": 196670257,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1588786642
    },
    {
        "content": "<p>Here's the example on p4 of the pdf, in Lean:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">hidden</span>\n\n<span class=\"n\">def</span> <span class=\"n\">div2</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">div2</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n\n<span class=\"n\">def</span> <span class=\"n\">double</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">n</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">nat</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">double_div2</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">div2</span> <span class=\"o\">(</span><span class=\"n\">double</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">d</span> <span class=\"n\">hd</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">refl</span><span class=\"o\">},</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">double</span> <span class=\"n\">at</span> <span class=\"n\">hd</span> <span class=\"err\">⊢</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">succ_add</span><span class=\"o\">,</span>\n  <span class=\"k\">show</span> <span class=\"n\">div2</span> <span class=\"o\">(</span><span class=\"bp\">_</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">div2</span><span class=\"o\">,</span>\n  <span class=\"k\">show</span> <span class=\"n\">div2</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"bp\">+</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"bp\">_</span> <span class=\"bp\">=</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">hd</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">double_div2&#39;</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">div2</span> <span class=\"o\">(</span><span class=\"n\">double</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n  <span class=\"k\">assume</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">rec_on</span> <span class=\"n\">n</span>\n  <span class=\"o\">(</span> <span class=\"k\">show</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n    <span class=\"k\">from</span> <span class=\"n\">rfl</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"k\">assume</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"k\">assume</span> <span class=\"n\">Hrec</span><span class=\"o\">,</span>\n   <span class=\"k\">calc</span> <span class=\"n\">div2</span> <span class=\"o\">(</span><span class=\"n\">double</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">m</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">div2</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">succ</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">rfl</span>\n   <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"n\">div2</span> <span class=\"o\">((</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">congr_arg</span> <span class=\"bp\">_</span> <span class=\"err\">$</span> <span class=\"k\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">succ_add</span><span class=\"o\">,</span> <span class=\"n\">add_succ</span><span class=\"o\">]</span>\n   <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">div2</span> <span class=\"o\">(</span><span class=\"n\">double</span> <span class=\"n\">m</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"n\">div2</span><span class=\"bp\">;</span> <span class=\"n\">refl</span>\n   <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"n\">Hrec</span>\n  <span class=\"o\">)</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">hidden</span>\n</code></pre></div>\n\n\n<p>Both modes are already available.</p>",
        "id": 196670417,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1588786690
    },
    {
        "content": "<p>See also the example at <a href=\"#narrow/stream/116395-maths/topic/Lebesgue.20number.20lemma/near/194033514\" title=\"#narrow/stream/116395-maths/topic/Lebesgue.20number.20lemma/near/194033514\">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lebesgue.20number.20lemma/near/194033514</a></p>",
        "id": 196670541,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1588786736
    },
    {
        "content": "<p>The main difference with Isar (beyond the additional flexibility) is the lack of sledgehammer to proving proofs of each small step.</p>",
        "id": 196670639,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1588786765
    },
    {
        "content": "<p>You can also mix Kevin's example, doing the structured tactic mode style.</p>",
        "id": 196670761,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1588786806
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246156\">@Brando Miranda</span>’s interests are in AI, so I don’t think he is asking from the point of a Lean user (i.e. how can I do this in practice), but for some other purpose (e.g. is there a formal declarative specification I can use to interact with Lean).  Can you clarify your motivation Brando?  (Also it is good to hear from you again.)</p>",
        "id": 196671249,
        "sender_full_name": "Jason Rute",
        "timestamp": 1588787024
    },
    {
        "content": "<p>Wow. Thanks Jason, that was <em>very</em> hard to guess from his message and then disappearance.</p>",
        "id": 196673519,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1588788028
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> Thanks for your response. It's greatly appreciated. I'm curious, what do you mean by disappearance? I didn't know when I would get a response so I just closed the chat and would be back to it later as I have now. </p>\n<p>My question has many facets. One of them is trying to understand what is the best representation from an interactive theorem prover side for machine learning (ML) systems to do proof search. I won't lie but with so many Interactive Theorem Provers (ITPs) in existence, it's been very hard for me to commit to any of them in depth (though Isabelle is the one I know best because it's the one taught in my university) because I just don't know which one is the best (especially for Machine Learning). I am not even sure what are all the features I should be considering when choosing one (especially for ML).</p>\n<p>In addition, to discover that there is a declarative style ITP language added yet another layer of complexity that I didn't know existed. It's not entirely clear why to me what the main problem declarative proofs solve vs procedural (I will admit if I don't know if there are more styles I am not aware of). </p>\n<p>Though, it was a pleasant surprise to hear that Lean has declarative proofs embedded in the language naturally, so I wouldn't have to worry about that if I were to choose Lean it seems, though I'm not an expert in ITPs, but I find them fascinating (and fun to use!).</p>",
        "id": 196691120,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1588796243
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"115715\">@Jason Rute</span>  Thanks for the kind message Jason. I plan to be very active this summer, as soon as classes end next week. Excited! :)</p>",
        "id": 196691565,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1588796431
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246156\">Brando Miranda</span> <a href=\"#narrow/stream/113488-general/topic/Declarative.20Lean/near/196691120\" title=\"#narrow/stream/113488-general/topic/Declarative.20Lean/near/196691120\">said</a>:</p>\n<blockquote>\n<p>Thanks for your response. It's greatly appreciated. I'm curious, what do you mean by disappearance? I didn't know when I would get a response so I just closed the chat and would be back to it later as I have now. </p>\n</blockquote>\n<p>There is no problem. I was making fun of Kevin and I trying to answer very quickly without really knowing the question (but adding some context can often help)</p>",
        "id": 196696020,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1588798626
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span>  Thanks! I didn't want to overwhelm people with every question I had but I am happy to start with a few first (and hopefully get them all cleared!). What problem are declarative style proofs suppose to solve (why were they invented for ITPs in particular)? Are they a good representation for proof search with respect to classical search methods or ML methods? Are they good at all for proof search?</p>",
        "id": 196700328,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1588800574
    },
    {
        "content": "<p>Declarative proof styles are intended for human readability. I think they are unlikely to be good for automatic search</p>",
        "id": 196700505,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588800637
    },
    {
        "content": "<p>the idea is that you can get a formal proof that has the general structure of an informal maths proof</p>",
        "id": 196700592,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588800684
    },
    {
        "content": "<p>Are the grammars for procedural ITPS vs declarative ITPS usually completely separate?</p>",
        "id": 196700717,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1588800740
    },
    {
        "content": "<p>No, in fact they have significant overlap, which is what I think Kevin's original point was. Lean has tactics corresponding to all the different proof styles</p>",
        "id": 196700857,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588800814
    },
    {
        "content": "<p>Why does Lean have such a feature embedded, apparently, so naturally in it? Was that a major design point for Lean? It seems other languages make a big deal out of this feature (e.g. Cezar for Coq, Miz3 for HOL Light, Isar for Isabelle perhaps more out there) so I am trying to understanding it better.</p>",
        "id": 196700892,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1588800832
    },
    {
        "content": "<p>Lean was made with the benefit of hindsight, but I don't think it was a major design point, as much as the idea of having a dynamically extensible tactic language in the first place</p>",
        "id": 196701072,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588800901
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Declarative.20Lean/near/196700857\" title=\"#narrow/stream/113488-general/topic/Declarative.20Lean/near/196700857\">said</a>:</p>\n<blockquote>\n<p>No, in fact they have significant overlap, which is what I think Kevin's original point was. Lean has tactics corresponding to all the different proof styles</p>\n</blockquote>\n<p>But this isn't standard afaik. Otherwise why draw the distinction btw Isabelle vs Isar?</p>",
        "id": 196701098,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1588800912
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Declarative.20Lean/near/196701072\" title=\"#narrow/stream/113488-general/topic/Declarative.20Lean/near/196701072\">said</a>:</p>\n<blockquote>\n<p>Lean was made with the benefit of hindsight, but I don't think it was a major design point, as much as the idea of having a dynamically extensible tactic language in the first place</p>\n</blockquote>\n<p>you mean we already know much more about ITPs before Lean was designed?</p>",
        "id": 196701150,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1588800941
    },
    {
        "content": "<p>Lean is only 5-6 years old. It's a baby compared to the others</p>",
        "id": 196701226,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588800966
    },
    {
        "content": "<p>Maybe this the wrong place to ask this (since the answer might be biased), but is due to this hindsight Lean the best ITP out there?</p>",
        "id": 196701245,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1588800977
    },
    {
        "content": "<p>That depends on what you mean by \"best\"</p>",
        "id": 196701316,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588801011
    },
    {
        "content": "<p>I think in terms of user interface lean gets a lot of things right</p>",
        "id": 196701356,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588801029
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Declarative.20Lean/near/196701316\" title=\"#narrow/stream/113488-general/topic/Declarative.20Lean/near/196701316\">said</a>:</p>\n<blockquote>\n<p>That depends on what you mean by \"best\"</p>\n</blockquote>\n<p>Is it possible to learn more about the way \"best\" was defined for Lean? e.g. the main decision that came around for the design of Lean?</p>",
        "id": 196701449,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1588801071
    },
    {
        "content": "<p>There is a paper on metaprogramming in lean 3, that might be a good place to look for major design decisions</p>",
        "id": 196701550,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588801108
    },
    {
        "content": "<p>that was when lean 3 first came out and differentiated itself from lean 2 with its much expanded tactic grammar</p>",
        "id": 196701604,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588801136
    },
    {
        "content": "<p>I am curious, what do you think is Lean's major advantages compared to Coq &amp; Isabelle? (I will read that reference thanks!)</p>",
        "id": 196701703,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1588801199
    },
    {
        "content": "<p>Different ITPs use different logics, e.g. some use higher order logic, some have the univalence axiom baked in, and so on. Hence it's difficult to say which is the \"best\" one -- it depends on what you plan on using it for. I have a hypothesis that Lean's particular choice of dependent type theory is the best one for doing a lot of different kinds of modern pure mathematics but it's difficult to \"prove\" this, other than by what we are doing, which is formalising lots of different kinds of pure mathematics and seeing what happens.</p>",
        "id": 196701809,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1588801256
    },
    {
        "content": "<p><a href=\"https://leanprover.github.io/papers/tactic.pdf\" title=\"https://leanprover.github.io/papers/tactic.pdf\">https://leanprover.github.io/papers/tactic.pdf</a></p>",
        "id": 196701813,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588801260
    },
    {
        "content": "<p>Coq takes the concerns of constructivists more seriously, but because most mathematicians aren't constructivists I regard this as a hindrance. I don't really understand this link <a href=\"https://artagnon.com/articles/leancoq\" title=\"https://artagnon.com/articles/leancoq\">https://artagnon.com/articles/leancoq</a> but perhaps you will.</p>",
        "id": 196701961,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1588801322
    },
    {
        "content": "<p>Isabelle/HOL is higher order logic, not dependent type theory, so the foundations are very different. What it does, it does very well, and very quickly. But my worries when it comes to mathematics are about what it can't do well at all.</p>",
        "id": 196702049,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1588801388
    },
    {
        "content": "<p>But these are just my personal opinions and they're highly skewed by my personal goal, which is to see e.g. an entire undergraduate pure maths degree in one system.</p>",
        "id": 196702120,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1588801441
    },
    {
        "content": "<p>Which one is the easiest to write where things that are \"obvious\" or \"intuitive\" can be taken for granted? I am guessing Lean is the best at this from this quote from the link you sent <a href=\"https://artagnon.com/articles/leancoq\" title=\"https://artagnon.com/articles/leancoq\">https://artagnon.com/articles/leancoq</a></p>\n<blockquote>\n<p>Quotient-reasoning makes formalizing commutative algebra painless, and it's baked into the Lean kernel.</p>\n</blockquote>",
        "id": 196702677,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1588801750
    },
    {
        "content": "<p>That's an eternal goal in any theorem prover</p>",
        "id": 196702912,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588801875
    },
    {
        "content": "<p>The way to prove an obvious thing is to apply the proof which someone else has already formalised in the maths library</p>",
        "id": 196702951,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1588801888
    },
    {
        "content": "<p>however this only works for some values of obvious</p>",
        "id": 196702973,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1588801897
    },
    {
        "content": "<p>and I've seen a lot of very complicated things being called obvious in research maths seminars in my time</p>",
        "id": 196703009,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1588801916
    },
    {
        "content": "<p>I was surprised to read that Lean is slow? I would have thought it's really fast because of the C++</p>\n<p>My inference is from this paragraph (<a href=\"https://artagnon.com/articles/leancoq\" title=\"https://artagnon.com/articles/leancoq\">https://artagnon.com/articles/leancoq</a>):</p>\n<blockquote>\n<p>One would think that Lean is an engineering feat, since it's written in C++: Coq's math-comp (90k loc) compares to Lean's mathlib (150k loc); math-comp builds in under ten minutes, while mathlib takes over thirty minutes to build! Indeed, due to their design decision to use a VM for computations, computation happens at a speed comparable to Python-bytecode evaluation — they seem to be overhauling this in Lean4 though, by compiling Lean code down to C before execution.</p>\n</blockquote>",
        "id": 196703014,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1588801920
    },
    {
        "content": "<p>obvious can mean \"known to the people in the room\" sometimes.</p>",
        "id": 196703076,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1588801932
    },
    {
        "content": "<p>Got it. I was just guessing based on the comment from the blog you sent me.</p>",
        "id": 196703103,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1588801956
    },
    {
        "content": "<p>Lean is <em>surprisingly</em> fast when you look at how much it is doing</p>",
        "id": 196703124,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588801969
    },
    {
        "content": "<p>hmm...What is it doing?</p>",
        "id": 196703169,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1588801995
    },
    {
        "content": "<p>The main slow things in lean are VM evaluation and typeclass inference</p>",
        "id": 196703197,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588802015
    },
    {
        "content": "<p>I guess from a proof search point of view (my interest mainly), I would be really happy if my ITP environment is fast. Very fast.</p>",
        "id": 196703215,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1588802026
    },
    {
        "content": "<p>VM evaluation is used for running tactics, which does impact your ML bottom line</p>",
        "id": 196703239,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588802042
    },
    {
        "content": "<p>But perhaps to focus only on fast is a naive goal. Hence the discussion I started and my interest in learning about Lean more (&amp; declarative proofs).</p>",
        "id": 196703319,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1588802080
    },
    {
        "content": "<p>Also, if proofs are going to be generated, it would be nice that they are human understandable, hence why I was curious about declarative style proofs (since that seems to be their main goal afaik).</p>",
        "id": 196703369,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1588802112
    },
    {
        "content": "<p>I think that a fast ITP is a great goal (which is why <a href=\"https://github.com/digama0/mm0\" title=\"https://github.com/digama0/mm0\">I built one</a>). It's tough selling this to the community though</p>",
        "id": 196703395,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588802141
    },
    {
        "content": "<p>I still have hope for post processing arbitrary proofs to make them more human readable / navigable / understandable</p>",
        "id": 196703555,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588802239
    },
    {
        "content": "<p>the main downside of procedural proofs is that you have to have the proof state in your head at all times to read the proof, which in practice means they can't be read without the program running alongside</p>",
        "id": 196703739,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588802336
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Declarative.20Lean/near/196703124\" title=\"#narrow/stream/113488-general/topic/Declarative.20Lean/near/196703124\">said</a>:</p>\n<blockquote>\n<p>Lean is <em>surprisingly</em> fast when you look at how much it is doing</p>\n</blockquote>\n<p>Is there any evidence for this? Coq also does typeclasses and tactic-based metaprogramming, and while Lean is not particularly slow, it also hasn't struck me as particularly fast. The mathlib compile times aren't great, but there is no direct comparison, so it's hard to evaluate these claims.</p>",
        "id": 196703844,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1588802389
    },
    {
        "content": "<p>That at least is easy enough to fix post facto</p>",
        "id": 196703845,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588802389
    },
    {
        "content": "<p>The typeclass problems lean has to slog though are <em>gigantic</em></p>",
        "id": 196703941,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588802421
    },
    {
        "content": "<p>I don't think Coq does as much with dynamic tactics as lean</p>",
        "id": 196704130,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588802533
    },
    {
        "content": "<p>most tactics are implemented in ML, certainly any of the \"serious\" ones. This gives them a big performance advantage</p>",
        "id": 196704175,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588802571
    },
    {
        "content": "<p>Lean is definitely slow when you look at how many lines of source it goes through per second, but that is more reflective of the complexity of the problems it has set itself (dependent type theory, unification up to definitional reduction, typeclass searches all over the place, etc) than the implementation (which is quite efficient and well optimized)</p>",
        "id": 196704405,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588802720
    }
]