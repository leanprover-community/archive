[
    {
        "content": "<p>I aspire to beef up the <code>#find</code> command to search for lemmas in various new and composable ways.</p>\n<p>Quick recap: Right now, the command takes <em>one</em> pattern (e.g. <code>#find (_ + _ = _)</code>, possibly with premises as in <code>#find (_ &gt; _ -&gt; _ + _ = _)</code>), and it will find all lemmas whose conclusion (i.e. the thing to the right of all <code>→</code> and <code>∀</code>) matches the given conclusion pattern, and where the premises in the pattern unify with premises of the lemma (in any order, and the lemma is allowed to have additional premises).</p>\n<p>I’d also like to be able to search for patterns that can occur anywhere. For example, <code>#find' (_ + _ (_ * _)) (_ &gt; _)</code> should find all lemmas that mention addition with a multiplication in the right argument anywhere, and <em>also</em> mention the greater-than operation somewhere. This is all heavily inspired by Isabelle’s <code>find_theorems</code>.</p>\n<p>This post is about brainstorming a convenient UI for it (so let’s put implementation concerns aside for now).</p>\n<p>It seems reasonable to let <code>#find</code> to take a sequence of “search predicates” (conclusion patterns, subexpression patterns,  and later more things like searching for lemma name). What would be a good way to distinguish a conclusion pattern (<code>( _ &gt; _)</code> in the examples below) from the subexpression pattern (<code>(_ + (_ * _))</code> in the example below)?</p>\n<p>I have some ideas, neither of which is really great:</p>\n<ol>\n<li>\n<p>The default could be “subset pattern”, and a conclusion pattern could be marked by prefixing it with <code>|-</code>:<br>\n<code>\n   #find |- (_ &gt; _) (_ + (_ * _))\n   </code><br>\n   A variant proposed by Eric is <code>_ -&gt; pat</code> for conclusion patterns.</p>\n</li>\n<li>\n<p>The default could be conclusion pattern, and a subset pattern could be written as <code>_ (_ &gt; _)</code>, which kinda makes sense if we interpret <code>_</code> as “arbitrary context” (and because <code>_ e</code> isn't legal otherwise).<br>\n<code>\n   #find (_ &gt; _) (_ (_ + (_ * _)))\n   </code></p>\n</li>\n<li>\n<p>Non-symbolic explicit qualifiers for both (with subexpression matching the default if no qualifier is used)?<br>\n<code>\n   #find concludes: (_ &gt; _) contains: (_ + (_ * _))\n   </code></p>\n</li>\n<li>\n<p>Make an educated guess based on the type of the pattern – if it is <code>Prop</code>, treat it as a conclusion pattern, else a subexpression pattern.</p>\n</li>\n<li>Any other ideas?</li>\n</ol>\n<p>I lean towards interpreting patterns as subexpression pattern by default, as it is the more permissive – it’ll likely give you the result you want, and only if you notice that the result list is too long you’ll likely want to refine.</p>",
        "id": 379975819,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1690709635
    },
    {
        "content": "<p>Does <code>_ →pattern</code> make sense as an explicit conclusion pattern?</p>",
        "id": 379988784,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1690712965
    },
    {
        "content": "<p>Yes, I think so. In so far as the cases where you are trying to use <code>_ → pat</code> as  a subexpression  pattern are probably at least rare.<br>\nSo presumably any <code>foo → bar</code> pattern is then interpreted as  a conclusion-pattern-with-premise.</p>",
        "id": 379995517,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1690714459
    }
]