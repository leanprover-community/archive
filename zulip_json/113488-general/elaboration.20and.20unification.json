[
    {
        "content": "<p>Can someone suggest a good reference for learning more about what exactly is meant by 'elaboration' and 'unification'? I have a vague feel for what they are but would like to learn more.</p>",
        "id": 218174888,
        "sender_full_name": "Paul van Wamelen",
        "timestamp": 1606587693
    },
    {
        "content": "<p>My very vague understanding of what's going on here is that in principle elaboration and unification are just the study of filling in certain kinds of blanks. For example when you <code>apply</code> some theorem of the form a = b to a goal of <code>f x = 37</code> the elaborator figures out that a is going to be f x and b is going to be 37. However the issue is that sometimes the elaborator has to solve a gigantic logic problem, and how it solves it is very system specific, so now I have to start talking about Lean and because I'm just going from experience rather than reading the C++ code or meta Lean code (neither of which I understand) things will now start to get hazier.</p>\n<p>Lean has this attribute system, where you can just stick a \"tag\" like <code>simp</code> or <code>no_lint docstring</code> or <code>irreducible</code> or even a tag which you made up yourself, onto a definition or theorem. These tags don't change the definition or theorem in any way, but they change the way various internal systems treat the definition or theorem. For example tagging a theorem with <code>simp</code> makes the simplifier aware of it. There are several tags which you can attach to things which change the way Lean elaborates them, for example <code>elab_as_eliminator</code> or <code>elab_simple</code>, and these slightly change the way the (presumably rather complicated) elaborator works when it's trying to fill in all the <code>{}</code> and <code>_</code> gaps in the term which it's trying to complete. We've seen examples recently where elaboration can fail for all sorts of obscure reasons, and then someone like Mario or Reid or one of the other people who _do_ know what's going on comes along and suggests a very minor tweak and all of a sudden things are working again.</p>",
        "id": 218175320,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1606588430
    },
    {
        "content": "<p>Isn't \"figures out that a is going to be f x and b is going to be 37\" unification? And elaboration is basically filling in underscores and other stuff that the user didn't supply explicitly?<br>\nAre there some settings or traces that can show me what elaboration does?</p>",
        "id": 218175568,
        "sender_full_name": "Paul van Wamelen",
        "timestamp": 1606588839
    },
    {
        "content": "<p>Elaboration is the whole proof script -&gt; proof process, which includes unification, type class inference, and running tactics</p>",
        "id": 218175621,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1606588947
    },
    {
        "content": "<p>unification is specifically \"A : T needs to have type T' here so T = T' and therefore this and that metavariable can be assigned\"</p>",
        "id": 218175634,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1606589032
    },
    {
        "content": "<p>Bumping an old thread: What is the best source for learning how elaboration works?  For simplicity, let's restrict to contexts in which no typeclasses are involved -- but there are still lambdas, structures, implicit arguments, etc:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">pow_two_pos_of_ne_zero</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">@_</span><span class=\"n\">root_</span><span class=\"bp\">.</span><span class=\"n\">pow_two_pos_of_ne_zero</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">sub_eq_zero</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">@_</span><span class=\"n\">root_</span><span class=\"bp\">.</span><span class=\"n\">sub_eq_zero</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Point</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span>\n<span class=\"w\">  </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Point</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Point</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"c1\">-- how does this proof term get typechecked</span>\n<span class=\"w\">  </span><span class=\"c1\">-- (and how are the implicit arguments determined?)</span>\n<span class=\"w\">  </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">pow_two_pos_of_ne_zero</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">hp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Iff</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">sub_eq_zero</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 472071909,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1727029294
    },
    {
        "content": "<p>If there's a resource which is about Coq, Haskell, Isabelle, or some simplified teaching language, I think that would be fine for me -- I would like to learn the general principles, not necessarily literally how it is done in Lean.</p>",
        "id": 472072072,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1727029440
    },
    {
        "content": "<p>In the future it should be the Lean reference manual, but for now I'm not sure. (Yesterday <a href=\"#narrow/stream/113489-new-members/topic/.E2.9C.94.20Strange.20type.20inference.20error.2Finconsistency/near/471969886\">I wrote</a> an explanation of a different elaboration example, in case that's helpful.)</p>",
        "id": 472072163,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727029488
    },
    {
        "content": "<p>By the way, I'm aware of the article <a href=\"https://arxiv.org/abs/1505.04324\">Elaboration in Dependent Type Theory</a> which is about Lean 2 -- how far is this from Lean 3/4?</p>",
        "id": 472072226,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1727029522
    },
    {
        "content": "<p>I'm not sure, but skimming through, (1) for defeq only similarity might be <em>that</em> there's unification, and all the details are probably different, including higher-order unification, which is much much simpler now and (2) now elaboration can postpone many problems until later until more information comes in.</p>",
        "id": 472072467,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727029700
    },
    {
        "content": "<p>OK, so quite far :)</p>",
        "id": 472072509,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1727029763
    },
    {
        "content": "<p>Here's a slightly simplified explanation of your example:</p>\n<ul>\n<li>We encounter the application <code>Real.pow_two_pos_of_ne_zero fun h ↦ hp (Iff.mp Real.sub_eq_zero h)</code> with expected type <code>f p &gt; 0</code>. We see it has function <code>Real.pow_two_pos_of_ne_zero</code> and positional argument list <code>[fun h ↦ hp (Iff.mp Real.sub_eq_zero h)]</code>.<ul>\n<li>We see that the function is a constant. We resolve the constant, getting that it is the theorem <code>Real.pow_two_pos_of_ne_zero</code> whose type is <code>∀ {a : ℝ}, a ≠ 0 → 0 &lt; a ^ 2</code>. Set expression <code>e</code> to this theorem.</li>\n<li>We begin processing the parameters to the function one at a time.<ul>\n<li>Parameter <code>{a : ℝ}</code>. This is implicit. We create a fresh metavariable <code>?a</code> and update <code>e</code> to be <code>e ?a</code>.</li>\n<li>Parameter <code>(_ : a ≠ 0)</code>. This is explicit.<ul>\n<li>Since it is the first explicit parameter, we try using the expected type to propagate type information. We try unifying <code>0 &lt; ?a ^ 2 =?= f p &gt; 0</code>. This causes <code>&gt;</code> to unfold to <code>0 &lt; f p</code>, and then this reduces to <code>?a ^ 2 =?= f p</code>. This causes <code>f</code> to unfold, reducing to <code>?a ^ 2 =?= (p.x - p.y) ^ 2</code>. This reduces to <code>?a =?= p.x - p.y</code>, and we ultimately get a solution <code>?a := p.x - p.y</code>.</li>\n<li>Now substituting <code>?a</code> for <code>a</code> in the parameter's type, we know the type of the argument needs to be <code>p.x - p.y ≠ 0</code>.</li>\n<li>We consume the next positional argument, which is <code>fun h ↦ hp (Iff.mp Real.sub_eq_zero h)</code> and elaborate it with expected type <code>p.x - p.y ≠ 0</code>.<ul>\n<li>The <code>fun</code> elaborator expects the expected type to be a pi type. This causes the expected type to unfold to <code>p.x - p.y = 0 -&gt; False</code>.</li>\n<li>We create a local variable <code>h</code> of type <code>p.x - p.y = 0</code> and elaborate <code>hp (Iff.mp Real.sub_eq_zero h)</code> with expected type <code>False</code>. <em>Skipping these details...</em> this happens, yielding an expression <code>e'</code>. We then abstract <code>h</code> out of <code>e'</code> and create a function expression <code>fun h : p.x - p.y = 0 =&gt; e'</code> (where this <code>e'</code> here is referring to the bvar h instead of the fvar h). Call this function expression <code>arg</code>.</li>\n</ul>\n</li>\n<li>With the positional argument elaborated as some expression <code>arg</code>, we update <code>e</code> to be <code>e arg</code>.</li>\n</ul>\n</li>\n<li>There are no more parameters.</li>\n</ul>\n</li>\n<li>Now we finalize the application. The result is the value of <code>e</code>, which is <code>@Real.pow_two_pos_of_ne_zero (p.x - p.y) arg</code>.</li>\n</ul>\n</li>\n</ul>",
        "id": 472073549,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727030596
    },
    {
        "content": "<p>This is really helpful.  Thank you, Kyle!</p>",
        "id": 472073947,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1727030869
    },
    {
        "content": "<p>I would still be very happy to receive recommendations for \"general reading\", if anyone has them.  I've started reading the <em>Elaboration in Dependent Type Theory</em> article and this is also useful so far.</p>",
        "id": 472074125,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1727030953
    },
    {
        "content": "<p>By the way, what part of the <code>lean4</code> codebase handles this?  I'm pretty sure reading this code is above my paygrade, but even so I would like to take a look.</p>",
        "id": 472074545,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1727031162
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113488-general/topic/elaboration.20and.20unification/near/472073549\">said</a>:</p>\n<blockquote>\n<p>Here's a slightly simplified explanation of your example:</p>\n</blockquote>\n<p>that's <em>very</em> insightful. i'd love to be able to read more details about what kind of problems can or need to be postponed when...</p>",
        "id": 472074811,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727031286
    },
    {
        "content": "<p>The most pervasive one is typeclass instances. It tries to synthesize immediately, but if it's able to blame a failure on metavariables, it'll put it into a work list for later.</p>\n<p>Another is <code>by</code> notation. If the expected type has metavariables, it again puts itself onto a work list for later.</p>",
        "id": 472075214,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727031519
    },
    {
        "content": "<p><code>if c then a else b</code> notation postpones if <code>c</code>'s type is a(n application of a) metavariable.</p>",
        "id": 472075323,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727031613
    },
    {
        "content": "<p>Custom elaborators can decide to postpone if they decide there isn't enough information to continue yet. Eventually they'll be forced to decide to continue anyway (like what <code>by</code> does) or throw an error (like what <code>@[elab_as_elim]</code> does).</p>",
        "id": 472075483,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727031749
    },
    {
        "content": "<p>Thanks Kyle. Here goes an apology to all the times I've called Lean names for being too slow <span aria-label=\"snail\" class=\"emoji emoji-1f40c\" role=\"img\" title=\"snail\">:snail:</span></p>",
        "id": 472084544,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1727039312
    },
    {
        "content": "<p>You can also enable tracing for elaboration (<code>set_option trace.Elab true</code> doesn't work, but enabling <code>trace.Elab.app</code> and <code>trace.Elab.step</code> seems to work ok), and for unification (<code>set_option trace.Meta.isDefEq true</code>) to get an idea of what's going on in specific instances</p>",
        "id": 472113327,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1727058784
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/113488-general/topic/elaboration.20and.20unification/near/472074125\">said</a>:</p>\n<blockquote>\n<p>I would still be very happy to receive recommendations for \"general reading\", if anyone has them.  I've started reading the <em>Elaboration in Dependent Type Theory</em> article and this is also useful so far.</p>\n</blockquote>\n<p>For general reading, I can recommend Adam Gundry's PhD dissertation on \"Type Inference, Haskell and Dependent Types\" and available on <a href=\"https://adam.gundry.co.uk/pub/thesis/\">his website</a>. I like his presentation because it starts simply: unification for a Hindley-Milner type system (just lambdas, variables and let-generalisation), makes a connection to elaboration and builds incrementally to the dependently typed setting. For his reconstruction of HM type inference alone, I am often returning to the relevant chapters.</p>\n<p>I would also be interested in additional resources on the topic. I can't recall any other relatively self-contained account of elaboration, type inference, and unification.</p>",
        "id": 472152912,
        "sender_full_name": "Craig McLaughlin",
        "timestamp": 1727076910
    },
    {
        "content": "<p>Thank you! I'll check it out.</p>",
        "id": 472205029,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1727091725
    }
]