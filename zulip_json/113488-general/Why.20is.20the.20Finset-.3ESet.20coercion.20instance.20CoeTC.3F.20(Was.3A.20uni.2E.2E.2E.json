[
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/1555\">#1555</a> (the PR where it was introduced) contains no explanation</p>",
        "id": 479357845,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1730148803
    },
    {
        "content": "<p>It looks like it was inherited straight from <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.set.has_coe_t\">docs3#finset.set.has_coe_t</a></p>",
        "id": 479357966,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1730148854
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/113488-general/topic/unification.20hints/near/479357560\">said</a>:</p>\n<blockquote>\n<p>Incidentally, why is <code>Finset.instCoeTCSet</code> a <code>CoeTC</code>? That's a nonstandard, since it's meant to be the transitive closure of <code>Coe</code>.</p>\n</blockquote>\n<p>I was wondering about that too earlier. It turns out there are hundreds of these in Mathlib and I don't think any of them should exist. At the very least, they're really confusing when trying to parse a <code>Coe*</code> synthesis trace.</p>",
        "id": 479363899,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1730151541
    },
    {
        "content": "<p>(It would be great having some clear guidance on when to use which coercion class — I still have a lot of uncertainty about this!)</p>",
        "id": 479364432,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730151846
    },
    {
        "content": "<p>I know the feeling! Since I only think about this once in a while, I find that I need to relearn the entire hierarchy every time. I think the main entry points are <code>Coe</code>, <code>CoeHead</code>, <code>CoeTail</code>, <code>CoeDep</code>, and everything else is internal.</p>",
        "id": 479365070,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1730152215
    },
    {
        "content": "<p>(We should probably move this since it's been established that unification hints are not useful for this issue.)</p>",
        "id": 479365310,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1730152374
    },
    {
        "content": "<p>6 messages were moved here from <a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/channel/113488-general/topic/unification.20hints\">#general &gt; unification hints</a> by <span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span>.</p>",
        "id": 479366451,
        "sender_full_name": "Notification Bot",
        "timestamp": 1730152971
    },
    {
        "content": "<p>Those are at least all mentioned in the source code, the module doc is helpful, but it would be really nice to have design guidance. When do you create a CoeHead vs a CoeOut vs a Coe vs a CoeTail? The docs mention something about CoeOut being for when there are more parameters in what's being coerced, but why?</p>\n<p>(CoeDep makes sense at least, since it's what you need if your coercion should depend on the value.)</p>",
        "id": 479366742,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730153120
    },
    {
        "content": "<p>What are examples of what the semiOutParams do? (Why don't semiOutParams do anything if you define <code>Finset.instCoeTCSet</code> as a <code>CoeHead</code>/<code>CoeOut</code> with the <code>((s : Finset Nat) : Set _)</code> example?)</p>",
        "id": 479366901,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730153210
    },
    {
        "content": "<p>They're called from <code>CoeT</code>, which has ordinary parameters. So, even though there are semiOutParams along the way, they still can't assign mvars at the final step.</p>",
        "id": 479367640,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1730153636
    },
    {
        "content": "<p>FWIW, I think the whole <code>Coe*</code> system is predicated on the output type being (almost) fully known. So any coercion where the output type has an unassigned mvar is likely to fail in the same way.</p>",
        "id": 479368304,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1730153999
    },
    {
        "content": "<p>I suppose the expectation is that users would fill-in the unassigned mvars when necessary.</p>",
        "id": 479368462,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1730154050
    },
    {
        "content": "<p>I see, the <code>semiOutParam</code> is to get the chaining to work</p>",
        "id": 479370238,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730154678
    }
]