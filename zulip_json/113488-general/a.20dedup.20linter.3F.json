[
    {
        "content": "<p>Another problem I came across is that<br>\n<a href=\"https://github.com/leanprover-community/mathlib/blob/c25280031da754d1731b31e81426ab2f8fe218d0/src/algebra/ring/basic.lean#L584\">https://github.com/leanprover-community/mathlib/blob/c25280031da754d1731b31e81426ab2f8fe218d0/src/algebra/ring/basic.lean#L584</a><br>\nand <a href=\"https://github.com/leanprover-community/mathlib/blob/c25280031da754d1731b31e81426ab2f8fe218d0/src/algebra/ring/basic.lean#L624\">https://github.com/leanprover-community/mathlib/blob/c25280031da754d1731b31e81426ab2f8fe218d0/src/algebra/ring/basic.lean#L624</a><br>\nhave exactly the same statement. How do we decide which name and proof are better and de-duplicate them? (Both are used, one right below, the other in algebra/group_power.)</p>",
        "id": 206951767,
        "sender_full_name": "Junyan Xu (inactive)",
        "timestamp": 1597424283
    },
    {
        "content": "<p>We should have a lint for this</p>",
        "id": 206951963,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597424381
    },
    {
        "content": "<p>I would keep <code>mul_self_sub_mul_self</code> (both name and proof)</p>",
        "id": 206952071,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597424414
    },
    {
        "content": "<p>We ran into one of these yesterday at Xena: something like <code>mul_left_cancel_iff</code> = <code>mul_right_inj</code> (with the same proof) in algebra.groups.defs (lines 132, 140)</p>",
        "id": 206952889,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597424872
    },
    {
        "content": "<p>I think that there are some deliberate aliases along those lines though</p>",
        "id": 206955532,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597426324
    },
    {
        "content": "<p>Can the linter require the deliberate aliases be written with <code>abbreviation</code>?</p>",
        "id": 206969816,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1597433989
    },
    {
        "content": "<p>they should be written using <code>alias</code></p>",
        "id": 206972824,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597434669
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125393\">@Junyan Xu</span> GitHub Actions will try to build your branch as soon as you push. That will tell you if it works or not <span aria-label=\"smiling face\" class=\"emoji emoji-263a\" role=\"img\" title=\"smiling face\">:smiling_face:</span>️</p>",
        "id": 207000663,
        "sender_full_name": "Chris Wong",
        "timestamp": 1597457785
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/Starting.20to.20contribute.20to.20mathlib/near/206951963\">said</a>:</p>\n<blockquote>\n<p>We should have a lint for this</p>\n</blockquote>\n<p>I guess the most obvious way to implement is to try to prove every statement with <code>library_search</code>, and complain if it finds a proof <code>by exact foo</code>?<br>\n<span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> <br>\nIs the less-powerful mode of library search cheap enough for this? (would it require an even weaker mode to get the behavior we want?)</p>\n<p>I guess this only helps if one of the files with the duplicate declaration imports the other. I expect that's true in a large fraction of cases?</p>",
        "id": 207092114,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1597615426
    },
    {
        "content": "<p>That's way too expensive. The simple option is to throw everything in an <code>expr_map</code> and check for duplicates, but I think that will have false negatives</p>",
        "id": 207094740,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597619659
    },
    {
        "content": "<p><del>is there a notion of bounded definitional equality that's cheap enough to compute and gets rid of most of the false negatives?</del><br>\nI think i don't have a model for what your false negative looks like. </p>\n<p>Do you want the linter to catch two instances of the same lemma, but with the Prop arguments in a different order?</p>",
        "id": 207095707,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1597621514
    },
    {
        "content": "<p>What we want to avoid is anything that is O(n^2)</p>",
        "id": 207098954,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597627372
    },
    {
        "content": "<p>False negatives here are because the expr ordering is fairly strict and might not pick up on theorems that we would say are the same but differ in some behind the scenes detail like variable names</p>",
        "id": 207099022,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597627443
    },
    {
        "content": "<p>This topic was moved here from <a class=\"stream-topic\" data-stream-id=\"113489\" href=\"/#narrow/stream/113489-new-members/topic/Starting.20to.20contribute.20to.20mathlib\">#new members &gt; Starting to contribute to mathlib</a> by <span class=\"user-mention silent\" data-user-id=\"252300\">Jalex Stark</span></p>",
        "id": 207100470,
        "sender_full_name": "Notification Bot",
        "timestamp": 1597629912
    },
    {
        "content": "<p>This topic was moved by <span class=\"user-mention silent\" data-user-id=\"252300\">Jalex Stark</span> to <a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/stream/113488-general/topic/a.20dedup.20linter.3F\">#general &gt; a dedup linter?</a></p>",
        "id": 207100471,
        "sender_full_name": "Notification Bot",
        "timestamp": 1597629912
    },
    {
        "content": "<p>okay, so I guess we can a little bit farther by computing a normal form for <code>expr</code>s that forgets variable names. informally speaking, the algorithm is like <br>\nFix a canonical infinite list of names. <br>\nfor a given expr, put an order on the variables names by traversing the expr tree and writing them down in the order you see them<br>\nrename the nth variable in this expr list to the nth variable in the canonical list</p>",
        "id": 207101856,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1597632208
    },
    {
        "content": "<p>but this approach doesn't seem like it will get you to a much coarser notion of equivalence than this uh \"syntactic equality up to renaming variables\"</p>",
        "id": 207101911,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1597632286
    },
    {
        "content": "<p>I think <code>expr.lt</code> already does something like this. I would try just using it and see if it needs tweaking after</p>",
        "id": 207103190,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597634288
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"252300\">@Jalex Stark</span> Maybe you can make all variables explicit during this step, because that might be another source of \"the same, but not syntactially so\"</p>",
        "id": 207104505,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1597636140
    },
    {
        "content": "<p>And if the order of two assumptions doesn't matter to the type checker, sort them by their types. That might take care of permutations of the variables.</p>",
        "id": 207104567,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1597636213
    },
    {
        "content": "<p>Initially with that suggestion I was worried about dependence of later args on earlier ones. But we're just trying to construct a function on <code>expr</code> whose preinages form the right equivalence relation. We don't need the image to be something we can elaborate! (I'll not sure \"elaborate\" is the right concept.)</p>",
        "id": 207126110,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1597658981
    },
    {
        "content": "<p><code>expr.alpha_eqv</code> compares expressions ignoring binder type and bound variable names. </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"kn\">eval</span> <span class=\"n\">expr</span><span class=\"bp\">.</span><span class=\"n\">alpha_eqv</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">},</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 207126614,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1597659441
    },
    {
        "content": "<p>I guess the next step is to peek into the implementation of <code>expr.alpha_eqv</code> and see whether it is already computing normal form <code>expr</code>s and checking <code>expr</code> equality, since that's really what's needed for the linter.</p>",
        "id": 207198748,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1597699148
    }
]