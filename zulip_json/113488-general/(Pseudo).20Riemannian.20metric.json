[
    {
        "content": "<p>I have been making some attempts on and off over the last months, with an initial goal of implementing an InnerProductspace on a Riemannian metric .</p>\n<p>This has been PR'd to PhysLean here <a href=\"https://github.com/HEPLean/PhysLean/pull/501\">https://github.com/HEPLean/PhysLean/pull/501</a>:</p>\n<p><a href=\"https://github.com/HEPLean/PhysLean/blob/caf4d53e75b3fac17a7c2799e6575029188e2ee9/PhysLean/Mathematics/Geometry/Metric/PseudoRiemannian/Defs.lean\">https://github.com/HEPLean/PhysLean/blob/caf4d53e75b3fac17a7c2799e6575029188e2ee9/PhysLean/Mathematics/Geometry/Metric/PseudoRiemannian/Defs.lean</a></p>\n<p><a href=\"https://github.com/HEPLean/PhysLean/blob/caf4d53e75b3fac17a7c2799e6575029188e2ee9/PhysLean/Mathematics/Geometry/Metric/Riemannian/Defs.lean\">https://github.com/HEPLean/PhysLean/blob/caf4d53e75b3fac17a7c2799e6575029188e2ee9/PhysLean/Mathematics/Geometry/Metric/Riemannian/Defs.lean</a></p>\n<p>The files can also be found here (i've tried them on latest <strong><em>stable</em></strong> mathlib 4.18):<br>\n<a href=\"/user_uploads/3121/c5HdS7oMyRkVskBJuqlUlytk/PseudoRiemannianRiemannian.lean\">PseudoRiemannian+Riemannian.lean</a></p>\n<p>I've tried a pragmatic approach aimed at development within PhysLean. I'm aware the ideal formalization would be as a section of tensor bundles and would like to generalise it in that direction at some point (or even better if someone else could do it), but wanted to avoid, at first, an escalation of complications like those mentioned in previous discussions. </p>\n<p>I thought this could first be a PR to PhysLean, which is the natural context where I would like to build over this framework, but would be happy of course, if this at some point could be fit for Mathlib.</p>\n<p>A first revision came after reading <span class=\"user-mention\" data-user-id=\"110050\">@S√©bastien Gou√´zel</span> in this post (<a href=\"#narrow/channel/113489-new-members/topic/Don't.20understand.20TangentBundle.20.26.20sections\">#new members &gt; Don't understand TangentBundle &amp; sections</a> and a second came after realizing the need to add a constraint for constant index, after a closer reading of O'Neill 'SemiRiemannian Geometry with applications to Relativity'.</p>\n<p>I'd greatly appreciate critical feedback and hope this could, at least in the short term, fill a gap and trigger further development. :)</p>\n<p>Previous discussions:<br>\n<a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/channel/287929-mathlib4/topic/Extend.20manifold.20smoothness/with/485812135\">#mathlib4 &gt; Extend manifold smoothness</a> <br>\n<a class=\"stream-topic\" data-stream-id=\"217875\" href=\"/#narrow/channel/217875-Is-there-code-for-X.3F/topic/Tensor.20product.20vector.20bundle/with/419045346\">#Is there code for X? &gt; Tensor product vector bundle</a> <br>\n<a class=\"stream-topic\" data-stream-id=\"217875\" href=\"/#narrow/channel/217875-Is-there-code-for-X.3F/topic/Riemannian.20manifolds/with/418252814\">#Is there code for X? &gt; Riemannian manifolds</a> <br>\n<a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/channel/287929-mathlib4/topic/Topology.20on.20sets.20with.20manifold.20structure/with/379320187\">#mathlib4 &gt; Topology on sets with manifold structure</a> <br>\n<a class=\"stream-topic\" data-stream-id=\"113489\" href=\"/#narrow/channel/113489-new-members/topic/Formalizing.20Riemannian.20geometry/with/376231280\">#new members &gt; Formalizing Riemannian geometry</a> <br>\n<a class=\"stream-topic\" data-stream-id=\"116395\" href=\"/#narrow/channel/116395-maths/topic/Fiber.20bundles/with/369308565\">#maths &gt; Fiber bundles</a> <br>\n<a href=\"#narrow/channel/116395-maths/topic/.5Bhelp.20needed.5D.20how.20to.20synthesis.20the.20inner.20from.20TangentSpace\">#maths &gt; &#91;help needed&#93; how to synthesis the inner from TangentSpace</a></p>",
        "id": 514930210,
        "sender_full_name": "Matteo Cipollina",
        "timestamp": 1745888516
    },
    {
        "content": "<p>+1 for the comprehensive list of links to previous discussions!</p>",
        "id": 514984991,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1745912471
    },
    {
        "content": "<p>Nice! Wow, it's been a couple of years since I last looked at this. I'd love to resurrect <span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span>'s proof-of-concept branch. Will see if I can work on porting it to Lean 4 in the next couple of weeks and try to fill in the <code>sorry</code>s (e.g. show that every smooth manifold admits a Riemannian metric... I know the earlier discussion said to do this with partitions of unity, but it would be nice to cheat and use the strong Whitney embedding theorem if it were actually available...). I appreciate your generalization to pseudo-Riemannian metrics as well, will have to add that in.</p>",
        "id": 517038902,
        "sender_full_name": "Michael Lee",
        "timestamp": 1746772352
    },
    {
        "content": "<p>Ages ago, I tried porting that branch myself (and didn't get very far). In case that helps, feel free to look at <a href=\"https://github.com/leanprover-community/mathlib4/tree/MR-hr-RiemannianMetric\">branch#MR-hr-RiemannianMetric</a> (lots of errors) and <a href=\"https://github.com/leanprover-community/mathlib4/tree/MR-Riemannian-metric\">branch#MR-Riemannian-metric</a> (no errors, but didn't get far).</p>",
        "id": 517076185,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1746785527
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"633028\">Michael Lee</span> <a href=\"#narrow/channel/113488-general/topic/.28Pseudo.29.20Riemannian.20metric/near/517038902\">said</a>:</p>\n<blockquote>\n<p>Nice! Wow, it's been a couple of years since I last looked at this. I'd love to resurrect <span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span>'s proof-of-concept branch. Will see if I can work on porting it to Lean 4 in the next couple of weeks and try to fill in the <code>sorry</code>s (e.g. show that every smooth manifold admits a Riemannian metric... I know the earlier discussion said to do this with partitions of unity, but it would be nice to cheat and use the strong Whitney embedding theorem if it were actually available...). I appreciate your generalization to pseudo-Riemannian metrics as well, will have to add that in.</p>\n</blockquote>\n<p>I'm guessing Mathlib has partitions of unity then?</p>",
        "id": 517137645,
        "sender_full_name": "Dominic Steinitz",
        "timestamp": 1746804505
    },
    {
        "content": "<p>Continuous ones at least: <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Topology/PartitionOfUnity.html\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Topology/PartitionOfUnity.html</a></p>",
        "id": 517138650,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1746804791
    },
    {
        "content": "<p>Although for the existence of a Riemannian metric, a smooth one is needed.</p>",
        "id": 517142493,
        "sender_full_name": "Dominic Steinitz",
        "timestamp": 1746806042
    },
    {
        "content": "<p>It also has smooth partitions of unity.</p>",
        "id": 517142778,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1746806141
    },
    {
        "content": "<p>In this file, I assume? <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Geometry/Manifold/PartitionOfUnity.html\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Geometry/Manifold/PartitionOfUnity.html</a></p>",
        "id": 517142949,
        "sender_full_name": "Ben Eltschig",
        "timestamp": 1746806185
    },
    {
        "content": "<p>And this is really the way to prove existence of Riemannian metrics. Morally it has nothing to do with embedding results.</p>",
        "id": 517142973,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1746806197
    },
    {
        "content": "<p>We simply need a version of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=exists_smooth_forall_mem_convex_of_local#doc\">docs#exists_smooth_forall_mem_convex_of_local</a> for non-trivial vector bundles.</p>",
        "id": 517143102,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1746806247
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/channel/113488-general/topic/.28Pseudo.29.20Riemannian.20metric/near/517142973\">said</a>:</p>\n<blockquote>\n<p>And this is really the way to prove existence of Riemannian metrics. Morally it has nothing to do with embedding results.</p>\n</blockquote>\n<p>Excellent news and I agree it would be going against the grain to use an embedding.</p>",
        "id": 517143180,
        "sender_full_name": "Dominic Steinitz",
        "timestamp": 1746806275
    },
    {
        "content": "<p>Note that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=exists_smooth_forall_mem_convex_of_local#doc\">docs#exists_smooth_forall_mem_convex_of_local</a> and its variants are on of my favorite examples of wonderful statements that I learned from formalized mathematics and don‚Äôt exist in the real world. It really says what partitions of unity will do for you instead of simply repeating endlessly the same argument.</p>",
        "id": 517143875,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1746806478
    },
    {
        "content": "<p>And here for instance it really points out the difference between Riemannian and semi-Riemannian cases. The key is that positive definite bilinear products form a convex set, whereas this isn‚Äôt true for other signatures.</p>",
        "id": 517144135,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1746806542
    },
    {
        "content": "<p>I've added a new file<br>\nPseudoRiemannian/Chart.lean at<br>\n<a href=\"https://github.com/HEPLean/PhysLean/blob/21f522bea68644a7c500ffb3aeb9104792d9de7d/PhysLean/Mathematics/Geometry/Metric/PseudoRiemannian/Chart.lean\">https://github.com/HEPLean/PhysLean/blob/21f522bea68644a7c500ffb3aeb9104792d9de7d/PhysLean/Mathematics/Geometry/Metric/PseudoRiemannian/Chart.lean</a> <br>\nwhich defines the components of a pseudo-Riemannian metric in local chart coordinates (chartMetric g e y). The main result is¬†chartMetric_coord_change, proving tensor transformation law under coordinate changes:¬†chartMetric g e (e x) = pullback (chartMetric g e' (e' x)) (mfderiv I I (e.symm.trans e') (e x)). This builds on the¬†Defs.lean¬†for pseudo-Riemannian metrics and several helpers lemmas that I could not find in Mathlib and that have grouped in hypothetical Mathlib modules: Analysis.ContDiff; LinearAlgebra.BilinearForm; Geometry.Manifold.PartialHomeomorph; Geometry.Manifold.Chart.Utilities, Smoothness, BilinearSmoothnes, CoordinateTransformations). <br>\n<a href=\"https://github.com/HEPLean/PhysLean/pull/501/commits/21f522bea68644a7c500ffb3aeb9104792d9de7d\">https://github.com/HEPLean/PhysLean/pull/501/commits/21f522bea68644a7c500ffb3aeb9104792d9de7d#</a><br>\nThanks <span class=\"user-mention\" data-user-id=\"633028\">@Michael Lee</span> , it would be great to join efforts and work in parallel on the old proof of concept (thanks @MichaelRothgang for sharing it, I couldn't find it anywhere), connect it to this level and prove the existence of the Riemannian metric via partitions of unity at some point</p>",
        "id": 517163042,
        "sender_full_name": "Matteo Cipollina",
        "timestamp": 1746813637
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"634338\">Michael Rothgang</span> <a href=\"#narrow/channel/113488-general/topic/.28Pseudo.29.20Riemannian.20metric/near/517076185\">said</a>:</p>\n<blockquote>\n<p>Ages ago, I tried porting that branch myself (and didn't get very far). In case that helps, feel free to look at <a href=\"https://github.com/leanprover-community/mathlib4/tree/MR-hr-RiemannianMetric\">branch#MR-hr-RiemannianMetric</a> (lots of errors) and <a href=\"https://github.com/leanprover-community/mathlib4/tree/MR-Riemannian-metric\">branch#MR-Riemannian-metric</a> (no errors, but didn't get far).</p>\n</blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/tree/michaellee94%2Friemannian\">branch#michaellee94/riemannian</a> should at least get us to parity with Heather's branch. I'll work on filling in the <code>sorry</code>s soon (my wife and I are moving house in a couple of days, so things might be hectic for a minute, but I'm determined to finish this!).</p>",
        "id": 517420766,
        "sender_full_name": "Michael Lee",
        "timestamp": 1747019648
    },
    {
        "content": "<p>My 2 cents as a lean newbie having some background in Riemannian Geometry (though that is a few years ago, I made my PhD in 2002 ;-)): I think we need to introduce tensor bundles in the form of multilinear maps from k factors of TM and l factors of T*M to k (or R/C) to really make a step forward.</p>\n<p>In general, we need the tensor bundles to define:</p>\n<ol>\n<li>Metrics as (2,0) tensors</li>\n<li>The Riemmanian curvature as (3,1) tensor</li>\n<li>Ricci curvature as (2,0) tensor</li>\n<li>Torsion of an affine connection as (2,1) tensor (this is necessary to introduce the Levi-Civita connection  which is torsion-free and the basis for (Pseudo-) Riemannian Geometry.</li>\n<li>Differential forms as alternating (k,0) tensors. (And go to deRham cohomology from there....)</li>\n</ol>\n<p>And potentially a few more, but that's more than enough....</p>\n<p>I thought of defining a VectorBundleCore with a subtype of MultiLinearMap  as fibres based on the TangentBundle. The construction could be done based on any vector bundle, but in practice, we would only need multilinear maps / tensors on the tangent bundle.</p>\n<p>One could also introduce a general notion of general tensor products for vector bundles, but that's probably much more complex, and probably not needed at all for differential geometry.</p>\n<p>Based on this, we could consider metrics \"just\" as a special case (k = 2, l = 0) of the tensor bundle. </p>\n<p>Maybe it's only slightly more complex to create such a tensor bundle instead of the cotangent bundle as bundle of linear maps to k, metrics as bilinear maps to k etc.</p>\n<p>Having said that - I'm not yet able to deal with VectorBundleCore, so I'm probably (surely) missing subtle details of the implementation....</p>",
        "id": 517817712,
        "sender_full_name": "Jens Lindekamp",
        "timestamp": 1747139506
    },
    {
        "content": "<p>If one restricts to finite dimensions, does anyone know if the complications of defining tensor products of vector bundles go away?</p>",
        "id": 517821447,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1747140464
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"653351\">Joseph Tooby-Smith</span> <a href=\"#narrow/channel/113488-general/topic/.28Pseudo.29.20Riemannian.20metric/near/517821447\">said</a>:</p>\n<blockquote>\n<p>If one restricts to finite dimensions, does anyone know if the complications of defining tensor products of vector bundles go away?</p>\n</blockquote>\n<p>Working with vector bundles in Mathlib right now is currently doable but definitely not easy. I don't think that assuming finite-dimensionality will make it easier to work with them.</p>",
        "id": 517822661,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1747140732
    },
    {
        "content": "<p>c.f. <span class=\"user-mention\" data-user-id=\"900335\">@Jens Lindekamp</span>'s last comment: </p>\n<p>I for one would be very interested in seeing the ability of general tensor products for vector bundles, since it would allow for lots of applications in PhysLean (GR and tensor products of fields in particle physics etc.). In particular one could generalize in the mathematically correct way to do index notation from tensors to tensor fields.</p>",
        "id": 517822948,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1747140809
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/channel/113488-general/topic/.28Pseudo.29.20Riemannian.20metric/near/517822661\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"653351\">Joseph Tooby-Smith</span> <a href=\"#narrow/channel/113488-general/topic/.28Pseudo.29.20Riemannian.20metric/near/517821447\">said</a>:</p>\n<blockquote>\n<p>If one restricts to finite dimensions, does anyone know if the complications of defining tensor products of vector bundles go away?</p>\n</blockquote>\n<p>Working with vector bundles in Mathlib right now is currently doable but definitely not easy. I don't think that assuming finite-dimensionality will make it easier to work with them.</p>\n</blockquote>\n<p>I guess I'm not asking from the point of view of Mathlib, but rather the point of view of the maths in developing the theory further.</p>\n<p>I guess I'm asking the following: <br>\nIs there an \"easy\" definition of the tensor product of vector bundles in the finite dimensional case that we could develop and work with in e.g. PhysLean, until Mathlib has the completely general case. </p>\n<p>Reading <a class=\"stream-topic\" data-stream-id=\"217875\" href=\"/#narrow/channel/217875-Is-there-code-for-X.3F/topic/Tensor.20product.20vector.20bundle/with/419045346\">#Is there code for X? &gt; Tensor product vector bundle</a> , it seems like the origin of the difficulties is really down to the infinite dimensional case, but I could be missing something from the mathematical point of view here.</p>",
        "id": 517824905,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1747141277
    },
    {
        "content": "<p>To define a Riemannian metric, one should really not use tensor product of bundles: a metric on a vector space <code>E</code> is a continuous bilinear map <code>E ‚ÜíL[‚Ñù] E ‚ÜíL[‚Ñù] ‚Ñù</code> which turns out to be symmetric and positive. Given a vector bundle (for instance the tangent bundle), we already have in mathlib the vector bundle of continuous linear maps, so iterating we already have the <code>E ‚ÜíL[‚Ñù] E ‚ÜíL[‚Ñù] ‚Ñù</code> vector bundle. Identification with a tensor bundle is not useful here, and even a little bit misleading as it makes things more complicated: <code>E ‚ÜíL[‚Ñù] E ‚ÜíL[‚Ñù] ‚Ñù</code> is a much simpler object than <code>E* ‚äó E*</code> (for instance, it has a canonical norm, it is complete whenever <code>E</code>is, and so on).</p>",
        "id": 517832764,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1747143261
    },
    {
        "content": "<blockquote>\n<p>To define a Riemannian metric, one should really not use tensor product of bundles...</p>\n</blockquote>\n<p>Sorry for causing confusion - this is what I actually meant. Reading my post again, I understand that this wasn't clear...</p>\n<p>In <a href=\"https://github.com/leanprover-community/mathlib4/tree/michaellee94%2Friemannian\">https://github.com/leanprover-community/mathlib4/tree/michaellee94%2Friemannian</a>, the CotangentSpace is defined using the TangentSpace. Does anybody have an opinion about similar constructions on slightly more arbitrary vector bundles? I think of normal bundles of immersed submanifolds, for example the second fundamental form for an immersed submanifold, which maps two vectors to a normal vector.  This could be a bilinear map E ‚ÜíL[‚Ñù] E ‚ÜíL[‚Ñù] E' at each point, where E is the tangent space of the sub-manifold and E' the normal bundle (probably seen as pullback bundle using the immersion, but haven't thought about it long enough).</p>\n<p>Thinking about differential forms: would they be defined inductively using ContinousLinearMap (plus conditions on being alternating)? <br>\nIf so, any ideas how one would formulate something like Œ±(v1, v2, ..., vk) = -Œ±(v2, v1, ...., vk)?</p>",
        "id": 517849834,
        "sender_full_name": "Jens Lindekamp",
        "timestamp": 1747147347
    },
    {
        "content": "<p>Differential forms would be defined not by induction, but as a bundle of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ContinuousAlternatingMap#doc\">docs#ContinuousAlternatingMap</a>. When you have a vector bundle, there are a bunch of constructions you can make, like bundles of continuous linear maps, but also bundles of multilinear maps, and so on.</p>",
        "id": 517853166,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1747148159
    },
    {
        "content": "<p>So, would differential forms on a manifold be formalized similar to <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Topology/VectorBundle/Hom.html\">Bundle.ContinuousLinearMap</a>, but based on ContinousAlternatingMap?</p>",
        "id": 517856875,
        "sender_full_name": "Jens Lindekamp",
        "timestamp": 1747148925
    },
    {
        "content": "<p>Pushing the concept a bit: if we want to formalize the Riemannian curvature tensor R(X,Y)Z for vectors X,Y,Z with values in TM,  would this be a similar construction, but using ContinousMultiLinearMap?</p>",
        "id": 517857481,
        "sender_full_name": "Jens Lindekamp",
        "timestamp": 1747149059
    },
    {
        "content": "<p>I think the curvature tensor would rather be formalized using linear maps, as <code>E ‚ÜíL[‚Ñù] E ‚ÜíL[‚Ñù] E ‚ÜíL[‚Ñù] E</code>, because curried variants are easier to use in this form. But essentially yes, this is the same thing as a multilinear map in three vectors.</p>",
        "id": 517860854,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1747149882
    },
    {
        "content": "<p>Agreed that this is the correct formulation, but this notation seems a bit tortured. Is it possible to define an abbrev for an (m, n) tensor type that curries the maps an appropriate number of times?</p>",
        "id": 517864131,
        "sender_full_name": "Michael Lee",
        "timestamp": 1747150759
    },
    {
        "content": "<p>One will just need to write this type once, when defining the tensor. Then, when applying it, you will just write <code>riemannTensor u v w</code> (and you can introduce a local notation to be able to write <code>R u v w</code>).</p>",
        "id": 517866244,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1747151310
    },
    {
        "content": "<p>What about other notions like covariant derivatives of (m, n) tensors or the Lie derivative of (m, n) tensors? Like the exterior derivative, which takes a k form to a k + 1 form, the other two derivatives can be defined on (m, n) tensors and take a (m, n) tensor to a (m + 1, n) tensor.</p>\n<p>If we define tensors (in the sense of multilinear maps...) in a case-by-case way, this might be difficult to formulate.</p>\n<p>Some examples:</p>\n<p>The Levi-Civita connection induces (like any connection) a connection on (3,1) tensors. When applied to the curvature tensor, this connection gives rise to the second Bianchi identity. And when it is 0, the Riemannian manifold is actually a symmetric space.</p>\n<p>The Levi-Civita connection of a metric is per definition 0, i.e. we may want to have the notion of an induced connection on (2,0) tensors to define it.</p>\n<p>A vector field is a Killing field iff the Lie derivative of the metric (as a (2,0) tensor) is 0.</p>\n<p>It would be nice to find a way to have the notational simplicity of using linear maps, but at the same time being able to talk about (m, n) tensors in general and the induced derivatives and other notions like contractions.</p>\n<p>Otherwise we would need to define the derivative of a metric and then the derivative of a curvature tensor and so on.</p>",
        "id": 517887388,
        "sender_full_name": "Jens Lindekamp",
        "timestamp": 1747157480
    },
    {
        "content": "<p>I think there will have to be some amount of duplication, because formalized maths is not as fluid as paper maths for identifications. For instance, in paper maths, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"double-struck\">R</mi><mn>1</mn></msup></mrow><annotation encoding=\"application/x-tex\">\\R^1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span></span></span> are the same thing. And <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi><mo>√ó</mo><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\R \\times \\R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7722em;vertical-align:-0.0833em;\"></span><span class=\"mord mathbb\">R</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">√ó</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"double-struck\">R</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">\\R^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span> are the same thing. It's not the same when formalizing: <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"double-struck\">R</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">\\R^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span> is the space of functions from <code>Fin n</code>to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span>, so the two identifications above fail. In the same way, if you define <code>(m, n)</code> tensors as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>E</mi><mrow><mo>‚äó</mo><mi>m</mi></mrow></msup><mo>‚äó</mo><mo stretchy=\"false\">(</mo><msup><mi>E</mi><mo>‚àó</mo></msup><msup><mo stretchy=\"false\">)</mo><mrow><mo>‚äó</mo><mi>n</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">E^{\\otimes m} \\otimes (E^*)^{\\otimes n}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8547em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">‚äó</span><span class=\"mord mathnormal mtight\">m</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">‚äó</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0213em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">‚àó</span></span></span></span></span></span></span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">‚äó</span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span></span>, then a vector is <em>not</em> a <code>(1, 0)</code> tensor, a metric (in the sense of a bilinear map) is <em>not</em> a <code>(0, 2)</code> tensor, and so on. So developing the theory for general <code>(m, n)</code> tensors would not contain the theory for the usual objects...</p>",
        "id": 517984395,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1747205873
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"900335\">Jens Lindekamp</span> <a href=\"#narrow/channel/113488-general/topic/.28Pseudo.29.20Riemannian.20metric/near/517817712\">said</a>:</p>\n<blockquote>\n<p>My 2 cents as a lean newbie having some background in Riemannian Geometry (though that is a few years ago, I made my PhD in 2002 ;-)): I think we need to introduce tensor bundles in the form of multilinear maps from k factors of TM and l factors of T*M to k (or R/C) to really make a step forward.</p>\n<p>In general, we need the tensor bundles to define:</p>\n<ol>\n<li>Metrics as (2,0) tensors</li>\n<li>The Riemmanian curvature as (3,1) tensor</li>\n<li>Ricci curvature as (2,0) tensor</li>\n<li>Torsion of an affine connection as (2,1) tensor (this is necessary to introduce the Levi-Civita connection  which is torsion-free and the basis for (Pseudo-) Riemannian Geometry.</li>\n<li>Differential forms as alternating (k,0) tensors. (And go to deRham cohomology from there....)</li>\n</ol>\n<p>And potentially a few more, but that's more than enough....</p>\n<p>I thought of defining a VectorBundleCore with a subtype of MultiLinearMap  as fibres based on the TangentBundle. The construction could be done based on any vector bundle, but in practice, we would only need multilinear maps / tensors on the tangent bundle.</p>\n<p>One could also introduce a general notion of general tensor products for vector bundles, but that's probably much more complex, and probably not needed at all for differential geometry.</p>\n<p>Based on this, we could consider metrics \"just\" as a special case (k = 2, l = 0) of the tensor bundle. </p>\n<p>Maybe it's only slightly more complex to create such a tensor bundle instead of the cotangent bundle as bundle of linear maps to k, metrics as bilinear maps to k etc.</p>\n<p>Having said that - I'm not yet able to deal with VectorBundleCore, so I'm probably (surely) missing subtle details of the implementation....</p>\n</blockquote>\n<p>I'd much rather follow Cartan and define connections via a principal G-bundle and then curvature is a Lie Algebra-valued 2-form. </p>\n<p>I haven't thought about this as much but torsion probably ought to be done via a soldering form.</p>\n<p>But I don't know the work on forms is progressing.</p>",
        "id": 517997362,
        "sender_full_name": "Dominic Steinitz",
        "timestamp": 1747210070
    },
    {
        "content": "<p>I believe Sam Lindauer is working these (in a project depending on mathlib) - and Yury Kudryashov has gradually been upstreaming some of the prerequisites. There's still a significant gap between these.</p>",
        "id": 517997887,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1747210214
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/channel/113488-general/topic/.28Pseudo.29.20Riemannian.20metric/near/517143102\">said</a>:</p>\n<blockquote>\n<p>We simply need a version of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=exists_smooth_forall_mem_convex_of_local#doc\">docs#exists_smooth_forall_mem_convex_of_local</a> for non-trivial vector bundles.</p>\n</blockquote>\n<p>Would really appreciate if you took a glance here at the results I've added for this:</p>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/blob/2d586707a31447b0735008e808232bd5f4b21892/Mathlib/Geometry/Manifold/PartitionOfUnity.lean#L628-L756\">https://github.com/leanprover-community/mathlib4/blob/2d586707a31447b0735008e808232bd5f4b21892/Mathlib/Geometry/Manifold/PartitionOfUnity.lean#L628-L756</a></p>\n<p>I'm happy to raise this as a PR on its own to break the reviewing effort up if you approve.</p>",
        "id": 518729147,
        "sender_full_name": "Michael Lee",
        "timestamp": 1747421793
    },
    {
        "content": "<p>At first glance, that looks like a useful statement - please make a PR!</p>",
        "id": 518747955,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1747429720
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"634338\">Michael Rothgang</span> <a href=\"#narrow/channel/113488-general/topic/.28Pseudo.29.20Riemannian.20metric/near/518747955\">said</a>:</p>\n<blockquote>\n<p>At first glance, that looks like a useful statement - please make a PR!</p>\n</blockquote>\n<p>Done!</p>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/24966\">https://github.com/leanprover-community/mathlib4/pull/24966</a></p>",
        "id": 518764470,
        "sender_full_name": "Michael Lee",
        "timestamp": 1747440524
    },
    {
        "content": "<p>If you'd like, I can also redo the proof of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=exists_contMDiffOn_forall_mem_convex_of_local#doc\">docs#exists_contMDiffOn_forall_mem_convex_of_local</a> to show that it's a special case.</p>",
        "id": 518770754,
        "sender_full_name": "Michael Lee",
        "timestamp": 1747446150
    },
    {
        "content": "<p>Thanks for making the PR! I was about to ask you for that - there's no need to duplicate the same proof twice.</p>",
        "id": 518793161,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1747466451
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"634338\">@Michael Rothgang</span> Replied to your PR comment, there's now a golfed proof of <code>exists_contMDiffOn_forall_mem_convex_of_local</code> that uses <code>exists_contMDiffOn_section_forall_mem_convex_of_local</code> directly. Thanks again!</p>",
        "id": 518827261,
        "sender_full_name": "Michael Lee",
        "timestamp": 1747494663
    },
    {
        "content": "<p>Here's a small step on the way to the Ehresmann connection (<a href=\"https://github.com/leanprover-community/mathlib4/pull/23426\">https://github.com/leanprover-community/mathlib4/pull/23426</a>)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Analysis</span><span class=\"bp\">.</span><span class=\"n\">Normed</span><span class=\"bp\">.</span><span class=\"n\">Ring</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">LinearAlgebra</span><span class=\"bp\">.</span><span class=\"n\">UnitaryGroup</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Topology</span><span class=\"bp\">.</span><span class=\"n\">FiberBundle</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Geometry</span><span class=\"bp\">.</span><span class=\"n\">Manifold</span><span class=\"bp\">.</span><span class=\"n\">ChartedSpace</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Geometry</span><span class=\"bp\">.</span><span class=\"n\">Manifold</span><span class=\"bp\">.</span><span class=\"n\">IsManifold</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Geometry</span><span class=\"bp\">.</span><span class=\"n\">Manifold</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">LieGroup</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">LinearAlgebra</span><span class=\"bp\">.</span><span class=\"n\">UnitaryGroup</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Topology</span><span class=\"bp\">.</span><span class=\"n\">FiberBundle</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Matrix</span><span class=\"w\"> </span><span class=\"n\">Bundle</span><span class=\"w\"> </span><span class=\"n\">Manifold</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">GBundleCore</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œπ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MulAction</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">FiberBundleCore</span><span class=\"w\"> </span><span class=\"n\">Œπ</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">coordChange_structure_group</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">baseSet</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">‚à©</span><span class=\"w\"> </span><span class=\"n\">baseSet</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">‚àÉ</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">coordChange</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">‚Ä¢</span><span class=\"w\"> </span><span class=\"n\">v</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">RightActions</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">SmoothLeftGAction</span>\n<span class=\"o\">{</span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NontriviallyNormedField</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">WithTop</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"bp\">‚àû</span><span class=\"o\">)</span>\n<span class=\"o\">{</span><span class=\"n\">E_G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span><span class=\"w\"> </span><span class=\"n\">E_G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedSpace</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">E_G</span><span class=\"o\">]</span>\n<span class=\"o\">{</span><span class=\"n\">E_M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span><span class=\"w\"> </span><span class=\"n\">E_M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedSpace</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">E_M</span><span class=\"o\">]</span>\n<span class=\"o\">{</span><span class=\"n\">H_G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">H_G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">I_G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ModelWithCorners</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">E_G</span><span class=\"w\"> </span><span class=\"n\">H_G</span><span class=\"o\">)</span>\n<span class=\"o\">{</span><span class=\"n\">H_M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">H_M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">I_M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ModelWithCorners</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">E_M</span><span class=\"w\"> </span><span class=\"n\">H_M</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ChartedSpace</span><span class=\"w\"> </span><span class=\"n\">H_G</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LieGroup</span><span class=\"w\"> </span><span class=\"n\">I_G</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ChartedSpace</span><span class=\"w\"> </span><span class=\"n\">H_M</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">MulAction</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">IsManifold</span><span class=\"w\"> </span><span class=\"n\">I_G</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">IsManifold</span><span class=\"w\"> </span><span class=\"n\">I_M</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">smooth_smul</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ContMDiff</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">I_G</span><span class=\"bp\">.</span><span class=\"n\">prod</span><span class=\"w\"> </span><span class=\"n\">I_M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">I_M</span><span class=\"w\"> </span><span class=\"bp\">‚ä§</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">√ó</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">‚Ä¢&gt;</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"o\">))</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">SmoothRightGAction</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NontriviallyNormedField</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">WithTop</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"bp\">‚àû</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">E_G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span><span class=\"w\"> </span><span class=\"n\">E_G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedSpace</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">E_G</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">E_M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span><span class=\"w\"> </span><span class=\"n\">E_M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedSpace</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">E_M</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">H_G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">H_G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">I_G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ModelWithCorners</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">E_G</span><span class=\"w\"> </span><span class=\"n\">H_G</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">H_M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">H_M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">I_M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ModelWithCorners</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">E_M</span><span class=\"w\"> </span><span class=\"n\">H_M</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ChartedSpace</span><span class=\"w\"> </span><span class=\"n\">H_G</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LieGroup</span><span class=\"w\"> </span><span class=\"n\">I_G</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ChartedSpace</span><span class=\"w\"> </span><span class=\"n\">H_M</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">MulAction</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MulOpposite</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">IsManifold</span><span class=\"w\"> </span><span class=\"n\">I_G</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">IsManifold</span><span class=\"w\"> </span><span class=\"n\">I_M</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">smooth_smul</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ContMDiff</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">I_M</span><span class=\"bp\">.</span><span class=\"n\">prod</span><span class=\"w\"> </span><span class=\"n\">I_G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">I_M</span><span class=\"w\"> </span><span class=\"bp\">‚ä§</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">√ó</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">&lt;‚Ä¢</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"o\">)</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NontriviallyNormedField</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"o\">]</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">WithTop</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"bp\">‚àû</span><span class=\"o\">}</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">E_G</span><span class=\"w\"> </span><span class=\"n\">E_M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span><span class=\"w\"> </span><span class=\"n\">E_G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span><span class=\"w\"> </span><span class=\"n\">E_M</span><span class=\"o\">]</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedSpace</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">E_G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedSpace</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">E_M</span><span class=\"o\">]</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">H_G</span><span class=\"w\"> </span><span class=\"n\">H_M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">H_G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">H_M</span><span class=\"o\">]</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ChartedSpace</span><span class=\"w\"> </span><span class=\"n\">H_G</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ChartedSpace</span><span class=\"w\"> </span><span class=\"n\">H_M</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">I_G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ModelWithCorners</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">E_G</span><span class=\"w\"> </span><span class=\"n\">H_G</span><span class=\"o\">}</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">I_M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ModelWithCorners</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">E_M</span><span class=\"w\"> </span><span class=\"n\">H_M</span><span class=\"o\">}</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LieGroup</span><span class=\"w\"> </span><span class=\"n\">I_G</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsManifold</span><span class=\"w\"> </span><span class=\"n\">I_G</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsManifold</span><span class=\"w\"> </span><span class=\"n\">I_M</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MulAction</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">SmoothLeftGAction</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">I_G</span><span class=\"w\"> </span><span class=\"n\">I_M</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">MulOpposite</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">mulAction_op_of_left</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MulAction</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MulAction</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"bp\">·µê·µí·µñ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">smul</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">unop</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"bp\">‚Åª¬π</span><span class=\"w\"> </span><span class=\"bp\">‚Ä¢</span><span class=\"w\"> </span><span class=\"n\">m</span>\n<span class=\"w\">  </span><span class=\"n\">one_smul</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚Ä¢</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">MulAction</span><span class=\"bp\">.</span><span class=\"n\">one_smul</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h3</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">unop</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">·µê·µí·µñ</span><span class=\"o\">)</span><span class=\"bp\">‚Åª¬π</span><span class=\"w\"> </span><span class=\"bp\">‚Ä¢&gt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">&lt;-</span><span class=\"n\">inv_one</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h1</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h3</span>\n\n<span class=\"w\">  </span><span class=\"n\">mul_smul</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">g‚ÇÅ</span><span class=\"w\"> </span><span class=\"n\">g‚ÇÇ</span><span class=\"w\"> </span><span class=\"n\">m</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">unop</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g‚ÇÅ</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">g‚ÇÇ</span><span class=\"o\">))</span><span class=\"bp\">‚Åª¬π</span><span class=\"w\"> </span><span class=\"bp\">‚Ä¢&gt;</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">unop</span><span class=\"w\"> </span><span class=\"n\">g‚ÇÅ</span><span class=\"o\">)</span><span class=\"bp\">‚Åª¬π</span><span class=\"w\"> </span><span class=\"bp\">‚Ä¢</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">unop</span><span class=\"w\"> </span><span class=\"n\">g‚ÇÇ</span><span class=\"o\">)</span><span class=\"bp\">‚Åª¬π</span><span class=\"w\"> </span><span class=\"bp\">‚Ä¢</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"k\">calc</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">unop</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g‚ÇÅ</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">g‚ÇÇ</span><span class=\"o\">))</span><span class=\"bp\">‚Åª¬π</span><span class=\"w\"> </span><span class=\"bp\">‚Ä¢&gt;</span><span class=\"w\"> </span><span class=\"n\">m</span>\n<span class=\"w\">        </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">unop</span><span class=\"w\"> </span><span class=\"n\">g‚ÇÇ</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">unop</span><span class=\"w\"> </span><span class=\"n\">g‚ÇÅ</span><span class=\"o\">)</span><span class=\"bp\">‚Åª¬π</span><span class=\"w\"> </span><span class=\"bp\">‚Ä¢&gt;</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\">       </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">unop_mul</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">unop</span><span class=\"w\"> </span><span class=\"n\">g‚ÇÅ</span><span class=\"o\">)</span><span class=\"bp\">‚Åª¬π</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">unop</span><span class=\"w\"> </span><span class=\"n\">g‚ÇÇ</span><span class=\"o\">)</span><span class=\"bp\">‚Åª¬π</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚Ä¢&gt;</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">root_</span><span class=\"bp\">.</span><span class=\"n\">mul_inv_rev</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">unop</span><span class=\"w\"> </span><span class=\"n\">g‚ÇÅ</span><span class=\"o\">)</span><span class=\"bp\">‚Åª¬π</span><span class=\"w\"> </span><span class=\"bp\">‚Ä¢</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">unop</span><span class=\"w\"> </span><span class=\"n\">g‚ÇÇ</span><span class=\"o\">)</span><span class=\"bp\">‚Åª¬π</span><span class=\"w\"> </span><span class=\"bp\">‚Ä¢</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MulAction</span><span class=\"bp\">.</span><span class=\"n\">mul_smul</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h1</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">SmoothRightGAction_of_Left</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">MulAction</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">LieGroup</span><span class=\"w\"> </span><span class=\"n\">I_G</span><span class=\"w\"> </span><span class=\"bp\">‚ä§</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"w\"> </span><span class=\"n\">IsManifold</span><span class=\"w\"> </span><span class=\"n\">I_M</span><span class=\"w\"> </span><span class=\"bp\">‚ä§</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">SmoothLeftGAction</span><span class=\"w\"> </span><span class=\"bp\">‚ä§</span><span class=\"w\"> </span><span class=\"n\">I_G</span><span class=\"w\"> </span><span class=\"n\">I_M</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">SmoothRightGAction</span><span class=\"w\"> </span><span class=\"bp\">‚ä§</span><span class=\"w\"> </span><span class=\"n\">I_G</span><span class=\"w\"> </span><span class=\"n\">I_M</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n\n<span class=\"w\">  </span><span class=\"n\">smooth_smul</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">√ó</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">√ó</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"bp\">‚Åª¬π</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ContMDiff</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">I_M</span><span class=\"bp\">.</span><span class=\"n\">prod</span><span class=\"w\"> </span><span class=\"n\">I_G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">I_G</span><span class=\"bp\">.</span><span class=\"n\">prod</span><span class=\"w\"> </span><span class=\"n\">I_M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚ä§</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">ContMDiff</span><span class=\"bp\">.</span><span class=\"n\">prodMk</span>\n<span class=\"w\">      </span><span class=\"bp\">¬∑</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">ContMDiff</span><span class=\"bp\">.</span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">contMDiff_inv</span><span class=\"w\"> </span><span class=\"n\">I_G</span><span class=\"w\"> </span><span class=\"bp\">‚ä§</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">contMDiff_snd</span>\n<span class=\"w\">      </span><span class=\"bp\">¬∑</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">contMDiff_fst</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">ContMDiff</span><span class=\"bp\">.</span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SmoothLeftGAction</span><span class=\"bp\">.</span><span class=\"n\">smooth_smul</span><span class=\"w\"> </span><span class=\"bp\">‚ä§</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">hf</span>\n\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">uK</span><span class=\"w\"> </span><span class=\"n\">uB</span><span class=\"w\"> </span><span class=\"n\">uF</span><span class=\"w\"> </span><span class=\"n\">uH</span><span class=\"w\"> </span><span class=\"n\">uI</span><span class=\"w\"> </span><span class=\"n\">uG</span><span class=\"w\"> </span><span class=\"n\">uP</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">PrincipalBundleCore</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">Œπ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">uP</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">uK</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NontriviallyNormedField</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">WithTop</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"bp\">‚àû</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">E_B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">uB</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">E_F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">uF</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">E_G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">uG</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span><span class=\"w\"> </span><span class=\"n\">E_B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedSpace</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">E_B</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span><span class=\"w\"> </span><span class=\"n\">E_F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedSpace</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">E_F</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span><span class=\"w\"> </span><span class=\"n\">E_G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedSpace</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">E_G</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">H_B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">uH</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">H_F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">uI</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">H_G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">uG</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">H_B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">H_F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">H_G</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">I_B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ModelWithCorners</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">E_B</span><span class=\"w\"> </span><span class=\"n\">H_B</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">I_F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ModelWithCorners</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">E_F</span><span class=\"w\"> </span><span class=\"n\">H_F</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">I_G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ModelWithCorners</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">E_G</span><span class=\"w\"> </span><span class=\"n\">H_G</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">uB</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ChartedSpace</span><span class=\"w\"> </span><span class=\"n\">H_B</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsManifold</span><span class=\"w\"> </span><span class=\"n\">I_B</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">uF</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ChartedSpace</span><span class=\"w\"> </span><span class=\"n\">H_G</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LieGroup</span><span class=\"w\"> </span><span class=\"n\">I_G</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">core</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FiberBundleCore</span><span class=\"w\"> </span><span class=\"n\">Œπ</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">MulAction</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MulOpposite</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">TotalSpace</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">core</span><span class=\"bp\">.</span><span class=\"n\">Fiber</span><span class=\"o\">))]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">ChartedSpace</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ModelProd</span><span class=\"w\"> </span><span class=\"n\">H_B</span><span class=\"w\"> </span><span class=\"n\">H_F</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">TotalSpace</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">core</span><span class=\"bp\">.</span><span class=\"n\">Fiber</span><span class=\"o\">)]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">IsManifold</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ModelWithCorners</span><span class=\"bp\">.</span><span class=\"n\">prod</span><span class=\"w\"> </span><span class=\"n\">I_B</span><span class=\"w\"> </span><span class=\"n\">I_F</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">TotalSpace</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">core</span><span class=\"bp\">.</span><span class=\"n\">Fiber</span><span class=\"o\">)]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">SmoothRightGAction</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">I_G</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ModelWithCorners</span><span class=\"bp\">.</span><span class=\"n\">prod</span><span class=\"w\"> </span><span class=\"n\">I_B</span><span class=\"w\"> </span><span class=\"n\">I_F</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">TotalSpace</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">core</span><span class=\"bp\">.</span><span class=\"n\">Fiber</span><span class=\"o\">)]</span>\n<span class=\"w\">  </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">respects_fibres</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TotalSpace</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">core</span><span class=\"bp\">.</span><span class=\"n\">Fiber</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">core</span><span class=\"bp\">.</span><span class=\"n\">proj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">&lt;‚Ä¢</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">core</span><span class=\"bp\">.</span><span class=\"n\">proj</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">is_free</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TotalSpace</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">core</span><span class=\"bp\">.</span><span class=\"n\">Fiber</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">&lt;‚Ä¢</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">is_transitive</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TotalSpace</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">core</span><span class=\"bp\">.</span><span class=\"n\">Fiber</span><span class=\"o\">)),</span>\n<span class=\"w\">    </span><span class=\"n\">core</span><span class=\"bp\">.</span><span class=\"n\">proj</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">core</span><span class=\"bp\">.</span><span class=\"n\">proj</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"bp\">‚àÉ</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">&lt;‚Ä¢</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 520875077,
        "sender_full_name": "Dominic Steinitz",
        "timestamp": 1748433886
    },
    {
        "content": "<p>I had a go at the definition of Riemannian manifolds in Mathlib, in <a href=\"https://github.com/leanprover-community/mathlib4/pull/25347\">#25347</a> (not designed to be merged, it's just to show the current state). It's somewhat orthogonal to the above discussion, because I'm not trying to show that a Riemannian metric exists, instead I'm trying to set up typeclasses so that one can work with Riemannian manifolds (for instance, I want the tangent spaces to be inner product spaces, but more importantly I want typeclass inference to be aware of this, to be able to use all our tools). The description of the PR in <a href=\"https://github.com/leanprover-community/mathlib4/pull/25347\">#25347</a> says more about the design, but let me mention a difficulty.</p>\n<p>The tangent spaces to a manifold always have a topological structure (in fact a topological vector space structure) because we use it all the time. So if you want to work with a Riemannian manifold you can not make the usual incantations and add <code>[‚àÄ x, InnerProductSpace ‚Ñù (TangentSpace I x)]</code> because this creates a diamond, with two different topologies on the tangent spaces. Instead, I introduce a new class <code>[RiemannianBundle (fun (b : M) -&gt; TangentSpace I b)]</code>, containing the data of inner product spaces on the fibers (as sections of the bundle of continuous bilinear maps with positivity and symmetry conditions), <em>compatible with the topology</em>, and from these I register inner product structures on the tangent spaces, without introducing diamonds. And on top of this I add Prop-valued classes registering whether the inner product varies continuously, or smoothly, with the base point. </p>\n<p>The design is a little bit complicated, and it is not battle-tested because I haven't proved nontrivial results with these definitions. But still, it looks pretty sound to me, and useful. I'm happy to take comments and suggestions! If people like it, I could even start PRing some bits.</p>",
        "id": 521576752,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1748797294
    },
    {
        "content": "<p>This is truly a gift, thanks @S√©bastien Gou√´zel :)</p>\n<p>If I'm not wrong, this sets up the ultimate typeclass infrastructure for Riemannian manifolds, and the diamond problem for¬†InnerProductSpace¬†on tangent spaces with¬†RiemannianBundle.</p>\n<p>I'm not sure you had a chance to look at my PR (<a href=\"https://github.com/leanprover-community/mathlib4/pull/564\">#564</a> in PhysLean <a href=\"https://github.com/HEPLean/PhysLean/tree/master/PhysLean/Mathematics/Geometry/Metric\">https://github.com/HEPLean/PhysLean/tree/master/PhysLean/Mathematics/Geometry/Metric</a><br>\n<a href=\"https://github.com/HEPLean/PhysLean/pull/564\">https://github.com/HEPLean/PhysLean/pull/564</a><br>\n), where I've tried to define the metric as a concrete data structure:</p>\n<ul>\n<li>PseudoRiemannianMetric:¬†val¬†(family of bilinear forms),¬†symm,¬†nondegenerate,¬†smooth_in_charts'¬†(smoothness of components in local charts), and¬†negDim_isLocallyConstant.</li>\n<li>RiemannianMetric: Extends PRM with¬†pos_def'.</li>\n<li>I also provide local¬†InnerProductSpace¬†structures on¬†TangentSpace I x¬†via¬†TangentSpace.metricInnerProductSpace g x, requiring¬†letI¬†in practice.</li>\n</ul>\n<p>It seems my¬†RiemannianMetric¬†structure could potentially provide the data for your¬†ContMDiffRiemannianMetricconstructor. The bridge would likely be showing that¬†smooth_in_charts'¬†implies the¬†ContMDiff¬†of the metric section you use, and showing that the topology is compatible (the isVonNBounded¬†condition).</p>\n<p>Am I on the right track thinking these are complementary? Or do you see a different integration path? or none?</p>",
        "id": 521586233,
        "sender_full_name": "Matteo Cipollina",
        "timestamp": 1748802850
    },
    {
        "content": "<p>Yes, these have definitely the same kind of flavor, especially the data to construct the metric. There are some subtleties, though: pointwise smoothness, as you require, is not equivalent to full smoothness in general, and also nondegeneracy is in general not enough to ensure that the topology defined by the inner product is the same as the original one (which is why I have to include this additional von Neumann bounded condition). However, they are equivalent when the space is finite-dimensional, which is the situation you are considering if I understand correctly!</p>",
        "id": 521593323,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1748806956
    },
    {
        "content": "<p>A comment on your PR to PhysLean: the line</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NormedAddCommGroup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">TangentSpace</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"n\">NormedAddCommGroup</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"k\">from</span><span class=\"w\"> </span><span class=\"n\">inferInstance</span>\n</code></pre></div>\n<p>is probably not a good idea if the plan is to put inner product spaces structures on the tangent spaces, as the two instances will conflict.</p>",
        "id": 521593536,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1748807106
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">S√©bastien Gou√´zel</span> <a href=\"#narrow/channel/113488-general/topic/.28Pseudo.29.20Riemannian.20metric/near/521593323\">ha scritto</a>:</p>\n<blockquote>\n<p>Yes, these have definitely the same kind of flavor, especially the data to construct the metric. There are some subtleties, though: pointwise smoothness, as you require, is not equivalent to full smoothness in general, and also nondegeneracy is in general not enough to ensure that the topology defined by the inner product is the same as the original one (which is why I have to include this additional von Neumann bounded condition). However, they are equivalent when the space is finite-dimensional, which is the situation you are considering if I understand correctly!</p>\n</blockquote>\n<p>Thanks so much for the explanation and for looking at the PhysLean PR! This is super helpful :)</p>",
        "id": 521601015,
        "sender_full_name": "Matteo Cipollina",
        "timestamp": 1748811851
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"633028\">Michael Lee</span> <a href=\"#narrow/channel/113488-general/topic/.28Pseudo.29.20Riemannian.20metric/near/518827261\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"634338\">Michael Rothgang</span> Replied to your PR comment, there's now a golfed proof of <code>exists_contMDiffOn_forall_mem_convex_of_local</code> that uses <code>exists_contMDiffOn_section_forall_mem_convex_of_local</code> directly. Thanks again!</p>\n</blockquote>\n<p>I left a review that I hope will be somewhat interesting. I‚Äôm sorry about the huge delay.</p>",
        "id": 524767624,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1750273601
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/28056\">#28056</a> (still heavily work in progress) will prove that every smooth finite rank real vector bundle (over a sigma-compact Hausdorff base) admits a smooth bundle metric.</p>",
        "id": 533151541,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1754501639
    }
]