[
    {
        "content": "<p>I assume someone has already asked about this, but I couldn't find it, so I'd like to ask here.</p>\n<p>Why do the <code>Repr</code> instances for <code>HashSet</code> and <code>HashMap</code> use the <code>ofList</code> function and not a custom notation? Personally, I find it more readable if <code>HashSet</code> is displayed using a notation like <code>{ a, b, c, ... }</code>. Is there a reason why that isn't possible?</p>",
        "id": 531736341,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1753844465
    },
    {
        "content": "<p>If the expected type is known to be <code>Std.HashMap Nat Nat</code>, then <code>{ (1, 2), (3, 4) }</code> does the right thing already, so it's certainly possible to have the notation. However, if I don't already know what kind of object is being constructed, then <code>Std.HashMap.ofList [(1, 2), (3, 4)]</code> is much more telling than <code>{ (1, 2), (3, 4) }</code> (both to humans and to the elaborator).</p>",
        "id": 531746116,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1753850257
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260921\">@Markus Himmel</span> </p>\n<p>Thank you very much for your reply.</p>\n<p>I find it strange that the expected type is unknown. For example, I would think that <code>{(1, \"hello\"), (2, \"world\")}</code> clearly represents an element of <code>HashMap Nat String</code>, but when I pass it to the <code>#check</code> command, that doesn't seem to be the case. It seems that Lean doesn't know what type this term has. Why is that?</p>",
        "id": 531759030,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1753856913
    },
    {
        "content": "<p>The notation is powered by the <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=EmptyCollection#doc\">docs#EmptyCollection</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Singleton#doc\">docs#Singleton</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Insert#doc\">docs#Insert</a> type classes which are polymorphic in the output type. Besides hash maps, the notation also applies to mathlib's <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set#doc\">docs#Set</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset#doc\">docs#Finset</a>, among other things.</p>",
        "id": 531763323,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1753858755
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260921\">@Markus Himmel</span> </p>\n<p>Thank you. You're right.</p>",
        "id": 531763718,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1753858889
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260921\">@Markus Himmel</span> </p>\n<p>By the way, wouldn't it be acceptable to display it in a form that explicitly specifies the expected type, like <code>({ [1, \"hello\"], [2, \"world\"] } : Std.HashMap Nat String)</code>?</p>",
        "id": 532048314,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1753961406
    },
    {
        "content": "<p>Yes, that would be possible, but I don't think it's better than the status quo.</p>",
        "id": 532048551,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1753961479
    }
]