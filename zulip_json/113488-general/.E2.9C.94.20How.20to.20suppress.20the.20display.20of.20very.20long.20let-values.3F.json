[
    {
        "content": "<p><a href=\"/user_uploads/3121/sWbjmkDvEEer-_3PxiwlZlE1/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/sWbjmkDvEEer-_3PxiwlZlE1/image.png\" title=\"image.png\"><img data-original-dimensions=\"1361x1245\" src=\"/user_uploads/thumbnail/3121/sWbjmkDvEEer-_3PxiwlZlE1/image.png/840x560.webp\"></a></div><p>Here the definition of h1 is very long, and in the current stage I don't really care about its definition. However, if I uncheck the 'let-values' option, all the let-values are suppressed. How can I only suppress some very long ones of them?</p>",
        "id": 485990117,
        "sender_full_name": "aprilgrimoire",
        "timestamp": 1733275913
    },
    {
        "content": "<p>Does <code>h1</code> contain any data that you care about, or is it just a proof? If the latter, you should use <code>have</code> rather than <code>let</code> to introduce it, and it will not show up then.</p>",
        "id": 485990536,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1733276155
    },
    {
        "content": "<p>It's just a proof. Thanks, what's the difference between have and let other than this feature? I didn't know have could be used outside tactic mode.</p>",
        "id": 485990769,
        "sender_full_name": "aprilgrimoire",
        "timestamp": 1733276282
    },
    {
        "content": "<p>That's pretty much the difference. <code>have</code> is also more efficient in some ways because it prevents the value from being used, even during typechecking or other operations.</p>",
        "id": 485990970,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1733276397
    },
    {
        "content": "<p>I think a Prop cannot contain data other than it's truth?</p>",
        "id": 485991057,
        "sender_full_name": "aprilgrimoire",
        "timestamp": 1733276427
    },
    {
        "content": "<p>When you define data with <code>have</code>, the value is not available to the body: it's a non-dependent binding. For example</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"c\">/-</span>\n<span class=\"cm\">  type mismatch</span>\n<span class=\"cm\">    Vector.mkVector n 1</span>\n<span class=\"cm\">  has type</span>\n<span class=\"cm\">    Vector Nat n : Type</span>\n<span class=\"cm\">  but is expected to have type</span>\n<span class=\"cm\">    Vector Nat 1 : Type</span>\n<span class=\"cm\">  -/</span>\n<span class=\"w\">  </span><span class=\"n\">Vector.mkVector</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n\n<span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"n\">Vector.mkVector</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"c1\">-- works</span>\n</code></pre></div>",
        "id": 485991118,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1733276462
    },
    {
        "content": "<p>Thanks! But even if a Prop is defined using a let expression, isn't it the case that its construction could never be retrieved?</p>",
        "id": 485991537,
        "sender_full_name": "aprilgrimoire",
        "timestamp": 1733276657
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"782502\">aprilgrimoire</span> has marked this topic as resolved.</p>",
        "id": 485991540,
        "sender_full_name": "Notification Bot",
        "timestamp": 1733276659
    },
    {
        "content": "<p>Something that frequently confuses me here when thinking about <code>have</code> is that the type of <code>have</code> can make use of the value of <code>n</code>, so it's still sort of dependent <span class=\"user-mention\" data-user-id=\"128280\">@Wojciech Nawrocki</span>. Example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"c1\">-- (let_fun n := 1; rfl) : 1 = 1</span>\n</code></pre></div>",
        "id": 485991655,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1733276719
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"782502\">@aprilgrimoire</span> No, the proof is still present in the <code>let</code> binding, and the variable can be substituted.</p>",
        "id": 485991778,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1733276767
    },
    {
        "content": "<p>Thanks. Is that a meta-programming thing?</p>\n<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/113488-general/topic/.E2.9C.94.20How.20to.20suppress.20the.20display.20of.20very.20long.20let-values.3F/near/485991778\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"782502\">aprilgrimoire</span> No, the proof is still present in the <code>let</code> binding, and the variable can be substituted.</p>\n</blockquote>",
        "id": 485991907,
        "sender_full_name": "aprilgrimoire",
        "timestamp": 1733276830
    },
    {
        "content": "<p>This can cause issues, since the proof might depend on other variables in the local context. That can prevent you from rewriting those variables for example.</p>",
        "id": 485991915,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1733276834
    },
    {
        "content": "<p>Using <code>have</code> ensures the details of the proof will have no impact on your goal state.</p>",
        "id": 485992065,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1733276890
    },
    {
        "content": "<p>(No, it is not a just metaprogramming thing.)</p>",
        "id": 485992099,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1733276916
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/113488-general/topic/.E2.9C.94.20How.20to.20suppress.20the.20display.20of.20very.20long.20let-values.3F/near/485992099\">said</a>:</p>\n<blockquote>\n<p>(No, it is not a just metaprogramming thing.)</p>\n</blockquote>\n<p>Thanks. I'm confused. In MLTT, Prop only have one element, then how could I extract any information from some element of that type?</p>",
        "id": 485992210,
        "sender_full_name": "aprilgrimoire",
        "timestamp": 1733276989
    },
    {
        "content": "<p>Proofs might be definitionally equal to each other, but they are still represented as terms. Take a look at your goal state in your screenshot. I see many variables that appear in the proof term, including phi. Therefore <code>h1</code> depends on phi.</p>",
        "id": 485992377,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1733277072
    },
    {
        "content": "<p>The proof term itself syntactically contains information.</p>",
        "id": 485992454,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1733277107
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/113488-general/topic/.E2.9C.94.20How.20to.20suppress.20the.20display.20of.20very.20long.20let-values.3F/near/485992454\">said</a>:</p>\n<blockquote>\n<p>The proof term itself syntactically contains information.</p>\n</blockquote>\n<p>Thanks. But other than metaprogramming, how can I make use of this dependency?</p>",
        "id": 485992592,
        "sender_full_name": "aprilgrimoire",
        "timestamp": 1733277165
    },
    {
        "content": "<p>See what happens if you <code>revert \\phi</code></p>",
        "id": 485992635,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1733277186
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/113488-general/topic/.E2.9C.94.20How.20to.20suppress.20the.20display.20of.20very.20long.20let-values.3F/near/485991655\">said</a>:</p>\n<blockquote>\n<p>Something that frequently confuses me here when thinking about <code>have</code> is that the type of <code>have</code> can make use of the value of <code>n</code>, so it's still sort of dependent <span class=\"user-mention silent\" data-user-id=\"128280\">Wojciech Nawrocki</span>. Example:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"c1\">-- (let_fun n := 1; rfl) : 1 = 1</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>That's the result of beta-reduction (because <code>let_fun</code> is secretly a function application), but the type-correctness of <code>rfl</code> here cannot depend on <code>n</code> having the value <code>1</code>: when checking the body, <code>n</code> is just a variable. This is the sense in which it's not dependent. Contrast with <code>#check let n := 1; (Eq.refl n : 1 = 1)</code>.</p>",
        "id": 485993562,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1733277603
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"782502\">aprilgrimoire</span> <a href=\"#narrow/channel/113488-general/topic/.E2.9C.94.20How.20to.20suppress.20the.20display.20of.20very.20long.20let-values.3F/near/485992592\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/113488-general/topic/.E2.9C.94.20How.20to.20suppress.20the.20display.20of.20very.20long.20let-values.3F/near/485992454\">said</a>:</p>\n<blockquote>\n<p>The proof term itself syntactically contains information.</p>\n</blockquote>\n<p>Thanks. But other than metaprogramming, how can I make use of this dependency?</p>\n</blockquote>\n<p>You generally cannot use proofs in meaningful ways (because they are all the same by proof-irrelevance) (*), but keeping track might prevent you from doing certain things so it's better to use <code>have</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">axiom</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"kd\">axiom</span><span class=\"w\"> </span><span class=\"n\">proveP</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">P</span>\n\n<span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">proveP</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat.add_comm</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"c1\">-- tactic 'clear' failed, variable 'h' depends on 'n'</span>\n<span class=\"w\">  </span><span class=\"n\">clear</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">proveP</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat.add_comm</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">clear</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"c1\">-- works</span>\n</code></pre></div>\n<p>(*) Proof terms may sometimes contain nested terms, especially nested proof terms, that can be useful, but imo this is more a symptom of bad API design than something to make use of.</p>",
        "id": 485994486,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1733278008
    },
    {
        "content": "<p>(<span class=\"user-mention\" data-user-id=\"128280\">@Wojciech Nawrocki</span> <a href=\"https://github.com/leanprover/lean4/commit/a2226a43ac117df40d6c43a772ae33d184d02109\">I'm aware</a> of the encoding :-) I'm just commenting on the fact that there are multiple levels of dependence for lets. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.Simp.SimpLetCase#doc\">docs#Lean.Meta.Simp.SimpLetCase</a> has a classification, but yeah, both nondep and nondepDepVar are non-dependent, and those are what <code>have</code> give.)</p>",
        "id": 485997506,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1733279358
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/113488-general/topic/.E2.9C.94.20How.20to.20suppress.20the.20display.20of.20very.20long.20let-values.3F/near/485997506\">said</a>:</p>\n<blockquote>\n<p>(<span class=\"user-mention silent\" data-user-id=\"128280\">Wojciech Nawrocki</span> <a href=\"https://github.com/leanprover/lean4/commit/a2226a43ac117df40d6c43a772ae33d184d02109\">I'm aware</a> of the encoding :-) I'm just commenting on the fact that there are multiple levels of dependence for lets. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.Simp.SimpLetCase#doc\">docs#Lean.Meta.Simp.SimpLetCase</a> has a classification, but yeah, both nondep and nondepDepVar are non-dependent, and those are what <code>have</code> give.)</p>\n</blockquote>\n<p><del>Coincidentally, are the comments on that (in the source code; they're not docstrings) slightly off? The result type cannot possibly depend on <code>x</code>, right? Maybe it was supposed to say \"depends on <code>v</code>\"?</del> Nvm, it does make sense after all. The result type of <em>b</em> depends on <code>x</code>, and the result type of the whole expression on <code>v</code>.</p>",
        "id": 485998081,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1733279616
    }
]