[
    {
        "content": "<p>Hello all. I'm looking at the containers in <code>Std.Data</code> and noticing that while they do have extensive proofs about membership and lookups for all operations, they don't seem to actually offer much in terms of equality of sets/maps themselves.</p>\n<p>I'm talking about e.g. an extensionality theorem like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">EquivBEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Hashable</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LawfulHashable</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">m₁</span><span class=\"w\"> </span><span class=\"n\">m₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashMap</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">m₁</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">m₂</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">m₁</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">m₂</span>\n</code></pre></div>\n<p>I haven't looked too deeply at the implementation details but the likely answer is that the buckets \"remember\" the insertion order. In that case, is there a reason <code>Std.HashMap</code> doesn't simply <code>Quotient</code> these differences out? Or at least, provide proofs that operations are \"proper\" wrt this setoid.</p>\n<p>The reason I'm looking at this is that I'm trying to reify some relational algebra in a computational context, and a piece of that is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">hashPred</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LawfulBEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Hashable</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LawfulHashable</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidablePred</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std.HashSet</span><span class=\"w\"> </span><span class=\"n\">α</span>\n</code></pre></div>\n<p>where <code>Fintype</code> gives me a list of <code>α</code> to check, but I have to promise that the result does not depend on the choice of the ordering of the list.</p>",
        "id": 495907119,
        "sender_full_name": "mniip",
        "timestamp": 1737840963
    },
    {
        "content": "<p>I think right now it's up to you to build the quotient yourself, perhaps with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Setoid.ker#doc\">docs#Setoid.ker</a></p>",
        "id": 495915001,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1737848782
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"678686\">mniip</span> <a href=\"#narrow/channel/113488-general/topic/.60Std.2EHashMap.60.20extensionality/near/495907119\">said</a>:</p>\n<blockquote>\n<p>Hello all. I'm looking at the containers in <code>Std.Data</code> and noticing that while they do have extensive proofs about membership and lookups for all operations, they don't seem to actually offer much in terms of equality of sets/maps themselves.</p>\n</blockquote>\n<p>Do you just need to know that two containers are equivalent for theoretical purposes, or do you need to compute the equivalence as in <code>if equivalent a b then ... else ...</code>?</p>",
        "id": 495925238,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1737858836
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119741\">@François G. Dorais</span> I need a mere proof that two containers are equal. I have a function of the form <code>f : α ≃ Fin n → Std.HashSet α</code>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fintype.truncEquivFin#doc\">docs#Fintype.truncEquivFin</a> can supply the <code>α ≃ Fin n</code>, but under a <code>Trunc</code>, and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Trunc.lift#doc\">docs#Trunc.lift</a> that can unpack the <code>Trunc</code>, but that requires proving <code>f iso₁ = f iso₂</code>.</p>",
        "id": 495928835,
        "sender_full_name": "mniip",
        "timestamp": 1737862516
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"678686\">mniip</span> <a href=\"#narrow/channel/113488-general/topic/.60Std.2EHashMap.60.20extensionality/near/495907119\">said</a>:</p>\n<blockquote>\n<p>In that case, is there a reason <code>Std.HashMap</code> doesn't simply <code>Quotient</code> these differences out?</p>\n</blockquote>\n<p>(I'm the author of <code>Std.HashMap</code>) The reason why we don't quotient out some notion of equality by default is that, as you guessed, operations like <code>toList</code>, iteration, folds etc. leak information about the insertion order, so these operations will have to be restricted/changed in an extensional hash map. The standard library will develop a good theory of equivalence of hash maps and define such a quotient under a name like <code>Std.ExtensionalHashMap</code> (or perhaps <code>Std.Extensional.HashMap</code>) in the future, but I can't make any promises about when we will get to this. If someone is interested in developing this in a downstream project (possibly with a view towards upstreaming to the standard library), I would be happy to help out where I can.</p>",
        "id": 495945378,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1737878833
    }
]