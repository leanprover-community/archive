[
    {
        "content": "<p>Many of the most important functions in <code>src/include/lean/lean.h</code> are sensibly declared <code>inline</code> for performance. However, this means that they do not export symbols in the <code>leanshared</code> dynamically-linked library. In order to write <code>@[extern]</code> functions, it is essential that the external code can construct Lean objects with <code>lean_alloc_small_object</code>, <code>lean_alloc_ctor</code>, and <code>lean_alloc_array</code>, access data from objects with <code>lean_ctor_get</code>, and manipulate reference counting with <code>lean_inc_ref</code> and <code>lean_dec_ref</code>. In each of these cases, the functions are inaccessible. <br>\nThe current workaround is to copy and transpile the needed inline functions from <code>lean.h</code> into the target language. This is done in <a href=\"https://github.com/digama0/lean-sys\">lean-sys</a> and <a href=\"https://github.com/chasenorman/Canonical/blob/main/crates/canonical-lean/src/lib.rs\">Canonical</a>. This works in some cases but has a number of issues:</p>\n<ol>\n<li>The FFI binaries no longer work for users when updates to these inline functions are made, even if the signature stays consistent.</li>\n<li>Developers must update the transpiled code to consistently mirror changes, such as the switch to <code>mimalloc</code> coming in <code>v4.19.0</code>.</li>\n<li>Developers must make assumptions about how preprocessor directives will be evaluated for the user's compiled version of Lean, and bake that into their FFI binary as well. If the user's configuration does not meet the assumption, the binary will not work.</li>\n<li>Discrepancies in how different languages represent and allocate structures and primitives can lead to (platform dependent) issues that are complex to debug. <br>\nI am suggesting the following simple change: For each <code>inline</code> function <code>f</code> in <code>src/include/lean/lean.h</code>, add</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">LEAN_EXPORT</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">type</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">f_export</span><span class=\"o\">([</span><span class=\"n\">args</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">([</span><span class=\"n\">args</span><span class=\"o\">])</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>\n<p>to declare an exported version of <code>f</code>. These functions should not be used by Lean internally, but rather make these functions accessible to programs linking with the <code>leanshared</code> dynamically-linked library. The primary beneficiaries are:</p>\n<ol>\n<li>Users of FFI programs, like <a href=\"https://github.com/abdoo8080/lean-cvc5\">lean-cvc5</a> and <a href=\"https://github.com/chasenorman/CanonicalLean\">CanonicalLean</a>, who continue using the same binaries across updates. </li>\n<li>Developers of FFI programs, who can rely on stable bindings for essential functions.</li>\n<li>Maintainers of transpiled versions of <code>lean.h</code>.</li>\n</ol>",
        "id": 513773165,
        "sender_full_name": "Chase Norman",
        "timestamp": 1745382866
    },
    {
        "content": "<p>I think you are asking for two things here. For one access to symbols that are currently only available as <code>static inline</code>. And secondly stability guarantees for these symbols. I think it is somewhat realistic to have the former but the Lean runtime is far away from a state where it would be stable enough to make guarantees for the functions available in <code>lean.h</code> I would say.</p>",
        "id": 513825332,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1745401748
    }
]