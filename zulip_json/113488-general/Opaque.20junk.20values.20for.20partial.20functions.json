[
    {
        "content": "<p>I was reading through <a href=\"#narrow/stream/113488-general/topic/Incomplete.20pattern.20match\">this thread</a> and was trying to think of ways to stop proofs that <code>1 - 2 = 3 - 6</code> (or something similar, I could see a variety of reasons that nat subtraction specifically shouldn't be changed). This idea probably sounded better in my head than it does on paper, but I was wondering if we could define a <code>junk_value</code> function that prevents proofs of equality, like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">opaque</span> <span class=\"n\">junk_value</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"kd\">def</span> <span class=\"n\">minus</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">m</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span> <span class=\"k\">then</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">m</span> <span class=\"k\">else</span> <span class=\"n\">junk_value</span> <span class=\"n\">n</span> <span class=\"n\">m</span>\n</code></pre></div>\n<p>That way, <code>1 - 2</code> reduces to <code>junk_value 1 2</code> and <code>3 - 5</code> reduces to <code>junk_value 3 5</code>, which are computationally equal, but as far as I know there's no way to prove this (except maybe <code>native_decide</code>, which I don't know how it works).</p>\n<p>A more generic <code>junk_value</code> function that works for all types could be:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universe</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n<span class=\"n\">opaque</span> <span class=\"n\">junk_value</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Inhabited</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">Inhabited.default</span>\n</code></pre></div>\n<p>where <code>β</code> would likely be a tuple containing the type of all arguments.</p>",
        "id": 319438942,
        "sender_full_name": "Niels Voss",
        "timestamp": 1672854380
    },
    {
        "content": "<p>One caveat is that for subtraction, it essentially has to be defined twice, once where <code>1 - 2</code> returns <code>0</code> and once where it returns <code>junk_value 1 2</code>. If you try defining it in one go, like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">sub</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Nat</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"n\">m</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">junk_value</span> <span class=\"mi\">0</span> <span class=\"n\">m</span>\n<span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">sub</span> <span class=\"n\">n</span> <span class=\"n\">m</span>\n</code></pre></div>\n<p>Then <code>1 - 5</code> and <code>2 - 6</code> both reduce to <code>junk_value 0 4</code> and can be proven equal.</p>",
        "id": 319441494,
        "sender_full_name": "Niels Voss",
        "timestamp": 1672855198
    },
    {
        "content": "<p>Is that a problem?</p>",
        "id": 319441866,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1672855318
    },
    {
        "content": "<p>Because <code>(1:ℤ) - (5:ℤ) = (2:ℤ) - (6:ℤ)</code>.</p>",
        "id": 319441955,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1672855340
    },
    {
        "content": "<p>I think it's reasonable to occasionaly have <code>junk_value a b = junk_value c d</code> if <code>a + d = c + b</code>.</p>",
        "id": 319442119,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1672855403
    },
    {
        "content": "<p>But anyway, it turns out that for applications in can be very helpful to have well-chosen junk-values.</p>",
        "id": 319442176,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1672855429
    },
    {
        "content": "<p>It can occasionally be a footgun, which is probably what you are trying to avoid. But it also saves you from checking a tonne of annoying side conditions.</p>",
        "id": 319442310,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1672855464
    },
    {
        "content": "<p>For natural number subtraction, I do agree that opaque junk values are not the way to go because having <code>1 - 2 = 0</code> is actually sometimes a useful property. I was thinking that <code>junk_value</code> would be more helpful in situations where there's not really a good junk value to choose.</p>",
        "id": 319442831,
        "sender_full_name": "Niels Voss",
        "timestamp": 1672855656
    },
    {
        "content": "<p>Why would it be helpful in such situations?</p>",
        "id": 319442883,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1672855681
    },
    {
        "content": "<p>If there's not really a good junk value to choose, then the risk for footguns is also quite small, I think.</p>",
        "id": 319443042,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1672855722
    },
    {
        "content": "<p>In which case it doesn't matter which junk value you choose.</p>",
        "id": 319443075,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1672855735
    },
    {
        "content": "<p>Do you have a concrete example in mind?</p>",
        "id": 319443144,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1672855761
    },
    {
        "content": "<p>No, I don't really have a concrete example. I guess it would help in some obscure definitions where it isn't made clear that junk values exist. I remember seeing some definition of an inverse in a ring or monoid (<a href=\"https://leanprover-community.github.io/mathlib_docs/find/ring.inverse\">docs#ring.inverse</a>) where it would return the inverse if it existed and zero if it didn't, but the function was just called <code>something.inverse</code> I think. That's not really a good example either because you can just read the doc strings, but someone looking at a lemma might see something like <code>inverse 3 = inverse 4</code> and be confused</p>",
        "id": 319443918,
        "sender_full_name": "Niels Voss",
        "timestamp": 1672856034
    },
    {
        "content": "<p>But generally, I agree that the risk is quite small</p>",
        "id": 319444062,
        "sender_full_name": "Niels Voss",
        "timestamp": 1672856070
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/ring.inverse\">docs#ring.inverse</a></p>",
        "id": 319444081,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1672856074
    },
    {
        "content": "<blockquote>\n<p>A more generic <code>junk_value</code> function that works for all types could be:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universe</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n<span class=\"n\">opaque</span> <span class=\"n\">junk_value</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Inhabited</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">Inhabited.default</span>\n</code></pre></div>\n<p>where <code>β</code> would likely be a tuple containing the type of all arguments.</p>\n</blockquote>\n<p>A <em>generic</em> junk value function is just as problematic as using 0, if you want to avoid \"junk\" theorems.  Because now you can prove e.g. <code>x / 0 = x % 0</code> by reflexivity.  You need to use a different opaque function for every occurrence to get truly unspecified values.</p>",
        "id": 319449267,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1672857762
    },
    {
        "content": "<p>And even then they're merely unspecified, you can still prove all kinds of theorems about them.  Like <code>(a / b)^2 + 1 &gt; 0</code>.</p>",
        "id": 319449932,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1672857996
    },
    {
        "content": "<p>I didn't consider the <code>x / 0 = x % 0</code> case that you mentioned. I guess a tactic could be used to generate the junk functions, or have <code>junk_value</code> take in a string containing the function name.<br>\nI don't really think there's a way to solve the second problem. At the very least, there's no way to take advantage of the specific undefined value and any theorems you prove about them essentially have to hold for every nat. It is still a bit unmathematical, but less alarming than something like <code>∀ n : ℕ, ∃ k, n / k = k</code>.</p>",
        "id": 319451841,
        "sender_full_name": "Niels Voss",
        "timestamp": 1672858567
    },
    {
        "content": "<p>On the other hand, there are useful theorems for nat.sub that you can't prove if the value is arbitrary instead of 0, like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/has_ordered_sub\">docs#has_ordered_sub</a>.</p>",
        "id": 319461233,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1672861864
    },
    {
        "content": "<p>Idea: mathlib should compile successfully independently of the choice of junk value for any partial function in mathlib. Why not have some kind of marker on all definitions of partial functions? Then periodically somebody goes through all these markers and changes their junk values to other junk values to test if the rest of mathlib is truly independent of these choices.</p>",
        "id": 319527101,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1672903413
    },
    {
        "content": "<p>I remember thinking about this a few years ago and then deciding that any change that made things more complicated was hard to justify in practice.</p>",
        "id": 319527558,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1672903614
    },
    {
        "content": "<p>this is not true: we sometimes rely on junk values so that some simple theorems are true with less assumptions than in traditional maths. I don't have a good example at hand, though.</p>",
        "id": 319527659,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1672903670
    },
    {
        "content": "<p>Is this something desirable if traditional mathematicians are the intended users?</p>",
        "id": 319527794,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1672903728
    },
    {
        "content": "<p>This is definitely desirable since it leaves less assumptions to check for the user of theorems, and therefore makes the library smoother to use.</p>",
        "id": 319527998,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1672903820
    },
    {
        "content": "<p>it is very practiable and if it does not change the interesting mathematics, then I think nobody will object to that.</p>",
        "id": 319528018,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1672903831
    },
    {
        "content": "<p>A good example is the change of variables formula <a href=\"https://leanprover-community.github.io/mathlib_docs/find/measure_theory.integral_target_eq_integral_abs_det_fderiv_smul\">docs#measure_theory.integral_target_eq_integral_abs_det_fderiv_smul</a>, where you don't need to check that the function is integrable because otherwise the same junk value <code>0</code> is used on both sides of the formula which is therefore still true.</p>",
        "id": 319528149,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1672903914
    },
    {
        "content": "<p>The canonical example is (a+b)/c=a/c+b/c</p>",
        "id": 319529970,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1672904857
    },
    {
        "content": "<p>Kevin has a nice blog post about this on Xena, btw. (If I was at a desk I'd look it up)</p>",
        "id": 319576075,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1672922138
    },
    {
        "content": "<p><a href=\"https://xenaproject.wordpress.com/2020/07/05/division-by-zero-in-type-theory-a-faq/\">https://xenaproject.wordpress.com/2020/07/05/division-by-zero-in-type-theory-a-faq/</a></p>",
        "id": 319577480,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1672922570
    },
    {
        "content": "<p>I somewhat agree with Sebastian Reichelt's comment on your post, Kevin, that the proof assistant should make the experience of using partial functions more convenient, independently of the question of the practical use of junk values. For example (maybe I'm totally misunderstanding how proof assistants work), when writing <code>real.sqrt x</code>, the proof assistant should let you keep on proving things without interruption, while silently introducing another goal <code>x ≥ 0</code> to be completed later. If such goals are showing up repeatedly throughout the proof, then a list of local \"facts\" may be declared and proven at the beginning of your proof / block, which the compiler can automatically use to discharge such goals.</p>",
        "id": 319691686,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1672961041
    },
    {
        "content": "<p>that would be nice, but I think it is mostly wishful thinking to think that those goals would be silently created and/or discharged without interrupting the \"flow\"</p>",
        "id": 319692325,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1672961329
    },
    {
        "content": "<p>A whole series of real functions happen to have junk values defined to be equal to the real part of the (principal value of the) corresponding complex function at that argument; that applies to <code>sqrt</code>, <code>log</code>, <code>arcsin</code>, <code>arccos</code>, <code>rpow</code> at least (though only <code>rpow</code> has that stated as the definition, rather than it being a possibly accidental consequence of the definition, and we don't have the complex square root or inverse trigonometric functions defined at all in mathlib at present). It seems those junk values often work well together to reduce the number of times hypotheses are needed that arguments are in range.</p>",
        "id": 319703228,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1672967671
    },
    {
        "content": "<p>Doesn't typing <code>suffices h : 0 &lt;= x</code> basically just keep the <code>0 &lt;= x</code> goal out of the way and force you to prove it at the end instead of immediately? I know no one uses it that way but I don't really think that Winston Yin's suggestion is infeasible with our current tactics. Discharging these goals is probably the hard part. It could perhaps be some new syntax, like two underscores or something, that you use instead of a proof to defer the proof until the end.</p>",
        "id": 319703229,
        "sender_full_name": "Niels Voss",
        "timestamp": 1672967672
    },
    {
        "content": "<blockquote>\n<p>A whole series of real functions happen to have junk values defined to be equal to the real part of the ...</p>\n</blockquote>\n<p>Then I am happy to stop calling them junk and call them unconventional instead. Seems to me they're no different than \"0! = 1\" or \"heaviside(0) = 1/2\" in spirit. From the standpoint of popularising formalisation towards mathematicians, this (philosophical) point about partial functions would have to be made clear from the beginning, probably somewhere on the path of de-conversion from set theory. Then I'll just accept that \"any practical implementation of type theory really doesn't like partial functions\".</p>",
        "id": 319720686,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1672982992
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"521331\">@Niels Voss</span> You would still be typing more lines of proof than you have to do now. Which I would rather not.</p>",
        "id": 319720869,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1672983155
    },
    {
        "content": "<p>I guess I agree with that. Also, having read all the replies to this thread, I agree now that having <code>1 - 2</code> be <code>0</code> is probably the best that we can do in practice, though I agree with Winston Yin that this should be documented somewhere.</p>",
        "id": 319721099,
        "sender_full_name": "Niels Voss",
        "timestamp": 1672983358
    },
    {
        "content": "<p>My point is that it should not only be documented on <code>nat.sub</code>, but in any introduction to computer formalisation of maths. For me that was TPiL, but it was not clear to me then how much Lean doesn't like partial functions and subtypes.</p>",
        "id": 319721350,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1672983544
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions/near/319720869\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"521331\">Niels Voss</span> You would still be typing more lines of proof than you have to do now. Which I would rather not.</p>\n</blockquote>\n<p>I think this is actually false</p>",
        "id": 319734891,
        "sender_full_name": "Reid Barton",
        "timestamp": 1672992706
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> Would you bundle the side conditions? Otherwise I don't see how you would save on lines.</p>",
        "id": 319735015,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1672992767
    },
    {
        "content": "<p>Unless you have some really smart automation going on.</p>",
        "id": 319735034,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1672992779
    },
    {
        "content": "<p>You basically always need to know whatever facts guarantee that what you wrote down was \"well-defined\" (else, why not just write 37 instead?) and if you make those proofs arguments to the partial functions, then they are available for later automation</p>",
        "id": 319735259,
        "sender_full_name": "Reid Barton",
        "timestamp": 1672992896
    },
    {
        "content": "<p>But that can also be done with our current strategy, right?</p>",
        "id": 319735675,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1672993121
    },
    {
        "content": "<p>You add <code>have aux1 : side condition</code> to your context, and voila, it is available to automation.</p>",
        "id": 319735702,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1672993139
    },
    {
        "content": "<p>only sufficiently local automation</p>",
        "id": 319735737,
        "sender_full_name": "Reid Barton",
        "timestamp": 1672993162
    },
    {
        "content": "<p>Anyways, I'm fairly convinced that the mathlib wisdom on this is just wrong but I don't think it will change.</p>",
        "id": 319735766,
        "sender_full_name": "Reid Barton",
        "timestamp": 1672993178
    },
    {
        "content": "<p>Are there examples of libraries (preferably with a DTT foundation) that take a different route?</p>",
        "id": 319735863,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1672993234
    },
    {
        "content": "<p>Also, if you want to pass the side condition to the partial function (which isn't what Niels was suggesting in the post I replied to) then how would you combine that with readable notation?</p>",
        "id": 319735940,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1672993275
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110043\">Gabriel Ebner</span> <a href=\"#narrow/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions/near/319449932\">said</a>:</p>\n<blockquote>\n<p>And even then they're merely unspecified, you can still prove all kinds of theorems about them.  Like <code>(a / b)^2 + 1 &gt; 0</code>.</p>\n</blockquote>\n<p>That only applies to type theory. In set theory, a function is a set of ordered pairs. If called with an argument outside of the domain, the result can be any set (choice-based set parametrized with the function and the argument), which is not necessarily in the codomain. So, you couldn't prove <code>(a / b)^2 + 1 &gt; 0</code> if <code>a</code> or <code>b</code> cannot be proved to be real numbers for example.</p>",
        "id": 319737388,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1672994059
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions/near/319735259\">said</a>:</p>\n<blockquote>\n<p>You basically always need to know whatever facts guarantee that what you wrote down was \"well-defined\" (else, why not just write 37 instead?) and if you make those proofs arguments to the partial functions, then they are available for later automation</p>\n</blockquote>\n<p>Making more functions take proofs as arguments will lead to <code>rw</code> throwing <code>motive not type correct</code> all the time.</p>",
        "id": 319737617,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1672994200
    },
    {
        "content": "<p>I think the idea for having an \"unknown\" junk value (or an implicit junk value as a corollary of using <code>classical.epsilon</code>) rather than an explicit default value is to prevent us from proving nonsense theorems (such as <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.div_zero\">docs#nat.div_zero</a>), simply because they are counter-intuitive to most mathematicians, and generally a bad advertisement for Lean. Instead, the right path would be to invent a better way of dealing with those special conditions.</p>",
        "id": 319738456,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1672994606
    },
    {
        "content": "<blockquote>\n<p>That only applies to type theory.</p>\n</blockquote>\n<p>Obviously we're only talking about Lean('s foundations) here.  There are other foundations where partiality is even \"better\" handled, and you can't even prove <code>a / b = a / b</code> (which is a junk theorem provable in set theory).</p>",
        "id": 319837755,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1673029908
    },
    {
        "content": "<p>Do you have an example of such foundations? I'm interested to learn more about them.</p>",
        "id": 319883493,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1673049359
    },
    {
        "content": "<p>BTW, I think <code>a / b = a / b</code> would be the expected result no matter what <code>a</code> and <code>b</code> are. Most mathematicians would agree that <code>1 / 0 = 1 / 0</code>, even though <code>1 / 0</code> may not be a real number, but it is definitely \"something\", and any object is equal to itself. (Unless equality is a partial relation?)</p>",
        "id": 319883578,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1673049404
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions/near/319692325\">said</a>:</p>\n<blockquote>\n<p>that would be nice, but I think it is mostly wishful thinking to think that those goals would be silently created and/or discharged without interrupting the \"flow\"</p>\n</blockquote>\n<p>This reminds me of what I see WolframAlpha doing sometimes. For example, <a href=\"https://www.wolframalpha.com/input?i=a+x+%5E+2+%2B+b+x+%2B+c+%3D+0+solve+for+x\">https://www.wolframalpha.com/input?i=a+x+%5E+2+%2B+b+x+%2B+c+%3D+0+solve+for+x</a>. The answer depends on whether or not a and b are 0, and I didn’t specify. But I still get an answer — in fact, I get a few answers, along with the additional hypotheses needed to get to each one.</p>",
        "id": 319885540,
        "sender_full_name": "Tyler Josephson ⚛️",
        "timestamp": 1673050826
    },
    {
        "content": "<p>We have this thing called partial equivalence relations, and it is very useful in proving type theoretic theorems. Also, some constructive foundations use this (a type equipped with a PER) when you don't have good quotients and subtypes.</p>",
        "id": 319905330,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1673067779
    },
    {
        "content": "<p>We have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/divp\">docs#divp</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/has_deriv_at\">docs#has_deriv_at</a>, and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nnreal.sqrt\">docs#nnreal.sqrt</a> for people who want to avoid junk values.</p>",
        "id": 319919992,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1673080094
    }
]