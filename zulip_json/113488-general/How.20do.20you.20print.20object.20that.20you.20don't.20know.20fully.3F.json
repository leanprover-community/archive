[
    {
        "content": "<p>I'm studying LEAN4 internals and I want to see the result of <code>Lean.readModuleData</code> function, however, I cannot print it (its type is <code>ModuleData × CompactedRegion</code>) and I cannot derive <code>ToString</code> for it also. In situation like this, how do you print objects? I think implementing printing function for every types is really painful.</p>",
        "id": 498492721,
        "sender_full_name": "lunuy",
        "timestamp": 1739013038
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"815149\">lunuy</span> <a href=\"#narrow/channel/113488-general/topic/How.20do.20you.20print.20object.20that.20you.20don't.20know.20fully.3F/near/498492721\">said</a>:</p>\n<blockquote>\n<p>I think implementing printing function for every types is really painful.</p>\n</blockquote>\n<p>In the same boat at present.</p>\n<p>What is somewhat helpful but only for the simpler types is using an LLM. Currently find some success with simpler types using <a href=\"https://claude.ai/\">Claude</a> and/or <a href=\"https://mistral.ai/en\">Mistral</a> but  have not tried all LLMs, e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Create</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"n\">toString</span><span class=\"w\"> </span><span class=\"n\">and</span><span class=\"w\"> </span><span class=\"n\">toJson</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"n\">type</span>\n\n<span class=\"bp\">&lt;</span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">definition</span><span class=\"bp\">&gt;</span>\n</code></pre></div>\n<p>Also consider using Lean <a href=\"https://leanprover-community.github.io/mathlib4_docs/Lean/Data/Json/FromToJson.html#Lean.ToJson\">toJson</a>. </p>\n<p>One caveat I found with toJson is that a <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Data/List/Basic.html\">Lean list</a>, ( <code>['a','b','c']</code> ) and a <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Data/Array\">Lean array</a> ( <code> #['a','b','c']</code>) will both be converted to a JSON array as there is no JSON list. (<a href=\"https://www.json.org/json-en.html\">JSON syntax</a>)</p>\n<p>My lean file for experimenting with toString and toJson. <br>\nHad to cut off much of it to meet the posting length. <span aria-label=\"frown\" class=\"emoji emoji-1f641\" role=\"img\" title=\"frown\">:frown:</span></p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>example.lean</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\"><pre><span></span><code>import Lean.Data.Json    -- ToJson\n\n-- https://github.com/teorth/equational_theories/blob/main/equational_theories/ParseImplications.lean#L12-L20\nstructure Implication where\n  lhs : String\n  rhs : String\n  finite : Bool\nderiving Lean.ToJson\n\n#print Implication\n/-\nstructure Implication : Type\nnumber of parameters: 0\nfields:\n  Implication.lhs : String\n  Implication.rhs : String\n  Implication.finite : Bool\nconstructor:\n  Implication.mk (lhs rhs : String) (finite : Bool) : Implication\n-/\n\n-- Define the ToString instance for Implication\ninstance : ToString Implication where\n  toString imp :=\n    &quot;Implication { lhs := &quot; ++ imp.lhs ++\n    &quot;, rhs := &quot; ++ imp.rhs ++\n    &quot;, finite := &quot; ++ toString imp.finite ++ &quot; }&quot;\n\n#check { lhs := &quot;a&quot;, rhs := &quot;b&quot;, finite := true : Implication }\n-- { lhs := &quot;a&quot;, rhs := &quot;b&quot;, finite := true } : Implication\n#check Implication.mk &quot;A&quot; &quot;B&quot; true\n-- { lhs := &quot;A&quot;, rhs := &quot;B&quot;, finite := true } : Implication\n#eval Implication.mk &quot;A&quot; &quot;B&quot; true\n-- Implication { lhs := A, rhs := B, finite := true }\n#eval IO.println (Lean.toJson { lhs := &quot;a&quot;, rhs := &quot;b&quot;, finite := true : Implication } ).pretty\n-- {&quot;rhs&quot;: &quot;b&quot;, &quot;lhs&quot;: &quot;a&quot;, &quot;finite&quot;: true}\n#eval toString { lhs := &quot;a&quot;, rhs := &quot;b&quot;, finite := true : Implication }\n-- &quot;Implication { lhs := a, rhs := b, finite := true }&quot;\ndef Implication_01 := Implication.mk &quot;A&quot; &quot;B&quot; true\n#check Implication_01\n-- Implication_01 : Implication\n#eval Implication_01\n-- Implication { lhs := A, rhs := B, finite := true }\n#eval toString Implication_01\n-- &quot;Implication { lhs := A, rhs := B, finite := true }&quot;\n#eval IO.println (Lean.toJson (Implication.mk &quot;a&quot; &quot;b&quot; true)).pretty\n-- {&quot;rhs&quot;: &quot;b&quot;, &quot;lhs&quot;: &quot;a&quot;, &quot;finite&quot;: true}\n#eval IO.println (Lean.toJson Implication_01 ).pretty\n-- {&quot;rhs&quot;: &quot;B&quot;, &quot;lhs&quot;: &quot;A&quot;, &quot;finite&quot;: true}\n\n-- ----------------------------------------------------------------------------\n\n-- Define an list of strings\ndef listOfStrings : List String := [&quot;a&quot;, &quot;b&quot;, &quot;1&quot;, &quot;Hello, World&quot;]\n#check listOfStrings\n-- listOfStrings : List String\n#eval listOfStrings\n-- [&quot;a&quot;, &quot;b&quot;, &quot;1&quot;, &quot;Hello, World&quot;]\n#eval toString listOfStrings\n-- &quot;[a, b, 1, Hello, World]&quot;\n#eval IO.println (Lean.toJson listOfStrings).pretty\n-- [&quot;a&quot;, &quot;b&quot;, &quot;1&quot;, &quot;Hello, World&quot;]\n\n-- Define an array of strings\ndef arrayOfStrings : Array String := #[&quot;a&quot;,&quot;b&quot;,&quot;1&quot;,&quot;Hello, World&quot;]\n#check arrayOfStrings\n-- arrayOfStrings : Array String\n#eval arrayOfStrings\n-- #[&quot;a&quot;, &quot;b&quot;, &quot;1&quot;, &quot;Hello, World&quot;]\n#eval toString arrayOfStrings\n-- &quot;#[a, b, 1, Hello, World]&quot;\n#eval IO.println (Lean.toJson arrayOfStrings).pretty\n-- [&quot;a&quot;, &quot;b&quot;, &quot;1&quot;, &quot;Hello, World&quot;]\n\ninstance : ToString (Array String) where\n  toString arr :=\n    let items := arr.map (fun s =&gt; &quot;\\&quot;&quot; ++ s ++ &quot;\\&quot;&quot;)\n    let joined := String.intercalate &quot;, &quot; items.toList\n    s!&quot;[{joined}]&quot;\n\n#eval toString (#[&quot;hello&quot;, &quot;world&quot;])\n-- &quot;[\\&quot;hello\\&quot;, \\&quot;world\\&quot;]&quot;\n#eval toString (#[&quot;hello world&quot;])\n-- &quot;[\\&quot;hello world\\&quot;]&quot;\n#eval toString (#[&quot;hello, world&quot;])\n-- &quot;[\\&quot;hello, world\\&quot;]&quot;\n#eval toString listOfStrings\n-- &quot;[a, b, 1, Hello, World]&quot;\n#eval toString arrayOfStrings\n-- &quot;[\\&quot;a\\&quot;, \\&quot;b\\&quot;, \\&quot;1\\&quot;, \\&quot;Hello, World\\&quot;]&quot;  -- NB This changed with the addition of `instance : ToString (Array String) where`\n</code></pre></div>\n</div></div>",
        "id": 498493616,
        "sender_full_name": "Eric Taucher",
        "timestamp": 1739013884
    },
    {
        "content": "<p>You can enclose code in quadruple backticks to display it properly in spoilers.</p>",
        "id": 498501350,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1739020606
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113488-general/topic/How.20do.20you.20print.20object.20that.20you.20don't.20know.20fully.3F/near/498501350\">said</a>:</p>\n<blockquote>\n<p>You can enclose code in quadruple backticks to display it properly in spoilers.</p>\n</blockquote>\n<p>Did not know that trick for Zulip markdown. To many variations for Markdown and too many forums to learn, oh my!</p>",
        "id": 498502243,
        "sender_full_name": "Eric Taucher",
        "timestamp": 1739021293
    },
    {
        "content": "<p>That's a standard markdown feature I believe. When you want to enclose something that contains <code>n</code> consecutive backticks, you can use <code>n + 1</code> consecutive backticks</p>",
        "id": 498502758,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1739021688
    },
    {
        "content": "<p>The use of \"standard\" when referring to markdown is somewhat risky :)</p>",
        "id": 498506006,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1739024426
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"815149\">@lunuy</span> There are objects of unknown (to lean) type stored inside <code>ModuleData</code>. <code>CompactedRegion</code> you can ignore, it's not really a piece of data itself but rather a handle to the region which stores the <code>ModuleData</code>, and which can be used (unsafely) to deallocate it. You can view arbitrary lean objects using the structure that the garbage collector uses to do its job; this is implemented in the <a href=\"https://github.com/digama0/oleandump\">oleandump</a> library, invented precisely for being able to inspect the module data in .olean files</p>",
        "id": 499066332,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739296259
    }
]