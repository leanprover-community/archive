[
    {
        "content": "<p>In <a class=\"stream-topic\" data-stream-id=\"516743\" href=\"/#narrow/channel/516743-computer-science/topic/CCS.20behavioural.20theory/with/539557956\">#computer science &gt; CCS behavioural theory</a>, we're trying to use <code>Subtype</code> to exclude some cases of an inductive:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Act</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">coname</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">τ</span>\n\n<span class=\"sd\">/-- An action is visible if it a name or a coname. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Act</span><span class=\"bp\">.</span><span class=\"n\">IsVisible</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Act</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">True</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">coname</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">True</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">τ</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">False</span>\n\n<span class=\"sd\">/-- The type of visible actions. -/</span>\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">VisibleAct</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Act</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"bp\">.</span><span class=\"n\">IsVisible</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"c1\">-- Tried both abbrev and def, no big difference</span>\n</code></pre></div>\n<p>That works well, and <code>match</code> seems smart at detecting that when we deal directly with values of that subtype.</p>\n<p>But when we try to do <code>cases</code> on another inductive with a constructor that <em>uses</em> the subtype, like this</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Tr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Process</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"w\"> </span><span class=\"n\">Constant</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Act</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Process</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"w\"> </span><span class=\"n\">Constant</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">...</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">com</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">VisibleAct</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Tr</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"n\">p'</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Tr</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"bp\">.</span><span class=\"n\">co</span><span class=\"w\"> </span><span class=\"n\">q'</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Tr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">par</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">Act</span><span class=\"bp\">.</span><span class=\"n\">τ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">par</span><span class=\"w\"> </span><span class=\"n\">p'</span><span class=\"w\"> </span><span class=\"n\">q'</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>we get into trouble with dependent elimination. To solve that, we gotta do cases on the subtype value first, which is annoying: <a href=\"https://github.com/leanprover/cslib/blob/2f5aa093f3facb49d51dbac76087f781d1f89406/Cslib/Languages/CCS/BehaviouralTheory.lean#L140\">https://github.com/leanprover/cslib/blob/2f5aa093f3facb49d51dbac76087f781d1f89406/Cslib/Languages/CCS/BehaviouralTheory.lean#L140</a></p>\n<p>Perhaps this has been discussed in general terms already?</p>",
        "id": 539561037,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1757943498
    },
    {
        "content": "<p>Does defining the predicate as an inductive type help?</p>",
        "id": 539608824,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1757955192
    },
    {
        "content": "<p>You mean IsVisible? I'll try, it might!</p>",
        "id": 539609489,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1757955444
    },
    {
        "content": "<p>It doesn't, unfortunately. I've hacked a bit at the <code>Coe</code> instance for the subtype, and making one manually using <code>match</code> reveals that <code>cases</code> on a <code>Tr</code> tries to do this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Dependent</span><span class=\"w\"> </span><span class=\"n\">elimination</span><span class=\"w\"> </span><span class=\"n\">failed</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Failed</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">solve</span><span class=\"w\"> </span><span class=\"n\">equation</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"bp\">.</span><span class=\"n\">co</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">property</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">coname</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">property</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">coname</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">    </span><span class=\"n\">τ</span>\n</code></pre></div>",
        "id": 539623179,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1757960310
    },
    {
        "content": "<p>(Lean is able to see that the match is complete, btw.)</p>",
        "id": 539623436,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1757960394
    },
    {
        "content": "<p>is there a chance that something like <code>fun_cases</code> or <code>fun_induction</code> is a tactic that does what you want?</p>",
        "id": 539626627,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1757961632
    },
    {
        "content": "<p>alternatively, you could try to write your own inductive principle for the cases/match/induction you want (where you do the cases on the subtype first), then set that to the default (if that is something you want) or manually supply that whenever you need to do this kind of matching by supplying a <code>using</code> argument</p>",
        "id": 539627629,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1757962021
    },
    {
        "content": "<p>finally, if neither of those work, you could consider passing around the proof as a separate argument, rather than working with <code>Subtype</code></p>",
        "id": 539627715,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1757962059
    },
    {
        "content": "<p>I've tried these options. The second was the most promising, but the issue is that I'm doing cases on <code>Tr</code>, which has a constructor using the subtype in question. That's where it fails. If I try a <code>using</code>, it complains that the recursor is for <code>VisibleAct</code> instead of <code>Tr</code>.</p>\n<p>What's <code>cases</code> doing when it deals with <code>Tr.com</code>? I feel like it's blindly (but understandably) applying the recursor for <code>Act</code>, because that's what the subtype is upcast to in <code>Tr.com</code>. Is there any way to control this?</p>",
        "id": 539630607,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1757963235
    },
    {
        "content": "<p>what i meant is write a custom inductor for <code>Tr</code> which you supply with <code>using</code> (or set to default)</p>",
        "id": 539631442,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1757963615
    },
    {
        "content": "<p>Ah, that'd of course be an option, but it'd also mean renouncing modularity, as the details of how I implemented VisibleAct end up affecting all the types that use it. If I had defined VisibleAct as a normal inductive copy-pasting the constructors from Act, I wouldn't have this problem, I expect. (Edit: actually, maybe I would, because I'd still have the upcast in <a href=\"http://Tr.com\">Tr.com</a>? Will check.)<br>\nI'm trying to find a way that avoids this copy-paste.</p>",
        "id": 539672395,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1757988930
    }
]