[
    {
        "content": "<p>I did Advent of Code in Lean (<a href=\"https://github.com/andrewmw94/2024_advent_of_code\">https://github.com/andrewmw94/2024_advent_of_code</a>) and one difficulty I ran into repeatedly was proving termination of standard graph algorithms (DFS, BFS or Dijkstra's) on finite graphs. I just used <code>sorry</code> and am now coming back to try to prove termination for these. My approach is to use a set of <em>unvisited</em> nodes (so the complement of the typical set) and prove that set decreases. I got this working (ignoring the needed LawfulBEq and LawfulHashable proofs) here: <a href=\"https://github.com/andrewmw94/2024_advent_of_code/blob/main/aoc_day6/AocDay6/Thm.lean\">https://github.com/andrewmw94/2024_advent_of_code/blob/main/aoc_day6/AocDay6/Thm.lean</a></p>\n<p>I'm unhappy with this for two reasons:<br>\n1) Building the unvisited set could take a lot of time / memory that shouldn't really be needed.<br>\n2) I can imagine some problems where I know the graph is finite, but enumerating every node isn't tractable. </p>\n<p>Am I approaching this wrong? How would you prove termination if you know the graph is finite but don't know the number of nodes?</p>\n<p>For a stand-alone example, I have <code>f1</code> which needs the same sort of proof, so you can just look at the first 38 lines.</p>",
        "id": 491461672,
        "sender_full_name": "Andrew Wells",
        "timestamp": 1735698112
    },
    {
        "content": "<p>You can track the set of visited nodes instead and have <code>(total nodes in graph) - visited.size</code> as the <code>termination_by</code> clause.</p>",
        "id": 491469370,
        "sender_full_name": "pandaman",
        "timestamp": 1735706574
    },
    {
        "content": "<p>Here is my DFS reachability code. It uses a custom set type, but the idea about the termination is the same. It also uses a stack to make the implementation tail-recursive, which prevents stack overflow.<br>\n<a href=\"https://github.com/pandaman64/lean-regex/blob/main/RegexCorrectness/VM/EpsilonClosure/Basic.lean#L24\">https://github.com/pandaman64/lean-regex/blob/main/RegexCorrectness/VM/EpsilonClosure/Basic.lean#L24</a></p>",
        "id": 491469691,
        "sender_full_name": "pandaman",
        "timestamp": 1735706945
    },
    {
        "content": "<p>If the unvisited set is only used in the termination proof and not the computation itself, then it won't use any time or memory at all. Proofs are ignored when compiling Lean code into an executable.</p>",
        "id": 491473851,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1735711085
    },
    {
        "content": "<p>Thanks for the pointer! I like this; especially that it could be expanded to take a proof that there are N unique states (each corresponding to a node) for a problem like mine. If I understand correctly, measure is defined as <code>def measure (s : SparseSet n) : Nat := n - s.count</code>, so you would need to know the size of the set. Any ideas for proving termination if you know the graph is finite but not the number of nodes?</p>",
        "id": 491554773,
        "sender_full_name": "Andrew Wells",
        "timestamp": 1735791394
    },
    {
        "content": "<p>Usually, we assume the number of nodes in a graph is known beforehand when writing a graph algorithm.</p>\n<p>If it's not the case (like discovering possible moves as we search through the states), I think you would need to know an upper bound of <code>n</code> (from the fact that the search space is finite). For example, I can imagine we can define a function like <code>def traverse {n : Nat} (visited : Std.HashSet Nat) (bound : visited.size &lt; n)</code> with <code>termination_by =&gt; n - visited.size</code>. Hopefully, the calculation of <code>n</code> on the caller would be erased.</p>",
        "id": 491581567,
        "sender_full_name": "pandaman",
        "timestamp": 1735808957
    },
    {
        "content": "<p>I wrote something similar to the <code>traverse</code> you're describing a while ago:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Std.Data.HashMap</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Std</span>\n\n<span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">HashMap.size_le_fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std.HashMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m.size</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"k\">suffices</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m.size</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"k\">from</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat.le_refl</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">k</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">generalizing</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Std.HashMap.isEmpty_iff_forall_not_mem</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Std.HashMap.isEmpty_eq_size_eq_zero</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">hm</span><span class=\"w\"> </span><span class=\"n\">hl'</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m.erase</span><span class=\"w\"> </span><span class=\"o\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">omega</span><span class=\"o\">⟩)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">omega</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kd\">by</span>\n<span class=\"w\">      </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">HashMap.mem_erase</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">beq_eq_false_iff_ne</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ne_eq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">and_imp</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"o\">⟩</span><span class=\"w\"> </span><span class=\"n\">hx'</span><span class=\"w\"> </span><span class=\"n\">hx''</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hl'</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">hx''</span>\n<span class=\"w\">      </span><span class=\"n\">simp_all</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">omega</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">HashMap.size_le_size_erase</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">omega</span><span class=\"o\">⟩)</span>\n<span class=\"w\">    </span><span class=\"n\">omega</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">dfs</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">graph</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">start</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HashMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">visit</span><span class=\"w\"> </span><span class=\"n\">start</span><span class=\"w\"> </span><span class=\"bp\">∅</span>\n<span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">visit</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cur</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">seen</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HashMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">      </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HashMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">seen.size</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">s.size</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Id.run</span><span class=\"w\"> </span><span class=\"k\">do</span>\n\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">cur</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">seen</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"o\">⟨</span><span class=\"n\">seen</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat.le_refl</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">⟩</span>\n<span class=\"w\">    </span><span class=\"k\">else</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">curSeen</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HashMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">seen.size</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">s.size</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">        </span><span class=\"o\">⟨</span><span class=\"n\">seen.insert</span><span class=\"w\"> </span><span class=\"n\">cur</span><span class=\"w\"> </span><span class=\"n\">seen.size</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">HashMap.size_insert</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">]⟩</span>\n\n<span class=\"w\">      </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">graph</span><span class=\"w\"> </span><span class=\"n\">cur</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">        </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">curSeen.val.size</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">seen.size</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">HashMap.size_le_fin</span><span class=\"w\"> </span><span class=\"n\">curSeen.val</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">omega</span>\n<span class=\"w\">        </span><span class=\"n\">curSeen</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">⟨</span><span class=\"n\">visit</span><span class=\"w\"> </span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"n\">curSeen</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat.lt_of_lt_of_le</span><span class=\"w\"> </span><span class=\"n\">curSeen.property</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">visit</span><span class=\"w\"> </span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"n\">curSeen</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">property</span><span class=\"o\">⟩</span>\n\n<span class=\"w\">      </span><span class=\"o\">⟨</span><span class=\"n\">curSeen.val</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat.le_of_lt</span><span class=\"w\"> </span><span class=\"n\">curSeen.property</span><span class=\"o\">⟩</span>\n<span class=\"w\">  </span><span class=\"n\">termination_by</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">seen.size</span>\n</code></pre></div>",
        "id": 491589743,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1735813539
    }
]