[
    {
        "content": "<p>In Lean 4, when a theorem is marked as <code>@[simp]</code>, does the elaborator automatically apply <code>funext</code> and <code>propext</code> before adding the theorem to the simp set? For example, does the following statement:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"bp\">¬</span><span class=\"n\">P</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span><span class=\"n\">Q</span>\n</code></pre></div>\n<p>get transformed to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"n\">Q</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">¬</span><span class=\"n\">P</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span><span class=\"n\">Q</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and the new proof (proved implicitly) gets added to the simp set? Or does <code>simp</code> store the theorem as is, and apply <code>funext</code> and <code>propext</code> ad-hoc on the place of simplification?</p>",
        "id": 324314661,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1674921348
    },
    {
        "content": "<p><code>propext</code> gets automatically added, so having <code>∀ (P Q : Prop), ¬(P ∧ Q) ↔ ¬P ∨ ¬Q</code> as a simp lemma will/should be the same as having <code>∀ (P Q : Prop), ¬(P ∧ Q) = ¬P ∨ ¬Q</code>. However, <code>funext</code> doesn't get automatically applied. If your simp lemma states <code>f x = g x</code>, then <code>f '' s</code> won't be simplified to <code>g '' s</code>. If you want that, you need to reformulate your lemma to <code>f  = g</code>. <br>\nAt least, that it my understanding of it.</p>",
        "id": 324417418,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1674990804
    }
]