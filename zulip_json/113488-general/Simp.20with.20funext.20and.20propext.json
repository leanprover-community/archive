[
    {
        "content": "<p>In Lean 4, when a theorem is marked as <code>@[simp]</code>, does the elaborator automatically apply <code>funext</code> and <code>propext</code> before adding the theorem to the simp set? For example, does the following statement:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"bp\">¬</span><span class=\"n\">P</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span><span class=\"n\">Q</span>\n</code></pre></div>\n<p>get transformed to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"n\">Q</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">¬</span><span class=\"n\">P</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span><span class=\"n\">Q</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and the new proof (proved implicitly) gets added to the simp set? Or does <code>simp</code> store the theorem as is, and apply <code>funext</code> and <code>propext</code> ad-hoc on the place of simplification?</p>",
        "id": 324314661,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1674921348
    },
    {
        "content": "<p><code>propext</code> gets automatically added, so having <code>∀ (P Q : Prop), ¬(P ∧ Q) ↔ ¬P ∨ ¬Q</code> as a simp lemma will/should be the same as having <code>∀ (P Q : Prop), ¬(P ∧ Q) = ¬P ∨ ¬Q</code>. However, <code>funext</code> doesn't get automatically applied. If your simp lemma states <code>f x = g x</code>, then <code>f '' s</code> won't be simplified to <code>g '' s</code>. If you want that, you need to reformulate your lemma to <code>f  = g</code>. <br>\nAt least, that it my understanding of it.</p>",
        "id": 324417418,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1674990804
    },
    {
        "content": "<p>I believe that there is a <code>higher_order</code> attribute that does this automatically:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">def</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">@[simp, higher_order]</span> <span class=\"kd\">lemma</span> <span class=\"n\">f_eq_g</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> Without `higher_order` on f_eq_g, this does not work -/</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"o\">(</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"bp\">∘</span> <span class=\"o\">(</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 325037446,
        "sender_full_name": "Praneeth Kolichala",
        "timestamp": 1675206844
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/tactic.higher_order_attr\">docs#tactic.higher_order_attr</a></p>",
        "id": 325536237,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1675391210
    }
]