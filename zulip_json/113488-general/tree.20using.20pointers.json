[
    {
        "content": "<p>I'm trying to make a tree/graph using pointers and I'm getting mutually inductive type error. Does anyone have any suggestions on how I should implement it?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- (kernel) mutually inductive types must live in the same universe</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">AutoDiffNode</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mk</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">outShape</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">parents</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ST</span><span class=\"bp\">.</span><span class=\"n\">Ref</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">RealWorld</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">AutoDiffNode</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)))</span>\n<span class=\"w\">    </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AutoDiffNode</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span>\n</code></pre></div>",
        "id": 490692758,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1735057661
    },
    {
        "content": "<p>i'm pretty sure inductive types already use pointers...</p>",
        "id": 490705365,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1735066763
    },
    {
        "content": "<p>that aside, this looks to me like a lean bug...</p>",
        "id": 490705463,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1735066819
    },
    {
        "content": "<p>Not a bug. When the kernel translates this nested inductive type into a mutual type, <code>AutoDiffNode</code> appears nested into <code>Nonempty</code> in <code>ST.Ref</code>, which lives in Prop (and thus, so does it’s auxiliary inductive translation), leading to this error.</p>",
        "id": 490709824,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1735070276
    },
    {
        "content": "<p>im trying to create a computation graphs where you can have multiple nodes pointing to the same node</p>",
        "id": 490709911,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1735070330
    },
    {
        "content": "<p>are refs the wrong approach for this</p>",
        "id": 490710589,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1735070823
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"676310\">Frederick Pu</span> <a href=\"#narrow/channel/113488-general/topic/tree.20using.20pointers/near/490709911\">said</a>:</p>\n<blockquote>\n<p>im trying to create a computation graphs where you can have multiple nodes pointing to the same node</p>\n</blockquote>\n<p>If it's acyclic then you should be able to directly use inductive types</p>",
        "id": 490742299,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1735102294
    },
    {
        "content": "<p>but if u have some node <code>x</code> and <code>y = mk _ #[x]</code> and you modify the value of <code>y</code>, how can u guarantee that your variable <code>x</code> will be changed? wouldnt u still need some sort of ref system?</p>",
        "id": 490780806,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1735134477
    },
    {
        "content": "<p>i think the best approach is just to store pointers to the data of the tree nodes rather than the tree nodes themselves, since my main goal is for multiple recursive calls to be able to modify the same trees data values: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">AutoDiffNode</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mk</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">outShape</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ST</span><span class=\"bp\">.</span><span class=\"n\">Ref</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">RealWorld</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">parents</span><span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">AutoDiffNode</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AutoDiffNode</span>\n</code></pre></div>",
        "id": 490795328,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1735147683
    },
    {
        "content": "<p>For mutable graphs you'll likely want to use an index-based data structure like one would in Rust <a href=\"https://smallcultfollowing.com/babysteps/blog/2015/04/06/modeling-graphs-in-rust-using-vector-indices/\">https://smallcultfollowing.com/babysteps/blog/2015/04/06/modeling-graphs-in-rust-using-vector-indices/</a></p>",
        "id": 490796071,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1735148470
    },
    {
        "content": "<p>is the IO.RealWorld based ref slower?</p>",
        "id": 490796637,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1735149105
    }
]