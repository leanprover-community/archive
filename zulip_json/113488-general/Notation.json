[
    {
        "content": "<p>Does anyone have a suggestion for Lean-friendly notation corresponding to TeX <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>f</mi><mo>∗</mo></msub></mrow><annotation encoding=\"application/x-tex\">f_*</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.175696em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>f</mi><mo>∗</mo></msup></mrow><annotation encoding=\"application/x-tex\">f^*</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.688696em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span></span></span></span>?<br>\n(Meaning whatever you want them to mean, but for example, post- and pre-composition with the morphism <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span></span></span></span>.)</p>",
        "id": 123093960,
        "sender_full_name": "Reid Barton",
        "timestamp": 1519832510
    },
    {
        "content": "<p>Apparently there are no Unicode subscript or superscript asterisk characters</p>",
        "id": 123094002,
        "sender_full_name": "Reid Barton",
        "timestamp": 1519832529
    },
    {
        "content": "<p><code>f^*</code> works okay for <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>f</mi><mo>∗</mo></msup></mrow><annotation encoding=\"application/x-tex\">f^*</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.688696em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span></span></span></span>, but <code>f_*</code> isn't as nice because <code>f_</code> parses as a single identifier, so it needs a space.</p>",
        "id": 123095373,
        "sender_full_name": "Reid Barton",
        "timestamp": 1519834649
    },
    {
        "content": "<p>you could cheat and use ＿, which is not _</p>",
        "id": 123097520,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1519837456
    },
    {
        "content": "<p>Or use one of the up/down arrows</p>",
        "id": 123097707,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1519837661
    },
    {
        "content": "<p>Any mathematician : \"Let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.00773em;\">R</span></span></span></span> be a ring and let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span> be <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-algebras. Then...\". Lean: <code>{R : Type*} [comm_ring R] {A : Type*} [comm_ring A] {B : Type*} [comm_ring B]\n  [algebra R A] [algebra R B]</code>. Can we somehow make this Lean code look less scary to mathematicians? Of course <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.00773em;\">R</span></span></span></span> is a type, that's why it's called <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.00773em;\">R</span></span></span></span>. I wouldn't write \"let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span> be a ring\", that would be madness!</p>",
        "id": 187721413,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1581176871
    },
    {
        "content": "<p>I'm not saying Lean should do this, but in Scala this thing with type classes comes up often and they have created a separate notation for it.<br>\nAssume <code>Ring</code> is a type class in Scala with a field <code>add</code> and that <code>+</code> knows to look at <code>add</code> in rings to implement addition.  Then one can write the following verbose definition in Scala.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">def</span> <span class=\"n\">double</span><span class=\"o\">[</span><span class=\"kt\">R</span><span class=\"o\">](</span><span class=\"n\">x</span><span class=\"k\">:</span> <span class=\"kt\">R</span><span class=\"o\">)(</span><span class=\"k\">implicit</span> <span class=\"n\">ringOfR</span><span class=\"k\">:</span> <span class=\"kt\">Ring</span><span class=\"o\">[</span><span class=\"kt\">R</span><span class=\"o\">])</span> <span class=\"k\">=</span> <span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"n\">x</span>\n</pre></div>\n\n\n<p>Notice that in Scala <code>[R]</code> is a type parameter, <code>(x:R)</code> is a regular parameter, and <code>(implicit ringOfR: Ring[R])</code> is an implicit parameter (very similar to Lean's type class parameters).</p>\n<p>One can also instead use the following shorthand type class notation where we \"treat\" R as if it is an element of <code>Ring</code>:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">def</span> <span class=\"n\">double</span><span class=\"o\">[</span><span class=\"kt\">R:</span> <span class=\"kt\">Rign</span><span class=\"o\">](</span><span class=\"n\">x</span><span class=\"k\">:</span> <span class=\"kt\">R</span><span class=\"o\">)</span> <span class=\"k\">=</span> <span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"n\">x</span>\n</pre></div>\n\n\n<p>Now, this notation might be less ambiguous in Scala than in Lean, since Scala treats type parameters and regular parameters differently with different notation (i.e. Scala is not dependently typed).</p>\n<p>A similar issue exists with <code>set</code>s in Lean.  (A type class is to <code>Type</code>s as sets are to <code>Prop</code>s.)   We can write the convenient notation</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"err\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</pre></div>\n\n\n<p>But if we apply <code>intro</code> twice we get the messy notation</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"err\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</pre></div>\n\n\n<p>One could imagine an alternative notation where one writes</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"err\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</pre></div>\n\n\n<p>I'm not claiming the Lean notation should change, but it is food for thought...</p>",
        "id": 187722286,
        "sender_full_name": "Jason Rute",
        "timestamp": 1581178450
    },
    {
        "content": "<blockquote>\n<p>One could imagine an alternative notation where one writes</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"err\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</pre></div>\n\n\n</blockquote>\n<p>This actually works exactly as you wrote it. I've never been sure if it's intentional or a \"feature\" enabled by the bounded quantifier syntax. Given that the <code>a ∈ s</code> hypothesis gets the default name <code>H</code>, I don't think it's something we should encourage in mathlib.</p>",
        "id": 187722562,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1581179105
    },
    {
        "content": "<p>Here's the relevant lean 3 issue: <a href=\"https://github.com/leanprover/lean/issues/1522\" target=\"_blank\" title=\"https://github.com/leanprover/lean/issues/1522\">https://github.com/leanprover/lean/issues/1522</a></p>",
        "id": 187722565,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1581179116
    },
    {
        "content": "<p>which would have allowed us to write just <code>[algebra R A] [algebra R B]</code></p>",
        "id": 187722617,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1581179212
    },
    {
        "content": "<p>Bundling helps somewhat, e.g., <code>{R : CommRing}</code> etc., though it's tricky in algebra since you typically have a lot of different levels of structure floating around</p>",
        "id": 187728991,
        "sender_full_name": "Reid Barton",
        "timestamp": 1581191203
    },
    {
        "content": "<p>What \"things\" are <code>binders</code> <code>foldr</code> <code>scoped</code>. I can't do <code>#check</code> on any of them. Is <code>foldr</code> different to <code>list.foldr</code> - the usage looks different.</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">notation</span> <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"bp\">`</span> <span class=\"n\">l</span><span class=\"o\">:(</span><span class=\"n\">foldr</span> <span class=\"bp\">`</span><span class=\"o\">,</span> <span class=\"bp\">`</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">h</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">nil</span> <span class=\"bp\">`</span><span class=\"o\">]</span><span class=\"bp\">`</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">l</span>\n<span class=\"kn\">notation</span> <span class=\"bp\">`∃!`</span> <span class=\"n\">binders</span> <span class=\"bp\">`</span><span class=\"o\">,</span> <span class=\"bp\">`</span> <span class=\"n\">r</span><span class=\"o\">:(</span><span class=\"n\">scoped</span> <span class=\"n\">P</span><span class=\"o\">,</span> <span class=\"n\">exists_unique</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">r</span>\n</code></pre></div>",
        "id": 202167673,
        "sender_full_name": "Billy Price",
        "timestamp": 1593232963
    },
    {
        "content": "<p>they are all magic pieces of syntax of the <code>notation</code> command</p>",
        "id": 202167758,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593233105
    },
    {
        "content": "<p>They are just keywords for the <code>notation</code> command. They have no meaning in Lean.</p>",
        "id": 202167762,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1593233109
    },
    {
        "content": "<p>Even the <code>(h t, list.cons h t)</code> isn't what it looks like - it's really more like <code>(\\lam h t, list.cons h t)</code></p>",
        "id": 202167775,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593233144
    },
    {
        "content": "<p>I see some mentions in the Lean reference manual on binders, but not much for foldr or foldl - is there documentation for them?</p>\n<p>I am generally familiar with foldr and foldr, but it'd be nice to see docs on them.</p>",
        "id": 202167951,
        "sender_full_name": "Billy Price",
        "timestamp": 1593233404
    },
    {
        "content": "<p>Also scoped and binders</p>",
        "id": 202167954,
        "sender_full_name": "Billy Price",
        "timestamp": 1593233415
    },
    {
        "content": "<p>Actually I do understand what binders is, but not how it becomes related to the rest of the expression</p>",
        "id": 202167964,
        "sender_full_name": "Billy Price",
        "timestamp": 1593233458
    },
    {
        "content": "<p>It's pretty much entirely pro forma. I don't think there are many reusable subparts of the <code>notation</code> command, just those particular keywords in that order</p>",
        "id": 202177910,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593251658
    },
    {
        "content": "<p>How does Lean decide whether it will use my <code>local notation</code> for pretty printing in the goal state?</p>",
        "id": 226379418,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1613393146
    },
    {
        "content": "<p>I currently have</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">system_of_complexes</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- `C.d` is the differential `C c i ⟶ C c (i+1)` for a system of complexes `C`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">differential</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hij</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">C</span> <span class=\"n\">c</span> <span class=\"n\">i</span> <span class=\"bp\">⟶</span> <span class=\"n\">C</span> <span class=\"n\">c</span> <span class=\"n\">j</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">C.obj</span> <span class=\"bp\">$</span> <span class=\"n\">op</span> <span class=\"n\">c</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">d</span> <span class=\"n\">i</span> <span class=\"bp\">≫</span> <span class=\"n\">congr_hom</span> <span class=\"n\">_</span> <span class=\"n\">rfl</span> <span class=\"n\">hij</span>\n\n<span class=\"kn\">local</span> <span class=\"kd\">notation</span> <span class=\"bp\">`</span><span class=\"n\">d</span><span class=\"bp\">`</span> <span class=\"o\">:=</span> <span class=\"n\">differential</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">int_magic</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 226379505,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1613393192
    },
    {
        "content": "<p>Here <code>int_magic</code> is a custom tactic that shouldn't be relevant (maybe it is?!)</p>",
        "id": 226379523,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1613393214
    },
    {
        "content": "<p>I can succesfully use <code>d</code> when entering statements, but Lean doesn't use <code>d</code> in the goal window.</p>",
        "id": 226379556,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1613393239
    },
    {
        "content": "<p>The Lean 3 pretty-printer is not particularly clever, it tries to syntactically match the notation.  In your case it looks for a <code>by int_magic</code> in the goal state.</p>",
        "id": 226380700,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1613393977
    },
    {
        "content": "<p>Ok, so this will never work <span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span></p>",
        "id": 226381080,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1613394211
    },
    {
        "content": "<p>You could use auto params.</p>",
        "id": 226381168,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1613394261
    },
    {
        "content": "<p>Except that those don't play well with bundled functions...</p>",
        "id": 226382176,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1613394900
    },
    {
        "content": "<p>Probably the best investment of my time is porting mathlib to Lean4</p>",
        "id": 226382223,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1613394940
    },
    {
        "content": "<p>That will solve these issues in a more principled way <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span></p>",
        "id": 226382248,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1613394960
    },
    {
        "content": "<p>I'm trying to add notation for a diffeomorphism between two normed spaces. Here is my code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">geometry.manifold.diffeomorph</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"bp\">𝕜</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">nondiscrete_normed_field</span> <span class=\"bp\">𝕜</span><span class=\"o\">]</span>\n<span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">normed_group</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_space</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n<span class=\"o\">{</span><span class=\"n\">E'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">normed_group</span> <span class=\"n\">E'</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_space</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E'</span><span class=\"o\">]</span>\n<span class=\"o\">{</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">H</span><span class=\"o\">]</span>\n<span class=\"o\">{</span><span class=\"n\">H'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">H'</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">model_with_corners</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">I'</span> <span class=\"o\">:</span> <span class=\"n\">model_with_corners</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E'</span> <span class=\"n\">H'</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">charted_space</span> <span class=\"n\">H</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">smooth_manifold_with_corners</span> <span class=\"n\">I</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">M'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">M'</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">charted_space</span> <span class=\"n\">H'</span> <span class=\"n\">M'</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">smooth_manifold_with_corners</span> <span class=\"n\">I'</span> <span class=\"n\">M'</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">with_top</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">times_diffeomorph</span>\n\n<span class=\"kd\">notation</span> <span class=\"n\">E</span> <span class=\"bp\">`</span> <span class=\"bp\">≃ₘ^`</span> <span class=\"n\">n</span> <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"bp\">`</span> <span class=\"bp\">𝕜</span> <span class=\"bp\">`</span><span class=\"o\">]</span> <span class=\"bp\">`</span> <span class=\"n\">E'</span> <span class=\"o\">:=</span> <span class=\"n\">times_diffeomorph</span> <span class=\"o\">(</span><span class=\"n\">model_with_corners_self</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">model_with_corners_self</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E'</span><span class=\"o\">)</span> <span class=\"n\">E</span> <span class=\"n\">E'</span> <span class=\"n\">n</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">lemma</span> <span class=\"n\">times_cont_diff</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">≃ₘ^</span><span class=\"n\">n</span><span class=\"o\">[</span><span class=\"bp\">𝕜</span><span class=\"o\">]</span> <span class=\"n\">E'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">times_cont_diff</span> <span class=\"bp\">𝕜</span> <span class=\"n\">n</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">times_diffeomorph</span>\n</code></pre></div>\n<p>Lean fails to parse the lemma. What am I doing wrong? Does Lean assume that <code>[</code> in the lemma is a part of <code>n</code>?</p>",
        "id": 228667982,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1614805478
    },
    {
        "content": "<p>I see that notation for <a href=\"https://leanprover-community.github.io/mathlib_docs/find/times_diffeomorph\">docs#times_diffeomorph</a> between two manifolds uses some fancy parentheses. Should I do the same?</p>",
        "id": 228668223,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1614805567
    },
    {
        "content": "<p>If yes, how do I disambiguate new and old notation? Here is the existing notation:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">localized</span> <span class=\"s2\">\"notation M ` ≃ₘ^ `n `⟮` I `,` J `⟯` N := times_diffeomorph I J M N n\"</span> <span class=\"k\">in</span> <span class=\"n\">manifold</span>\n<span class=\"n\">localized</span> <span class=\"s2\">\"notation M ` ≃ₘ⟮` I `,` J `⟯` N := times_diffeomorph I J M N ⊤\"</span> <span class=\"k\">in</span> <span class=\"n\">manifold</span>\n</code></pre></div>",
        "id": 228668318,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1614805605
    },
    {
        "content": "<p>UPD: this works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">notation</span> <span class=\"n\">E</span> <span class=\"bp\">`</span> <span class=\"bp\">≃ₘ^`</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"mi\">1000</span> <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">50</span> <span class=\"bp\">𝕜</span> <span class=\"bp\">`</span><span class=\"o\">]</span> <span class=\"bp\">`</span> <span class=\"n\">E'</span> <span class=\"o\">:=</span> <span class=\"n\">times_diffeomorph</span> <span class=\"o\">(</span><span class=\"n\">model_with_corners_self</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">model_with_corners_self</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E'</span><span class=\"o\">)</span> <span class=\"n\">E</span> <span class=\"n\">E'</span> <span class=\"n\">n</span>\n</code></pre></div>",
        "id": 228668661,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1614805729
    },
    {
        "content": "<p>What are the policies about priorities? What should I use instead of 1000 and 50?</p>",
        "id": 228668722,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1614805754
    }
]