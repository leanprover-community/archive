[
    {
        "content": "<p>I have a hard time getting mwe, but I noticed an issue like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">EuclideanSpace</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">)}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Ioi</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">∩</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Ioi</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"bp\">#</span><span class=\"n\">count_heartbeats</span><span class=\"w\"> </span><span class=\"c1\">--33726166</span>\n<span class=\"w\">  </span><span class=\"n\">grind</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">EuclideanSpace</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">)}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Ioi</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">∩</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Ioi</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">clear</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"bp\">#</span><span class=\"n\">count_heartbeats</span><span class=\"w\"> </span><span class=\"c1\">--777105</span>\n<span class=\"w\">  </span><span class=\"n\">grind</span>\n</code></pre></div>\n<p>This is a silly little side-goal about <code>i</code> involving set membership over reals that grind should be able to dispatch quickly. The <code>S</code> and <code>T</code> are irrelevant. By removing the goal <code>h</code>, grind runs about 40x faster. Actually, on the local (not-minimzed) version, it's the difference between succeeding or not: without the <code>clear</code>, grind fails with</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">failed</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">synthesize</span>\n<span class=\"w\">  </span><span class=\"n\">LE</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Grind</span><span class=\"bp\">.</span><span class=\"n\">IntModule</span><span class=\"bp\">.</span><span class=\"n\">OfNatModule</span><span class=\"bp\">.</span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Submodule</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">WithLp</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"o\">))))</span>\n<span class=\"o\">(</span><span class=\"n\">deterministic</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">timeout</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"ss\">`typeclass</span><span class=\"bp\">`</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">maximum</span><span class=\"w\"> </span><span class=\"n\">number</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">heartbeats</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">20000</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">been</span><span class=\"w\"> </span><span class=\"n\">reached</span>\n</code></pre></div>\n<p>In the end, I can clear hypotheses, sure, but it feels a bit annoying to do <code>by clear foo; grind</code> when I want to just have <code>by grind</code> in a sidegoal. Is there a flag I can pass to grind to turn this off? I tried <code>grind -ring</code> but it didn't help. I'm also not sure if there's anything I can really do, because linear inequality solving is part of the actual final goal.</p>\n<p>An interesting heuristic to explore would be to have grind explore what it can prove only with the \"relevant\" variables first (relevant in the same sense that <code>extract_goal</code> uses - those connected by some variables to the conclusion), and then when that gets stuck, it starts processing disconnected hypotheses.</p>",
        "id": 574542867,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1771430039
    },
    {
        "content": "<p>I think that Mathlib's type classes are to blame here. The following takes 0.8 seconds to fail, which is part of your slow <code>grind</code> call:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">module</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">profiler</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">synthInstance</span><span class=\"w\"> </span><span class=\"n\">true</span>\n\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Grind</span><span class=\"bp\">.</span><span class=\"n\">OrderedAdd</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Submodule</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">WithLp</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"o\">)))</span>\n</code></pre></div>",
        "id": 574908263,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1771583129
    },
    {
        "content": "<p>I've made <a href=\"https://github.com/leanprover-community/mathlib4/pull/35563\">#35563</a> to address this slow failing synthesis.</p>",
        "id": 574912682,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1771584532
    },
    {
        "content": "<p>Now that this PR has been merged, the <code>grind</code> calls you posted have both become a bit faster, and presumably it won't time out anymore in your non-minimized version.</p>\n<p>However, the original problem remains. One issue I've noticed is that it seems that whenever <code>grind</code> encounters the type <code>ENNReal</code>, it wastes about 0.8s synthesizing type classes:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">module</span><span class=\"w\"> </span><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ENNReal</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"bp\">#</span><span class=\"n\">count_heartbeats</span><span class=\"w\"> </span><span class=\"c1\">-- 8344000</span>\n<span class=\"w\">  </span><span class=\"n\">grind</span>\n</code></pre></div>\n<p>And although it doesn't look like it, you example secretly contains the type <code>ENNReal</code>, namely via <code>WithLp.instAddCommGroup</code>.</p>",
        "id": 575192392,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1771794625
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"479299\">@Jovan Gerbscheid</span>, might you be able to add another test to MathlibTest/slow_instances.lean, to validate/guard against regressions from your <a href=\"https://github.com/leanprover-community/mathlib4/pull/35563\">#35563</a>?</p>",
        "id": 575198305,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1771799943
    },
    {
        "content": "<p>Sure, I've opened <a href=\"https://github.com/leanprover-community/mathlib4/pull/35667\">#35667</a></p>",
        "id": 575209792,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1771809415
    }
]