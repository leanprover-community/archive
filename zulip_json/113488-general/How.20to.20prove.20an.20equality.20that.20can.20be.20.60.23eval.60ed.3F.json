[
    {
        "content": "<p>I have a term like <code>function value</code> and <code>#check</code> knows that it is equal to some <code>result</code>. I want to prove my <code>example : function value = result</code>. With Lean 4.12.0, I was able to use <code>rfl</code>, but in Lean 4.13.0-rc1 (<a href=\"#narrow/channel/113488-general/topic/.E2.9C.94.20.60rfl.60.20regression.3F\">#general&gt;✔ &#96;rfl&#96; regression?</a>) it leads to an error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">dropLastElemIf</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">pred</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">pred</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">dropLastElemIf</span><span class=\"w\"> </span><span class=\"n\">pred</span><span class=\"w\"> </span><span class=\"n\">as</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"bp\">.</span><span class=\"n\">mylines</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">input</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">dropLastElemIf</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"bp\">.</span><span class=\"n\">isEmpty</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">input</span><span class=\"bp\">.</span><span class=\"n\">splitOn</span><span class=\"w\"> </span><span class=\"s2\">\"</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"s2\">\"\"</span><span class=\"bp\">.</span><span class=\"n\">mylines</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s2\">\"\"</span><span class=\"bp\">.</span><span class=\"n\">mylines</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>In Lean 4.12.0, it just passes and tells me that <code>\"\".mylines</code> evaluates to <code>[]</code>.<br>\nIn Lean 4.13.0-rc1 (and later, also in 4.14.0), it tells me that <code>\"\".mylines</code> evaluates to <code>[]</code> and then fails the proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">lean</span><span class=\"o\">:</span><span class=\"mi\">9</span><span class=\"o\">:</span><span class=\"mi\">32</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">error</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">rfl'</span><span class=\"w\"> </span><span class=\"n\">failed</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">left</span><span class=\"bp\">-</span><span class=\"n\">hand</span><span class=\"w\"> </span><span class=\"n\">side</span>\n<span class=\"w\">  </span><span class=\"s2\">\"\"</span><span class=\"bp\">.</span><span class=\"n\">mylines</span>\n<span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">definitionally</span><span class=\"w\"> </span><span class=\"n\">equal</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">right</span><span class=\"bp\">-</span><span class=\"n\">hand</span><span class=\"w\"> </span><span class=\"n\">side</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"s2\">\"\"</span><span class=\"bp\">.</span><span class=\"n\">mylines</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n</code></pre></div>\n<p>How do I prove the result of a term that Lean knows to evaluate using <code>#eval</code>? How do I tell Lean to \"just compute it\"?</p>",
        "id": 485975594,
        "sender_full_name": "Tobias Bucher",
        "timestamp": 1733268968
    },
    {
        "content": "<p><code>by native_decide</code> works here but it is discouraged, not sure why (anyone has explanations?)</p>",
        "id": 485986670,
        "sender_full_name": "nrs",
        "timestamp": 1733274098
    },
    {
        "content": "<p>The difference between versions is that well-founded recursion stopped unfolding by default. You can \"unseal\" the relevant definition:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">unseal</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"bp\">.</span><span class=\"n\">splitOnAux</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s2\">\"\"</span><span class=\"bp\">.</span><span class=\"n\">mylines</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>(I found this by guessing it might be <code>String.splitOn</code> and looked at the definition.)</p>",
        "id": 485989423,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1733275557
    },
    {
        "content": "<p>Yes, <code>native_decide</code> invokes <code>#eval</code>, and that's exactly the issue, it means you have to trust the compiler, which is fine if you trust it.</p>",
        "id": 485989714,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1733275699
    },
    {
        "content": "<p>I think <code>native_decide</code> adds an extra axiom to your theorem that is disallowed in Mathlib due to its riskiness (you can check axioms with <code>#print axioms your_theorem</code>)</p>",
        "id": 485990210,
        "sender_full_name": "Niels Voss",
        "timestamp": 1733275949
    },
    {
        "content": "<p>Is there a <code>rfl</code> on 1.14.0 that unfolds everything by default? My example can be proven by just unfolding often enough. I'd love to have a solution where I don't have to look up how all the used functions are defined.</p>\n<p>I assume <code>rfl</code> on 1.12.0 didn't need extra axioms?</p>",
        "id": 485990471,
        "sender_full_name": "Tobias Bucher",
        "timestamp": 1733276112
    },
    {
        "content": "<p>The point of that axiom <span class=\"user-mention\" data-user-id=\"521331\">@Niels Voss</span> is that it's a way for the kernel to invoke the <code>#eval</code> machinery.</p>",
        "id": 485990517,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1733276145
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"721510\">@Tobias Bucher</span> In neither 1.12.0 nor 1.14.0 does <code>rfl</code> need any extra axioms.</p>\n<p>Maybe <span class=\"user-mention\" data-user-id=\"470149\">@Joachim Breitner</span> has suggestions for how to unseal everything.</p>\n<p>One trick I know is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s2\">\"\"</span><span class=\"bp\">.</span><span class=\"n\">mylines</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"n\">kernel</span>\n</code></pre></div>\n<p>Depending on your version it might still be <code>decide!</code>.</p>",
        "id": 485990749,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1733276273
    },
    {
        "content": "<p>What this does effectively is skip the elaborator and ask the kernel directly to do <code>rfl</code>.</p>",
        "id": 485990853,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1733276307
    },
    {
        "content": "<p><code>decide!</code> worked for me on Lean 1.14.0.</p>",
        "id": 485994557,
        "sender_full_name": "Tobias Bucher",
        "timestamp": 1733278036
    },
    {
        "content": "<p>Should we just unseal <code>splitOn</code> globally? While making well-founded recursion irreducible by default is probably sensible to avoid accidental performance issues, it feels like we should opt in wherever is convenient.</p>",
        "id": 485995027,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1733278244
    },
    {
        "content": "<p>I am under the impression that any well-founded recursive function can easily lead reduction to go astray – or do you have a good reason why this won’t happen with <code>String.splitOn</code>?</p>",
        "id": 486047162,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1733304547
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/--</span>\n<span class=\"sd\">error: maximum recursion depth has been reached</span>\n<span class=\"sd\">use `set_option maxRecDepth &lt;num&gt;` to increase limit</span>\n<span class=\"sd\">use `set_option diagnostics true` to get diagnostic information</span>\n<span class=\"sd\">-/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"n\">unseal</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"bp\">.</span><span class=\"n\">splitOnAux</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s2\">\"this is a mildly long string so let's see what happens\"</span><span class=\"bp\">.</span><span class=\"n\">splitOn</span><span class=\"w\"> </span><span class=\"s2\">\"o\"</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"s2\">\"this is a mildly l\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"ng string s\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\" let's see what happens\"</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 486047691,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1733304705
    },
    {
        "content": "<p><code>splitOn</code> was not designed for kernel computation. There is a significantly simpler implementation for the kernel</p>",
        "id": 486055776,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733307146
    },
    {
        "content": "<p>Here's a structural recursive implementation of <code>splitOn</code> optimized for call-by-need:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">String</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">splitOn'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sep</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\" \"</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">sep</span><span class=\"bp\">.</span><span class=\"n\">data</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">s</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">sep₁</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">sep</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">aux</span><span class=\"w\"> </span><span class=\"n\">sep₁</span><span class=\"w\"> </span><span class=\"n\">sep</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">data</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">aux</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sep₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Char</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sep</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Char</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Char</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Char</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Char</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Char</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">String</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[],</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"o\">[]]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"bp\">«</span><span class=\"k\">match</span><span class=\"bp\">»</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">aux</span><span class=\"w\"> </span><span class=\"n\">sep₁</span><span class=\"w\"> </span><span class=\"n\">sep</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">sep₁</span><span class=\"w\"> </span><span class=\"n\">sep</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"o\">[])</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">sep₁'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">sep'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"bp\">«</span><span class=\"k\">match</span><span class=\"bp\">»</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">aux</span><span class=\"w\"> </span><span class=\"n\">sep₁</span><span class=\"w\"> </span><span class=\"n\">sep</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">sep₁'</span><span class=\"w\"> </span><span class=\"n\">sep'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">s'</span>\n\n<span class=\"w\">  </span><span class=\"bp\">«</span><span class=\"k\">match</span><span class=\"bp\">»</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">aux</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Char</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Char</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Char</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">sep₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Char</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sep</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Char</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Char</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">sep₁</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">sep</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">sep'</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">aux</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">sep'</span><span class=\"o\">))</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">s'</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">aux</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"w\">    </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">aux</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"n\">none</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s2\">\"this is a mildly long string so let's see what happens\"</span><span class=\"bp\">.</span><span class=\"n\">splitOn'</span><span class=\"w\"> </span><span class=\"s2\">\"o\"</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"s2\">\"this is a mildly l\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"ng string s\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\" let's see what happens\"</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 486066045,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733310314
    },
    {
        "content": "<p>Perhaps the implementation should change to this, and the current implementation could be a <code>@[csimp]</code>?</p>",
        "id": 486068282,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1733311027
    },
    {
        "content": "<p>that was my intent with the suggestion</p>",
        "id": 486069175,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733311323
    },
    {
        "content": "<p>although thinking about it now, this might be an example where we have three separate implementations, since the optimal version for equations is not this either</p>",
        "id": 486069284,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733311363
    },
    {
        "content": "<p>so the definition would be kernel-optimized, the <code>@[csimp]</code> lemma points to a compiler-optimized definition, and the <code>@[simp]</code> lemmas point to a reasoning-optimized version</p>",
        "id": 486069618,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733311482
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/channel/113488-general/topic/How.20to.20prove.20an.20equality.20that.20can.20be.20.60.23eval.60ed.3F/near/486047162\">said</a>:</p>\n<blockquote>\n<p>I am under the impression that any well-founded recursive function can easily lead reduction to go astray – or do you have a good reason why this won’t happen with <code>String.splitOn</code>?</p>\n</blockquote>\n<p>Your example compiles for me in Lean 1.14.0, no error message about maximum recursion depth.</p>",
        "id": 486071279,
        "sender_full_name": "Tobias Bucher",
        "timestamp": 1733312029
    },
    {
        "content": "<p>Did you include the <code>guard_msgs</code> command when testing? Then no error message means that that error message was produce :-)</p>\n<p>In any case, I produced this on <a href=\"http://live.lean-lang.org\">live.lean-lang.org</a>, version Lean 4.15.0-rc1</p>",
        "id": 486071551,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1733312129
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/113488-general/topic/How.20to.20prove.20an.20equality.20that.20can.20be.20.60.23eval.60ed.3F/near/486069618\">said</a>:</p>\n<blockquote>\n<p>so the definition would be kernel-optimized, the <code>@[csimp]</code> lemma points to a compiler-optimized definition, and the <code>@[simp]</code> lemmas point to a reasoning-optimized version</p>\n</blockquote>\n<p>If I understand correctly, we don't currently have a reasoning-optimized version, is that right?</p>\n<p>If so, I suggest we do this in stages:</p>\n<ol>\n<li>If someone could write the <code>@[csimp]</code> lemma, we can install Mario's <code>splitOn</code> as a the \"official\" <code>splitOn</code>, with a <code>@[csimp]</code> lemma replacing it with the current version.</li>\n<li>I will happily review / merge that.</li>\n<li>Separately/later, we come up with a reasoning-optimized version and add that (either in Lean or Batteries, I'm happy either way).</li>\n</ol>",
        "id": 486205546,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1733360275
    },
    {
        "content": "<blockquote>\n<p>If I understand correctly, we don't currently have a reasoning-optimized version, is that right?</p>\n</blockquote>\n<p>The reasoning optimized version is basically \"have lemmas that say splitOn does something sensible\". There is a fair bit of work on this in <a href=\"https://github.com/leanprover-community/batteries/pull/743\">batteries#743</a> .</p>",
        "id": 486259090,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733390715
    }
]