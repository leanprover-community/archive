[
    {
        "content": "<p>Is it possible to define boolean operators such that commutativity is definitional? Concretely, I'm looking for something which could be used for <code>Or'</code> here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Or'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Or'_eq_Or</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Or'</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Or</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">guard_expr</span><span class=\"w\"> </span><span class=\"n\">Or'</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"bp\">=~</span><span class=\"w\"> </span><span class=\"n\">Or'</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">p</span>\n</code></pre></div>",
        "id": 499891664,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1739605046
    },
    {
        "content": "<p>Why?</p>\n<p>A few years ago when we were trying to figure out how to do homological algebra in lean a related question came up: could we redefine addition on the naturals and integers such that associativity was rfl? I think the conclusion was that even if it were possible (and I don't think anyone ever managed to do it) the question was moot anyway because core would not be accepting such a PR.</p>",
        "id": 499893895,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1739607266
    },
    {
        "content": "<p>Now Iâ€™m genuinely curious as to how that came up while doing homological algebra</p>",
        "id": 499897044,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1739610108
    },
    {
        "content": "<p>You can try to write down the definition of a chain complex and see for yourself where it goes wrong :) There have been many threads on Zulip about this over the years. The first I could find is <a class=\"message-link\" href=\"/#narrow/channel/113488-general/topic/morphisms.20between.20objects.20that.20are.20.22equal.22/near/205089684\">#general &gt; morphisms between objects that are \"equal\" @ ðŸ’¬</a> . Mathlib has a rather elegant solution for this; see the module doc for <a href=\"https://tqft.net/mathlib4files/Algebra/Homology/ComplexShape\">file#Algebra/Homology/ComplexShape</a>.</p>",
        "id": 499898208,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1739611200
    },
    {
        "content": "<p>This is super informal, so take it with a grain of salt, but if such an <code>Or'</code> could exist, wouldn't that mean that both <code>Or' p q</code> and <code>Or' q p</code> reduce to the same expression <code>E[p,q]</code> depending on <code>p</code> and <code>q</code>? This would mean that <code>E[p,q]</code> and <code>E[q,p]</code> are definitionally the same, but since they are both irreducible, if they are syntactically different this would mean that <code>Or' p q</code> has essentially two normal forms. So either <code>E[p,q]</code> is syntactically symmetric with respect to <code>p</code> and <code>q</code>, or <code>Or' p q</code> has two normal forms. Either of these options seems really strange to me, so I'd be surprised if you could find a way to make this work.</p>",
        "id": 499898387,
        "sender_full_name": "Niels Voss",
        "timestamp": 1739611329
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/Definitional.20commutativity/near/499893895\">said</a>:</p>\n<blockquote>\n<p>Why?</p>\n<p>A few years ago when we were trying to figure out how to do homological algebra in lean a related question came up: could we redefine addition on the naturals and integers such that associativity was rfl? I think the conclusion was that even if it were possible (and I don't think anyone ever managed to do it) the question was moot anyway because core would not be accepting such a PR.</p>\n</blockquote>\n<p>I'm just curious, not for any real usage</p>",
        "id": 499898841,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1739611775
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466290\">Luigi Massacci</span> <a href=\"#narrow/channel/113488-general/topic/Definitional.20commutativity/near/499897044\">said</a>:</p>\n<blockquote>\n<p>Now Iâ€™m genuinely curious as to how that came up while doing homological algebra</p>\n</blockquote>\n<p>Long story short: if you define a complex of groups (that mathematically is just a group <code>G_i</code> for every integer <code>i</code> and maps <code>d_i : G_i â†’ G_(i+1)</code> such that the composition of two consecutive maps is zero) just as a function <code>â„¤ â†’ GroupCat</code> with the maps then Lean complains that the composition <code>d_(i-1)</code> with <code>d_i</code> is meaningless, because it doesn't realize that <code>G_(i-1+1)</code> and <code>G_i</code> are the same.</p>",
        "id": 499902675,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1739615429
    },
    {
        "content": "<p>the same happens with various operations on <code>â„¤</code>, and definitional equality would help.</p>",
        "id": 499902735,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1739615492
    },
    {
        "content": "<p>Commutativity is impossible unless the type theory directly supports it (for example universe levels are definitionally commutative, but obviously that can't be leveraged here). Associativity can be done via the D-List technique. We define <code>AssocNat</code> as a function <code>Nat -&gt; Nat</code> that commutes with successor. Then addition is just composition which is definitionally associative (there is that extra component, but Prop-valued types are definitional subsingletons so it doesn't matter). This should be generalizable to make definitionally associative categories via representable functors, but I haven't thought about it.</p>",
        "id": 499907313,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1739619759
    },
    {
        "content": "<p>I think the OG thread where associativity was first mentioned was <a href=\"#narrow/channel/116395-maths/topic/CDGAs/near/167848869\">this one</a>. If you have a graded algebra graded by pieces <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">A(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> and multiplications <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo><mo>Ã—</mo><mi>A</mi><mo stretchy=\"false\">(</mo><mi>j</mi><mo stretchy=\"false\">)</mo><mo>â†’</mo><mi>A</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo>+</mo><mi>j</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">A(i)\\times A(j)\\to A(i+j)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">Ã—</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">â†’</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span></span></span></span> then stating associativity in the naive way results in a type mismatch as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">(</mo><mi>i</mi><mo>+</mo><mi>j</mi><mo stretchy=\"false\">)</mo><mo>+</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">A((i+j)+k)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">((</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo>+</mo><mo stretchy=\"false\">(</mo><mi>j</mi><mo>+</mo><mi>k</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">A(i+(j+k))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">))</span></span></span></span> aren't defeq.</p>",
        "id": 500020162,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1739720628
    }
]