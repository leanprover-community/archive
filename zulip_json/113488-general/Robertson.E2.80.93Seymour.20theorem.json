[
    {
        "content": "<p>Would people be interested in formalizing the Robertson–Seymour theorem as a community project?</p>",
        "id": 464799811,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1724481616
    },
    {
        "content": "<p>I would love to see it done but I probably won't have time myself!</p>",
        "id": 464801048,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1724482187
    },
    {
        "content": "<p>Iirc, something like ~half of the work is proving the Graph Structure Theorem first. That would be a satisfying milestone to hit</p>",
        "id": 464809938,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1724487909
    },
    {
        "content": "<p>Count me in!</p>",
        "id": 464848655,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1724507155
    },
    {
        "content": "<p>Are there expositions of the proof other then the original papers of Robertson and Seymour?</p>",
        "id": 464855977,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1724510228
    },
    {
        "content": "<p>There is a chapter in Diestel with the whole purpose of proving it, but I admit I haven't read it yet.</p>",
        "id": 464856108,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1724510330
    },
    {
        "content": "<p>Chapter 12: Minors, Trees, and WQO from Diestel's Graph Theory</p>",
        "id": 464856245,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1724510430
    },
    {
        "content": "<p>Yes, I saw it, and there's a lot of graph minor theory there which would surely be helpful, but there's only a rough sketch of the proof of the theorem itself there</p>",
        "id": 464856438,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1724510600
    },
    {
        "content": "<p>I'll join where I can!</p>",
        "id": 465362370,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1724745746
    },
    {
        "content": "<p>I think there is a lot of infrastructure that is still needed before even stating the structure theorem is possible. </p>\n<p>A good (but tiny) first step would be to figure out how to formalize the notion of a multigraph in such a way that Kuratowski's theorem can be reasonably stated.</p>",
        "id": 465480913,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1724771709
    },
    {
        "content": "<p>For a sense of what <em>stating</em> the actual GM structure theorem would involve, see Theorem 2 of <a href=\"https://www.sciencedirect.com/science/article/pii/S0095895612000482\">this paper</a>, which is a simplification of the original Robertson-Seymour version. It relies on a technical notion of 'richness' of a graph embedding, which is a seven-part definition with complicated parts. </p>\n<p>I don't think this is an FLT-sized project, but it is orders of magnitude larger than anything attempted in formalization in combinatorics in lean, and is much bigger than the four-colour theorem. It will need a lot of input from experts.</p>",
        "id": 465482644,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1724772211
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329425\">Peter Nelson</span> <a href=\"#narrow/stream/113488-general/topic/Robertson.E2.80.93Seymour.20theorem/near/465480913\">said</a>:</p>\n<blockquote>\n<p>I think there is a lot of infrastructure that is still needed before even stating the structure theorem is possible. </p>\n<p>A good (but tiny) first step would be to figure out how to formalize the notion of a multigraph in such a way that Kuratowski's theorem can be reasonably stated.</p>\n</blockquote>\n<p>I'm currently working on defining planar graphs using combinatorial maps. <a href=\"https://github.com/leanprover-community/mathlib4/pull/16074\">#16074</a> introduces these maps (it is still a WIP), but we don't have orientable manifolds in mathlib yet, I will define those in order to define a graph embedding into an orientable surface then show that such an embedding is equivalent to a combinatorial map. The details of implementation are still not very clear to me but that's the general idea. I wonder if this would cover multigraphs too.</p>",
        "id": 465484141,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1724772609
    },
    {
        "content": "<p>That sounds great!</p>\n<p>I think that  defining graph embeddings without the generality of multigraphs would be a mistake. I still don't know how to define multigraphs in a way that plays nice with edge contraction, though...</p>",
        "id": 465485563,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1724773047
    },
    {
        "content": "<p>In a multigraph edge contraction, do we do contract all parallel edges at once, or are we allowed to remove only 1 edge while the others turn into loops?<br>\nAnother question, is the edge contraction allowed to turn a <code>SimpleGraph</code> into a multigraph?</p>",
        "id": 465491667,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1724774387
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"580947\">@Rida Hamadani</span> what I really want to do is generalise combinatorial maps and hypermaps to the band decompositions described in <a href=\"https://jeffe.cs.illinois.edu/teaching/comptop/2020/notes/19-surface-maps.pdf\">https://jeffe.cs.illinois.edu/teaching/comptop/2020/notes/19-surface-maps.pdf</a> (Wikipedia calls them generalised maps)</p>",
        "id": 465492889,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1724774588
    },
    {
        "content": "<p>Band decompositions also allow representing non-orientable surfaces, which form half of the Ringel–Youngs theorem</p>",
        "id": 465493461,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1724774679
    },
    {
        "content": "<p>This is very nice, I'll look more into it.</p>",
        "id": 465494002,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1724774786
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"580947\">Rida Hamadani</span> <a href=\"#narrow/stream/113488-general/topic/Robertson.E2.80.93Seymour.20theorem/near/465491667\">said</a>:</p>\n<blockquote>\n<p>In a multigraph edge contraction, do we do contract all parallel edges at once, or are we allowed to remove only 1 edge while the others turn into loops?<br>\nAnother question, is the edge contraction allowed to turn a <code>SimpleGraph</code> into a multigraph?</p>\n</blockquote>\n<p>In a multigraph, contracting one edge should turn the parallel edges into loops. </p>\n<p>In a <code>SimpleGraph</code>, contracting an edge <code>e</code> should identify pairs of edges <code>x,y</code> for which <code>exy</code> is a triangle, to give another simple graph. But if <code>G : SimpleGraph a</code> is coerced to a multigraph, then <code>x,y</code> should become parallel in the contraction.</p>",
        "id": 465503212,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1724777027
    },
    {
        "content": "<p>The 'should' in my statements above is a value judgment. What I really mean is that this is the way to make edge contraction and deletion be dual operations with respect to planar/surface duality.</p>",
        "id": 465503783,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1724777144
    },
    {
        "content": "<p>You seem to be saying that even though we think of simple graphs as a \"special case\" of multigraphs, really they are distinct structures, and there are (distinct) contraction functions from simple graphs to multigraphs and from simple graphs to simple graphs.</p>",
        "id": 465569716,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1724793834
    },
    {
        "content": "<p>How are we going to save the data in a <code>SimpleGraph</code> that <code>x,y</code> are parallel if the graph gets coerced into a multigraph?</p>",
        "id": 465571912,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1724794520
    },
    {
        "content": "<p>In my opinion, we can make the contraction function return a multigraph even when its input is a <code>SimpleGraph</code>, and then we can coerce this multigraph into a <code>SimpleGraph</code> if we want by deleting parallel edges.</p>",
        "id": 465572116,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1724794609
    },
    {
        "content": "<p>I think the point is that in simple graph contraction, you don't, parallel edges are lost after a contraction. Instead, you have two different contraction functions, where the multigraph one doesn't flatten parallel edges, and the simple graph contraction is related to the multigraph contraction via <code>SimpleGraph -embed-&gt; MultiGraph -contract-&gt; MultiGraph -quotient-&gt; SimpleGraph</code></p>",
        "id": 465575871,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1724795552
    },
    {
        "content": "<p>At one point I tried to survey some literature to how these words (\"contraction\", \"dissolution\", \"vertex identification\", etc.) are used in the settings of simple graph / digraphs / multigraphs ... Basically I found that there is a combinatorial explosion of what these mean. :) For instance, how to handle self-loops? If I contract an edge x-y, do I end up with a loop on the resulting vertex? For some contexts it's crucial that you do.</p>\n<p>This was my partial progress: <a href=\"https://ohaithe.re/graph_substructure#modifications\">https://ohaithe.re/graph_substructure#modifications</a></p>",
        "id": 465578710,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1724796937
    },
    {
        "content": "<p>The only thing that seemed really consistent across all contexts was \"edge deletion\". That's removing an edge, no two bones about it.</p>",
        "id": 465578808,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1724796987
    },
    {
        "content": "<p>In the context of the RS theorem obviously there is a preferred meaning, but when people talk about e.g. topological minors vs minors vs immersion minors, which are ingredients of the proof, there end up being some annoying subtleties of convention</p>",
        "id": 465578872,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1724797049
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329425\">Peter Nelson</span> <a href=\"#narrow/stream/113488-general/topic/Robertson.E2.80.93Seymour.20theorem/near/465485563\">said</a>:</p>\n<blockquote>\n<p>That sounds great!</p>\n<p>I think that  defining graph embeddings without the generality of multigraphs would be a mistake. I still don't know how to define multigraphs in a way that plays nice with edge contraction, though...</p>\n</blockquote>\n<p>One option that I played around with a little is to consider a contraction as a special case of a pushforward of graph, where the map has connected fibers. This allows the contraction of many edges at once (which will likely be necessary if we want to look at infinite graphs, and generally makes life easier). Then if one wants to contract a single edge, one has to construct a vertex type for the contraction which does not feel so nice...</p>\n<p>One way to do this with the Serre version of multigraphs:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">V'</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">SerreGraph</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">V</span>\n<span class=\"w\">  </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">E</span>\n<span class=\"w\">  </span><span class=\"n\">r_ne</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">e</span>\n<span class=\"w\">  </span><span class=\"n\">r_inv</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">e</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">SerreGraph</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SerreGraph</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">V'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SerreGraph</span><span class=\"w\"> </span><span class=\"n\">V'</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">o</span>\n<span class=\"w\">  </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">r</span>\n<span class=\"w\">  </span><span class=\"n\">r_ne</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">r_ne</span>\n<span class=\"w\">  </span><span class=\"n\">r_inv</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">r_inv</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ContractRel</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SerreGraph</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">)</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">contractRel_equiv</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Equivalence</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ContractRel</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ContractSetoid</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SerreGraph</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Setoid</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">ContractRel</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">contractRel_equiv</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ContractType</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SerreGraph</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Quotient</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ContractSetoid</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Contract</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SerreGraph</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SerreGraph</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ContractType</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">SerreGraph</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Quotient</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>(The second half is likely done somewhere already.)</p>",
        "id": 465819402,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1724866417
    },
    {
        "content": "<p>(Also, it might make sense to instead keep <code>V</code> and use <code>update id (G.o e) (G.o (G.r e))</code> as a map, it is much simpler but has the drawback of creating an isolated vertex.)</p>",
        "id": 465820202,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1724866763
    },
    {
        "content": "<p>The version with <code>SimpleGraph</code> is not so nice because of all the edge merging and having to take care of removing self-loops ...</p>",
        "id": 465820535,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1724866848
    },
    {
        "content": "<p>I like the Serre graphs. </p>\n<p>But another part of me still wants a set-theoretic notion of contraction. It is very frustrating to contract a single edge <code>e</code> to get <code>G / e</code>, and then have a vertex <code>x</code> somewhere else in the graph be a one-element set/ equivalence class in the contracted graph, rather than just a vertex. </p>\n<p>This would have some form like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Card</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Multigraph</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">β</span>\n<span class=\"w\">  </span><span class=\"n\">inc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"w\">  </span><span class=\"n\">inc_mem_edge</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">inc</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">E</span>\n<span class=\"w\">  </span><span class=\"n\">inc_mem_vx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">inc</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">V</span>\n<span class=\"w\">  </span><span class=\"n\">inc_exists</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">inc</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"w\">  </span><span class=\"n\">inc_card</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">inc</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">encard</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Multigraph</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">deleteEdges</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Multigraph</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Multigraph</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">V</span>\n<span class=\"w\">  </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"w\"> </span><span class=\"n\">F</span>\n<span class=\"w\">  </span><span class=\"n\">inc</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">∉</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">inc</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"w\">  </span><span class=\"n\">inc_mem_edge</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">inc_mem_vx</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">inc_exists</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">inc_card</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"sd\">/-- identify a set `S` of vertices to a vertex named `z`, which can be inside or outside `V`.</span>\n<span class=\"sd\">edges with both ends in `S` become loops at `z`.  Probably inadvisible to use if `z ∈ G.V \\ S` --/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">identify</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Multigraph</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Multigraph</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">insert</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">E</span>\n<span class=\"w\">  </span><span class=\"n\">inc</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">∉</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">inc</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">inc</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">inc_mem_edge</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">inc_mem_vx</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">inc_exists</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">inc_card</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"sd\">/-- contract an edge `e` to a vertex `z`. We can choose `z` as an existing end of `e`, or</span>\n<span class=\"sd\">give it a new name from a vertex outside `V`.  Probably a bad idea if neither is the case. --/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">contractEdge</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Multigraph</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Multigraph</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">identify</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">inc</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">deleteEdges</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">e</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>There are tradeoffs, but I think this might be a better way to avoid DTT hell. </p>\n<p>Doing things like contracting a single edge and comparing the state of things before and after contraction is very common in actual written graph theory proofs, and this kind of approach removes the need for quotients.</p>",
        "id": 465839162,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1724874613
    },
    {
        "content": "<p>You can always replace quotients with subtypes to remove the extra vertex:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">merge</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">update</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">?_⟩</span>\n<span class=\"w\">  </span><span class=\"n\">by_cases</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>but it's possibly even worse :-(</p>",
        "id": 465853499,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1724880849
    },
    {
        "content": "<p>Here <a href=\"https://github.com/vbeffara/lean/tree/main/src/graph_theory\">https://github.com/vbeffara/lean/tree/main/src/graph_theory</a> I implemented (in Lean 3) the proof of Menger's theorem from Diestel's book, using the <code>Function.update</code> version with all the extra single vertices, and it went kind of ok - OTOH it's an induction on the number of edges so isolated vertices don't hurt.</p>",
        "id": 465853857,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1724881013
    }
]