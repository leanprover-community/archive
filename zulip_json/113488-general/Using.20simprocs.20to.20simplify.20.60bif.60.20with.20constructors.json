[
    {
        "content": "<p>Take this inductive type:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">iN</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bits</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">bitvec</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"n\">bits</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">iN</span><span class=\"w\"> </span><span class=\"n\">bits</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">poison</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">iN</span><span class=\"w\"> </span><span class=\"n\">bits</span>\n</code></pre></div>\n<p>I have expressions of the form:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">bif</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">slt</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"bp\">#</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">bitvec</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"bp\">#</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">bitvec</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"bp\">#</span><span class=\"mi\">1</span>\n<span class=\"c1\">-- or in general:</span>\n<span class=\"n\">bif</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">bitvec</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">bitvec</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n</code></pre></div>\n<p>I would like to move the <code>bitvec</code> constructor outside, so I can eventually bubble up all constructors to the root. Like <code>bitvec bif _ then _ else _</code>. This would be pretty fragile to do with normal simp lemmas as i want it to be general on all <code>if</code>s, I'm guessing simprocs are the way to do it?</p>\n<p>This is what I have so far:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">simproc</span><span class=\"w\"> </span><span class=\"bp\">↓</span><span class=\"w\"> </span><span class=\"n\">bifBitvec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cond</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bitvec</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bitvec</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">let_expr</span><span class=\"w\"> </span><span class=\"n\">cond</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">lhs</span><span class=\"w\"> </span><span class=\"n\">rhs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">continue</span>\n<span class=\"w\">  </span><span class=\"n\">unless</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">matchesInstance</span><span class=\"w\"> </span><span class=\"n\">lhs</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mkConst</span><span class=\"w\"> </span><span class=\"ss\">``bitvec</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">continue</span>\n<span class=\"w\">  </span><span class=\"n\">unless</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">matchesInstance</span><span class=\"w\"> </span><span class=\"n\">rhs</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mkConst</span><span class=\"w\"> </span><span class=\"ss\">``bitvec</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">continue</span>\n\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">va</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getBitVecValue?</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">lhs</span><span class=\"bp\">.</span><span class=\"n\">getArg!</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">continue</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">vb</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getBitVecValue?</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rhs</span><span class=\"bp\">.</span><span class=\"n\">getArg!</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">continue</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- va : (n : Nat) × BitVec n</span>\n<span class=\"w\">  </span><span class=\"c1\">-- vb : (n : Nat) × BitVec n</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- ?</span>\n</code></pre></div>",
        "id": 539037531,
        "sender_full_name": "l1mey",
        "timestamp": 1757675339
    },
    {
        "content": "<p>are you looking for the reverse direction of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Bool.apply_cond#doc\">docs#Bool.apply_cond</a></p>",
        "id": 539037718,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757675411
    },
    {
        "content": "<p>Yes, that seems like it. However I want this to be part of a wider proof automation pipeline, I would like to apply it to bubble up constructors over many different expressions, and <code>bif</code> is not the only one.</p>",
        "id": 539038434,
        "sender_full_name": "l1mey",
        "timestamp": 1757675656
    },
    {
        "content": "<p>what are the other ones</p>",
        "id": 539038680,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757675750
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=apply_ite#doc\">docs#apply_ite</a></p>",
        "id": 539038739,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1757675768
    },
    {
        "content": "<p>You could imagine one for general <code>match</code>es too</p>",
        "id": 539038921,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1757675838
    },
    {
        "content": "<p>I think this has been discussed before</p>",
        "id": 539038936,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1757675844
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/113488-general/topic/Using.20simprocs.20to.20simplify.20.60bif.60.20with.20constructors/near/539038680\">said</a>:</p>\n<blockquote>\n<p>what are the other ones</p>\n</blockquote>\n<p>At the moment just <code>HAnd</code>, which is defined as:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">iN</span><span class=\"bp\">.</span><span class=\"n\">poisonWrapper</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">k</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">iN</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">iN</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">iN</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">iN</span><span class=\"w\"> </span><span class=\"n\">k</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">poison</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">poison</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">poison</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">poison</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">bitvec</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">bitvec</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">LangRef: https://llvm.org/docs/LangRef.html#and-instruction</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">iN</span><span class=\"bp\">.</span><span class=\"n\">and</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">iN</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">iN</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">iN</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">iN</span><span class=\"bp\">.</span><span class=\"n\">poisonWrapper</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">&amp;&amp;&amp;</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HAnd</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">iN</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">iN</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">iN</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">hAnd</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">iN</span><span class=\"bp\">.</span><span class=\"n\">and</span>\n</code></pre></div>\n<p>The bubbling up should basically work for every instruction that uses <code>iN.poisonWrapper</code> in its body. Which is why I would want it to be extensible.</p>",
        "id": 539039707,
        "sender_full_name": "l1mey",
        "timestamp": 1757676136
    },
    {
        "content": "<p>I already have some automation for decomposing <code>iN.poisonWrapper</code> which leaves me with many ifs and ands. But in general it should work for any boolean expression.</p>",
        "id": 539039887,
        "sender_full_name": "l1mey",
        "timestamp": 1757676205
    },
    {
        "content": "<p>write a lemma about <code>iN.poisonWrapper</code></p>",
        "id": 539039979,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757676239
    },
    {
        "content": "<p>I already have a collection of lemmas, but these don't try to match the arbitrary expressions unless <code>g</code> is carefully simplified in a way such that it is an actual function application:</p>\n<p><a href=\"/user_uploads/3121/O_H_mNDguJd-dIH8TwT4L2HV/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/O_H_mNDguJd-dIH8TwT4L2HV/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1236x656\" src=\"/user_uploads/thumbnail/3121/O_H_mNDguJd-dIH8TwT4L2HV/image.png/840x560.webp\"></a></div>",
        "id": 539040495,
        "sender_full_name": "l1mey",
        "timestamp": 1757676414
    },
    {
        "content": "<p>Is there a way to match expressions that don't force me to ensure that the expression is a function? For example, nested expressions inside the condition where <code>g</code> is don't simplify at all.</p>",
        "id": 539040963,
        "sender_full_name": "l1mey",
        "timestamp": 1757676574
    }
]