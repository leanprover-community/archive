[
    {
        "content": "<p>Hey everyone, making my first post on the Lean Zulip!</p>\n<p>I've identified an undesirable feature of simp when applied to GetElem expressions like <code>list[i]</code> (on Lists, Arrays, Vectors, ...): It often happens that the list is completely unfolded <em>before</em> resolving the element access, leading to expressions like <code>[0, 1, 2, 3][i]</code> which are very annoying to reason about when <code>i</code> is not explicitly known. This happens even if a useful <code>getElem_</code> lemma is in theory available (it's just not applied at the right moment).</p>\n<p>My question, in brief, is whether it's possible to engineer a simp set that will always prioritize an applicable <code>getElem_</code> lemma, while keeping the power to fully resolve the list.</p>\n<p>Full toy example demonstrating the problem and a partial solution:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">ofFn</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">^</span><span class=\"mi\">2</span>\n\n<span class=\"c1\">-- BAD: simplifies list before applying getElem lemmas</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">l</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"c1\">-- ⊢ [0, 1, 4, 9, 16][↑i] = ↑i ^ 2</span>\n\n<span class=\"c1\">-- GOOD: simp path that we actually want</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">l</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">getElem_ofFn</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"c1\">-- no goals</span>\n\n<span class=\"c1\">-- explicit version of bad simplification to understand what happens:</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">l</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">ofFn_succ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">ofFn_zero</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- expands list</span>\n<span class=\"w\">  </span><span class=\"c1\">-- ⊢ [↑0 ^ 2, ↑(Fin.succ 0) ^ 2, ↑(Fin.succ 0).succ ^ 2, ↑(Fin.succ 0).succ.succ ^ 2, ↑(Fin.succ 0).succ.succ.succ ^ 2][↑i] = ↑i ^ 2</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">val_zero</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">val_succ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">reduceAdd</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">reducePow</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- fully evaluates elements</span>\n<span class=\"w\">  </span><span class=\"c1\">-- ⊢ [0, 1, 4, 9, 16][↑i] = ↑i ^ 2</span>\n\n<span class=\"c1\">-- we want to try `List.getElem_ofFn` before \"simplifying\" the list</span>\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"bp\">↓</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">getElem_ofFn</span>\n\n<span class=\"c1\">-- GOOD: full simp set available, and prioritizes getElem lemma</span>\n<span class=\"c1\">-- BUT only works when unfolding `l` first :/</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">l</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"c1\">-- no goals</span>\n\n<span class=\"c1\">-- STILL BAD: doesn't work with a single simp call</span>\n<span class=\"c1\">-- because `List.getElem_ofFn` can't be applied right away?</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">l</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"c1\">-- ⊢ [0, 1, 4, 9, 16][↑i] = ↑i ^ 2</span>\n</code></pre></div>\n<p><strong>Question</strong>: Is there any way to change the simp set such that the final <code>example</code> succeeds?</p>\n<p>More context:</p>\n<ul>\n<li>I'm developing a Lean library with a custom simp set, which plays a central role in the library's usability (this is some of the current simp set: <a href=\"https://github.com/Verified-zkEVM/clean/blob/98b891970f2b33664cd3612b9f2bc3c278c7c7f0/Clean/Circuit/Basic.lean#L599-L636\">https://github.com/Verified-zkEVM/clean/blob/98b891970f2b33664cd3612b9f2bc3c278c7c7f0/Clean/Circuit/Basic.lean#L599-L636</a>)</li>\n<li>The question is not about <code>ofFn</code> or <code>List</code> in particular, but about the general phenomenon of unfolding iterables before resolving the element access</li>\n<li>I'm looking for solutions that don't require the user to manually construct a smaller set of lemmas and pass that to <code>simp</code></li>\n</ul>",
        "id": 517759673,
        "sender_full_name": "Gregor",
        "timestamp": 1747122519
    },
    {
        "content": "<p>For this particular case you could instruct <code>List.getElem_ofFn</code> to be applied before its subexpressions are simplified by adding it the <code>↓</code> option to the <code>simp</code> attribute.</p>\n<p>If I add the following to the top of your file, the first example works.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"bp\">↓</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">getElem_ofFn</span>\n</code></pre></div>\n<p>EDIT: It doesn't work for your last case though</p>",
        "id": 517775074,
        "sender_full_name": "Ayhon",
        "timestamp": 1747126975
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"690100\">@Ayhon</span>, that's indeed the partial solution already shown in my example</p>",
        "id": 517777875,
        "sender_full_name": "Gregor",
        "timestamp": 1747127818
    },
    {
        "content": "<p>Oh my god, I completely missed that <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 517777954,
        "sender_full_name": "Ayhon",
        "timestamp": 1747127849
    },
    {
        "content": "<p>If you don't want <code>ofFn</code> to be simplified by itself, I don't think there's a good way around disabling those specific simp theorems.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"n\">simp</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">ofFn_succ</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">ofFn_zero</span>\n</code></pre></div>",
        "id": 517799191,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1747134400
    },
    {
        "content": "<p>That was my worry <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> Thanks <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span></p>",
        "id": 517799514,
        "sender_full_name": "Gregor",
        "timestamp": 1747134503
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"757093\">Gregor</span> has marked this topic as resolved.</p>",
        "id": 517799604,
        "sender_full_name": "Notification Bot",
        "timestamp": 1747134532
    },
    {
        "content": "<p>I thought this would be achievable with <code>simp</code> priorities, doing something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"bp\">↓</span><span class=\"w\"> </span><span class=\"mi\">1000</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">getElem_ofFn</span>\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">ofFn_succ</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">ofFn_zero</span>\n</code></pre></div>\n<p>However it seems to have no effect. There's also not much information on what prio does with <code>simp</code> in the <a href=\"https://lean-lang.org/doc/reference/latest///The-Simplifier/Simp-sets/#Lean___Parser___Attr___simp\">Lean  reference</a>. Why doesn't this work?</p>",
        "id": 517810747,
        "sender_full_name": "Ayhon",
        "timestamp": 1747137642
    }
]