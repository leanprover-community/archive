[
    {
        "content": "<p>Dear All,</p>\n<p>I have been playing around a bit with the idea of auto-generating more lemmas in the style of <code>to_additive</code>.  I have a very simple-minded implementation of a command that tries to autogenerate the <em>statement</em> of a lemma that is the \"<code>to_opposite</code>\" of a give one.  (Note: it currently makes no attempt at <em>proving</em> the \"opposite\" statement, it just states it -- proofs would be a follow up!)</p>\n<p>Here is a quick demo on <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=mul_le_mul_left#doc\">docs#mul_le_mul_left</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- the actual lemma in the library</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">mul_le_mul_left</span> <span class=\"o\">[</span><span class=\"n\">PosMulMono</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">PosMulMonoRev</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a0</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">↔</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"c1\">-- and the following one</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">mul_le_mul_right</span> <span class=\"o\">[</span><span class=\"n\">MulPosMono</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MulPosMonoRev</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a0</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">↔</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>With the command that I have been trying out, this is what you can do:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- you state your lemma</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">mul_le_mul_left</span> <span class=\"o\">[</span><span class=\"n\">PosMulMono</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">PosMulMonoRev</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a0</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">↔</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"c1\">-- and maybe you prove it</span>\n<span class=\"c1\">-- then</span>\n<span class=\"n\">rev</span> <span class=\"n\">mul_le_mul_left</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">*</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"n\">α</span>  <span class=\"c1\">-- this autogenerates</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">@[reverse mul_le_mul_left]</span>\n<span class=\"cm\">lemma mul_le_mul_right : ∀ {α : Type u_1} {a b c : α} [inst : Mul α] [inst_1 : Zero α] [inst_2 : Preorder α]</span>\n<span class=\"cm\">  [inst_3 : MulPosMono α] [inst_4 : MulPosMonoRev α], 0 &lt; a → (b * a ≤ c * a ↔ b ≤ c) := by</span>\n<span class=\"cm\">  sorry</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>The syntax of <code>rev</code> is as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">rev</span> <span class=\"n\">name</span> <span class=\"n\">operation</span> <span class=\"n\">type</span>\n</code></pre></div>\n<p>where</p>\n<ul>\n<li><code>name</code> is the name of the declaration;</li>\n<li><code>operation</code> is the (binary) operation that you want to reverse;</li>\n<li><code>type</code> is the Type on which the reversal should occur (i.e. <code>rev</code> looks for <code>(operation : type → type → type)</code> in the statement of <code>name</code>).</li>\n</ul>\n<p>The idea is that the autogenerated lemma may in the future be proved automatically, but right now the attribute <code>@[reverse decl]</code> is supposed to maintain them in synch.</p>",
        "id": 390386808,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1694465769
    },
    {
        "content": "<p>I know that this came up several times and that there are plenty of possible further developments, but I thought that maybe starting with something small, that simply suggests the \"new\" lemma statement might be a useful stepping stone for further improvement.</p>",
        "id": 390386938,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1694465854
    },
    {
        "content": "<p>If there is interest in this, I can polish what I have a little and start a PR.</p>",
        "id": 390386966,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1694465873
    }
]