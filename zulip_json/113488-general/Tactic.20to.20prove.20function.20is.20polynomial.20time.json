[
    {
        "content": "<p>Hey everyone,</p>\n<p>I've been working on a small project recently to formalize polynomial time complexity. You can check it out here: <a href=\"https://github.com/prakol16/lean_complexity_theory_polytime_trees\">https://github.com/prakol16/lean_complexity_theory_polytime_trees</a>.</p>\n<p>I have a tactic <code>polyfun</code> which tries to automatically prove that functions run in polynomial time. The core idea of the tactic is to split a goal of the form</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">⊢</span> <span class=\"n\">polytime_fun</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g₁</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g₂</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">...</span> <span class=\"o\">(</span><span class=\"n\">gₙ</span> <span class=\"n\">x</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>into</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">⊢</span> <span class=\"n\">polytime_funₙ</span> <span class=\"n\">f</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">polytime_fun</span> <span class=\"n\">g₁</span>\n<span class=\"bp\">...</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">polytime_fun</span> <span class=\"n\">gₙ</span>\n</code></pre></div>\n<p>Note that <code>polytime_funₙ f</code> is by definition <code>polytime_fun (λ (x : α₁ × ⋯ × αₙ), f x.1 x.2 ... x.n)</code>.</p>\n<p>I'm still new to tactic writing so I need some help.</p>\n<p>One issue with this is that it doesn't generalize well based on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>. Currently, I just handle <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n=1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">n=2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span>, and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">n=3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span> each with their own lemma (although this is all I've needed so far, and it isn't terribly hard to add a few more lemmas for larger <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>). I'm not sure if there is a better way though.</p>\n<p>Another issue is determining how many parameters there are. In particular we need to ignore arguments that just supply e.g. the type, or instances. The way I do this currently is search for a <code>pencodable</code> instance on each argument. For example, if the goal was</p>\n<p><code>⊢ polytime_fun (λ (m n : list α), m ++ n)</code></p>\n<p>then it should split this into goals saying that <code>list.append</code> is a <code>polytime_fun₂</code> and projections are. However, there is an implicit argument to <code>list.append</code> (namely, <code>α</code>) which should be ignored. In this case, it is ignored because <code>Type u</code> (the type of <code>α</code>) does not have a <code>polycodable</code> instance.</p>\n<p>However, I'm worried about performance here -- is there a better way to infer which arguments are \"true\" arguments and which are likely just auxiliary information without doing a full instance search?</p>",
        "id": 292300361,
        "sender_full_name": "Praneeth Kolichala",
        "timestamp": 1659850747
    },
    {
        "content": "<p>You could try using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/arity\">docs#arity</a> to generalize this to however many variables, but do note that this has very little use throughout mathlib</p>",
        "id": 292354444,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1659925263
    },
    {
        "content": "<p>What's the type of <code>f</code> here?</p>",
        "id": 292381279,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1659952604
    },
    {
        "content": "<p>Would an approach based on typeclass inference work here? This is a rough outline of what I had in mind:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\"> A typeclass for polynomial-time functions.</span>\n<span class=\"cm\">   To make the typeclass inference work smoothly, the class `polytime` is defined for terms of arbitrary types rather than only for simple function types. -/</span>\n<span class=\"kd\">class</span> <span class=\"n\">polytime</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"c1\">-- the definition of a polynomial time function goes here</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> The value of a polynomial-time function at any input is still a polynomial time function -/</span>\n<span class=\"kd\">instance</span> <span class=\"n\">polytime_eval</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">polytime</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">polytime</span> <span class=\"n\">a</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">polytime</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> The composition of polynomial-time function is polynomial-time -/</span>\n<span class=\"kd\">instance</span> <span class=\"n\">polytime_comp</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">polytime</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">polytime</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">polytime</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> The application of a polynomial-time function to a polynomial-time argument is polynomial-time -/</span>\n<span class=\"kd\">instance</span> <span class=\"n\">polytime_app</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">polytime</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">polytime</span> <span class=\"n\">b</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">polytime</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>And here are some specific examples of inference in action:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">nat.sq</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">n</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"c1\">-- squares a natural number</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> The identity function is polynomial-time -/</span>\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">polytime</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">id</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> The function `nat.sq` is polynomial-time -/</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">polytime</span> <span class=\"o\">(</span><span class=\"n\">nat.sq</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> Addition of natural numbers is polynomial-time -/</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">polytime</span> <span class=\"n\">nat.add</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> Every natural number is polynomial time (one way to make sense of this is that every constant is a 0-ary function that can be evaluated in a fixed amount of time) -/</span>\n<span class=\"kd\">instance</span> <span class=\"n\">nat_polytime</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">polytime</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- here the `α` in `id α` is ignored and only the relevant parameters are considered</span>\n<span class=\"kd\">instance</span> <span class=\"n\">eg_infer</span> <span class=\"o\">:</span> <span class=\"n\">polytime</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">nat.sq</span> <span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">infer_instance</span>\n\n<span class=\"c1\">-- a bit more work is required here, but this complicated is still derivable from typeclass inference</span>\n<span class=\"kd\">instance</span> <span class=\"n\">eg_multi_arg</span> <span class=\"o\">:</span> <span class=\"n\">polytime</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">nat.add</span> <span class=\"o\">(</span><span class=\"n\">nat.sq</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"mi\">5</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n  <span class=\"k\">show</span> <span class=\"n\">polytime</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">((</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">nat.add</span> <span class=\"o\">(</span><span class=\"n\">nat.sq</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"mi\">5</span><span class=\"o\">),</span>\n  <span class=\"n\">apply_instance</span><span class=\"o\">,</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>This is by no means a complete solution, but I think it addresses some parts of the question (such as ignoring implicit arguments). There may also be a better way to do this that avoids the <code>show</code> in the last example, but I am not aware of one. I suspect that the three typeclass instances above will be enough to handle a wide variety of cases thanks to currying.</p>",
        "id": 292626404,
        "sender_full_name": "Anand Rao",
        "timestamp": 1660067292
    },
    {
        "content": "<p>I'm pretty sure typeclass search won't work for <code>comp</code>, as we had trouble with it on is_monoid_hom due to it performing higher order unification</p>",
        "id": 292642347,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1660073018
    },
    {
        "content": "<p>OK I tried to make a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> of what I currently have, but it mostly involved copying and pasting the code I already have for the tactic, and it is quite long.</p>\n<p>Someone who knows more than me about the instance search could explain whether what I have really is bad performance-wise. I think I'm currently redoing the instance search every time I apply <code>polytime_fun.comp</code>, but honestly, I just fiddled with the tactics until it seemed to work, so I'm not quite sure what exactly the code is doing in terms of the fine details.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic.core</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic.tidy</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic.show_term</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ptree</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">pencodable</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">encode</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ptree</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">decode</span> <span class=\"o\">:</span> <span class=\"n\">ptree</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"c\">/-</span><span class=\"cm\"> (other prop's omitted) -/</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"n\">δ</span> <span class=\"n\">ε</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">pencodable</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">pencodable</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">pencodable</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">pencodable</span> <span class=\"n\">δ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">pencodable</span> <span class=\"n\">ε</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">pencodable</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">polytime_fun</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">polytime_fun.id</span> <span class=\"o\">:</span> <span class=\"n\">polytime_fun</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">id</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">polytime_fun.const</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">polytime_fun</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">polytime_fun.comp</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">polytime_fun</span> <span class=\"n\">f</span> <span class=\"bp\">→</span> <span class=\"n\">polytime_fun</span> <span class=\"n\">g</span> <span class=\"bp\">→</span> <span class=\"n\">polytime_fun</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">polytime_fun.pair</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">polytime_fun</span> <span class=\"n\">f</span> <span class=\"bp\">→</span> <span class=\"n\">polytime_fun</span> <span class=\"n\">g</span> <span class=\"bp\">→</span> <span class=\"n\">polytime_fun</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">polytime_fun.fst</span> <span class=\"o\">:</span> <span class=\"n\">polytime_fun</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">prod.fst</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">polytime_fun.snd</span> <span class=\"o\">:</span> <span class=\"n\">polytime_fun</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">prod.snd</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">polytime_fun₂</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">polytime_fun</span> <span class=\"o\">(</span><span class=\"n\">function.uncurry</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">polytime_fun₃</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"n\">polytime_fun</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span> <span class=\"bp\">×</span> <span class=\"n\">γ</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x.1</span> <span class=\"n\">x.2.1</span> <span class=\"n\">x.2.2</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">polytime_fun.comp₂</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">δ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">δ</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">polytime_fun₂</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hg</span> <span class=\"o\">:</span> <span class=\"n\">polytime_fun</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hh</span> <span class=\"o\">:</span> <span class=\"n\">polytime_fun</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">polytime_fun</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"n\">polytime_fun.comp</span> <span class=\"n\">hf</span> <span class=\"o\">(</span><span class=\"n\">polytime_fun.pair</span> <span class=\"n\">hg</span> <span class=\"n\">hh</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">polytime_fun.comp₃</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">g₁</span> <span class=\"o\">:</span> <span class=\"n\">ε</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">g₂</span> <span class=\"o\">:</span> <span class=\"n\">ε</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">g₃</span> <span class=\"o\">:</span> <span class=\"n\">ε</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">γ</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">polytime_fun₃</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hg₁</span> <span class=\"o\">:</span> <span class=\"n\">polytime_fun</span> <span class=\"n\">g₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hg₂</span> <span class=\"o\">:</span> <span class=\"n\">polytime_fun</span> <span class=\"n\">g₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hg₃</span> <span class=\"o\">:</span> <span class=\"n\">polytime_fun</span> <span class=\"n\">g₃</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">polytime_fun</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g₁</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g₂</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g₃</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"n\">polytime_fun.comp</span> <span class=\"n\">hf</span> <span class=\"o\">(</span><span class=\"n\">polytime_fun.pair</span> <span class=\"n\">hg₁</span> <span class=\"o\">(</span><span class=\"n\">polytime_fun.pair</span> <span class=\"n\">hg₂</span> <span class=\"n\">hg₃</span><span class=\"o\">))</span>\n\n<span class=\"kd\">end</span>\n\n<span class=\"kn\">section</span>\n\n<span class=\"kd\">@[user_attribute]</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">polyfun</span> <span class=\"o\">:</span> <span class=\"n\">user_attribute</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"n\">polyfun</span><span class=\"o\">,</span>\n  <span class=\"n\">descr</span> <span class=\"o\">:=</span> <span class=\"s2\">\"lemmas usable to prove polynomial time\"</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">polyfun</span><span class=\"o\">]</span>\n  <span class=\"n\">polytime_fun.id</span>\n  <span class=\"n\">polytime_fun.const</span>\n  <span class=\"n\">polytime_fun.pair</span>\n  <span class=\"n\">polytime_fun.fst</span>\n  <span class=\"n\">polytime_fun.snd</span>\n\n<span class=\"kd\">@[polyfun]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">polytime_fun.id'</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">pencodable</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">polytime_fun</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">polytime_fun.id</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">polytime_fun_lemmas</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">name</span> <span class=\"o\">:=</span>\n<span class=\"o\">[</span><span class=\"bp\">``</span><span class=\"n\">polytime_fun</span><span class=\"o\">,</span> <span class=\"bp\">``</span><span class=\"n\">polytime_fun₂</span><span class=\"o\">,</span> <span class=\"bp\">``</span><span class=\"n\">polytime_fun₃</span><span class=\"o\">]</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">polytime_fun_comp_lemmas</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">name</span> <span class=\"o\">:=</span>\n<span class=\"o\">[</span><span class=\"bp\">``</span><span class=\"n\">polytime_fun.comp</span><span class=\"o\">,</span> <span class=\"bp\">``</span><span class=\"n\">polytime_fun.comp₂</span><span class=\"o\">,</span> <span class=\"bp\">``</span><span class=\"n\">polytime_fun.comp₃</span><span class=\"o\">]</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">unfold_polytime</span> <span class=\"o\">(</span><span class=\"n\">md</span> <span class=\"o\">:</span> <span class=\"n\">transparency</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"k\">do</span> <span class=\"n\">dunfold_target</span> <span class=\"o\">(</span><span class=\"bp\">``</span><span class=\"n\">function.uncurry</span> <span class=\"o\">::</span> <span class=\"n\">polytime_fun_lemmas.tail</span><span class=\"o\">),</span>\n   <span class=\"n\">try</span> <span class=\"n\">dsimp_target</span>\n\n<span class=\"c1\">-- In order to help resolve polytime_fun of propositions (which are converted to bool's)</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">simp_to_bool</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">bool.to_bool_not</span><span class=\"o\">,</span> <span class=\"n\">bool.to_bool_and</span><span class=\"o\">,</span> <span class=\"n\">bool.to_bool_or</span><span class=\"o\">,</span> <span class=\"n\">bool.to_bool_coe</span><span class=\"o\">]]</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\"> Tries to infer if the given expression is a real argument by testing</span>\n<span class=\"sd\"> if it has a `pencodable` instance on it. TODO: make faster. Does this need</span>\n<span class=\"sd\"> to do a full instance search?</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">is_polycodable</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">bool</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"k\">do</span>\n   <span class=\"n\">e'</span> <span class=\"bp\">←</span> <span class=\"n\">infer_type</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n   <span class=\"n\">cache</span> <span class=\"bp\">←</span> <span class=\"n\">mk_instance_cache</span> <span class=\"n\">e'</span><span class=\"o\">,</span>\n   <span class=\"o\">(</span><span class=\"n\">cache'</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">instance_cache.get</span> <span class=\"n\">cache</span> <span class=\"bp\">``</span><span class=\"n\">pencodable</span><span class=\"o\">,</span>\n   <span class=\"n\">return</span> <span class=\"n\">tt</span><span class=\"o\">)</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"o\">(</span><span class=\"n\">return</span> <span class=\"n\">ff</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- Given an expression of the form `polytime_fun (f x₁ x₂ ... xₙ)`, tries to infer `n`,</span>\n<span class=\"sd\">   the number of arguments. -/</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">get_num_params</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"k\">do</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">polytime_fun</span> <span class=\"bp\">%%</span><span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">target</span><span class=\"o\">,</span>\n    <span class=\"n\">guard</span> <span class=\"n\">s.is_lambda</span><span class=\"o\">,</span>\n    <span class=\"n\">mv</span> <span class=\"bp\">←</span> <span class=\"n\">mk_meta_var</span> <span class=\"n\">s.binding_domain</span><span class=\"o\">,</span>\n    <span class=\"n\">e</span> <span class=\"bp\">←</span>  <span class=\"n\">instantiate_mvars</span> <span class=\"o\">(</span><span class=\"n\">s.instantiate_lambdas</span> <span class=\"o\">[</span><span class=\"n\">mv</span><span class=\"o\">]),</span>\n    <span class=\"n\">f</span> <span class=\"bp\">←</span> <span class=\"n\">mfilter</span> <span class=\"n\">is_polycodable</span> <span class=\"n\">e.get_app_args</span><span class=\"o\">,</span>\n    <span class=\"n\">return</span> <span class=\"n\">f.length</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">  Given a goal of the form `⊢ polytime_fun (λ x, f (g₁ x) (g₂ x) ... (gₙ x))`</span>\n<span class=\"sd\">  tries to apply the corresponding composition rule to produce</span>\n<span class=\"sd\">  `⊢ polytime_funₙ f`, `⊢ polytime_fun g₁`, ..., `⊢ polytime_fun gₙ`</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">apply_polyfun.comp</span> <span class=\"o\">(</span><span class=\"n\">md</span> <span class=\"o\">:</span> <span class=\"n\">transparency</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"k\">do</span> <span class=\"n\">fail_if_success</span> <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">exact</span> <span class=\"n\">polytime_fun.const</span> <span class=\"n\">_</span><span class=\"o\">],</span>\n   <span class=\"n\">fail_if_success</span> <span class=\"o\">(</span><span class=\"n\">to_expr</span> <span class=\"bp\">``</span><span class=\"o\">(</span><span class=\"n\">polytime_fun.pair</span><span class=\"o\">)</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">e</span> <span class=\"o\">{</span><span class=\"n\">md</span> <span class=\"o\">:=</span> <span class=\"n\">md</span><span class=\"o\">}),</span>\n   <span class=\"n\">old_goal</span> <span class=\"bp\">←</span> <span class=\"n\">target</span><span class=\"o\">,</span>\n   <span class=\"n\">n</span> <span class=\"bp\">←</span> <span class=\"n\">get_num_params</span><span class=\"o\">,</span> <span class=\"n\">guard</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">∧</span> <span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"n\">polytime_fun_lemmas.length</span><span class=\"o\">),</span>\n   <span class=\"n\">s</span> <span class=\"bp\">←</span> <span class=\"n\">resolve_name</span> <span class=\"o\">(</span><span class=\"n\">polytime_fun_comp_lemmas.inth</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)),</span>\n   <span class=\"n\">s'</span> <span class=\"bp\">←</span> <span class=\"n\">to_expr</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n   <span class=\"n\">apply</span> <span class=\"n\">s'</span> <span class=\"o\">{</span><span class=\"n\">md</span> <span class=\"o\">:=</span> <span class=\"n\">md</span><span class=\"o\">},</span>\n   <span class=\"n\">try</span> <span class=\"bp\">`</span><span class=\"o\">[</span> <span class=\"n\">any_goals</span> <span class=\"o\">{</span> <span class=\"n\">apply_instance</span><span class=\"o\">,</span> <span class=\"o\">}</span> <span class=\"o\">],</span> <span class=\"c1\">-- why is this necessary??</span>\n   <span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">    - If the target is md-definitionally equal to what it used to be, up to</span>\n<span class=\"cm\">    - unfolding of polytime_fun₂, polytime_fun₃ etc., then no real progress has been made</span>\n<span class=\"cm\">    - EXCEPT if the goal can be immediately solved by apply_rules.</span>\n<span class=\"cm\">    - This last check is important because if we have something like</span>\n<span class=\"cm\">    - `⊢ polytime_fun (λ x : α × β, f x.1 x.2)`, and `polytime_fun₂ f` is a `polyfun` lemma,</span>\n<span class=\"cm\">    - even though this goal is definitionally equal to `polytime_fun₂ f`, `apply_rules` would not</span>\n<span class=\"cm\">    - find it at the `reducible` setting. Therefore, this will get reduced to</span>\n<span class=\"cm\">    - `⊢ polytime_fun₂ f`, `⊢ polytime_fun (λ x : α × β, x.1)`, and `⊢ polytime_fun (λ x : α × β, x.2)`.</span>\n<span class=\"cm\">    - It looks like no progress has been made, but because we can immediately solve `polytime_fun₂ f`, we continue to advance.</span>\n\n<span class=\"cm\">    - We need to check for definitional equality up to `unfold_polytime` because otherwise we get caught in a loop</span>\n<span class=\"cm\">    - where it looks like we make progress even though we don't. If we have the goal `⊢ polytime_fun (λ x, f x.1 x.2)`,</span>\n<span class=\"cm\">    - this gets reduced to `⊢ polytime_fun₂ f`, ... as before. If `f` is not actually polytime, it seems like we make progress</span>\n<span class=\"cm\">    - if we do not unfold `polytime_fun₂`, but `polytime_fun₂` will just be unfolded back to `polytime_fun (λ x, f x.1 x.2)` before</span>\n<span class=\"cm\">    - `apply_polyfun.comp` is called, causing a loop.</span>\n\n<span class=\"cm\">    - This check replaces the check to exclude `id` of the `continuity` tactic.</span>\n<span class=\"cm\">   -/</span>\n   <span class=\"o\">(</span><span class=\"n\">fail_if_success</span> <span class=\"o\">(</span><span class=\"n\">unfold_polytime</span> <span class=\"n\">md</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">target</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"bp\">λ</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">unify</span> <span class=\"n\">t</span> <span class=\"n\">old_goal</span> <span class=\"n\">md</span><span class=\"o\">))</span> <span class=\"bp\">&lt;|&gt;</span>\n    <span class=\"n\">focus1</span> <span class=\"o\">(</span><span class=\"n\">apply_rules</span> <span class=\"o\">[]</span> <span class=\"o\">[</span><span class=\"bp\">``</span><span class=\"n\">polyfun</span><span class=\"o\">]</span> <span class=\"mi\">50</span> <span class=\"o\">{</span> <span class=\"n\">md</span> <span class=\"o\">:=</span> <span class=\"n\">md</span> <span class=\"o\">}</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">done</span><span class=\"o\">),</span>\n  <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">polyfun_tactics</span> <span class=\"o\">(</span><span class=\"n\">md</span> <span class=\"o\">:</span> <span class=\"n\">transparency</span> <span class=\"o\">:=</span> <span class=\"n\">reducible</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">tactic</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">[</span>\n  <span class=\"n\">apply_rules</span> <span class=\"o\">[]</span> <span class=\"o\">[</span><span class=\"bp\">``</span><span class=\"n\">polyfun</span><span class=\"o\">]</span> <span class=\"mi\">50</span> <span class=\"o\">{</span> <span class=\"n\">md</span> <span class=\"o\">:=</span> <span class=\"n\">md</span> <span class=\"o\">}</span>\n                        <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">pure</span> <span class=\"s2\">\"apply_rules with polyfun\"</span><span class=\"o\">,</span>\n  <span class=\"n\">unfold_polytime</span> <span class=\"n\">md</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">pure</span> <span class=\"s2\">\"dunfold_target polytime_fun_lemmas.tail\"</span><span class=\"o\">,</span>\n  <span class=\"n\">simp_to_bool</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">pure</span> <span class=\"s2\">\"simp only [bool.to_bool_not, bool.to_bool_and, bool.to_bool_or]\"</span><span class=\"o\">,</span>\n  <span class=\"n\">apply_polyfun.comp</span> <span class=\"n\">md</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"s2\">\"apply \"</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"n\">to_string</span> <span class=\"bp\">$</span> <span class=\"n\">polytime_fun_comp_lemmas.inth</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)))</span>\n<span class=\"o\">]</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">interactive</span>\n<span class=\"n\">setup_tactic_parser</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">polyfun</span>\n  <span class=\"o\">(</span><span class=\"n\">bang</span> <span class=\"o\">:</span> <span class=\"n\">parse</span> <span class=\"bp\">$</span> <span class=\"n\">optional</span> <span class=\"o\">(</span><span class=\"n\">tk</span> <span class=\"s2\">\"!\"</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">trace</span> <span class=\"o\">:</span> <span class=\"n\">parse</span> <span class=\"bp\">$</span> <span class=\"n\">optional</span> <span class=\"o\">(</span><span class=\"n\">tk</span> <span class=\"s2\">\"?\"</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">cfg</span> <span class=\"o\">:</span> <span class=\"n\">tidy.cfg</span> <span class=\"o\">:=</span> <span class=\"o\">{})</span> <span class=\"o\">:</span>\n  <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"k\">let</span> <span class=\"n\">md</span>              <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">bang.is_some</span> <span class=\"k\">then</span> <span class=\"n\">semireducible</span> <span class=\"k\">else</span> <span class=\"n\">reducible</span><span class=\"o\">,</span>\n    <span class=\"n\">polyfun_core</span> <span class=\"o\">:=</span> <span class=\"n\">tactic.tidy</span> <span class=\"o\">{</span> <span class=\"n\">tactics</span> <span class=\"o\">:=</span> <span class=\"n\">polyfun_tactics</span> <span class=\"n\">md</span><span class=\"o\">,</span> <span class=\"bp\">..</span><span class=\"n\">cfg</span> <span class=\"o\">},</span>\n    <span class=\"n\">trace_fn</span>        <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">trace.is_some</span> <span class=\"k\">then</span> <span class=\"n\">show_term</span> <span class=\"k\">else</span> <span class=\"n\">id</span> <span class=\"k\">in</span>\n<span class=\"n\">trace_fn</span> <span class=\"n\">polyfun_core</span>\n\n\n<span class=\"kd\">end</span> <span class=\"n\">interactive</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">end</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">pencodable</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">@[polyfun]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">polytime_fun.nat_add</span> <span class=\"o\">:</span> <span class=\"n\">polytime_fun₂</span> <span class=\"o\">((</span><span class=\"bp\">+</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">polytime_fun₃</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">polyfun</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">polytime_fun</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">polyfun</span>\n\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p><span class=\"user-mention\" data-user-id=\"303675\">@Anand Rao</span> I agree with Eric Wieser that it seems a bit dangerous and unpredictable to put <code>comp</code> in the instance search.</p>\n<p>Also, what is your interpretation of e.g.  <code>polytime nat.add</code>, since <code>nat.add</code> has signature <code>ℕ → ℕ → ℕ</code>? Keep in mind, the function which takes in a natural number <code>ℕ</code> and outputs a function <code>ℕ → ℕ</code>, to be considered to be \"polynomial time,\" needs to have an encoding for functions <code>ℕ → ℕ</code>. For example, the encoding could be to encode (polynomial-time) functions as programs themselves. But this presents its own complications, because you need to already know that adding a constant is polynomial time, and \"uniformly\" polynomial time in the argument (i.e. you can create in polynomial time a program to add any particular constant in polynomial time). Moreover, you don't get an encoding for all functions <code>ℕ → ℕ</code>, just the polytime ones, so this couldn't be stated as <code>polytime nat.add</code> in any case, it seems.</p>",
        "id": 292681311,
        "sender_full_name": "Praneeth Kolichala",
        "timestamp": 1660093706
    },
    {
        "content": "<p>Maybe we could encode functions of the type <code>ℕ → ℕ</code> through their corresponding expressions. So we could say that a function <code>f : ℕ →  ℕ → ℕ</code> is polynomial time in its first input if the <code>expr</code> for <code>f a</code> can be computed in polynomial time in <code>a</code>, and the resulting function <code>f a</code> is also a polynomial-time function (in the usual sense).<br>\n(The interpretation I had in mind while writing my code was more in line with your <code>polytime_fun₂</code> function, but I am not confident about the correctness of that interpretation in the context of my code anymore.)</p>",
        "id": 292694804,
        "sender_full_name": "Anand Rao",
        "timestamp": 1660108536
    },
    {
        "content": "<p>Proving qualities about parsers was done using the TC system, and it seems to have worked in figuring out that the map of a parser or the bind of two parsers is X when both are X. It used the derive handler</p>",
        "id": 292736196,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1660130835
    },
    {
        "content": "<p>The key difference here is that <a href=\"https://leanprover-community.github.io/mathlib_docs/find/parser\">docs#parser</a> is not a raw function composed with <code>function.comp</code>, so there is no danger of higher order unification breaking things.</p>",
        "id": 292738117,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1660131625
    },
    {
        "content": "<blockquote>\n<p>Would an approach based on typeclass inference work here?</p>\n</blockquote>\n<p>Maybe, but it's definitely not a proper approach. This is a job for a tactic.</p>",
        "id": 292859756,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1660185264
    },
    {
        "content": "<p>We've previously discussed how in most cases, you probably shouldn't be using classes on terms. I forget what the reasoning was, but I do remember some high-profile people pitching in on this discussion</p>",
        "id": 292859831,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1660185341
    },
    {
        "content": "<p>Ah, here goes: <a href=\"#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/286467225\">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/286467225</a></p>",
        "id": 292859976,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1660185446
    },
    {
        "content": "<p>On this same topic, I think we should set in stone what exactly we want the job of typeclass inference to be. I think most of us already have the mental model of classes as a hierarchy, e.g. the order hierarchy or algebraic hierarchy in mathlib, and this more clever use of typeclasses just doesn't fit in that model.</p>",
        "id": 292860063,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1660185533
    },
    {
        "content": "<p>Thanks. From the discussion in the thread and Eric Wieser's message above, it seems like inferring that composition of polynomial-time functions is polynomial-time might be problematic.</p>",
        "id": 292868802,
        "sender_full_name": "Anand Rao",
        "timestamp": 1660195359
    },
    {
        "content": "<p>One crude workaround is to use <code>show ...</code> to bring the expression to an appropriate form before using typeclass inference.</p>",
        "id": 292868913,
        "sender_full_name": "Anand Rao",
        "timestamp": 1660195453
    },
    {
        "content": "<p>The role of typeclasses in keeping track of order or algebraic hierarchies is similar to the role of \"classes\" in imperative languages. <br>\nAs mentioned in TPiL, the additional ability of Lean's typeclass mechanism to chain various instances can be quite powerful, and I think the full-blown logical language that arises from recursive chaining can be very useful (like in the present case).</p>\n<p>Of course, I speak only as a user of the language, and I don't know what conventions will be more suitable for <code>mathlib</code> taking into consideration aspects like efficiency and readability.</p>",
        "id": 292870572,
        "sender_full_name": "Anand Rao",
        "timestamp": 1660196949
    },
    {
        "content": "<p>Actually, this could very well be the job of the typeclass inference because a function is polynomial-time <strong>structurally</strong>. Namely, a function is polynomial-time because it's built out of polynomial-time functions, and recursively... The only thing that goes against that is indeed that one of the \"constructors\" for polynomial-time functions is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/function.comp\">docs#function.comp</a>, which is reducible. And that seems to screw everything up.</p>",
        "id": 292905361,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1660214936
    },
    {
        "content": "<p>But note the same remark about structure could be said about the problems solved by the <code>continuity</code> tactic, where we don't use a typeclass</p>",
        "id": 292983471,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1660242251
    }
]