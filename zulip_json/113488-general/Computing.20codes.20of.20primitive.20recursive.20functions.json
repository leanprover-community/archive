[
    {
        "content": "<p>I am trying to wrap my head around <code>`Mathlib.Computability.PartrecCode</code>. In particular, I would like to define codes of the combinators <code>K</code> and <code>S</code>. Let's consider <code>K</code>, which is easier. Intuitively, <code>K</code> is the primitive recursive function which takes a number <code>n</code> and outputs the number encoding <code>Code.const n</code>. It feels like <code>PartrecCode</code> should have the ability to do this. (We need a Batman-style  signal for <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>)</p>",
        "id": 491518593,
        "sender_full_name": "Andrej Bauer",
        "timestamp": 1735755362
    },
    {
        "content": "<p>I think I want <code>Mathlib.Computability.Code.exists_code</code> but with a dependent sum instead of the existential, except that this is not the sort of thing I can hope to get, becuse it would give canonical codes of partial computable maps.</p>",
        "id": 491519348,
        "sender_full_name": "Andrej Bauer",
        "timestamp": 1735756178
    },
    {
        "content": "<p>It looks like I could show that there exists a code for the <code>K</code> combinator, but it won't let me actually compute the code – which is kind of funny, because the \"correct\" definition of a PCA asks for existence of <code>K</code> and <code>S</code>, rather than concrete instances of them.</p>",
        "id": 491521540,
        "sender_full_name": "Andrej Bauer",
        "timestamp": 1735758348
    },
    {
        "content": "<p>Is there some <code>noncomputable</code> trickery that would allow me to derive from <code>∃ x : A, p x</code> an element <code>a : A</code> and a proof of <code>p a</code>?</p>",
        "id": 491780124,
        "sender_full_name": "Andrej Bauer",
        "timestamp": 1735921625
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Exists.choose#doc\">docs#Exists.choose</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Exists.choose_spec#doc\">docs#Exists.choose_spec</a></p>",
        "id": 491780333,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1735921739
    },
    {
        "content": "<p>if you're doing things with <code>Nat</code>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.find#doc\">docs#Nat.find</a> might also be among your interests (as it is computable)</p>",
        "id": 491780563,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1735921841
    },
    {
        "content": "<p>Unfortunately no, the predicates involved are Π⁰₁ (namely that a number is the Godel code of a partial recursive map).</p>",
        "id": 491780872,
        "sender_full_name": "Andrej Bauer",
        "timestamp": 1735921983
    },
    {
        "content": "<p>actually, if this just concerns a proof, just using the <code>obtain</code> tactic should be sufficient</p>",
        "id": 491781116,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1735922103
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"345260\">@Andrej Bauer</span> (the batmobile is in the shop, sorry for the delay) You seem to have found the answer already, but <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.Partrec.Code.const_prim#doc\">docs#Nat.Partrec.Code.const_prim</a> is the theorem you are looking for, except that as you point out it is a mere existence statement. You could copy and paste it to construct the <code>Code</code> though. Another possibility is to refactor things so that most of the primrec theorems are data-carrying. I think at the time I reasoned that it's better not to use defs for primrec proofs because the concrete definitions are not at all good computationally and I didn't want to have to think about that</p>",
        "id": 495232238,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1737537299
    },
    {
        "content": "<p>but basically all of them are explicit constructive proofs so it's easy enough to refactor them to get witnesses as needed</p>",
        "id": 495232492,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1737537375
    }
]