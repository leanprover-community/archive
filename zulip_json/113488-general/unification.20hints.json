[
    {
        "content": "<p>Can we use unification hints to make sure that we can just write <code>ℤ</code> if we want to view the integers as an object of the category <code>CommRing</code>?</p>",
        "id": 158512228,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1550133397
    },
    {
        "content": "<p>I don't think so. Unification hints seem more useful for unbundling a bundled structure than bundling an unbundled one</p>",
        "id": 158546457,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1550164725
    },
    {
        "content": "<p>Too bad... I really liked the notation (-;</p>",
        "id": 158549046,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1550166718
    },
    {
        "content": "<p>Is there a canonical example of unification hints being used in Lean that someone can point to?</p>",
        "id": 158607025,
        "sender_full_name": "Joseph Corneli",
        "timestamp": 1550229350
    },
    {
        "content": "<p>Cyril and Assia had a demonstration at Lean Together, I wonder if that file is available somewhere</p>",
        "id": 158607080,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1550229387
    },
    {
        "content": "<p>It's never been used in lean core or mathlib outside one example in <code>init.core</code></p>",
        "id": 158607093,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1550229425
    },
    {
        "content": "<p>I emailed them to ask about the file!</p>",
        "id": 158612898,
        "sender_full_name": "Joseph Corneli",
        "timestamp": 1550236384
    },
    {
        "content": "<p>Hi! Both the Coq demo and the Lean equivalent are available on <a href=\"https://lean-forward.github.io/lean-together/2019/\" target=\"_blank\" title=\"https://lean-forward.github.io/lean-together/2019/\">https://lean-forward.github.io/lean-together/2019/</a></p>",
        "id": 158612979,
        "sender_full_name": "Cyril Cohen",
        "timestamp": 1550236498
    },
    {
        "content": "<p>Assia Mahboubi: unification hints (in Coq) <a href=\"https://lean-forward.github.io/lean-together/2019/slides/coq_cs_demo.v\" target=\"_blank\" title=\"https://lean-forward.github.io/lean-together/2019/slides/coq_cs_demo.v\">https://lean-forward.github.io/lean-together/2019/slides/coq_cs_demo.v</a><br>\nCyril Cohen: unification hints (in Lean) <a href=\"https://lean-forward.github.io/lean-together/2019/slides/demo_structures.lean\" target=\"_blank\" title=\"https://lean-forward.github.io/lean-together/2019/slides/demo_structures.lean\">https://lean-forward.github.io/lean-together/2019/slides/demo_structures.lean</a></p>",
        "id": 158613068,
        "sender_full_name": "Cyril Cohen",
        "timestamp": 1550236608
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> </p>\n<blockquote>\n<p>Can we use unification hints to make sure that we can just write <code>ℤ</code> if we want to view the integers as an object of the category <code>CommRing</code>?</p>\n</blockquote>\n<p>We, in mathcomp, usually explicitly wrap them e.g. <code>[CommRing  of ℤ]</code> to denote the canonical structure associated to a carrier. In Coq there is no way to automate this further to my knowledge. But maybe in Lean you could use some special kind of coercion. Indeed, since coercions are fused with the typeclass system, you could make a coercion from <code>Type</code> that finds the structure  and packages it with the type to give you the structure as a result.</p>",
        "id": 158613326,
        "sender_full_name": "Cyril Cohen",
        "timestamp": 1550236850
    },
    {
        "content": "<p>thanks!</p>",
        "id": 158613483,
        "sender_full_name": "Joseph Corneli",
        "timestamp": 1550237024
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110193\">@Cyril Cohen</span> I don't follow... you want a coercion from <code>Type</code> to <code>CommRing</code>? But then it has to turn every type into a commutative ring...</p>",
        "id": 158613615,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1550237138
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> only when the inference succeeds in finding a <code>CommRing</code> typeclass on the argument. I'm not sure it works, I'm just guessing it might, given how coercions are implemented in lean.</p>",
        "id": 158614041,
        "sender_full_name": "Cyril Cohen",
        "timestamp": 1550237576
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> on second thought, I do not think it is possible ... sorry for the false hopes...</p>",
        "id": 158614207,
        "sender_full_name": "Cyril Cohen",
        "timestamp": 1550237739
    },
    {
        "content": "<p>No problem...</p>",
        "id": 158614275,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1550237791
    },
    {
        "content": "<p>How does the <code>coe</code> from <code>Prop</code> to <code>bool</code> work? That's a partial coercion.</p>",
        "id": 158616977,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1550240331
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> which files did you import?</p>",
        "id": 158617505,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1550240854
    },
    {
        "content": "<p>I'm afk, but I think it's in core. It only works on decidable props.</p>",
        "id": 158617735,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1550241022
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">to_bool</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">decidable</span> <span class=\"n\">p</span><span class=\"o\">],</span> <span class=\"n\">bool</span>\n</pre></div>",
        "id": 158617772,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1550241056
    },
    {
        "content": "<p>But I don't have to write <code>to_bool</code></p>",
        "id": 158617804,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1550241088
    },
    {
        "content": "<p>interesting</p>",
        "id": 158617817,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1550241099
    },
    {
        "content": "<p>bool to Prop is a special case handled in the C++ code, iirc</p>",
        "id": 158618974,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1550242044
    },
    {
        "content": "<p>this will change in some way in lean 4, but I don't remember where I read that</p>",
        "id": 158619078,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1550242102
    },
    {
        "content": "<p>I have been trying to write a unification hint to get <code>((s : Finset α) : Set _)</code> to work. Can anyone see what I did wrong?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Meta</span>\n\n<span class=\"c1\">-- @[unify] def finsetToSet {α β : Type*} (s : Finset α) (t : Set β) : UnificationHint where</span>\n<span class=\"c1\">--   pattern := ⟨`(s), t⟩</span>\n<span class=\"c1\">--   constraints := [⟨α, β⟩]</span>\n\n<span class=\"kn\">unif_hint</span><span class=\"w\"> </span><span class=\"n\">forget_obj_eq_coe</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">≟</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">≟</span><span class=\"w\"> </span><span class=\"n\">t</span>\n<span class=\"c1\">-- unexpected token '≟'; expected ':' or ']'</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">application type mismatch</span>\n<span class=\"cm\">  Set.univ ⊆ s</span>\n<span class=\"cm\">argument</span>\n<span class=\"cm\">  s</span>\n<span class=\"cm\">has type</span>\n<span class=\"cm\">  Finset α : Type u_1</span>\n<span class=\"cm\">but is expected to have type</span>\n<span class=\"cm\">  Set ?m.342 : Type u_1</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 478968092,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1729880388
    },
    {
        "content": "<p>I think α and β need t be at the same universe level. But I don't understand what you're trying to do here.</p>",
        "id": 478992552,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1729892943
    },
    {
        "content": "<p>Maybe you mean something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">unif_hint</span><span class=\"w\"> </span><span class=\"n\">guess</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=?=</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=?=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 478993555,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1729893569
    },
    {
        "content": "<p>I am trying to get the <code>example</code> in my MWE working without error</p>",
        "id": 479000637,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1729897938
    },
    {
        "content": "<p>I don't really understand what membership has to do with it</p>",
        "id": 479000673,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1729897980
    },
    {
        "content": "<p>It is a huge impediment to the finset library that we can't use <code>s : Set alpha</code> in a function expecting a <code> Set ?beta</code> unless Lean knows that <code>?beta := alpha</code>. I am trying to make Lean automatically set <code>?beta := alpha</code> in such a situation.</p>",
        "id": 479000869,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1729898159
    },
    {
        "content": "<p>I'm not too familiar with unification hints, but it seems like the won't work here. The issue is that you're needing a coercion to apply, and it's the coercion that's failing to be synthesized because typeclass synthesis refuses to assign the metavariable in <code>Set _</code>. This assignment can't happen even with hints.</p>",
        "id": 479001264,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729898441
    },
    {
        "content": "<p>But Yael is right, I've run into this and I hardly ever use finsets, so presumably many people have. Is there anything we can do about it?</p>",
        "id": 479001480,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1729898621
    },
    {
        "content": "<p>Coercion has special support for some similar situations, like if Finset and Set were both monads and there were a <code>MonadLift Finset Set</code> instance then it could do something.</p>\n<p>It would be nice if there were a system supporting \"functorial\" coercions, like a coercion from the <code>Finset</code> to <code>Set</code> (not a coercion from <code>Finset X</code> to <code>Set X</code> — a coercion of the type functions themselves)</p>",
        "id": 479001491,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729898630
    },
    {
        "content": "<p>Somewhat related, we have support for this situation in mathlib in the form of the <code>fbinop%</code> elaborator for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SProd.sprod#doc\">docs#SProd.sprod</a>, to be able to elaborate products of sets/finsets/filters.</p>",
        "id": 479001764,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729898834
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/113488-general/topic/unification.20hints/near/479000637\">said</a>:</p>\n<blockquote>\n<p>I am trying to get the <code>example</code> in my MWE working without error</p>\n</blockquote>\n<p>For a unification hint to be valid the conclusion has to unify given the unification hypotheses.  Your (slightly edited) proposal</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">unif_hint</span><span class=\"w\"> </span><span class=\"n\">forget_obj_eq_coe</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">≟</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">≟</span><span class=\"w\"> </span><span class=\"n\">t</span>\n</code></pre></div>\n<p>doesn't work since it says that any such s and t must unify so long as α and β unify. That doesn't make sense (except perhaps when α and β are both empty). I don't understand what you're aiming for.</p>",
        "id": 479008359,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1729904731
    },
    {
        "content": "<p>(Also, the proposed example doesn't appear to be true.)</p>",
        "id": 479008472,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1729904872
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/113488-general/topic/unification.20hints/near/479000869\">said</a>:</p>\n<blockquote>\n<p>It is a huge impediment to the finset library that we can't use <code>s : Set alpha</code> in a function expecting a <code> Set ?beta</code> unless Lean knows that <code>?beta := alpha</code>. I am trying to make Lean automatically set <code>?beta := alpha</code> in such a situation.</p>\n</blockquote>\n<p>So you want this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">unif_hint</span><span class=\"w\"> </span><span class=\"n\">another_guess</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">≟</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">≟</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">β</span>\n</code></pre></div>\n<p>I don't think that's useful but it works!</p>",
        "id": 479008659,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1729905076
    },
    {
        "content": "<p>Yael misspoke, that doesn't need a unification hint since it already follows from the usual defeq rules. It's for <code>((s : Finset X) : Set _)</code>, getting the coercion to work and propagating the <code>X</code>.</p>",
        "id": 479008861,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729905348
    },
    {
        "content": "<p>With an example that makes sense, I might be able to figure out the right unification hint (assuming that's what is actually needed).</p>",
        "id": 479009447,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1729906023
    },
    {
        "content": "<p>Did anyone try  a <code>HasHSubset</code> class? (Not clear where the extra <code>H</code> should go.)</p>",
        "id": 479011006,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1729907729
    },
    {
        "content": "<p>Actually that might be a job for a default instance?</p>",
        "id": 479028486,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1729926974
    },
    {
        "content": "<p>I don't just want this to work for subset notation but any function that expects a set</p>",
        "id": 479028502,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1729927019
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">annoying</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">∅</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Subsingleton</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Here's a massively simplified example of what gets frustrating in practice. Lean gives the error</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">application</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">mismatch</span>\n<span class=\"w\">  </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Subsingleton</span><span class=\"w\"> </span><span class=\"n\">s</span>\n<span class=\"n\">argument</span>\n<span class=\"w\">  </span><span class=\"n\">s</span>\n<span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"n\">but</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">expected</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">102</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n</code></pre></div>\n<p>but - in my mind - it's clear that <code>Set ℕ</code> is the only sensible choice here. The current workarounds which appear are:<br>\n<code>Set.Subsingleton s.toSet</code> or <code>Set.Subsingleton (s : Set ℕ)</code>, both of which seem unnecessarily wordy (especially if I have a finset in a type which is less nice to write down). It'd be really nice if I could just write <code>Set.Subsingleton s</code>, and Lean could automatically figure out that a finite set of naturals can be seen as a set of naturals.</p>",
        "id": 479184548,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1730080973
    },
    {
        "content": "<p>I was mentioning earlier that if <code>Set</code> and <code>Finset</code> were both monads and you had a MonadLift instance, then there's already coercion infrastructure for this, but we intentionally disabled the <code>Set</code> monad instance earlier this year because it could be surprising, and it would insert some monad functions that there wasn't any theory about.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>MonadLift example</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Classical</span>\n\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"kn\">local</span><span class=\"w\"> </span><span class=\"kd\">instance</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">Set.monad</span><span class=\"w\"> </span><span class=\"n\">Finset.instMonad</span>\n\n<span class=\"kd\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MonadLift</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">monadLift</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">s</span>\n\n<span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">annoying</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">∅</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set.Subsingleton</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">annoying {s : Finset ℕ} (hs : s = ∅) : (liftM s).Subsingleton</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n</div></div>",
        "id": 479191384,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730086879
    },
    {
        "content": "<p>And what if we made that monad function the default coercion from a finset to a set. How would that be?</p>",
        "id": 479210037,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1730099961
    },
    {
        "content": "<p>In Bhavik's example, unification works fine and unification hints don't work. TC inference fails because the goal is <code>CoeT (Finset Nat) s (Set ?m)</code> but TC inference can't assign the mvar.</p>\n<p>Kyle's example works because the TC goal is <code>MonadLiftT Finset Set</code>, which has no unassignable mvars. This is probably the right way to go.</p>",
        "id": 479258323,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1730116787
    },
    {
        "content": "<p>Is it at all possible to make TC inference able to assign the mvar in that example?</p>",
        "id": 479270118,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1730120459
    },
    {
        "content": "<p>To make TC inference to assign mvars they need to be semiOutParam or outParam. I'm thinking that with <code>CoeT</code> this is not going to play well with the complex maze of <code>Coe*</code> classes. This is what <code>CoeHead</code> is for but that won't help here, I think. The other mechanism is default instances but I'm skeptical that can be made to work.</p>",
        "id": 479274815,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1730121863
    },
    {
        "content": "<p>Could CoeOut be useful here?</p>",
        "id": 479298604,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1730128343
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119741\">François G. Dorais</span> <a href=\"#narrow/channel/113488-general/topic/unification.20hints/near/479274815\">said</a>:</p>\n<blockquote>\n<p>I'm thinking that with <code>CoeT</code> this is not going to play well with the complex maze of <code>Coe*</code> classes.</p>\n</blockquote>\n<p>Also neither argument to <code>Coe</code> is an output. We'd soon run into examples where we want <code>fun s : Finset _ =&gt; (s : Set Nat)</code> to work too.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"119741\">François G. Dorais</span> <a href=\"#narrow/channel/113488-general/topic/unification.20hints/near/479258323\">said</a>:</p>\n<blockquote>\n<p>Kyle's example works because the TC goal is <code>MonadLiftT Finset Set</code>, which has no unassignable mvars.</p>\n</blockquote>\n<p>Yes and no. That's why the MonadLiftT instance succeeds, but the key fact is that there is special elaborator support for computing coercions using monad lifts.</p>\n<p>I would rather that we don't explore using Monad here, but instead come up with a solid proposal for functorial coercions in core. This problem crops up frequently.</p>",
        "id": 479298803,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730128412
    },
    {
        "content": "<p>There are two axes here:</p>\n<ol>\n<li>Given <code>F X</code> and a \"functor coercion\" from <code>F</code> to <code>G</code>, getting a coercion <code>F X -&gt; G X</code>.</li>\n<li>Given <code>F X</code> and a coercion <code>X</code> to <code>Y</code>, getting a coercion <code>F X -&gt; F Y</code>.</li>\n</ol>\n<p>The monad coercion system lets you navigate both of these:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- The monad</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MonadLiftT</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"c1\">-- The type</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">[(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">CoeT</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"c1\">-- Both</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MonadLiftT</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">CoeT</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>\n<p>Questions:</p>\n<ol>\n<li>Should the system derive an automatic coercion from <code>Finset Nat</code> to <code>Finset Int</code>?</li>\n<li>Should the system derive an automatic coercion from <code>Finset Nat</code> to <code>Set Int</code>?</li>\n</ol>\n<p>A \"yes\" answer to 1 implies a \"yes\" to 2 by transitivity of coercions.</p>\n<p>My own opinion is \"no\" to these. While it makes sense for monads (monads are values-with-context, the context should be relatively transparent), with containers this is more fraught. (1) For programming, the inserted coercion might insert a completely accidental copying of the entire data structure. (2) For math, I would expect that getting elaboration to succeed would become a lot more slippery due to all these postponed coercion problems. We disabled the <code>Set</code> monad instance in mathlib partly because it wasn't always anticipated. (We also disabled it because it introduced weird monad functions, but that's fixable in principle.)</p>",
        "id": 479353819,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730146890
    },
    {
        "content": "<p>My answers:</p>\n<ol>\n<li>Eh, maybe</li>\n<li>No, because you could either go through <code>Finset Int</code> or <code>Set Nat</code>, and the defeq is different depending on which way you go</li>\n</ol>",
        "id": 479354187,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1730147046
    },
    {
        "content": "<p>Good point re 2, that's a lot better of a reason than my justification. (And a 'no' to 2 means a 'no' to 1, since otherwise coercions aren't transitive.)</p>",
        "id": 479355554,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730147630
    },
    {
        "content": "<p>Coercions don't <em>have</em> to be transitive, right? That's why we have so many <code>CoeSomething</code> typeclasses, no?</p>",
        "id": 479355896,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1730147790
    },
    {
        "content": "<p>Yeah I suppose you're right.</p>\n<p>If this were wired into <code>CoeHead</code> for example, then that would solve 2, though you could still trigger a sequence of coercions to get a coercion diamond.</p>\n<p>Incidentally, why is <code>Finset.instCoeTCSet</code> a <code>CoeTC</code>? That's a nonstandard, since it's meant to be the transitive closure of <code>Coe</code>.</p>",
        "id": 479357560,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730148644
    },
    {
        "content": "<p>6 messages were moved from this topic to <a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/channel/113488-general/topic/Why.20is.20the.20Finset-.3ESet.20coercion.20instance.20CoeTC.3F.20.28Was.3A.20uni.2E.2E.2E\">#general &gt; Why is the Finset-&gt;Set coercion instance CoeTC? (Was: uni...</a> by <span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span>.</p>",
        "id": 479366455,
        "sender_full_name": "Notification Bot",
        "timestamp": 1730152973
    }
]