[
    {
        "content": "<p>In my project, I want to include some reasoning from Wadler's \"Theorems for Free!\" I stated one of his metatheorems as an axiom and then tried to apply it in a theorem but failed. Lean 3 complained about the type of the polymorphic function. I suspect the problem is due to my use of <code>Type*</code> and how Lean 3 handles it, but I don't know how to resolve it. Perhaps something with declaring a universe? Below is a MWE.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- If a function is polymorphic, it commutes with the map function</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">wadler</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">},</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">l.map</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">l</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">g</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">fact</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">},</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">bool</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">l.map</span> <span class=\"n\">h</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">((</span><span class=\"n\">f</span> <span class=\"n\">l</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">wadler</span> <span class=\"n\">f</span> <span class=\"n\">l</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>The error in Lean is </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">application</span>\n  <span class=\"n\">wadler</span> <span class=\"n\">f</span>\n<span class=\"n\">term</span>\n  <span class=\"n\">f</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">list</span> <span class=\"bp\">?</span><span class=\"n\">m_1</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"bp\">?</span><span class=\"n\">m_1</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">?</span><span class=\"o\">},</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"bp\">?+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 325275466,
        "sender_full_name": "Cayden Codel",
        "timestamp": 1675288389
    },
    {
        "content": "<p>Replace <code>f</code> by <code>@f _</code> to force Lean to remove the <code>{α : Type ?}</code> argument.</p>",
        "id": 325275978,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1675288572
    },
    {
        "content": "<p>Oh wow. Writing just <code>@f</code> instead of <code>f</code> works (adding the underscore kept the same error). Thanks!</p>",
        "id": 325276403,
        "sender_full_name": "Cayden Codel",
        "timestamp": 1675288747
    },
    {
        "content": "<p>Ah right I misparsed the error! :D</p>",
        "id": 325276644,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1675288835
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">wadler</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">},</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">l.map</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">l</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">g</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">not_wadler</span> <span class=\"o\">:</span> <span class=\"n\">false</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">classical</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">),</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"n\">ℕ</span> <span class=\"k\">then</span> <span class=\"bp\">λ</span> <span class=\"n\">L</span><span class=\"o\">,</span> <span class=\"o\">[]</span> <span class=\"k\">else</span> <span class=\"bp\">λ</span> <span class=\"n\">L</span><span class=\"o\">,</span> <span class=\"n\">L</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">wadler</span> <span class=\"n\">f</span> <span class=\"o\">[</span><span class=\"n\">unit.star</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"mi\">37</span><span class=\"o\">),</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">if_pos</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">unit</span> <span class=\"bp\">≠</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">subsingleton</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span> <span class=\"n\">infer_instance</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">h</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">this</span> <span class=\"k\">with</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n    <span class=\"n\">specialize</span> <span class=\"n\">this</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"o\">},</span>\n  <span class=\"n\">rw</span> <span class=\"n\">if_neg</span> <span class=\"n\">foo</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 325276986,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1675288974
    },
    {
        "content": "<p>Turns out, you get what you pay for</p>",
        "id": 325277417,
        "sender_full_name": "Reid Barton",
        "timestamp": 1675289161
    },
    {
        "content": "<p>Parametricity is <em>anti-classical</em>, meaning it directly implies the negation of excluded middle. Also, Wadler seems to be in a system where there is no universe levels, and the <code>forall</code> can quantify over every type, including the type you are defining itself. So there isn't much hope doing this in Lean.</p>",
        "id": 325367916,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1675335860
    },
    {
        "content": "<p>Trebor, Kevin is well-aware of all this. His answer is his way to say: I'm living in the real world, not a world of exotic logic.</p>",
        "id": 325421624,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1675350410
    },
    {
        "content": "<p>I'm living in the world of mathematics departments is perhaps a more accurate way to say it. If you look at the axioms I use in my proof you can see I'm using classical ones. If you are careful you can probably still develop a theory using the wadler axiom in lean 3 but you'll have to be super careful that you check every result for classical axioms because you can't turn them off.</p>",
        "id": 325430425,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1675352627
    },
    {
        "content": "<p>I remember reading the wadler paper and being so confused! I was trying to learn type theory at the time and I was just thinking \"but all of these theorems are false!\"</p>",
        "id": 325430708,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1675352691
    },
    {
        "content": "<p>The real (classically-valid) theorem is that the parametricity theorems hold for all the terms that you can define without axioms.</p>",
        "id": 325434994,
        "sender_full_name": "Reid Barton",
        "timestamp": 1675353784
    },
    {
        "content": "<p>It's internal parametricity that's anti-classical.</p>",
        "id": 325435090,
        "sender_full_name": "Reid Barton",
        "timestamp": 1675353807
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/Fighting.20with.20type.20universing/near/325430708\">said</a>:</p>\n<blockquote>\n<p>I remember reading the wadler paper and being so confused! I was trying to learn type theory at the time and I was just thinking \"but all of these theorems are false!\"</p>\n</blockquote>\n<p>If you interpret <code>forall</code> as an <em>intersection</em> instead of an infinite product, then it does seem right even to mathematicians. <code>id</code> is the only function (understood in the Eulerian sense, i.e. defined by an expression, not in the modern sense, being defined by a correspondence relation) that is in the intersection of all the types <code>x -&gt; x</code>.</p>",
        "id": 325436129,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1675354022
    },
    {
        "content": "<p>No, this doesn't make sense to mathematicians</p>",
        "id": 325437216,
        "sender_full_name": "Reid Barton",
        "timestamp": 1675354263
    },
    {
        "content": "<p>For me \"if then else\" makes a lot of sense, maybe this is the problem</p>",
        "id": 325484694,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1675367375
    },
    {
        "content": "<p>You also don't need to do weird case splits on equalities of Types to disprove it.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.List.Dedup</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">wadler</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">},</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">l.map</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">l</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">g</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">not_wadler</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">classical</span> <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">wadler</span> <span class=\"n\">Bool</span> <span class=\"n\">Bool</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">l</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">l.dedup</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">true</span><span class=\"o\">,</span> <span class=\"n\">false</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span><span class=\"o\">)</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">@</span><span class=\"n\">List.dedup_cons_of_not_mem</span>  <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n      <span class=\"o\">(</span><span class=\"n\">mt</span> <span class=\"n\">List.mem_singleton.1</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"n\">true</span> <span class=\"bp\">≠</span> <span class=\"n\">false</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span><span class=\"o\">))]</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">List.map</span><span class=\"o\">,</span> <span class=\"n\">List.dedup_cons_of_mem</span> <span class=\"o\">(</span><span class=\"n\">List.mem_singleton.2</span> <span class=\"n\">rfl</span><span class=\"o\">)]</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n</code></pre></div>",
        "id": 325588783,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1675418873
    },
    {
        "content": "<p>The constructivist take on this example is that <code>List.dedup</code> only works on types with decidable equality and so you only get a parametricity theorem that works on functions that preserve equality (i.e., injective functions).</p>",
        "id": 325591725,
        "sender_full_name": "Reid Barton",
        "timestamp": 1675419839
    }
]