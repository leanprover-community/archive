[
    {
        "content": "<p>Right now we have the silly situation where I explain to mathematicians what <code>rw</code> does, and then they try it when they're using finite sums or whatever, and it doesn't work and you get an inscrurible error, and then I have to tell them that <code>rw</code> doesn't work under binders and you have to use <code>simp_rw</code> instead. </p>\n<p>Why can't we just make <code>rw</code> work under binders, e.g. by replacing it with <code>simp_rw</code>?</p>",
        "id": 451341051,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1720951667
    },
    {
        "content": "<p><code>rw</code> works in some cases where <code>simp_rw</code> doesn't (when it has to create side goals, which <code>simp</code> does not).</p>",
        "id": 451341786,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1720952233
    },
    {
        "content": "<p>(Sitting on a train from Munich to Berlin, with a number of your compatriots that want to watch the final <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> )</p>",
        "id": 451341825,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1720952270
    },
    {
        "content": "<p>Then why can't we \"just fix <code>rw</code> so that it works under binders\"? All I'm saying is that from a naive usability perspective this just looks totally weird. Maybe I'm being too naive.</p>",
        "id": 451344541,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1720954105
    },
    {
        "content": "<p>This is just me guessing, but my impression of the <code>rw</code> tactic has been that it's supposed to be simple and efficient, which mean's that the mechanism it uses for rewriting is also simple (just using the recursor of <code>Eq</code>?). Rewriting under binders requires more sophisticated mechanisms like function extensionality, which in turn requires congruence lemmas, which gets complicated once you have dependent functions. So I think that's why that kind of rewriting is only available in the more complicated tactics like <code>simp</code>. <br>\nBut would be interesting to hear the reasons from the people who actually know.</p>",
        "id": 451344942,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1720954494
    },
    {
        "content": "<p>If <code>rw</code> is so fast then you can automatically try if it works, else use <code>simp_rw</code>?</p>",
        "id": 451345545,
        "sender_full_name": "Ralf Stephan",
        "timestamp": 1720955055
    },
    {
        "content": "<p>There is the annoyance that <code>simp_rw</code> is less ‘surgical’ - what if you only want to apply it exactly once to something inside a binder?</p>",
        "id": 451347124,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1720957006
    },
    {
        "content": "<p>The following works, showing that <code>simp_rw</code> is able to use functional extensionality, something we probably don't want for a basic tactic like <code>rw</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"n\">simp_rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 451347164,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1720957077
    },
    {
        "content": "<p>In particular this <code>simp_rw</code> is impossible to obtain without <code>Quot.sound</code> and <code>propext</code></p>",
        "id": 451347254,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1720957175
    },
    {
        "content": "<p>Having said that, I agree that it would be nice if <code>import Mathlib</code> could make <code>rw</code> more powerful.</p>",
        "id": 451347337,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1720957288
    },
    {
        "content": "<p>How difficult would it be to make rw detect \"I'm asked to rewrite under binders\" and provide an error \"sorry Dave, I can't do that; use simp_rw instead\"?</p>",
        "id": 451347420,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1720957415
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"479299\">@Jovan Gerbscheid</span> has a version of rewrite working under binders</p>",
        "id": 451348454,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1720958696
    },
    {
        "content": "<p>Yes my point is that it's confusing for beginners. It would be nice if the error message said something less confusing than \"I can't find the pattern which you can see is visibly there\"</p>",
        "id": 451349063,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1720959379
    },
    {
        "content": "<p>Yes, making <code>rw</code> work under binders is indeed possible, but the algorithm is a bit more complicated than the current <code>rw</code>. The tricky thing is that the metavariables in the rewrite pattern need to be allowed to depend on the bound variables (which have to be introduced as free variables locally, after those metavariables have already been introduced).</p>\n<p>The proof term requires an extra <code>funext</code> for each bound variable that appears in the rewritten expression, so this doesn't make a big impact on the proof complexity.</p>\n<p>It would probably be hard to convince the core developpers to change the behaviour of <code>rw</code>. On the other hand, making a change to <code>rw</code> that works under <code>import Mathlib</code> could also confuse people. I imagine that option as making a tactic <code>brw</code> (bound rewriting), which is run automatically if <code>rw</code> fails, and only rewrites at expressions containing bound variables.</p>",
        "id": 451369142,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1720977431
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"634338\">Michael Rothgang</span> <a href=\"#narrow/stream/113488-general/topic/Why.20can't.20.60rw.60.20rewrite.20under.20binders.3F/near/451347420\">said</a>:</p>\n<blockquote>\n<p>How difficult would it be to make rw detect \"I'm asked to rewrite under binders\" and provide an error \"sorry Dave, I can't do that; use simp_rw instead\"?</p>\n</blockquote>\n<p>If you can detect unification with bound variables, then I'd say you may as well go all the way and support rewriting them.</p>",
        "id": 451369227,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1720977519
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/113488-general/topic/Why.20can't.20.60rw.60.20rewrite.20under.20binders.3F/near/451347164\">said</a>:</p>\n<blockquote>\n<p><code>simp_rw</code> is able to use functional extensionality, something we probably don't want for a basic tactic like <code>rw</code>.</p>\n</blockquote>\n<p>Why wouldn't you want <code>rw</code> to use <code>funext</code>?</p>",
        "id": 451369336,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1720977638
    },
    {
        "content": "<p>Personally I don't have anything against it, but those axioms aren't even in core, aren't they?</p>",
        "id": 451369463,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1720977789
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"372804\">Marcus Rossel</span> <a href=\"#narrow/stream/113488-general/topic/Why.20can't.20.60rw.60.20rewrite.20under.20binders.3F/near/451344942\">said</a>:</p>\n<blockquote>\n<p>Rewriting under binders requires more sophisticated mechanisms like function extensionality, which in turn requires congruence lemmas, which gets complicated once you have dependent functions.</p>\n</blockquote>\n<p>I didn't need any congruence lemmas for rewriting bound variables.</p>",
        "id": 451369470,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1720977801
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329425\">Peter Nelson</span> <a href=\"#narrow/stream/113488-general/topic/Why.20can't.20.60rw.60.20rewrite.20under.20binders.3F/near/451347124\">said</a>:</p>\n<blockquote>\n<p>what if you only want to apply it exactly once to something inside a binder?</p>\n</blockquote>\n<p>I thought you could use <code>singlePass := true</code> for this, but it seems not to always help:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp_rw</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">config</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">singlePass</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">add_comm</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- still does both</span>\n</code></pre></div>",
        "id": 451369492,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1720977837
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/113488-general/topic/Why.20can't.20.60rw.60.20rewrite.20under.20binders.3F/near/451369463\">said</a>:</p>\n<blockquote>\n<p>Personally I don't have anything against it, but those axioms aren't even in core, aren't they?</p>\n</blockquote>\n<p>funext is in core, otherwise simp could not work under binders.</p>",
        "id": 451369561,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1720977908
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/113488-general/topic/Why.20can't.20.60rw.60.20rewrite.20under.20binders.3F/near/451369463\">said</a>:</p>\n<blockquote>\n<p>Personally I don't have anything against it, but those axioms aren't even in core, aren't they?</p>\n</blockquote>\n<p>Given core forces <code>Classical.choice</code> upon us when splitting <code>if</code>s, I doubt anyone cares about <code>funext</code> (aka, <code>propext</code> and <code>Quotient.sound</code>) being used in other core tactics</p>",
        "id": 451369573,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1720977918
    },
    {
        "content": "<p>Ah ok, I didn't think about that</p>",
        "id": 451369694,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1720978028
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/stream/113488-general/topic/Why.20can't.20.60rw.60.20rewrite.20under.20binders.3F/near/451369470\">said</a>:</p>\n<blockquote>\n<p>I didn't need any congruence lemmas for rewriting bound variables.</p>\n</blockquote>\n<p><span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> How did you do it?</p>",
        "id": 451419299,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1721024516
    },
    {
        "content": "<p>The \"congruence lemmas\" are generated on the fly. If you want to rewrite <code>a = b</code> in <code>⨆ n, a + n = ⨆ n, b + n</code>, Jovan's tactic first shows <code>(fun n ↦ a + n) = fun n ↦ b + n</code> then rewrites with that</p>",
        "id": 451419653,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1721024688
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> Which tactic is \"Jovan's tactic\" (/where does it live)?</p>",
        "id": 451420408,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1721025031
    },
    {
        "content": "<p>To do it without congruence lemmas, you can beta expand to turn your rewrite into a rewrite without bound variables, if you want the rewrite <code>⨆ n, a + n = ⨆ n, n + a</code>,<br>\nmy tactic first shows <code>a + n = n + a</code>. Then by <code>funext</code>, it shows that <code>fun n =&gt; a + n = fun n =&gt; n + a</code>. Then you can do the usual thing to show that <code>⨆ n, (fun n =&gt; a + n) n = ⨆ n, (fun n =&gt; n + a) n</code>,</p>",
        "id": 451420657,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1721025141
    },
    {
        "content": "<p>I have an ordered/directed rewrite tactic, and a normal rewrite tactic that rewrite in a given position (unlike <code>rw</code> which figures out the position itself). The ordered rewrite tactic does use specific congruence lemmas. To find the right rewrite congruence lemma, I used type class search to find it.</p>",
        "id": 451421207,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1721025404
    },
    {
        "content": "<p>Here's where the <a href=\"https://github.com/Human-Oriented-ATP/lean-tactics/blob/main/MotivatedMoves/Moves/TreeRewrite.lean\">rewrite</a> and <a href=\"https://github.com/Human-Oriented-ATP/lean-tactics/blob/main/MotivatedMoves/Moves/TreeRewriteOrd.lean\">ordered rewrite</a> tactics live. I wrote them 1 year ago. However they don't work in Lean out of the box, as we were representing the proofstate in a specific custom way.</p>",
        "id": 451452456,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1721035592
    },
    {
        "content": "<p>This \"expression abstraction\" trick is what <code>generalize_proofs</code> does to pull proofs out from under binders. In some ways that's easier to handle though since you don't have to worry about \"motive not type correct\" due to proof irrelevance (with a small proviso due to Acc.rec reduction I suppose...)</p>",
        "id": 451570676,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1721065623
    },
    {
        "content": "<p>Something I've been wondering is if we can compute a motive for a rewrite in a friendly way, where there's an automated algorithm that can recursively typecheck the motive, replacing subexpressions that it decides are to blame.</p>\n<p>There'd be no \"motive not type correct\" with such an algorithm, at the cost of people wondering why certain rewrites don't seem to be possible.</p>",
        "id": 451571755,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1721065802
    }
]