[
    {
        "content": "<p>Hello! I'm fairly new to lean metaprogramming and I'm looking to make a program that, when given an input theorem in a lean file will extract all dependencies (lemmas, definitions, structures, etc defined in the current file or other packages/files) and output some sort of pointer to said theorem/definition/etc (not an actual pointer, maybe just a file path + start/end coordinate in row/column form, or perhaps the file path and declaration).</p>\n<p>Currently I'm extracting the infotree using something like how this works: <a href=\"https://github.com/semorrison/lean-training-data\">https://github.com/semorrison/lean-training-data</a>. But I'm not sure if any of the <code>tactic_invocations</code> have the data inside them to find where the references are.</p>\n<p>Any advice on what datastructures I should be looking for or how lean stores and handles these references would be really helpful to help me get started on this. Thanks!</p>",
        "id": 465860819,
        "sender_full_name": "Riyaz Ahuja",
        "timestamp": 1724884845
    },
    {
        "content": "<p>If you're happy with just knowing about the constants referenced in the proof term generated by the tactic (but not looking at actual tactic invocations), you will find life much easier using functions such as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.ConstantInfo.getUsedConstantsAsSet#src\">src#Lean.ConstantInfo.getUsedConstantsAsSet</a>. It may also be helpful to read <a href=\"https://github.com/leanprover-community/import-graph/blob/main/ImportGraph/RequiredModules.lean\">https://github.com/leanprover-community/import-graph/blob/main/ImportGraph/RequiredModules.lean</a></p>",
        "id": 465863134,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1724886154
    },
    {
        "content": "<p>As far as I can see, the outputted <code>NameSet</code> doesn't contain any information about which file the reference is from, or what kind of reference it is (type, lemma, etc). For example, with the function:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">dsimp_test</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">h₁</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">mul_zero</span>\n<span class=\"w\">  </span><span class=\"n\">simp_all</span>\n</code></pre></div>\n<p>Outputting the <code>getUsedConstantsAsSet</code> we get something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">[[</span><span class=\"s2\">\"OfNat\"</span><span class=\"o\">,</span><span class=\"s2\">\"ofNat\"</span><span class=\"o\">],</span>\n<span class=\"o\">[</span><span class=\"s2\">\"instAddNat\"</span><span class=\"o\">],</span>\n<span class=\"o\">[</span><span class=\"s2\">\"instHAdd\"</span><span class=\"o\">],</span>\n<span class=\"o\">[</span><span class=\"s2\">\"HAdd\"</span><span class=\"o\">,</span><span class=\"s2\">\"hAdd\"</span><span class=\"o\">],</span>\n<span class=\"o\">[</span><span class=\"s2\">\"True\"</span><span class=\"o\">],</span>\n<span class=\"o\">[</span><span class=\"s2\">\"Nat\"</span><span class=\"o\">,</span><span class=\"s2\">\"mul_zero\"</span><span class=\"o\">],</span>\n<span class=\"o\">[</span><span class=\"s2\">\"Eq\"</span><span class=\"o\">],</span>\n<span class=\"o\">[</span><span class=\"s2\">\"instHMul\"</span><span class=\"o\">],</span>\n<span class=\"o\">[</span><span class=\"s2\">\"Nat\"</span><span class=\"o\">,</span><span class=\"s2\">\"zero_add\"</span><span class=\"o\">],</span>\n<span class=\"o\">[</span><span class=\"s2\">\"eq_true\"</span><span class=\"o\">],</span>\n<span class=\"o\">[</span><span class=\"s2\">\"of_eq_true\"</span><span class=\"o\">],</span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>(truncated...)</p>\n<p>Which matches up mostly with the proof term:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">dsimp_test</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">h₁</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">mul_zero</span><span class=\"bp\">;</span>\n<span class=\"w\">  </span><span class=\"n\">of_eq_true</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">trans</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">congrArg</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x_1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">x_1</span><span class=\"o\">))</span>\n<span class=\"w\">        </span><span class=\"o\">(</span><span class=\"n\">congr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">congrArg</span><span class=\"w\"> </span><span class=\"n\">HAdd</span><span class=\"bp\">.</span><span class=\"n\">hAdd</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">congrArg</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">HAdd</span><span class=\"bp\">.</span><span class=\"n\">hAdd</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">mul_one</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero_add</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)))</span>\n<span class=\"w\">          </span><span class=\"o\">((</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">h₁</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"o\">)))</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">eq_true</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>However, I would like to get some more info about these references, such as what file/module <code>Nat.mul_zero</code> is inside. Is there any way to do this?</p>",
        "id": 465866873,
        "sender_full_name": "Riyaz Ahuja",
        "timestamp": 1724888657
    },
    {
        "content": "<p>There is a function called <code>getModuleFor</code> (approximately) which gives the module name of a constant</p>",
        "id": 465867793,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1724889405
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/ImportGraph/RequiredModules.html#Lean.Environment.getModuleFor\">https://leanprover-community.github.io/mathlib4_docs/ImportGraph/RequiredModules.html#Lean.Environment.getModuleFor</a>?</p>",
        "id": 465867839,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1724889442
    },
    {
        "content": "<p>Thanks that's really useful! Additionally, is there anyway to extract a <code>ConstantInfo</code> from an <code>InfoTree</code>? I'm trying to figure out how to call the <code>getUsedConstantsAsSet</code>.</p>",
        "id": 465896186,
        "sender_full_name": "Riyaz Ahuja",
        "timestamp": 1724904609
    },
    {
        "content": "<p>Or if not from an infotree, then where do I get <code>ConstantInfo</code> from?</p>",
        "id": 465896359,
        "sender_full_name": "Riyaz Ahuja",
        "timestamp": 1724904654
    },
    {
        "content": "<p>It seems that it should come from an <code>Environment</code>, but since I'm given a <code>ModuleName</code>, when I compile it and get a <code>List[CompilationStep]</code>, which I can map to a <code>List[Environment]</code>, If I use these environments to get my <code>ConstantInfo</code>'s, there ends up being millions of items in the associated <code>ConstantMap</code>, which is not reasonable. So I believe I'm using the wrong environment. The question is how do I get the correct environment(s)? Is it through the infotrees?</p>",
        "id": 465911956,
        "sender_full_name": "Riyaz Ahuja",
        "timestamp": 1724910007
    },
    {
        "content": "<p>Millions of items seems reasonable? It's all the constants coming from imported files.</p>",
        "id": 465915078,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1724911581
    },
    {
        "content": "<p>Hm, then is there any way to filter to only constants in the current file? By that I mean for a specific theorem in a specific file, I want to extract out the constants inside that theorem only as a ConstantInfo. Then I can run the aforementioned functions to get the files/lemmas that this theorem depends on.</p>",
        "id": 465915479,
        "sender_full_name": "Riyaz Ahuja",
        "timestamp": 1724911747
    },
    {
        "content": "<p>constants.map\\2 rather than constants.map\\1</p>",
        "id": 465915835,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1724911861
    },
    {
        "content": "<p>That worked, thanks!!<br>\nHowever, it is still very slow (looks like when I'm running env.constants it processes all of the millions of constants through all the imports, and then filtering by map2 just throws out the ones we don't need). Is there any way to speed this up without having to process all the constants?</p>",
        "id": 465918040,
        "sender_full_name": "Riyaz Ahuja",
        "timestamp": 1724912460
    },
    {
        "content": "<p>I'm looking at <a href=\"https://github.com/reaslab/jixia\">Jixia</a> and modified the  <code>Symbol.lean</code> to output from the same functions as you mentioned earlier. However, instead of compiling the module name and converting each of the compilation steps into environments directly, it uses a function:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">getResult</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CommandElabM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">SymbolInfo</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">env</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getEnv</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"n\">info</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">env</span><span class=\"bp\">.</span><span class=\"n\">getModuleIdxFor?</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">isSome</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">si</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">liftTermElabM</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">getSymbolInfo</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"n\">info</span><span class=\"w\"> </span><span class=\"n\">env</span>\n<span class=\"w\">    </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">push</span><span class=\"w\"> </span><span class=\"n\">si</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">env</span><span class=\"bp\">.</span><span class=\"n\">constants</span><span class=\"bp\">.</span><span class=\"n\">map₁</span><span class=\"bp\">.</span><span class=\"n\">foldM</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[]</span>\n<span class=\"w\">  </span><span class=\"n\">env</span><span class=\"bp\">.</span><span class=\"n\">constants</span><span class=\"bp\">.</span><span class=\"n\">map₂</span><span class=\"bp\">.</span><span class=\"n\">foldlM</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>\n<p>Which gives the same output, but way way quicker.</p>",
        "id": 465918762,
        "sender_full_name": "Riyaz Ahuja",
        "timestamp": 1724912622
    },
    {
        "content": "<p>The Jixia code is hard to understand imo and harder to port into my code, as I am unsure how they are accessing the module or getting the environment. For reference, here is my modified <code>getSymbolInfo</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">getSymbolInfo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">info</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ConstantInfo</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">env</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Environment</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">TermElabM</span><span class=\"w\"> </span><span class=\"n\">SymbolInfo</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">temp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NameSet</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">info</span><span class=\"bp\">.</span><span class=\"n\">getUsedConstantsAsSet</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">temp2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">temp</span><span class=\"bp\">.</span><span class=\"n\">toList</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">get_mod</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">temp2</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"n\">env</span><span class=\"bp\">.</span><span class=\"n\">getModuleFor?</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">refs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"bp\">.</span><span class=\"n\">empty</span><span class=\"bp\">.</span><span class=\"n\">insertMany</span><span class=\"w\"> </span><span class=\"n\">get_mod</span>\n\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">refs</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>\n<p>(With <code>SymbolInfo</code> updated accordingly, of course)</p>",
        "id": 465919157,
        "sender_full_name": "Riyaz Ahuja",
        "timestamp": 1724912780
    },
    {
        "content": "<p>Note that the output ends up being essentially the same in either case, but the computation time is significantly less for the modified Jixia version</p>",
        "id": 466061509,
        "sender_full_name": "Riyaz Ahuja",
        "timestamp": 1724948905
    },
    {
        "content": "<p>Hi Riyaz, you may want to check our code in <a href=\"https://github.com/cmu-l3/ntp-toolkit\">cmu-l3/ntp-toolkit</a>. It is based on Kim's <code>lean-training-data</code>. Specifically using the <code>--premises</code> flag seems to do exactly what you want (code in <code>scripts/premises.lean</code>). Extracting mathlib still takes time on the order of ~1h. It is designed to extract everything in each module in a repository. In fact it should be a lot faster if you have one specific module/theorem in mind, or if our engineering pipeline was changed, but that increases engineering difficulty for our other functions.</p>",
        "id": 466129381,
        "sender_full_name": "Thomas Zhu",
        "timestamp": 1724974774
    },
    {
        "content": "<p>I also don't understand why you would get a list of environments from one module name? You can look at how we got the environment in our code; basically</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">CoreM</span><span class=\"bp\">.</span><span class=\"n\">withImportModules</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"bp\">...</span><span class=\"w\"> </span><span class=\"n\">module</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"bp\">...</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">env</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getEnv</span>\n</code></pre></div>",
        "id": 466130001,
        "sender_full_name": "Thomas Zhu",
        "timestamp": 1724975208
    },
    {
        "content": "<p>After every command the environment changes.</p>",
        "id": 466130215,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1724975380
    },
    {
        "content": "<p>Yes, but for extracting premise data, you only need the final environment</p>",
        "id": 466130299,
        "sender_full_name": "Thomas Zhu",
        "timestamp": 1724975420
    },
    {
        "content": "<p>Well, it depends what you mean by “premise data”</p>",
        "id": 466130433,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1724975512
    },
    {
        "content": "<p>I mean a mapping from constant name to names of its dependencies, like what was asked for above</p>",
        "id": 466130856,
        "sender_full_name": "Thomas Zhu",
        "timestamp": 1724975800
    },
    {
        "content": "<p>For that you don’t even need to process things file by file. Just import all of mathlib, get the env, loop through the constants, and look at all used constants for each one. You can filter using <code>isBlacklisted</code> or some variant</p>",
        "id": 466130961,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1724975888
    },
    {
        "content": "<p>I did this a little while ago, and it only takes a few minutes to process</p>",
        "id": 466130992,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1724975920
    },
    {
        "content": "<p>Yes, that's what I wanted to mean by \"if our engineering pipeline was changed\", but thanks for point that out.</p>",
        "id": 466131261,
        "sender_full_name": "Thomas Zhu",
        "timestamp": 1724976070
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"k\">#eval</span><span class=\"w\"> </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"n\">CoreM</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"k\">from</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">env</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getEnv</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">data</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Name</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[]</span>\n<span class=\"w\">  </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">env.constants</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">n.isBlackListed</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">continue</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">cs</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">c.getUsedConstantsAsSet.toList.filterM</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">t.isBlackListed</span>\n<span class=\"w\">      </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">!</span><span class=\"n\">b</span>\n<span class=\"w\">    </span><span class=\"n\">data</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">data.push</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">cs.toArray</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">IO.FS.withFile</span><span class=\"w\"> </span><span class=\"s2\">\"data\"</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">write</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">handle</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"n\">cs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">data</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"n\">handle.putStrLn</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">toString</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"s2\">\" \"</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">toString</span><span class=\"w\"> </span><span class=\"n\">cs</span>\n</code></pre></div>",
        "id": 466131545,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1724976230
    },
    {
        "content": "<p>The output is around 145M</p>",
        "id": 466131680,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1724976293
    },
    {
        "content": "<p>(too big to upload to zulip unfortunately)</p>",
        "id": 466131719,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1724976313
    },
    {
        "content": "<p>Thanks, this is great. Just a minor point, I assume in this way the output might contain constants like <code>._auxLemma.4</code> produced by simp which need additional processing (depending on the needs), and it is dealt with in our code (from Kim Morrison's code)</p>",
        "id": 466132983,
        "sender_full_name": "Thomas Zhu",
        "timestamp": 1724977129
    },
    {
        "content": "<p>Yeah the filter should be a bit better, I agree.</p>",
        "id": 466133676,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1724977582
    },
    {
        "content": "<p>The function <code>Lean.Name.isInternal</code> can be used to filer out constants like <code>._auxLemma.4</code></p>",
        "id": 466148354,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1724986834
    },
    {
        "content": "<p>I'm circling back on this thread as although everyone's help as now let me be able to extract all the important constants/dependencies from a given module, organized by the Name object that has the dependency inside (Thm, def, etc). </p>\n<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> I ended up using a modified version of the ntp-toolkit premises function as shown in <a href=\"https://github.com/riyazahuja/ImProof/blob/main/scripts/constants.lean\">this github</a>.</p>\n<p>However, if you look at how my code outputs, it has outputs in the format of </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">[{</span><span class=\"n\">name</span><span class=\"o\">:</span><span class=\"n\">Name</span><span class=\"o\">,</span>\n<span class=\"n\">dependencies</span><span class=\"o\">:[{</span>\n<span class=\"w\">    </span><span class=\"n\">name</span><span class=\"o\">:</span><span class=\"n\">Name</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">location</span><span class=\"o\">:</span><span class=\"n\">String</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">]</span>\n<span class=\"o\">}]</span>\n</code></pre></div>\n<p>Where the outside Name is the key part of the <code>Env.constants.map₁</code>, and in practice ends up being the name of the theorem we're looking at. </p>\n<p>However, what I'm trying to do is given this <code>Name</code> (and <code>Environment</code> and <code>ConstantInfo</code> as needed) Is there any way to extract the start and end positions (in row,column form) of said theorem (or i suppose it would work equivalently for defs, etc.)? And same thing with each dependency, given the location (module name as a string), can I get the start and end position of the dependency?</p>",
        "id": 468507718,
        "sender_full_name": "Riyaz Ahuja",
        "timestamp": 1725768685
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.findDeclarationRanges%3F#doc\">docs#Lean.findDeclarationRanges?</a> should do what you want</p>",
        "id": 469497586,
        "sender_full_name": "Thomas Zhu",
        "timestamp": 1726084581
    },
    {
        "content": "<p>how does <a href=\"https://github.com/semorrison/lean-training-data\">https://github.com/semorrison/lean-training-data</a> handle pattern matching tactics like cases or induction?</p>",
        "id": 490928550,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1735257722
    },
    {
        "content": "<p>Maybe this should be its own thread or connected to a previous thread in lean-training-data?</p>",
        "id": 490930597,
        "sender_full_name": "Jason Rute",
        "timestamp": 1735259590
    },
    {
        "content": "<p>It is not that hard to run, so you could try it and see.  There is also an example here: <a href=\"https://github.com/kim-em/lean-training-data/tree/master/Examples\">https://github.com/kim-em/lean-training-data/tree/master/Examples</a>. Search for “goalsbefore” to see all the recorded tactics.  (The tactic is the “pp” field.)  You see it records at many levels of depth from the whole proof to the atomic tactics, basically everywhere you can see a goal when hovering over that spot.</p>",
        "id": 490931146,
        "sender_full_name": "Jason Rute",
        "timestamp": 1735260131
    }
]