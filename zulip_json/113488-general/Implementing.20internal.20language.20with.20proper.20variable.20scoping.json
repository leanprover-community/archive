[
    {
        "content": "<p>Are there examples of implementation of an internal language (of a category), especially ones with proper variable bindings? Something along the lines of:</p>\n<ol>\n<li>\n<p>Algebraic theories: write something like <code>x, y, z ⊢ t</code> to build a term <code>t</code> in the context with variables <code>x, y, z</code>. The term <code>t</code> denotes a morphism <code>S × S × S → S</code> where <code>S</code> is the carrier of the algebra (an object in a category with finite limits). For example <code>x, y, z ⊢ y</code> should be the second projection. If we also introduce pairs, then <code>x ⊢ (x,x)</code> has to be the diagonal.</p>\n</li>\n<li>\n<p>Typed λ-calculus as the internal language of a cartesian-closed category (ccc): here the challenge is handling of bound variables. A term <code>x : A ⊢ t : B</code> would denote a morphism <code>A → B</code> where <code>A</code> and <code>B</code> are objects of the underlying ccc.</p>\n</li>\n</ol>\n<p>I am looking for code that will teach me how to humanely handle variable scoping (the <code>x, y, z</code> in the above examples, and bound variables in a λ-calculus). I suspect that this is the job for the elaborator, but I am not sure. It might be the case that I can use parsing to construct a tree representation, and apply an interpretation functions to the tree. However, the tree would have to be valid, so some checking of variable scopes and type-checking needs to occur (so we're back to an elaborator).</p>\n<p>The best I managed to do so far was to use de Bruijn indices for variables, and even there I cheated by interpreting invalid de Bruijn indices in an ad hoc maner. Wasn't there a \"HOTT0\" project along the lines of what I am asking for? Perhaps <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  did some work on it?</p>",
        "id": 488643095,
        "sender_full_name": "Andrej Bauer",
        "timestamp": 1734012931
    },
    {
        "content": "<p>So there is an implementation of the simply-typed λ-calculus at <a href=\"https://github.com/muldrik/lean-stlc/tree/master\">https://github.com/muldrik/lean-stlc/tree/master</a> which uses strings as variable names. I suppose that's not too bad, but one would hope that  Lean would offer some support for variables.</p>",
        "id": 488644600,
        "sender_full_name": "Andrej Bauer",
        "timestamp": 1734013355
    },
    {
        "content": "<p>Unfortunately HoTT-0 isn't yet at the stage where it would have such a tactic. The thing we end up with is also likely to be rather more \"heavyweight\" than you would want for simply interpreting the language of CCCs. I think there has been some discussion about that before but I don't know where it's gone.</p>\n<p>One concrete implementation which gets pretty close to what you want and may be good enough to cargo cult is a <a href=\"https://github.com/digama0/lean4lean/blob/a86111c30d41b6a9af1981bd7da4f18de7aa43cc/Lean4Lean/Theory/Meta.lean#L9-L79\">small tactic</a> I wrote for lean4lean to be able to quote lean terms into the deeply embedded <code>VExpr</code> type used for reasoning about the lean type theory. You give it a typing context and an expression (which is elaborated using lean, so it can e.g. infer types in the expression), like and it returns a literal of the <code>VExpr</code> type. There are a few versions of it, <a href=\"https://github.com/digama0/lean4lean/blob/a86111c30d41b6a9af1981bd7da4f18de7aa43cc/Lean4Lean/Theory/Quot.lean#L11\">here</a> is an example use to define lean's quotient definitional equality rule</p>",
        "id": 488645992,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1734013677
    },
    {
        "content": "<p>cc: <span class=\"user-mention\" data-user-id=\"128280\">@Wojciech Nawrocki</span> who has also thought a lot about this kind of thing</p>",
        "id": 488646726,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1734013871
    },
    {
        "content": "<p>Another (rather elaborate) example of this is the <code>Qq</code> library, which builds a custom context within which to elaborate lean terms, then post-processes the result to produce typed <code>Expr</code> terms</p>",
        "id": 488647783,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1734014180
    },
    {
        "content": "<p>As long as the internal language is a subset of lean (possibly extended with axiomatic constants), the nicest approach here is likely to set up a custom context, elaborate the body as plain lean syntax, then postprocess the result to translate it into your internal language and ensure nothing outside the subset is accepted.</p>",
        "id": 488648175,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1734014286
    },
    {
        "content": "<p>I have a toy embedding of STLC (with a nice elaborator) <a href=\"https://github.com/JLimperg/internal-language/blob/main/InternalLanguage.lean\">here</a> in case that helps.</p>",
        "id": 488703605,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1734031654
    },
    {
        "content": "<p>Examples are at the bottom of that file. Some of them fail to typecheck, in which case you get a compile-time error.</p>",
        "id": 488703885,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1734031775
    }
]