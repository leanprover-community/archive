[
    {
        "content": "<p>Hi all, I implemented the Miller–Rabin primality test, and proved that the Miller–Rabin primality test on composite n is correct to 3/4 of the bases. Here is my code: <a href=\"https://github.com/hanwenzhu/primality-tests\">https://github.com/hanwenzhu/primality-tests</a></p>\n<p>Main results:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Fast modular exponentiation, tail recursive -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">pow</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ZMod</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ZMod</span> <span class=\"n\">n</span>\n\n<span class=\"sd\">/-- `n` is a *Fermat probable prime* to base `a` if `a ^ (n - 1) = 1`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">FPP</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ZMod</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"n\">a</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">FPP.Carmichael</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ZMod</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">ˣ</span><span class=\"o\">,</span> <span class=\"n\">FPP</span> <span class=\"n\">n</span> <span class=\"n\">a</span>\n\n<span class=\"sd\">/-- `n` is a *strong probable prime* to base `a`, if `a ^ d = 1` or `a ^ (2^s * d) = -1`, where</span>\n<span class=\"sd\">`d` is odd, `s &lt; s'`, and `s'` is such that `n - 1 = 2^s' * d`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">SPP</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ZMod</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"n\">a</span> <span class=\"bp\">^</span> <span class=\"n\">oddPart</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">∨</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"bp\">&lt;</span> <span class=\"n\">val₂</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">a</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"n\">s</span> <span class=\"bp\">*</span> <span class=\"n\">oddPart</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"mi\">1</span>\n\n<span class=\"sd\">/-- A prime is a strong probable prime to any nonzero base. -/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">SPP.of_prime</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fact</span> <span class=\"n\">p.Prime</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ZMod</span> <span class=\"n\">p</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">SPP</span> <span class=\"n\">p</span> <span class=\"n\">a</span>\n\n<span class=\"sd\">/-- The proportion of Miller–Rabin nonwitnesses of composite `n` is at most 1/4. -/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">SPP.card_SPP_of_not_prime</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fact</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">≥</span> <span class=\"mi\">2</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">ho</span> <span class=\"o\">:</span> <span class=\"n\">Odd</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hnp</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">n.Prime</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">Fintype.card</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"bp\">//</span> <span class=\"n\">SPP</span> <span class=\"n\">n</span> <span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"bp\">*</span> <span class=\"mi\">4</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span>\n\n<span class=\"sd\">/-- The *Miller–Rabin* primality test on input `n`, run `r` times. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">millerRabin</span> <span class=\"o\">{</span><span class=\"n\">gen</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">RandomGen</span> <span class=\"n\">gen</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">gen</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"bp\">×</span> <span class=\"n\">gen</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">runMillerRabin</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Bool</span>\n</code></pre></div>\n<p>Also IMO there are one or two results in <code>PrimalityTests/Lemmas.lean</code> that should be in mathlib.</p>\n<p>I really hope to extend this:</p>\n<ol>\n<li>Show <code>millerRabin g n r</code> is correct to a probability arbitrarily close to 1 exponentially in <code>r</code>, assuming the random number generator <code>g</code> is random enough. This is already immediate conceptually from existing results, though is very tricky to formulate (integrating measure-theoretic probability with <code>RandomGen</code>, potentially; I don't have a clear idea). This will be helpful to eventually implementing some cryptography algorithms in Lean efficiently <em>and</em> proving their soundness</li>\n<li>Verifying primality certificates so we can use large primes in math proofs (like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=lucas_primality#doc\">docs#lucas_primality</a>)</li>\n<li>Implement other probabilistic primality tests (like Baillie–PSW)</li>\n</ol>\n<p>Suggestions/PRs are very welcome! I hope some would find this work useful.</p>\n<p>There was a previous <a href=\"https://github.com/leanprover-community/mathlib/tree/miller-rabin\">attempt</a> to implement Miller–Rabin, but the proof is very incomplete AFAIK. There was also a <a href=\"#narrow/stream/113488-general/topic/Verifying.20a.20deterministic.20algorithm/near/192793709\">discussion</a> on formalizing the correctness of probabilistic algorithms, though that was even before <code>Random</code></p>",
        "id": 408543899,
        "sender_full_name": "Thomas Zhu",
        "timestamp": 1702882473
    },
    {
        "content": "<p>Completely stupid question: can this code be compiled and run, so you can test if a number like 561 is prime or not?</p>",
        "id": 408565379,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1702890471
    },
    {
        "content": "<p>Yes you can compile the code: <a href=\"https://github.com/hanwenzhu/primality-tests/blob/main/PrimalityTests/MillerRabin.lean#L9\">https://github.com/hanwenzhu/primality-tests/blob/main/PrimalityTests/MillerRabin.lean#L9</a></p>\n<p>But keep in mind its only a probability based test so it's not like we could integrate this as a decision procedure that ships with a proof that something is a prime. <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span></p>",
        "id": 408565754,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1702890605
    },
    {
        "content": "<p>And what happens if you try with a ten digit number? Is it instant or does it take forever?</p>",
        "id": 408565996,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1702890710
    },
    {
        "content": "<p>But it's still a pretty good test, in computer science we use it to get primes for asymmetric encryptions on numbers between 2k and 4k bits so numbers that look like this: 13182040934309431001038897942365913631840191610932727690928034502417569281128344551079752123172122033140940756480716823038446817694240581281731062452512184038544674444386888956328970642771993930036586552924249514488832183389415832375620009284922608946111038578754077913265440918583125586050431647284603636490823850007826811672468900210689104488089485347192152708820119765006125944858397761874669301278745233504796586994514054435217053803732703240283400815926169348364799472716094576894007243168662568886603065832486830606125017643356469732407252874567217733694824236675323341755681839221954693820456072020253884371226826844858636194212875139566587445390068014747975813971748114770439248826688667129237954128555841874460665729630492658600179338272579110020881228767361200603478973120168893997574353727653998969223092798255701666067972698906236921628764772837915526086464389161570534616956703744840502975279094087587298968423516531626090898389351449020056851221079048966718878943309232071978575639877208621237040940126912767610658141079378758043403611425454744180577150855204937163460902512732551260539639221457005977247266676344018155647509515396711351487546062479444592779055555421362722504575706910949376.</p>",
        "id": 408566024,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1702890719
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/Miller.E2.80.93Rabin.20Primality.20Test/near/408565996\">said</a>:</p>\n<blockquote>\n<p>And what happens if you try with a ten digit number? Is it instant or does it take forever?</p>\n</blockquote>\n<p>I guess that answers the question :P although I am not sure how good the implementation above is but it is very much a practical thing that your computer can do with a good implementation</p>",
        "id": 408566119,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1702890746
    },
    {
        "content": "<p>It can deterministically say a number is composite however.</p>",
        "id": 408566777,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1702890978
    },
    {
        "content": "<p>Nice! Long ago, I asked an undergrad REU student to prove that the Miller-Rabin witnesses become equidistributed for large composite <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> (an observation which I couldn't find in the literature, though I doubted it was original to me?). Could be a fun project to formalize? <a href=\"https://arxiv.org/pdf/1608.07317.pdf\">https://arxiv.org/pdf/1608.07317.pdf</a></p>",
        "id": 408622640,
        "sender_full_name": "Alex Kontorovich",
        "timestamp": 1702909679
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/113488-general/topic/Miller.E2.80.93Rabin.20Primality.20Test/near/408566119\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/Miller.E2.80.93Rabin.20Primality.20Test/near/408565996\">said</a>:</p>\n<blockquote>\n<p>And what happens if you try with a ten digit number? Is it instant or does it take forever?</p>\n</blockquote>\n<p>I guess that answers the question :P although I am not sure how good the implementation above is but it is very much a practical thing that your computer can do with a good implementation</p>\n</blockquote>\n<p>Yes I'm well aware of that! What I am asking is whether <span class=\"user-mention\" data-user-id=\"631691\">@Thomas Zhu</span> 's implementation can deal with numbers this large (although I started smaller than you :-) )</p>",
        "id": 408631270,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1702912365
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/Miller.E2.80.93Rabin.20Primality.20Test/near/408565996\">said</a>:</p>\n<blockquote>\n<p>And what happens if you try with a ten digit number? Is it instant or does it take forever?</p>\n</blockquote>\n<p>To answer your question: it tests this number in under a second on my computer<br>\n<a href=\"/user_uploads/3121/I6b1JZxjpAHYOk-lk9rVXRyO/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/I6b1JZxjpAHYOk-lk9rVXRyO/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/I6b1JZxjpAHYOk-lk9rVXRyO/image.png\"></a></div>",
        "id": 408640856,
        "sender_full_name": "Thomas Zhu",
        "timestamp": 1702915337
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284160\">Eric Rodriguez</span> <a href=\"#narrow/stream/113488-general/topic/Miller.E2.80.93Rabin.20Primality.20Test/near/408566777\">said</a>:</p>\n<blockquote>\n<p>It can deterministically say a number is composite however.</p>\n</blockquote>\n<p>Yes, essentially one would obtain a compositeness proof from the contrapositive of <code>SPP.of_prime</code>, and for most large composite numbers checking to one or a few bases already suffices</p>",
        "id": 408643868,
        "sender_full_name": "Thomas Zhu",
        "timestamp": 1702916261
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"252920\">Alex Kontorovich</span> <a href=\"#narrow/stream/113488-general/topic/Miller.E2.80.93Rabin.20Primality.20Test/near/408622640\">said</a>:</p>\n<blockquote>\n<p>Nice! Long ago, I asked an undergrad REU student to prove that the Miller-Rabin witnesses become equidistributed for large composite <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> (an observation which I couldn't find in the literature, though I doubted it was original to me?). Could be a fun project to formalize? <a href=\"https://arxiv.org/pdf/1608.07317.pdf\">https://arxiv.org/pdf/1608.07317.pdf</a></p>\n</blockquote>\n<p>This could be a good project to formalize indeed!</p>",
        "id": 408645975,
        "sender_full_name": "Thomas Zhu",
        "timestamp": 1702916879
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"631691\">Thomas Zhu</span> <a href=\"#narrow/stream/113488-general/topic/Miller.E2.80.93Rabin.20Primality.20Test/near/408640856\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/Miller.E2.80.93Rabin.20Primality.20Test/near/408565996\">said</a>:</p>\n<blockquote>\n<p>And what happens if you try with a ten digit number? Is it instant or does it take forever?</p>\n</blockquote>\n<p>To answer your question: it tests this number in under a second on my computer<br>\n<a href=\"/user_uploads/3121/I6b1JZxjpAHYOk-lk9rVXRyO/image.png\">image.png</a></p>\n</blockquote>\n<p>Just out of curiosity: Could you maybe take a prime from some RSA private key and try to factorize that at the same certainty as the C code that generates them (idk how many rounds they do?) does?</p>",
        "id": 408667263,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1702924495
    },
    {
        "content": "<p>Wait, C code doesn't <em>only</em> generates primes to a provided certainty. It eventually uses a deterministic check to verify they are prime. Or do you mean, the level of certainty from Miller-Rabin <em>prior</em> to doing a deterministic check?</p>",
        "id": 408670050,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1702925742
    },
    {
        "content": "<p>Yeah in general to the degree that C code does use miller rabin, to see if its somewhat competetive in terms of speed</p>",
        "id": 408670748,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1702926029
    },
    {
        "content": "<p>Last I checked, RSA key generation in OpenSSH doesn't check primality using a deterministic test, just Miller-Rabin.</p>",
        "id": 408670815,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1702926054
    },
    {
        "content": "<p>Well then someone should probably also figure that out lol.</p>",
        "id": 408670970,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1702926103
    },
    {
        "content": "<p>Yeah, only using Miller-Rabin is pretty standard I think. Keep in mind that RSA is <em>much</em> older than the first deterministic poly-time algorithm for primality testing!</p>",
        "id": 408678971,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1702929574
    },
    {
        "content": "<p>Well, <em>PRIMES is in P</em> is only from 2004, but there was a deterministic algorithm which runs in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><msup><mo stretchy=\"false\">)</mo><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>log</mi><mo>⁡</mo><mi>log</mi><mo>⁡</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow></msup></mrow><annotation encoding=\"application/x-tex\">(\\log n)^{O(\\log \\log \\log n)}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.138em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.888em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen mtight\">(</span><span class=\"mop mtight\"><span class=\"mtight\">l</span><span class=\"mtight\">o</span><span class=\"mtight\" style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace mtight\" style=\"margin-right:0.1952em;\"></span><span class=\"mop mtight\"><span class=\"mtight\">l</span><span class=\"mtight\">o</span><span class=\"mtight\" style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace mtight\" style=\"margin-right:0.1952em;\"></span><span class=\"mop mtight\"><span class=\"mtight\">l</span><span class=\"mtight\">o</span><span class=\"mtight\" style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace mtight\" style=\"margin-right:0.1952em;\"></span><span class=\"mord mathnormal mtight\">n</span><span class=\"mclose mtight\">)</span></span></span></span></span></span></span></span></span></span></span></span> from 1983, so well before open ssh, and (I think) is suitable for use for modern key sizes.</p>",
        "id": 408681931,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1702930881
    },
    {
        "content": "<p>I thought AKS was super slow in practice?</p>",
        "id": 408682537,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1702931163
    },
    {
        "content": "<p>I think they got it down to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><msup><mo stretchy=\"false\">)</mo><mn>6</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O((\\log n)^6)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">((</span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">6</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>?</p>",
        "id": 408683093,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1702931413
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/113488-general/topic/Miller.E2.80.93Rabin.20Primality.20Test/near/408667263\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"631691\">Thomas Zhu</span> <a href=\"#narrow/stream/113488-general/topic/Miller.E2.80.93Rabin.20Primality.20Test/near/408640856\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/Miller.E2.80.93Rabin.20Primality.20Test/near/408565996\">said</a>:</p>\n<blockquote>\n<p>And what happens if you try with a ten digit number? Is it instant or does it take forever?</p>\n</blockquote>\n<p>To answer your question: it tests this number in under a second on my computer<br>\n<a href=\"/user_uploads/3121/I6b1JZxjpAHYOk-lk9rVXRyO/image.png\">image.png</a></p>\n</blockquote>\n<p>Just out of curiosity: Could you maybe take a prime from some RSA private key and try to factorize that at the same certainty as the C code that generates them (idk how many rounds they do?) does?</p>\n</blockquote>\n<p>It would be interesting to compare the speed, though I suspect Lean would be slower in CPU time — I can try to do that at some time</p>",
        "id": 408683145,
        "sender_full_name": "Thomas Zhu",
        "timestamp": 1702931454
    },
    {
        "content": "<p>There are some deterministic primality test that are faster than AKS in practice, but they are much more complex than Miller-Rabin.</p>",
        "id": 408683666,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1702931731
    },
    {
        "content": "<p>When I implemented Miller Rabin (on <code>leanprover/lean4:nightly-2023-06-10</code> <span aria-label=\"fear\" class=\"emoji emoji-1f628\" role=\"img\" title=\"fear\">:fear:</span> ) I brute force iterated for witnesses for a 13 digit number to get make speed comparisons more pronounced. I was pleased to see that the binary performed as well as the Go version I made while teaching cryptography last year. </p>\n<p>As a plus for backward compatibility, <code>elan</code> just pulled that toolchain fine and then still just worked.</p>",
        "id": 408683797,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1702931778
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"284160\">@Eric Rodriguez</span>  Yes, I think AKS is still too slow to be useful. I'm just saying that I think we've had stuff that's fast enough for a while. (But maybe I'm wrong; I'm no cryptographer!)</p>",
        "id": 408684757,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1702932351
    },
    {
        "content": "<p>Speaking of benchmarking, I would love to see Lean <a href=\"https://benchmarksgame-team.pages.debian.net/benchmarksgame/index.html\">here</a></p>",
        "id": 408684922,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1702932419
    },
    {
        "content": "<p>By the way, I think <a href=\"https://github.com/leanprover-community/mathlib4/pull/8885\">#8885</a> should make the fast modular exponentiation above unnecessary. (Or rather, it already implements it)</p>",
        "id": 408685102,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1702932501
    },
    {
        "content": "<p>AKS is not used in practice at all AFAIK, it is much slower than BPSW for less than 2^64 in which BPSW was shown to be correct, and for larger than that AKS is already getting prohibitive. Other methods like ECPP is not shown to by poly-time, but in practice much faster. I think if you need a large prime in a math proof, you can also just use an external ECPP to generate a primality certificate, and then verify that in Lean, similar to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=lucas_primality#doc\">docs#lucas_primality</a></p>",
        "id": 408685590,
        "sender_full_name": "Thomas Zhu",
        "timestamp": 1702932723
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/113488-general/topic/Miller.E2.80.93Rabin.20Primality.20Test/near/408685102\">said</a>:</p>\n<blockquote>\n<p>By the way, I think <a href=\"https://github.com/leanprover-community/mathlib4/pull/8885\">#8885</a> should make the fast modular exponentiation above unnecessary. (Or rather, it already implements it)</p>\n</blockquote>\n<p>Thanks! I was not aware of that. Indeed it implements the modular exponentiation above</p>",
        "id": 408685646,
        "sender_full_name": "Thomas Zhu",
        "timestamp": 1702932739
    },
    {
        "content": "<p>In practice you can easily run Miller–Rabin say 100 times, so you at least have a 4^-100 confidence, which is already much lower than probability of a hardware failure. This is certainly good enough for cryptography, but it doesn't produce a proof of <code>n.Prime</code></p>",
        "id": 408686880,
        "sender_full_name": "Thomas Zhu",
        "timestamp": 1702933265
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"631691\">Thomas Zhu</span> <a href=\"#narrow/stream/113488-general/topic/Miller.E2.80.93Rabin.20Primality.20Test/near/408686880\">said</a>:</p>\n<blockquote>\n<p>In practice you can easily run Miller–Rabin say 100 times, so you at least have a 4^-100 confidence, which is already much lower than probability of a hardware failure. This is certainly good enough for cryptography, but it doesn't produce a proof of <code>n.Prime</code></p>\n</blockquote>\n<p>This is a problem that has been pretty frustrating to me in the past. I think it would be cool if we could avoid it by introducing a new axiom to derandomize specific tests like this.</p>",
        "id": 408687558,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1702933477
    },
    {
        "content": "<p>Some discussion on this happened around <a href=\"#narrow/stream/113488-general/topic/Probability.20projects/near/388593903\">here</a></p>",
        "id": 408687665,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1702933542
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/113488-general/topic/Miller.E2.80.93Rabin.20Primality.20Test/near/408685102\">said</a>:</p>\n<blockquote>\n<p>By the way, I think <a href=\"https://github.com/leanprover-community/mathlib4/pull/8885\">#8885</a> should make the fast modular exponentiation above unnecessary. (Or rather, it already implements it)</p>\n</blockquote>\n<p>I was going to make something similar after <a href=\"https://github.com/leanprover/std4/pull/314\">std4#314</a>.</p>",
        "id": 408688627,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1702934007
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"282271\">Bolton Bailey</span> <a href=\"#narrow/stream/113488-general/topic/Miller.E2.80.93Rabin.20Primality.20Test/near/408687558\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"631691\">Thomas Zhu</span> <a href=\"#narrow/stream/113488-general/topic/Miller.E2.80.93Rabin.20Primality.20Test/near/408686880\">said</a>:</p>\n<blockquote>\n<p>In practice you can easily run Miller–Rabin say 100 times, so you at least have a 4^-100 confidence, which is already much lower than probability of a hardware failure. This is certainly good enough for cryptography, but it doesn't produce a proof of <code>n.Prime</code></p>\n</blockquote>\n<p>This is a problem that has been pretty frustrating to me in the past. I think it would be cool if we could avoid it by introducing a new axiom to derandomize specific tests like this.</p>\n</blockquote>\n<p>It would be very cool to do so, but I'm not sure how to set up this axiom. Maybe it has to state that <code>StdGen</code> (or some more random generator) is random enough, but then one might be able to craft counterexamples by engineering on the seed or something, and then derive falsehood. Another way is to argue that some pseudorandom generators are indistinguishable from true uniform in poly-time, then prove MR is somehow correct against poly-time attacks, but I don't know enough about cryptography to comment on how to do that, and it would be more for cryptography than for use in math</p>",
        "id": 408689496,
        "sender_full_name": "Thomas Zhu",
        "timestamp": 1702934444
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"455791\">Yuyang Zhao</span> <a href=\"#narrow/stream/113488-general/topic/Miller.E2.80.93Rabin.20Primality.20Test/near/408688627\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/113488-general/topic/Miller.E2.80.93Rabin.20Primality.20Test/near/408685102\">said</a>:</p>\n<blockquote>\n<p>By the way, I think <a href=\"https://github.com/leanprover-community/mathlib4/pull/8885\">#8885</a> should make the fast modular exponentiation above unnecessary. (Or rather, it already implements it)</p>\n</blockquote>\n<p>I was going to make something similar after <a href=\"https://github.com/leanprover/std4/pull/314\">std4#314</a>.</p>\n</blockquote>\n<p>Cool! Given the number of divisions by 2 and parity tests in modular exponentiation and Miller–Rabin, I think divisions and parity tests based on bit manipulations would be faster</p>",
        "id": 408690250,
        "sender_full_name": "Thomas Zhu",
        "timestamp": 1702934915
    },
    {
        "content": "<p>Currently <code>Nat.binaryRec</code> in my PR is implemented via <code>· &gt;&gt;&gt; 1</code> and <code>1 &amp;&amp;&amp; ·</code>. If Lean has a efficient <code>Nat.testBit</code> I think it could be faster. (I didn't check if GMP bignum supports it.)</p>",
        "id": 408690887,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1702936093
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"631691\">Thomas Zhu</span> <a href=\"#narrow/stream/113488-general/topic/Miller.E2.80.93Rabin.20Primality.20Test/near/408689496\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"282271\">Bolton Bailey</span> <a href=\"#narrow/stream/113488-general/topic/Miller.E2.80.93Rabin.20Primality.20Test/near/408687558\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"631691\">Thomas Zhu</span> <a href=\"#narrow/stream/113488-general/topic/Miller.E2.80.93Rabin.20Primality.20Test/near/408686880\">said</a>:</p>\n<blockquote>\n<p>In practice you can easily run Miller–Rabin say 100 times, so you at least have a 4^-100 confidence, which is already much lower than probability of a hardware failure. This is certainly good enough for cryptography, but it doesn't produce a proof of <code>n.Prime</code></p>\n</blockquote>\n<p>This is a problem that has been pretty frustrating to me in the past. I think it would be cool if we could avoid it by introducing a new axiom to derandomize specific tests like this.</p>\n</blockquote>\n<p>It would be very cool to do so, but I'm not sure how to set up this axiom. Maybe it has to state that <code>StdGen</code> (or some more random generator) is random enough, but then one might be able to craft counterexamples by engineering on the seed or something, and then derive falsehood. Another way is to argue that some pseudorandom generators are indistinguishable from true uniform in poly-time, then prove MR is somehow correct against poly-time attacks, but I don't know enough about cryptography to comment on how to do that, and it would be more for cryptography than for use in math</p>\n</blockquote>\n<p>Cryptography is indeed exactly what I am thinking of using here, and it's in cryptography where I have mainly seen the need for formally certified primes. There are also some <a href=\"#narrow/stream/113488-general/topic/proof.20by.20example/near/262756606\">applications in math</a>, but they seem to be more rare.</p>",
        "id": 408695867,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1702939063
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"282271\">@Bolton Bailey</span> I think this is quite an interesting. Do you have in mind an exact formulation of the axiom? And how would you state \"n is probably a prime\" in lean?</p>",
        "id": 408698135,
        "sender_full_name": "Thomas Zhu",
        "timestamp": 1702940390
    },
    {
        "content": "<p>Here is a relatively simple version of something adapted from a draft I have been working on, <code>H</code> is meant to be a cryptographic pseudorandomness generator</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">axiom</span> <span class=\"n\">probabilistic_miller_rabin</span>\n  <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">Finset.range</span> <span class=\"mi\">256</span><span class=\"o\">,</span> <span class=\"n\">not_miller_rabin_compositeness_witness</span> <span class=\"n\">p</span> <span class=\"o\">((</span><span class=\"n\">H</span> <span class=\"n\">p</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">%</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">p.Prime</span>\n</code></pre></div>",
        "id": 408699713,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1702941012
    },
    {
        "content": "<p>There are a variety of small issues with this approach, some of which can be fixed, and some not. For example, maybe <code>H</code> will have some structure that lets you prove this axiom is false, potentially without even explicitly determining what value of p it's false for.</p>",
        "id": 408700379,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1702941370
    },
    {
        "content": "<p>But if you come up with a bit of a more rigorous version, like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">axiom</span> <span class=\"n\">probabilistic_miller_rabin</span>\n  <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">2</span><span class=\"bp\">^</span><span class=\"mi\">2048</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">Finset.range</span> <span class=\"mi\">2048</span><span class=\"o\">,</span> <span class=\"n\">not_miller_rabin_compositeness_witness</span> <span class=\"n\">p</span> <span class=\"o\">((</span><span class=\"n\">SHA3</span> <span class=\"o\">(</span><span class=\"n\">outputbits</span><span class=\"o\">:=</span> <span class=\"mi\">2048</span><span class=\"o\">)</span> <span class=\"n\">p</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">%</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">p.Prime</span>\n</code></pre></div>\n<p>You can get something which seems very plausibly true, and also lets you resolve primality goals.</p>",
        "id": 408700642,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1702941516
    },
    {
        "content": "<p>The first axiom is surely definitely false, you'll surely be able to use the Chinese remainder theorem and quadratic reciprocity to find some absolutely gigantic counterexample whatever your choice of H (if something like this were true then it would be an extremely efficient test for primality). The second might be true but it might be the case that to check it you'll just have to do the brute force calculation which is of course completely unfeasable, you may as well just list all the primes less than 2^2048 and then do a look up :-)</p>",
        "id": 408701863,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1702942058
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/Miller.E2.80.93Rabin.20Primality.20Test/near/408701863\">said</a>:</p>\n<blockquote>\n<p>The first axiom is surely definitely false, you'll surely be able to use the Chinese remainder theorem and quadratic reciprocity to find some absolutely gigantic counterexample whatever your choice of H (if something like this were true then it would be an extremely efficient test for primality). The second might be true but it might be the case that to check it you'll just have to do the brute force calculation which is of course completely unfeasable, you may as well just list all the primes less than 2^2048 and then do a look up :-)</p>\n</blockquote>\n<p>Wait, are you saying you could prove the first one is false for SHA3? I can definitely think of at least one example of a (of course relatively inefficient) H for which it's not false, namely, an <code>H</code> that deterministically checks if <code>p</code> is prime, and then finds only examples of witnesses that confirm that fact.</p>",
        "id": 408702126,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1702942203
    },
    {
        "content": "<p>I was thinking the axiom wasn't going to be so specific but instead something like \"if P(event) &lt; 10^-100 then ¬event\"</p>",
        "id": 408702240,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1702942238
    },
    {
        "content": "<p>I agree that it is almost definitely false for SHA3, but I'm not sure it could be proved. For a non-cryptographic PRNG, maybe there could be a number-theoretic proof it's false.</p>",
        "id": 408702299,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1702942280
    },
    {
        "content": "<p>Hmm, I was thinking more like proving that if <code>H</code> is a (<a href=\"https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator\">random enough</a>) pseudorandom number generator, then there is no efficient (maybe poly-time) algorithm to produce counterexamples to Miller–Rabin</p>",
        "id": 408702321,
        "sender_full_name": "Thomas Zhu",
        "timestamp": 1702942296
    },
    {
        "content": "<p>For large prime <code>p</code>, I don't actually think you need axioms to show <code>p.Prime</code>, since you can get away with good deterministic primality tests that generate certificates that can be checked in Lean. But this might have applications for other probabilistic tests</p>",
        "id": 408702473,
        "sender_full_name": "Thomas Zhu",
        "timestamp": 1702942373
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"282271\">@Bolton Bailey</span> your first axiom has no bounds on p. I don't know what SHA3 is but I know that there are infinitely many composite numbers.</p>",
        "id": 408702791,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1702942545
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"631691\">Thomas Zhu</span> <a href=\"#narrow/stream/113488-general/topic/Miller.E2.80.93Rabin.20Primality.20Test/near/408702473\">said</a>:</p>\n<blockquote>\n<p>For large prime <code>p</code>, I don't actually think you need axioms to show <code>p.Prime</code>, since you can get away with good deterministic primality tests that generate certificates that can be checked in Lean. But this might have applications for other probabilistic tests</p>\n</blockquote>\n<p>What deterministic primality certificate generator are you think of and what is it's time complexity? When I was reviewing this the best I could find were elliptic curve-based tests that were slower than Miller-Rabin.</p>",
        "id": 408702807,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1702942552
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"282271\">Bolton Bailey</span> <a href=\"#narrow/stream/113488-general/topic/Miller.E2.80.93Rabin.20Primality.20Test/near/408702807\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"631691\">Thomas Zhu</span> <a href=\"#narrow/stream/113488-general/topic/Miller.E2.80.93Rabin.20Primality.20Test/near/408702473\">said</a>:</p>\n<blockquote>\n<p>For large prime <code>p</code>, I don't actually think you need axioms to show <code>p.Prime</code>, since you can get away with good deterministic primality tests that generate certificates that can be checked in Lean. But this might have applications for other probabilistic tests</p>\n</blockquote>\n<p>What deterministic primality certificate generator are you think of and what is it's time complexity? When I was reviewing this the best I could find were elliptic curve-based tests that were slower than Miller-Rabin.</p>\n</blockquote>\n<p>I think elliptic curve-based tests are good enough. It's not proven to be polynomial but in practice acts polynomially. I'm not sure how large are the primes people want to prove <code>Nat.Prime</code> holds (maybe in number theory) but it's probably something ECPP can still handle?</p>",
        "id": 408703401,
        "sender_full_name": "Thomas Zhu",
        "timestamp": 1702942834
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/Miller.E2.80.93Rabin.20Primality.20Test/near/408702791\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"282271\">Bolton Bailey</span> your first axiom has no bounds on p. I don't know what SHA3 is but I know that there are infinitely many composite numbers.</p>\n</blockquote>\n<p>I am not sure what quadratic reciprocity can do to help us analyze SHA3 here.</p>",
        "id": 408703686,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1702942986
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"631691\">Thomas Zhu</span> <a href=\"#narrow/stream/113488-general/topic/Miller.E2.80.93Rabin.20Primality.20Test/near/408703401\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"282271\">Bolton Bailey</span> <a href=\"#narrow/stream/113488-general/topic/Miller.E2.80.93Rabin.20Primality.20Test/near/408702807\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"631691\">Thomas Zhu</span> <a href=\"#narrow/stream/113488-general/topic/Miller.E2.80.93Rabin.20Primality.20Test/near/408702473\">said</a>:</p>\n<blockquote>\n<p>For large prime <code>p</code>, I don't actually think you need axioms to show <code>p.Prime</code>, since you can get away with good deterministic primality tests that generate certificates that can be checked in Lean. But this might have applications for other probabilistic tests</p>\n</blockquote>\n<p>What deterministic primality certificate generator are you think of and what is it's time complexity? When I was reviewing this the best I could find were elliptic curve-based tests that were slower than Miller-Rabin.</p>\n</blockquote>\n<p>I think elliptic curve-based tests are good enough. It's not proven to be polynomial but in practice acts polynomially. I'm not sure how large are the primes people want to prove <code>Nat.Prime</code> holds (maybe in number theory) but it's probably something ECPP can still handle?</p>\n</blockquote>\n<p>I take your point. I guess what I am riding on here is that as long as there is some gap in complexity between the deterministic and randomized tests, then there is some size of prime and some amount of compute for which you can carry out the proof with Miller-Rabin, but not any deterministic method.</p>",
        "id": 408703890,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1702943083
    },
    {
        "content": "<p>Yes, there are definitely primes too large for deterministic tests but ok for MR, but I'm not sure when that's needed: if you're doing cryptography, you are most likely using MR anyway (and using many probabilistic things elsewhere), and if you're proving something in number theory that needs a huge prime, it's still usually manageable with ECPP</p>",
        "id": 408704763,
        "sender_full_name": "Thomas Zhu",
        "timestamp": 1702943570
    },
    {
        "content": "<p>I might be wrong though - do people actually need very large primes that can only be shown probabilistically outside of cryptography?</p>",
        "id": 408705370,
        "sender_full_name": "Thomas Zhu",
        "timestamp": 1702943900
    },
    {
        "content": "<p>I guess the only thing I know about is this Helfgott proof of the odd Goldbach conjecture, where he had to prove numbers on the order of 10^27 were prime, but didn't need to prove <em>specific</em> number prime, so he could use certificates that were much more efficient.</p>",
        "id": 408705409,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1702943928
    },
    {
        "content": "<p>I am also curious about potential number theory applications - when/do number theorists have to prove specific large numbers are prime, and how large are they?</p>",
        "id": 408705471,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1702943969
    },
    {
        "content": "<p>Incidentally, Kevin's comment has gotten me curious: Is it true/known that the sum over composite n from n = 1 to infinity of the fraction of k &lt; n  that are non Miller-Rabin witnesses diverges? Or if that sequence when raised to the power of 256/ some other value diverges?</p>",
        "id": 408706071,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1702944170
    },
    {
        "content": "<p>If not, I am suddenly not even sure that the first version of the axiom even <em>is</em> false.</p>",
        "id": 408706370,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1702944274
    },
    {
        "content": "<p>There is probably an answer to this specific question, since the fraction of MR witnesses is well studied I would imagine</p>",
        "id": 408706590,
        "sender_full_name": "Thomas Zhu",
        "timestamp": 1702944379
    },
    {
        "content": "<p><del>I know that 3/4 is only achieved for very specific composites, I think composites of the form <code>p * (2p + 1)</code> for prime <code>p</code>.</del><br>\nIt's <code>p * (2p - 1)</code> for which it approaches 3/4.</p>",
        "id": 408706753,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1702944455
    },
    {
        "content": "<p>I guess there are infinitely many of those? Edit <a href=\"https://kconrad.math.uconn.edu/blurbs/ugradnumthy/millerrabin.pdf\">it's conjectured, but apparently not proven</a>.</p>",
        "id": 408706789,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1702944475
    },
    {
        "content": "<p>The first axiom is definitely true for <em>some</em> H: just let <code>H p i</code> be the compositeness witness of <code>p</code> if <code>p</code> is composite. The question is more if it's true for a specific <em>computable</em> H, like SHA3 for primes &lt; 2 ^ 4096</p>",
        "id": 408707239,
        "sender_full_name": "Thomas Zhu",
        "timestamp": 1702944685
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"282271\">Bolton Bailey</span> <a href=\"#narrow/stream/113488-general/topic/Miller.E2.80.93Rabin.20Primality.20Test/near/408706071\">said</a>:</p>\n<blockquote>\n<p>Incidentally, Kevin's comment has gotten me curious: Is it true/known that the sum over composite n from n = 1 to infinity of the fraction of k &lt; n  that are non Miller-Rabin witnesses diverges? Or if that sequence when raised to the power of 256/ some other value diverges?</p>\n</blockquote>\n<p>Well, for this specific series, it of course diverges because -1 is a nonwitness for every composite number, so the fraction is at least 1/n</p>",
        "id": 408707584,
        "sender_full_name": "Thomas Zhu",
        "timestamp": 1702944833
    },
    {
        "content": "<p>Right. The cryptographic justification would be that H is some very random-looking function that we can approximate by a \"random oracle\" - that is, a function whose outputs are independently random for any input. So I am wondering what the probability of the statement being false if for a random H.</p>",
        "id": 408707720,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1702944878
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"631691\">Thomas Zhu</span> <a href=\"#narrow/stream/113488-general/topic/Miller.E2.80.93Rabin.20Primality.20Test/near/408707584\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"282271\">Bolton Bailey</span> <a href=\"#narrow/stream/113488-general/topic/Miller.E2.80.93Rabin.20Primality.20Test/near/408706071\">said</a>:</p>\n<blockquote>\n<p>Incidentally, Kevin's comment has gotten me curious: Is it true/known that the sum over composite n from n = 1 to infinity of the fraction of k &lt; n  that are non Miller-Rabin witnesses diverges? Or if that sequence when raised to the power of 256/ some other value diverges?</p>\n</blockquote>\n<p>Well, for this specific series, it of course diverges because -1 is a nonwitness for every composite number, so the fraction is at least 1/n</p>\n</blockquote>\n<p>Ah good point. But if we repeat the test, we raise the fraction to a power and the series 1/n^2 doesn't diverge, so this doesn't prove that there is no number of repetitions for which it diverges.</p>",
        "id": 408707927,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1702944961
    },
    {
        "content": "<p><code>axiom</code> definitely doesn't look like the right tool for the job here. It shouldn't be too hard to define the probability distribution of the output of Miller-Rabin on a given composite number, and then prove that the error probability goes down exponentially with the number of rounds.</p>",
        "id": 408719640,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1702949125
    },
    {
        "content": "<p>I recall the Starkware certification by <span class=\"user-mention\" data-user-id=\"110865\">@Jeremy Avigad</span> included a probabilistic claim of exactly this form. It was stated as saying that the size of the bad set was smaller than some explicit small bound</p>",
        "id": 408733332,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1702954371
    },
    {
        "content": "<p><a href=\"https://github.com/starkware-libs/formal-proofs/blob/d0edfe9f3601bfd073c10ad8fc14d0ec7c77fc7f/src/starkware/cairo/lean/semantics/air_encoding/final_correctness.lean#L37-L81\">https://github.com/starkware-libs/formal-proofs/blob/d0edfe9f3601bfd073c10ad8fc14d0ec7c77fc7f/src/starkware/cairo/lean/semantics/air_encoding/final_correctness.lean#L37-L81</a></p>",
        "id": 408734240,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1702954559
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"311453\">Frédéric Dupuis</span> <a href=\"#narrow/stream/113488-general/topic/Miller.E2.80.93Rabin.20Primality.20Test/near/408719640\">said</a>:</p>\n<blockquote>\n<p><code>axiom</code> definitely doesn't look like the right tool for the job here. It shouldn't be too hard to define the probability distribution of the output of Miller-Rabin on a given composite number, and then prove that the error probability goes down exponentially with the number of rounds.</p>\n</blockquote>\n<p>I agree we shouldn't need axioms. We would indeed be able to prove that \"if we try MR r times on composite n, there only prob. 4^-r that it still returns true\". The axiom gets us the \"contrapositive\": \"if we try MR r times on n and it returns true, n is probably prime (with prob 1-4^-r, conceptually)\". But we can't say a number is \"probably prime\" because it's either prime or composite.</p>\n<p>For a theorem T depending on primality of p that is only possible to test with MR, instead of showing \"T\" we can show instead \"If T is false, we can prove it's false with prob. 1/2\", and this doesn't need any axioms.</p>\n<p>If anything one might state an axiom that Baillie PSW is right - it's deterministic, as fast as MR, and we haven't found a counterexample despite many targeted searches, and it's shown correct for under 2^64.</p>",
        "id": 408734561,
        "sender_full_name": "Thomas Zhu",
        "timestamp": 1702954619
    },
    {
        "content": "<p>axiomatizing that a probabilistic algorithm is correct will usually result in a short proof of false, and axiomatizing that a probabilistic algorithm is correct for less than some big but fixed value of n (larger than anything that has been actually proved) is gambling with unclear odds</p>",
        "id": 408736186,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1702954910
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"631691\">Thomas Zhu</span> <a href=\"#narrow/stream/113488-general/topic/Miller.E2.80.93Rabin.20Primality.20Test/near/408734561\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"311453\">Frédéric Dupuis</span> <a href=\"#narrow/stream/113488-general/topic/Miller.E2.80.93Rabin.20Primality.20Test/near/408719640\">said</a>:</p>\n<blockquote>\n<p><code>axiom</code> definitely doesn't look like the right tool for the job here. It shouldn't be too hard to define the probability distribution of the output of Miller-Rabin on a given composite number, and then prove that the error probability goes down exponentially with the number of rounds.</p>\n</blockquote>\n<p>I agree we shouldn't need axioms. We would indeed be able to prove that \"if we try MR r times on composite n, there only prob. 4^-r that it still returns true\". The axiom gets us the \"contrapositive\": \"if we try MR r times on n and it returns true, n is probably prime (with prob 1-4^-r, conceptually)\". But we can't say a number is \"probably prime\" because it's either prime or composite.</p>\n<p>For a theorem T depending on primality of p that is only possible to test with MR, instead of showing \"T\" we can show instead \"If T is false, we can prove it's false with prob. 1/2\", and this doesn't need any axioms.</p>\n</blockquote>\n<p>I have considered this approach too. You can even define a general transform that turns any proposition you want into a type of probabilistic tests of that proposition, and then combine probabilistic tests at will, then run a test at any time you want for confirmation. </p>\n<p>I still think there's value in the <code>axiom</code> approach, though, since that way you don't have to carry this mildly weird new type with you after you test your result.</p>",
        "id": 408767140,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1702960222
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"455791\">Yuyang Zhao</span> <a href=\"#narrow/stream/113488-general/topic/Miller.E2.80.93Rabin.20Primality.20Test/near/408688627\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/113488-general/topic/Miller.E2.80.93Rabin.20Primality.20Test/near/408685102\">said</a>:</p>\n<blockquote>\n<p>By the way, I think <a href=\"https://github.com/leanprover-community/mathlib4/pull/8885\">#8885</a> should make the fast modular exponentiation above unnecessary. (Or rather, it already implements it)</p>\n</blockquote>\n<p>I was going to make something similar after <a href=\"https://github.com/leanprover/std4/pull/314\">std4#314</a>.</p>\n</blockquote>\n<p>I found my branch and made <a href=\"https://github.com/leanprover-community/mathlib4/pull/9154\">#9154</a>. But it depends on too many other PRs. It may take a while before it can be merged.</p>",
        "id": 409044223,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1703033631
    },
    {
        "content": "<p>To answer the speed comparison: on my laptop, verifying the <del>primality</del> probable primality of 2^3217-1 using 500 rounds of Miller–Rabin takes 27 seconds on Lean (my implementation), 6 seconds on C (using OpenSSL <code>BN_is_prime_ex</code>), and 20 seconds on C if Montgomery multiplication is disabled (again OpenSSL).</p>",
        "id": 409051329,
        "sender_full_name": "Thomas Zhu",
        "timestamp": 1703035548
    },
    {
        "content": "<p>Just to be clear, you're not claiming to actually verify the primality here right?</p>",
        "id": 409054205,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1703036378
    },
    {
        "content": "<p>Why not? Medium sized numbers like that (but randomer) are pretty useful! If anything 6s seems like a long time, even from 500 rounds. It's instantaneous here, using the sample code from the GMP source code.</p>",
        "id": 409058662,
        "sender_full_name": "Richard Copley",
        "timestamp": 1703037537
    },
    {
        "content": "<p>Oh, mathematically. That might take a little longer. The consensus seems to be that cryptography programs needn't bother.</p>",
        "id": 409060957,
        "sender_full_name": "Richard Copley",
        "timestamp": 1703037954
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/Miller.E2.80.93Rabin.20Primality.20Test/near/409054205\">said</a>:</p>\n<blockquote>\n<p>Just to be clear, you're not claiming to actually verify the primality here right?</p>\n</blockquote>\n<p>No :) just that 500 rounds of MR doesn't find that it's composite, not that it proves it's prime</p>",
        "id": 409061358,
        "sender_full_name": "Thomas Zhu",
        "timestamp": 1703038036
    },
    {
        "content": "<p>All 3 tests are 500 rounds of MR</p>",
        "id": 409062525,
        "sender_full_name": "Thomas Zhu",
        "timestamp": 1703038266
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"631691\">Thomas Zhu</span> <a href=\"#narrow/stream/113488-general/topic/Miller.E2.80.93Rabin.20Primality.20Test/near/409051329\">said</a>:</p>\n<blockquote>\n<p>To answer the speed comparison: on my laptop, verifying the <del>primality</del> probable primality of 2^3217-1 using 500 rounds of Miller–Rabin takes 27 seconds on Lean (my implementation), 6 seconds on C (using OpenSSL <code>BN_is_prime_ex</code>), and 20 seconds on C if Montgomery multiplication is disabled (again OpenSSL).</p>\n</blockquote>\n<p>I spent some time yesterday implementing Montgomery modular multiplication in lean. But probably the gmp implementation of mod is so good that there is almost no advantage over not using Montgomery modular multiplication.</p>",
        "id": 409548291,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1703236306
    },
    {
        "content": "<p>I'm sure there's plenty of room for improvement with elliptic curve multiplication :-)</p>",
        "id": 409548431,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1703236364
    },
    {
        "content": "<p>I was sent this paper by my former tutor that shows how to formalize probabilistic algorithms: <a href=\"https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-566.pdf\">https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-566.pdf</a> It defines a probability measure on the state of the RNG (Nat -&gt; Bool) that is, if I interpret correctly, the countable product of Bernoulli(1/2) (i.e. assumes independence and uniformity of the RNG) and then is able to calculate the probability of outputs of monadic programs using random generators. It also applies this to the Miller–Rabin test.</p>",
        "id": 409628994,
        "sender_full_name": "Thomas Zhu",
        "timestamp": 1703271385
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"455791\">Yuyang Zhao</span> <a href=\"#narrow/stream/113488-general/topic/Miller.E2.80.93Rabin.20Primality.20Test/near/409548291\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"631691\">Thomas Zhu</span> <a href=\"#narrow/stream/113488-general/topic/Miller.E2.80.93Rabin.20Primality.20Test/near/409051329\">said</a>:</p>\n<blockquote>\n<p>To answer the speed comparison: on my laptop, verifying the <del>primality</del> probable primality of 2^3217-1 using 500 rounds of Miller–Rabin takes 27 seconds on Lean (my implementation), 6 seconds on C (using OpenSSL <code>BN_is_prime_ex</code>), and 20 seconds on C if Montgomery multiplication is disabled (again OpenSSL).</p>\n</blockquote>\n<p>I spent some time yesterday implementing Montgomery modular multiplication in lean. But probably the gmp implementation of mod is so good that there is almost no advantage over not using Montgomery modular multiplication.</p>\n</blockquote>\n<p>It looks like GMP also uses Montgomery: <code>mpz_probab_prime_p</code> <a href=\"https://github.com/alisw/GMP/blob/2bbd52703e5af82509773264bfbd20ff8464804f/mpz/pprime_p.c#L147\">calls</a> <code>millerrabin</code> which <a href=\"https://github.com/alisw/GMP/blob/2bbd52703e5af82509773264bfbd20ff8464804f/mpz/millerrabin.c#L205\">calls</a> <code>mpz_powm</code> which <a href=\"https://github.com/alisw/GMP/blob/2bbd52703e5af82509773264bfbd20ff8464804f/mpz/powm.c#L191\">calls</a> <code>mpn_powm</code> which <a href=\"https://github.com/alisw/GMP/blob/master/mpn/generic/powm.c\">uses</a> REDC. Similarly OpenSSH also uses Montgomery</p>",
        "id": 409631162,
        "sender_full_name": "Thomas Zhu",
        "timestamp": 1703272489
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/Miller.E2.80.93Rabin.20Primality.20Test/near/409548431\">said</a>:</p>\n<blockquote>\n<p>I'm sure there's plenty of room for improvement with elliptic curve multiplication :-)</p>\n</blockquote>\n<p>I'm not sure what you mean here, I don't think elliptic curves are used in Miller Rabin. Or are you saying for deterministic primality tests?</p>",
        "id": 409632325,
        "sender_full_name": "Thomas Zhu",
        "timestamp": 1703273183
    },
    {
        "content": "<p><code>mpz_probab_prime_p</code> takes around 4.066 seconds here with first argument <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mn>3217</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">2^{3217}-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8974em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">3217</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> and second argument 500, which apparently means 476 iterations of Miller-Rabin. (Its documentation says it will do <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi><mi>e</mi><mi>p</mi><mi>s</mi><mo>−</mo><mn>24</mn></mrow><annotation encoding=\"application/x-tex\">reps-24</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">re</span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">s</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">24</span></span></span></span> repetitions; but then it also says \"Reasonable values of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi><mi>e</mi><mi>p</mi><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">reps</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">re</span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">s</span></span></span></span> are between 15 and 50\", so a pinch of salt needs to be taken somewhere.)</p>",
        "id": 409634112,
        "sender_full_name": "Richard Copley",
        "timestamp": 1703274223
    },
    {
        "content": "<p>Yes, it does a Baillie-PSW first, which it claims to already give 1/4^24 confidence, and then the rest resp-24 tests</p>",
        "id": 409637817,
        "sender_full_name": "Thomas Zhu",
        "timestamp": 1703276399
    },
    {
        "content": "<p>(it also does some trial divisions before that)</p>",
        "id": 409638074,
        "sender_full_name": "Thomas Zhu",
        "timestamp": 1703276546
    },
    {
        "content": "<p>That's why I thought it fairer to compare to the OpenSSH implementation, though of course one could do the pure Miller–Rabin on GMP using the <code>millerrabin</code> subprocedure of <code>mpz_probab_prime_p</code></p>",
        "id": 409638804,
        "sender_full_name": "Thomas Zhu",
        "timestamp": 1703277034
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Miller.E2.80.93Rabin.20Primality.20Test/near/408736186\">said</a>:</p>\n<blockquote>\n<p>axiomatizing that a probabilistic algorithm is correct will usually result in a short proof of false, ...</p>\n</blockquote>\n<p>Why is that? I don't see the problem in this, as long as the algorithm can't know the seed of the pseudorandom generator, and you do sufficiently many iterations. For example, while</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">axiom</span> <span class=\"n\">probabilistic_miller_rabin</span>\n  <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">Finset.range</span> <span class=\"mi\">256</span><span class=\"o\">,</span> <span class=\"n\">not_miller_rabin_compositeness_witness</span> <span class=\"n\">p</span> <span class=\"o\">((</span><span class=\"n\">H</span> <span class=\"n\">p</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">%</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">p.Prime</span>\n</code></pre></div>\n<p>may be false,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">axiom</span> <span class=\"n\">probabilistic_miller_rabin</span>\n  <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">Finset.range</span> <span class=\"o\">(</span><span class=\"mi\">3</span> <span class=\"n\">log</span> <span class=\"n\">p</span><span class=\"o\">),</span> <span class=\"n\">not_miller_rabin_compositeness_witness</span> <span class=\"n\">p</span> <span class=\"o\">((</span><span class=\"n\">H</span> <span class=\"n\">p</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">%</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">p.Prime</span>\n</code></pre></div>\n<p>is certainly true with a high probability for a random <code>H</code>, and I don't think it's unreasonable to claim that SHA3, for instance, is such a function, especially after testing all values up to say <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\"application/x-tex\">10^9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span></span></span></span> (which reduces the <em>global</em> error probability to around <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mrow><mo>−</mo><mn>150</mn></mrow></msup></mrow><annotation encoding=\"application/x-tex\">2^{-150}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">150</span></span></span></span></span></span></span></span></span></span></span></span>).</p>\n<p>The same can be done for any other particular <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>BPP</mtext></mrow><annotation encoding=\"application/x-tex\">\\text{BPP}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord text\"><span class=\"mord\">BPP</span></span></span></span></span> algorithm, but there is a problem in doing it in general deterministically - the algorithm can simulate whatever process is used to get a seed for it. There is also the problem of it completely breaking if the algorithm can try all possible seeds for <code>H</code>, and I don't think we can formalize bounds on the complexity of the algorithm.</p>\n<p>If we could, though, it might be possible to make the pseudorandom generator be inefficient enough that the algorithm couldn't possibly run it, and this also solves the previous problem.</p>",
        "id": 436835204,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1714722879
    },
    {
        "content": "<p>I don't see any particular reason to think that an axiomatization of a particular algorithm like Miller Rabin derandomized with a function like SHA3 would lead to a short proof of false. After all, if you derandomize it with the identity function and prove false, you have disproven the extended Riemann Hypothesis, which is pretty hard to do. You would think SHA3 would only make it harder.</p>",
        "id": 436966351,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1714774243
    },
    {
        "content": "<p>Also, I would really like to see a proof that the first axiom is false. I am not saying it's true, but as I tried to point out earlier, the question of proving it false seems like a fun puzzle that I have not been able to solve.</p>",
        "id": 436967059,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1714774643
    },
    {
        "content": "<p>Perhaps it is worth mentioning though that a version of the axiom derandomizing general probabilistic tests would be provably false for diagonalization reasons.</p>",
        "id": 436967701,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1714775013
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"282271\">Bolton Bailey</span> <a href=\"#narrow/stream/113488-general/topic/Miller.E2.80.93Rabin.20Primality.20Test/near/436967701\">said</a>:</p>\n<blockquote>\n<p>Perhaps it is worth mentioning though that a version of the axiom derandomizing general probabilistic tests would be provably false for diagonalization reasons.</p>\n</blockquote>\n<p>Yes, this seems hard to resolve without formalizing resource bounds. Maybe the pseudorandom generator could run the algorithm itself somehow to generate a seed, and then the fact that the algorithm terminates would prevent it from running the generator?</p>",
        "id": 436987619,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1714793633
    },
    {
        "content": "<p>A version of (closed source CAS) Mathematica in the 1990s proudly claimed that the primality test they implemented was correct assuming GRH, and a friend of mine in Cambridge found an explicit number which wasn't prime and was being reported prime. They were wise enough to not start celebrating -- they applied the test which mathematica was claiming to do, manually, and it worked. Turned out the manual was lying.</p>",
        "id": 437010829,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1714818635
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/Miller.E2.80.93Rabin.20Primality.20Test/near/437010829\">said</a>:</p>\n<blockquote>\n<p>A version of (closed source CAS) Mathematica in the 1990s proudly claimed that the primality test they implemented was correct assuming GRH, and a friend of mine in Cambridge found an explicit number which wasn't prime and was being reported prime. They were wise enough to not start celebrating -- they applied the test which mathematica was claiming to do, manually, and it worked. Turned out the manual was lying.</p>\n</blockquote>\n<p>Interesting, i'd be interested to know how this test was different from the Miller test.</p>",
        "id": 437032035,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1714838960
    },
    {
        "content": "<p>(Also, did wikipedia just lie to me, does the Miller test correctness follow from the ERH, GRH or both?)</p>",
        "id": 437032110,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1714839015
    },
    {
        "content": "<p>I am noticing that <a href=\"https://www.wikiwand.com/en/Miller%E2%80%93Rabin_primality_test\">the intro to this page</a> says:</p>\n<blockquote>\n<p><a href=\"https://www.wikiwand.com/en/Gary_Miller_(professor)\">Gary L. Miller</a> discovered the test in 1976. Miller's version of the test is <a href=\"https://www.wikiwand.com/en/Deterministic_algorithm\">deterministic</a>, but its correctness relies on the unproven <a href=\"https://www.wikiwand.com/en/Extended_Riemann_hypothesis\">extended Riemann hypothesis</a>.</p>\n</blockquote>\n<p>But <a href=\"https://www.wikiwand.com/en/Miller%E2%80%93Rabin_primality_test#Miller_test\">a later section</a> says:</p>\n<blockquote>\n<p>Assuming the truth of the <a href=\"https://www.wikiwand.com/en/Generalized_Riemann_hypothesis\">generalized Riemann hypothesis</a> (GRH), it is known that the group is generated by its elements smaller than O((<a href=\"https://www.wikiwand.com/en/Natural_logarithm\">ln</a> <em>n</em>)2), which was already noted by Miller.</p>\n</blockquote>",
        "id": 437032387,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1714839344
    },
    {
        "content": "<p>Looks like the second one is the lie: The original Miller paper doesn't mention GRH at all, only the ERH.</p>",
        "id": 437032454,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1714839388
    },
    {
        "content": "<p>Update with more surprising facts: Incredibly, it seems like it is maybe <a href=\"https://mathoverflow.net/questions/14798/riemann-hypothesis-generalization-names-extended-versus-generalized\">actually the case that the mathematical literature is ambiguous about which of these things means what</a>.</p>",
        "id": 437043265,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1714848158
    },
    {
        "content": "<p>And of course Kevin turns up in the comments <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 437046063,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1714850894
    },
    {
        "content": "<p>Not sure if this paper of Alford, Granville and Pomerance was mentioned before in the thread, apologies if it was: <a href=\"https://link.springer.com/chapter/10.1007/3-540-58691-1_36\">https://link.springer.com/chapter/10.1007/3-540-58691-1_36</a></p>",
        "id": 437314393,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1715019520
    }
]