[
    {
        "content": "<p>I was trying to define a has_add instance for lists without using an auxiliary function and noticed a strange behavior of \"match with\". First I tried a one-liner in term mode which works fine:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">hidden</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">has_add</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">add</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">add</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">has_add.add</span>\n\n<span class=\"kd\">notation</span> <span class=\"n\">a</span> <span class=\"bp\">`</span> <span class=\"bp\">+'</span> <span class=\"bp\">`</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">add</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">nat_has_add</span> <span class=\"o\">:</span> <span class=\"n\">has_add</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span>\n<span class=\"n\">has_add.mk</span> <span class=\"n\">nat.add</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">list_has_add</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_add</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">has_add.mk</span>\n<span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">l₁</span><span class=\"o\">,</span> <span class=\"n\">list.rec_on</span> <span class=\"n\">l₁</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">l₂</span><span class=\"o\">,</span> <span class=\"n\">l₂</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">hd₁</span> <span class=\"n\">tl₁</span> <span class=\"n\">ih₁</span><span class=\"o\">,</span>\n    <span class=\"bp\">λ</span> <span class=\"n\">l₂</span><span class=\"o\">,</span> <span class=\"n\">list.cases_on</span> <span class=\"n\">l₂</span>\n      <span class=\"o\">(</span><span class=\"n\">hd₁</span> <span class=\"o\">::</span> <span class=\"n\">tl₁</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">hd₂</span> <span class=\"n\">tl₂</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">hd₁</span> <span class=\"bp\">+'</span> <span class=\"n\">hd₂</span><span class=\"o\">)</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">ih₁</span> <span class=\"n\">tl₂</span><span class=\"o\">))))</span>\n\n<span class=\"k\">#reduce</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">]</span> <span class=\"bp\">+'</span> <span class=\"o\">[</span><span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"mi\">6</span><span class=\"o\">]</span> <span class=\"c1\">--[5, 7, 9]</span>\n<span class=\"k\">#reduce</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">]</span> <span class=\"bp\">+'</span> <span class=\"o\">[</span><span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">]</span>    <span class=\"c1\">--[5, 7, 3]</span>\n<span class=\"k\">#reduce</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">]</span> <span class=\"bp\">+'</span> <span class=\"o\">[</span><span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"mi\">6</span><span class=\"o\">]</span>    <span class=\"c1\">--[5, 7, 6]</span>\n</code></pre></div>\n<p>Then I tried to do the same thing with patter matching and using an auxiliary function this also works without problems:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">list_add</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">hadd</span> <span class=\"o\">:</span> <span class=\"n\">has_add</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"n\">list.nil</span> <span class=\"n\">list.nil</span> <span class=\"o\">:=</span> <span class=\"n\">list.nil</span>\n<span class=\"bp\">|</span> <span class=\"n\">list.nil</span> <span class=\"o\">(</span><span class=\"n\">hd₂</span> <span class=\"o\">::</span> <span class=\"n\">tl₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">hd₂</span> <span class=\"o\">::</span> <span class=\"n\">tl₂</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">hd₁</span> <span class=\"o\">::</span> <span class=\"n\">tl₁</span><span class=\"o\">)</span> <span class=\"n\">list.nil</span> <span class=\"o\">:=</span> <span class=\"n\">hd₁</span> <span class=\"o\">::</span> <span class=\"n\">tl₁</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">hd₁</span> <span class=\"o\">::</span> <span class=\"n\">tl₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hd₂</span> <span class=\"o\">::</span> <span class=\"n\">tl₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">hd₁</span> <span class=\"bp\">+'</span> <span class=\"n\">hd₂</span><span class=\"o\">)</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">list_add</span> <span class=\"n\">tl₁</span> <span class=\"n\">tl₂</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">list_has_add</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">has_add</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_add</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">has_add.mk</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">list_add</span> <span class=\"n\">α</span> <span class=\"n\">ha</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>However, if I don't want to use an auxiliary function I need to use \"match with\" (I think) because I need to invoke the constructor of has_add, and here I noticed a strange behavior I can't explain:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">list_has_add</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_add</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">has_add.mk</span>\n<span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span><span class=\"o\">,</span> <span class=\"k\">match</span> <span class=\"n\">l₁</span><span class=\"o\">,</span> <span class=\"n\">l₂</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"n\">list.nil</span><span class=\"o\">,</span> <span class=\"n\">list.nil</span> <span class=\"o\">:=</span> <span class=\"n\">list.nil</span>\n<span class=\"bp\">|</span> <span class=\"n\">list.nil</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">hd₂</span> <span class=\"o\">::</span> <span class=\"n\">tl₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">hd₂</span> <span class=\"o\">::</span> <span class=\"n\">tl₂</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">hd₁</span> <span class=\"o\">::</span> <span class=\"n\">tl₁</span><span class=\"o\">),</span> <span class=\"n\">list.nil</span> <span class=\"o\">:=</span> <span class=\"n\">hd₁</span> <span class=\"o\">::</span> <span class=\"n\">tl₁</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">hd₁</span> <span class=\"o\">::</span> <span class=\"n\">tl₁</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">hd₂</span> <span class=\"o\">::</span> <span class=\"n\">tl₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">hd₁</span> <span class=\"bp\">+'</span> <span class=\"n\">hd₂</span><span class=\"o\">)</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">_match</span> <span class=\"n\">tl₁</span> <span class=\"n\">tl₂</span><span class=\"o\">)</span> <span class=\"c1\">--This works</span>\n<span class=\"c1\">--| (hd₁ :: tl₁), (hd₂ :: tl₂) := (hd₁ +' hd₂) :: (_match tl₁ tl₂) --but this does not (it won't find _match in term mode)</span>\n<span class=\"kd\">end</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>The same holds true if I define the auxiliary function using \"match with\":</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">list_add</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">hadd</span> <span class=\"o\">:</span> <span class=\"n\">has_add</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span><span class=\"o\">,</span> <span class=\"k\">match</span> <span class=\"n\">l₁</span><span class=\"o\">,</span> <span class=\"n\">l₂</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"n\">list.nil</span><span class=\"o\">,</span> <span class=\"n\">list.nil</span> <span class=\"o\">:=</span> <span class=\"n\">list.nil</span>\n<span class=\"bp\">|</span> <span class=\"n\">list.nil</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">hd₂</span> <span class=\"o\">::</span> <span class=\"n\">tl₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">hd₂</span> <span class=\"o\">::</span> <span class=\"n\">tl₂</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">hd₁</span> <span class=\"o\">::</span> <span class=\"n\">tl₁</span><span class=\"o\">),</span> <span class=\"n\">list.nil</span> <span class=\"o\">:=</span> <span class=\"n\">hd₁</span> <span class=\"o\">::</span> <span class=\"n\">tl₁</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">hd₁</span> <span class=\"o\">::</span> <span class=\"n\">tl₁</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">hd₂</span> <span class=\"o\">::</span> <span class=\"n\">tl₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">hd₁</span> <span class=\"bp\">+'</span> <span class=\"n\">hd₂</span><span class=\"o\">)</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">_match</span> <span class=\"n\">tl₁</span> <span class=\"n\">tl₂</span><span class=\"o\">)</span> <span class=\"c1\">--This works</span>\n<span class=\"c1\">--| (hd₁ :: tl₁), (hd₂ :: tl₂) := (hd₁ +' hd₂) :: (_match tl₁ tl₂) --but this does not (it won't find _match in term mode)</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">list_has_add</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">has_add</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_add</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">has_add.mk</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">list_add</span> <span class=\"n\">α</span> <span class=\"n\">ha</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Does anybody know why term mode and tactic mode make a difference here? Also, how can I choose a different name for \"_match\"?</p>",
        "id": 348224262,
        "sender_full_name": "Mario Weitzer",
        "timestamp": 1681135477
    },
    {
        "content": "<p>Match expressions are elaborated by creating an auxiliary definition, which is why you find there is a <code>_match</code> function. Lean 3 doesn't support recursive definitions with expressions. I would suggest creating an auxiliary definition using pattern matching yourself like in your second example.</p>\n<p>As to why you can use tactics to see the auxiliary <code>_match</code>, tactic blocks defer their elaboration until later -- either when there's nothing left to do or when something forces all pending tactics to evaluate. Presumably here the block is being deferred to when the auxiliary definition is being defined. I don't think you can rely on this. I haven't checked, but I suspect a well-placed <code>let</code> would break it.</p>",
        "id": 348237484,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681138575
    },
    {
        "content": "<p>I see, thanks!</p>",
        "id": 348246588,
        "sender_full_name": "Mario Weitzer",
        "timestamp": 1681140962
    }
]