[
    {
        "content": "<p>I'm trying to prove something about two mutually defined propositions inductively. Because the induction tactic does not work with mutual, I used \"cases\" and made recursive calls manually. However I get the following error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">fail</span> <span class=\"n\">to</span> <span class=\"k\">show</span> <span class=\"n\">termination</span> <span class=\"n\">for</span>\n  <span class=\"n\">completeness</span>\n<span class=\"k\">with</span> <span class=\"n\">errors</span>\n<span class=\"n\">structural</span> <span class=\"n\">recursion</span> <span class=\"n\">failed</span><span class=\"o\">,</span> <span class=\"n\">produced</span> <span class=\"n\">type</span> <span class=\"n\">incorrect</span> <span class=\"n\">term</span>\n</code></pre></div>\n<p>Could anyone give me any insight to what this error means? I've stripped my definition down to a single recursive call which is trivially structurally recursive. My real code is a little involved so difficult to post a complete example.</p>",
        "id": 382596255,
        "sender_full_name": "Ellis Kesterton",
        "timestamp": 1691408655
    },
    {
        "content": "<p>This is the most minimal example I can come up with:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">axiom</span> <span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n\n\n<span class=\"kd\">mutual</span>\n  <span class=\"kd\">inductive</span> <span class=\"n\">Tree</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n    <span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">Tree</span> <span class=\"n\">n</span>\n    <span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"n\">n</span> <span class=\"n\">ns</span> <span class=\"bp\">→</span> <span class=\"n\">Forest</span> <span class=\"n\">ns</span> <span class=\"n\">ns.length</span> <span class=\"bp\">→</span> <span class=\"n\">Tree</span> <span class=\"n\">n</span>\n\n  <span class=\"kd\">inductive</span> <span class=\"n\">Forest</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n    <span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">Forest</span> <span class=\"n\">ns</span> <span class=\"n\">zero</span>\n    <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"n\">Tree</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">Forest</span> <span class=\"n\">ns</span> <span class=\"n\">k</span> <span class=\"bp\">→</span> <span class=\"n\">Forest</span> <span class=\"n\">ns</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"n\">k</span><span class=\"o\">)</span>\n<span class=\"kd\">end</span>\n\n\n<span class=\"kd\">axiom</span> <span class=\"n\">Qs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n\n\n<span class=\"kd\">theorem</span> <span class=\"n\">q</span> <span class=\"o\">(</span><span class=\"n\">forest</span> <span class=\"o\">:</span> <span class=\"n\">Forest</span> <span class=\"n\">ns</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Qs</span> <span class=\"n\">ns</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">forest</span>\n  <span class=\"n\">case</span> <span class=\"n\">nil</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"n\">case</span> <span class=\"n\">cons</span> <span class=\"n\">t</span> <span class=\"n\">ts</span> <span class=\"bp\">=&gt;</span>\n\n    <span class=\"k\">have</span> <span class=\"n\">qs'</span> <span class=\"o\">:=</span> <span class=\"n\">q</span> <span class=\"n\">ts</span>\n    <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 382597768,
        "sender_full_name": "Ellis Kesterton",
        "timestamp": 1691408971
    },
    {
        "content": "<p>My understanding is that 'ts' should be smaller than 'forest', and implicitly the 'k' passed will be smaller too.</p>",
        "id": 382598813,
        "sender_full_name": "Ellis Kesterton",
        "timestamp": 1691409201
    }
]