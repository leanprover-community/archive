[
    {
        "content": "<p>Two very confusing typeclass failures:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.NormedSpace.OperatorNorm</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"bp\">𝕜</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">NontriviallyNormedField</span> <span class=\"bp\">𝕜</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">SeminormedAddCommGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">Dual</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">E</span> <span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"bp\">𝕜</span><span class=\"o\">]</span> <span class=\"bp\">𝕜</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">inclusionInDoubleDual</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"bp\">𝕜</span><span class=\"o\">]</span> <span class=\"n\">Dual</span> <span class=\"bp\">𝕜</span> <span class=\"o\">(</span><span class=\"n\">Dual</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"bp\">‖</span><span class=\"n\">ContinuousLinearMap.id</span> <span class=\"bp\">𝕜</span> <span class=\"o\">(</span><span class=\"n\">Dual</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">)</span><span class=\"bp\">‖</span>\n\n<span class=\"c1\">-- ok</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">exact</span> <span class=\"bp\">‖</span><span class=\"n\">inclusionInDoubleDual</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"bp\">‖</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">‖</span><span class=\"n\">ContinuousLinearMap.id</span> <span class=\"bp\">𝕜</span> <span class=\"o\">(</span><span class=\"n\">Dual</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">)</span><span class=\"bp\">‖</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- fail</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">‖</span><span class=\"n\">inclusionInDoubleDual</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"bp\">‖</span> <span class=\"bp\">=</span> <span class=\"bp\">‖</span><span class=\"n\">ContinuousLinearMap.id</span> <span class=\"bp\">𝕜</span> <span class=\"o\">(</span><span class=\"n\">Dual</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">)</span><span class=\"bp\">‖</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">--ok</span>\n<span class=\"kd\">example</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">ContinuousLinearMap.norm_id_le</span> <span class=\"bp\">𝕜</span> <span class=\"o\">(</span><span class=\"n\">Dual</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n\n<span class=\"c1\">-- fail</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">‖</span><span class=\"n\">inclusionInDoubleDual</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"bp\">‖</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">ContinuousLinearMap.norm_id_le</span> <span class=\"bp\">𝕜</span> <span class=\"o\">(</span><span class=\"n\">Dual</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n  <span class=\"bp\">·</span> <span class=\"gr\">sorry</span>\n  <span class=\"bp\">·</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- where did these goals come from?</span>\n  <span class=\"bp\">·</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 389833387,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694161216
    },
    {
        "content": "<p>In the first example, the <code>‖inclusionInDoubleDual 𝕜 E‖</code> on the LHS is breaking typeclass search on the RHS (unless we use <code>by exact</code> to isolate it)</p>",
        "id": 389833456,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694161238
    },
    {
        "content": "<p>In the second example, the type of the goal is somehow changing the elaboration of a <code>have</code> statement</p>",
        "id": 389833561,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694161286
    },
    {
        "content": "<p>(cc <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span>, whom I discussed this with this morning)</p>",
        "id": 389833609,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694161309
    },
    {
        "content": "<p>Replacing <code>Dual 𝕜 E</code> with <code>E →L[𝕜] 𝕜</code> in any of the broken examples seems to fix the issue, suggesting this is a bug in <code>abbrev</code> + TC search.</p>",
        "id": 389833981,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694161455
    },
    {
        "content": "<p>The problem seems to be a bad search cache: on the first example, I get</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">Meta.synthInstance</span><span class=\"o\">]</span> <span class=\"bp\">❌</span> <span class=\"n\">Norm</span> <span class=\"o\">(</span><span class=\"n\">Dual</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span> <span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"bp\">𝕜</span><span class=\"o\">]</span> <span class=\"n\">Dual</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"bp\">▼</span>\n  <span class=\"o\">[]</span> <span class=\"n\">new</span> <span class=\"n\">goal</span> <span class=\"n\">Norm</span> <span class=\"o\">(</span><span class=\"n\">Dual</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span> <span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"bp\">𝕜</span><span class=\"o\">]</span> <span class=\"n\">Dual</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"bp\">▼</span>\n    <span class=\"o\">[</span><span class=\"n\">instances</span><span class=\"o\">]</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"bp\">@</span><span class=\"n\">SeminormedAddGroup.toNorm</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">SeminormedGroup.toNorm</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">NormedAddGroup.toNorm</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">NormedGroup.toNorm</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">SeminormedAddCommGroup.toNorm</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">SeminormedCommGroup.toNorm</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">NormedAddCommGroup.toNorm</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">NormedCommGroup.toNorm</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">NonUnitalSeminormedRing.toNorm</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">SeminormedRing.toNorm</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">NonUnitalNormedRing.toNorm</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">NormedRing.toNorm</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">NormedDivisionRing.toNorm</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">NormedField.toNorm</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">ContinuousLinearMap.hasOpNorm</span><span class=\"o\">]</span>\n  <span class=\"o\">[]</span> <span class=\"bp\">❌</span> <span class=\"n\">apply</span> <span class=\"bp\">@</span><span class=\"n\">ContinuousLinearMap.hasOpNorm</span> <span class=\"n\">to</span> <span class=\"n\">Norm</span> <span class=\"o\">(</span><span class=\"n\">Dual</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span> <span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"bp\">𝕜</span><span class=\"o\">]</span> <span class=\"n\">Dual</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"bp\">▼</span>\n    <span class=\"o\">[</span><span class=\"n\">tryResolve</span><span class=\"o\">]</span> <span class=\"bp\">❌</span> <span class=\"n\">Norm</span> <span class=\"o\">(</span><span class=\"n\">Dual</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span> <span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"bp\">𝕜</span><span class=\"o\">]</span> <span class=\"n\">Dual</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"bp\">≟</span> <span class=\"n\">Norm</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">m.16472</span> <span class=\"bp\">→</span><span class=\"n\">SL</span><span class=\"o\">[</span><span class=\"bp\">?</span><span class=\"n\">m.16480</span><span class=\"o\">]</span> <span class=\"bp\">?</span><span class=\"n\">m.16473</span><span class=\"o\">)</span> <span class=\"bp\">▼</span>\n      <span class=\"o\">[]</span> <span class=\"bp\">✅</span> <span class=\"n\">NontriviallyNormedField</span> <span class=\"bp\">𝕜</span> <span class=\"bp\">▼</span>\n        <span class=\"o\">[]</span> <span class=\"n\">result</span> <span class=\"n\">inst</span><span class=\"bp\">✝²</span> <span class=\"o\">(</span><span class=\"n\">cached</span><span class=\"o\">)</span>\n      <span class=\"o\">[]</span> <span class=\"bp\">✅</span> <span class=\"n\">NontriviallyNormedField</span> <span class=\"bp\">𝕜</span> <span class=\"bp\">▶</span>\n      <span class=\"o\">[]</span> <span class=\"bp\">❌</span> <span class=\"n\">SeminormedAddCommGroup</span> <span class=\"o\">(</span><span class=\"n\">Dual</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"bp\">▼</span>\n        <span class=\"o\">[]</span> <span class=\"n\">result</span> <span class=\"bp\">&lt;</span><span class=\"n\">not</span><span class=\"bp\">-</span><span class=\"n\">available</span><span class=\"bp\">&gt;</span> <span class=\"o\">(</span><span class=\"n\">cached</span><span class=\"o\">)</span>\n<span class=\"bp\">&lt;</span><span class=\"n\">snip</span><span class=\"bp\">&gt;</span>\n</code></pre></div>\n<p>where on the last line, lean didn't even bother to look for the instance that it couldn't find and just falsely claimed it already knew it was missing</p>",
        "id": 389836298,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694162352
    },
    {
        "content": "<p>Another MWE, where a <code>rw</code> affects TC search withina <code>have</code> that follows it; even though the <code>have</code> does not ever see the main goal!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.NormedSpace.OperatorNorm</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"bp\">𝕜</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">NontriviallyNormedField</span> <span class=\"bp\">𝕜</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">SeminormedAddCommGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">Dual</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">E</span> <span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"bp\">𝕜</span><span class=\"o\">]</span> <span class=\"bp\">𝕜</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">inclusionInDoubleDual</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"bp\">𝕜</span><span class=\"o\">]</span> <span class=\"n\">Dual</span> <span class=\"bp\">𝕜</span> <span class=\"o\">(</span><span class=\"n\">Dual</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">‖</span><span class=\"n\">inclusionInDoubleDual</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"bp\">‖</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">-- this `rw` is needed to make the `have` below work</span>\n  <span class=\"c1\">-- rw [inclusionInDoubleDual]</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">Norm</span> <span class=\"o\">(</span><span class=\"n\">Dual</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span> <span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"bp\">𝕜</span><span class=\"o\">]</span> <span class=\"n\">Dual</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">inferInstance</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 389838599,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694163176
    },
    {
        "content": "<p>Underlying bug is <a href=\"https://github.com/leanprover/lean4/pull/2522\">lean4#2522</a>. More data on impact and a non-Mathlib MWE would be greatly appreciated!</p>",
        "id": 389855748,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1694169366
    },
    {
        "content": "<p>Thanks, your explanation is already helpful!</p>",
        "id": 389865985,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694173674
    },
    {
        "content": "<p>Making a non-Mathlib MWE will be hours of work, however it would not surprise me if someone could be persuaded to do that work if someone explained to them more details about why non-Mathlib MWEs are so important. All I know from experience is that they are very much appreciated by the lean dev community, but I don't really understand why. Is it because you don't know about <code>lake exe cache get</code> and think that you have to spend hours compiling mathlib? ;-) If the answer is \"mathlib just makes traces much more cluttered in general\" then my first reaction to this is \"are you absolutely sure that mathlib is making traces much more cluttered in this particular case?\". But maybe the answer is something else which I haven't internalised yet.</p>",
        "id": 389875839,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694177319
    },
    {
        "content": "<blockquote>\n<p>Is it because you don't know about lake exe cache get and think that you have to spend hours compiling mathlib?</p>\n</blockquote>\n<p>If you make a fix to Lean, the cache is (probably?) invalidated and you have to rebuild it all again</p>",
        "id": 389876042,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694177398
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Also, we can't add code with dependencies to the Lean 4 test suite (whose tests' runtimes should be measured in seconds, not hours)</p>",
        "id": 389876889,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1694177695
    },
    {
        "content": "<p>But note that doing minimization the usual way starting from the full code really isn't the optimal way here I believe. Instead one should start at the traces I posted and recreate only the components mentioned there, which hopefully should be much faster.</p>",
        "id": 389877231,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1694177806
    },
    {
        "content": "<p>I think that it's not unreasonable to suggest that a general tool which produces mathlib-free MWEs would be very useful for this sort of thing; of course I don't have the ability to make it. I've heard that there is one in Coq but I don't know how well it works in practice. Thanks for the responses Sebastian and Eric.</p>",
        "id": 389882090,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694179588
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> and <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> I might well take on mathlib-free minimisation of an example this evening; just to let you know in case you've started on one as well. What is the best target? Is it <a href=\"#narrow/stream/113488-general/topic/Typeclass.20search.20is.20affected.20by.20other.20subexpressions/near/389838599\">this post</a>?</p>",
        "id": 389882380,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694179701
    },
    {
        "content": "<p>Sebastian -- do you have a preference?</p>",
        "id": 389882477,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694179738
    },
    {
        "content": "<p>I was not planning to take this on in the immediate future, so please do so!</p>",
        "id": 389882509,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694179749
    },
    {
        "content": "<p>I would guess all three examples will reproduce the same way</p>",
        "id": 389882555,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694179763
    },
    {
        "content": "<p>Here is a preliminary reduction, although there is still a long way to go:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.Normed.Field.Basic</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"bp\">𝕜</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">NonUnitalSeminormedRing</span> <span class=\"bp\">𝕜</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">SeminormedAddCommGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">ContinuousLinearMap'</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">M₂</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">M₂</span><span class=\"o\">]</span> <span class=\"n\">where</span>\n\n<span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"mi\">25</span> <span class=\"n\">M</span> <span class=\"s2\">\" →z \"</span> <span class=\"n\">M₂</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ContinuousLinearMap'</span> <span class=\"n\">M</span> <span class=\"n\">M₂</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">Dual</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">E</span> <span class=\"bp\">→</span><span class=\"n\">z</span> <span class=\"bp\">𝕜</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">ContinuousLinearMap'.toSeminormedAddCommGroup</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span>\n    <span class=\"o\">[</span><span class=\"n\">SeminormedAddCommGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">SeminormedAddCommGroup</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">SeminormedAddCommGroup</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"bp\">→</span><span class=\"n\">z</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span><span class=\"n\">z</span> <span class=\"n\">Dual</span> <span class=\"bp\">𝕜</span> <span class=\"o\">(</span><span class=\"n\">Dual</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">‖</span><span class=\"n\">foo</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"bp\">‖</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">-- this `rw` is needed to make the `have` below work</span>\n  <span class=\"c1\">--rw [foo]</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">SeminormedAddCommGroup</span> <span class=\"o\">(</span><span class=\"n\">Dual</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">inferInstance</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>But now I need to properly understand what is going on, because further attempts by me to minimise just result in the problem going away. I have two questions about the summary at <a href=\"https://github.com/leanprover/lean4/pull/2522\">lean4#2522</a> :</p>\n<p>1) what is a nested TC problem?</p>\n<p>2) If I add <code>set_option trace.Meta.synthInstance true</code> then I can see the failure</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">Meta.synthInstance</span><span class=\"o\">]</span> <span class=\"bp\">❌</span> <span class=\"n\">SeminormedAddCommGroup</span> <span class=\"o\">(</span><span class=\"n\">Dual</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"bp\">▼</span>\n  <span class=\"o\">[]</span> <span class=\"n\">result</span> <span class=\"bp\">&lt;</span><span class=\"n\">not</span><span class=\"bp\">-</span><span class=\"n\">available</span><span class=\"bp\">&gt;</span> <span class=\"o\">(</span><span class=\"n\">cached</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>at the end of the example above. My understanding is that the current belief is that the cache has been tricked to return this because of some earlier failure (when things were \"nested\"). But I can't find that earlier failure in the trace and am not entirely sure where I should be looking.</p>",
        "id": 389945747,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694204886
    },
    {
        "content": "<p>Aah, I've solved (2), it's deep within <code>[Meta.synthInstance] ✅ Norm (E →z Dual 𝕜 (Dual 𝕜 E))</code></p>",
        "id": 389948548,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694206320
    },
    {
        "content": "<p>Aah and in my search I suspect I've also figured out what a nested typeclass search is; indeed the reason it was hard to find was because it was...erm...a typeclass search within a typeclass search.</p>",
        "id": 389949413,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694206764
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">Norm'</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">norm</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n\n<span class=\"kn\">export</span> <span class=\"n\">Norm'</span> <span class=\"o\">(</span><span class=\"n\">norm</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">TopologicalSpace'</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">random</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"c1\">-- need something here for some reason</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">SeminormedAddCommGroup'</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Norm'</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">TopologicalSpace'</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n\n<span class=\"c1\">-- need to extend Norm' again for some reason; note that this doesn't seem to cause a diamond</span>\n<span class=\"kd\">class</span> <span class=\"n\">NonUnitalSeminormedRing'</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Norm'</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">SeminormedAddCommGroup'</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"bp\">𝕜</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">NonUnitalSeminormedRing'</span> <span class=\"bp\">𝕜</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">SeminormedAddCommGroup'</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">ContinuousLinearMap'</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace'</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">M₂</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace'</span> <span class=\"n\">M₂</span><span class=\"o\">]</span> <span class=\"n\">where</span>\n\n<span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"mi\">25</span> <span class=\"n\">M</span> <span class=\"s2\">\" →z \"</span> <span class=\"n\">M₂</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ContinuousLinearMap'</span> <span class=\"n\">M</span> <span class=\"n\">M₂</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">Dual</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">E</span> <span class=\"bp\">→</span><span class=\"n\">z</span> <span class=\"bp\">𝕜</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">ContinuousLinearMap'.toSeminormedAddCommGroup'</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span>\n    <span class=\"o\">[</span><span class=\"n\">SeminormedAddCommGroup'</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">SeminormedAddCommGroup'</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">SeminormedAddCommGroup'</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"bp\">→</span><span class=\"n\">z</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span><span class=\"n\">z</span> <span class=\"n\">Dual</span> <span class=\"bp\">𝕜</span> <span class=\"o\">(</span><span class=\"n\">Dual</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"bp\">#</span><span class=\"n\">synth</span> <span class=\"n\">SeminormedAddCommGroup'</span> <span class=\"o\">(</span><span class=\"n\">Dual</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"c1\">-- works fine</span>\n\n<span class=\"c1\">-- set_option trace.Meta.synthInstance true</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">norm</span> <span class=\"o\">(</span><span class=\"n\">foo</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">-- this `rw` is needed to make the `have` below work</span>\n  <span class=\"c1\">--rw [foo]</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">SeminormedAddCommGroup'</span> <span class=\"o\">(</span><span class=\"n\">Dual</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">inferInstance</span> <span class=\"c1\">-- now fails!</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"c\">/-</span>\n\n<span class=\"cm\">Relevant traces in the example:</span>\n\n<span class=\"cm\">1) On `norm (foo 𝕜 E)`:</span>\n\n<span class=\"cm\">[Meta.synthInstance] ✅ Norm' (E →z Dual 𝕜 (Dual 𝕜 E)) ▼</span>\n<span class=\"cm\">  [] new goal Norm' (E →z Dual 𝕜 (Dual 𝕜 E)) ▶</span>\n<span class=\"cm\">  [] ✅ apply @NonUnitalSeminormedRing'.toNorm' to Norm' (E →z Dual 𝕜 (Dual 𝕜 E)) ▶</span>\n<span class=\"cm\">  [] ❌ apply inst✝¹ to NonUnitalSeminormedRing' (E →z Dual 𝕜 (Dual 𝕜 E)) ▶</span>\n<span class=\"cm\">  [] ✅ apply @SeminormedAddCommGroup'.toNorm' to Norm' (E →z Dual 𝕜 (Dual 𝕜 E)) ▶</span>\n<span class=\"cm\">  [] ❌ apply inst✝ to SeminormedAddCommGroup' (E →z Dual 𝕜 (Dual 𝕜 E)) ▶</span>\n<span class=\"cm\">  [] ✅ apply @ContinuousLinearMap'.toSeminormedAddCommGroup' to SeminormedAddCommGroup' (E →z Dual 𝕜 (Dual 𝕜 E)) ▼</span>\n<span class=\"cm\">    [tryResolve] ✅ SeminormedAddCommGroup' (E →z Dual 𝕜 (Dual 𝕜 E)) ≟ SeminormedAddCommGroup' (E →z Dual 𝕜 (Dual 𝕜 E)) ▼</span>\n<span class=\"cm\">      [] ✅ SeminormedAddCommGroup' E ▶</span>\n<span class=\"cm\">      [] ✅ SeminormedAddCommGroup' (Dual 𝕜 (Dual 𝕜 E)) ▼</span>\n<span class=\"cm\">        [] new goal SeminormedAddCommGroup' (Dual 𝕜 (Dual 𝕜 E)) ▶</span>\n<span class=\"cm\">        [] ❌ apply inst✝ to SeminormedAddCommGroup' (Dual 𝕜 (Dual 𝕜 E)) ▶</span>\n<span class=\"cm\">        [] ✅ apply @ContinuousLinearMap'.toSeminormedAddCommGroup' to SeminormedAddCommGroup' (Dual 𝕜 (Dual 𝕜 E)) ▼</span>\n<span class=\"cm\">          [tryResolve] ✅ SeminormedAddCommGroup' (Dual 𝕜 (Dual 𝕜 E)) ≟ SeminormedAddCommGroup' (Dual 𝕜 E →z 𝕜) ▼</span>\n<span class=\"cm\">            [] ❌ SeminormedAddCommGroup' (Dual 𝕜 E) ▼</span>\n<span class=\"cm\">              [] new goal SeminormedAddCommGroup' (Dual 𝕜 E) ▶</span>\n<span class=\"cm\">              [] ❌ apply inst✝ to SeminormedAddCommGroup' (Dual 𝕜 E) ▶</span>\n<span class=\"cm\">              [] ❌ apply @ContinuousLinearMap'.toSeminormedAddCommGroup' to SeminormedAddCommGroup' (Dual 𝕜 E) ▼</span>\n<span class=\"cm\">                [tryResolve] ❌ SeminormedAddCommGroup' (Dual 𝕜 E) ≟ SeminormedAddCommGroup' (?m.8308 →z ?m.8309)</span>\n\n<span class=\"cm\">2) Later, on `inferInstance`</span>\n\n<span class=\"cm\">[Meta.synthInstance] ❌ SeminormedAddCommGroup' (Dual 𝕜 E) ▼</span>\n<span class=\"cm\">  [] result &lt;not-available&gt; (cached)</span>\n\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>Mathlib-free! Should I post this on the github issue or are the names distasteful and I should replace them with proper computer science name like <code>foo</code> and <code>bar</code>?</p>",
        "id": 389956561,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694211047
    },
    {
        "content": "<p>I think those names are allowed.</p>",
        "id": 389956659,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1694211122
    },
    {
        "content": "<p>The example is extremely fragile (this was one reason that minimisation was hard). If you tinker with random things then all of a sudden the failing <code>[tryResolve] ❌ SeminormedAddCommGroup' (Dual 𝕜 E) ≟ SeminormedAddCommGroup' (?m.8308 →z ?m.8309)</code> magically turns into a succeeding <code>SeminormedAddCommGroup' (Dual 𝕜 E) ≟ SeminormedAddCommGroup' (E →z 𝕜)</code>. I have no understanding of what is going on here. Similarly the topological space structure has to have a field or else the problem goes away, and you have to extend <code>Norm'</code> twice or the problem goes away.</p>",
        "id": 389957075,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694211331
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">Norm'</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">norm</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n\n<span class=\"kn\">export</span> <span class=\"n\">Norm'</span> <span class=\"o\">(</span><span class=\"n\">norm</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">TopologicalSpace'</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">random</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"c1\">-- need something here for some reason</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">SeminormedAddCommGroup'</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Norm'</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">TopologicalSpace'</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n\n<span class=\"c1\">-- need to extend Norm' again for some reason; note that this doesn't seem to cause a diamond</span>\n<span class=\"kd\">class</span> <span class=\"n\">NonUnitalSeminormedRing'</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Norm'</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">SeminormedAddCommGroup'</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"bp\">𝕜</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">NonUnitalSeminormedRing'</span> <span class=\"bp\">𝕜</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- no diamond</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">NonUnitalSeminormedRing'.toNorm'</span> <span class=\"o\">:</span> <span class=\"n\">Norm'</span> <span class=\"bp\">𝕜</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n    <span class=\"bp\">@</span><span class=\"n\">SeminormedAddCommGroup'.toNorm'</span> <span class=\"bp\">𝕜</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">NonUnitalSeminormedRing'.toSeminormedAddCommGroup'</span> <span class=\"bp\">𝕜</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 389957531,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694211632
    }
]