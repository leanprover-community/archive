[
    {
        "content": "<p>I am doing Advent of Code with Lean 4. When solving the problem of today, I wrote the following code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">blink</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">toDigits</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">splitAt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">asString</span><span class=\"bp\">.</span><span class=\"n\">toNat!</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">asString</span><span class=\"bp\">.</span><span class=\"n\">toNat!</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">2024</span><span class=\"o\">]</span>\n\n<span class=\"c1\">--@[specialize] def foldr (f : α → β → β) (init : β) : List α → β</span>\n<span class=\"c1\">--  | []     =&gt; init</span>\n<span class=\"c1\">--  | a :: l =&gt; f a (foldr f init l)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">blinkAll</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\">      </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">blink</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">blinkAll</span><span class=\"w\"> </span><span class=\"n\">xs</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">solvePart1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">stones</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">25</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">repeat</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"n\">foldr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">blink</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[])</span><span class=\"w\"> </span><span class=\"n\">stones</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">parseInput</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">input</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">input</span><span class=\"bp\">.</span><span class=\"n\">splitOn</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"bp\">.</span><span class=\"n\">toNat!</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">input</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">parseInput</span><span class=\"w\"> </span><span class=\"s2\">\"5688 62084 2 3248809 179 79 0 172169\"</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">solvePart1</span><span class=\"w\"> </span><span class=\"n\">input</span><span class=\"w\"> </span><span class=\"mi\">25</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">length</span>\n</code></pre></div>\n<p>As you can see, the <code>blinkAll</code> function is essentially <code>foldr</code>specialized with <code>f := (blink · ++ ·)</code> and <code>init := []</code>. However, the <code>solvePart1</code> implemented using <code>foldr</code> can successfully give an answer with <code>n := 25</code>, but if <code>(·.foldr (blink · ++ ·) [])</code> is replaced with <code>blinkAll</code>, the language server would crash. (Actually, it crashes when <code>n := 20</code>.)</p>\n<p>What did Lean 4 do to make foldr mysteriously faster than hand-written recursion?</p>",
        "id": 488049807,
        "sender_full_name": "Paro",
        "timestamp": 1733908547
    },
    {
        "content": "<p>Lean defines an optimized version of <code>List.foldr</code> based on <code>Array</code> and tells the compiler to use that instead of the naive <code>foldr</code> implementation. You can see this redefinition here: <a href=\"https://github.com/leanprover/lean4/blob/ffac974dba799956a97d63ffcb13a774f700149c/src/Init/Data/List/Impl.lean#L90-L94\">https://github.com/leanprover/lean4/blob/ffac974dba799956a97d63ffcb13a774f700149c/src/Init/Data/List/Impl.lean#L90-L94</a> The <code>@[csimp]</code> attribute tells the compiler to use <code>List.foldrTR</code> instead when encountering a call to <code>List.foldr</code>. Digging a little deeper, you will find that <code>List.foldrTR</code> eventually calls <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Array.foldrM#doc\">docs#Array.foldrM</a>, which has an <code>implemented_by</code> attribute. <code>implemented_by</code> is basically the unsafe version of <code>csimp</code>, and so the compiler will actually invoke <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Array.foldrMUnsafe#doc\">docs#Array.foldrMUnsafe</a>, which is even more optimized.</p>",
        "id": 488051706,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1733909117
    },
    {
        "content": "<p>Wait, so <code>List.foldr</code> actually copies the whole list into an array, then folds over that? I feel like this should be mentioned more prominently, ideally in the <code>foldr</code> docstring.</p>",
        "id": 488056110,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1733910498
    },
    {
        "content": "<p>Depends what you mean by \"actually\". :-)</p>",
        "id": 488074172,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1733916385
    },
    {
        "content": "<p>But also, do compile your code into a binary if you care about performance</p>",
        "id": 488086059,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1733920162
    }
]