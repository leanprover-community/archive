[
    {
        "content": "<p>Hi, I haven't had a lot of time to work on Lean recently because of PhD-duties, but I'm slowly trying to orient myself on possible research topics to proceed from there, and I was wondering what the status is for the following problem, or if anyone has any thoughts on it, as it is something I may consider working on in the future. Let's begin with a hypothetical situation:</p>\n<p>Suppose I have a lemma <code>lem1</code> that establishes <code>f(n) = O(g(n))</code> and a lemma <code>lem2</code> that establishes <code>g(n) = O(h(n))</code>. From this, I can derive my <code>my_theorem</code>, <code>f(n) = O(h(n))</code>. </p>\n<p>Now suppose that I'm interested in getting explicit constants for <code>f(n) = O(h(n))</code>: I might begin by getting constants for both lemmata, <code>lem1_ex</code> and <code>lem2_ex</code> and then combining them to get a constant for <code>my_theorem_ex</code>, a version of <code>my_theorem</code> with explicit constants. After a while, someone might refine the constant in <code>lem1_ex</code>, which means that I might be able to improve on my constant for <code>my_theorem_ex</code> (and probably breaking its proof). With only few lemmata, we may keep track of any such changes and reasonably expect and breaks to proofs to be fixed, but with many lemmata, it would be nice to have an automated way of doing this. </p>\n<p>You could argue that the proof <code>my_theorem_ex</code> would largely follow the proof <code>my_theorem</code>, so I'm wondering if there is a way to use some automation in such a way that 'explicit' versions of results follow easily from their non-explicit versions? </p>\n<p>The current picture I have is the following: for any basic 'implicit' theorems, register (with some tagging mechanism) (an) explicit version(s) (such as <code>lem1_ex</code> and <code>lem2_ex</code> above). To then compute a constant for <code>my_theorem_ex</code>, we use an extensible macro (e.g. called <code>explicit</code>) that reads the proof of <code>my_theorem</code> and replaces all implicit versions of results called by explicit versions. I understand that this is still vague, and to make reasoning go through, we will probably need to add some additional information to <code>my_theorem</code>, but I hope I get the message across. </p>\n<p>So, my questions are:</p>\n<ol>\n<li>Do we have this?</li>\n<li>If we do not have this, do we want this?</li>\n<li>If we want this, would the above approach (on a very abstract level) be a desirable approach, or would you say alternative methods are preferable?</li>\n</ol>",
        "id": 503202882,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1741075515
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> and I have been experimenting with a slightly different approach, which is to make every single constant that appears in a statement its own <code>def</code>. In your example, it would look like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">lem1Const</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">lem1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀ᶠ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">atTop</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">‖</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">‖</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">lem1Const</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">‖</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">‖</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">lem2Const</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">lem2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀ᶠ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">atTop</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">‖</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">‖</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">lem2Const</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">‖</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">‖</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">myTheoremConst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">lem1Const</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">lem2Const</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">my_theorem</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀ᶠ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">atTop</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">‖</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">‖</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">myTheoremConst</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">‖</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">‖</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 503226739,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1741082937
    },
    {
        "content": "<p>And now you can prove results about <code>myTheoremConst</code> like <code>myTheoremConst &lt; 1000</code></p>",
        "id": 503226857,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1741082974
    },
    {
        "content": "<p>I didn't think about using constants yet, that indeed seems like a very elegant approach to the problem where you would not really need a lot of automation. Perhaps you'd want to have a lemma <code>pretty_myTheoremConst</code> which shows that <code>myTheoremConst = somePrettyExpression</code> (at a given state of <code>lem1Const</code> and <code>lem2Const</code>), where this lemma would now need updating once the constants involved change, but that seems manageable (and perhaps amenable to some automatisation)</p>",
        "id": 503238846,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1741086581
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"673728\">Josha Dekker</span> <a href=\"#narrow/channel/113488-general/topic/Explicit.20constants.2Frates/near/503238846\">said</a>:</p>\n<blockquote>\n<p>Perhaps you'd want to have a lemma <code>pretty_myTheoremConst</code> which shows that <code>myTheoremConst = somePrettyExpression</code> (at a given state of <code>lem1Const</code> and <code>lem2Const</code>), where this lemma would now need updating once the constants involved change</p>\n</blockquote>\n<p>Part of Bhavik and I's approach is that you should <strong>not</strong> do that, because it exposes the definition of the constant (and encourages downstream users to access it). Instead, you should only prove results of the form <code>const ≤ some_explicit_expr</code> (or <code>≥</code>, depending on the constant): if ever you lower <code>const</code>, the proof of those results will break, but the statement will remain unchanged (you <em>could</em> change the statement to a stronger form, but I don't think you <em>should</em>. Write a new statement instead)</p>",
        "id": 503239679,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1741086785
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/113488-general/topic/Explicit.20constants.2Frates/near/503239679\">said</a>:</p>\n<blockquote>\n<p>it exposes the definition of the constant (and encourages downstream users to access it)</p>\n</blockquote>\n<p>In fact, I would go as far as saying that <code>const</code> should be an <code>irreducible_def</code></p>",
        "id": 503240148,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1741086915
    },
    {
        "content": "<p>I think this idea came from the Carleson project, actually!</p>",
        "id": 503293908,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1741101526
    },
    {
        "content": "<p>Note that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Asymptotics.isBigOWith_iff#doc\">docs#Asymptotics.isBigOWith_iff</a> tells you that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Asymptotics.IsBigOWith#doc\">docs#Asymptotics.IsBigOWith</a> might give you a nice way to spell your statement</p>",
        "id": 503294079,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1741101564
    }
]