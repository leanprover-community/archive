[
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">NonemptyList</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">PSigma</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">list</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">list</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"o\">[])</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">nextUncontainedString</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NonemptyList</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">String</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_⟩</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">isPrefixOf</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">toList</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">toList</span>\n<span class=\"w\">                              </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">nextUncontainedString</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"bp\">⟩</span>\n<span class=\"w\">                              </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">nextUncontainedString</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"o\">([</span><span class=\"n\">x</span><span class=\"o\">]),</span><span class=\"w\"> </span><span class=\"bp\">_⟩</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"n\">termination_by</span><span class=\"w\"> </span><span class=\"n\">nel</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">nel</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">l</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_⟩</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">length</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">MemberOfList</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">PSigma</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>The above isn't in <code>theorem</code> format because I'm trying to use these to write a dependently-typed application. Now, I'm trying to write the function</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">memFromNextUncontainedString</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">nel</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NonemptyList</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">MemberOfList</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"n\">nel</span><span class=\"bp\">.</span><span class=\"n\">fst</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nel</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">PSigma</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">nextUncontainedString</span><span class=\"w\"> </span><span class=\"n\">nel</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">proof</span>\n<span class=\"w\">  </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"n\">proof</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Is the only approach to <code>proof</code> here to use <code>by rw [nextUncontainedString.eq_def]</code> then repeatedly <code>split</code> until all cases are covered?</p>\n<p>context: this is a lemma for a function <code>def filterOutNonMaximalWrtStringInclusion : Nonemptylist String -&gt; Nonemptylist String</code> that filters out all members of the list that are not maximal wrt string prefix inclusion (so <code>[\"/my/path\", \"/another/path\", \"/my/path/with/more\"]</code> is transformed to <code>[\"/another/path\", \"/my/path/with/more\"]</code>)</p>",
        "id": 481319001,
        "sender_full_name": "nrs",
        "timestamp": 1731073997
    },
    {
        "content": "<p>hm, I think working with something similar to</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">NonemptyList'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">first</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">NonemptyList'</span><span class=\"w\"> </span><span class=\"n\">A</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">NonemptyList'</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">NonemptyList'</span><span class=\"w\"> </span><span class=\"n\">A</span>\n</code></pre></div>\n<p>would make the workflow more natural here, but this probably throws away much of the work on Lists in the ecosystem</p>",
        "id": 481356586,
        "sender_full_name": "nrs",
        "timestamp": 1731086560
    },
    {
        "content": "<p>Is there a reason you're using PSigma instead of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Subtype#doc\">docs#Subtype</a> ?</p>",
        "id": 481359539,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1731087834
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"690858\">Daniel Weber</span> <a href=\"#narrow/channel/113488-general/topic/x.20.E2.88.88.20list.20.2B.20maximal.20wrt.20string.20inclusion.20implies.20x.20.E2.88.88.20list/near/481359539\">said</a>:</p>\n<blockquote>\n<p>Is there a reason you're using PSigma instead of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Subtype#doc\">docs#Subtype</a> ?</p>\n</blockquote>\n<p>None at all, just to remind myself that <code>Subtype</code> is a special kind of sigma type. Will adopt it if it it makes easier it to prove properties</p>",
        "id": 481359939,
        "sender_full_name": "nrs",
        "timestamp": 1731088006
    },
    {
        "content": "<p>edit: thought I had an answer, but it is wrong</p>",
        "id": 481368400,
        "sender_full_name": "nrs",
        "timestamp": 1731091491
    },
    {
        "content": "<p>Generally for something like this it is much easy to write your definitions just in terms of List, then prove after the fact that if the input is nonempty the output is nonempty.</p>",
        "id": 481411451,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1731114041
    },
    {
        "content": "<p>Moreover generality is your friend, you could write a <code>filterMaximal</code> for any type with <code>LT</code>, then specialize that to string prefix order.</p>",
        "id": 481411620,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1731114136
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/channel/113488-general/topic/x.20.E2.88.88.20list.20.2B.20maximal.20wrt.20string.20inclusion.20implies.20x.20.E2.88.88.20list/near/481411451\">said</a>:</p>\n<blockquote>\n<p>Generally for something like this it is much easy to write your definitions just in terms of List, then prove after the fact that if the input is nonempty the output is nonempty.</p>\n</blockquote>\n<p>These are great suggestions! tyvm for the help</p>",
        "id": 481464126,
        "sender_full_name": "nrs",
        "timestamp": 1731161450
    }
]