[
    {
        "content": "<p>I've been experimenting for a while on how to enable entirely automated proofs for this LLVM rewrites formalisation project I've been working on. I have been working with definitions of LLVM integers as so:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">iN</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bits</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">bitvec</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"n\">bits</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">iN</span><span class=\"w\"> </span><span class=\"n\">bits</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">poison</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">iN</span><span class=\"w\"> </span><span class=\"n\">bits</span>\n\n<span class=\"kn\">export</span><span class=\"w\"> </span><span class=\"n\">iN</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">poison</span><span class=\"w\"> </span><span class=\"n\">bitvec</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">`Rewrite x y` means the value `x` can be rewritten into the value `y`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Rewrite</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">iN</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">iN</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- A value rewrites to itself. -/</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">iN</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Rewrite</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- Poison can be rewritten into any concrete value. -/</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">poison_forge</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Rewrite</span><span class=\"w\"> </span><span class=\"n\">poison</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bitvec</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>These are easily amenable to proof, and easy to read. The <code>Rewrite</code> relation encodes the semantics of valid coercions.</p>\n<p>However, it is impossible to be used with <code>bv_decide</code>, as the constructors <code>poison</code> and <code>bitvec</code> need to be removed from the expression:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">addNsw_assoc</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">iN</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">iN</span><span class=\"bp\">.</span><span class=\"n\">addNsw</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">~&gt;</span><span class=\"w\"> </span><span class=\"n\">iN</span><span class=\"bp\">.</span><span class=\"n\">addNsw</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- this simp would be automated</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">iN</span><span class=\"bp\">.</span><span class=\"n\">addNsw</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">iN</span><span class=\"bp\">.</span><span class=\"n\">poisonWrapper</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">iN</span><span class=\"bp\">.</span><span class=\"n\">addNswBV</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">iN</span><span class=\"bp\">.</span><span class=\"n\">poisonPreconditions</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"c\">/-</span>\n<span class=\"cm\">  n : Nat</span>\n<span class=\"cm\">  x y : iN n</span>\n<span class=\"cm\">  ⊢ (match x, y with</span>\n<span class=\"cm\">    | poison, x =&gt; poison</span>\n<span class=\"cm\">    | x, poison =&gt; poison</span>\n<span class=\"cm\">    | bitvec a, bitvec b =&gt; if a.saddOverflow b = true then poison else bitvec (a + b)) ~&gt;</span>\n<span class=\"cm\">    match y, x with</span>\n<span class=\"cm\">    | poison, x =&gt; poison</span>\n<span class=\"cm\">    | x, poison =&gt; poison</span>\n<span class=\"cm\">    | bitvec a, bitvec b =&gt; if a.saddOverflow b = true then poison else bitvec (a + b)</span>\n<span class=\"cm\">  -/</span>\n<span class=\"w\">  </span><span class=\"n\">bv_decide</span>\n<span class=\"w\">  </span><span class=\"c1\">-- None of the hypotheses are in the supported</span>\n<span class=\"w\">  </span><span class=\"c1\">-- BitVec fragment after applying preprocessing.</span>\n</code></pre></div>\n<p>Even if I were to introduce simplifiers that would take away all these match cases and leave only <code>BitVec</code> operations, which I have, it still wouldn't be able to bitblast, because the goal contains <code>iN</code> from the inputs and hence needs to be matched anyway. So in all cases, I'm always left with the inputs being unable to simplify down. Either I change my definitions (1), or find some way to transform the goal and have it replaced (2).</p>\n<p>(Below at the end of the post, I have attached MWEs for the pattern match definition of <code>iN</code>, and the bitwise version of <code>iN</code>.)</p>\n<p>So I thought to myself that I should change my definitions (1), to allow it to be easily bitblasted, I did so and ended up with:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">iN</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bits</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"n\">bitvec</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"n\">bits</span>\n<span class=\"w\">  </span><span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"n\">poison</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">poison</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">iN</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"bp\">⟩</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">bitvec</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">iN</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">value</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"bp\">⟩</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">`Rewrite x y` means the value `x` can be rewritten into the value `y`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Rewrite</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">iN</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"c\">/-</span><span class=\"cm\"> A value rewrites to itself. -/</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"bp\">¬</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">poison</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">poison</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">bitvec</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">bitvec</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∨</span>\n\n<span class=\"w\">  </span><span class=\"c\">/-</span><span class=\"cm\"> (or) Poison can be rewritten into anything. -/</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">poison</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>The <code>Rewrite</code> relation is entirely encoded in propositional logic, and is equivalent. There wasn't much code that needed to be adjusted, other than the <code>match</code> expressions, and so this definition fit in nicely.</p>\n<p>However, I quickly ended up with an unprovable result, due to the fact that I define <code>poison</code> as <code>⟨0, true⟩</code>. This definition doesn't actually encode that a value being poison means that it's concrete value is inaccessible:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">unprovable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">iN</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">poison</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">poison</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">poison</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"bp\">*</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"c\">/-</span>\n<span class=\"cm\">  n : Nat</span>\n<span class=\"cm\">  x : iN n</span>\n<span class=\"cm\">  h : x.poison = true</span>\n<span class=\"cm\">  ⊢ x = { bitvec := 0#n, poison := true }</span>\n<span class=\"cm\">  -/</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>So, I'm back at at (2). I want to know how to convert the goals in terms of <code>iN</code>, to equivalent goals in terms of propositional logic, that would encode <code>poison</code> states faithfully. This would be essentially be \"bitblasting\" these goals, even though there isn't much to change.</p>\n<p>I am quite new to metaprogramming, but know enough to write some basic tactics. I have a general understanding of how you'd want to do this, a proof by reflection taking the goal and reifying it and then having some lemmas about equality of denoted expressions. So far my knowledge is from the article <a href=\"https://timothymou.com/posts/proof-by-reflection-and-why-not-to-use-it/\">Proof by Reflection (and why not to use it)</a> by <span class=\"user-mention\" data-user-id=\"463489\">@Timothy Mou</span>. I have done a cursory read about how <code>bv_decide</code> works and I know it does a similar proof by reflection, but that's all I know. I wanted to ask first to see where people could lead me.</p>\n<p>Could someone offer their experience? I know this is possibly out of the range of what most Lean users do.</p>\n<p>This file is an MWE for the inductive type definition of <code>iN</code>: <a href=\"/user_uploads/3121/XUDfSaD0DUr1hh4cqC1mZFxR/mwe.lean\">mwe.lean</a>. This MWE contains the bitwise definition of <code>iN</code>: <a href=\"/user_uploads/3121/BfptDYhZffMuAzBWFJxPDWpm/mwe2.lean\">mwe2.lean</a>.</p>",
        "id": 539489812,
        "sender_full_name": "l1mey",
        "timestamp": 1757924290
    },
    {
        "content": "<p>Is there at least any material on how to write tactics that transform the goal from one that isn't amenable to automated proof, into one that can? How would you even structure a tactic like that? I've been reading the <code>bv_decide</code> code, and while it isn't exactly related, it is helping me at a slow pace.</p>\n<p>The ability to construct the theorem <code>x ~&gt; y ↔ $(convert x y)</code>, where <code>convert</code> converts the expressions <code>x</code> and <code>y</code> into something that works only on bitvectors would be a big win for me. Then it would allow me to replace the goal with something easier to work on.</p>",
        "id": 540193798,
        "sender_full_name": "l1mey",
        "timestamp": 1758189467
    }
]