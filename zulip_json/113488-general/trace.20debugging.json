[
    {
        "content": "<p>Right now I'm looking at some <code>trace.profiler</code> output in quite a large block of code, and it doesn't add up. I'd like to investigate further. Right now it looks like this in the infoview when I unfold the unique output of the trace profiler:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">Elab.command</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"bp\">.</span><span class=\"mi\">682466</span><span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"sd\">/--</span>\n<span class=\"sd\">    The Hales-Jewett theorem. This version has a restriction on universe levels which is necessary</span>\n<span class=\"sd\">    for the proof. See `exists_mono_in_high_dimension` for a fully universe-polymorphic version. -/</span>\n   <span class=\"bp\">**</span><span class=\"mi\">100</span> <span class=\"n\">lines</span> <span class=\"n\">omitted</span><span class=\"bp\">*</span> <span class=\"bp\">▼</span>\n  <span class=\"o\">[</span><span class=\"n\">Elab.step</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">010713</span><span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"n\">expected</span> <span class=\"n\">type</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">inst</span> <span class=\"o\">:</span> <span class=\"n\">Finite</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">κ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">v</span> <span class=\"n\">u</span><span class=\"o\">))</span><span class=\"bp\">...</span>\n  <span class=\"bp\">**</span><span class=\"n\">pretty</span> <span class=\"n\">much</span> <span class=\"n\">same</span> <span class=\"mi\">100</span> <span class=\"n\">lines</span> <span class=\"n\">omitted</span> <span class=\"bp\">▶</span>\n  <span class=\"o\">[</span><span class=\"n\">Elab.step</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">382477</span><span class=\"n\">s</span><span class=\"o\">]</span>\n   <span class=\"bp\">**</span> <span class=\"n\">etc</span><span class=\"bp\">**</span> <span class=\"bp\">▶</span>\n  <span class=\"o\">[</span><span class=\"n\">Kernel</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">024552</span><span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"n\">typechecking</span> <span class=\"n\">declaration</span>\n</code></pre></div>\n<p>It was stupidly annoying having to check that the smaller numbers didn't add up to the bigger numbers (and I did it all by manual text editor in emacs, I could easily have got it wrong). Is there a way I can just view the top few nodes on the skeleton in a small number of lines as I start changing the proof, in order to further debug?</p>",
        "id": 383042913,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1691518781
    },
    {
        "content": "<p>By \"top\" you mean the slowest ones? If it doesn't add up, we simply may be missing a trace node for a task. Could you check the plain <code>profiler</code> on the declaration as well?</p>",
        "id": 383067667,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1691525284
    },
    {
        "content": "<p>You can still use <a href=\"https://github.com/hargoniX/Flame\">https://github.com/hargoniX/Flame</a> to get a nice overview as well^^</p>",
        "id": 383068771,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1691525601
    },
    {
        "content": "<p>BTW: I also ran into this question <a href=\"#narrow/stream/113488-general/topic/Why.20is.20.60simpNF.60.20complaining.20here.3F/near/379073748\">here</a>.</p>",
        "id": 383081728,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1691529622
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/113488-general/topic/trace.20debugging/near/383068771\">said</a>:</p>\n<blockquote>\n<p>You can still use <a href=\"https://github.com/hargoniX/Flame\">https://github.com/hargoniX/Flame</a> to get a nice overview as well^^</p>\n</blockquote>\n<p>I wrote a command <code>#profile_this_file</code> that automatically compiles the current file with profiler and launches speedscope. I use it all the time.</p>\n<p><a href=\"https://github.com/lecopivo/SciLean/blob/master/SciLean/Profile.lean\">https://github.com/lecopivo/SciLean/blob/master/SciLean/Profile.lean</a></p>\n<p>Just on th6e line 5 change the location of flame on your system.</p>",
        "id": 383087523,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1691531639
    },
    {
        "content": "<p>I have output from Flame in \"collapsed stack format\" here </p>\n<p><a href=\"/user_uploads/3121/GKgZk1YI2k9ILEGBGXW9xotm/out.txt\">out.txt</a></p>\n<p>but have no idea what to do with it. I looked at it using an online viewer -- is it something to do with the unused variables linter? I don't even know what I'm looking at.</p>",
        "id": 383094775,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1691534698
    },
    {
        "content": "<p>Aah, <code>set_option pp.oneline true</code> was what I was looking for earlier I think:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">Elab.command</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"bp\">.</span><span class=\"mi\">126436</span><span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"sd\">/-- The Hales-Jewett theorem. This version has a restriction on universe levels which is necessary [...] ▼</span>\n<span class=\"sd\">  [step] [0.011979s] expected type: ∀ (α : Type u) [inst : Finite α] (κ : Type (max v u)) [inst : Finite κ], [...], term</span>\n<span class=\"sd\">      Finite.induction_empty_option [...] ▶</span>\n<span class=\"sd\">  [step] [0.331203s] intro α _ ihα κ _ [...] ▶</span>\n<span class=\"sd\">  [Kernel] [0.018651s] typechecking declaration</span>\n</code></pre></div>\n<p>My issue is that 0.01+0.33+0.01 is not 3.12.</p>",
        "id": 383095987,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1691535245
    },
    {
        "content": "<p>The subtraces do not cover the parent trace, i.e. there might be more calls beyond <code>step/step/Kernel</code> made during the <code>[Elab.command]</code> step which are not traced. We only get an inequality. It would be worrying if the inequality didn't hold though!</p>",
        "id": 383096312,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1691535441
    },
    {
        "content": "<p>My question is why the HalesJewett file in mathlib is slow. How should I proceed?</p>",
        "id": 383096873,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1691535724
    },
    {
        "content": "<p>Comment it halfway and add a sorry. See if there is a significant change. If not cut that in half. If so add in half of what was left out.</p>",
        "id": 383097200,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1691535888
    },
    {
        "content": "<p>I have been trying to do that for literally hours. It's really hard. <code>extract_goal</code> needs some work.</p>",
        "id": 383097256,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1691535929
    },
    {
        "content": "<p>I don't understand the mathematics at all, this is one of the issues.</p>",
        "id": 383097306,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1691535960
    },
    {
        "content": "<p>The profiler says</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">tactic</span> <span class=\"n\">execution</span> <span class=\"n\">of</span> <span class=\"n\">Lean.Parser.Tactic.rewriteSeq</span> <span class=\"n\">took</span> <span class=\"mi\">124</span><span class=\"n\">ms</span>\n<span class=\"n\">linting</span> <span class=\"n\">took</span> <span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"mi\">74</span><span class=\"n\">s</span>\n<span class=\"n\">elaboration</span> <span class=\"n\">took</span> <span class=\"mi\">3</span><span class=\"bp\">.</span><span class=\"mi\">07</span><span class=\"n\">s</span>\n</code></pre></div>\n<p>So it is the unused variables linter?</p>",
        "id": 383098087,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1691536379
    },
    {
        "content": "<p>If I sorry any of the goals from the last <code>refine</code>, it is pretty snappy. There must be somethings being postponed and unified at the completion of the proof.</p>",
        "id": 383098205,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1691536457
    },
    {
        "content": "<p>Beyond some point </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"n\">refine'</span> <span class=\"n\">Or.inl</span> <span class=\"o\">⟨⟨(</span><span class=\"n\">s.lines.map</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"o\">⟨(</span><span class=\"n\">l'.map</span> <span class=\"n\">some</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">vertical</span> <span class=\"n\">s.focus</span><span class=\"o\">,</span> <span class=\"n\">C'</span> <span class=\"n\">s.focus</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n            <span class=\"n\">Sum.elim</span> <span class=\"n\">s.focus</span> <span class=\"o\">(</span><span class=\"n\">l'.map</span> <span class=\"n\">some</span> <span class=\"n\">none</span><span class=\"o\">),</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>stopped working for me</p>",
        "id": 383098887,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1691536835
    },
    {
        "content": "<p>there was some unification issue which I couldn't resolve</p>",
        "id": 383098966,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1691536877
    },
    {
        "content": "<p>There are some benchmark results in this file that I would like to understand better: between the merges of <a href=\"https://github.com/leanprover-community/mathlib4/pull/6256\">#6256</a> and <a href=\"https://github.com/leanprover-community/mathlib4/pull/5998\">#5998</a> VelCom reports an increase from 44M to 58M instructions, then between <a href=\"https://github.com/leanprover-community/mathlib4/pull/6395\">#6395</a> and <a href=\"https://github.com/leanprover-community/mathlib4/pull/6441\">#6441</a> it goes down to 48M instructions. I can't figure out what would cause either change: in the first range I don't see a commit that would obviously affect the build times, while in the second range we have <a href=\"https://github.com/leanprover-community/mathlib4/pull/6145\">#6145</a> which reports a benchmark <strong>increase</strong>.</p>",
        "id": 383191435,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1691570235
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span>, would you be willing to prioritize benchmarking <a href=\"http://speedcenter.informatik.kit.edu/mathlib4/run-detail/e7b27246-a3e6-496a-b552-ff4b45c7236e/1accbf5b66031155d16edae730d6d4b623f48c40\">1accb5fb</a>?</p>",
        "id": 383192513,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1691570476
    },
    {
        "content": "<p>Done</p>",
        "id": 383193222,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1691570609
    },
    {
        "content": "<p>Thank you!</p>",
        "id": 383193266,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1691570619
    },
    {
        "content": "<p>The instructions counts have been very reliable so far, if they cease to do that, that would be worrying. I think the next step there would be for someone to reproduce those timings on their own machine (requires Linux <code>perf stat</code>)</p>",
        "id": 383193522,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1691570669
    },
    {
        "content": "<p>I can also rerun the commit with the unexpected rise but of course that's two more hours of queueing</p>",
        "id": 383193826,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1691570734
    },
    {
        "content": "<p>My hypothesis is that the instruction counts are accurate (they seem to be reliable across commits that don't affect the imported files, at least) and we just don't know what subtle thing causes them to go up and down so much.</p>",
        "id": 383194400,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1691570860
    },
    {
        "content": "<p>Here's my latest attempt at splitting up the slow proof. Splitting <code>key</code> off made the whole thing go from 9s to 7s + 0.2s. Splitting off <code>refine</code> as well made it go to 2s + 0.2s + 0.2s. This is similar to, but less dramatic than, what I saw with <code>ClassGroup</code>, where the speedup seemed to be in hiding a big expression behind a <code>def</code> so it wouldn't get unfolded in the rest of the proof. Maybe something similar is going on here?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">set_option</span> <span class=\"n\">trace.profiler</span> <span class=\"n\">true</span>\n\n<span class=\"c1\">-- ~2s</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">exists_mono_in_high_dimension'.refine</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">κ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">v</span> <span class=\"n\">u</span><span class=\"o\">))</span>\n    <span class=\"o\">[</span><span class=\"n\">Nonempty</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"n\">ι'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"bp\">⊕</span> <span class=\"n\">ι'</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">κ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l'</span> <span class=\"o\">:</span> <span class=\"n\">Line</span> <span class=\"n\">α</span> <span class=\"n\">ι'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">C'</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">κ</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hl'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">v'</span> <span class=\"n\">v</span> <span class=\"bp\">↦</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">Sum.elim</span> <span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"bp\">∘</span> <span class=\"n\">v'</span><span class=\"o\">)))</span> <span class=\"o\">((</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">i</span> <span class=\"bp\">↦</span> <span class=\"n\">Option.getD</span> <span class=\"o\">(</span><span class=\"n\">idxFun</span> <span class=\"n\">l'</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">C'</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ColorFocused</span> <span class=\"n\">C'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sr</span> <span class=\"o\">:</span> <span class=\"n\">Multiset.card</span> <span class=\"n\">s.lines</span> <span class=\"bp\">=</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">¬∃</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">s.lines</span> <span class=\"bp\">∧</span> <span class=\"n\">p.color</span> <span class=\"bp\">=</span> <span class=\"n\">C'</span> <span class=\"n\">s.focus</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ColorFocused</span> <span class=\"n\">C</span><span class=\"o\">),</span> <span class=\"n\">Multiset.card</span> <span class=\"n\">s.lines</span> <span class=\"bp\">=</span> <span class=\"n\">Nat.succ</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"bp\">∃</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">IsMono</span> <span class=\"n\">C</span> <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine'</span> <span class=\"n\">Or.inl</span> <span class=\"o\">⟨⟨(</span><span class=\"n\">s.lines.map</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"o\">⟨(</span><span class=\"n\">l'.map</span> <span class=\"n\">some</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">vertical</span> <span class=\"n\">s.focus</span><span class=\"o\">,</span> <span class=\"n\">C'</span> <span class=\"n\">s.focus</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n          <span class=\"n\">Sum.elim</span> <span class=\"n\">s.focus</span> <span class=\"o\">(</span><span class=\"n\">l'.map</span> <span class=\"n\">some</span> <span class=\"n\">none</span><span class=\"o\">),</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n  <span class=\"c1\">-- Porting note: Needed to reorder the following two goals</span>\n  <span class=\"c1\">-- The product lines are almost monochromatic.</span>\n  <span class=\"bp\">·</span> <span class=\"n\">refine'</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">p.line.prod</span> <span class=\"o\">(</span><span class=\"n\">l'.map</span> <span class=\"n\">some</span><span class=\"o\">),</span> <span class=\"n\">p.color</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Line.prod_apply</span><span class=\"o\">,</span> <span class=\"n\">Line.map_apply</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">p.has_color</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">congr_fun</span> <span class=\"o\">(</span><span class=\"n\">hl'</span> <span class=\"n\">x</span><span class=\"o\">)]</span>\n  <span class=\"c1\">-- The vertical line is almost monochromatic.</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">vertical_apply</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">congr_fun</span> <span class=\"o\">(</span><span class=\"n\">hl'</span> <span class=\"n\">x</span><span class=\"o\">),</span> <span class=\"n\">Line.map_apply</span><span class=\"o\">]</span>\n  <span class=\"c1\">-- Our `r+1` lines have the same endpoint.</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">Multiset.mem_cons</span><span class=\"o\">,</span> <span class=\"n\">Multiset.mem_map</span><span class=\"o\">]</span>\n    <span class=\"n\">rintro</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">rfl</span> <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"n\">hq</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩)</span>\n    <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">vertical_apply</span><span class=\"o\">]</span>\n    <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">prod_apply</span><span class=\"o\">,</span> <span class=\"n\">s.is_focused</span> <span class=\"n\">q</span> <span class=\"n\">hq</span><span class=\"o\">]</span>\n  <span class=\"c1\">-- Our `r+1` lines have distinct colors (this is why we needed to split into cases above).</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Multiset.map_cons</span><span class=\"o\">,</span> <span class=\"n\">Multiset.map_map</span><span class=\"o\">,</span> <span class=\"n\">Multiset.nodup_cons</span><span class=\"o\">,</span> <span class=\"n\">Multiset.mem_map</span><span class=\"o\">]</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"n\">hq</span><span class=\"o\">,</span> <span class=\"n\">he</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h</span> <span class=\"o\">⟨</span><span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"n\">hq</span><span class=\"o\">,</span> <span class=\"n\">he</span><span class=\"o\">⟩,</span> <span class=\"n\">s.distinct_colors</span><span class=\"o\">⟩</span>\n  <span class=\"c1\">-- Finally, we really do have `r+1` lines!</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Multiset.card_cons</span><span class=\"o\">,</span> <span class=\"n\">Multiset.card_map</span><span class=\"o\">,</span> <span class=\"n\">sr</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- ~ 0.2s</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">exists_mono_in_high_dimension'.key</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">ihα</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">κ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">v</span> <span class=\"n\">u</span><span class=\"o\">))</span> <span class=\"o\">[</span><span class=\"n\">Finite</span> <span class=\"n\">κ</span><span class=\"o\">],</span>\n      <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_x</span> <span class=\"o\">:</span> <span class=\"n\">Fintype</span> <span class=\"n\">ι</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">κ</span><span class=\"o\">),</span> <span class=\"bp\">∃</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">IsMono</span> <span class=\"n\">C</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">κ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">v</span> <span class=\"n\">u</span><span class=\"o\">))</span>\n    <span class=\"o\">[</span><span class=\"n\">inst</span> <span class=\"o\">:</span> <span class=\"n\">Fintype</span> <span class=\"n\">κ</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Nonempty</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_x</span> <span class=\"o\">:</span> <span class=\"n\">Fintype</span> <span class=\"n\">ι</span><span class=\"o\">),</span>\n      <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">κ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ColorFocused</span> <span class=\"n\">C</span><span class=\"o\">),</span> <span class=\"n\">Multiset.card</span> <span class=\"n\">s.lines</span> <span class=\"bp\">=</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"bp\">∃</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">IsMono</span> <span class=\"n\">C</span> <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction'</span> <span class=\"n\">r</span> <span class=\"k\">with</span> <span class=\"n\">r</span> <span class=\"n\">ihr</span>\n  <span class=\"c1\">-- The base case `r = 0` is trivial as the empty collection is color-focused.</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">PEmpty</span><span class=\"o\">,</span> <span class=\"n\">inferInstance</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">C</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Or.inl</span> <span class=\"o\">⟨</span><span class=\"n\">default</span><span class=\"o\">,</span> <span class=\"n\">Multiset.card_zero</span><span class=\"o\">⟩⟩</span>\n  <span class=\"c1\">-- Supposing the key claim holds for `r`, we need to show it for `r+1`. First pick a high</span>\n  <span class=\"c1\">-- enough dimension `ι` for `r`.</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"n\">_inst</span><span class=\"o\">,</span> <span class=\"n\">hι</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">ihr</span>\n  <span class=\"c1\">-- Then since the theorem holds for `α` with any number of colors, pick a dimension `ι'` such</span>\n  <span class=\"c1\">-- that `ι' → α` always has a monochromatic line whenever it is `(ι → Option α) → κ`-colored.</span>\n  <span class=\"c1\">-- have : Finite ((ι → Option α) → κ) := Fintype.finite (@Pi.fintype _ _ _ _ _)</span>\n  <span class=\"n\">specialize</span> <span class=\"n\">ihα</span> <span class=\"o\">((</span><span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">κ</span><span class=\"o\">)</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">ι'</span><span class=\"o\">,</span> <span class=\"n\">_inst</span><span class=\"o\">,</span> <span class=\"n\">hι'</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">ihα</span>\n  <span class=\"c1\">-- We claim that `ι ⊕ ι'` works for `Option α` and `κ`-coloring.</span>\n  <span class=\"n\">refine'</span> <span class=\"o\">⟨</span><span class=\"n\">Sum</span> <span class=\"n\">ι</span> <span class=\"n\">ι'</span><span class=\"o\">,</span> <span class=\"n\">inferInstance</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n  <span class=\"n\">intro</span> <span class=\"n\">C</span>\n  <span class=\"c1\">-- A `κ`-coloring of `ι ⊕ ι' → Option α` induces an `(ι → Option α) → κ`-coloring of `ι' → α`.</span>\n  <span class=\"n\">specialize</span> <span class=\"n\">hι'</span> <span class=\"k\">fun</span> <span class=\"n\">v'</span> <span class=\"n\">v</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">Sum.elim</span> <span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"bp\">∘</span> <span class=\"n\">v'</span><span class=\"o\">))</span>\n  <span class=\"c1\">-- By choice of `ι'` this coloring has a monochromatic line `l'` with color class `C'`, where</span>\n  <span class=\"c1\">-- `C'` is a `κ`-coloring of `ι → α`.</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">l'</span><span class=\"o\">,</span> <span class=\"n\">C'</span><span class=\"o\">,</span> <span class=\"n\">hl'</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hι'</span>\n  <span class=\"c1\">-- If `C'` has a monochromatic line, then so does `C`. We use this in two places below.</span>\n  <span class=\"k\">have</span> <span class=\"n\">mono_of_mono</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">IsMono</span> <span class=\"n\">C'</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">IsMono</span> <span class=\"n\">C</span> <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">hl</span><span class=\"o\">⟩</span>\n    <span class=\"n\">refine'</span> <span class=\"o\">⟨</span><span class=\"n\">l.horizontal</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"bp\">∘</span> <span class=\"n\">l'</span> <span class=\"o\">(</span><span class=\"n\">Classical.arbitrary</span> <span class=\"n\">α</span><span class=\"o\">)),</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Line.horizontal_apply</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">hl</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">hl'</span><span class=\"o\">]</span>\n  <span class=\"c1\">-- By choice of `ι`, `C'` either has `r` color-focused lines or a monochromatic line.</span>\n  <span class=\"n\">specialize</span> <span class=\"n\">hι</span> <span class=\"n\">C'</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">hι</span> <span class=\"k\">with</span> <span class=\"o\">(⟨</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">sr</span><span class=\"o\">⟩</span> <span class=\"bp\">|</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n  <span class=\"n\">on_goal</span> <span class=\"mi\">2</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"n\">Or.inr</span> <span class=\"o\">(</span><span class=\"n\">mono_of_mono</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n  <span class=\"c1\">-- Here we assume `C'` has `r` color focused lines. We split into cases depending on whether</span>\n  <span class=\"c1\">-- one of these `r` lines has the same color as the focus point.</span>\n  <span class=\"n\">by_cases</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">s.lines</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">AlmostMono</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">color</span> <span class=\"bp\">=</span> <span class=\"n\">C'</span> <span class=\"n\">s.focus</span>\n  <span class=\"c1\">-- If so then this is a `C'`-monochromatic line and we are done.</span>\n  <span class=\"bp\">·</span> <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">p_mem</span><span class=\"o\">,</span> <span class=\"n\">hp</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h</span>\n    <span class=\"n\">refine'</span> <span class=\"n\">Or.inr</span> <span class=\"o\">(</span><span class=\"n\">mono_of_mono</span> <span class=\"o\">⟨</span><span class=\"n\">p.line</span><span class=\"o\">,</span> <span class=\"n\">p.color</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩)</span>\n    <span class=\"n\">rintro</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hp</span><span class=\"o\">,</span> <span class=\"n\">s.is_focused</span> <span class=\"n\">p</span> <span class=\"n\">p_mem</span><span class=\"o\">]</span>\n    <span class=\"n\">apply</span> <span class=\"n\">p.has_color</span>\n  <span class=\"c1\">-- If not, we get `r+1` color focused lines by taking the product of the `r` lines with `l'`</span>\n  <span class=\"c1\">-- and adding to this the vertical line obtained by the focus point and `l`.</span>\n  <span class=\"n\">exact</span> <span class=\"n\">Combinatorics.Line.exists_mono_in_high_dimension'.refine.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">κ</span> <span class=\"n\">r</span> <span class=\"n\">ι</span> <span class=\"n\">ι'</span> <span class=\"n\">C</span> <span class=\"n\">l'</span> <span class=\"n\">C'</span> <span class=\"n\">hl'</span> <span class=\"n\">s</span> <span class=\"n\">sr</span> <span class=\"n\">h</span>\n\n<span class=\"c1\">-- ~ 0.2s</span>\n<span class=\"sd\">/-- The Hales-Jewett theorem. This version has a restriction on universe levels which is necessary</span>\n<span class=\"sd\">for the proof. See `exists_mono_in_high_dimension` for a fully universe-polymorphic version. -/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">exists_mono_in_high_dimension'</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Finite</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">κ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">max</span> <span class=\"n\">v</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Finite</span> <span class=\"n\">κ</span><span class=\"o\">],</span>\n      <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Fintype</span> <span class=\"n\">ι</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">κ</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">Line</span> <span class=\"n\">α</span> <span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"n\">l.IsMono</span> <span class=\"n\">C</span> <span class=\"o\">:=</span>\n<span class=\"c1\">-- The proof proceeds by induction on `α`.</span>\n  <span class=\"n\">Finite.induction_empty_option</span>\n  <span class=\"o\">(</span><span class=\"c1\">-- We have to show that the theorem is invariant under `α ≃ α'` for the induction to work.</span>\n  <span class=\"k\">fun</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">α'</span><span class=\"o\">}</span> <span class=\"n\">e</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">forall_imp</span> <span class=\"k\">fun</span> <span class=\"n\">κ</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">forall_imp</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"n\">Exists.imp</span> <span class=\"k\">fun</span> <span class=\"n\">ι</span> <span class=\"bp\">=&gt;</span>\n          <span class=\"n\">Exists.imp</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">h</span> <span class=\"n\">C</span> <span class=\"bp\">=&gt;</span>\n            <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">lc</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h</span> <span class=\"k\">fun</span> <span class=\"n\">v</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"bp\">∘</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n            <span class=\"o\">⟨</span><span class=\"n\">l.map</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">e.forall_congr_left.mp</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">lc</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">Line.map_apply</span><span class=\"o\">]⟩)</span>\n  <span class=\"o\">(</span><span class=\"kd\">by</span>\n    <span class=\"c1\">-- This deals with the degenerate case where `α` is empty.</span>\n    <span class=\"n\">intro</span> <span class=\"n\">κ</span> <span class=\"n\">_</span>\n    <span class=\"n\">by_cases</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Nonempty</span> <span class=\"n\">κ</span>\n    <span class=\"bp\">·</span> <span class=\"n\">refine'</span> <span class=\"o\">⟨</span><span class=\"n\">Unit</span><span class=\"o\">,</span> <span class=\"n\">inferInstance</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">C</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">default</span><span class=\"o\">,</span> <span class=\"n\">Classical.arbitrary</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">PEmpty.rec</span><span class=\"o\">⟩⟩</span>\n    <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">Empty</span><span class=\"o\">,</span> <span class=\"n\">inferInstance</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">C</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">⟨</span><span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">Empty.rec</span><span class=\"o\">)⟩)</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"o\">⟩)</span>\n  <span class=\"o\">(</span><span class=\"kd\">by</span>\n    <span class=\"c1\">-- Now we have to show that the theorem holds for `Option α` if it holds for `α`.</span>\n    <span class=\"n\">intro</span> <span class=\"n\">α</span> <span class=\"n\">_</span> <span class=\"n\">ihα</span> <span class=\"n\">κ</span> <span class=\"n\">_</span>\n    <span class=\"n\">cases</span> <span class=\"n\">nonempty_fintype</span> <span class=\"n\">κ</span>\n    <span class=\"c1\">-- Later we'll need `α` to be nonempty. So we first deal with the trivial case where `α` is</span>\n    <span class=\"c1\">-- empty.</span>\n    <span class=\"c1\">-- Then `Option α` has only one element, so any line is monochromatic.</span>\n    <span class=\"n\">by_cases</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Nonempty</span> <span class=\"n\">α</span>\n    <span class=\"n\">case</span> <span class=\"n\">neg</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">refine'</span> <span class=\"o\">⟨</span><span class=\"n\">Unit</span><span class=\"o\">,</span> <span class=\"n\">inferInstance</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">C</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">diagonal</span> <span class=\"n\">_</span> <span class=\"n\">Unit</span><span class=\"o\">,</span> <span class=\"n\">C</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span><span class=\"o\">,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩⟩</span>\n      <span class=\"n\">rintro</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">⟩)</span>\n      <span class=\"bp\">·</span> <span class=\"n\">rfl</span>\n      <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">⟩)</span><span class=\"bp\">.</span><span class=\"n\">elim</span>\n    <span class=\"c1\">-- The key idea is to show that for every `r`, in high dimension we can either find</span>\n    <span class=\"c1\">-- `r` color focused lines or a monochromatic line.</span>\n    <span class=\"k\">suffices</span> <span class=\"n\">key</span> <span class=\"o\">:</span>\n      <span class=\"bp\">∀</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span>\n        <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Fintype</span> <span class=\"n\">ι</span><span class=\"o\">),</span>\n          <span class=\"bp\">∀</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">κ</span><span class=\"o\">,</span>\n            <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ColorFocused</span> <span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"n\">Multiset.card</span> <span class=\"n\">s.lines</span> <span class=\"bp\">=</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"bp\">∃</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">IsMono</span> <span class=\"n\">C</span> <span class=\"n\">l</span>\n    <span class=\"c1\">-- Given the key claim, we simply take `r = |κ| + 1`. We cannot have this many distinct colors</span>\n    <span class=\"c1\">-- so we must be in the second case, where there is a monochromatic line.</span>\n    <span class=\"bp\">·</span> <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"n\">_inst</span><span class=\"o\">,</span> <span class=\"n\">hι</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">key</span> <span class=\"o\">(</span><span class=\"n\">Fintype.card</span> <span class=\"n\">κ</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n      <span class=\"n\">refine'</span> <span class=\"o\">⟨</span><span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"n\">_inst</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">C</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">hι</span> <span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">resolve_left</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n      <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">sr</span><span class=\"o\">⟩</span>\n      <span class=\"n\">apply</span> <span class=\"n\">Nat.not_succ_le_self</span> <span class=\"o\">(</span><span class=\"n\">Fintype.card</span> <span class=\"n\">κ</span><span class=\"o\">)</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Nat.add_one</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">sr</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">Multiset.card_map</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">Finset.card_mk</span><span class=\"o\">]</span>\n      <span class=\"n\">exact</span> <span class=\"n\">Finset.card_le_univ</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">s.distinct_colors</span><span class=\"o\">⟩</span>\n    <span class=\"n\">exact</span> <span class=\"n\">exists_mono_in_high_dimension'.key.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">κ</span> <span class=\"o\">:=</span> <span class=\"n\">κ</span><span class=\"o\">)</span> <span class=\"bp\">@</span><span class=\"n\">ihα</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 383212170,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1691574677
    },
    {
        "content": "<p>So you are saying that if you split up the argument then you can avoid the secret time hole. Here is my attempt to minimise the secret time hole:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Combinatorics.HalesJewett</span>\n\n<span class=\"c1\">-- 44K heartbeats, 4.3 seconds</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">    [] [4.407894s] theorem extracted_1 {α : Type} [Finite α] [...] ▼</span>\n<span class=\"cm\">      [step] [0.713942s] suffices key : [...] ▶</span>\n<span class=\"cm\">      [Kernel] [0.025385s] typechecking declaration</span>\n<span class=\"cm\">-/</span>\n<span class=\"n\">count_heartbeats</span> <span class=\"k\">in</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.profiler</span> <span class=\"n\">true</span> <span class=\"k\">in</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">profiler</span> <span class=\"n\">true</span> <span class=\"k\">in</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">pp.oneline</span> <span class=\"n\">true</span> <span class=\"k\">in</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">Combinatorics.Line.extracted_1</span>\n    <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Finite</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">ihα</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">κ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Finite</span> <span class=\"n\">κ</span><span class=\"o\">],</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Fintype</span> <span class=\"n\">ι</span><span class=\"o\">),</span>\n      <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">κ</span><span class=\"o\">),</span> <span class=\"bp\">∃</span> <span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">Line</span> <span class=\"n\">α</span> <span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"n\">l.IsMono</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">κ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Finite</span> <span class=\"n\">κ</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Nonempty</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n     <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Fintype</span> <span class=\"n\">ι</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">κ</span><span class=\"o\">),</span> <span class=\"bp\">∃</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">IsMono</span> <span class=\"n\">C</span> <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">suffices</span> <span class=\"n\">key</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∀</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span>\n      <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Fintype</span> <span class=\"n\">ι</span><span class=\"o\">),</span>\n        <span class=\"bp\">∀</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">κ</span><span class=\"o\">,</span>\n          <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ColorFocused</span> <span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"n\">Multiset.card</span> <span class=\"n\">s.lines</span> <span class=\"bp\">=</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"bp\">∃</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">IsMono</span> <span class=\"n\">C</span> <span class=\"n\">l</span>\n  <span class=\"c1\">-- Given the key claim, we simply take `r = |κ| + 1`. We cannot have this many distinct colors</span>\n  <span class=\"c1\">-- so we must be in the second case, where there is a monochromatic line.</span>\n  <span class=\"bp\">·</span> <span class=\"n\">classical</span>\n    <span class=\"k\">let</span> <span class=\"n\">inst37</span> <span class=\"o\">:</span> <span class=\"n\">Fintype</span> <span class=\"n\">κ</span> <span class=\"o\">:=</span> <span class=\"n\">Fintype.ofFinite</span> <span class=\"n\">κ</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"n\">_inst</span><span class=\"o\">,</span> <span class=\"n\">hι</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">key</span> <span class=\"o\">(</span><span class=\"n\">Fintype.card</span> <span class=\"n\">κ</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n    <span class=\"n\">refine'</span> <span class=\"o\">⟨</span><span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"n\">_inst</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">C</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">hι</span> <span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">resolve_left</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n    <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">sr</span><span class=\"o\">⟩</span>\n    <span class=\"n\">apply</span> <span class=\"n\">Nat.not_succ_le_self</span> <span class=\"o\">(</span><span class=\"n\">Fintype.card</span> <span class=\"n\">κ</span><span class=\"o\">)</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Nat.add_one</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">sr</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">Multiset.card_map</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">Finset.card_mk</span><span class=\"o\">]</span>\n    <span class=\"n\">exact</span> <span class=\"n\">Finset.card_le_univ</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">s.distinct_colors</span><span class=\"o\">⟩</span>\n  <span class=\"c1\">-- We now prove the key claim, by induction on `r`.</span>\n  <span class=\"n\">intro</span> <span class=\"n\">r</span>\n  <span class=\"n\">induction'</span> <span class=\"n\">r</span> <span class=\"k\">with</span> <span class=\"n\">r</span> <span class=\"n\">ihr</span>\n  <span class=\"c1\">-- The base case `r = 0` is trivial as the empty collection is color-focused.</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">Empty</span><span class=\"o\">,</span> <span class=\"n\">inferInstance</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">C</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Or.inl</span> <span class=\"o\">⟨</span><span class=\"n\">default</span><span class=\"o\">,</span> <span class=\"n\">Multiset.card_zero</span><span class=\"o\">⟩⟩</span>\n  <span class=\"c1\">-- Supposing the key claim holds for `r`, we need to show it for `r+1`. First pick a high</span>\n  <span class=\"c1\">-- enough dimension `ι` for `r`.</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"n\">_inst</span><span class=\"o\">,</span> <span class=\"n\">hι</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">ihr</span>\n  <span class=\"n\">classical</span>\n  <span class=\"k\">let</span> <span class=\"n\">iFα</span> <span class=\"o\">:</span> <span class=\"n\">Fintype</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">Fintype.ofFinite</span> <span class=\"n\">α</span>\n  <span class=\"k\">let</span> <span class=\"n\">iFκ</span> <span class=\"o\">:</span> <span class=\"n\">Fintype</span> <span class=\"n\">κ</span> <span class=\"o\">:=</span> <span class=\"n\">Fintype.ofFinite</span> <span class=\"n\">κ</span>\n<span class=\"c1\">--    let moo : Fintype (ι → Option α) := Pi.fintype</span>\n<span class=\"c1\">--    let foo : Fintype ((ι → Option α) → κ) := Pi.fintype</span>\n  <span class=\"c1\">-- Then since the theorem holds for `α` with any number of colors, pick a dimension `ι'` such</span>\n  <span class=\"c1\">-- that `ι' → α` always has a monochromatic line whenever it is `(ι → Option α) → κ`-colored.</span>\n  <span class=\"n\">specialize</span> <span class=\"n\">ihα</span> <span class=\"o\">((</span><span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">κ</span><span class=\"o\">)</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">ι'</span><span class=\"o\">,</span> <span class=\"n\">_inst</span><span class=\"o\">,</span> <span class=\"n\">hι'</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">ihα</span>\n  <span class=\"c1\">-- We claim that `ι ⊕ ι'` works for `Option α` and `κ`-coloring.</span>\n  <span class=\"n\">refine'</span> <span class=\"o\">⟨</span><span class=\"n\">Sum</span> <span class=\"n\">ι</span> <span class=\"n\">ι'</span><span class=\"o\">,</span> <span class=\"n\">inferInstance</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n  <span class=\"n\">intro</span> <span class=\"n\">C</span>\n  <span class=\"c1\">-- A `κ`-coloring of `ι ⊕ ι' → Option α` induces an `(ι → Option α) → κ`-coloring of `ι' → α`.</span>\n  <span class=\"n\">specialize</span> <span class=\"n\">hι'</span> <span class=\"k\">fun</span> <span class=\"n\">v'</span> <span class=\"n\">v</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">Sum.elim</span> <span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"bp\">∘</span> <span class=\"n\">v'</span><span class=\"o\">))</span>\n  <span class=\"c1\">-- By choice of `ι'` this coloring has a monochromatic line `l'` with color class `C'`, where</span>\n  <span class=\"c1\">-- `C'` is a `κ`-coloring of `ι → α`.</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">l'</span><span class=\"o\">,</span> <span class=\"n\">C'</span><span class=\"o\">,</span> <span class=\"n\">hl'</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hι'</span>\n  <span class=\"c1\">-- If `C'` has a monochromatic line, then so does `C`. We use this in two places below.</span>\n  <span class=\"k\">have</span> <span class=\"n\">mono_of_mono</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">IsMono</span> <span class=\"n\">C'</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">IsMono</span> <span class=\"n\">C</span> <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">hl</span><span class=\"o\">⟩</span>\n    <span class=\"n\">refine'</span> <span class=\"o\">⟨</span><span class=\"n\">l.horizontal</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"bp\">∘</span> <span class=\"n\">l'</span> <span class=\"o\">(</span><span class=\"n\">Classical.arbitrary</span> <span class=\"n\">α</span><span class=\"o\">)),</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Line.horizontal_apply</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">hl</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">hl'</span><span class=\"o\">]</span>\n  <span class=\"c1\">-- By choice of `ι`, `C'` either has `r` color-focused lines or a monochromatic line.</span>\n  <span class=\"n\">specialize</span> <span class=\"n\">hι</span> <span class=\"n\">C'</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">hι</span> <span class=\"k\">with</span> <span class=\"o\">(⟨</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">sr</span><span class=\"o\">⟩</span> <span class=\"bp\">|</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n  <span class=\"n\">on_goal</span> <span class=\"mi\">2</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"n\">Or.inr</span> <span class=\"o\">(</span><span class=\"n\">mono_of_mono</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n  <span class=\"c1\">-- Here we assume `C'` has `r` color focused lines. We split into cases depending on whether</span>\n  <span class=\"c1\">-- one of these `r` lines has the same color as the focus point.</span>\n  <span class=\"n\">by_cases</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">s.lines</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">AlmostMono</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">color</span> <span class=\"bp\">=</span> <span class=\"n\">C'</span> <span class=\"n\">s.focus</span>\n  <span class=\"c1\">-- If so then this is a `C'`-monochromatic line and we are done.</span>\n  <span class=\"bp\">·</span> <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">p_mem</span><span class=\"o\">,</span> <span class=\"n\">hp</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h</span>\n    <span class=\"n\">refine'</span> <span class=\"n\">Or.inr</span> <span class=\"o\">(</span><span class=\"n\">mono_of_mono</span> <span class=\"o\">⟨</span><span class=\"n\">p.line</span><span class=\"o\">,</span> <span class=\"n\">p.color</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩)</span>\n    <span class=\"n\">rintro</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hp</span><span class=\"o\">,</span> <span class=\"n\">s.is_focused</span> <span class=\"n\">p</span> <span class=\"n\">p_mem</span><span class=\"o\">]</span>\n    <span class=\"n\">apply</span> <span class=\"n\">p.has_color</span>\n  <span class=\"c1\">-- If not, we get `r+1` color focused lines by taking the product of the `r` lines with `l'`</span>\n  <span class=\"c1\">-- and adding to this the vertical line obtained by the focus point and `l`.</span>\n  <span class=\"n\">refine'</span> <span class=\"n\">Or.inl</span> <span class=\"o\">⟨⟨(</span><span class=\"n\">s.lines.map</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"o\">⟨(</span><span class=\"n\">l'.map</span> <span class=\"n\">some</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">vertical</span> <span class=\"n\">s.focus</span><span class=\"o\">,</span> <span class=\"n\">C'</span> <span class=\"n\">s.focus</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n          <span class=\"n\">Sum.elim</span> <span class=\"n\">s.focus</span> <span class=\"o\">(</span><span class=\"n\">l'.map</span> <span class=\"n\">some</span> <span class=\"n\">none</span><span class=\"o\">),</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n  <span class=\"c1\">-- Porting note: Needed to reorder the following two goals</span>\n  <span class=\"c1\">-- The product lines are almost monochromatic.</span>\n  <span class=\"bp\">·</span> <span class=\"n\">refine'</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">p.line.prod</span> <span class=\"o\">(</span><span class=\"n\">l'.map</span> <span class=\"n\">some</span><span class=\"o\">),</span> <span class=\"n\">p.color</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Line.prod_apply</span><span class=\"o\">,</span> <span class=\"n\">Line.map_apply</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">p.has_color</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">congr_fun</span> <span class=\"o\">(</span><span class=\"n\">hl'</span> <span class=\"n\">x</span><span class=\"o\">)]</span>\n  <span class=\"c1\">-- The vertical line is almost monochromatic.</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">vertical_apply</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">congr_fun</span> <span class=\"o\">(</span><span class=\"n\">hl'</span> <span class=\"n\">x</span><span class=\"o\">),</span> <span class=\"n\">Line.map_apply</span><span class=\"o\">]</span>\n  <span class=\"c1\">-- Our `r+1` lines have the same endpoint.</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">Multiset.mem_cons</span><span class=\"o\">,</span> <span class=\"n\">Multiset.mem_map</span><span class=\"o\">]</span>\n    <span class=\"n\">rintro</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">rfl</span> <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"n\">hq</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩)</span>\n    <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">vertical_apply</span><span class=\"o\">]</span>\n    <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">prod_apply</span><span class=\"o\">,</span> <span class=\"n\">s.is_focused</span> <span class=\"n\">q</span> <span class=\"n\">hq</span><span class=\"o\">]</span>\n  <span class=\"c1\">-- Our `r+1` lines have distinct colors (this is why we needed to split into cases above).</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Multiset.map_cons</span><span class=\"o\">,</span> <span class=\"n\">Multiset.map_map</span><span class=\"o\">,</span> <span class=\"n\">Multiset.nodup_cons</span><span class=\"o\">,</span> <span class=\"n\">Multiset.mem_map</span><span class=\"o\">]</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"n\">hq</span><span class=\"o\">,</span> <span class=\"n\">he</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h</span> <span class=\"o\">⟨</span><span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"n\">hq</span><span class=\"o\">,</span> <span class=\"n\">he</span><span class=\"o\">⟩,</span> <span class=\"n\">s.distinct_colors</span><span class=\"o\">⟩</span>\n  <span class=\"c1\">-- Finally, we really do have `r+1` lines!</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Multiset.card_cons</span><span class=\"o\">,</span> <span class=\"n\">Multiset.card_map</span><span class=\"o\">,</span> <span class=\"n\">sr</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>This proof goes: \"suffices blah, &lt;proof&gt;, &lt;proof&gt;\". If you replace either of the proofs with <code>sorry</code> then the secret time hole disappears. But with both sorrys filled you get this funny trace</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"o\">[]</span> <span class=\"o\">[</span><span class=\"mi\">4</span><span class=\"bp\">.</span><span class=\"mi\">407894</span><span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"kd\">theorem</span> <span class=\"n\">extracted_1</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Finite</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">...</span><span class=\"o\">]</span> <span class=\"bp\">▼</span>\n      <span class=\"o\">[</span><span class=\"n\">step</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">713942</span><span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"k\">suffices</span> <span class=\"n\">key</span> <span class=\"o\">:</span> <span class=\"o\">[</span><span class=\"bp\">...</span><span class=\"o\">]</span> <span class=\"bp\">▶</span>\n      <span class=\"o\">[</span><span class=\"n\">Kernel</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">025385</span><span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"n\">typechecking</span> <span class=\"n\">declaration</span>\n</code></pre></div>\n<p>which doesn't add up.</p>",
        "id": 383222010,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1691576488
    },
    {
        "content": "<p>Yep, that also matches my experience a couple weeks ago.</p>",
        "id": 383222340,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1691576548
    },
    {
        "content": "<p>That does point to the unused variables linter as it ignores decls with <code>sorry</code>. Does turning off <code>linter.unusedVariables</code> fix it then?</p>",
        "id": 383231300,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1691578079
    },
    {
        "content": "<p>On both the current and modified version of the file, <code>set_option linter.unusedVariables false</code> does not actually seem to change the <code>Elab.command</code> time, although the <code>Elab.lint</code> time indeed goes from 3s to 0.2s.</p>",
        "id": 383255362,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1691582844
    },
    {
        "content": "<p>Uh, interesting?</p>",
        "id": 383300899,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1691590522
    },
    {
        "content": "<p>I'm kind of at a loss of words. Does the plain <code>profiler</code> output change?</p>",
        "id": 383301326,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1691590588
    },
    {
        "content": "<p>Let me check... (By the way, the VelCom queue says \"No worker registered :( I will not be able to benchmark anything! Please setup a runner and point it to this instance.\", is that supposed to happen / a known issue?)</p>",
        "id": 383335438,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1691596044
    },
    {
        "content": "<p>Uh oh</p>",
        "id": 383336589,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1691596278
    },
    {
        "content": "<p>With <code>set_option profiler true</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">▶</span> <span class=\"mi\">219</span><span class=\"o\">:</span><span class=\"mi\">1</span><span class=\"bp\">-</span><span class=\"mi\">219</span><span class=\"o\">:</span><span class=\"mi\">1</span><span class=\"o\">:</span> <span class=\"n\">information</span><span class=\"o\">:</span>\n<span class=\"n\">tactic</span> <span class=\"n\">execution</span> <span class=\"n\">of</span> <span class=\"n\">Lean.Parser.Tactic.rewriteSeq</span> <span class=\"n\">took</span> <span class=\"mi\">228</span><span class=\"n\">ms</span>\n<span class=\"n\">linting</span> <span class=\"n\">took</span> <span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"mi\">77</span><span class=\"n\">s</span>\n<span class=\"n\">elaboration</span> <span class=\"n\">took</span> <span class=\"mi\">7</span><span class=\"bp\">.</span><span class=\"mi\">75</span><span class=\"n\">s</span>\n</code></pre></div>\n<p>With <code>set_option profiler true; set_option linter.unusedVariables false</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">▶</span> <span class=\"mi\">221</span><span class=\"o\">:</span><span class=\"mi\">1</span><span class=\"bp\">-</span><span class=\"mi\">221</span><span class=\"o\">:</span><span class=\"mi\">1</span><span class=\"o\">:</span> <span class=\"n\">information</span><span class=\"o\">:</span>\n<span class=\"n\">tactic</span> <span class=\"n\">execution</span> <span class=\"n\">of</span> <span class=\"n\">Lean.Parser.Tactic.rewriteSeq</span> <span class=\"n\">took</span> <span class=\"mi\">219</span><span class=\"n\">ms</span>\n<span class=\"n\">elaboration</span> <span class=\"n\">took</span> <span class=\"mi\">7</span><span class=\"bp\">.</span><span class=\"mi\">97</span><span class=\"n\">s</span>\n</code></pre></div>",
        "id": 383337354,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1691596412
    },
    {
        "content": "<p>This file gets almost 20% faster with <a href=\"https://github.com/leanprover-community/mathlib4/pull/6370\">#6370</a> if I remember correctly</p>",
        "id": 383338020,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1691596526
    },
    {
        "content": "<p>Maybe useful info</p>",
        "id": 383338144,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1691596552
    },
    {
        "content": "<p>Good point! There is certainly some universe trickery inside these theorems so that sounds likely to have an impact.</p>",
        "id": 383338524,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1691596630
    },
    {
        "content": "<p>In my \"minimal\" example above I have stripped out all the universes (for precisely this reason)</p>",
        "id": 383353478,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1691599485
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"238446\">Anne Baanen</span> <a href=\"#narrow/stream/113488-general/topic/trace.20debugging/near/383335438\">said</a>:</p>\n<blockquote>\n<p>Let me check... (By the way, the VelCom queue says \"No worker registered :( I will not be able to benchmark anything! Please setup a runner and point it to this instance.\", is that supposed to happen / a known issue?)</p>\n</blockquote>\n<p>I know you can't do anything now but FYI <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> if you haven't seen it</p>",
        "id": 383398853,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1691609289
    },
    {
        "content": "<p>Nothing I can do about it right now, please bear with it a little while longer</p>",
        "id": 383408139,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1691612128
    },
    {
        "content": "<p>Of course.</p>",
        "id": 383408656,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1691612289
    }
]