[
    {
        "content": "<p>Hi, here's a snippet to illustrate the problem I have(apologies if it's not as minimal as it could've been)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">unit</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">}</span>\n\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">unit_yes</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hi</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">unit_yes</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">unit_no</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hi</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">trivial</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">unit_no</span>\n</code></pre></div>\n<p>This outputs</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">@</span><span class=\"n\">unit_yes</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">unit</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hi</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">True</span>\n</code></pre></div>\n<p>and then almost the same type for unit_no but without the <code>{unit : Œ±}</code> part. You could say that this happens because h is unused but I have some examples that show it's not the case.</p>\n<p>Instead, it seems to me that the issue is that axioms and theorems get elaborated in 2 different ways, the former with \"mkForallFVars with usedOnly := true\" and the latter with \"<code>collectFVars</code> on the already-elaborated header type, then <code>removeUnused</code> to restrict the local context\"(this was explained to me by an LLM agent, but does seem at least somewhat close to the truth).</p>\n<p>Is this intentional?</p>\n<p>(why this is a problem for me: for my project I wanted to try replacing theorems with axioms, I thought this would be alwsys safe, but because of the issue described, a proof that was <code>apply</code> ing the original theorem now creates an additional goal)</p>",
        "id": 574010022,
        "sender_full_name": "Mikhail Mayorov",
        "timestamp": 1771192817
    },
    {
        "content": "<p>this is essentially the same as the difference between <code>def</code> and <code>theorem</code>/<code>lemma</code>. I'm reasonably sure this is intentional.</p>",
        "id": 574010257,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1771193056
    },
    {
        "content": "<p>i believe the reasoning for this was that for <code>lemmas</code> you usually only want to include <code>variable</code>s which are somehow related to the type of the lemma</p>",
        "id": 574010439,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1771193233
    },
    {
        "content": "<blockquote>\n<p>I wanted to try replacing theorems with axioms</p>\n</blockquote>\n<p>For which reason? Note that under the module system, theorems already become axioms when imported.</p>",
        "id": 574010759,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1771193528
    },
    {
        "content": "<p>(not literally, although lean indeed doesn't inspect the proof of imported lemmas)</p>",
        "id": 574010921,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1771193636
    },
    {
        "content": "<p>It might be literally, per <a href=\"#narrow/channel/270676-lean4/topic/Accessing.20.60Expr.60.20of.20a.20def.20across.20modules/near/573371782\">#lean4 &gt; Accessing &#96;Expr&#96; of a def across modules @ üí¨</a><br>\nThe <code>ConstantInfo</code> of defs/theorems becomes <code>ConstantInfo.axiomInfo</code></p>",
        "id": 574013869,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1771196187
    },
    {
        "content": "<p>I don't understand how this can be intentional. Only <code>axiom</code> behaves differently from others (I tried <code>def</code>, <code>lemma</code>, <code>theorem</code>, <code>opaque</code>), and usual Lean users use at most 6 axioms altogether, so I don't see a good reason to give it a special treatment.</p>",
        "id": 574014157,
        "sender_full_name": "Mirek Ol≈°√°k",
        "timestamp": 1771196480
    },
    {
        "content": "<p>I guess the reason for this to happen is that in the <code>axiom</code>, the tactic for a valid index for <code>a[i]</code> finds a different proof in axiom than in the other cases.</p>",
        "id": 574014419,
        "sender_full_name": "Mirek Ol≈°√°k",
        "timestamp": 1771196790
    },
    {
        "content": "<p>No, it doesn't seem like that's the case. My guess is that there was just an oversight</p>",
        "id": 574014611,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1771197038
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"933054\">Snir Broshi</span> <a href=\"#narrow/channel/113488-general/topic/theorem.20vs.20axiom.20elaborating.20difference/near/574013869\">said</a>:</p>\n<blockquote>\n<p>It might be literally, per <a href=\"#narrow/channel/270676-lean4/topic/Accessing.20.60Expr.60.20of.20a.20def.20across.20modules/near/573371782\">#lean4 &gt; Accessing &#96;Expr&#96; of a def across modules @ üí¨</a><br>\nThe <code>ConstantInfo</code> of defs/theorems becomes <code>ConstantInfo.axiomInfo</code></p>\n</blockquote>\n<p>and yet, <code>#print axioms</code> will not report them... so they are not in every aspect the same as though they are axioms</p>",
        "id": 574014910,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1771197433
    },
    {
        "content": "<p><code>#print axioms</code> doesn't currently work though in the module system?</p>",
        "id": 574015277,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1771197871
    },
    {
        "content": "<p>To be precise: If you remove that error, then <code>#print axioms</code> with the current implementation would report every theorem, opaque and non-exposed definition in modules.</p>",
        "id": 574015578,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1771198191
    },
    {
        "content": "<p>Oh wow that makes sense, I couldn't figure out why I couldn't shake any axioms when trying to come up with a counterexample for <a class=\"stream-topic\" data-stream-id=\"236446\" href=\"/#narrow/channel/236446-Type-theory/topic/Equality.20without.20axioms/with/573486479\">#Type theory &gt; Equality without axioms</a> <br>\nMaybe we can add a temporary warning until they fix it</p>",
        "id": 574015739,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1771198363
    },
    {
        "content": "<p>What is going on?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">unit</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">unit_nah</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hi</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"bp\">'</span><span class=\"n\">hi</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"bp\">'</span><span class=\"n\">hi</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">unit_yes</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hi</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"bp\">'</span><span class=\"n\">hi</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"bp\">'</span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">assumption</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">unit_nah</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">unit_yes</span>\n</code></pre></div>",
        "id": 574016057,
        "sender_full_name": "Mirek Ol≈°√°k",
        "timestamp": 1771198740
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"873547\">Robin Arnez</span> <a href=\"#narrow/channel/113488-general/topic/theorem.20vs.20axiom.20elaborating.20difference/near/574010759\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>I wanted to try replacing theorems with axioms</p>\n</blockquote>\n<p>For which reason? Note that under the module system, theorems already become axioms when imported.</p>\n</blockquote>\n<p>What I want to achieve is, given some computer-generated proof, make sure it does not depend on a given theorem. And <code>#print axioms</code> already does all the heavy lifting for this. </p>\n<p>(+ the program that generates the proofs isn't written in lean, so just adding a line to the proof and checking compiler diagnostics sounded like an elegant solution).</p>\n<p><del>I am very interested in any other approaches for this, but they should be accessible for lean beginner :D</del><br>\nupd: I found a good solution now</p>",
        "id": 574016138,
        "sender_full_name": "Mikhail Mayorov",
        "timestamp": 1771198833
    },
    {
        "content": "<p>Back to the original topic, it seems like the problem was indeed the proof for <code>a[i]</code> but not because it is different for <code>axiom</code> but because it gets <code>instantiateMVars</code>ed too late:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\"> Bad code (how we currently have it) -/</span>\n<span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">instantiateMVars</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"c1\">-- only mvars in the type get instantiated</span>\n<span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">mkForallFVars</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"c1\">-- but not in the binder types</span>\n<span class=\"c1\">-- so we have mvars depending on the entire context</span>\n<span class=\"c1\">-- so `mkForallFVars` can't remove any binder</span>\n<span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">mkForallFVars</span><span class=\"w\"> </span><span class=\"n\">vars</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">usedOnly</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">)</span>\n<span class=\"c1\">-- another `instantiateMVars` happens somewhere later</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> Good code (fix) -/</span>\n<span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">mkForallFVars</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"c1\">-- instantiates mvars everywhere including the binders</span>\n<span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">instantiateMVars</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"c1\">-- mvars are gone so no more dependency!</span>\n<span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">mkForallFVars</span><span class=\"w\"> </span><span class=\"n\">vars</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">usedOnly</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 574016270,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1771198969
    },
    {
        "content": "<p>Nice! So you could again submit a fix to hear from FRO that they are afraid it could be a breaking change <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> .</p>",
        "id": 574016575,
        "sender_full_name": "Mirek Ol≈°√°k",
        "timestamp": 1771199344
    },
    {
        "content": "<p>Here it is: <a href=\"https://github.com/leanprover/lean4/pull/12497\">lean4#12497</a></p>",
        "id": 574020070,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1771203346
    },
    {
        "content": "<p>Supposedly, it's ok to be liberal with <code>instantiateMVars</code> (says the metaprogramming book), so we could use it before <em>and</em> after <code>mkForallFVars</code>?</p>",
        "id": 574021733,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1771205011
    }
]