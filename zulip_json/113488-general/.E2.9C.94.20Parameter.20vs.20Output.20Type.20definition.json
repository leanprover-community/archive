[
    {
        "content": "<p>Is it always possible to convert a definition defined like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">A_1</span> <span class=\"bp\">→</span> <span class=\"n\">A_2</span> <span class=\"bp\">→</span> <span class=\"bp\">...</span> <span class=\"bp\">→</span> <span class=\"n\">A_n</span>  <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>to be like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">a1</span> <span class=\"o\">:</span> <span class=\"n\">A_1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a2</span> <span class=\"o\">:</span> <span class=\"n\">A_2</span><span class=\"o\">)</span> <span class=\"bp\">...</span>  <span class=\"o\">:</span> <span class=\"n\">A_n</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>and vice versa?</p>\n<p>I was under the impression this was true until I came across the definition of <code>Eq</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Eq</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n    <span class=\"n\">refl</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Eq</span> <span class=\"n\">a</span> <span class=\"n\">a</span>\n</code></pre></div>\n<p>I wasn't able to find a way to convert the definition into one like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Eq</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n    <span class=\"bp\">|</span> <span class=\"n\">refl</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>If the two ways of defining something are not interchangeable, then in what situations are they not interchangeable?</p>",
        "id": 363190897,
        "sender_full_name": "Petur Vetle",
        "timestamp": 1685752418
    },
    {
        "content": "<p>You can always (I think) define a definition using <code>def</code> trivially in terms of another (possibly even so that they are definitionally equal).  I think you are asking something about <code>inductive</code> type definitions instead.</p>",
        "id": 363200607,
        "sender_full_name": "Jason Rute",
        "timestamp": 1685760355
    },
    {
        "content": "<p>I guess it's true for <code>def</code> but not for <code>inductive</code>.</p>",
        "id": 363220688,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1685774643
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"115715\">Jason Rute</span> <a href=\"#narrow/stream/113488-general/topic/Parameter.20vs.20Output.20Type.20definition/near/363200607\">said</a>:</p>\n<blockquote>\n<p>You can always (I think) define a definition using <code>def</code> trivially in terms of another (possibly even so that they are definitionally equal).  I think you are asking something about <code>inductive</code> type definitions instead.</p>\n</blockquote>\n<p>You are right, I am talking about <code>inductive</code> type definitions. I conflated the two since they use the same syntax, so I thought the answer would be the same. </p>\n<p>So does that mean <code>inductive</code> type definitions may only be definable in one way and <code>Eq</code> cannot be defined using parameters?</p>",
        "id": 363353080,
        "sender_full_name": "Petur Vetle",
        "timestamp": 1685813364
    },
    {
        "content": "<p>They don't use the same syntax, they use similar syntax. The definition of an inductive type looks similar to the syntax used when you are defining a function which takes an inductive type as an input and you use pattern matching. The pipes are the same but the syntax after the pipes is rather different.</p>",
        "id": 363357985,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1685815376
    },
    {
        "content": "<p><code>inductive</code>s have two different kinds of arguments: parameters and indices. Generally parameters come before the colon and indices come after the colon, but Lean 4 can promote indices to be parameters automatically. Every constructor has the same parameters, but the indices can vary and can make use of the values of the parameters or of any additional constructor arguments.</p>\n<p>In the case of <code>Eq</code>, you can define it with one parameter and one index:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Eq'</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n  <span class=\"bp\">|</span> <span class=\"n\">refl</span> <span class=\"o\">:</span> <span class=\"n\">Eq'</span> <span class=\"n\">a</span> <span class=\"n\">a</span>\n</code></pre></div>\n<p>This can't be done with just parameters since there's a constraint on what can be the second argument.</p>",
        "id": 363362830,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1685817398
    },
    {
        "content": "<p>Thanks. That is what I was looking for. Looking at the type for <code>@Eq.rec</code>, it appears that one is able to \"pull out\" the first index but not the second, which would explain why only the first index can be parameterized.</p>\n<p>I do have another question about the type of @Eq.rec, but I'll ask that in the new members stream.</p>",
        "id": 363386805,
        "sender_full_name": "Petur Vetle",
        "timestamp": 1685829476
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"621865\">Petur Vetle</span> has marked this topic as resolved.</p>",
        "id": 363387441,
        "sender_full_name": "Notification Bot",
        "timestamp": 1685829824
    }
]