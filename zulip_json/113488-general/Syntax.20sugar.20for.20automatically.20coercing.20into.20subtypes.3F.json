[
    {
        "content": "<p>Currently the refinement subtypes in Lean have worse ergonomics when compared to a language like F*, because you must explicitly provide trivial proofs like rfl, cluttering the callsite such that I honestly hardly ever want to use the feature in general programs.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"bp\">‚ü©</span>\n</code></pre></div>\n<p>If F*, it looks like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">int</span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n</code></pre></div>\n<p>seamless, because the proof is handled for you automatically.</p>\n<p>is there any way currently in Lean, through its macros or notation system or implicit arguments, to make <code>f 2</code> translate into <code>f ‚ü®2, rfl‚ü©</code>without requiring manual callsite clutter?</p>",
        "id": 566472043,
        "sender_full_name": "Lhr",
        "timestamp": 1767669530
    },
    {
        "content": "<p>you could write an <code>OfNat</code> instance</p>",
        "id": 566472963,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1767670238
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/113488-general/topic/Syntax.20sugar.20for.20automatically.20coercing.20into.20subtypes.3F/near/566472963\">said</a>:</p>\n<blockquote>\n<p>you could write an <code>OfNat</code> instance</p>\n</blockquote>\n<p>What would that look like?</p>",
        "id": 566473191,
        "sender_full_name": "Lhr",
        "timestamp": 1767670421
    },
    {
        "content": "<p>actually I don't know</p>",
        "id": 566473518,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1767670664
    },
    {
        "content": "<p>since you should be able to have <code>2</code> but not <code>3</code></p>",
        "id": 566473553,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1767670696
    },
    {
        "content": "<p>so it's a bit weird</p>",
        "id": 566473562,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1767670704
    },
    {
        "content": "<p>We can't do this at the moment.</p>\n<p>What we can do is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">EvenInt</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"w\">  </span><span class=\"n\">even</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">grind</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">EvenInt</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"c1\">-- no proof required!</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"mi\">2</span><span class=\"bp\">‚ü©</span><span class=\"w\"> </span><span class=\"c1\">-- but this still doesn't work, nor `f 2`.</span>\n</code></pre></div>\n<p>It would not be crazy to make <code>f ‚ü®2‚ü©</code> work, and this is been requested before. Making <code>f 2</code> work is harder.</p>\n<p>Notice here I had to make my own subtype in order to provide the <code>auto_param</code> (<code>:= by grind</code>).</p>",
        "id": 566479893,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1767676405
    },
    {
        "content": "<p>Thanks. what sort of thing would be required to make <code>f 2</code>  work,  with no prior ceremony or manual labor like defining a structure and your example,  but just using the native subtype notation like my example </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>\n<p>are you saying it would need to be a sophisticated change in the compiler?  what sort of change would need to happen in the compiler?</p>\n<p>I'm interested in reading through the compiler and experimenting.</p>",
        "id": 566481554,
        "sender_full_name": "Lhr",
        "timestamp": 1767677764
    },
    {
        "content": "<p>It's the elaborator, rather than the compiler. Are you imagining this is restricted to subtypes? Or any structure with a single data field? Which tactic do you want to use.</p>",
        "id": 566499584,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1767688663
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/channel/113488-general/topic/Syntax.20sugar.20for.20automatically.20coercing.20into.20subtypes.3F/near/566499584\">said</a>:</p>\n<blockquote>\n<p>It's the elaborator, rather than the compiler. Are you imagining this is restricted to subtypes? Or any structure with a single data field? Which tactic do you want to use.</p>\n</blockquote>\n<p>Yes, getting this to work for subtypes is what I only care about for now, coming from F* where subtypes feel awesome and boilerplate-free.</p>\n<p>In this case, I would want the expression to just translate into <code>‚ü®2, rfl‚ü©</code>behind the scenes. Will this not work for other subtypes? Also, I see that there is an smt solver lib for lean. Possibly, that could be used, but I am hoping that most subtype proofs are as simple as <code>rfl</code></p>",
        "id": 566504740,
        "sender_full_name": "Lhr",
        "timestamp": 1767690909
    },
    {
        "content": "<p>if this is such an issue, you might want to try this pattern for your functions:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n</code></pre></div>\n<p>It's not quite the same as what you wrote (the return type is different), but usually that's just better anyway, as you are able to decide afterward what facts you want to show about the returned value of your function.</p>",
        "id": 566537132,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1767703492
    },
    {
        "content": "<p>But it's not always possible to use unbundled version. For the good UX, we should either get rid of subtypes completely, or ensure seamless feature parity between subtypes and unbundled version.</p>",
        "id": 566541289,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1767705265
    },
    {
        "content": "<p>It <em>is</em> also possible to write an <code>OfNat</code> with some instance magic:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">EvenInt</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"w\">  </span><span class=\"n\">even</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">IsTrue</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">out</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">true</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsTrue</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">no_index</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"n\">rfl</span><span class=\"bp\">‚ü©</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">even</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsTrue</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">mod</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">beq</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OfNat</span><span class=\"w\"> </span><span class=\"n\">EvenInt</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">‚ü®</span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">norm_cast</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">even</span><span class=\"bp\">.</span><span class=\"n\">out</span><span class=\"bp\">‚ü©</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">EvenInt</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"c1\">-- works</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"c1\">-- fails</span>\n</code></pre></div>",
        "id": 566542146,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1767705647
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/channel/113488-general/topic/Syntax.20sugar.20for.20automatically.20coercing.20into.20subtypes.3F/near/566537132\">said</a>:</p>\n<blockquote>\n<p>if this is such an issue, you might want to try this pattern for your functions:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n</code></pre></div>\n<p>It's not quite the same as what you wrote (the return type is different), but usually that's just better anyway, as you are able to decide afterward what facts you want to show about the returned value of your function.</p>\n</blockquote>\n<p>I'm aware of this approach, but it still seems worse than what a proper subtype system could do.  The type of <code>x</code> is not truly refined there, so you may have to reprove this extrinsic statement elsewhere as you compose <code>f</code> with other functions. Consider our case here where <code>f</code> is the identity function</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- error</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">could</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">synthesize</span><span class=\"w\"> </span><span class=\"n\">default</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">parameter</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">hx'</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">tactics</span>\n<span class=\"ss\">`grind</span><span class=\"bp\">`</span><span class=\"w\"> </span><span class=\"n\">failed</span>\n<span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">grind</span>\n<span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬¨</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">‚ãØ</span><span class=\"w\"> </span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"bp\">‚ä¢</span><span class=\"w\"> </span><span class=\"n\">False</span>\n<span class=\"o\">(</span><span class=\"n\">trace</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 566560339,
        "sender_full_name": "Lhr",
        "timestamp": 1767711381
    },
    {
        "content": "<p>there will always be times it can't automatically prove the subtype condition</p>",
        "id": 566614975,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1767730411
    },
    {
        "content": "<p>what kind of \"proper subtype system\" are you imagining</p>",
        "id": 566615006,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1767730429
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/113488-general/topic/Syntax.20sugar.20for.20automatically.20coercing.20into.20subtypes.3F/near/566614975\">said</a>:</p>\n<blockquote>\n<p>there will always be times it can't automatically prove the subtype condition</p>\n</blockquote>\n<p>Maybe we could have a syntax like with arrays: <code>el'?_</code> or <code>el!</code>.</p>",
        "id": 566632709,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1767739293
    },
    {
        "content": "<p>Or just normal <code>\\&lt;el, ?_\\&gt;</code> but only required when the condition can't be proved.</p>",
        "id": 566632774,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1767739339
    },
    {
        "content": "<p>and there's also stuff like</p>",
        "id": 566632791,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1767739356
    },
    {
        "content": "<p>what if you have a subtype of a subtype</p>",
        "id": 566632805,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1767739360
    },
    {
        "content": "<p>so it might become ambiguous?</p>",
        "id": 566632819,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1767739373
    },
    {
        "content": "<p>If both target and source types are known that I don't think there's ambiguity? But I could imagine cases where one or the other might be not known without additional type annotations. I guess that's similar kind of problem as with coercions from subtype to underlying type?</p>",
        "id": 566632960,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1767739483
    },
    {
        "content": "<p>yeah so now if you have coercions in both directions it becomes a problem</p>",
        "id": 566633699,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1767740027
    },
    {
        "content": "<p>that's why we got rid of the coercion from <code>Nat</code> to <code>Fin</code></p>",
        "id": 566633718,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1767740039
    },
    {
        "content": "<p>I'm not sure if it's worthwhile putting any substantial effort into saving a total of six keystrokes.</p>",
        "id": 566637003,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1767742333
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hern√°ndez</span> <a href=\"#narrow/channel/113488-general/topic/Syntax.20sugar.20for.20automatically.20coercing.20into.20subtypes.3F/near/566637003\">said</a>:</p>\n<blockquote>\n<p>I'm not sure if it's worthwhile putting any substantial effort into saving a total of six keystrokes.</p>\n</blockquote>\n<p>There's no mechanism to specify automatic dischargers for subtypes atm. And the solution <a href=\"#narrow/channel/113488-general/topic/Syntax.20sugar.20for.20automatically.20coercing.20into.20subtypes.3F/near/566479893\">here</a> is way more than six keystrokes.</p>",
        "id": 566639873,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1767744303
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hern√°ndez</span> <a href=\"#narrow/channel/113488-general/topic/Syntax.20sugar.20for.20automatically.20coercing.20into.20subtypes.3F/near/566637003\">said</a>:</p>\n<blockquote>\n<p>I'm not sure if it's worthwhile putting any substantial effort into saving a total of six keystrokes.</p>\n</blockquote>\n<p>It is worthwhile if you want the language to be adopted for practical general purpose programming, rather than only for mathematicians writing proofs. In normal business applications, refinements like these are only <em>slightly</em> beneficial, which means that any amount of friction will be enough to make most programmers decide that they are not worth doing in general. Consider:</p>\n<div class=\"codehilite\" data-code-language=\"Scala\"><pre><span></span><code><span class=\"k\">class</span><span class=\"w\"> </span><span class=\"nc\">User</span><span class=\"p\">(</span><span class=\"kd\">val</span><span class=\"w\"> </span><span class=\"n\">age</span><span class=\"w\"> </span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Int</span><span class=\"p\">)</span>\n</code></pre></div>\n<p>This is standard in industry, C++ and Java programmers write this all the time. Everyone knows the code would be slightly more sensical and less bug prone if we could express that a user's <code>age</code> cannot be negative, but it really isn't a big deal -- it's unlikely someone would ever actually pass a negative anyway. Mainstream languages have existed for decades without this feature just fine. And if a programmer did care enough, they could always compensate for the inexpressive type system by putting runtime checks will throw errors:</p>\n<div class=\"codehilite\" data-code-language=\"Scala\"><pre><span></span><code><span class=\"k\">class</span><span class=\"w\"> </span><span class=\"nc\">User</span><span class=\"p\">(</span><span class=\"kd\">val</span><span class=\"w\"> </span><span class=\"n\">age</span><span class=\"w\"> </span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Int</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"n\">age</span><span class=\"w\"> </span><span class=\"o\">&gt;=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>Now consider the fact that despite this being available to industry programmers as an objective improvement to their code, almost no one ever bothers to do it. It's just too much effort to justify as a general practice. \"Do we really need to enforce that <code>factorial(n)</code> accepts only natural numbers, especially if that is going to make invoking the function a slight pain everywhere else forever? Can't we just expect that this will be obvious to other programmers?\" </p>\n<p>Application developers are only willing to sprinkle refinements like this throughout their code if it is dead simple -- nearly as easy as without them. That means: no prior ceremony like <span class=\"user-mention\" data-user-id=\"873547\">@Robin Arnez</span>'s example, and no cluttering callsites with awkward tuples or explicit casts. I want to call factorial on a natural number, not on a natural number paired with a proof that it is natural.</p>\n<p>The language I used for the code snippets is Scala, and in Scala there is actually a compile time refinement library called Iron which lets you seamlessly express this</p>\n<div class=\"codehilite\" data-code-language=\"Scala\"><pre><span></span><code><span class=\"k\">class</span><span class=\"w\"> </span><span class=\"nc\">User</span><span class=\"p\">(</span><span class=\"kd\">val</span><span class=\"w\"> </span><span class=\"n\">age</span><span class=\"w\"> </span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Int</span><span class=\"w\"> </span><span class=\"o\">:|</span><span class=\"w\"> </span><span class=\"nc\">GreaterEqual</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])</span>\n</code></pre></div>\n<p>And can even be made easier with alias if desired</p>\n<div class=\"codehilite\" data-code-language=\"Scala\"><pre><span></span><code><span class=\"k\">class</span><span class=\"w\"> </span><span class=\"nc\">User</span><span class=\"p\">(</span><span class=\"kd\">val</span><span class=\"w\"> </span><span class=\"n\">age</span><span class=\"w\"> </span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Int</span><span class=\"w\"> </span><span class=\"o\">:|</span><span class=\"w\"> </span><span class=\"o\">&gt;=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])</span>\n</code></pre></div>\n<p>And callsites are unchanged</p>\n<div class=\"codehilite\" data-code-language=\"Scala\"><pre><span></span><code><span class=\"kd\">val</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nc\">User</span><span class=\"p\">(</span><span class=\"mi\">42</span><span class=\"p\">)</span>\n<span class=\"kd\">val</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nc\">User</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">42</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"c1\">// fails to compile</span>\n</code></pre></div>\n<p>That's to say that, it would be sad if a much less sophisticated language like Scala is able to offer a more pleasant refinement type experience than a premium dependently typed language like Lean4. Surely we can make this more ergonomic for the common simple cases.</p>",
        "id": 566650563,
        "sender_full_name": "Lhr",
        "timestamp": 1767752460
    },
    {
        "content": "<p>so how is this lacking?</p>\n<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/channel/113488-general/topic/Syntax.20sugar.20for.20automatically.20coercing.20into.20subtypes.3F/near/566537132\">said</a>:</p>\n<blockquote>\n<p>if this is such an issue, you might want to try this pattern for your functions:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n</code></pre></div>\n<p>It's not quite the same as what you wrote (the return type is different), but usually that's just better anyway, as you are able to decide afterward what facts you want to show about the returned value of your function.</p>\n</blockquote>",
        "id": 566650951,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1767752731
    },
    {
        "content": "<p>Well I showed an example of how the type not truly being refined causes certain usages that you would expect to work, not work</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- error</span>\n</code></pre></div>\n<p>there may be more I haven't found where it breaks. I know that if you try using <code>rfl</code> or <code>simp</code> instead of <code>grind</code>, composition with another function breaks:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"c1\">-- could not synthesize default value for parameter 'hx' using tactics</span>\n</code></pre></div>\n<p>whereas both work using subtypes</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"bp\">‚ü©</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 566651462,
        "sender_full_name": "Lhr",
        "timestamp": 1767753124
    },
    {
        "content": "<p>how are we possibly supposed to know the output of <code>f 2</code> satisfies the constraint</p>",
        "id": 566652151,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1767753696
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/113488-general/topic/Syntax.20sugar.20for.20automatically.20coercing.20into.20subtypes.3F/near/566652151\">said</a>:</p>\n<blockquote>\n<p>how are we possibly supposed to know the output of <code>f 2</code> satisfies the constraint</p>\n</blockquote>\n<p>Because <code>f</code> is an identity function. It returns it's input unchanged, and we have established that  it's input has this constraint, so we should - we hope we could - be able to conclude that it's output has the same constraint.. That's the advantage of subtypes I'm seeing.</p>",
        "id": 566652224,
        "sender_full_name": "Lhr",
        "timestamp": 1767753787
    },
    {
        "content": "<p>ah, but how are we supposed to know <code>f</code> is an identity function</p>",
        "id": 566652268,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1767753836
    },
    {
        "content": "<p>tactics usually don't peek inside <code>def</code>s</p>",
        "id": 566652448,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1767753990
    },
    {
        "content": "<p>if you want to expose that <code>f</code> is an identity function you can make it an <code>abbrev f</code> or you can write a lemma that says <code>f</code> is an identity function and you can mark it <code>@[simp]</code> or <code>@[grind =]</code> or something</p>",
        "id": 566652581,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1767754110
    },
    {
        "content": "<p>don't we do something similar for <code>GetElem</code> where the proof of correctness is done automatically using an extensible tactic and you can still supply a proof manually if you want to</p>",
        "id": 566652694,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1767754192
    },
    {
        "content": "<p>I don't really know what kind of constraints you would want to express anyways</p>",
        "id": 566652998,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1767754389
    },
    {
        "content": "<p>since I don't really use subtypes</p>",
        "id": 566653357,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1767754645
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"1011232\">Lhr</span> <a href=\"#narrow/channel/113488-general/topic/Syntax.20sugar.20for.20automatically.20coercing.20into.20subtypes.3F/near/566650563\">said</a>:</p>\n<blockquote>\n<p>That's to say that, it would be sad if a much less sophisticated language like Scala is able to offer a more pleasant refinement type experience than a premium dependently typed language like Lean4. Surely we can make this more ergonomic for the common simple cases.</p>\n</blockquote>\n<p>I would think this is actually to be expected when comparing the two,  more expressivity leaves room for more ambiguity surely. In your example,  <code>assert(age &gt;= 0)</code> doesn't work in a Lean friendly way. In Scala,¬†<code>Int</code>¬†is a 32-bit signed integer value type, so this would be an example of type punning.</p>",
        "id": 566654547,
        "sender_full_name": "Yan Yablonovskiy üá∫üá¶",
        "timestamp": 1767755605
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">grind</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>works fine.</p>",
        "id": 566656202,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1767756955
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"773147\">Yan Yablonovskiy üá∫üá¶</span> <a href=\"#narrow/channel/113488-general/topic/Syntax.20sugar.20for.20automatically.20coercing.20into.20subtypes.3F/near/566654547\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"1011232\">Lhr</span> <a href=\"#narrow/channel/113488-general/topic/Syntax.20sugar.20for.20automatically.20coercing.20into.20subtypes.3F/near/566650563\">said</a>:</p>\n<blockquote>\n<p>That's to say that, it would be sad if a much less sophisticated language like Scala is able to offer a more pleasant refinement type experience than a premium dependently typed language like Lean4. Surely we can make this more ergonomic for the common simple cases.</p>\n</blockquote>\n<p>I would think this is actually to be expected when comparing the two,  more expressivity leaves room for more ambiguity surely. In your example,  <code>assert(age &gt;= 0)</code> doesn't work in a Lean friendly way. In Scala,¬†<code>Int</code>¬†is a 32-bit signed integer value type, so this would be an example of type punning.</p>\n</blockquote>\n<p><code>assert(age &gt;= 0)</code> was meant as an example where expressing a constraint is <em>upleasant</em>, such that few programmers ever do it even in languages like Java.</p>\n<p>Anyway yes, it is true that sometimes we trade having simple cases be seamless to that we can unlock more advanced cases. But we often can still post-fact introduce syntax sugar for making the simple cases easy again. <code>Option a</code> is more powerful than <code>null | a</code>, but we also provide an implicit conversion from <code>a -&gt; Some a</code> where <code>Option a</code> is required to get the best of both worlds.</p>\n<p>I would look to F* as an example of a language that is far far more expressive than Scala while still having just as easy and often easier syntax. Yes this is largely because of their SMT solver, but even without one I assume there are ways we could improve the handling of subtypes in Lean.</p>",
        "id": 566662489,
        "sender_full_name": "Lhr",
        "timestamp": 1767761836
    }
]