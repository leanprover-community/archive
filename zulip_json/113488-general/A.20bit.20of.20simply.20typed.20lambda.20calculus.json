[
    {
        "content": "<p>A friend of mine read TAPL (that famous book with handwavey proofs) and made a simple programming language to solve AoC with it. I was inspired by this and decided to formalize a bit of typed lambda calculus in Lean.</p>\n<p>I never formalized lambda calculus before, but I heard some ideas. Like, locally nameless approach syntactically distinguishes free and bound variables, and normalization by evaluation uses de Bruijn levels for free variables and de Bruijn indices for bound variables.</p>\n<p>Since simply typed lambda calculus has \"simple\" in it's name, I decided that merely having ideas is enough and formalizing some basic results should be a quick and fun exercise.</p>\n<p>It took longer than I anticipated.</p>\n<p>But here's the result: <a href=\"https://github.com/suhr/lambda\">https://github.com/suhr/lambda</a></p>\n<p>The only thing I proved is type preservation, and it took 677 lines to do so.</p>\n<p>Comments are suggestions are very welcome. I wonder how I can simplify this thing and extend it do more interesting types (for example, System F).</p>",
        "id": 565678785,
        "sender_full_name": "suhr",
        "timestamp": 1767018444
    },
    {
        "content": "<p>In CSLib we have locally nameless implementations of both simple types and System F with subtyping if you'd like to compare. </p>\n<p>I only took a quick look, but there were a few things that seem different from what I'm used to. I didn't see a definition for local closure, in the definition of reduction or otherwise. You also seem to have some notions of shifting and indexing on contexts. This seems a bit opposed to the point of locally nameless in differentiating between bound and free variables.</p>",
        "id": 565681616,
        "sender_full_name": "Chris Henson",
        "timestamp": 1767019608
    },
    {
        "content": "<p>I see. So CSLib preserves names in the context, and this makes relation <code>Γ ⊢ e : α</code> much less rigid, since adding assumptions in the <em>middle</em> of Γ does not require to change <code>e</code>.</p>",
        "id": 565690815,
        "sender_full_name": "suhr",
        "timestamp": 1767023292
    },
    {
        "content": "<p>Yes, I wrote contexts to be a list of pairs of names and types. For any element of the context, there is a typing judgement then says that this name as a free variable has the corresponding type. In this way there is no sensitivity to the order of the context. There is then a theorem that permuting the context preserves derivations, and weakening is a further theorem instead of a constructor.</p>",
        "id": 565692369,
        "sender_full_name": "Chris Henson",
        "timestamp": 1767024020
    }
]