[
    {
        "content": "<p>I'm happy to share an experiment in building a web application with Lean:</p>\n<p><a href=\"https://leantodo.fly.dev/\">https://leantodo.fly.dev/</a></p>\n<p>It’s a simple in-browser todo app for creating and managing todos. This project uses two excellent Lean libraries by <span class=\"user-mention\" data-user-id=\"354934\">@David Thrane Christiansen</span>:</p>\n<ul>\n<li><a href=\"https://github.com/leanprover/leansqlite\">leansqlite</a> for database</li>\n<li><a href=\"https://github.com/leanprover/verso\">Verso</a> for HTML templating</li>\n</ul>\n<p>I see a lot of potential in Verso's HTML output for web development. It provides a JSX-like experience and makes it easy to compose HTML components in Lean using data pulled from SQLite. It also pairs nicely with HTML-centric tools like <a href=\"https://htmx.org/\">HTMX</a> and <a href=\"https://tailwindcss.com/\">Tailwind CSS</a>.<br>\nI could even <a href=\"https://github.com/pandaman64/LeanToDo/blob/ed2a35faea361a3dd435895ae32cef8c9ae9dcfa/.vscode/settings.json#L3\">enable</a> the Tailwind VSCode extension to auto-complete utility classes inside Verso's HTML macros!</p>\n<p>This repository has no proofs or dependent types. It's mostly procedural code and side effects. I hope it’s another useful example that Lean can be used for “normal” software, including web applications.</p>\n<p>The code is available at <a href=\"https://github.com/pandaman64/LeanToDo\">https://github.com/pandaman64/LeanToDo</a>. Thank you!</p>",
        "id": 570800633,
        "sender_full_name": "pandaman",
        "timestamp": 1769694991
    },
    {
        "content": "<p>I'm glad you had a good experience!  How did you like the interpolation API for SQLite prepared statements?</p>",
        "id": 570823744,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1769699935
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395416\">@pandaman</span>, this is awesome! Lovely to see all these new ecosystem capabilities in action.</p>\n<p>If you really want to live on the bleeding edge, Lean is getting its own HTTP server which you could use, see <a href=\"https://github.com/leanprover/lean4/pull/12151\">lean#12151</a>. (Or just set your lean-toolchain to <code>leanprover/lean4-pr-releases:pr-release-12151</code>, yolo...)</p>",
        "id": 570913986,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1769729086
    },
    {
        "content": "<p>The query! macro was nice. Things like implementing SQLite.Row and handling Stmt felt a bit low level, but I can definitely see a future where these are nicely wrapped. <br>\nI'll definitely try Lean.HTTP as I want to get rid of GPT's hacky implementation<span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span></p>",
        "id": 570932385,
        "sender_full_name": "pandaman",
        "timestamp": 1769741417
    },
    {
        "content": "<p>If you have suggestions for how to make the API more convenient, I'm all ears. This is the early days of it, and improvement driven by real use are very welcome. Or would <code>deriving SQLite.Row</code> have been sufficient?</p>",
        "id": 570946513,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1769751547
    },
    {
        "content": "<p>There's now a <a href=\"https://github.com/leanprover/leansqlite/pull/13\">deriving handler</a> for <code>Row</code>, along with <code>QueryParam</code> and <code>ResultColumn</code>.</p>",
        "id": 570966076,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1769761340
    },
    {
        "content": "<p>I’m very curious about the motivation for this sql stuff. David is there any information you’re allowed to share about why you worked on that?</p>",
        "id": 570966261,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1769761400
    },
    {
        "content": "<p>I'm in the process of redoing how Verso gets docstrings when rendering the manual. Right now, it looks in the environment, but this won't work with the module system because docstrings are stored in the server olean and aren't loaded in command-line builds. So instead doc-gen will be set up to dump a database in addition to HTML, and Verso will get them from the database.</p>",
        "id": 570967025,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1769761627
    },
    {
        "content": "<p>SQLite isn't strictly necessary for this, but it makes many things easier. Cross-cutting queries like \"give me all the instances for this type\" can run efficiently without needing to put work into how we represent the dumped data, and this flexibility will make it feasible to make Verso's output richer as well.</p>",
        "id": 570967391,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1769761741
    },
    {
        "content": "<p>It's also much easier to debug - there's great tools for SQLite already</p>",
        "id": 570967513,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1769761773
    },
    {
        "content": "<p>Being able to use the module system in the manual will greatly reduce incremental build times. The idea is to have the turnaround from \"changed text in chapter 5\" to reading the text on the screen be as short as possible.</p>",
        "id": 570967770,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1769761842
    },
    {
        "content": "<p>Great!</p>",
        "id": 570978994,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1769765414
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"354934\">@David Thrane Christiansen</span> Something that might be a lot of fun to explore for SELECT queries is to model them as composable data pipelines. <a href=\"https://prql-lang.org/\">https://prql-lang.org/</a> calls this \"orthogonality of transformations\".</p>",
        "id": 570989941,
        "sender_full_name": "Nilesh",
        "timestamp": 1769768539
    },
    {
        "content": "<p>Right now my goals are more aligned with getting tools out the door than exploration, but I'd love to see what you can come up with should you decide to explore it!</p>",
        "id": 570990167,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1769768603
    },
    {
        "content": "<blockquote>\n<p>If you have suggestions for how to make the API more convenient, I'm all ears. This is the early days of it, and improvement driven by real use are very welcome. Or would <code>deriving SQLite.Row</code> have been sufficient?</p>\n</blockquote>\n<p>The deriving handlers are great, but in general, I don't have a good answer.</p>\n<p>I'd expect there will be several \"opinionated\" approaches, including:</p>\n<ul>\n<li>Type and code generation a la <a href=\"https://github.com/sqlc-dev/sqlc\">sqlc</a></li>\n<li>type-safe query builder a la <a href=\"https://diesel.rs/\">diesel</a></li>\n<li>Or we could even bring <a href=\"https://smlsharp.github.io/en/documents/4.2.0/Ch12.html\">SML#'s SQL feature</a> to Lean, having a type system capable inferring SQL types!</li>\n</ul>\n<p>I don't see the programming community is converging on a single solution, and I'd love to see experiments around this area in Lean on top of lower-level bindings for SQLite, Postgres, MySQL, etc. (If I had infinite time...)</p>",
        "id": 570990591,
        "sender_full_name": "pandaman",
        "timestamp": 1769768741
    },
    {
        "content": "<p>Those sounds good!</p>\n<p>I wanted to avoid spending a bunch of time innovating on the interface to SQLite here, and focus on providing fairly complete bindings at a lower level, plus a certain minimum of convenience features like the result set iterator. I hope this library can be a basis for higher-level ones like you're describing, but those kinds of features are outside my current scope.</p>\n<p>Let me know if other papercuts come up, at least.</p>",
        "id": 570991288,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1769768939
    },
    {
        "content": "<p>Yeah, I think people can build their favorite high-level frameworks on top of bindings like yours.</p>\n<blockquote>\n<p>Let me know if other papercuts come up, at least.</p>\n</blockquote>\n<p>Will do. And thank again for the great library!</p>",
        "id": 570992023,
        "sender_full_name": "pandaman",
        "timestamp": 1769769171
    },
    {
        "content": "<p>Thanks for the good feedback, and for using it!</p>",
        "id": 570996821,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1769770570
    },
    {
        "content": "<p>Nice!<br>\nIf you want to use PostgreSQL for your backend, you may check these:</p>\n<ul>\n<li><a href=\"https://github.com/typednotes/lean-pq\">github.com/typednotes/lean-pq</a> (I wrote it, it's a binding to libpq)</li>\n<li><a href=\"https://github.com/kaito2/lean-pq\">github.com/kaito2/lean-pq</a> (looks cool, it's a rewrite of the postgres protocol in pure lean)</li>\n</ul>",
        "id": 575788462,
        "sender_full_name": "Nicolas Grislain",
        "timestamp": 1772029945
    }
]