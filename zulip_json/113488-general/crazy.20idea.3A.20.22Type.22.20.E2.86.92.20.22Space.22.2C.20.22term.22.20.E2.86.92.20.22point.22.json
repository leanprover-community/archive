[
    {
        "content": "<p>It just occurred to me: one of the pieces of friction when mathematicians start playing with formalization is that they have to change from their familiar \"elements\" in a \"Set\" to \"terms\" of a \"Type\". They get over it pretty quickly, but it's a papercut (and an important one to go through, e.g., <code>Set X</code> means functions <code>X ‚Üí Bool</code>, so we don't want to confuse things by calling <code>X</code> itself a Set). But mathematicians already have vocabulary for \"Type\" and \"term\", they just call them \"Space\" and \"point\"! I came to this realization when I was considering in my lecture today to call a <code>TopologicalSpace</code> a <code>TopologicalType</code> (it's a Type, with a topology on it). But why not meet people where they are? We already use \"Space\" in exactly the same way as \"Type\" is used in type theory. <code>VectorSpace</code> (ok, <code>Module</code>) is a Type with the structure of a vector space. <code>FunctionSpace</code> is the Type of <code>f : X ‚Üí Y</code>. <code>MeasureSpace</code>, <code>MetricSpace</code>. The dependent type <code>Œ†(x : A), B(x)</code> could be thought of as a \"function space from space A to the B-family of spaces,\" and <code>Œ£(x : A), B(x)</code> as a \"bundle space over A with fibers B(x).\" Even higher-order constructions like universes could be \"spaces of spaces.\" Etc etc. Mathematicians can also easily understand the \"Space of all proofs of proposition <code>P</code>\" and a \"point\" in this space corresponding to a proof of <code>P</code>. How impossible would it be to start talking about abstract points <code>x : X</code> of a <code>Space</code> <code>X</code> and dropping the \"term : Type\" vocabulary? I'm sure this suggestion will get immediately shot down, but thought I'd just throw it out there.</p>",
        "id": 524464470,
        "sender_full_name": "Alex Kontorovich",
        "timestamp": 1750169844
    },
    {
        "content": "<p>Isn't this, in fact, precisely the point of view that HoTT pushes you towards?</p>",
        "id": 524465250,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1750170034
    },
    {
        "content": "<p>Interesting! Here's my quick opinion. (I've used Lean a fair bit, but not yet taught a Lean course.)<br>\nSwitching all talk about Lean to this vocabulary is probably not good (as it will, for example, confuse computer scientist or type theorists) --- but for a project more focused on teaching, this could be worthwhile.</p>",
        "id": 524465504,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1750170103
    },
    {
        "content": "<p>I'm not trying to do anything to computer scientists or type theorists. I just have in mind that we mathematicians can tell each other: other people call \"points\" \"terms\" and \"Spaces\" \"Types\", so if you hear those funny words, that's what they mean. Maybe we can have an <code>abbrev</code> that <code>Space</code> is the same thing as <code>Type</code>? That would allow me to write:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">topologicalSpace</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Space</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">isOpen</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"w\">  </span><span class=\"n\">isOpen_univ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">isOpen</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">finiteInter</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">isOpen</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">isOpen</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">isOpen</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">‚à©</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">arbUnion</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œπ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)),</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">Œπ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">isOpen</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">isOpen</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">‚ãÉ</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">Œπ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>(Ok, I have to be more careful about universes, but some version of that?) So <code>X</code> is some abstract <code>Space</code>, and I'll put on top of it the structure of a topology, so it makes sense to now call it a <code>TopologicalSpace</code>...</p>",
        "id": 524475082,
        "sender_full_name": "Alex Kontorovich",
        "timestamp": 1750172870
    },
    {
        "content": "<p>I think category theory might also be useful in explaining type theory. Afterall, in Category Theory, it is not a well-formed question to ask about equality, which translates to the fact that we also don't talk about equality of types.</p>",
        "id": 524476062,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750173141
    },
    {
        "content": "<p>I have to second what Yael is saying, but extend it by pointing out that your intuition is guiding you towards models of type theory. Hoffman and Steicher‚Äôs groupoid interpretation might be your cup of tea as a mathematician.</p>",
        "id": 524482446,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1750175038
    },
    {
        "content": "<p>The example could be even more idiomatic if <code>Set X</code> was <code>ùí´ X</code> for the powerset and if <code>‚àà</code> was an alias for <code>:</code>.</p>",
        "id": 524488460,
        "sender_full_name": "Chase Norman",
        "timestamp": 1750177139
    },
    {
        "content": "<p>I get the sense that Mathlib tends to avoid having multiple names for the same concept (this would complicate lemma search, for instance).  But for downstream projects I think it would be fine.  </p>\n<p>Recently I formalized a ZFC-type set theory (with atoms) in Lean in <a href=\"https://github.com/teorth/analysis/blob/main/analysis/Analysis/Section_3_1.lean\">https://github.com/teorth/analysis/blob/main/analysis/Analysis/Section_3_1.lean</a> .  With some judicious <code>export</code>s and <code>variable</code>s, I can hide the usual laundry list of types and inferences one would ordinarily need in Lean, and pretend that I have some pre-existing types (or spaces, if you wish) <code>Set</code> and <code>Object</code> that obey all the axioms of ZFC (well, actually just ZF, as this section doesn't introduce choice yet).  This allows for clean statements such as</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">SetTheory</span><span class=\"bp\">.</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">compl_union</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">:</span><span class=\"n\">Set</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hAX</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">‚äÜ</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hBX</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">‚äÜ</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">‚à™</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚à©</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Types then barely show up (except at one annoying remaining technicality, in that an element <code>x:A</code> of <code>A:Set</code> is not an <code>Object</code> but rather belongs to the subtype <code>{ x // x ‚àà A}</code> of <code>Object</code> corresponding to that <code>Set</code>).  At the end of the Lean file I provide some API to convert things back to Mathlib's more type-theoretic <code>A: Set X</code> formalism.</p>\n<p>Similarly, for other sections of my book, I have found it relatively easy to introduce custom notation that aligns quite well with the spirit of my original text, and only at the end of the formalization do I provide the API to convert it back to the Mathlib analogues of the same concepts.  So one could do something similar here with files downstream from Mathlib that use your custom abbreviations such as <code>Space</code>.</p>",
        "id": 524488495,
        "sender_full_name": "Terence Tao",
        "timestamp": 1750177150
    },
    {
        "content": "<p>Back in the lean 3 days I once gave a department colloquium where I started by saying \"a type in lean is just another word for a collection of stuff, the same way that a set is\" and I then defined <code>Set</code> to mean <code>Type</code> (can't do this in lean 4 because Set is taken) and then just wrote <code>X : Set</code> all the way through my demo rather than <code>X : Type</code>.</p>",
        "id": 524498994,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1750181456
    },
    {
        "content": "<p>In the lean file I shared above, I was able to use <code>namespace</code>, <code>export</code>, and <code>variable</code> to override the Mathlib <code>Set X</code> (which now becomes <code>_root_.Set X</code>) and introduce my own type <code>Set</code> to be whatever I wanted (in particular, automatically obeying the axioms I wanted, which in this case were Zermelo-Frankel set theory with atoms).  (There is one line of code, <code>variable [SetTheory]</code>, that introduces all these axioms \"by fiat\".  But I never need to show that <code>SetTheory</code> is actually an inhabited type; Lean supports purely axiomatic reasoning just fine while hiding the type theory.)</p>",
        "id": 524500028,
        "sender_full_name": "Terence Tao",
        "timestamp": 1750181914
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"657719\">@Terence Tao</span> You might know this already, but Mathlib has a model of ZFC called <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/SetTheory/ZFC/Basic.html#ZFSet\">ZFSet</a>, and it might be a fun exercise for someone (maybe me) to show that Mathlib's <code>ZFSet</code> is an instance of your <code>SetTheory</code>. Not sure if I might run into universe issues though, I might only be able to prove it if I change your <code>Type</code> to <code>Type 1</code> <span aria-label=\"melt\" class=\"emoji emoji-1fae0\" role=\"img\" title=\"melt\">:melt:</span> <br>\n<a href=\"https://github.com/teorth/analysis/blob/main/analysis/Analysis/Section_3_1.lean#L38-L39\">https://github.com/teorth/analysis/blob/main/analysis/Analysis/Section_3_1.lean#L38-L39</a></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"c1\">-- Axiom 3.1</span>\n<span class=\"w\">  </span><span class=\"n\">Object</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"c1\">-- Axiom 3.1</span>\n</code></pre></div>",
        "id": 524501311,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750182419
    },
    {
        "content": "<p>It might as well be independent of Lean whether <code>SetTheory</code> is consistent, since it might be independent of Lean whether a universe exists in <code>Type</code> (there's no axiom saying that <code>Type</code> has to be the smallest universe)</p>",
        "id": 524501526,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750182515
    },
    {
        "content": "<p>Nice question.  My guess is that there will be some computability issues: my axioms permit replacement and substitution by arbitrary predicates, not just ones that are computable, or internally definable within the theory.  This may introduce some subtle issues (hopefully not Russell paradox-level issues though).</p>",
        "id": 524582850,
        "sender_full_name": "Terence Tao",
        "timestamp": 1750188754
    },
    {
        "content": "<p>Using <code>Prop</code> might indeed be problematic in a classical setting (with a very liberal use of the word \"classical\"), but I suspect it wouldn't be a problem here because <code>ZFSet</code> also uses arbitrary predicates:<br>\n<a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/SetTheory/ZFC/PSet.html#PSet.powerset\">PSet.powerset</a></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- The pre-set powerset operator -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">powerset</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PSet</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PSet</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">‚ü®</span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"kt\">Type</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">Func</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"bp\">‚ü©‚ü©</span>\n</code></pre></div>\n<p>A lot of things wouldn't be \"computable\", but it doesn't really matter in classical mathematics, at least in this context. We can't have computable models of ZFC in paper-mathematics either (assuming, well, ZFC is consistent).</p>",
        "id": 524587826,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750190718
    },
    {
        "content": "<p>i'm trying this right now (because it's a good excuse to get aquainted with <code>ZFSet</code> and its quircs), and curiously, <code>replace</code> seems to be somewhat annoying... In particular, the closest thing in the <code>ZFSet</code> api is <code>ZFSet.image</code> which <em>does not</em> take functional relation, but instead <em>an actual function</em>... As a result, i think proving this version requires mathlib's <code>choice</code> axiom...</p>",
        "id": 524590156,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1750191652
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"684366\">@Edward van de Meent</span> did you have to change <code>Type</code> to <code>Type 1</code>?</p>",
        "id": 524590501,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750191775
    },
    {
        "content": "<p>yes</p>",
        "id": 524590532,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1750191783
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/channel/113488-general/topic/crazy.20idea.3A.20.22Type.22.20.E2.86.92.20.22Space.22.2C.20.22term.22.20.E2.86.92.20.22point.22/near/524590156\">said</a>:</p>\n<blockquote>\n<p>i'm trying this right now (because it's a good excuse to get aquainted with <code>ZFSet</code> and its quircs), and curiously, <code>replace</code> seems to be somewhat annoying... In particular, the closest thing in the <code>ZFSet</code> api is <code>ZFSet.image</code> which <em>does not</em> take functional relation, but instead <em>an actual function</em>... As a result, i think proving this version requires mathlib's <code>choice</code> axiom...</p>\n</blockquote>\n<p>Yeah I wouldn't be surprised if you need <code>choice</code> everywhere</p>",
        "id": 524590584,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750191802
    },
    {
        "content": "<p>yea, most of these probably already use choice, it was just unexpected that i'd have to use it explicitly instead of the API being in such a way you don't notice it.</p>",
        "id": 524590756,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1750191860
    },
    {
        "content": "<p>I feel like if Tao's <code>P: Subtype (mem . A) ‚Üí Object ‚Üí Prop</code> had <code>Object</code> instead of <code>Subtype (mem . A)</code>, it might not even be possible to prove</p>",
        "id": 524591844,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750192294
    },
    {
        "content": "<p>since the ZFC thing seems to need some <code>Definable</code> instance</p>",
        "id": 524591871,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750192303
    },
    {
        "content": "<p>never mind, I guess in that case we would still be able to restrict the predicate to <code>A</code></p>",
        "id": 524591913,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750192323
    },
    {
        "content": "<p>I feel like this <code>Definable</code> thing can likely be created via choice</p>",
        "id": 524591943,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1750192338
    },
    {
        "content": "<p>yeah, probably</p>",
        "id": 524592012,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750192370
    },
    {
        "content": "<p>Yeah, I found to my annoyance that even when I did not explicitly assume choice in ZF set theory, I needed to work with \"unique choice\" in which any predicate <code>P x y</code> that had a unique solution <code>y</code> for each given <code>x</code> could be assigned a choice function.  This is much weaker than full choice, but I don't think it follows from constructive logic, so with Lean's standard axiom set I had no option other than to use choice.  I guess one could introduce a custom <code>unique_choice</code> axiom but I don't know how interesting it would be to anyone else to do so.</p>",
        "id": 524592976,
        "sender_full_name": "Terence Tao",
        "timestamp": 1750192811
    },
    {
        "content": "<p>You could write down the axiom as:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">uniqueChoice</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Subsingleton</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Œ±</span>\n</code></pre></div>\n<p>But yeah, I don't know if people would be interested in this, especially when <code>choice</code> is already so integrated with everything we do</p>",
        "id": 524593303,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750192981
    },
    {
        "content": "<p>Occasionally we get set theorists here who are well aware what AC is and are surprised that it's needed in lean to prove unique choice, which apparently is a theorem in <del>ZFC</del>ZF (I'm not an expert but this is my understanding; it's definitely not provable constructively in Lean's type theory though because AC in lean can be thought of as \"breaking out of Prop into Type\" which this is doing)</p>",
        "id": 524593347,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1750192998
    },
    {
        "content": "<p>yeah, ZFC doesn't really have the concept of \"data\", so every theorem is just Lean's Prop, so to prove unique choice you just write down the set</p>\n<p>as an analogy, to show that's it's more \"constructive\", the \"algorithm\" is to just take the intersection of the whole set, that will give you the unique element that is in a given set</p>",
        "id": 524593559,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750193103
    },
    {
        "content": "<p>(which is equivalent to taking the union of the whole set!)</p>",
        "id": 524593600,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750193121
    },
    {
        "content": "<p>constructing an equivalence between <code>ZFSet.omega</code> and <code>Nat</code> is surprisingly annoying</p>",
        "id": 524595140,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1750193861
    },
    {
        "content": "<p>i would have expected more API</p>",
        "id": 524595171,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1750193874
    },
    {
        "content": "<p>i suspect the map <code>ZFSet.omega -&gt; Nat</code> will require choice?</p>",
        "id": 524595460,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1750193973
    },
    {
        "content": "<p>I've not used set theory at all in Lean but isn't this just some straightforward recursion to define the map (from Nat to omega) and induction to prove it's injective and surjective?</p>",
        "id": 524595471,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1750193980
    },
    {
        "content": "<p>Can you use <code>Nat.rec</code> or just inductive matching <br>\nto build a map from <code>Nat</code> to <code>ZFSet.omega</code> and then later figure out how to prove that it is injective and surjective?</p>",
        "id": 524595496,
        "sender_full_name": "Terence Tao",
        "timestamp": 1750193990
    },
    {
        "content": "<p>silly me, i thought i'd need to define cardinality of <code>ZFSet</code>s first <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 524595685,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1750194061
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113488-general/topic/crazy.20idea.3A.20.22Type.22.20.E2.86.92.20.22Space.22.2C.20.22term.22.20.E2.86.92.20.22point.22/near/524593347\">said</a>:</p>\n<blockquote>\n<p>Occasionally we get set theorists here who are well aware what AC is and are surprised that it's needed in lean to prove unique choice, which apparently is a theorem in ZFC</p>\n</blockquote>\n<p>\"a theorem in ZF\" is what you meant, I assume</p>",
        "id": 524595814,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1750194107
    },
    {
        "content": "<p>[I'm not a mathematician]<br>\nMy mental model is that we're using a digital system with types that are expressive enough to encode mathematical concepts. I actually like the grounded terminology of terms and types because that's what is actually happening in the system. A different terminology would make me more confused as a learner (as it did in my early Lean days).</p>",
        "id": 524596079,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1750194226
    },
    {
        "content": "<p>By the way, is it possible to restrict choice in such a way, so non-constructive content is encapsulated in <code>Prop</code> (you can state the existence but can't get a standalone value in <code>Type</code>)? So you have calculus of propositions and calculus of problems in the spirit of <a href=\"https://arxiv.org/pdf/2307.09202\">https://arxiv.org/pdf/2307.09202</a>.</p>",
        "id": 524596094,
        "sender_full_name": "suhr",
        "timestamp": 1750194233
    },
    {
        "content": "<p>The issue with mathematicians is that they have typically literally never even heard of type theory, and whilst many of them have not done a formal course in set theory they are told on day 1 that a set is \"a collection of stuff, like the naturals or reals or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mn>37</mn><mo separator=\"true\">,</mo><mi>x</mi><mo separator=\"true\">,</mo><mrow><mi mathvariant=\"normal\">b</mi><mi mathvariant=\"normal\">u</mi><mi mathvariant=\"normal\">s</mi><mtext>¬†</mtext><mi mathvariant=\"normal\">s</mi><mi mathvariant=\"normal\">t</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">p</mi></mrow><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{37,x,\\mathrm{bus\\ stop}\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">37</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">bus</span><span class=\"mspace\">¬†</span><span class=\"mord mathrm\">stop</span></span><span class=\"mclose\">}</span></span></span></span>\" (and given no further information) and then later on that \"a group is a set equipped with...\", \"a manifold is a set equipped with...\", \"a metric space is a set equipped with...\", \"a perfectoid space is a set equipped with...\". So the language is ubiquitous even though many mathematicians never see a formal exposition of any foundational system.</p>",
        "id": 524596663,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1750194490
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/channel/113488-general/topic/crazy.20idea.3A.20.22Type.22.20.E2.86.92.20.22Space.22.2C.20.22term.22.20.E2.86.92.20.22point.22/near/524595140\">said</a>:</p>\n<blockquote>\n<p>constructing an equivalence between <code>ZFSet.omega</code> and <code>Nat</code> is surprisingly annoying</p>\n</blockquote>\n<p>Everything is defined explicitly using <code>PSet</code>, so I would just do explicit functions using those</p>",
        "id": 524598374,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750195132
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/channel/113488-general/topic/crazy.20idea.3A.20.22Type.22.20.E2.86.92.20.22Space.22.2C.20.22term.22.20.E2.86.92.20.22point.22/near/524595460\">said</a>:</p>\n<blockquote>\n<p>i suspect the map <code>ZFSet.omega -&gt; Nat</code> will require choice?</p>\n</blockquote>\n<p>The way Terry and I suggested to do it, yes (because you'll need the inverse of a bijection, which needs unique choice). I've not looked at the definition but the big question is whether the recursor needs AC. Because Nat is defined as an inductive type, you get its recursor for free in a computable way. But my guess is that omega will be defined in a far more obscure way so the question will be whether its eliminator can be made constructive.</p>",
        "id": 524599408,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1750195607
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ZFSet.omega#doc\">docs#ZFSet.omega</a></p>",
        "id": 524599472,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1750195625
    },
    {
        "content": "<p>Oh this looks like it might have a constructive recursor -- it's just Nat in disguise? Hmm it's Nat wrapped in a <code>Quotient.mk</code> and a ULift so the question is whether these are sufficiently constructive. It wouldn't surprise me...</p>",
        "id": 524599613,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1750195691
    },
    {
        "content": "<p>According to me, a constructive map should be possible.</p>",
        "id": 524601374,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750196580
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113488-general/topic/crazy.20idea.3A.20.22Type.22.20.E2.86.92.20.22Space.22.2C.20.22term.22.20.E2.86.92.20.22point.22/near/524599613\">said</a>:</p>\n<blockquote>\n<p>Oh this looks like it might have a constructive recursor -- it's just Nat in disguise? Hmm it's Nat wrapped in a <code>Quotient.mk</code> and a ULift so the question is whether these are sufficiently constructive. It wouldn't surprise me...</p>\n</blockquote>\n<p>At a glance, this will need choice because you don't get enough out of \"equivalent to something in the image of <code>PSet.ofNat</code>\" to be able to invert the map. You would need something like an explicit equivalence.</p>",
        "id": 524609164,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1750201969
    },
    {
        "content": "<p>But I don't need to invert any map, I'm defining both functions in both directions</p>",
        "id": 524610316,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750202824
    },
    {
        "content": "<p>I think it's not computable, since if it were you could decide any proposition (assuming this is what you meant):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsEmpty</span><span class=\"w\"> </span><span class=\"n\">PSet</span><span class=\"bp\">.</span><span class=\"n\">empty</span><span class=\"bp\">.</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"n\">PEmpty</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"bp\">‚ü©</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ZFSet</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">ZFSet</span><span class=\"bp\">.</span><span class=\"n\">omega</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">LeftInverse</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"w\">      </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"n\">ZFSet</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">PSet</span><span class=\"bp\">.</span><span class=\"n\">ofNat</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">up</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">rfl</span><span class=\"bp\">‚ü©</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Decidable</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PSet</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ULift</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">PLift</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">empty</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h0</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hnP</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬¨</span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">Equiv</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">empty</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsEmpty</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">hP</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">absurd</span><span class=\"w\"> </span><span class=\"n\">hP</span><span class=\"bp\">.</span><span class=\"n\">down</span><span class=\"bp\">.</span><span class=\"n\">down</span><span class=\"w\"> </span><span class=\"n\">hnP</span><span class=\"bp\">‚ü©</span>\n<span class=\"w\">    </span><span class=\"n\">PSet</span><span class=\"bp\">.</span><span class=\"n\">equiv_of_isEmpty</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">empty</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hP</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">Equiv</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">insert</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">empty</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">empty</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span>\n<span class=\"w\">    </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"n\">none</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">rfl</span><span class=\"bp\">‚ü©</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"bp\">‚ü®.</span><span class=\"n\">up</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">up</span><span class=\"w\"> </span><span class=\"n\">hP</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">rfl</span><span class=\"bp\">‚ü©</span><span class=\"w\"> </span><span class=\"n\">PEmpty</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"bp\">‚ü©</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">PSet</span><span class=\"bp\">.</span><span class=\"n\">omega</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">byCases</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">hP</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">‚ü®.</span><span class=\"n\">up</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"n\">hP</span><span class=\"bp\">‚ü©</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">hnP</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">‚ü®.</span><span class=\"n\">up</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h0</span><span class=\"w\"> </span><span class=\"n\">hnP</span><span class=\"bp\">‚ü©</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h‚ÇÄ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hnP</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬¨</span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"n\">ZFSet</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">‚ü©</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">congrArg</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Subtype</span><span class=\"bp\">.</span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ZFSet</span><span class=\"bp\">.</span><span class=\"n\">sound</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h0</span><span class=\"w\"> </span><span class=\"n\">hnP</span><span class=\"o\">))))</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h‚ÇÅ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hP</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"n\">ZFSet</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">‚ü©</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">congrArg</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Subtype</span><span class=\"bp\">.</span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ZFSet</span><span class=\"bp\">.</span><span class=\"n\">sound</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"n\">hP</span><span class=\"o\">))))</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">decidable_of_iff</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"n\">ZFSet</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">‚ü©</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">byCases</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">hP</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">hP</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">h‚ÇÅ</span><span class=\"w\"> </span><span class=\"n\">hP</span><span class=\"bp\">‚ü©</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">hnP</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"bp\">‚ü®</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">absurd</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">h‚ÇÄ</span><span class=\"w\"> </span><span class=\"n\">hnP</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero_ne_one</span><span class=\"o\">,</span>\n<span class=\"w\">        </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">hP</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">absurd</span><span class=\"w\"> </span><span class=\"n\">hP</span><span class=\"w\"> </span><span class=\"n\">hnP</span><span class=\"bp\">‚ü©</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 524612104,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1750204448
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"816344\">@Aaron Liu</span> hmm, it does seem to be not as simple as I thought. It might also depend on the definition of \"function\". I was hoping that I could just define a PSet explicitly and then interpret it as a function.</p>\n<p>It also seems like this latter approach might still work if we change the definition of function to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/SetTheory/ZFC/Basic.html#ZFSet.funs\">ZFSet.funs</a>.</p>\n<p>(But then of course this would have nothing to do with the axioms stated by Tao)</p>",
        "id": 524612663,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750204923
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113488-general/topic/crazy.20idea.3A.20.22Type.22.20.E2.86.92.20.22Space.22.2C.20.22term.22.20.E2.86.92.20.22point.22/near/524599408\">said</a>:</p>\n<blockquote>\n<p>yes (because you'll need the inverse of a bijection, which needs unique choice)</p>\n</blockquote>\n<p>You can also define the inverse map using <code>Nat.find</code> (but it requires <code>DecidableEq</code>).</p>",
        "id": 524636328,
        "sender_full_name": "Jz Pan",
        "timestamp": 1750227764
    },
    {
        "content": "<p>These details BTW are exactly why <code>Definable</code> exists; they give some conditions under which you can construct such a function without choice. In practice it didn't really work out, and there is a classical instance making everything <code>Definable</code></p>",
        "id": 524662729,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1750238170
    },
    {
        "content": "<p>indeed, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Classical.allZFSetDefinable#doc\">docs#Classical.allZFSetDefinable</a></p>",
        "id": 524662849,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1750238210
    },
    {
        "content": "<p>Personally I try and teach and use the pair (element, Type) as it is consistent with the type theory literature, but one less new word for people to learn</p>",
        "id": 524730896,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1750259687
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"252920\">Alex Kontorovich</span> <a href=\"#narrow/channel/113488-general/topic/crazy.20idea.3A.20.22Type.22.20.E2.86.92.20.22Space.22.2C.20.22term.22.20.E2.86.92.20.22point.22/near/524464470\">said</a>:</p>\n<blockquote>\n<p>We already use \"Space\" in exactly the same way as \"Type\" is used in type theory.</p>\n</blockquote>\n<p>I don't think this is actually true, or at the very least depends heavily on what part of math someone is from. The use of the word space in math is almost always either historical/idiomatic (as in 'vector space') or somehow related to some topological notion. </p>\n<p>If you start telling a typical mathematician about a group <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> and then casually mention the 'underlying space of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span>', they will assume that the group in question is a topological group or at least something very similar, rather than an abstract group. Imagine trying to clarify this: 'no, the elements of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> don't live in a topological space, they just live in a space'. This just isn't how mathematicians talk.</p>\n<p>The identification of types with spaces in HoTT is also pretty narrow relative to the general sense of the word 'space' in mathematics.</p>",
        "id": 524802845,
        "sender_full_name": "James E Hanson",
        "timestamp": 1750295604
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/channel/113488-general/topic/crazy.20idea.3A.20.22Type.22.20.E2.86.92.20.22Space.22.2C.20.22term.22.20.E2.86.92.20.22point.22/near/524592976\">said</a>:</p>\n<blockquote>\n<p>This is much weaker than full choice, but I don't think it follows from constructive logic,</p>\n</blockquote>\n<p>To some extent this depends on which 'brand' of constructive mathematics you're talking about. Unique choice is provable in the context of topos theory and constructive set theory. As far as I know it really wasn't until the advent of modern type theory that people starting thinking about systems that don't prove unique choice. Also, for what it's worth, I believe that there are systems with classical logic in which it isn't provable, so it is in some sense orthogonal to constructivity.</p>",
        "id": 524803638,
        "sender_full_name": "James E Hanson",
        "timestamp": 1750296592
    },
    {
        "content": "<p>Unique choice and function extensionality are both provable in cubical type theory as well, which is another flavor of constructive type theory. This is the main reason in my opinion that cubical type theory despite all of the higher homotopy stuff turns out to be the most \"normal\" constructive type theory that has a usable implementation currently (cubical Agda).</p>",
        "id": 525930507,
        "sender_full_name": "Max New",
        "timestamp": 1750951520
    },
    {
        "content": "<p>but there the definition of <code>Prop</code> is different: a <code>Prop</code> is a <code>Type</code> all of whose elements are equal</p>",
        "id": 525931484,
        "sender_full_name": "Max New",
        "timestamp": 1750951844
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"115247\">Max New</span> <a href=\"#narrow/channel/113488-general/topic/crazy.20idea.3A.20.22Type.22.20.E2.86.92.20.22Space.22.2C.20.22term.22.20.E2.86.92.20.22point.22/near/525931484\">said</a>:</p>\n<blockquote>\n<p>but there the definition of <code>Prop</code> is different: a <code>Prop</code> is a <code>Type</code> all of whose elements are equal</p>\n</blockquote>\n<p>I am confused by this statement. How is that different from this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h‚ÇÅ</span><span class=\"w\"> </span><span class=\"n\">h‚ÇÇ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">h‚ÇÅ</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">h‚ÇÇ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 525932908,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1750952301
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"115247\">Max New</span> <a href=\"#narrow/channel/113488-general/topic/crazy.20idea.3A.20.22Type.22.20.E2.86.92.20.22Space.22.2C.20.22term.22.20.E2.86.92.20.22point.22/near/525931484\">said</a>:</p>\n<blockquote>\n<p>all of whose elements are equal</p>\n</blockquote>\n<p>provably or judgementally?</p>",
        "id": 525933238,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1750952408
    },
    {
        "content": "<p>Provably, afaik. That is the difference to Lean</p>",
        "id": 525933302,
        "sender_full_name": "ùö†ùöòùöìùöåùöíùöéùöåùöë ùöóùöäùö†ùöõùöòùöåùöîùöí",
        "timestamp": 1750952433
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/113488-general/topic/crazy.20idea.3A.20.22Type.22.20.E2.86.92.20.22Space.22.2C.20.22term.22.20.E2.86.92.20.22point.22/near/525932908\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"115247\">Max New</span> <a href=\"#narrow/channel/113488-general/topic/crazy.20idea.3A.20.22Type.22.20.E2.86.92.20.22Space.22.2C.20.22term.22.20.E2.86.92.20.22point.22/near/525931484\">said</a>:</p>\n<blockquote>\n<p>but there the definition of <code>Prop</code> is different: a <code>Prop</code> is a <code>Type</code> all of whose elements are equal</p>\n</blockquote>\n<p>I am confused by this statement. How is that different from this:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h‚ÇÅ</span><span class=\"w\"> </span><span class=\"n\">h‚ÇÇ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">h‚ÇÅ</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">h‚ÇÇ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>In lean, all <code>Prop</code>s satisfy this definition, but in cubical type theory you define a new type <code>hProp</code> to be a pair of a <code>P : Type</code> and a proof that <code>forall p1 p2 : P. p1 = p2</code>. But you don't get definitional proof irrelevance which is a big difference from Lean</p>",
        "id": 525933737,
        "sender_full_name": "Max New",
        "timestamp": 1750952581
    },
    {
        "content": "<p>On mastodon I've been pointed to these slides from an expert on this stuff that suggests they think this is the major sticking point, the principle of unique choice and definitional proof irrelevance seem irreconcilable constructively: <a href=\"https://pujet.fr/pdf/uniquechoice_slides.pdf\">https://pujet.fr/pdf/uniquechoice_slides.pdf</a></p>",
        "id": 525934399,
        "sender_full_name": "Max New",
        "timestamp": 1750952788
    }
]