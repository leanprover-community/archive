[
    {
        "content": "<p>I am trying to build some framework about lattices (or Boolean algebras) where the suprema and infima of any countable collection exist.<br>\nIf we have a <code>Lattice</code> that is also an <code>OmegaCompletePartialOrder</code>, then for any countable collection, we can take the chain of finite supremas, this has a supremum which is exactly the supremum of the original collection.</p>\n<p>My problem is that I cannot find any infimum based version of <code>OmegaCompletePartialOrder</code>, it feels like it would therefore make sense to create it. This would mimic <code>CompleteSemilatticeSup</code> and <code>CompleteSemilatticeInf</code> that are combined to give <code>CompleteLattice</code>. But this feels like a problem as <code>OmegaCompletePartialOrder</code> should probably be the name of the combination of some <code>OmegaCompletePartialOrderSup</code> and <code>OmegaCompletePartialOrderInf</code>.</p>\n<p>I'm not sure how to achieve this without either picking names that are not nice or redefining <code>OmegaCompleteSemilattice</code> to be a closed under suprema and infima of countable chains.</p>\n<p>One last thing, the definition of a <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Order/OmegaCompletePartialOrder.html#OmegaCompletePartialOrder.Chain\">OmegaCompletePartialOrder.Chain</a> is <code>([ℕ](https://leanprover-community.github.io/mathlib4_docs/Init/Prelude.html#Nat) [→o](https://leanprover-community.github.io/mathlib4_docs/Mathlib/Order/Hom/Basic.html#OrderHom) α)</code> which makes it complicated to take infima meaningfully (compared to a definition of chain as a totally ordered subset of a partial order).</p>\n<p>Any idea or suggestion would be welcome.</p>",
        "id": 530619426,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1753380357
    },
    {
        "content": "<p>I wonder why <code>ωSup</code> wasn't defined as <code>ωSup : (s : Set α) → s.Countable → α</code>, or something similar. Or is the existence of suprema for things that aren't chains not guaranteed?</p>",
        "id": 530862801,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1753485356
    },
    {
        "content": "<p>If only countable chains have suprema, perhaps its easier to redefine <code>OmegaCompletePartialOrder.Chain s</code> as <code>IsChain (· ≤ ·) s ∧ s.Countable</code>. I think that should be the same condition you want for the infimum.</p>",
        "id": 530862987,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1753485484
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"459227\">@Violeta Hernández</span> The existence of arbitrary countable sets (non-chains) is guaranteed only in a Omega complete lattice which is simply a Lattice that is also Omega Complete.</p>\n<p>I like this definition of chain better than the current one as it doesn't restrict them to have a minimal element. Otherwise you would need a dual concept to chains and that can get messy, I will try to see how hard it is to replace.</p>\n<p>Note that with this definition, then <code>ωSup</code> is in some sense a <code>sSup</code> that is LUB. In <code>ConditionallyCompleteLattice</code>, <code>sSup</code> is defined on all <code>s : Set α</code> and <code>IsLUB s (sSup s)</code> is guaranteed if <code>s</code> is bounded above and non-empty. Similarly, we could replace defining <code>ωSup</code> by inheriting from <code>SupSet</code>, thereby defining <code>sSup</code>, and guaranteeing that <code>IsLUB s (sSup s)</code> whenever <code>IsChain (· ≤ ·) s ∧ s.Countable</code>. If we do that, then defining <code>OmegaCompleteLattice</code> only requires us to inherit from <code>Lattice</code>, <code>OmegaCompletePartialOrder</code> and its dual counterpart (which would give <code>sInf</code>). Finally, we can show that this must be closed under countable supremum and infimum.</p>",
        "id": 530917623,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1753520518
    },
    {
        "content": "<p>Does this mean we'd get rid of <code>ωSup</code> and simply make use of <code>sSup</code> but with a different set of axioms?</p>",
        "id": 530919751,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1753521770
    },
    {
        "content": "<p>I like that approach.</p>",
        "id": 530919785,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1753521788
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"459227\">@Violeta Hernández</span>  That is an option. I can see several pros such as getting <code>iSup</code> and associated notations for free. I can see one con which is that we force users to define <code>sSup</code> even on set that cannot have a supremum, I'm not sure of how much this is a problem.</p>",
        "id": 530919974,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1753521890
    },
    {
        "content": "<p>I don't think it should be any more of a problem than it is for <code>ConditionallyCompleteLattice</code>. As long as your type is inhabited you can always provide some convenient dummy value.</p>",
        "id": 530920089,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1753521957
    },
    {
        "content": "<p>I doubt this is a problem in practice: One can always do <code>if blah then decent_sSup else junk_value</code></p>",
        "id": 530920102,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1753521969
    },
    {
        "content": "<p>You could even wrap this into a constructor that requires the user to merely provide <code>decent_sSup</code></p>",
        "id": 530920140,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1753521995
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/113488-general/topic/Any.20infimum.20based.20version.20of.20.60OmegaCompletePartialOrder.60.3F/near/530920140\">said</a>:</p>\n<blockquote>\n<p>You could even wrap this into a constructor that requires the user to merely provide <code>decent_sSup</code></p>\n</blockquote>\n<p>That would indeed be helpful, I might add this to <code>ConditionallyCompleteLattice</code>independently if it does not exist</p>",
        "id": 530920249,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1753522055
    },
    {
        "content": "<p>Okay then I will explore that direction. I am still unsure about naming, I would vouch for something like</p>\n<ul>\n<li><code>OmegaCompletePartialOrderSup</code> is the equivalent of the current <code>OmegaCompletePartialOrder</code></li>\n<li><code>OmegaCompletePartialOrderInf</code> its dual notion with <code>sInf</code></li>\n<li><code>OmegaCompletePartialOrder</code> extends both classes above.</li>\n</ul>\n<p>I think that doing this might be problematic for users that construct some <code>OmegaCompletePartialOrder</code> as they would need to provide the dual notion with <code>sInf</code>. But in any case they might lose <code>ωSup</code> so there will be some work for them.</p>",
        "id": 530920780,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1753522350
    },
    {
        "content": "<p>Do we have a typeclass for <code>(∃ x, IsLUB s x) → IsLUB s (sSup s)</code> (and its dual)?</p>",
        "id": 530924612,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753524501
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/113488-general/topic/Any.20infimum.20based.20version.20of.20.60OmegaCompletePartialOrder.60.3F/near/530924612\">said</a>:</p>\n<blockquote>\n<p>Do we have a typeclass for <code>(∃ x, IsLUB s x) → IsLUB s (sSup s)</code> (and its dual)?</p>\n</blockquote>\n<p>IMO we should, and any subclass of <code>SupSet</code> should inherit from it. I think this means that we should add this in <code>SupSet</code>. Also this would make the default constructor easy (and not depend on inhabited). I'm tempted to do a PR with that, any objection?</p>",
        "id": 530942910,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1753534359
    },
    {
        "content": "<p>I think this is a much better way to define <code>sSup</code> than what we have right now. So then a complete lattice is one where every set has LUB and GLB, a conditionally complete lattice is one where every bounded set has a LUB and GLB, and an omega complete lattice is one where every countable chain has LUB and GLB.</p>",
        "id": 530997290,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1753560900
    },
    {
        "content": "<p>And as a bonus we don't need <code>ConditionallyCompleteLinearOrderBot</code> as a separate structure! The condition <code>sSup ∅ = bot</code> follows directly from this typeclass + the existence of a bottom element.</p>",
        "id": 530997401,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1753560955
    },
    {
        "content": "<p>We can also have constructors that simply require proofs of existence for the LUB and GLB, and construct the sup/inf nonconstructively. In nearly all cases <code>sSup</code> and <code>sInf</code> are noncomputable anyways.</p>",
        "id": 530997633,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1753561069
    },
    {
        "content": "<p>All very nice indeed, I'm still unsure on how to proceed as <code>SupSet</code> is part of <code>SetNotation</code>, and I think this goes beyond set notations and deserves its own type class. But then we do need <code>SupSet</code> to define <code>sSup</code> to be able to define <code>iSup</code> in <code>SetNotation</code>, so I am not sure what is the best way to proceed.</p>",
        "id": 530999967,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1753562158
    },
    {
        "content": "<p>Yeah, this shouldn't be part of <code>sSup</code>, that typeclass should be purely notational. We can define a typeclass like e.g. <code>LawfulSup</code> with the condition <code>IsLUB s x -&gt; sSup s = x</code>.</p>",
        "id": 531001672,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1753562933
    },
    {
        "content": "<p>I think that should initially go in a new file, and then we can work on subsequent PRs that redefine the existing lattice typeclasses to extend <code>LawfulSup</code> / <code>LawfulInf</code>.</p>",
        "id": 531001903,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1753563035
    },
    {
        "content": "<p>Tag me in these PRs and I'll be sure to review them!</p>",
        "id": 531002038,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1753563105
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 531003025,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1753563561
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/stream/113488-general/topic/Any.20infimum.20based.20version.20of.20.60OmegaCompletePartialOrder.60.3F/near/531003025\">said</a>:</p>\n<blockquote>\n<p>Oh, I'm wrong about <code>ConditionallyCompleteLinearOrderBot</code>. The theorem <code>sSup ∅ = bot</code> just assigns a convenient junk value, it's not really a mathematical condition.</p>\n</blockquote>\n<p>no?</p>",
        "id": 531032377,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753577946
    },
    {
        "content": "<p>We have <code>IsLUB ∅ x ↔ IsBot x</code></p>",
        "id": 531032547,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753578012
    },
    {
        "content": "<p>Oh</p>",
        "id": 531032687,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1753578085
    },
    {
        "content": "<p>You're right, it's <code>sInf ∅</code> that doesn't exist</p>",
        "id": 531032865,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1753578166
    },
    {
        "content": "<p>The docstring is a bit misleading then, <code>sSup ∅ = bot</code> isn't a convention, it's a theorem!</p>",
        "id": 531032940,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1753578211
    },
    {
        "content": "<p>But it's unfortunately not provable from the axioms of a <code>ConditionallyCompleteLinearOrderBot</code></p>",
        "id": 531033313,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753578357
    },
    {
        "content": "<p>unless you add it in explicitly</p>",
        "id": 531033345,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753578374
    },
    {
        "content": "<p>which is what has been done here</p>",
        "id": 531033363,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753578384
    },
    {
        "content": "<p>Yeah, but it is provable from the axiom of <code>LawfulSup</code>!</p>",
        "id": 531033368,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1753578387
    },
    {
        "content": "<p>So the typeclass will be redundant after the refactor</p>",
        "id": 531033415,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1753578408
    },
    {
        "content": "<p>And I'm glad! It's awful having to write it down</p>",
        "id": 531033451,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1753578419
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/stream/113488-general/topic/Any.20infimum.20based.20version.20of.20.60OmegaCompletePartialOrder.60.3F/near/531001672\">said</a>:</p>\n<blockquote>\n<p>Yeah, this shouldn't be part of <code>sSup</code>, that typeclass should be purely notational. We can define a typeclass like e.g. <code>LawfulSup</code> with the condition <code>IsLUB s x -&gt; sSup s = x</code>.</p>\n</blockquote>\n<p>This means <code>LawfulSSup</code> would not be preserved under order equivalences, which I don't like</p>",
        "id": 531033586,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753578477
    },
    {
        "content": "<p>I think instead we should have the slighly weaker version <code>IsLUB s x -&gt; IsLUB s (sSup x)</code></p>",
        "id": 531033713,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753578539
    },
    {
        "content": "<p>Sure. The stronger version is satisfied by any partial order, anyways.</p>",
        "id": 531035352,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1753579303
    },
    {
        "content": "<p>A lot of results in <code>CompleteLattice</code>, <code>ConditionallyCompleteLattice</code> and later <code>OmegaCompleteLattice</code> are in essence the same result. They typically have a proof of existence of some <code>sSup s</code>, then it proves some fact and then the existence of a new <code>sSup</code>. As an example, if <code>IsLUB s (sSup s)</code> then for any <code>a</code>, we have  <code>IsLUB {a ⊔ b | b ∈ s } (a ⊔ (sSup s))</code>, then we combine this fact with the a proof of the first to get the second one and finally a proof that <code>{a ⊔ b | b ∈ s }</code> has LUB <code>sSup {a ⊔ b | b ∈ s }</code>. The end result would prove <code>sSup {a ⊔ b | b ∈ s } = a ⊔ sSup s</code> given appropriate assumptions to prove the existence of both.</p>\n<p>But if we work and the level of <code>Lattice</code> and we can provide <code>sSup</code> for any <code>Lattice</code> with a constructor of <code>LawfulSup</code>, then we can provide a proof of <code>IsLUB s (sSup s) → IsLUB {a ⊔ b | b ∈ s } (a ⊔ (sSup s))</code>. Then in all subclass we can use assumptions to deduce existence.</p>",
        "id": 531078217,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1753598041
    },
    {
        "content": "<p>Apologies if I am stating the obvious, but if you really are interested in rewriting complete lattices, have you thought of looking at how (co)complete <em>categories</em> are dealt with in mathlib?</p>",
        "id": 531087363,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1753601998
    },
    {
        "content": "<p>I know very little of category theory and have not started browsing the Category folder. If you have a good entry point, I would be glad to take it.</p>",
        "id": 531088870,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1753602654
    },
    {
        "content": "<p>In Lattice, we will get <code>sSup s</code> and <code>sInf s</code> whenever s is finite quite naturally. That's nice.</p>",
        "id": 531192206,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1753642021
    },
    {
        "content": "<p>I think this all sounds really good and I'm interested.</p>",
        "id": 531242965,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1753663027
    },
    {
        "content": "<p>In OmegaCompleteLattice, should we provide a constructor for a LawfulSupInf rather than extending it?</p>",
        "id": 531289918,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1753686097
    },
    {
        "content": "<p>In <a href=\"https://github.com/leanprover-community/mathlib4/pull/27534\">#27534</a> I have a problem:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Preorder</span><span class=\"bp\">.</span><span class=\"n\">toLawfulSup</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Preorder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Inhabited</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">LawfulSup</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">sSup</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">choose</span><span class=\"w\"> </span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">default</span>\n<span class=\"w\">  </span><span class=\"n\">isLUB_sSup_of_exists_isLUB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hs</span><span class=\"bp\">⟩</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">dif_pos</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">choose_spec</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hs</span><span class=\"bp\">⟩</span>\n</code></pre></div>\n<p>Seems to be fine, but adding a docstring in front of it makes the <code>open</code> unhapy:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">unexpected</span><span class=\"w\"> </span><span class=\"n\">token</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"kn\">open</span><span class=\"bp\">';</span><span class=\"w\"> </span><span class=\"n\">expected</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"kn\">lemma</span><span class=\"bp\">'</span>\n</code></pre></div>\n<p>Note that this was not a problem with <code>instance</code> instead of <code>def</code> but it feels like this should work.</p>\n<p>EDIT: This could be fixed by using:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- Defines `sSup` so as to return an arbitrary LUB when it exists, and a default element otherwise.</span>\n<span class=\"sd\">-/</span>\n<span class=\"c1\">-- open Classical in</span>\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Preorder</span><span class=\"bp\">.</span><span class=\"n\">toLawfulSup</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Preorder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Inhabited</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Decidable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LawfulSup</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">sSup</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">choose</span><span class=\"w\"> </span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">default</span>\n<span class=\"w\">  </span><span class=\"n\">isLUB_sSup_of_exists_isLUB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hs</span><span class=\"bp\">⟩</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">dif_pos</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">choose_spec</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hs</span><span class=\"bp\">⟩</span>\n</code></pre></div>\n<p>It is also possible to have <code>[∀ s : Set α, Decidable (∃ x, IsLUB s x)]</code> but I think that the first one is <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Prelude.html#Decidable\">prefered</a>. Those two approaches make the def heavy, but would be trivial when using Classical.<br>\nNot sure what is preferable and if the previous behavior is wrong and should be reported.</p>",
        "id": 531294209,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1753687575
    },
    {
        "content": "<p>You have to put the docstring after <code>open</code></p>",
        "id": 531326413,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753697148
    },
    {
        "content": "<p>Since <code>open ... in</code> expands to a <code>section ... end</code></p>",
        "id": 531326616,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753697210
    },
    {
        "content": "<p>Decidability should be reserved to two circumstances:</p>\n<ul>\n<li>you need it for your statement to even type check</li>\n<li>you want computability</li>\n</ul>\n<p>Here you're getting neither, so it's better to just use <code>Classical.choice</code> instead.</p>",
        "id": 531465103,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1753737925
    },
    {
        "content": "<p>You can never have such a decidability hypothesis anyways since it would decide the halting problem</p>",
        "id": 531474800,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753742500
    },
    {
        "content": "<p>Just use classical</p>",
        "id": 531474810,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753742505
    },
    {
        "content": "<p>Okay, so what is the next step here? <span class=\"user-mention\" data-user-id=\"459227\">@Violeta Hernández</span> it feels like you had in mind changing axioms of all class that currently inherit from <code>SupSet</code> and <code>InfSet</code> to provide existential statements (and therefore not inheriting from <code>SupSet</code> and <code>InfSet</code>?). So for instance, in <code>Conditionally CompleteLattice</code>, we currently have this definition:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">ConditionallyCompleteLattice</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">Lattice</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">SupSet</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">InfSet</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- `a ≤ sSup s` for all `a ∈ s`. -/</span>\n<span class=\"w\">  </span><span class=\"n\">le_csSup</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">BddAbove</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">sSup</span><span class=\"w\"> </span><span class=\"n\">s</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- `sSup s ≤ a` for all `a ∈ upperBounds s`. -/</span>\n<span class=\"w\">  </span><span class=\"n\">csSup_le</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">upperBounds</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">sSup</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- `sInf s ≤ a` for all `a ∈ s`. -/</span>\n<span class=\"w\">  </span><span class=\"n\">csInf_le</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">BddBelow</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">sInf</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- `a ≤ sInf s` for all `a ∈ lowerBounds s`. -/</span>\n<span class=\"w\">  </span><span class=\"n\">le_csInf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">lowerBounds</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">sInf</span><span class=\"w\"> </span><span class=\"n\">s</span>\n</code></pre></div>\n<p>Now I think that <code>le_csSup</code> and <code>csInf_le</code> might now be irrelevant as we would want to prove that <code>BddAbove</code> implies that there exists an element above the set (trivial). Therefore I think this all can be simplified to</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">ConditionallyCompleteLattice</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">Lattice</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">exists_isLUB_of_nonempty_bounded</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">BddAbove</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"n\">exists_isGLB_of_nonempty_bounded</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">BddAbove</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>\n<p>And then we can make a constructor for <code>LawfulSupInf</code>.</p>\n<p>Is that an oversimplification?</p>",
        "id": 531549907,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1753779043
    },
    {
        "content": "<p>All you say makes sense to me</p>",
        "id": 531550253,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1753779134
    },
    {
        "content": "<p>some git question. If I branch the PR with Lawful stuff, as bors squashes the commits that I made, will there be any problem if I <code>git rebase</code> my branch on master later on? Or is there another way to do that?</p>",
        "id": 531551363,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1753779417
    },
    {
        "content": "<p>No, there will no problem. Personally my git commits look like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">feat</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">first</span><span class=\"w\"> </span><span class=\"n\">PR</span>\n<span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">more</span>\n<span class=\"n\">fix</span>\n<span class=\"n\">fix</span>\n<span class=\"n\">fix</span>\n<span class=\"n\">bleh</span>\n<span class=\"n\">feat</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">second</span><span class=\"w\"> </span><span class=\"n\">PR</span>\n<span class=\"n\">fix</span>\n<span class=\"n\">whoops</span>\n<span class=\"n\">fix</span>\n<span class=\"n\">feat</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">third</span><span class=\"w\"> </span><span class=\"n\">PR</span>\n<span class=\"n\">etc</span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>Then when the first PR gets merged, I rebase the second PR onto master by dropping</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">feat</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">first</span><span class=\"w\"> </span><span class=\"n\">PR</span>\n<span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">more</span>\n<span class=\"n\">fix</span>\n<span class=\"n\">fix</span>\n<span class=\"n\">fix</span>\n<span class=\"n\">bleh</span>\n</code></pre></div>\n<p>and then rebase the third PR onto the second PR's branch by dropping</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">feat</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">first</span><span class=\"w\"> </span><span class=\"n\">PR</span>\n<span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">more</span>\n<span class=\"n\">fix</span>\n<span class=\"n\">fix</span>\n<span class=\"n\">fix</span>\n<span class=\"n\">bleh</span>\n</code></pre></div>\n<p>again.</p>",
        "id": 531552136,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1753779621
    },
    {
        "content": "<p>oh so when you rebase you do it interactively and you drop the commits, makes sense. Thanks!</p>",
        "id": 531552599,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1753779718
    },
    {
        "content": "<p>Yes, I was inspired by the \"stacked diffs\" philosophy. The workflow I just described above is seemingly the closest you get from true stacked diffs if you want to stick with github</p>",
        "id": 531553710,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1753779952
    },
    {
        "content": "<p>Most (if not all) of the <code>csSup</code> and <code>csInf</code> results in <code>ConditionallyCompleteLattice</code> will now take one of <code>[LawfulSup α]</code>, <code>[LawfulInf α]</code> or <code>[LawfulSupInf α]</code>. In <code>CompleteLattice</code>, we can define an instance of <code>LawfulSupInf α</code> rather than a def as we do not need Classical. For this reason, I don't think we will need to condition the <code>sSup</code> and <code>sInf</code> results on the lawful results.</p>\n<p>Some of the results in both of those can now be factorized in <code>Lattice</code>or even <code>Preorder</code>  as if we condition on <code>LawfulSup</code>, we have e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">le_sSup</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Preorder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LawfulSup</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">sSup</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I am not certain that those results are important, but maybe results that are more involved proofwise will be useful to factorize some proofs from all <code>Complete</code> kind of partial orders (<code>CompleteLattice</code>, <code>ConditionallyCompleteLattice</code>, <code>OmegaCompletePartialOrder</code>, <code>ComplettePartialOrder</code>, etc..).</p>",
        "id": 531645204,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1753804424
    },
    {
        "content": "<p>For the last part, it is probably better to have <code>hs : IsLUB s (sSup s)</code> rather than <code>hs : ∃ b, IsLUB s b</code> as the former does not  necessitate <code>Classical</code> and both are equivalent under <code>LawfulSup</code></p>",
        "id": 531655777,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1753807517
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"928941\">Pierre Quinton</span> <a href=\"#narrow/channel/113488-general/topic/Any.20infimum.20based.20version.20of.20.60OmegaCompletePartialOrder.60.3F/near/531655777\">said</a>:</p>\n<blockquote>\n<p>For the last part, it is probably better to have <code>hs : IsLUB s (sSup s)</code> rather than <code>hs : ∃ b, IsLUB s b</code> as the former does not  necessitate <code>Classical</code> and both are equivalent under <code>LawfulSup</code></p>\n</blockquote>\n<p>what?</p>",
        "id": 531671901,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753812704
    },
    {
        "content": "<p>can you give an example?</p>",
        "id": 531671919,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753812712
    },
    {
        "content": "<p>Sorry, that's astupid mistake</p>",
        "id": 531672341,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1753812876
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"928941\">Pierre Quinton</span> <a href=\"#narrow/channel/113488-general/topic/Any.20infimum.20based.20version.20of.20.60OmegaCompletePartialOrder.60.3F/near/531549907\">said</a>:</p>\n<blockquote>\n<p>Okay, so what is the next step here? <span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> it feels like you had in mind changing axioms of all class that currently inherit from <code>SupSet</code> and <code>InfSet</code> to provide existential statements (and therefore not inheriting from <code>SupSet</code> and <code>InfSet</code>?).</p>\n</blockquote>\n<p>I think the lattice classes should extend <code>SupInfSet</code> as well. They would not provide any extra information, mathematically, but I think most people would expect that <code>CompleteLattice α</code> should enable <code>sSup</code> and <code>sInf</code>.</p>",
        "id": 531719330,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1753833654
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"928941\">Pierre Quinton</span> <a href=\"#narrow/channel/113488-general/topic/Any.20infimum.20based.20version.20of.20.60OmegaCompletePartialOrder.60.3F/near/531645204\">said</a>:</p>\n<blockquote>\n<p>Some of the results in both of those can now be factorized in <code>Lattice</code>or even <code>Preorder</code>  as if we condition on <code>LawfulSup</code></p>\n</blockquote>\n<p>I think you can build the API like this. First, take all of the basic results on suprema/infima that are provable on <code>LawfulSup</code>/<code>LawfulInf</code>and prove them there. All of the most basic stuff like <code>le_sSup</code>, <code>lt_sSup_iff</code>, etc. should have a <code>LawfulSup</code> version, for instance. Then prove the results for conditional/complete/etc. lattices as special cases of these.</p>\n<p>We probably need to find better names for the <code>LawfulSup</code>/<code>LawfulInf</code> theorems, so that they don't clash with the theorems on conditional lattices. I propose <code>le_lsSup</code> (where the l stands for lawful, kind of like the c in <code>le_csSup</code> stands for conditional). It's not pretty, but I find it preferable to spamming primes.</p>",
        "id": 531719916,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1753833937
    },
    {
        "content": "<p>How about using namespaces?</p>",
        "id": 531754550,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1753854752
    },
    {
        "content": "<p>Hm. Is there ever a situation where we'd want to use the lawful theorems over the more specific theorems for different kinds of lattices?</p>",
        "id": 531754681,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1753854806
    },
    {
        "content": "<p>I imagine that won't be a very common occurence, save for when we're proving the more specific theorems themselves.</p>",
        "id": 531754711,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1753854826
    },
    {
        "content": "<p>I don't think so but then this is a good reason to put them in a namespace right?</p>",
        "id": 531754737,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1753854846
    },
    {
        "content": "<p>I guess we could put everything in a <code>LawfulSupInf</code> namespace.</p>",
        "id": 531754738,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1753854847
    },
    {
        "content": "<p>BTW, I feel weird about having supset and infset in lattices</p>",
        "id": 531754787,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1753854878
    },
    {
        "content": "<p>Especially if they don't give meaning to the symbols</p>",
        "id": 531754807,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1753854890
    },
    {
        "content": "<p>In lattices? Yeah we shouldn't have them in lattices, but in complete lattices!</p>",
        "id": 531754865,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1753854918
    },
    {
        "content": "<p>I think I misspoke</p>",
        "id": 531754871,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1753854920
    },
    {
        "content": "<p>No I got that, subtypes of lattice that have some logic on sups and infs</p>",
        "id": 531754931,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1753854950
    },
    {
        "content": "<p>The thing is, if we use existantial definitions, for instqnce in complete lattice, every set has a LUB, then sSup is not constrained at all</p>",
        "id": 531755015,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1753854996
    },
    {
        "content": "<p>I mean, we wouldn't <em>just</em> have <code>SupSet</code>.</p>",
        "id": 531755076,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1753855030
    },
    {
        "content": "<p>Maybe I misread what you said earlier. What I mean is that complete/conditionally complete/omega complete lattices should all inherit from <code>LawfulSup</code> and <code>LawfulInf</code>.</p>",
        "id": 531755131,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1753855056
    },
    {
        "content": "<p>So we would have that sSup s is the LUB of s?</p>",
        "id": 531755138,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1753855058
    },
    {
        "content": "<p>My bad</p>",
        "id": 531755179,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1753855069
    },
    {
        "content": "<p>Okay I get it, but still feels weird as this will typically force people to use Classical</p>",
        "id": 531755249,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1753855105
    },
    {
        "content": "<p>(which is typically the case anyway)</p>",
        "id": 531755272,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1753855116
    },
    {
        "content": "<p>Mathlib is by and large a library for classical logic. And nearly all instances of complete lattices are noncomputable/defined through choice, anyways.</p>",
        "id": 531755308,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1753855136
    },
    {
        "content": "<p>(in fact, you can't compute a supremum or infimum except for trivial cases, since the type <code>Set α = α → Prop</code> carries no meaningful data)</p>",
        "id": 531755459,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1753855207
    },
    {
        "content": "<p>Right, but it makes sense to avoid it if it doesn't make the structure anoying. In any case I don't see a good way to avoid it.</p>",
        "id": 531755473,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1753855212
    },
    {
        "content": "<p>I disagree. If <code>CompleteLattice</code> didn't extend <code>LawfulSupInf</code> the vast majority of theorems would have to write <code>[CompleteLattice α] [LawfulSupInf α]</code>, which benefits no one.</p>",
        "id": 531755619,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1753855267
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/stream/113488-general/topic/Any.20infimum.20based.20version.20of.20.60OmegaCompletePartialOrder.60.3F/near/531755459\">said</a>:</p>\n<blockquote>\n<p>(in fact, you can't compute a supremum or infimum except for trivial cases, since the type <code>Set α = α → Prop</code> carries no meaningful data)</p>\n</blockquote>\n<p>Yeah I think you are right, even if you had a sigma algebra, then knowing when a collection of measurable sets has measurable union is not possible.</p>",
        "id": 531755701,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1753855303
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/stream/113488-general/topic/Any.20infimum.20based.20version.20of.20.60OmegaCompletePartialOrder.60.3F/near/531755619\">said</a>:</p>\n<blockquote>\n<p>I disagree. If <code>CompleteLattice</code> didn't extend <code>LawfulSupInf</code> the vast majority of theorems would have to write <code>[CompleteLattice α] [LawfulSupInf α]</code>, which benefits no one.</p>\n</blockquote>\n<p>Agreed</p>",
        "id": 531755789,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1753855337
    },
    {
        "content": "<p>As a maybe analogous example, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ring#doc\">docs#Ring</a> extends <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=NatCast#doc\">docs#NatCast</a> even though you can define the map <code>ℕ → R</code> using the other data provided.</p>",
        "id": 531755818,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1753855354
    },
    {
        "content": "<p>In that case it's more about giving nice definitional equalities, but the point of \"sometimes it's fine to have redundant data\" stands.</p>",
        "id": 531755869,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1753855381
    },
    {
        "content": "<p>So what is the currently planned design? Could you recap?</p>",
        "id": 531812858,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1753873424
    },
    {
        "content": "<p>Just been reading up :)</p>",
        "id": 531812888,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1753873434
    },
    {
        "content": "<p>Basically, the plan is to redefine the complete/conditional/omega lattice types. We defined a new typeclass <code>LawfulInfSup</code> which states that <code>IsLUB s x -&gt; IsLUB s (sSup s)</code>, and likewise for the infimum. Then, instead of the lattice typeclasses placing different constraints on <code>Sup</code> and <code>Inf</code>, they'd inherit from this typeclass, and place constraints on which sets have a LUB/GLB.</p>",
        "id": 531813696,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1753873696
    },
    {
        "content": "<p>This has various nice side effects, with the one I'm happiest about being the overly verbose <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ConditionallyCompleteLinearOrderBot#doc\">docs#ConditionallyCompleteLinearOrderBot</a> now getting subsumed by it's slightly slimmer sibling <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ConditionallyCompleteLinearOrder#doc\">docs#ConditionallyCompleteLinearOrder</a></p>",
        "id": 531814184,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1753873875
    },
    {
        "content": "<p>(the <code>sSup ∅ = bot</code> condition follows from <code>OrderBot + LawfulSup</code>)</p>",
        "id": 531814333,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1753873930
    },
    {
        "content": "<p>I assume you mean <code>IsLUB s x -&gt; IsLUB s (sSup s)</code> instead.</p>",
        "id": 531817166,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1753874846
    },
    {
        "content": "<p>Whoops</p>",
        "id": 531817234,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1753874873
    },
    {
        "content": "<p>It might get odd if you're not in a partial order (as then you can have multiple LUBs than aren't equal I think?)</p>",
        "id": 531817454,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1753874943
    },
    {
        "content": "<p>All the types we care about are partial orders. I think this definition was chosen for generalizing slightly better to preorders.</p>",
        "id": 531818002,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1753875107
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/113488-general/topic/Any.20infimum.20based.20version.20of.20.60OmegaCompletePartialOrder.60.3F/near/531817454\">said</a>:</p>\n<blockquote>\n<p>It might get odd if you're not in a partial order (as then you can have multiple LUBs than aren't equal I think?)</p>\n</blockquote>\n<p>There is another version that was proposed <code>IsLUB s x -&gt; sSup s = x</code> and I objected because this one implies partial order and therefore is evil from a category theory point of view</p>",
        "id": 531818875,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753875364
    },
    {
        "content": "<p>Stupid question: Why keep <code>sSup</code> as notation? Wouldn't it be better to define <code>sSup s := if h : \\exists x, IsLUB s x then h.choose else Classical.arbitrary</code>? My reasoning is that defeqs for <code>sSup</code>/<code>iSup</code>  are actually always bad, and therefore it's not a loss to throw them away.</p>",
        "id": 531820178,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1753875751
    },
    {
        "content": "<p>What I mean by bad defeq is for example that <code>sSup</code>/<code>iSup</code> don't commute definitionally with projections from a product or pi type. And generally I've never seen them commute definitionally with anything interesting</p>",
        "id": 531820527,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1753875852
    },
    {
        "content": "<p>Counterpoint: we want <code>sSup</code> on sets to be def-eq to the union.</p>",
        "id": 531820791,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1753875907
    },
    {
        "content": "<p>(and presumably you can make <code>sSup x = ∅</code> def-eq for an empty type, which is at least something)</p>",
        "id": 531821009,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1753875955
    },
    {
        "content": "<p>There seem to be three possibilities, each with pros and cons, I might be missing a fourth that is a strict improvement over all three:<br>\n1) Have <code>sSup s</code> defined as <code>if h : \\exists x, IsLUB s x then h.choose else Classical.arbitrary</code>. Con: No def-eq for unions of sets.<br>\n2) Have some <code>PartialOrder</code>s inherit from Lawful such as <code>Complete*</code>, <code>OmegaComplete*</code>, <code>ConditionallyComplete*</code>. Con: If this is a good idea, then why is it a bad idea to have all PartialOrder inherit from <code>Lawful</code> stuff? For instance <code>Lattice</code> is in essence a <code>FinitelyCompleteLattice</code> where we can prove that <code>sSup</code> is well defined on finite collections, so I think this would require us to justify what makes an order inherit lawfulsupinf or not.<br>\n3) Have some <code>PartialOrder</code>s (same as in 2) provide proof of existence of LUB and provide constructors to build lawful orders from those (def for all, instance for <code>CompleteLattice</code>). Con: We would have to carry some <code>[LawfulSup α]</code>, <code>[LawfulInf α]</code> or <code>[LawfulSupInf α]</code> around. Maybe this approach also breaks def-eq?</p>\n<p>It would be nice to settle this before proceeding.</p>",
        "id": 531839614,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1753881112
    },
    {
        "content": "<p>I'd rather go with 2.</p>",
        "id": 531842437,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1753881816
    },
    {
        "content": "<p>As for why lattices don't use <code>Sup</code>, I think that's just the <code>max</code>/<code>sup</code> argument again. We have some amount of duplication, but not enough to warrant going against mathematical convention.</p>",
        "id": 531842879,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1753881919
    },
    {
        "content": "<p>(in any case, if we wanted, we could prove <code>Sup s = Finset.sup s</code> for finite sets in a <code>LawfulSupInf</code> lattice)</p>",
        "id": 531843556,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1753882083
    },
    {
        "content": "<p>So if I understand you correctly, the role of those complete (or partially complete) type classes are to provide <code>sSup</code> and/or <code>sInf</code> operations and so they should inherit from lawful. If we want to have say a <code>FinitelyCompleteLattice</code>, then we could make it inherit from <code>Lattice</code> and <code>LawfulSupInf</code> and provide meaningful definition to <code>sSup s</code> and <code>sInf s</code> when <code>s</code> is finite?</p>",
        "id": 531844560,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1753882345
    },
    {
        "content": "<p>Yes to the first part, though I don't really think we'll ever need <code>FinitelyCompleteLattice</code>.</p>",
        "id": 531845196,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1753882524
    },
    {
        "content": "<p>Would <code>[FinitelyCompleteLattice α]</code> be equivalent to <code>[Lattice α]</code> or <code>[Lattice α] [BoundedOrder α]</code>?</p>",
        "id": 531845491,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753882604
    },
    {
        "content": "<p>Good question</p>",
        "id": 531845595,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1753882631
    },
    {
        "content": "<p>empty sets are certainly finite</p>",
        "id": 531845912,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753882687
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/113488-general/topic/Any.20infimum.20based.20version.20of.20.60OmegaCompletePartialOrder.60.3F/near/531845196\">said</a>:</p>\n<blockquote>\n<p>Yes to the first part, though I don't really think we'll ever need <code>FinitelyCompleteLattice</code>.</p>\n</blockquote>\n<p>me neither, but it is an example of things that we should be able to decide on.</p>",
        "id": 531846535,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1753882840
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/113488-general/topic/Any.20infimum.20based.20version.20of.20.60OmegaCompletePartialOrder.60.3F/near/531845491\">said</a>:</p>\n<blockquote>\n<p>Would <code>[FinitelyCompleteLattice α]</code> be equivalent to <code>[Lattice α]</code> or <code>[Lattice α] [BoundedOrder α]</code>?</p>\n</blockquote>\n<p>Like <code>OmegaComplete</code> I guess it must be bounded.</p>",
        "id": 531846765,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1753882900
    },
    {
        "content": "<p>I like the idea of continuing to use <code>Sup</code> where we already use it, and not introduce it elsewhere, at least not until a subsequent refactor</p>",
        "id": 531847370,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1753883057
    },
    {
        "content": "<p>I like it too. Are there any other strong opinions?</p>",
        "id": 531848993,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1753883470
    },
    {
        "content": "<p>And the reason I pointed out category theory earlier</p>\n<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/stream/113488-general/topic/Any.20infimum.20based.20version.20of.20.60OmegaCompletePartialOrder.60.3F/near/531820791\">said</a>:</p>\n<blockquote>\n<p>Counterpoint: we want <code>sSup</code> on sets to be def-eq to the union.</p>\n</blockquote>\n<p>But how do you define <code>sUnion</code>? Why can't it be the same definition as <code>sSup</code>?</p>",
        "id": 531857482,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1753885571
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/stream/113488-general/topic/Any.20infimum.20based.20version.20of.20.60OmegaCompletePartialOrder.60.3F/near/531842879\">said</a>:</p>\n<blockquote>\n<p>As for why lattices don't use <code>Sup</code>, I think that's just the <code>max</code>/<code>sup</code> argument again. We have some amount of duplication, but not enough to warrant going against mathematical convention.</p>\n</blockquote>\n<p>I actually think the refactor we're discussing here would be a great opportunity to get rid of all the clutter around <code>Finset.sup</code>, <code>Finset.sup'</code>, <code>Finset.max</code>. I think the definitions can stay, for computation, but the API could be transferred to <code>sSup</code> of a finite set, meaning that we could finally use the <code>\\Sup</code> notation</p>",
        "id": 531857962,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1753885702
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/113488-general/topic/Any.20infimum.20based.20version.20of.20.60OmegaCompletePartialOrder.60.3F/near/531857482\">said</a>:</p>\n<blockquote>\n<p>And the reason I pointed out category theory earlier</p>\n<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/stream/113488-general/topic/Any.20infimum.20based.20version.20of.20.60OmegaCompletePartialOrder.60.3F/near/531820791\">said</a>:</p>\n<blockquote>\n<p>Counterpoint: we want <code>sSup</code> on sets to be def-eq to the union.</p>\n</blockquote>\n<p>But how do you define <code>sUnion</code>? Why can't it be the same definition as <code>sSup</code>?</p>\n</blockquote>\n<p>We want <code>x ∈ ⋃₀ S</code> to be defeq to <code>∃ s ∈ S, x ∈ s</code></p>",
        "id": 531859136,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753886029
    },
    {
        "content": "<p>for sets</p>",
        "id": 531859164,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753886038
    },
    {
        "content": "<p>I get the point, but <code>x \\in iUnion f</code> is already not defeq to <code>\\exists i, x \\in f i</code>. How do you explain this disconnect to a beginner?</p>",
        "id": 531860470,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1753886403
    },
    {
        "content": "<p>it's still something you can <code>rintro</code> or <code>obtain</code> and get a nice goal state out of</p>",
        "id": 531861304,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753886604
    },
    {
        "content": "<p>I use this a lot</p>",
        "id": 531861324,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753886610
    },
    {
        "content": "<p>finsets are more difficult</p>",
        "id": 531861376,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753886623
    },
    {
        "content": "<p>Is <code>∃</code> a fundamental of the language or is it defined somewhere? (Just out of curiosity)</p>",
        "id": 531883471,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1753892930
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Exists#doc\">docs#Exists</a></p>",
        "id": 531883570,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753892970
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113488-general/topic/Any.20infimum.20based.20version.20of.20.60OmegaCompletePartialOrder.60.3F/near/531860470\">said</a>:</p>\n<blockquote>\n<p>I get the point, but <code>x \\in iUnion f</code> is already not defeq to <code>\\exists i, x \\in f i</code>. How do you explain this disconnect to a beginner?</p>\n</blockquote>\n<p>It isn't? How come?</p>",
        "id": 531961539,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1753925732
    },
    {
        "content": "<p>I think the point still stands though. Surely we at the very least want the supremum of say, subgroups, to be def-eq to the supremum of sets?</p>",
        "id": 531961678,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1753925816
    },
    {
        "content": "<p>Again, this all reminds me of <code>NatCast</code>, which can always be defined for certain structures, but which can often be defined <em>nicely</em>.</p>",
        "id": 531961937,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1753925994
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/113488-general/topic/Any.20infimum.20based.20version.20of.20.60OmegaCompletePartialOrder.60.3F/near/531961539\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113488-general/topic/Any.20infimum.20based.20version.20of.20.60OmegaCompletePartialOrder.60.3F/near/531860470\">said</a>:</p>\n<blockquote>\n<p>I get the point, but <code>x \\in iUnion f</code> is already not defeq to <code>\\exists i, x \\in f i</code>. How do you explain this disconnect to a beginner?</p>\n</blockquote>\n<p>It isn't? How come?</p>\n</blockquote>\n<p>It's defeq to <code>∃ s ∈ Set.range f, x ∈ s</code>, which is the same as <code>∃ s, (∃ i, f i = s) ∧ x ∈ s</code>.</p>",
        "id": 531962431,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753926293
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/113488-general/topic/Any.20infimum.20based.20version.20of.20.60OmegaCompletePartialOrder.60.3F/near/531961678\">said</a>:</p>\n<blockquote>\n<p>I think the point still stands though. Surely we at the very least want the supremum of say, subgroups, to be def-eq to the supremum of sets?</p>\n</blockquote>\n<p>Unfortunately they're not even propositionally equal, so I don't know how you plan to make them defeq.</p>",
        "id": 531962685,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753926446
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/stream/113488-general/topic/Any.20infimum.20based.20version.20of.20.60OmegaCompletePartialOrder.60.3F/near/531962685\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/113488-general/topic/Any.20infimum.20based.20version.20of.20.60OmegaCompletePartialOrder.60.3F/near/531961678\">said</a>:</p>\n<blockquote>\n<p>I think the point still stands though. Surely we at the very least want the supremum of say, subgroups, to be def-eq to the supremum of sets?</p>\n</blockquote>\n<p>Unfortunately they're not even propositionally equal, so I don't know how you plan to make them defeq.</p>\n</blockquote>\n<p>Sorry, not the supremum, the infimum</p>",
        "id": 531962771,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1753926508
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/113488-general/topic/Any.20infimum.20based.20version.20of.20.60OmegaCompletePartialOrder.60.3F/near/531820178\">said</a>:</p>\n<blockquote>\n<p>Stupid question: Why keep <code>sSup</code> as notation? Wouldn't it be better to define <code>sSup s := if h : \\exists x, IsLUB s x then h.choose else Classical.arbitrary</code>? My reasoning is that defeqs for <code>sSup</code>/<code>iSup</code>  are actually always bad, and therefore it's not a loss to throw them away.</p>\n</blockquote>\n<p>I think that this is actually orthogonal to some of the steps that <span class=\"user-mention\" data-user-id=\"459227\">@Violeta Hernández</span> was suggesting. This idea would just have an impact on the proofs that we provide but not on the structure that we are building. If I am right about this, then we can proceed with refactoring some of the <code>Complete</code> orders classes. We could then have a discussion once this is done, I think we will have better information and understanding at that time.</p>",
        "id": 532001410,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1753947262
    },
    {
        "content": "<p>I agree. I'm not entirely opposed to that refactor, but we should do things one step at a time.</p>",
        "id": 532001526,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1753947300
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"459227\">@Violeta Hernández</span> I added some <code>OrderDual</code> material to the PR if you want to take a look. I realized that <code>CompleteLattice.lean</code> was the place where the dual of <code>SupSet</code> and <code>InfSet</code> were defined, now <code>LawfulSupInf</code> takes that responsibility.</p>",
        "id": 532002021,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1753947473
    },
    {
        "content": "<p>In terms of theorems for Lawful orders, what do you think of having namespace of the type class with the least assumptions needed to prove things? Let me illustrate, we could have in <code>LawfulSupInf.lean</code> the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Preorder</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">isLUB_sSup</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LawfulSup</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sSup</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">LawfulSup</span><span class=\"bp\">.</span><span class=\"n\">isLUB_sSup_of_exists_isLUB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">hs</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">isGLB_sInf</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LawfulInf</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sInf</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">isLUB_sSup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"bp\">ᵒᵈ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">hs</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">le_sSup</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LawfulSup</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">sSup</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">isLUB_sSup</span><span class=\"w\"> </span><span class=\"n\">hs</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"n\">ha</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">sInf_le</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LawfulInf</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">sInf</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">le_sSup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"bp\">ᵒᵈ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"n\">ha</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">sSup_le</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LawfulSup</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">sSup</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">isLUB_sSup</span><span class=\"w\"> </span><span class=\"n\">hs</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"w\"> </span><span class=\"n\">ha</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">le_sInf</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LawfulInf</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">sInf</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">sSup_le</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"bp\">ᵒᵈ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"n\">ha</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">Preorder</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">PartialOrder</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PartialOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">sSup_eq_of_isLUB</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LawfulSup</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">sSup</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">IsLUB</span><span class=\"bp\">.</span><span class=\"n\">unique</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Preorder</span><span class=\"bp\">.</span><span class=\"n\">isLUB_sSup</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hs</span><span class=\"bp\">⟩</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">hs</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">sInf_eq_of_isGLB</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LawfulInf</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">sInf</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">sSup_eq_of_isLUB</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"bp\">ᵒᵈ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">hs</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">PartialOrder</span>\n</code></pre></div>\n<p>So all results that are always provable go in the namespace <code>Preorder</code>, then if we need <code>PartialOrder</code>, it goes in there, then we can have <code>Lattice</code> and all sort of namespace we would like.</p>",
        "id": 532008455,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1753949520
    },
    {
        "content": "<p>Hmm. I am not sure it's usual to use namespaces rather than sections here.</p>",
        "id": 532009674,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1753949889
    },
    {
        "content": "<p>Yes but the problem is that we can have many theorems with the same name as we will adapt the conditions, for instance <code>isLUB_sSup</code> is in <code>CompleteLattice</code>, <code>isLUB_csSup</code> is in <code>ConditionallyCompleteLattice</code>, etc...</p>",
        "id": 532009969,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1753949989
    },
    {
        "content": "<p>Ah I see the issue.</p>",
        "id": 532010010,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1753949999
    },
    {
        "content": "<p>Yes good point.</p>",
        "id": 532010033,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1753950004
    },
    {
        "content": "<p>My thinking is that <code>LawfulSupInf</code> is in some sense private content that helps structure all those type classes that are public, but I don't think that a user would use them directly.</p>",
        "id": 532010413,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1753950122
    },
    {
        "content": "<p>It's an interesting idea, though why not just have everything in a <code>LawfulSup</code>/<code>LawfulInf</code>/<code>LawfulSupInf</code> namespace?</p>",
        "id": 532011887,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1753950573
    },
    {
        "content": "<p>It would look something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">LawfulSup</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LawfulSup</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">isLUB_sSup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sSup</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">LawfulSup</span><span class=\"bp\">.</span><span class=\"n\">isLUB_sSup_of_exists_isLUB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hs</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">le_sSup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">sSup</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">isLUB_sSup</span><span class=\"w\"> </span><span class=\"n\">hs</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"n\">ha</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">sSup_le</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">sSup</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">isLUB_sSup</span><span class=\"w\"> </span><span class=\"n\">hs</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"w\"> </span><span class=\"n\">ha</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">sSup_eq_of_isLUB</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PartialOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">sSup</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">isLUB_sSup</span><span class=\"w\"> </span><span class=\"n\">hs</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">unique</span><span class=\"w\"> </span><span class=\"n\">hs</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">LawfulSup</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">LawfulInf</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LawfulInf</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">isGLB_sInf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sInf</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">LawfulSup</span><span class=\"bp\">.</span><span class=\"n\">isLUB_sSup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"bp\">ᵒᵈ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">hs</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">sInf_le</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">sInf</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">LawfulSup</span><span class=\"bp\">.</span><span class=\"n\">le_sSup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"bp\">ᵒᵈ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"n\">ha</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">le_sInf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">sInf</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">LawfulSup</span><span class=\"bp\">.</span><span class=\"n\">sSup_le</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"bp\">ᵒᵈ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"n\">ha</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">sInf_eq_of_isGLB</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PartialOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">sInf</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">LawfulSup</span><span class=\"bp\">.</span><span class=\"n\">sSup_eq_of_isLUB</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"bp\">ᵒᵈ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">hs</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">LawfulInf</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">LawfulSupInf</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LawfulSupInf</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">sInf_le_sSup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">Nonempty</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hb</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">sInf</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">sSup</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">isGLB_le_isLUB</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">LawfulInf</span><span class=\"bp\">.</span><span class=\"n\">isGLB_sInf</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">LawfulSup</span><span class=\"bp\">.</span><span class=\"n\">isLUB_sSup</span><span class=\"w\"> </span><span class=\"n\">hb</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">hs</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">LawfulSupInf</span>\n</code></pre></div>\n<p>I like it too.</p>",
        "id": 532013779,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1753951165
    },
    {
        "content": "<p>Normally I don't think we tend to have hypotheses of the form <code>hs : ∃ b, IsGLB s b</code>, because this can be replaced by <code>{b} (hs : IsGLB s b)</code> which is somehow more natural.</p>",
        "id": 532022485,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1753953625
    },
    {
        "content": "<p>Makes sense, it is better</p>",
        "id": 532022670,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1753953673
    },
    {
        "content": "<p>i.e. implicitly we use <code>exists_imp</code>.</p>",
        "id": 532022685,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1753953678
    },
    {
        "content": "<p>Basically you prove the exists by providing a witness.</p>",
        "id": 532022765,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1753953697
    },
    {
        "content": "<p>Now I think that we need to think hard about what we should do about <code>iSup</code> results. The first one I have encountered in <code>CompleteLattice.Defs</code> while working on translating the old way to the new is this one:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">le_iSup_iff</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">iSup</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">iSup</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">le_sSup_iff</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">upperBounds</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>The only way that we have to prove this in <code>LawfulSup</code> is by assuming that the range of <code>s</code> has a LUB. This is doable but is rather different from the condition I had in mind for <code>OmegaCompleteLattice</code> that <code>ι</code> is Countable.</p>\n<p>Any thoughts are welcome.</p>",
        "id": 532149089,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1753988830
    },
    {
        "content": "<p>well countable sets have least upper bound in omega complete lattice and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.countable_range#doc\">docs#Set.countable_range</a> will say your range is countable</p>",
        "id": 532150070,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753989225
    },
    {
        "content": "<p>I know, but it gets very nasty with <code>iSup2</code> results</p>",
        "id": 532150350,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1753989342
    },
    {
        "content": "<p>oh ok</p>",
        "id": 532150577,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753989430
    },
    {
        "content": "<p>Sorry, let me rephrase, I think we should discuss about <code>iSup₂</code> results such as</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">le_iSup₂</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">κ</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">κ</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"bp\">⨆</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">j</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>It might be annoying to require as an assumption that for all <code>i</code>, the range of <code>f i</code> has a LUB. We clearly can't have assumptions on <code>κ</code> or <code>ι</code>. For most of those results, it would be enough to have a condition on the existence of a LUB of <code>{f i j | (i : ι) (j : κ i)}</code>, but maybe this would make most of those results useless.</p>",
        "id": 532152091,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1753990010
    },
    {
        "content": "<p>Actually, I think it makes sense to have ```<br>\n{f : ∀ i, κ i → α} {g : ι → α} (h₁ : ∀ i, IsLUB (Set.range (f i)) (g i)) (h₂ : IsLUB (Set.range g) a)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">And</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">leave</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">responsibility</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">proving</span><span class=\"w\"> </span><span class=\"n\">those</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">instances</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">especially</span><span class=\"w\"> </span><span class=\"n\">since</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">proof</span><span class=\"w\"> </span><span class=\"n\">will</span><span class=\"w\"> </span><span class=\"n\">typically</span><span class=\"w\"> </span><span class=\"n\">be</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">same</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">all</span><span class=\"w\"> </span><span class=\"n\">theorems</span><span class=\"w\"> </span><span class=\"n\">involving</span><span class=\"w\"> </span><span class=\"ss\">`iSup₂</span><span class=\"bp\">`.</span>\n</code></pre></div>",
        "id": 532468349,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1754151720
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> could you elaborate on what you were saying about secret suprema?</p>",
        "id": 533012290,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754445841
    },
    {
        "content": "<p>I don't really get what the problem you're talking about is</p>",
        "id": 533012336,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754445878
    },
    {
        "content": "<p>Say you want to deduce results about <code>OmegaCompletePartialOrder</code> from <code>LawfulSupInf</code>: You cannot, as there are possibly sets which are not chains or not countable that have suprema anyway</p>",
        "id": 533032304,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1754461429
    },
    {
        "content": "<p>Why is that an issue? Results on <code>LawfulSupInf</code> would presumably be of the form \"if this set has a LUB/GLB, then X\". Results on <code>OmegaCompletePartialOrder</code> would look like \"for every countable chain, then X\". Since every countable chain has a LUB/GLB, the result would follow from the <code>LawfulSupInf</code> version.</p>",
        "id": 533043686,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754466471
    },
    {
        "content": "<p>If some other set happens to have a supremum that isn't accounted for by the typeclass assumptions, then yeah, the typeclass assumptions won't say anything about it. <code>LawfulSupInf</code> might, though.</p>",
        "id": 533043809,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754466520
    },
    {
        "content": "<p>So now you're suggesting to not prove anything about <code>OmegaCompletePartialOrder</code> but instead <code>OmegaCompletePartialOrder</code> + <code>LawfulSupInf</code>? That's strictly less general of course, and I do not know how you will instantiate this combo of typeclasses in practice, except by taking the <code>sSup s := if hs : ∃ b, IsGLB s b then hs.choose else junk</code> approach I explained above</p>",
        "id": 533051167,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1754469113
    },
    {
        "content": "<p>I thought the idea was to make the existing typeclasses extend <code>LawfulSupInf</code>.</p>",
        "id": 533051328,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754469174
    },
    {
        "content": "<p>Yes then again I do not know how you will instantiate them except for my approach to defining <code>sSup</code></p>",
        "id": 533051473,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1754469231
    },
    {
        "content": "<p>That will be by far the most common approach to instantiate them, that's true. But as I mentioned earlier I do think there's some situations where you can have nice def-eqs, and I think we should preserve that.</p>",
        "id": 533051686,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754469310
    },
    {
        "content": "<p>Would instances with proper priority solve part of our dilemma? If we have a low priority instance for <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> construction of ssup and higher one for say powerset?</p>",
        "id": 533259531,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1754560943
    },
    {
        "content": "<p>Tweaking priorities doesn't solve diamonds sadly, so no</p>",
        "id": 533265743,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1754563249
    },
    {
        "content": "<p><del>I have a very good reason to not define <code>sSup</code> through choice - we lose the def-eqs between <code>sSup</code> on an order and <code>sInf</code> on the order dual, and viceversa.</del> oh nevermind, I think we would still have that, actually</p>",
        "id": 533767220,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754911802
    },
    {
        "content": "<p>how else would you define sSup, the fact that you're pulling data from Prop means that you require choice</p>",
        "id": 533773337,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754912426
    },
    {
        "content": "<p>(oops, I just realised that I have completely no idea of the context of this discussion)</p>",
        "id": 533773446,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754912458
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> I am currently rather stuck on this matter. I think I'm missing a point and maybe you can help me. What would be the main advantages of having defined <code>sSup</code> in the way you suggest? You mentioned on github that in the case of an OmegaCompleteLattice that is actually complete, we could not deduce <code>LawfulSup</code> for all elements of the family from the axioms of OmegaCompleteLattice only. But still, if we make <code>OmegaCompleteLattice</code> satisfy <code>LawfulSup</code>, then the user defined <code>sSup</code> must be a LUB whenever there exists one. So for a coutnable collection, you can deduce facts by combining existence from <code>OmegaCompleteLattice</code> and facts from <code>IsLawfulSup</code>. But still, if you have for instance the collection of all elements of your lattice, then you can deduce that its <code>sSup</code> is the maximal element by using <code>IsLawfulSup</code> right?<br>\nAm I missing something?</p>",
        "id": 534607532,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1755241279
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/113488-general/topic/Any.20infimum.20based.20version.20of.20.60OmegaCompletePartialOrder.60.3F/near/531962431\">said</a>:</p>\n<blockquote>\n<p>Violeta Hernández <a href=\"#narrow/channel/113488-general/topic/Any.20infimum.20based.20version.20of.20.60OmegaCompletePartialOrder.60.3F/near/531961539\">said</a>:</p>\n<blockquote>\n<p>Yaël Dillies <a href=\"#narrow/stream/113488-general/topic/Any.20infimum.20based.20version.20of.20.60OmegaCompletePartialOrder.60.3F/near/531860470\">said</a>:</p>\n<blockquote>\n<p>I get the point, but <code>x \\in iUnion f</code> is already not defeq to <code>\\exists i, x \\in f i</code>. How do you explain this disconnect to a beginner?</p>\n</blockquote>\n<p>It isn't? How come?</p>\n</blockquote>\n<p>It's defeq to <code>∃ s ∈ Set.range f, x ∈ s</code>, which is the same as <code>∃ s, (∃ i, f i = s) ∧ x ∈ s</code>.</p>\n</blockquote>\n<p>Sorry if I'm taking this discussion a bit off topic (I find the thread hard to follow), but wouldn't it be better to use <code>∃ i, x ∈ f i</code> for iUnion and iSup? I find the current definition quite clumsy and don't see any advantages.</p>",
        "id": 536790748,
        "sender_full_name": "Jozef Mikušinec",
        "timestamp": 1756474639
    },
    {
        "content": "<p>The advantage is that it's defeq to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=iSup#doc\">docs#iSup</a>, and therefore you can use results about <code>iSup</code> when proving results about <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.iUnion#doc\">docs#Set.iUnion</a>.</p>",
        "id": 536795797,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1756476178
    },
    {
        "content": "<p>I've been thinking about this a lot. I'm increasingly on the side of Yaël - I think we should unbundle <code>sSup</code> from any typeclass and simply define it as:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">sSup</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Preorder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Inhabited</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">choose</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">default</span>\n</code></pre></div>\n<p>Pros:</p>\n<ul>\n<li>No need for any <code>Lawful</code> typeclasses, which aren't really mathematically meaningful.</li>\n<li>We can re-use this for <code>Finset.sup</code> and <code>Finset.max</code>.</li>\n<li>It seems more elegant to characterize the different types of complete orders based on what GLB/LUB exist, rather than the precise values of the <code>sSup</code> and <code>sInf</code> functions.</li>\n<li>This would also make <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CompleteSemilatticeSup#doc\">docs#CompleteSemilatticeSup</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CompleteSemilatticeInf#doc\">docs#CompleteSemilatticeInf</a> entirely redundant.</li>\n</ul>\n<p>Cons:</p>\n<ul>\n<li>We can't set junk values anymore (though presumably <code>default</code> should match whatever we were already using)</li>\n<li>We lose the def-eqs for sets (or singletons).</li>\n</ul>",
        "id": 567387711,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1768134899
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"459227\">@Violeta Hernández</span> did you mean to write <code>IsLUB</code> in that definition or am I just confused?</p>",
        "id": 567408931,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1768156986
    },
    {
        "content": "<p>Oops, sorry</p>",
        "id": 567408951,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1768157020
    },
    {
        "content": "<p>all good</p>",
        "id": 567408971,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1768157054
    },
    {
        "content": "<p>Fantastic. Then I think this wouldn't change much (relatively). Let me try to list the changes that are required after creating the <code>def</code>s for <code>sSup</code> and <code>sInf</code> (and I guess <code>iSup</code> and <code>iInf</code>). The <code>Inhabited</code> condition might be a bit annoying as we will either have to make all statements depend on it, or classes such as <code>CompleteLattice</code> to require it (which I don't find too crazy).</p>\n<p>As an example of changes,  in <code>CompleteLattice</code>, we would not inherit from <code>CompleteLatticeSup</code> and <code>CompleteLatticeInf</code>. We would then remove <code>le_sSup</code> and <code>sSup_le</code>in the typeclass  in favor of something like <code>exists_isLUB</code> which says that for any set <code>s</code>, there exists <code>a</code> which is a LUB of <code>s</code>. Then we would prove <code>le_sSup</code> and <code>sSup_le</code> instead.</p>\n<p>This doesn't seem too complicated. Does anyone sees something I missed that would make this more complicated? Is there anything else to add?</p>",
        "id": 567535061,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1768225065
    },
    {
        "content": "<p>Every SupSet is already nonempty, since sSup of the empty set must be some value in the type. The idea behind requiring inhabited is that we're able to keep convenient junk values, like the supremum/infimum of an empty or unbounded set of reals both being 0 (which statements like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ArchimedeanClass.stdPart_eq_sInf#doc\">docs#ArchimedeanClass.stdPart_eq_sInf</a> depend on)</p>",
        "id": 567548691,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1768228036
    },
    {
        "content": "<p>Fair enough, for some class such as CompleteLattice, OmegaCompleteLattice, ConditionallyCompleteLattice I guess we could provide a constructor for Inhabited. But actually SupSet is supposed to disappear right? This means we won't have this guarantee anymore (I guess <code>supSet_to_nonempty</code>)</p>",
        "id": 567709765,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1768293952
    },
    {
        "content": "<p>Okay, I will now start drafting a branch where I remove <code>SupSet</code> and <code>InfSet</code>, create the def for sSup and sInf suggested by <span class=\"user-mention\" data-user-id=\"459227\">@Violeta Hernández</span> . Then I will update <code>iSup</code>, <code>iInf</code> and the current goal is to attempt refactoring <code>CompleteLattice</code>: remove <code>CompleteLatticeSup</code> and <code>CompleteLatticeInf</code>, change statements to existence of GLBs and LUBs, update proofs. I think this will give some information about what will be needed for this refactor. If this goes well, I can move on to essentially every instances of <code>SupSet</code> and <code>InfSet</code>.</p>\n<p>I'll report back here.</p>",
        "id": 568056532,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1768416280
    },
    {
        "content": "<p>Thanks for taking up this work! Excited to get this working.</p>",
        "id": 568061238,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1768417919
    },
    {
        "content": "<p>(Just to make sure, no one is opposed to this change? I imagined there might be someone annoyed that their min/max functions now depend on choice)</p>",
        "id": 568061359,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1768417963
    },
    {
        "content": "<p>I don't like this</p>",
        "id": 568068186,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1768420411
    },
    {
        "content": "<p>it breaks the defeq for <code>Set</code></p>",
        "id": 568068201,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1768420418
    },
    {
        "content": "<p>And why exactly do we need the def-eq? We could have better def-eqs for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.iUnion#doc\">docs#Set.iUnion</a> in exchange.</p>",
        "id": 568069201,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1768420814
    },
    {
        "content": "<p>I don't think we get defeqs for <code>iUnion</code> since presumably <code>iSup</code> will also be classical</p>",
        "id": 568069934,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1768421057
    },
    {
        "content": "<p>What I mean is, we could redefine <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.iUnion#doc\">docs#Set.iUnion</a> so that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.mem_iUnion#doc\">docs#Set.mem_iUnion</a> is now def-eq, instead of having it not be that so as to awkwardly match <code>iSup</code>.</p>",
        "id": 568070061,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1768421107
    },
    {
        "content": "<p>but then lemmas about <code>iSup</code> won't apply to <code>iUnion</code></p>",
        "id": 568070178,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1768421152
    },
    {
        "content": "<p>Not without first rewriting</p>",
        "id": 568070854,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1768421371
    },
    {
        "content": "<p>So what do you suggest then? Do you think these <code>LawfulSup</code> classes are a better design?</p>",
        "id": 568070923,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1768421409
    },
    {
        "content": "<p>I've been thinking that we should use <code>IsGLB</code> more</p>",
        "id": 568071139,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1768421500
    },
    {
        "content": "<p>Wait, question. Why do we need both <code>LawfulSup</code> and <code>SupSet</code>? What if we just added the condition that <code>sSup s</code> always need to be a LUB if one exists?</p>",
        "id": 568071412,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1768421583
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/113488-general/topic/Any.20infimum.20based.20version.20of.20.60OmegaCompletePartialOrder.60.3F/near/568071139\">said</a>:</p>\n<blockquote>\n<p>I've been thinking that we should use <code>IsGLB</code> more</p>\n</blockquote>\n<p>Well yeah that's one of the goals of this refactor</p>",
        "id": 568071509,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1768421623
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/113488-general/topic/Any.20infimum.20based.20version.20of.20.60OmegaCompletePartialOrder.60.3F/near/568071412\">said</a>:</p>\n<blockquote>\n<p>Wait, question. Why do we need both <code>LawfulSup</code> and <code>SupSet</code>? What if we just added the condition that <code>sSup s</code> always need to be a LUB if one exists?</p>\n</blockquote>\n<p>Didn't we have this idea already</p>",
        "id": 568072185,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1768421831
    },
    {
        "content": "<p>Well this entire thread is about variants of that proposal</p>",
        "id": 568072266,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1768421850
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/113488-general/topic/Any.20infimum.20based.20version.20of.20.60OmegaCompletePartialOrder.60.3F/near/568071139\">said</a>:</p>\n<blockquote>\n<p>I've been thinking that we should use <code>IsGLB</code> more</p>\n</blockquote>\n<p>Could you expend a bit more on that? Because I feel like this idea would actually go in that direction. Since we will not inherit from SupSet and InfSet anymore, then every of those classes (CompleteLattice, ConditionallyComplete, e.t.c.) will now change definitions to existence of GLB/LUB rather than sSup/sInf being the LUB/GLB.</p>",
        "id": 568138707,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1768462006
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"928941\">Pierre Quinton</span> <a href=\"#narrow/channel/113488-general/topic/Any.20infimum.20based.20version.20of.20.60OmegaCompletePartialOrder.60.3F/near/568056532\">said</a>:</p>\n<blockquote>\n<p>Okay, I will now start drafting a branch where I remove <code>SupSet</code> and <code>InfSet</code>, create the def for sSup and sInf suggested by <span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> . Then I will update <code>iSup</code>, <code>iInf</code> and the current goal is to attempt refactoring <code>CompleteLattice</code>: remove <code>CompleteLatticeSup</code> and <code>CompleteLatticeInf</code>, change statements to existence of GLBs and LUBs, update proofs. I think this will give some information about what will be needed for this refactor. If this goes well, I can move on to essentially every instances of <code>SupSet</code> and <code>InfSet</code>.</p>\n<p>I'll report back here.</p>\n</blockquote>\n<p>Any updates? I've been recently considering converting various completeness properties into mixins to simplify the order typeclass hierarchy after this refactor.</p>",
        "id": 571015794,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1769776363
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"455791\">Yuyang Zhao</span> <a href=\"#narrow/channel/113488-general/topic/Any.20infimum.20based.20version.20of.20.60OmegaCompletePartialOrder.60.3F/near/571015794\">said</a>:</p>\n<blockquote>\n<p>Any updates? I've been recently considering converting various completeness properties into mixins to simplify the order typeclass hierarchy after this refactor.</p>\n</blockquote>\n<p>I have been a bit busy lately, next week will be better. Also I'm trying to think about small steps that will satisfy everyone, it seems we are locked into a local optimal and it is hard to move away from it.<br>\nI think that everybody here agrees on the fact that we have to disentangle subclasses of <code>Lattice</code> such as <code>CompleteLattice</code> from the current <code>SupSet</code> and <code>InfSet</code>. An intermediate step between the current state and the one I mentioned in my other message might be to stop inheriting from <code>SupSet</code> in <code>CompleteLattice</code> and such, change the definition to existence of GLBs and LUBs, this I'll call the algebraic <code>CompleteLattice</code>. Then redefine the current CompleteLattice class as a subclass of both the algebraic CompleteLattice and both SupSet and InfSet. This change is not big, but it separates the abstraction level of the algebraic properties and the set notations, and it seems like a change everybody here would agree with. After that the plan is not clear yet.</p>",
        "id": 571377311,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1770022931
    },
    {
        "content": "<p>I tried it today and found that the current approach seems to require writing the same proof twice for <code>isLUB_sSup_of_exists_isLUB : ∀ s : Set α, (∃ a, IsLUB s a) → IsLUB s (sSup s)</code> and <code>exists_isLUB : ∀ s : Set α, ∃ a, IsLUB s a</code>. The only solution I can think of is to replace <code>∃ a, IsLUB s a</code> in <code>isLUB_sSup_of_exists_isLUB</code> with a custom predicate (here it's set to <code>fun _ =&gt; True</code>) and then use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=autoParam#doc\">docs#autoParam</a> for <code>exists_isLUB</code>, but it feels like overkill.</p>",
        "id": 571825084,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1770186221
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"455791\">Yuyang Zhao</span> <a href=\"#narrow/channel/113488-general/topic/Any.20infimum.20based.20version.20of.20.60OmegaCompletePartialOrder.60.3F/near/571825084\">said</a>:</p>\n<blockquote>\n<p>I tried it today and found that the current approach seems to require writing the same proof twice for <code>isLUB_sSup_of_exists_isLUB : ∀ s : Set α, (∃ a, IsLUB s a) → IsLUB s (sSup s)</code> and <code>exists_isLUB : ∀ s : Set α, ∃ a, IsLUB s a</code>. The only solution I can think of is to replace <code>∃ a, IsLUB s a</code> in <code>isLUB_sSup_of_exists_isLUB</code> with a custom predicate (here it's set to <code>fun _ =&gt; True</code>) and then use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=autoParam#doc\">docs#autoParam</a> for <code>exists_isLUB</code>, but it feels like overkill.</p>\n</blockquote>\n<p>I guess the second one is specific for <code>CompleteLattice</code> while the first one is true on any <code>Preorder</code>? Not sure why the proof of the two should be the same, one doesn't depend on Completeness at all.</p>",
        "id": 572621062,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1770557538
    },
    {
        "content": "<p>After the first step of refactor, both are fields of <code>CompleteLattice</code>. For example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CompleteLattice</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"bp\">...</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"n\">isLUB_sSup_of_exists_isLUB</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">isLUB_sUnion</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n<span class=\"w\">    </span><span class=\"n\">isGLB_sInf_of_exists_isGLB</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">isGLB_sInter</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n<span class=\"w\">    </span><span class=\"n\">exists_isLUB</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">isLUB_sUnion</span><span class=\"w\"> </span><span class=\"bp\">_⟩</span>\n<span class=\"w\">    </span><span class=\"n\">exists_isGLB</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">isGLB_sInter</span><span class=\"w\"> </span><span class=\"bp\">_⟩</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 572623114,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1770559321
    },
    {
        "content": "<p>It feels like only the second one should be a field of <code>CompleteLattice</code> because the second one will be provable, and we want the definition of <code>CompleteLattice</code> to be made agnostic of <code>sSup</code>/<code>sInf</code>.<br>\nThis would mean \"A complete lattice is a lattice whose every subset has a LUB/GLB\". Then <code>sSup</code> and <code>sInf</code> are defined for any <code>PreOrder</code> (or maybe <code>PartialOrder</code>). With this, <code>isLUB_sSup_of_exists_isLUB</code> is provable on a CompleteLattice.</p>",
        "id": 572642906,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1770577279
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"928941\">Pierre Quinton</span> <a href=\"#narrow/channel/113488-general/topic/Any.20infimum.20based.20version.20of.20.60OmegaCompletePartialOrder.60.3F/near/571377311\">said</a>:</p>\n<blockquote>\n<p>Then redefine the current CompleteLattice class as a subclass of both the algebraic CompleteLattice and both SupSet and InfSet.</p>\n</blockquote>\n<p>Shouldn't we add <code>isLUB_sSup_of_exists_isLUB</code> at this step?</p>",
        "id": 572670584,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1770604700
    },
    {
        "content": "<p>Actually, I'm wrong here. It feels like we don't need the current <code>CompleteLattice</code> class anymore, and <code>isLUB_sSup_of_exists_isLUB</code> can be proven from the new (algebraic) <code>CompleteLattice</code> and the definition of <code>sSup</code>.<br>\nI think the reason why I wanted to reintroduce the current <code>CompleteLattice</code> is for compatibility, as a first step in the direction we want, but in the end, it is very weird as it should contain nothing (it would be CompleteLattice with  Classical).</p>",
        "id": 572716821,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1770628727
    },
    {
        "content": "<p>Don't we need the intermediate steps? Without defeq many proofs would be broken.</p>",
        "id": 572741984,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1770634759
    },
    {
        "content": "<p>My apologies, I got confused by thinking that <code>sSup</code> and <code>sInf</code> were defined as <span class=\"user-mention\" data-user-id=\"459227\">@Violeta Hernández</span> said. Instead <code>CompleteLattice</code> now inherit from our new algebraic complete lattice, SupSet and InfSet. Could you give me the definition of this new complete lattice?</p>\n<p>I don't feel like this intermediate step is good anymore, it feels like we either need to do a big refactor with the defs of <code>sSup</code> and <code>sInf</code>, or we can do it smoother with <code>LawfulSup</code> and <code>LawfulInf</code>, possibly reaching the same outcome but less chaotically.</p>",
        "id": 572760245,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1770639434
    },
    {
        "content": "<p>I put my attempt into PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/35263\">#35263</a>. You can check my definition of complete lattices there.</p>",
        "id": 573799342,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1771005226
    },
    {
        "content": "<p>Hi, it's been a while since I checked this thread. What's the current proposal we're discussing?</p>",
        "id": 574382903,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1771361663
    },
    {
        "content": "<p>Well, it seems hard to find a small satisfying step and any large one causes a lot of friction, so I'm not sure what to do here. I need to think some more.</p>",
        "id": 574509080,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1771421677
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"455791\">Yuyang Zhao</span> <a href=\"#narrow/channel/113488-general/topic/Any.20infimum.20based.20version.20of.20.60OmegaCompletePartialOrder.60.3F/near/573799342\">said</a>:</p>\n<blockquote>\n<p>I put my attempt into PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/35263\">#35263</a>. You can check my definition of complete lattices there.</p>\n</blockquote>\n<p>PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/35674\">#35674</a> only modifies <code>ConditionallyCompleteLattice</code>. The diff there is much smaller.</p>",
        "id": 575232633,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1771828454
    },
    {
        "content": "<p>Just saw the PRs, I really like this new approach!</p>",
        "id": 575378876,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1771873922
    }
]