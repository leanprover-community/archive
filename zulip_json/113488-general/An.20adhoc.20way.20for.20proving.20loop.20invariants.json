[
    {
        "content": "<p>I want to make a custom notation (elaborator) that allows you to prove loop invariants internally within lean's do notation using a similar sort of notation that is used for termination_by.<br>\nNamely:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Id</span><span class=\"bp\">.</span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n<span class=\"w\">    </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"c1\">--     ...</span>\n<span class=\"w\">    </span><span class=\"n\">perserving</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"ss\">`stx</span><span class=\"bp\">`</span>\n<span class=\"w\">    </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span>\n</code></pre></div>\n<p>gets elaborated into </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Id</span><span class=\"bp\">.</span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">h'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Subtype</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h'</span><span class=\"bp\">.</span><span class=\"m\">2</span>\n<span class=\"w\">    </span><span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h'</span><span class=\"bp\">.</span><span class=\"m\">1</span>\n<span class=\"w\">    </span><span class=\"c1\">-- ...</span>\n<span class=\"w\">    </span><span class=\"n\">h'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"ss\">`stx</span><span class=\"bp\">`⟩</span>\n<span class=\"w\">  </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h'</span><span class=\"bp\">.</span><span class=\"n\">property</span>\n<span class=\"w\">  </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span>\n</code></pre></div>\n<p>Note that the <code>w : x + z = 2 := h</code> is just to demonstrate that the loop invariant is accessible outside of the loop body.<br>\nRight now I've mainly been looking at Lean.Predefinition.TerminationArgument for inspiration on how to implement the elaborator. Does anyone have any tips on what the general approach or structure would be for implementing an elaborator like this? (also any feedback on the design of the dsl/notation would also be appreciated)</p>",
        "id": 473193583,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1727465453
    },
    {
        "content": "<p>nice idea!</p>",
        "id": 473348125,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1727530529
    },
    {
        "content": "<p>One thing that complicates this is that the <code>...</code> could contain <code>break</code> or <code>return</code> or <code>continue</code></p>",
        "id": 473364828,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727542149
    },
    {
        "content": "<p>I think <span class=\"user-mention\" data-user-id=\"110865\">@Jeremy Avigad</span> had ideas for such a syntax, we discussed this problem a few months ago</p>",
        "id": 473365399,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727542631
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"483794\">@Zach Battleman</span>, Mario, and I did some experiments on this the summer before last. IIRC, our main conclusion was that a small variation on existing <code>do</code> notation would do the trick, namely, allowing mutable variables to have dependent types. Then you could write something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Id</span><span class=\"bp\">.</span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"w\">    </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"w\">      </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"w\">      </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>In other words, you update the proof of the the invariant the same way you update the variables.  Mario had an experimental alternative implementation of Lean's <code>do</code> notation and I think we convinced ourselves that the modifications needed to handle the dependency would be reasonably straightforward, but we never had an implementation.</p>\n<p>Another conclusion we came to is that in the definitions of <code>x</code>, <code>z</code>, and <code>h</code> it is useful to refer to the previous (shadowed) definitions of <code>x</code> and <code>z</code>. One can do this manually in the current framework by renaming them. We talked about having special notation like <code>old x</code> and <code>old z</code> to refer to the previous values. I wasn't crazy about that, but I don't have a better idea.</p>\n<p>Finally, I think we decided that the most general thing we would want to handle is a <code>while</code> loop:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">10</span>\n<span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">15</span>\n<span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n\n<span class=\"n\">while</span><span class=\"w\"> </span><span class=\"n\">cond</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">30</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"c1\">-- shadows old x</span>\n<span class=\"w\">  </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"c1\">-- shadows old y</span>\n<span class=\"w\">  </span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">100</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">100</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">old</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"n\">termination_by</span><span class=\"w\"> </span><span class=\"mi\">100</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>\n<p>After the <code>while</code> loop, the context should have <code>cond : ¬ x &lt; 30</code>. <code>for</code> and <code>repeat ... until</code> can be defined from that.</p>\n<p>I'd love to see something like this implemented! We called the project \"lafny,\" i.e. our take on a Lean version of the Dafny system.</p>",
        "id": 473385568,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1727557706
    },
    {
        "content": "<p>Yeah I'd defintely be interested in implementing dependently typed mutable variables and also getting termination by support for while loops. Would it be possible to get some mentorship for you guys since I'm still pretty new to the Lean/Parser/Do and Lean/Elab/Do code files?</p>",
        "id": 473401934,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1727575127
    },
    {
        "content": "<p>This would be really cool, and is a huge missing piece of the current story for <code>do</code> blocks. Seeing more prototypes in this direction would be nice. (Remember, of course, that actually getting a solution into Lean is going to be a process with many moving parts, and will require the FRO to have the bandwidth to study and invest in a particular solution; right now that isn't there, but we do really want to get to this!)</p>",
        "id": 473408867,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1727582480
    },
    {
        "content": "<p>Is there any resource explaining how the current mutable var system works for Lean's do notation? I'm having trouble understanding the big picture when reading Lean/Elab/Do</p>",
        "id": 473410824,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1727584707
    },
    {
        "content": "<p>Apologies if this is a dumb question, but have you read \"Do unchained\"?</p>",
        "id": 473411960,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1727585639
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/stream/113488-general/topic/An.20adhoc.20way.20for.20proving.20loop.20invariants/near/473411960\">said</a>:</p>\n<blockquote>\n<p>Apologies if this is a dumb question, but have you read \"Do unchained\"?</p>\n</blockquote>\n<p>Yeah I have, although maybe not as thoroughly as I should have. I'm but I don't think that paper explains how variables are stored in the Context type. Since it seems to mainly focus on the semantics and soundness properties of lean's do notation</p>",
        "id": 473413167,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1727586533
    },
    {
        "content": "<p>oh do do you mean I should right a reference implementation in a form similar to do' as a demo first and then try integrate into the actual do notation?</p>",
        "id": 473413494,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1727586882
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/stream/113488-general/topic/An.20adhoc.20way.20for.20proving.20loop.20invariants/near/473411960\">said</a>:</p>\n<blockquote>\n<p>Apologies if this is a dumb question, but have you read \"Do unchained\"?</p>\n</blockquote>\n<p>Do unchained is also not how the implementation currently actually works. Its more of a suggestion on how one could make an academically pleasing implementation. The current do elaborator is very different</p>",
        "id": 473429001,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1727600242
    },
    {
        "content": "<p>Which does make it much easier to prototype extensions in</p>",
        "id": 473433644,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1727603519
    },
    {
        "content": "<p>Frederick, I’m afraid Henrik is not explicit enough. <a href=\"https://github.com/leanprover/lean4/blob/master/src/Lean/Elab/Do.lean\">Lean.Elab.Do</a> alone is 1800 lines of delicate mission critical code. There is no doubt that people would love to have efficient ways to prove things about programs written using all the great do notation goodies. And it’s great to experiment with that. But pushing those experimenting to core Lean is a completely different story. It would most certainly require to first try your hand at a lot of easier tasks, building your skills and trust from the core team. I don’t want to cut your momentum, and I’m not part of the core team. I only want you to have realistic expectation to avoid frustration.</p>",
        "id": 473435133,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1727604738
    },
    {
        "content": "<p>Oh wow! It's great to see that people are interested in this! <span class=\"user-mention\" data-user-id=\"110865\">@Jeremy Avigad</span> basically covered the story up to now about what we worked on, and admittedly it's been some time since I took a look at this, but I'm really excited to hear that there is interest in this! I don't have the bandwidth right now to work on it, but I'd be very excited to see where this develops and I'd be eager to return to it in the future. </p>\n<p><span class=\"user-mention\" data-user-id=\"110865\">@Jeremy Avigad</span> is the repo owner so once he makes it public he can post it here (discussed over email)</p>",
        "id": 473451549,
        "sender_full_name": "Zach Battleman",
        "timestamp": 1727618249
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110865\">Jeremy Avigad</span> <a href=\"#narrow/stream/113488-general/topic/An.20adhoc.20way.20for.20proving.20loop.20invariants/near/473385568\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"483794\">Zach Battleman</span>, Mario, and I did some experiments on this the summer before last. IIRC, our main conclusion was that a small variation on existing <code>do</code> notation would do the trick, namely, allowing mutable variables to have dependent types. Then you could write something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Id</span><span class=\"bp\">.</span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"w\">    </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"w\">      </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"w\">      </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>In other words, you update the proof of the the invariant the same way you update the variables.  Mario had an experimental alternative implementation of Lean's <code>do</code> notation and I think we convinced ourselves that the modifications needed to handle the dependency would be reasonably straightforward, but we never had an implementation.</p>\n<p>Another conclusion we came to is that in the definitions of <code>x</code>, <code>z</code>, and <code>h</code> it is useful to refer to the previous (shadowed) definitions of <code>x</code> and <code>z</code>. One can do this manually in the current framework by renaming them. We talked about having special notation like <code>old x</code> and <code>old z</code> to refer to the previous values. I wasn't crazy about that, but I don't have a better idea.</p>\n<p>Finally, I think we decided that the most general thing we would want to handle is a <code>while</code> loop:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">10</span>\n<span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">15</span>\n<span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n\n<span class=\"n\">while</span><span class=\"w\"> </span><span class=\"n\">cond</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">30</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"c1\">-- shadows old x</span>\n<span class=\"w\">  </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"c1\">-- shadows old y</span>\n<span class=\"w\">  </span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">100</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">100</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">old</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"n\">termination_by</span><span class=\"w\"> </span><span class=\"mi\">100</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>\n<p>After the <code>while</code> loop, the context should have <code>cond : ¬ x &lt; 30</code>. <code>for</code> and <code>repeat ... until</code> can be defined from that.</p>\n<p>I'd love to see something like this implemented! We called the project \"lafny,\" i.e. our take on a Lean version of the Dafny system.</p>\n</blockquote>\n<p>K, so I have a concern about the dependently typed mutable variables.<br>\nSince h has a type dependent on x and z, wouldnt that mean you would need to update h everytime either x or z is updated? What mechanism allows you to procrasinate the proof h until the end of the do block inside of the for body?</p>\n<p>I was thinking that whenever you break or coninue or reach the end of the loop body you need to emit a proof that the loop invariant holds somehting like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">perserving</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"bp\">...</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">       </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">....</span>\n<span class=\"w\">       </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.....</span>\n<span class=\"w\">       </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">              </span><span class=\"n\">continue</span><span class=\"w\"> </span><span class=\"n\">emit</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"ss\">`proof</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">invariant</span><span class=\"bp\">`</span><span class=\"o\">)</span>\n<span class=\"w\">       </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">              </span><span class=\"n\">break</span><span class=\"w\"> </span><span class=\"n\">emit</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"ss\">`proof</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">invariant</span><span class=\"bp\">`</span><span class=\"o\">)</span>\n<span class=\"w\">       </span><span class=\"n\">emit</span><span class=\"w\"> </span><span class=\"ss\">`proof</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">invariant</span><span class=\"bp\">`</span>\n</code></pre></div>\n<p>Overall i feel like having dependently typed mutable vars might be too aggressive of an abstraction for being able to prove loop invariants since the loop invariant would need to updated everytime the anytime the mutables vars it's responsible for are updated.</p>\n<p>Instead, you should only need to prove the invariant whenever you are completing the current iteration of the loop (ie continueing to the end of the loop body, breaking out of hte loop body, or have reached the end of the loop body)</p>",
        "id": 473465908,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1727627303
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113488-general/topic/An.20adhoc.20way.20for.20proving.20loop.20invariants/near/473435133\">said</a>:</p>\n<blockquote>\n<p>Frederick, I’m afraid Henrik is not explicit enough. <a href=\"https://github.com/leanprover/lean4/blob/master/src/Lean/Elab/Do.lean\">Lean.Elab.Do</a> alone is 1800 lines of delicate mission critical code. There is no doubt that people would love to have efficient ways to prove things about programs written using all the great do notation goodies. And it’s great to experiment with that. But pushing those experimenting to core Lean is a completely different story. It would most certainly require to first try your hand at a lot of easier tasks, building your skills and trust from the core team. I don’t want to cut your momentum, and I’m not part of the core team. I only want you to have realistic expectation to avoid frustration.</p>\n</blockquote>\n<p>yeah im not to worried about that since I a) havent fleshed out how I want to implement the loop invariant thing b) have not implemented it yet lol</p>",
        "id": 473466950,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1727627777
    },
    {
        "content": "<p>That’s great, it means you know from the beginning what you can expect.  And I hope good things will come out of this work, one way or another.</p>",
        "id": 473467081,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1727627894
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"676310\">Frederick Pu</span> <a href=\"#narrow/stream/113488-general/topic/An.20adhoc.20way.20for.20proving.20loop.20invariants/near/473465908\">said</a>:</p>\n<blockquote>\n<p>Since h has a type dependent on x and z, wouldnt that mean you would need to update h everytime either x or z is updated? What mechanism allows you to procrasinate the proof h until the end of the do block inside of the for body?</p>\n</blockquote>\n<p>If you don't update <code>h</code> in the block, you will get a type error because the desugared code will attempt to pass the original <code>h</code> to the next iteration, and it will have the wrong type for that</p>",
        "id": 473471504,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727630612
    },
    {
        "content": "<p>Other than that, there isn't really anything that needs to be done implementation wise, except to remove the piece of code which lean uses to explicitly force the type not to change when you use <code>h := ...</code> syntax. It's actually quite easy to implement since it's negative code</p>",
        "id": 473471822,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727630693
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"676310\">Frederick Pu</span> <a href=\"#narrow/stream/113488-general/topic/An.20adhoc.20way.20for.20proving.20loop.20invariants/near/473465908\">said</a>:</p>\n<blockquote>\n<p>Overall i feel like having dependently typed mutable vars might be too aggressive of an abstraction for being able to prove loop invariants since the loop invariant would need to updated everytime the anytime the mutables vars it's responsible for are updated.</p>\n</blockquote>\n<p>I think this is a misunderstanding, you don't need to update <code>h</code> immediately after <code>x</code> and <code>z</code> here, but if you don't you will see in the infoview that it has a type referring to the old shadowed values of <code>x</code> and <code>z</code>, and you won't be able to end the loop until you've updated <code>h</code> to have a type consistent with the values of <code>x</code> and <code>z</code> that will be used in the next iteration.</p>",
        "id": 473472321,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727630824
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/An.20adhoc.20way.20for.20proving.20loop.20invariants/near/473472321\">said</a>:</p>\n<blockquote>\n<p>I think this is a misunderstanding, you don't need to update <code>h</code> immediately after <code>x</code> and <code>z</code> here, but if you don't you will see in the infoview that it has a type referring to the old shadowed values of <code>x</code> and <code>z</code>, and you won't be able to end the loop until you've updated <code>h</code> to have a type consistent with the values of <code>x</code> and <code>z</code> that will be used in the next iteration.</p>\n</blockquote>\n<p>ok so if I'm understanding correctly, you need give the elaborator enough information to prove loop invariant by the end of the loop or it'll just treat the x and z modifications you made as shadowed variables?<br>\nBut you can't shadow a mutable variable so is there some weird trick to make that work?</p>",
        "id": 473473145,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1727631258
    },
    {
        "content": "<p>mutable variables are desugared to shadowing let bindings</p>",
        "id": 473473190,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727631331
    },
    {
        "content": "<p>plus some extra sauce so that modifications inside control structures are propagated to the subsequent scope</p>",
        "id": 473473218,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727631360
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"n\">Id</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"k\">from</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n<span class=\"w\">  </span><span class=\"c1\">-- _h : x✝ = x✝</span>\n<span class=\"w\">  </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"c1\">-- let_fun this :=</span>\n<span class=\"c1\">--   let x := 1;</span>\n<span class=\"c1\">--   let_fun _h := ⋯;</span>\n<span class=\"c1\">--   let x := 2;</span>\n<span class=\"c1\">--   pure x;</span>\n<span class=\"c1\">-- this : Id Nat</span>\n</code></pre></div>",
        "id": 473473460,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727631558
    },
    {
        "content": "<p>so the no shadowing mutable variables is more like a linter error generated by do notation?</p>",
        "id": 473473700,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1727631738
    },
    {
        "content": "<p>also what happens if multiple variables dependent on the same variable x . Then you would need to both them to be proven in order for x to be unshadowed no?</p>",
        "id": 473474150,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1727632137
    },
    {
        "content": "<p>also i dont see the definition of <code>for ... in</code> for the do unchained reference implementation</p>",
        "id": 473474795,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1727632610
    },
    {
        "content": "<p>Only variables that are mutated in the loop need to have up to date types</p>",
        "id": 473475475,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727633120
    },
    {
        "content": "<p>or rather, when a variable is mutated in the loop anything depending on it also needs to be updated when you go around the loop</p>",
        "id": 473475596,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727633181
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/An.20adhoc.20way.20for.20proving.20loop.20invariants/near/473475596\">said</a>:</p>\n<blockquote>\n<p>or rather, when a variable is mutated in the loop anything depending on it also needs to be updated when you go around the loop</p>\n</blockquote>\n<p>so how do you know that all of it's corresponding types have been updated? that seems like you'd have to do some reference counting or smth.</p>",
        "id": 473475728,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1727633325
    },
    {
        "content": "<p>cause i thought it was just like when you prove <code>h</code> you also unshadow x and y. But if you have both h1 and h2 depending on x, then that trick wont work.</p>",
        "id": 473475757,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1727633372
    },
    {
        "content": "<p>im working through the do unchained reference implementation right now and I'm getting the following error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"n\">declare_syntax_cat</span><span class=\"w\"> </span><span class=\"n\">stmt</span>\n\n<span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"s2\">\"do'\"</span><span class=\"w\"> </span><span class=\"n\">stmt</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">term</span>\n<span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"s2\">\"if\"</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"s2\">\"then\"</span><span class=\"w\"> </span><span class=\"n\">stmt</span><span class=\"w\"> </span><span class=\"s2\">\"else\"</span><span class=\"w\"> </span><span class=\"n\">stmt</span><span class=\"o\">:</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">stmt</span>\n<span class=\"kn\">macro</span><span class=\"w\"> </span><span class=\"s2\">\"{\"</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">stmt</span><span class=\"w\"> </span><span class=\"s2\">\"}\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">stmt</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">s</span><span class=\"o\">)</span>\n<span class=\"c1\">-- application type mismatch</span>\n<span class=\"c1\">--   s.raw</span>\n<span class=\"c1\">-- argument</span>\n<span class=\"c1\">--   s</span>\n<span class=\"c1\">-- has type</span>\n<span class=\"c1\">--   Lean.TSyntax `stmt : Type</span>\n<span class=\"c1\">-- but is expected to have type</span>\n<span class=\"c1\">--   Lean.TSyntax `term : Type</span>\n</code></pre></div>",
        "id": 473478566,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1727634919
    },
    {
        "content": "<p>I am happy to see the activity here. I should have made it clear when I said that I would love to see an implementation that what I am hoping for is a prototype proof of concept and some examples of how it can be used. That would help show that Lean can be used to verify programs in the precondition/postcondition/assertion/invariant style of doing things. That could be helpful to the Lean development team down the line if / when they revisit do notation one day.</p>\n<p>This was a undergraduate research project for <span class=\"user-mention\" data-user-id=\"483794\">@Zach Battleman</span> the summer before last, between his second and third years at CMU. By the end of the summer, we had worked out the syntax described above on paper and the translation to ordinary functional programs in Lean. Zach also manually worked out some examples from the <a href=\"https://mitpress.mit.edu/9780262546232/program-proofs/\">Dafny book</a> to convince ourselves that our approach was robust enough to support them. The repository is <a href=\"https://github.com/avigad/lafny-experiments\">here</a>. It wasn't meant for public use, but perhaps it will be useful. The repository also contains some of Mario's experiments implementing the syntax.</p>",
        "id": 473481679,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1727636119
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"676310\">Frederick Pu</span> <a href=\"#narrow/stream/113488-general/topic/An.20adhoc.20way.20for.20proving.20loop.20invariants/near/473475728\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/An.20adhoc.20way.20for.20proving.20loop.20invariants/near/473475596\">said</a>:</p>\n<blockquote>\n<p>or rather, when a variable is mutated in the loop anything depending on it also needs to be updated when you go around the loop</p>\n</blockquote>\n<p>so how do you know that all of it's corresponding types have been updated? that seems like you'd have to do some reference counting or smth.</p>\n</blockquote>\n<p>No, just typechecking. If you don't update these values, then the original variables will be passed, but the type of the continuation function to go around the loop expects the values to have compatible types so this is a type error.</p>",
        "id": 473484913,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727638671
    },
    {
        "content": "<p>There is no \"unshadowing\" going on. When you update <code>h</code> it's now another variable shadowing the original <code>h</code>, and this one has a type mentioning the new <code>x</code> and not the old one. If you update <code>h</code> but not <code>x</code> or vice versa, then it won't be the case that <code>&lt;x, h&gt;</code> lives in the appropriate sigma type.</p>",
        "id": 473485014,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727638782
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/An.20adhoc.20way.20for.20proving.20loop.20invariants/near/473484913\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"676310\">Frederick Pu</span> <a href=\"#narrow/stream/113488-general/topic/An.20adhoc.20way.20for.20proving.20loop.20invariants/near/473475728\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/An.20adhoc.20way.20for.20proving.20loop.20invariants/near/473475596\">said</a>:</p>\n<blockquote>\n<p>or rather, when a variable is mutated in the loop anything depending on it also needs to be updated when you go around the loop</p>\n</blockquote>\n<p>so how do you know that all of it's corresponding types have been updated? that seems like you'd have to do some reference counting or smth.</p>\n</blockquote>\n<p>No, just typechecking. If you don't update these values, then the original variables will be passed, but the type of the continuation function to go around the loop expects the values to have compatible types so this is a type error.</p>\n</blockquote>\n<p>What would the type of the continuation function be if you have h1 h2 dependent on x?<br>\nWould it be like Subtype (fun x =&gt; h1[x/x] ^ h2[x/x]) -&gt; M (Subtype (fun x =&gt; h1[x/x] ^ h2[x/x]))<br>\n?</p>",
        "id": 473490342,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1727643599
    },
    {
        "content": "<p><code>cont : (x : T) -&gt; (h1 : foo x) -&gt; (h2 : bar x) -&gt; M result</code></p>",
        "id": 473490646,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727643849
    },
    {
        "content": "<p>in the desugaring this function is called as <code>cont x h1 h2</code> with whatever the \"current values\" of <code>x</code>,<code>h1</code>,<code>h2</code> are (i.e. the result of the last mutation to the variables), so <code>h1</code> needs to have the type <code>foo x</code> and if not (e.g. if it's <code>foo x✝</code> instead) it's a type error</p>",
        "id": 473490782,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727643977
    },
    {
        "content": "<p>Do you declare it a type error, or do you just drop <code>h1</code> from the continuation? I'm thinking of a <code>while</code> loop that preserves an invariant related to termination, but then uses <code>break</code> at a point where it is no longer preserved</p>",
        "id": 473492083,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727645201
    },
    {
        "content": "<p>when it's not used, it's not passed so there is no problem</p>",
        "id": 473492442,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727645524
    },
    {
        "content": "<p>this is the loop continue continuation we're talking about</p>",
        "id": 473492460,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727645550
    },
    {
        "content": "<p>so how is the continuation function used?</p>",
        "id": 473493285,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1727646328
    },
    {
        "content": "<p>is it called within the for loop after desugaring or smth?</p>",
        "id": 473493425,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1727646413
    },
    {
        "content": "<p>yes, the body of the loop concludes by calling one of the available continuations corresponding to the kind of exit (<code>break</code>, <code>continue</code>, <code>return</code>, end of block = <code>continue</code>)</p>",
        "id": 473493528,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727646499
    },
    {
        "content": "<p>i guess the one way it would differ from a loop invariant is you dont need to prove the loop invariant if you're returning. but i guess x would be scoped anyways in that case</p>",
        "id": 473493571,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1727646560
    },
    {
        "content": "<p>This is implemented in the <code>do</code> implementation Jeremy linked, <a href=\"https://github.com/avigad/lafny-experiments/blob/main/Lafny/Do.lean\">https://github.com/avigad/lafny-experiments/blob/main/Lafny/Do.lean</a></p>",
        "id": 473493580,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727646563
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"676310\">Frederick Pu</span> <a href=\"#narrow/stream/113488-general/topic/An.20adhoc.20way.20for.20proving.20loop.20invariants/near/473478566\">said</a>:</p>\n<blockquote>\n<p>im working through the do unchained reference implementation right now and I'm getting the following error:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"n\">declare_syntax_cat</span><span class=\"w\"> </span><span class=\"n\">stmt</span>\n\n<span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"s2\">\"do'\"</span><span class=\"w\"> </span><span class=\"n\">stmt</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">term</span>\n<span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"s2\">\"if\"</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"s2\">\"then\"</span><span class=\"w\"> </span><span class=\"n\">stmt</span><span class=\"w\"> </span><span class=\"s2\">\"else\"</span><span class=\"w\"> </span><span class=\"n\">stmt</span><span class=\"o\">:</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">stmt</span>\n<span class=\"kn\">macro</span><span class=\"w\"> </span><span class=\"s2\">\"{\"</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">stmt</span><span class=\"w\"> </span><span class=\"s2\">\"}\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">stmt</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">s</span><span class=\"o\">)</span>\n<span class=\"c1\">-- application type mismatch</span>\n<span class=\"c1\">--   s.raw</span>\n<span class=\"c1\">-- argument</span>\n<span class=\"c1\">--   s</span>\n<span class=\"c1\">-- has type</span>\n<span class=\"c1\">--   Lean.TSyntax `stmt : Type</span>\n<span class=\"c1\">-- but is expected to have type</span>\n<span class=\"c1\">--   Lean.TSyntax `term : Type</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>im sorry to bring this up again but i think it might have gotten buried.</p>",
        "id": 473493855,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1727646799
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">macro</span><span class=\"w\"> </span><span class=\"s2\">\"{\"</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">stmt</span><span class=\"w\"> </span><span class=\"s2\">\"}\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">stmt</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">stmt</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">s</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 473493877,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727646833
    },
    {
        "content": "<p>the way these things get parsed changed a bit since that was written</p>",
        "id": 473493936,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727646855
    },
    {
        "content": "<p>also is there a way to verify that a parser/elaborator is correct with respect to a reference implmentation using lean's hygenic  macro system?</p>",
        "id": 473494436,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1727647326
    },
    {
        "content": "<p>no, proofs about tactics and other metaprogramming is more or less completely unsupported</p>",
        "id": 473494508,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727647433
    },
    {
        "content": "<p>MetaCoq has an interesting system for verified metaprogramming called Template-Coq, so in theory Lean4Lean could do the same thing and build a verified metaprogramming system on top</p>",
        "id": 473494564,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727647476
    },
    {
        "content": "<p>what about just the elaborator, since i think this change probably doesn't change the parser at all</p>",
        "id": 473494921,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1727647727
    },
    {
        "content": "<p>cause arent most of the monad calls used to get fresh metavariables and stuff like that?</p>",
        "id": 473495096,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1727647798
    },
    {
        "content": "<p>the elaborator is the most complicated part of lean, and it has access to a ton of state, including IO</p>",
        "id": 473495148,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727647813
    },
    {
        "content": "<p>so it's like impossible to seperate the semantics of elab/do.lean from any of the sideeffect calls it makes right?</p>",
        "id": 473495191,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1727647865
    },
    {
        "content": "<p>it's possible but not without rewriting parts of core</p>",
        "id": 473495280,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727647934
    },
    {
        "content": "<p>and even if you did it would be really crazy complicated to reason about</p>",
        "id": 473495318,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727647970
    },
    {
        "content": "<p>maybe it'll be possible with lafney 2051</p>",
        "id": 473495339,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1727647989
    },
    {
        "content": "<p>you would be better off writing another tactic framework from scratch with verification in mind</p>",
        "id": 473495341,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727647991
    },
    {
        "content": "<p>now getting the following errors</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n\n<span class=\"n\">declare_syntax_cat</span><span class=\"w\"> </span><span class=\"n\">stmt</span>\n<span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"s2\">\"do'\"</span><span class=\"w\"> </span><span class=\"n\">stmt</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">term</span>\n<span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"s2\">\"let\"</span><span class=\"w\"> </span><span class=\"n\">ident</span><span class=\"w\"> </span><span class=\"s2\">\"←\"</span><span class=\"w\"> </span><span class=\"n\">stmt</span><span class=\"w\"> </span><span class=\"s2\">\";\"</span><span class=\"w\"> </span><span class=\"n\">stmt</span><span class=\"o\">:</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">stmt</span>\n<span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"s2\">\"if\"</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"s2\">\"then\"</span><span class=\"w\"> </span><span class=\"n\">stmt</span><span class=\"w\"> </span><span class=\"s2\">\"else\"</span><span class=\"w\"> </span><span class=\"n\">stmt</span><span class=\"o\">:</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">stmt</span>\n<span class=\"kn\">macro</span><span class=\"w\"> </span><span class=\"s2\">\"{\"</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">stmt</span><span class=\"w\"> </span><span class=\"s2\">\"}\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">stmt</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">stmt</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">s</span><span class=\"o\">)</span>\n\n<span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"s2\">\"d!\"</span><span class=\"w\"> </span><span class=\"n\">stmt</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">term</span>\n\n<span class=\"kn\">macro_rules</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">d!</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">s</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">s'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">((</span><span class=\"n\">d!</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">d!</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">s'</span><span class=\"o\">))</span>\n\n<span class=\"n\">declare_syntax_cat</span><span class=\"w\"> </span><span class=\"n\">expander</span>\n<span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"s2\">\"expand!\"</span><span class=\"w\"> </span><span class=\"n\">expander</span><span class=\"w\"> </span><span class=\"s2\">\"in\"</span><span class=\"w\"> </span><span class=\"n\">stmt</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">stmt</span>\n<span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"s2\">\"mut\"</span><span class=\"w\"> </span><span class=\"n\">ident</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">expander</span>\n\n<span class=\"kn\">macro_rules</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">stmt</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">expand!</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">e</span><span class=\"o\">:</span><span class=\"n\">stmt</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">stmt</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">StateT</span><span class=\"bp\">.</span><span class=\"n\">lift</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">e</span><span class=\"o\">)</span>\n<span class=\"c1\">-- unexpected identifier; expected stmtLean 4</span>\n<span class=\"c1\">-- (for StateT.lift)</span>\n\n<span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"s2\">\"return\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">expander</span><span class=\"w\"> </span><span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"s2\">\"break\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">expander</span><span class=\"w\"> </span><span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"s2\">\"lift\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">expander</span>\n\n<span class=\"kn\">macro_rules</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">stmt</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">expand!</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">exp</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">s1</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">s2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">stmt</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">expand!</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">exp</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">s1</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">expand!</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">exp</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">s2</span><span class=\"o\">)</span>\n\n<span class=\"kn\">macro_rules</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">stmt</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">expand!</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">s</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">s'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"n\">throw</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Macro</span><span class=\"bp\">.</span><span class=\"n\">Exception</span><span class=\"bp\">.</span><span class=\"n\">error</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">s!</span><span class=\"s2\">\"cannot shadow 'mut' variable '{x.getId}'\"</span>\n<span class=\"k\">else</span>\n<span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">stmt</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">expand!</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">s</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">get</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">expand!</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">s'</span><span class=\"o\">)</span>\n<span class=\"c1\">-- elaboration function for 'command.pseudo.antiquot' has not been implemented</span>\n<span class=\"c1\">-- (for `get` `y `and `s'`)</span>\n</code></pre></div>",
        "id": 473513297,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1727657306
    },
    {
        "content": "<p>also im assuming that do unchained doesn't show a full reference implementation since the syntax for let &lt;- is missing and so is that for for loops</p>",
        "id": 473513385,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1727657347
    },
    {
        "content": "<p>also doesnt the <code>mut in</code> syntax declaration contradict the macro?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">declare_syntax_cat</span><span class=\"w\"> </span><span class=\"n\">expander</span>\n<span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"s2\">\"expand!\"</span><span class=\"w\"> </span><span class=\"n\">expander</span><span class=\"w\"> </span><span class=\"s2\">\"in\"</span><span class=\"w\"> </span><span class=\"n\">stmt</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">stmt</span>\n<span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"s2\">\"mut\"</span><span class=\"w\"> </span><span class=\"n\">ident</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">expander</span>\n\n<span class=\"kn\">macro_rules</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">stmt</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">expand!</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">e</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">stmt</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">StateT</span><span class=\"bp\">.</span><span class=\"n\">lift</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">e</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 473519291,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1727659217
    },
    {
        "content": "<p>ig the problem goes away if you add <code>syntax term : stmt</code> but that's kinda sketch</p>",
        "id": 473520360,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1727659603
    },
    {
        "content": "<p>the real do notation does in fact have <code>syntax term : stmt</code></p>",
        "id": 473600535,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727677356
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"676310\">Frederick Pu</span> <a href=\"#narrow/stream/113488-general/topic/An.20adhoc.20way.20for.20proving.20loop.20invariants/near/473519291\">said</a>:</p>\n<blockquote>\n<p>also doesnt the <code>mut in</code> syntax declaration contradict the macro?</p>\n</blockquote>\n<p>I don't know what you mean by this</p>",
        "id": 473600631,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727677384
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/An.20adhoc.20way.20for.20proving.20loop.20invariants/near/473600631\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"676310\">Frederick Pu</span> <a href=\"#narrow/stream/113488-general/topic/An.20adhoc.20way.20for.20proving.20loop.20invariants/near/473519291\">said</a>:</p>\n<blockquote>\n<p>also doesnt the <code>mut in</code> syntax declaration contradict the macro?</p>\n</blockquote>\n<p>I don't know what you mean by this</p>\n</blockquote>\n<p>I just mean that for the macro rule it says e is  a term but according to the syntax definition it should be a stmt</p>",
        "id": 473834131,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1727724527
    },
    {
        "content": "<p>also just to confirm, the do unchained paper doesn't describe a full reference implementation using hygenic macros just a rough sketch of what you would need to do?</p>",
        "id": 473844355,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1727726848
    },
    {
        "content": "<p>Yes.</p>",
        "id": 473845561,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1727727134
    },
    {
        "content": "<p>Everything in that paper is much simpler than the real thing (and also the real thing involved since that paper).</p>",
        "id": 473845727,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1727727167
    },
    {
        "content": "<p>so what's the difference between using (registerBuiltinParser and the leading_parser macro) and registering a syntax category? Do builtin parsers actually get compiled into the lean source code or are they still part of the Init library?</p>",
        "id": 475364020,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1728325823
    },
    {
        "content": "<p>also, if the latter is true, i wonder if there could be a way of testing builtinParsers in a sandboxed enviroment (so that they have behavior to syntax categories). That would probably provide a nice debugging tool and also allow for some level of (albeit very scuffed) formal verification</p>",
        "id": 475364434,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1728325996
    }
]