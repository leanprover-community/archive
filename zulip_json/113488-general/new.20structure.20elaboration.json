[
    {
        "content": "<p>While bumping mathlib in Carleson, I encountered a weird behavior, probably due to the new structure elaboration, in which typeclass instances are not available when extending classes. I'm not sure this has already been reported <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>, so here it is. MWE:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">myClass</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">instLEmyClass</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">myClass</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LE</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">True</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">fails</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">myClass</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">y</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">works</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">myClass</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">letI</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LE</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">instLEmyClass</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n<span class=\"w\">    </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">y</span>\n</code></pre></div>\n<p>The LE instance on <code>m.X</code> is not available when defining a class that extends <code>myClass</code>. This used to work on 4.18.</p>",
        "id": 511809561,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1744462660
    },
    {
        "content": "<p>i think that this already was mentioned in porting notes, and i seem to recall that those also mentioned that this is being worked on?</p>",
        "id": 511811208,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744464160
    },
    {
        "content": "<p>The reason this used to work is that when <code>class fails</code> was being elaborated, the local context right before elaborating the <code>p</code> field looks like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">tomyClass</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">myClass</span>\n<span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">toMyClass</span><span class=\"bp\">.</span><span class=\"n\">X</span>\n</code></pre></div>\n<p>and so <code>(x y : X)</code> is the same as <code>(x y : tomyClass.X)</code>. Since the <code>LE</code> instance is on <code>m.X</code>, that would enable the <code>instLEmyClass</code> instance to be found for <code>x ≤ y</code>.</p>\n<p>This is brittle; it only works for fields from so-called \"subobject parents\" (parents that happen to be embedded as the structure's constructor fields). For example, this breaks it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">nClass</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">myClass</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">nClass</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">instLEmyClass</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">myClass</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LE</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">True</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">fails</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">nClass</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">myClass</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"c1\">-- failed to synthesize LE X</span>\n</code></pre></div>\n<p>The issue is that the the field overlap causes <code>myClass</code> to not be represented as a subobject parent, and instead the new <code>X</code> field is represented as its own constructor field. The local context instead looks like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">tonClass</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">nClass</span>\n<span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">nClass</span><span class=\"bp\">.</span><span class=\"n\">n</span>\n<span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n</code></pre></div>\n<p>so given <code>(x y : X)</code>, one no longer has any connection between <code>X</code> and <code>myClass</code>.</p>\n<p>With the new structure elaborator, instead the local context in <code>class fails</code> looks like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"n\">tomyClass</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">myClass</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>\n<p>The relationship between fields and parents is inverted; fields are primary, and the parent projections are all let bindings. No details of which parents are subobject fields are exposed anymore. (Another benefit: all parents provide themselves as instances now, and they can all be referred to in field declarations.)</p>\n<p>The cost is that some things that used to elaborate no longer elaborate (sorry), but I don't see how to reliably have instances for fields of parent classes apply in general.</p>\n<p>That said, I think we have two reliable workarounds for your problem that should appear for the next release. They both involve allowing <code>let</code> bindings as fields.</p>\n<p><strong>Future workaround 1:</strong> I expect that this will be allowed syntax:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">works</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">myClass</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">instLE</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LE</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">instLEmyClass</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n<span class=\"w\">  </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">y</span>\n</code></pre></div>\n<p><strong>Future workaround 2:</strong> Same syntax, but you use it to define a fixed LE instance in the parent class</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">myClass</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">instLE</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LE</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>\n<p>and then when <code>class fails</code> is being defined, this instance would be in the local context.</p>\n<p>I hadn't planned on it, but a potential feature could be the ability to mark certain definitions to be turned into let bindings whenever a structure is extended. For example, imagine</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">myClass</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">structure_include_let</span><span class=\"kd\">]</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">myClass</span><span class=\"bp\">.</span><span class=\"n\">instLE</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">myClass</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LE</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">True</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">fails</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">myClass</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">y</span>\n</code></pre></div>\n<p>and then the local context when <code>p</code> is being elaborated could be</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"n\">tomyClass</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">myClass</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">}</span>\n<span class=\"n\">instLE</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LE</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">myClass</span><span class=\"bp\">.</span><span class=\"n\">instLE</span><span class=\"w\"> </span><span class=\"n\">tomyClass</span>\n</code></pre></div>\n<p>Other than these sorts of features (new <code>let</code> field syntax or a <code>@[structure_include_let]</code> attribute), I don't see how we could support the old behavior — and I believe the old behavior wasn't intended.</p>\n<p>Let me know if this is a significant issue, or if there are more examples that we should address.</p>",
        "id": 511834270,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1744482970
    },
    {
        "content": "<p>let me try to rephrase those possible solutions to check my understanding.<br>\nBoth solutions allows you to tell lean about instances to use when trying to make sense of the types of class fields.</p>\n<ul>\n<li>Workaround 1 allows you to do so when defining the class which needs the instance</li>\n<li>Workaround 2 allows you to do so when defining the parent class, telling lean \"keep this in mind for any child class\"</li>\n<li>Workaround 2b (the <code>structure_include_let</code> option) allows you to do so when defining an <em>instance</em>, telling lean \"add this in mind while extending ?????\"</li>\n</ul>\n<p>I'm not sure i quite get when some instance could be applicable to some class definition. I'm having a hard time visualizing exactly what aspects of <code>myClass.instLE</code> tell lean what classes this should be added to as \"let\" binding.</p>",
        "id": 511835805,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744484284
    },
    {
        "content": "<p>honestly i'm having a hard time writing down my question...<br>\nlet me try an example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">myClass</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">structure_include_let</span><span class=\"kd\">]</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"bp\">.</span><span class=\"n\">instGroup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">structure_include_let</span><span class=\"kd\">]</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">myClass</span><span class=\"bp\">.</span><span class=\"n\">instLE</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">myClass</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">X</span><span class=\"o\">]:</span><span class=\"w\"> </span><span class=\"n\">LE</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">True</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">fails</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">myClass</span><span class=\"w\"> </span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">y</span>\n</code></pre></div>\n<p>How does lean realize that <code>myClass.instLE</code> and <code>Foo.instGroup</code> should be added as let-bindings here?</p>",
        "id": 511836546,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744484923
    },
    {
        "content": "<p>or, well, how will/might lean do this when this is implemented...</p>",
        "id": 511836660,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744485014
    },
    {
        "content": "<p>To be clear, the features I'm proposing are not for instances per se, but they can be used to supply instances (since typeclass inference makes use of any instances introduced with <code>let</code>).</p>\n<ul>\n<li>Workaround 1: Yes, the <code>let</code> lets you introduce instances that are needed to define fields. This is the \"obvious\" use of the potential feature.</li>\n<li>Workaround 2: Yes, the idea would be that <code>let</code>s are remembered, and they might even be available as additional projections.</li>\n<li>Workaround 2b: Not quite. Recall that Lean lets you define new projections using generalized field notation. The idea here is that you could mark such definitions to be added as new <code>let</code> fields when a structure is being extended.</li>\n</ul>",
        "id": 511836947,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1744485272
    },
    {
        "content": "<p>Any of the workarounds you propose looks good to me (in particular the <code>structure_include_let</code> one, because it means downstream users don't need to understand that something subtle is going on). To be honest, the local introduction of missing instances with <code>letI</code> is also not too painful. The most surprising fact to me was that it used to work, and then is stopped working, but the explanation you give is perfectly convincing.</p>\n<p>In an ideal world, maybe there could be some error message tweaking in this kind of situation, that would explain a little bit to the user what could be going on?</p>",
        "id": 511837081,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1744485369
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"684366\">@Edward van de Meent</span> In your example of</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">fails</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">myClass</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">y</span>\n</code></pre></div>\n<p>the local context before elaborating <code>p</code> would be something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"n\">instLE</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">LE</span><span class=\"w\"> </span><span class=\"n\">X</span>\n<span class=\"n\">instGroup</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">X</span>\n</code></pre></div>",
        "id": 511837087,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1744485375
    },
    {
        "content": "<p>my main question is basically how lean would know what argument is the right one to check for when extending...</p>",
        "id": 511837264,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744485530
    },
    {
        "content": "<p>i guess lean could look at the result type of the instance, and then check which arguments it depends on, then all of those are marked as \"parents to check for\"?</p>",
        "id": 511837337,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744485600
    },
    {
        "content": "<p>so when lean sees an instance like<br>\n<code>(m:myClass) (f: Foo) : Module f.X m.X</code>, lean figures out to only add this let binding to the context when a class extends both <code>myClass</code> and <code>Foo</code>?</p>",
        "id": 511837545,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744485755
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sébastien Gouëzel</span> <a href=\"#narrow/channel/113488-general/topic/new.20structure.20elaboration/near/511837081\">said</a>:</p>\n<blockquote>\n<p>(in particular the <code>structure_include_let</code> one, because it means downstream users don't need to understand that something subtle is going on)</p>\n</blockquote>\n<p>I think this is even the simplest way to implement it, so all the better! (There are a couple complexities to allowing users to write such definitions themselves that I'll have to work through though.)</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sébastien Gouëzel</span> <a href=\"#narrow/channel/113488-general/topic/new.20structure.20elaboration/near/511837081\">said</a>:</p>\n<blockquote>\n<p>In an ideal world, maybe there could be some error message tweaking in this kind of situation, that would explain a little bit to the user what could be going on?</p>\n</blockquote>\n<p>Yeah, though I can't think of much we can do... Maybe if there's an instance synthesis error, if it were possible to make custom errors, we could detect that one of the field local variables is in the class's type and say \"by the way, instances about fields aren't available to child structures, though you might be able to make use of such instances by introducing them with <code>let</code>\". More sophisticated, but less reliably, we could also try to replace field locals with projections of a parent and resynthesizing to figure out exactly which instances are missing.</p>",
        "id": 511837885,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1744486066
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"684366\">@Edward van de Meent</span> I think you're sort of getting ahead of me with the feature idea. I wasn't considering letting these depend on instances defined by other <code>@[structure_include_let]</code> declarations.</p>\n<p>All I had in mind was that such declarations would use a similar mechanism as dot notation. It would look for the argument whose type is the namespace the declaration is within. Notice that <code>instLE</code> is a function in the local context I gave.</p>",
        "id": 511838819,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1744486816
    },
    {
        "content": "<p>right... i personally figured that that would be because the return type doesn't depend on it, so it would be fine to leave that argument unspecified in the let</p>",
        "id": 511838876,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744486898
    },
    {
        "content": "<p>i guess that asking what the implementation is before it is written is sort of backwards</p>",
        "id": 511838942,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744486931
    },
    {
        "content": "<p>Sorry, I don't really know what you mean or what you're imagining <code>@[structure_include_let]</code> would do. What's the significance of dependence in the types?</p>",
        "id": 511839397,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1744487346
    },
    {
        "content": "<p>ehmmmm</p>",
        "id": 511839483,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744487414
    },
    {
        "content": "<p>i guess that doesn't really matter here</p>",
        "id": 511839500,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744487439
    },
    {
        "content": "<p>sorry for my confusing questions</p>",
        "id": 511839522,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744487465
    },
    {
        "content": "<p>Thanks for probing the design. There are still many details I'm not sure about, and it might not be good to make this attribute user-accessible in the end, we'll see.</p>",
        "id": 511840940,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1744488597
    }
]