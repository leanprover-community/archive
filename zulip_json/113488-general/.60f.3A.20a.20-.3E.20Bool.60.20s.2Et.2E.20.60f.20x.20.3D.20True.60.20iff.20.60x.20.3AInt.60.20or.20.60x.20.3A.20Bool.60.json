[
    {
        "content": "<p>Am working on how exactly type-level programming works in Lean. Does there exist a function <code>f : a -&gt;  Bool</code> satisfies <code>f x = True</code> iff <code>x : Int</code> or <code>x : Bool</code>? Am having a hard time refining <code>x</code> into anything without severely constraining what <code>a</code> can be from the very start.</p>",
        "id": 476252462,
        "sender_full_name": "nrs",
        "timestamp": 1728607423
    },
    {
        "content": "<p>\"a function <code>f : a -&gt; Bool</code>\" makes no sense before you define what <code>a</code> is. The best you can do is define <strong>a family of</strong> functions <code>f : a -&gt; Bool</code> <strong>for all <code>a</code></strong>.<br>\nFor example</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"kn\">scoped</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">noncomputable</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">false</span>\n</code></pre></div>",
        "id": 476253237,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1728607863
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/stream/113488-general/topic/.60f.3A.20a.20-.3E.20Bool.60.20s.2Et.2E.20.60f.20x.20.3D.20True.60.20iff.20.60x.20.3AInt.60.20or.20.60x.20.3A.20Bool.60/near/476253237\">said</a>:</p>\n<blockquote>\n<p>\"a function <code>f : a -&gt; Bool</code>\" makes no sense before you define what <code>a</code> is. The best you can do is define <strong>a family of</strong> functions <code>f : a -&gt; Bool</code> <strong>for all <code>a</code></strong>.<br>\nFor example</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"kn\">scoped</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">noncomputable</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">false</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Thank you for the answer! I see, ty for the examle it is very instructive. Is there a way to state more formally what makes this specification satisfiable only by noncomputable functions?</p>",
        "id": 476253571,
        "sender_full_name": "nrs",
        "timestamp": 1728608045
    },
    {
        "content": "<p>I can't state it formally, but in general there is no algorithm to decide whether a <code>T = Int</code>. In fact, in Lean if <code>T</code> has the same cardinallity as <code>Int</code> but isn't intensionally equal to it, then <code>T = Int</code> is both unprovable and undisprovable.</p>",
        "id": 476254449,
        "sender_full_name": "Niels Voss",
        "timestamp": 1728608512
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"521331\">Niels Voss</span> <a href=\"#narrow/stream/113488-general/topic/.60f.3A.20a.20-.3E.20Bool.60.20s.2Et.2E.20.60f.20x.20.3D.20True.60.20iff.20.60x.20.3AInt.60.20or.20.60x.20.3A.20Bool.60/near/476254449\">said</a>:</p>\n<blockquote>\n<p>I can't state it formally, but in general there is no algorithm to decide whether a <code>T = Int</code>. In fact, in Lean if <code>T</code> has the same cardinallity as <code>Int</code> but isn't intensionally equal to it, then <code>T = Int</code> is both unprovable and undisprovable.</p>\n</blockquote>\n<p>Very important fact thank you for the answer, by any chance would you have suggestions about what to look up or read to understand this?</p>",
        "id": 476254621,
        "sender_full_name": "nrs",
        "timestamp": 1728608590
    },
    {
        "content": "<p>I think it might be buried in Zulip chat logs. You can probably do a search for \"Cardinality Model\" if you want to know how this is formally shown.</p>\n<p>By the way, if what you are working on actually requires this to be computable, but you only plan on using explicit types, then you might want to consider using the typeclass system.</p>",
        "id": 476255003,
        "sender_full_name": "Niels Voss",
        "timestamp": 1728608774
    },
    {
        "content": "<p>Or you could use the \"universe pattern\" where you define a scheme for encoding the types you're interested in. For example,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span><span class=\"w\"> </span><span class=\"n\">MyType</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">int</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">bool</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">MyType.T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyType</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">int</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">bool</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Bool</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyType</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">a.T</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Bool</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">int</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">bool</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">false</span>\n</code></pre></div>",
        "id": 476259599,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1728610968
    },
    {
        "content": "<p>Thank you very much for the answers, I'm thinking about how all of this works</p>",
        "id": 476261509,
        "sender_full_name": "nrs",
        "timestamp": 1728611884
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"500038\">Timo Carlin-Burns</span> <a href=\"#narrow/stream/113488-general/topic/.60f.3A.20a.20-.3E.20Bool.60.20s.2Et.2E.20.60f.20x.20.3D.20True.60.20iff.20.60x.20.3AInt.60.20or.20.60x.20.3A.20Bool.60/near/476259599\">said</a>:</p>\n<blockquote>\n<p>Or you could use the \"universe pattern\" where you define a scheme for encoding the types you're interested in. For example,</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span><span class=\"w\"> </span><span class=\"n\">MyType</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">int</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">bool</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">MyType.T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyType</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">int</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">bool</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Bool</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyType</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">a.T</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Bool</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">int</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">bool</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">false</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>in a sense, this is equivalent to designing an interpreter for an AST, right? this pattern sort of reminds me of patterns used in the extensible interpreters literature involving free monads</p>",
        "id": 476292782,
        "sender_full_name": "nrs",
        "timestamp": 1728619621
    },
    {
        "content": "<p>I suppose it's related. If you made <code>MyType</code> more complicated so it contained, for example, product types, then it would be fair to call terms of <code>MyType</code> abstract syntax trees for some grammar of types.</p>",
        "id": 476294931,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1728620359
    },
    {
        "content": "<p>Ty for the reply I will be thinking about your comments</p>",
        "id": 476296845,
        "sender_full_name": "nrs",
        "timestamp": 1728621059
    }
]