[
    {
        "content": "<p>what is <code>[elab_as_elim]</code> attribute? what does this attribute? what is the difference when I add this attribute to something...?</p>",
        "id": 505631084,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1741946399
    },
    {
        "content": "<p>It changes the way the declaration is elaborated. I don't know the technical details but presumably the idea is that with the tag, Lean is more prepared to have a good guess at the type of the motive which the user means, even though this typically means solving a higher-order unification problem.</p>",
        "id": 505633483,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1741947047
    },
    {
        "content": "<p>is there an example ?</p>",
        "id": 505633724,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1741947115
    },
    {
        "content": "<p>Sure, search mathlib for the attribute, then remove it from something and see what breaks.</p>",
        "id": 505633866,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1741947141
    },
    {
        "content": "<p><code>@[elab_as_elim]</code> registers the declaration as an eliminator. Eliminators have special support for filling in the motives automatically with syntactic replacement instead of using second-order unification. By default, <code>.rec</code>, <code>.recOn</code>, <code>.casesOn</code>, <code>.brecOn</code> are all eliminators.</p>",
        "id": 505633961,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741947166
    },
    {
        "content": "<p>Things we want to use as recursors (i.e. stuff we want to use to do induction) is what is being tagged.</p>",
        "id": 505634009,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1741947179
    },
    {
        "content": "<p>Thank you!</p>",
        "id": 505634217,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1741947234
    },
    {
        "content": "<p>In general, <code>@[elab_as_elim]</code> is for declarations whose return type is of the form <code>p x1 x2 ... xn</code>, and during elaboration you want <code>p</code> to be solved for using the expected type. The expressions <code>x1</code> through <code>xn</code> can be arbitrary expressions. To solve for <code>p</code>, <code>xn</code> through <code>x1</code> are replaced by variables in that order; the result is the body for <code>p</code>. (This process can fail, and you may get a \"motive not type correct\" error. That's when the expression for <code>p</code> is ill-typed.) The elaborator will throw an error if there is no expected type.</p>\n<p>There are a couple of other different rules for how these are elaborated. It eagerly elaborates all arguments that appear in <code>x1</code> through <code>xn</code>. These are like \"major premises\", using eliminator terminology. The remaining arguments are \"minor premises\", and and elaboration for those is deferred until after <code>p</code> is computed.</p>\n<p><code>@[elab_as_elim]</code> at this point is only loosely related to eliminators, but every eliminator uses this elaboration procedure.</p>\n<p>This attribute shouldn't be confused with <code>@[induction_eliminator]</code> or <code>@[cases_eliminator]</code>, which are for configuring which induction or cases principle should be used for the <code>induction</code> and <code>cases</code> tactics.</p>",
        "id": 505662738,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741955514
    }
]