[
    {
        "content": "<p>I'd like to coerce decidable propositions to natural numbers, so I could write expressions like in <a href=\"https://en.wikipedia.org/wiki/Iverson_bracket\">https://en.wikipedia.org/wiki/Iverson_bracket</a>.</p>\n<p>I tried to do this naively:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Decidable</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">]:</span><span class=\"w\"> </span><span class=\"n\">Coe</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">decide</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toNat</span>\n</code></pre></div>\n<p>Unfortunately this does not work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">cannot</span><span class=\"w\"> </span><span class=\"n\">find</span><span class=\"w\"> </span><span class=\"n\">synthesization</span><span class=\"w\"> </span><span class=\"n\">order</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"bp\">«</span><span class=\"n\">instCoeNatOfDecidable_external</span><span class=\"o\">:</span><span class=\"n\">file</span><span class=\"o\">:</span><span class=\"bp\">///</span><span class=\"n\">MathlibDemo</span><span class=\"bp\">/</span><span class=\"n\">MathlibDemo</span><span class=\"bp\">.</span><span class=\"n\">lean</span><span class=\"bp\">»</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Decidable</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Coe</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"n\">all</span><span class=\"w\"> </span><span class=\"n\">remaining</span><span class=\"w\"> </span><span class=\"n\">arguments</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">metavariables</span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">Decidable</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">p</span>\n</code></pre></div>\n<p>Is there a way to fix this?</p>",
        "id": 527291224,
        "sender_full_name": "suhr",
        "timestamp": 1751732626
    },
    {
        "content": "<p>Of course I can just define <code>def chi (p : Prop) [h : Decidable p] : Nat := (decide p).toNat</code>, but <code>chi (x &gt; i)</code> is a bit annoying compared to just <code>(x &gt; i)</code>.</p>",
        "id": 527291281,
        "sender_full_name": "suhr",
        "timestamp": 1751732700
    },
    {
        "content": "<p>there's two issues here; the first is that <code>Coe p Nat</code> means \"i can turn any element of <code>p</code> into an element of <code>Nat</code>\". in other words, this will choose a constant function from proofs of <code>p</code> (<em>not</em> the veracity or not of <code>p</code>) to natural numbers. The second is that as the error suggests, since lean won't be able to infer <code>p</code> just from <code>Nat</code>, the synth order has to be the other way, meaning that you want to implement the <code>CoeOut</code> typeclass instead</p>",
        "id": 527291587,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1751733138
    },
    {
        "content": "<p>you might be interested in this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Decidable</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">]:</span><span class=\"w\"> </span><span class=\"n\">CoeDep</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">decide</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toNat</span>\n</code></pre></div>",
        "id": 527291885,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1751733525
    }
]