[
    {
        "content": "<p><a href=\"https://leanprover.github.io/functional_programming_in_lean/functor-applicative-monad/inheritance.html\">Here</a> shows you can emulate hierarchical inheritance modeling using <code>structure B extends A</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Element</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">position</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"bp\">Ã—</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Canvas</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">Element</span>\n</code></pre></div>\n<p>which to my understanding is syntax sugar for composition going on under the hood.</p>\n<p>When practically working with inheritance, we want liskov-substitution to work -- passing a <code>Canvas</code> to functions that expect an <code>Element</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Element</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">()</span>\n\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Canvas</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">c</span>\n<span class=\"c1\">--          ^ error</span>\n<span class=\"c1\">-- application type mismatch f c</span>\n<span class=\"c1\">-- argument c has type Canvas : Type</span>\n<span class=\"c1\">-- but is expected to have type Element : Type</span>\n</code></pre></div>\n<p>Of course the reality in Lean is that <code>c</code> is only a <code>Canvas</code> and not an <code>Element</code>,  but a method to explicitly convert is provided built-in that we can use.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">toElement</span>\n</code></pre></div>\n<p>it works, but is clunky and tedious.</p>\n<p>We can create an implicit coercion to make this feel natural again.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Coe</span><span class=\"w\"> </span><span class=\"n\">Canvas</span><span class=\"w\"> </span><span class=\"n\">Element</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Canvas</span><span class=\"bp\">.</span><span class=\"n\">toElement</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"c1\">-- works</span>\n</code></pre></div>\n<p>The problem is that you must manually create this boilerplate for every scenario like this.</p>\n<p>Since the language already wants to let developers act as if inheritance is a somewhat supported feature with the <code>extends</code> syntax sugar, and since it already set as a precedent for causing certain functionality like <code>.toElement</code> to be included free of any manual labor from developers, I would like to propose that we also provide the <code>instance : Coe Canvas Element where coe := Canvas.toElement</code> declaration to be available implicitly, no manual ceremony beyond writing <code>extends</code>.</p>\n<p>Is this technically feasible to implement? Looking forward to hearing feedback, thanks!</p>",
        "id": 574103938,
        "sender_full_name": "Marvin",
        "timestamp": 1771246740
    },
    {
        "content": "<p>Have you tried this out in practice? For example start writing these instances in Mathlib and tell us how badly it goes. :-)</p>",
        "id": 574130896,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1771254580
    },
    {
        "content": "<p>I'm quite new to the language so I admit I'm not sure how this would interact across all the use cases. Is it just ambiguity and reasoning about code difficulties you're talking about, or maybe implicit look up conflicts in the compiler when multiple instances exist? Why would this go badly? I'm not doubting you, I'd like to learn more so I don't make messes in my own projects.</p>",
        "id": 574153641,
        "sender_full_name": "Marvin",
        "timestamp": 1771261508
    }
]