[
    {
        "content": "<p>In proving theorems I sometimes find I'm trying to prove something with the form:</p>\n<p>(∀ (a b : X ), P a → Q b) → R</p>\n<p>How can I shift the scope of the forall to get?</p>\n<p>(∀ (a b : X ), P a → Q b → R)</p>\n<p>The motivation is that the way the <code>intro</code> tactic works makes it difficult to do certain things to the hypothesis once it's moved out of the main goal. </p>\n<p>e.g., when I use <code>intro h1</code> it gives me:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">h1</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">R</span>\n</code></pre></div>\n<p>So I cannot use <code>intro h1 a b</code> since there are not longer any quantified a b in the goal.</p>\n<p>One concrete example where this has been an issue is when X is a finite type and I want to use the <code>cases</code> tactic to evaluate all possible values for a and b. I can't use <code>cases a b</code> unless I can get <code>a</code> and <code>b</code> as hypotheses.</p>\n<p>This could also be solved if there was a tactic that worked like <code>cases</code> but applied inside the scope of logical connectives.</p>",
        "id": 470859479,
        "sender_full_name": "Avi Craimer",
        "timestamp": 1726546275
    },
    {
        "content": "<p>it might not be true if we want to pull those quantifiers out. <br>\nAssuming X is not empty, the following is true. <br>\n<code>((∀a∀b(Pa→Qb))→R)↔(∃a∃b((Pa→Qb)→R))</code><br>\nsee, <a href=\"https://www.umsu.de/trees/#((~6a~6b(Pa~5Qb))~5R)~4(~7a~7b((Pa~5Qb)~5R))\">https://www.umsu.de/trees/#((~6a~6b(Pa~5Qb))~5R)~4(~7a~7b((Pa~5Qb)~5R))</a></p>",
        "id": 470870051,
        "sender_full_name": "cairunze cairunze",
        "timestamp": 1726549634
    },
    {
        "content": "<p>Those things are definitely not logically equivalent, so Lean will correctly not allow you to do this.</p>",
        "id": 470905035,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1726560731
    },
    {
        "content": "<p>Just to clarify, in the cases I need to use this I definitely could prove it on a case-by-case basis. I just was wondering if there was a tactics-based way of doing this so I don't have to prove a bunch of extra obvious statements.</p>",
        "id": 470979650,
        "sender_full_name": "Avi Craimer",
        "timestamp": 1726579724
    },
    {
        "content": "<p>the theorem is in general false, so there must be something more to the question</p>",
        "id": 471002891,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726584098
    },
    {
        "content": "<p>In practice this problem occurs with universal quantifiers over variables of type PUnit. Since there is only one value for this type a specialization to the single value also proves the universal. I believe this is done with the <code>cases</code> tactic. It works fine if I've got a universal as a complete statement in the main goal, but I can't figure apply the tactic when I have a complex goal such as </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PUnit</span><span class=\"w\"> </span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">R</span>\n</code></pre></div>\n<p>Here I can intro the whole universal into a hypothesis but then I can't apply <code>cases</code> to the hypothesis.</p>\n<p>It may be there is a different tactic I don't know about that solves this.</p>",
        "id": 471003485,
        "sender_full_name": "Avi Craimer",
        "timestamp": 1726584213
    },
    {
        "content": "<p>it's still in general false even without the quantifiers</p>",
        "id": 471003694,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726584252
    },
    {
        "content": "<p>(A -&gt; B) -&gt; C is not the same as A -&gt; (B -&gt; C)</p>",
        "id": 471003791,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726584277
    },
    {
        "content": "<p>That's not what I'm sayin. </p>\n<p>I believe this holds:</p>\n<p><code>(∀ (a b : X ), (P a → Q b)) → R</code></p>\n<p>Iff</p>\n<p><code>(∀ (a b : X ), (P a → Q b) → R)</code></p>\n<p>Assuming R does not contain variables a or b.</p>\n<p>We aren't re-associating inside the body of forall,  just expanding the scope of the quantifier to include R</p>",
        "id": 471004290,
        "sender_full_name": "Avi Craimer",
        "timestamp": 1726584401
    },
    {
        "content": "<p>the parentheses are different than the first time</p>",
        "id": 471005333,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726584604
    },
    {
        "content": "<p>My mistake.</p>",
        "id": 471005441,
        "sender_full_name": "Avi Craimer",
        "timestamp": 1726584625
    },
    {
        "content": "<p>but this is also not true unless <code>X</code> is a singleton type</p>",
        "id": 471005468,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726584631
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  to avoid the XY help-desk issues you mentioned in the context of my other question, I want to clarify that the specific of changing the quantifier scope is less important to solving my problem, than the more general question of how to solve the issue of not being able to apply certain tactics to a hypothesis in the tactics state.</p>",
        "id": 471005583,
        "sender_full_name": "Avi Craimer",
        "timestamp": 1726584658
    },
    {
        "content": "<p>the tactics you can apply to a hypothesis or the goal are based on the valid rules of natural deduction</p>",
        "id": 471005698,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726584691
    },
    {
        "content": "<p>obviously these are different, so it's not always the same operations you can perform</p>",
        "id": 471005842,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726584724
    },
    {
        "content": "<p>Ok, so maybe it would help to make the question hyper-specific. </p>\n<p>Suppose you have: </p>\n<p><code>(∀ (a b : X ), (P a → Q b)) → R</code><br>\nsuch that X has finitely many inhabitants. </p>\n<p>How do I prove <code>(∀ (a b : X ), (P a → Q b))</code> by proving it for every inhabitant. </p>\n<p>Note: I can't use <code>cases</code> since <code>(∀ (a b : X ), (P a → Q b))</code> is not the main goal.</p>",
        "id": 471010577,
        "sender_full_name": "Avi Craimer",
        "timestamp": 1726585848
    },
    {
        "content": "<p>Any time <code>(∀ (a b : X ), (P a → Q b))</code> is false (for example, <code>X = Fin 2</code>, <code>P 0 = True</code>, <code>P 1 = True</code>, <code>Q 0 = True</code>, <code>Q 1 = False</code>), it holds that <code>(∀ (a b : X ), (P a → Q b)) → R</code> is true. So I don't understand why you want to prove <code>(∀ (a b : X ), (P a → Q b))</code>.</p>",
        "id": 471014811,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1726586641
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"346046\">@Avi Craimer</span> this discussion could be the poster child for demonstrating why it's best to ask questions with <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> s. Can you show some fully compiling lean code with a (provable) sorry which you would like to fill in? I think that way it will be possible to understand much better what the actual question is.</p>",
        "id": 471022338,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1726588044
    }
]