[
    {
        "content": "<p>In a lot of math proofs, it's pretty standard and useful technique to introduce an arbitrary variable, argue in terms of that specific variable, then use the fact that it was arbitrary to generalize the argument to an entire set. It's not too hard to do that when the variable is defined in the theorem statement with a \"forall\", but sometimes it's useful to do it in proofs as an intermediate step, where the variable that's introduced wasn't a part of the final proof statement. </p>\n<p>I've figured out that I can use <code>let x : A := Classical.arbitrary x</code> to get an arbitrary x of type A in a proof. Once I do that though, I find it's hard to perform usual operations you would do after introducing arbitrary variables. </p>\n<p>Right now for example, I'm trying to construct a function using a value constructed from an arbitrary variable. As a minimal working example, in the code </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">arbitrary</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">real_value</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I would love to somehow take real_value, which is a real number defined in terms of the arbitrary natural number n, and define a function f which returns the value of real_value for each n. (Obviously I could accomplish this much more simply by defining the function and computing the real_value in terms of the function argument, but this gives an idea for the kind of thing I'm trying to do). </p>\n<p>Is there some way in Lean 4 to construct a function from an arbitrary variable like that? If manipulations like that are impossible, what's the use case for arbitrary variables, and is there some way to introduce and interact with arbitrary values like we do in math proofs?</p>",
        "id": 510841453,
        "sender_full_name": "Strategist _",
        "timestamp": 1744090549
    },
    {
        "content": "<p>I think what you want is <code>let f (n : ℕ) : ℝ := n - 1</code>, or <code>let f : ℕ → ℝ := fun n =&gt; n - 1</code>. It means that \"define a function from ℕ to ℝ which maps n to n - 1\". The <code>Classical.arbitrary ℕ</code> means choose a random element in <code>ℕ</code>. It is not what you want.</p>",
        "id": 510849784,
        "sender_full_name": "Jz Pan",
        "timestamp": 1744094299
    },
    {
        "content": "<p>Or do you mean you want to turn \"for all x, there exists a y\" into a function that maps x to y? In that case, there's the <code>choose</code> tactic</p>",
        "id": 510851974,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1744095201
    },
    {
        "content": "<p>I think we need concrete examples of your “pretty standard and useful technique” to help you. I strongly suspect there are better way to do those proofs, but maybe we’ll still find something useful to say.</p>",
        "id": 510879676,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1744103644
    },
    {
        "content": "<p>We can already point out something that can be very confusing for beginners: Lean is much more suitable for explaining proofs than searching for proofs. What you describe sounds a lot like proof search exploration.</p>",
        "id": 510879851,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1744103696
    },
    {
        "content": "<p>Right: if you want to \"let x be arbitrary\" that is typically because you are in the middle of deciding what you want to do. Once you've decided (e.g. you've decided that it will be helpful that x^2&gt;=0 for x arbitrary) it is that that point that you can write the next line of Lean, which would be <code>have helpful_thing : \\forall x, x^2&gt;=0</code> and then Lean will ask you to prove that too. But you can't write the line of Lean code until you've decided exactly what you're doing with this arbitrary x, i.e. you've gone from the \"search\" phase to the \"explain\" phase.</p>",
        "id": 510883310,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1744104682
    },
    {
        "content": "<p>Well you can write <code>have not_so_helpful_thing (x : Sometype) : True</code> which I do sometimes to explore what I can do.</p>",
        "id": 510884843,
        "sender_full_name": "Christian Merten",
        "timestamp": 1744105073
    },
    {
        "content": "<p>You can also do:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"c1\">-- have: Whatever := whatever</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"o\">()</span>\n</code></pre></div>\n<p>Same idea.</p>",
        "id": 510904556,
        "sender_full_name": "suhr",
        "timestamp": 1744111212
    },
    {
        "content": "<p>As a side note, it sounds like your \"standard technique is\", I think, pretty much a statement of function extensionality -- some statement about functions is true iff it is true when evaluated at an arbitrary <code>x</code>. Where it isn't, it should be instead equivalent to using <code>generalize</code> to replace some subexpression with an arbitrary value.</p>",
        "id": 511025532,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1744146305
    },
    {
        "content": "<p>Yeah that was the \"simpler\" method I was talking about, defining the output in terms of the function argument. That could work for specific situations, but there are other situations where I might want to do something other than define a function using the arbitrary variable. Thanks for the response though!</p>",
        "id": 511027706,
        "sender_full_name": "Strategist _",
        "timestamp": 1744147212
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/channel/113488-general/topic/Introducing.20Arbitrary.20Variables.20in.20Proofs/near/510851974\">said</a>:</p>\n<blockquote>\n<p>Or do you mean you want to turn \"for all x, there exists a y\" into a function that maps x to y? In that case, there's the <code>choose</code> tactic</p>\n</blockquote>\n<p>Sort of that, but I was hoping without an explicit \"for all x, there exists a y\" proposition, just using the arbitrary variable directly. I guess I could use a have statement to prove that type of statement though.</p>",
        "id": 511027983,
        "sender_full_name": "Strategist _",
        "timestamp": 1744147327
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/channel/113488-general/topic/Introducing.20Arbitrary.20Variables.20in.20Proofs/near/510879676\">said</a>:</p>\n<blockquote>\n<p>I think we need concrete examples of your “pretty standard and useful technique” to help you. I strongly suspect there are better way to do those proofs, but maybe we’ll still find something useful to say.</p>\n</blockquote>\n<p>Ok, as one example, in the textbook \"Partial Differential Equations\" by Evans, during a proof of the existence of certain PDEs, they introduce an arbitrary natural number N<br>\n<a href=\"/user_uploads/3121/yBDHfz13ZkmOF0giOnshZaC5/Screenshot-2025-04-08-at-2.23.36PM.png\">Screenshot 2025-04-08 at 2.23.36 PM.png</a>. </p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/yBDHfz13ZkmOF0giOnshZaC5/Screenshot-2025-04-08-at-2.23.36PM.png\" title=\"Screenshot 2025-04-08 at 2.23.36 PM.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1370x1016\" src=\"/user_uploads/thumbnail/3121/yBDHfz13ZkmOF0giOnshZaC5/Screenshot-2025-04-08-at-2.23.36PM.png/840x560.webp\"></a></div><p>They use this to construct a function that depends on that N, and then they use the fact that if you allow N to vary over all natural numbers, the functions constructed form a dense subset of the space of interest. This is the sort of thing I'm after.</p>",
        "id": 511028406,
        "sender_full_name": "Strategist _",
        "timestamp": 1744147533
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/channel/113488-general/topic/Introducing.20Arbitrary.20Variables.20in.20Proofs/near/510879851\">said</a>:</p>\n<blockquote>\n<p>We can already point out something that can be very confusing for beginners: Lean is much more suitable for explaining proofs than searching for proofs. What you describe sounds a lot like proof search exploration.</p>\n</blockquote>\n<p>I'm actually just trying to reproduce some Evans PDE proofs in Lean, so I'm not exactly searching for proofs. It just seems like the proofs in standard math textbooks use a pretty different \"language\" than Lean does. I guess I'm searching for a convenient way to translate proofs, rather than searching for the proofs themselves.</p>",
        "id": 511028764,
        "sender_full_name": "Strategist _",
        "timestamp": 1744147688
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"648495\">Christian Merten</span> <a href=\"#narrow/channel/113488-general/topic/Introducing.20Arbitrary.20Variables.20in.20Proofs/near/510884843\">said</a>:</p>\n<blockquote>\n<p>Well you can write <code>have not_so_helpful_thing (x : Sometype) : True</code> which I do sometimes to explore what I can do.</p>\n</blockquote>\n<p>Sounds interesting. And does that let you treat the x as arbitrary somehow?</p>",
        "id": 511028921,
        "sender_full_name": "Strategist _",
        "timestamp": 1744147768
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"359992\">Robert Maxton</span> <a href=\"#narrow/channel/113488-general/topic/Introducing.20Arbitrary.20Variables.20in.20Proofs/near/511025532\">said</a>:</p>\n<blockquote>\n<p>As a side note, it sounds like your \"standard technique is\", I think, pretty much a statement of function extensionality -- some statement about functions is true iff it is true when evaluated at an arbitrary <code>x</code>. Where it isn't, it should be instead equivalent to using <code>generalize</code> to replace some subexpression with an arbitrary value.</p>\n</blockquote>\n<p>Interesting. I'll have to look into generalize a bit more.</p>",
        "id": 511028973,
        "sender_full_name": "Strategist _",
        "timestamp": 1744147798
    },
    {
        "content": "<p>Thanks for all the comments everyone!</p>",
        "id": 511029034,
        "sender_full_name": "Strategist _",
        "timestamp": 1744147808
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"876071\">Strategist _</span> <a href=\"#narrow/channel/113488-general/topic/Introducing.20Arbitrary.20Variables.20in.20Proofs/near/511028406\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/channel/113488-general/topic/Introducing.20Arbitrary.20Variables.20in.20Proofs/near/510879676\">said</a>:</p>\n<blockquote>\n<p>I think we need concrete examples of your “pretty standard and useful technique” to help you. I strongly suspect there are better way to do those proofs, but maybe we’ll still find something useful to say.</p>\n</blockquote>\n<p>Ok, as one example, in the textbook \"Partial Differential Equations\" by Evans, during a proof of the existence of certain PDEs, they introduce an arbitrary natural number N<br>\n<a href=\"/user_uploads/3121/yBDHfz13ZkmOF0giOnshZaC5/Screenshot-2025-04-08-at-2.23.36PM.png\">Screenshot 2025-04-08 at 2.23.36 PM.png</a>. </p>\n<p>They use this to construct a function that depends on that N, and then they use the fact that if you allow N to vary over all natural numbers, the functions constructed form a dense subset of the space of interest. This is the sort of thing I'm after.</p>\n</blockquote>\n<p>So this is \"have eqn29: \\forall N, \\forall v : (C^1 function), \\forall d : Fin N -&gt; (smooth functions), v = sum_{k=1}^N ... =&gt; \\forall m &gt;= N, integral from 0 to T ... = integral from 0 to T of ... := by intro everything, multiply (16) by d^k, sum and then integrate\" in Lean.</p>",
        "id": 511030778,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1744148622
    },
    {
        "content": "<p>The claim (29) is a new claim which you're pulling out of a hat so this is a <code>have</code> statement, and then everything before (29) in the para is either the statement or the proof of this new claim. Once you have stated eqn29 you start the new proof with <code>by</code> and then after the <code>intro</code> you have the N which you seek.</p>",
        "id": 511031416,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1744148886
    },
    {
        "content": "<p>However rather than having intermediate <code>have</code>s in a proof, you might consider factoring these arguments out as sublemmas which can be proved and named beforehand; Lean would rather have two shorter proofs than one long one, because lean can get sluggish with very long proofs. If you take a look at files in mathlib they are often mostly comprised of many short proofs of easy things rather than a few very long ones and nothing else.</p>",
        "id": 511032121,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1744149201
    },
    {
        "content": "<p>In particular let me stress that in contrast to the way it is written, you cannot be formally \"fixing an integer N\" because if N were fixed (e.g. N=37, that's a fixed integer) then you would not be able to vary it in the argument just before (31). Informally this is the way we write, but what we <em>mean</em> is not \"for an arbitrary fixed N which the reader can choose\", we mean \"for all N\".</p>",
        "id": 511032530,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1744149382
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113488-general/topic/Introducing.20Arbitrary.20Variables.20in.20Proofs/near/511032530\">said</a>:</p>\n<blockquote>\n<p>In particular let me stress that in contrast to the way it is written, you cannot be formally \"fixing an integer N\" because if N were fixed (e.g. N=37, that's a fixed integer) then you would not be able to vary it in the argument just before (31). Informally this is the way we write, but what we <em>mean</em> is not \"for an arbitrary fixed N which the reader can choose\", we mean \"for all N\".</p>\n</blockquote>\n<p>Yeah ok, that makes sense. Thanks. </p>\n<p>Do you know what the actual use case for Classical.arbitrary and Nonempty.some would be then, if not introducing a weird alternate version of a forall statement?</p>",
        "id": 511033592,
        "sender_full_name": "Strategist _",
        "timestamp": 1744149856
    },
    {
        "content": "<p>They can be used to provide junk values when there's no other obvious choice.</p>",
        "id": 511035780,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744150851
    },
    {
        "content": "<p>For example, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Function.invFun#doc\">docs#Function.invFun</a></p>",
        "id": 511036018,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744150933
    },
    {
        "content": "<p>I would actually support changing the name of <code>Classical.arbitrary</code>, especially since it lends itself easily to being used the wrong way by a mathematician who, understandably, would like to transcribe the sentence \"let x be an arbitrary...\" and might reach for <code>let x := Classical.arbitrary ...</code> after searching for \"arbitrary\".</p>\n<p>I think forall free variable introduction (in one way or another) is the nearly-exclusive way mathematicians use the word \"arbitrary\"; I would even go so far as to say that most mathematicians probably do not even usually come in contact with global choice! \"There is a fixed, canonical, globally-chosen element for every type\" is not a thing mathematicians intuitively believe, and while it is \"arbitrarily chosen\" at the foundational level, this isn't really the level at which mathematicians work.</p>",
        "id": 511036993,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1744151423
    },
    {
        "content": "<p>Yeah I'm not sure mathematicians want to use <code>Classical.arbitrary</code>.  This is just a strong version of the axiom of choice. The way lean does the axiom of choice is that it has a function where you feed it a set (or more precisely a type) plus a proof that the set isn't empty and the function returns you an element of that set, and you're unable to prove anything about the element other than the fact that it's in the set. So asking \"when do you use <code>Classical.arbitrary</code> \" is a bit like asking \"when do you use the axiom of choice\".</p>",
        "id": 511041606,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1744154143
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"876071\">Strategist _</span> <a href=\"#narrow/channel/113488-general/topic/Introducing.20Arbitrary.20Variables.20in.20Proofs/near/511028406\">said</a>:</p>\n<blockquote>\n<p>Ok, as one example, in the textbook \"Partial Differential Equations\" by Evans, during a proof of the existence of certain PDEs, they introduce an arbitrary natural number N</p>\n</blockquote>\n<p>That’s another difference between ordinary maths writing and Lean. In Lean you announce what you will prove before proving it. We don’t suddenly start a different story arc without a warning. As Kevin explained, you can use the <code>have</code> tactic or, better, write more lemmas. It is expected that switching to this style takes some time. Something very productive you can do is to formalize this proof and then ask for help to make it idiomatic Lean. This will work if you don’t need to add to much preparatory material. Otherwise choose a different first target.</p>",
        "id": 511120854,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1744190424
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113488-general/topic/Introducing.20Arbitrary.20Variables.20in.20Proofs/near/511120854\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"876071\">Strategist _</span> <a href=\"#narrow/channel/113488-general/topic/Introducing.20Arbitrary.20Variables.20in.20Proofs/near/511028406\">said</a>:</p>\n<blockquote>\n<p>Ok, as one example, in the textbook \"Partial Differential Equations\" by Evans, during a proof of the existence of certain PDEs, they introduce an arbitrary natural number N</p>\n</blockquote>\n<p>That’s another difference between ordinary maths writing and Lean. In Lean you announce what you will prove before proving it. We don’t suddenly start a different story arc without a warning. As Kevin explained, you can use the <code>have</code> tactic or, better, write more lemmas. It is expected that switching to this style takes some time. Something very productive you can do is to formalize this proof and then ask for help to make it idiomatic Lean. This will work if you don’t need to add to much preparatory material. Otherwise choose a different first target.</p>\n</blockquote>\n<p>How _could_ you start a different arc suddenly? Are there affordances for it?</p>",
        "id": 511313297,
        "sender_full_name": "Alok Singh",
        "timestamp": 1744260669
    },
    {
        "content": "<p>You have to announce where your arc is going:</p>\n<p>\"Here is a story about how some dwarves, a wizard and a hobbit go on an adventure to reclaim a treasure from a dragon.\"</p>\n<p>Not:</p>\n<p>\"In a hole in the ground there lived a hobbit.\"</p>\n<p>So I think the key difference is: in Lean you can change arcs, but not \"suddenly\".</p>",
        "id": 511313648,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1744260881
    },
    {
        "content": "<p>\"We <code>have</code> a story about how some dwarves, a wizard and a hobbit go on an adventure to reclaim a treasure from a dragon.\"</p>",
        "id": 511368510,
        "sender_full_name": "Jz Pan",
        "timestamp": 1744280382
    }
]