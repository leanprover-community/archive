[
    {
        "content": "<p>How would I define this function without using <code>partial</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">T</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">T</span>\n\n<span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">T.size</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">cs</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">cs.foldl</span> <span class=\"o\">(</span><span class=\"n\">init</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"n\">c</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">c.size</span>\n</code></pre></div>\n<p>My best bet would be to assume we have a <code>Array.attach</code> like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.attach#doc\">docs#List.attach</a> and do something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">T</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">T</span>\n\n<span class=\"n\">opaque</span> <span class=\"n\">Array.attach</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span>  <span class=\"bp\">→</span> <span class=\"n\">Array</span> <span class=\"o\">({</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">a.data</span> <span class=\"o\">})</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">T.size</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">cs</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">cs.attach.foldl</span> <span class=\"o\">(</span><span class=\"n\">init</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"o\">⟨</span><span class=\"n\">c</span><span class=\"o\">,</span><span class=\"n\">hc</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">c.size</span>\n<span class=\"n\">termination_by</span> <span class=\"n\">_</span> <span class=\"n\">t</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">sizeOf</span> <span class=\"n\">t</span>\n</code></pre></div>\n<p>(which doesn’t work yet but I believe I could make it work) but I wonder if there is a better direction.</p>",
        "id": 398695746,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1698328894
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 398717749,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1698335038
    },
    {
        "content": "<p>Here is a way that seems to work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">T</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">T</span>\n\n<span class=\"n\">opaque</span> <span class=\"n\">Array.attach</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span>  <span class=\"bp\">→</span> <span class=\"n\">Array</span> <span class=\"o\">({</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">a.data</span> <span class=\"o\">})</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">Array.sizeOf_eq</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">SizeOf</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">cs</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">sizeOf</span> <span class=\"n\">cs</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">sizeOf</span> <span class=\"n\">cs.data</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">T.size</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">cs</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">cs.attach.foldl</span> <span class=\"o\">(</span><span class=\"n\">init</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"o\">⟨</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">_hc</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">c.size</span>\n<span class=\"n\">termination_by</span> <span class=\"n\">_</span> <span class=\"n\">t</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">sizeOf</span> <span class=\"n\">t</span>\n</code></pre></div>\n<p>Do I really have to tell Lean to unfold <code>sizeOf</code> here?</p>",
        "id": 398721164,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1698336150
    },
    {
        "content": "<p>Ah, looks like there is setup for such recursion in <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Data/Array/Mem.html\">https://leanprover-community.github.io/mathlib4_docs/Init/Data/Array/Mem.html</a>, but it (needlessly) requires decidable equality on the elements, and I can’t quite get <code>Array.sizeOf_lt_of_mem</code> to work here.</p>",
        "id": 398754440,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1698348767
    },
    {
        "content": "<p>This works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">T</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">T</span>\n\n<span class=\"n\">opaque</span> <span class=\"n\">Array.attach</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">α</span><span class=\"o\">]:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Array</span> <span class=\"o\">({</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">a</span> <span class=\"o\">})</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">DecidableEq</span> <span class=\"n\">T</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"n\">macro</span> <span class=\"s2\">\"array_mem_dec\"</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">first</span>\n    <span class=\"bp\">|</span> <span class=\"n\">apply</span> <span class=\"n\">Array.sizeOf_lt_of_mem</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span><span class=\"bp\">;</span> <span class=\"n\">done</span>\n    <span class=\"bp\">|</span> <span class=\"n\">apply</span> <span class=\"n\">Nat.lt_trans</span> <span class=\"o\">(</span><span class=\"n\">Array.sizeOf_lt_of_mem</span> <span class=\"bp\">?</span><span class=\"n\">h</span><span class=\"o\">)</span>\n      <span class=\"n\">case'</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">assumption</span>\n      <span class=\"n\">simp_arith</span><span class=\"o\">)</span>\n\n<span class=\"n\">macro_rules</span> <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">decreasing_trivial</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">array_mem_dec</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">T.size</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">cs</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">cs.attach.foldl</span> <span class=\"o\">(</span><span class=\"n\">init</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"o\">⟨</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">_hc</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">c.size</span>\n</code></pre></div>\n<p>Is the setup in <code>Init.Data.Array.Mem</code> incomplete? It defines <code>Array.sizeOf_lt_of_mem</code>, but doesn’t register it with <code>decreasing_trivial</code> in the same way that <code>List.sizeOf_lt_of_mem</code> is set up. Maybe a simple omission because nobody complained loudly enough yet. If that’s the case, then &lt;<a href=\"https://github.com/leanprover/lean4/pull/2774\">https://github.com/leanprover/lean4/pull/2774</a>&gt; should improve matters. If and once that tickles through to <code>std4</code> I can also add <code>Array.attach</code> there.</p>",
        "id": 398755055,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1698349050
    }
]