[
    {
        "content": "<p>I am planning to teach Lean, so I tried to dig deeper to a few topics, one of them is typeclass search. Originally, I thought that it does search similar to logical-programming (like prolog), but it seems that it never can have the full strength of prolog because it needs to know the direction of information flow given by <code>outParam</code>, correct?<br>\nI tried the following implemention of a sum using a logical program:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">PrologSum</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">reason</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PrologSum</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">reason</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">s!</span><span class=\"s2\">\"base {a}\"</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PrologSum</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PrologSum</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">reason</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">s!</span><span class=\"s2\">\"{h.reason}, update {a} {b}+1 {c}+1\"</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">EvalPrologSum</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"w\">  </span><span class=\"n\">reason</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PrologSum</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">EvalPrologSum</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">c</span>\n<span class=\"w\">  </span><span class=\"n\">reason</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">reason</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">EvalPrologDiff</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"w\">  </span><span class=\"n\">reason</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PrologSum</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">EvalPrologDiff</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"w\">  </span><span class=\"n\">reason</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">reason</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">inferInstance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PrologSum</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">)</span><span class=\"w\">    </span><span class=\"c1\">-- A</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">inferInstance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">EvalPrologSum</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"c1\">-- B</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">inferInstance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">EvalPrologDiff</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- C</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PrologSum</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">()</span><span class=\"w\"> </span><span class=\"c1\">-- D</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PrologSum</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">()</span><span class=\"w\"> </span><span class=\"c1\">-- E</span>\n</code></pre></div>\n<p>Then I looked at which examples succeed, and which fail based on the type annotation for variables <code>b</code> &amp; <code>c</code>, and I got a bit confused.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">A</span><span class=\"w\">        </span><span class=\"n\">B</span><span class=\"w\">        </span><span class=\"n\">C</span><span class=\"w\">        </span><span class=\"n\">D</span><span class=\"w\">        </span><span class=\"n\">E</span>\n<span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\">    </span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\">    </span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"w\">    </span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\">    </span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"bp\">.</span>\n<span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\">    </span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\">    </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\">    </span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\">    </span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"bp\">.</span>\n<span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"w\">    </span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\">    </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\">    </span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"w\">    </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">.</span>\n\n<span class=\"bp\">`*`</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Success</span>\n<span class=\"bp\">`.`</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Fail</span>\n<span class=\"n\">Row</span><span class=\"w\">    </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"n\">semiOutParam</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"n\">Column</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"n\">semiOutParam</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"bp\">-/</span>\n</code></pre></div>\n<p>When both <code>b</code>, <code>c</code> are <code>outParams</code>, why does case A fail (I thought it is the most basic one), while both B, C succeed? Also, I was a bit surprised that D is so much harder than B (and analogously E than C), why? Is there another one-liner that could emulate B without having to build a new typeclass?</p>",
        "id": 547268950,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1761569570
    },
    {
        "content": "<p>The best way to see how Lean chooses to look for instances is by enabling <code>set_option trace.Meta.synthInstance true</code> (and sometimes also <code>set_option trace.Meta.isDefEq true</code> if you want to know why an instance fails to apply). For example, for case A we see:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">synthInstance</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">❌️</span><span class=\"w\"> </span><span class=\"n\">PrologSum</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"bp\">▼</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">new</span><span class=\"w\"> </span><span class=\"n\">goal</span><span class=\"w\"> </span><span class=\"n\">PrologSum</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">tc</span><span class=\"bp\">.</span><span class=\"m\">0</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">tc</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">▶</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">✅️</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">instPrologSumOfNatNat</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">PrologSum</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">▼</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">tryResolve</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">✅️</span><span class=\"w\"> </span><span class=\"n\">PrologSum</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">≟</span><span class=\"w\"> </span><span class=\"n\">PrologSum</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">answer</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">✅️</span><span class=\"w\"> </span><span class=\"n\">PrologSum</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">❌️</span><span class=\"w\"> </span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">        </span><span class=\"n\">PrologSum</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n<span class=\"w\">      </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">definitionally</span><span class=\"w\"> </span><span class=\"n\">equal</span><span class=\"w\"> </span><span class=\"n\">to</span>\n<span class=\"w\">        </span><span class=\"n\">PrologSum</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"mi\">4</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"n\">not</span><span class=\"bp\">-</span><span class=\"n\">available</span><span class=\"bp\">&gt;</span>\n</code></pre></div>\n<p>In words: instance search is called with a goal of type <code>PrologSum 2 2 4</code>. It immediately turns the outParams into metavariables: <code>_tc.0</code> and <code>_tc.1</code> and finds a solution for the problem of the form <code>PrologSum 2 _ _</code>, namely <code>2 + 0 = 2</code>. Then it checks that this matches the goal, and errors.</p>\n<p>This is how it works for any <code>outParam</code>: any concrete values are first erased and replaced with metavariables, and then the resulting type will be checked. The reason, as I understand it, that Lean is implemented this way is to make instance synthesis and unification independent from each other. If a suble change in elaboration means that unification assigns slightly different values, we want the instance search algorithm to still work the same and not start returning different answers. (There is a similar phenomenon where an instance can already be (partially) found through unification, but this partial answer is not taken into account when synthesizing the new one: it's only checked when synthesis is complete.</p>\n<p><code>semiOutParam</code>s, like <code>outParam</code>s, include a promise that after a successful instance synthesis, they will be metavariable-free. Unlike <code>outParam</code>s, however, they can already be assigned at the start of instance search. They will, as a result, not assign metavariables created outside of the context of the instance search. (Which is why D fails for <code>semiOutParam</code>s.)</p>\n<p>From a user's perspective, the rule for <code>outParam</code>s is that there should be only one solution for any goal, no matter which assignments to (semi)<code>outParam</code>s are made.</p>",
        "id": 547283332,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1761573473
    },
    {
        "content": "<p>Thanks! I think it makes sense. The (semi)OutParam is needed to enable prolog-like search with open metavariables, but both options have some difficulties in interacting with the external query. <code>outParam</code> ignores the input, and <code>semiOutParam</code> disallows assigning external metavariables.</p>",
        "id": 547599723,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1761690885
    },
    {
        "content": "<p>But now, I got confused by another example, what is so special about <code>2+2</code> in the following example (term reduction)? I tried to enable <code>trace.Meta.isDefEq</code> but I am unsure which line is responsible for it.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">myClass</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">cinst1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">myClass</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">⟩</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">cinst2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">myClass</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">⟩</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">cinst3</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">myClass</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">⟩</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">cinst4</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">myClass</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"bp\">⟩</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">cinst5</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">myClass</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">synthInstance</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">isDefEq</span><span class=\"w\"> </span><span class=\"n\">true</span>\n\n<span class=\"bp\">#</span><span class=\"n\">instances</span><span class=\"w\"> </span><span class=\"n\">myClass</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">4</span><span class=\"o\">)</span><span class=\"w\">    </span><span class=\"c1\">-- 1, 2</span>\n<span class=\"bp\">#</span><span class=\"n\">instances</span><span class=\"w\"> </span><span class=\"n\">myClass</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"c1\">-- 2</span>\n<span class=\"bp\">#</span><span class=\"n\">instances</span><span class=\"w\"> </span><span class=\"n\">myClass</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"c1\">-- 3, 2</span>\n<span class=\"bp\">#</span><span class=\"n\">instances</span><span class=\"w\"> </span><span class=\"n\">myClass</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"c1\">-- 4, 2</span>\n<span class=\"bp\">#</span><span class=\"n\">instances</span><span class=\"w\"> </span><span class=\"n\">myClass</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- 5, 2</span>\n</code></pre></div>",
        "id": 547600090,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1761691126
    },
    {
        "content": "<p>It's the first one that got tried?</p>",
        "id": 547602958,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761692781
    },
    {
        "content": "<p>I wouldn't say so. If I comment out the line with <code>2+2</code> instance, every expression is only matched with itself.</p>",
        "id": 547603348,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1761693049
    },
    {
        "content": "<p>check the discr tree keys</p>",
        "id": 547604241,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761693665
    },
    {
        "content": "<p>one of these is not like the others</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">myClass</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">cinst1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">myClass</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">⟩</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">cinst2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">myClass</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">⟩</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">cinst3</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">myClass</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">⟩</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">cinst4</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">myClass</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"bp\">⟩</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">cinst5</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">myClass</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"bp\">⟩</span>\n\n<span class=\"bp\">#</span><span class=\"n\">discr_tree_key</span><span class=\"w\"> </span><span class=\"n\">cinst1</span>\n<span class=\"bp\">#</span><span class=\"n\">discr_tree_key</span><span class=\"w\"> </span><span class=\"n\">cinst2</span>\n<span class=\"bp\">#</span><span class=\"n\">discr_tree_key</span><span class=\"w\"> </span><span class=\"n\">cinst3</span>\n<span class=\"bp\">#</span><span class=\"n\">discr_tree_key</span><span class=\"w\"> </span><span class=\"n\">cinst4</span>\n<span class=\"bp\">#</span><span class=\"n\">discr_tree_key</span><span class=\"w\"> </span><span class=\"n\">cinst5</span>\n</code></pre></div>",
        "id": 547604442,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761693842
    },
    {
        "content": "<p>That actually makes sense as a reason why it behaves that way.</p>",
        "id": 547604524,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1761693914
    },
    {
        "content": "<p>But not really why (2+2) gets translated into a joker</p>",
        "id": 547604595,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1761693966
    },
    {
        "content": "<p>It might not be worth it digging much deeper but it is a peculiar curiosity <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span> .</p>",
        "id": 547604831,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1761694151
    },
    {
        "content": "<p>Offsets (e.g. <code>Nat.succ x</code>, <code>x + n</code>) are jokers to e.g. allow</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">instNeZeroSucc</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NeZero</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">succ_ne_zero</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">⟩</span>\n</code></pre></div>\n<p>to match <code>NeZero 4</code></p>",
        "id": 547649633,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1761725314
    },
    {
        "content": "<p>So the conclusion is: when we want to match a natural number using definitional equality, and not exact structure, add <code>+0</code> <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 547667297,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1761730553
    },
    {
        "content": "<p>It seems that the <code>#instances</code> command doesn't actually do the required unification, because instance search isn't allowed to unfold definitions such as <code>id</code>. (but the standard operations on <code>Nat</code> are treated specially, so they are an exception to this rule)</p>",
        "id": 547678519,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1761733486
    },
    {
        "content": "<p>Type class search operates in the <code>reducible_and_instances</code> transparency, which means that instances and definitions marked <code>@[reducible]</code> will be unfolded.</p>",
        "id": 547678955,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1761733612
    },
    {
        "content": "<p>Do you know if proper logical programming is possible through typeclass inference? I know it is not the intention but as an exercise, I tried to write a basic intuistionistic solver through it but the search still feels too much out of my control. I am not sure how to make forced moves (like Prolog's cuts) such as \"If you see it is an implictaion, always intro, and do not try anything else\", or more importantly, \"If the assumption is already present in the context, do not add it.\" I thought that a combination of <code>outParam</code>s and <code>priority</code>s could it, it works in basic examples but in a more complex setup, it breaks, and is hard to follow.<br>\n<a href=\"/user_uploads/3121/8UJ14uepFnwSrMlZ6IA5eh3m/IntuSolve.lean\">IntuSolve.lean</a></p>",
        "id": 548111831,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1761903019
    },
    {
        "content": "<p>You probably don't want to use <code>Prop</code> directly because matching on <code>Prop</code> is flaky. It's better to define a prop-like inductive type and evaluate into <code>Prop</code> when you need it.</p>",
        "id": 548126854,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1761907946
    },
    {
        "content": "<p>I am a bit hesitant to write it with a custom inductive, then the hard problem will be even more unreadable (so I will be unsure if I made a mistake)... And the matching seems working to me, only that sometimes I get multiple equal assumptions, and I don't understand how (maybe it decided to backtrack?)...</p>",
        "id": 548158259,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1761917665
    },
    {
        "content": "<p>Why exactly is it flaky?</p>",
        "id": 548158910,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1761917826
    },
    {
        "content": "<p>Maybe <span class=\"user-mention\" data-user-id=\"119741\">@François G. Dorais</span> means that unifying proofs is flaky, because unification might decide to not assign metavariables, and use proof irrelevance instead. But unifying propositions is fine.</p>",
        "id": 548163885,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1761919179
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek Olšák</span> <a href=\"#narrow/channel/113488-general/topic/Understanding.20typeclass.20search.20.26.20outParams/near/548111831\">said</a>:</p>\n<blockquote>\n<p>Do you know if proper logical programming is possible through typeclass inference? I know it is not the intention but as an exercise, I tried to write a basic intuistionistic solver through it but the search still feels too much out of my control. I am not sure how to make forced moves (like Prolog's cuts) such as \"If you see it is an implictaion, always intro, and do not try anything else\", or more importantly, \"If the assumption is already present in the context, do not add it.\" I thought that a combination of <code>outParam</code>s and <code>priority</code>s could it, it works in basic examples but in a more complex setup, it breaks, and is hard to follow.<br>\n<a href=\"/user_uploads/3121/8UJ14uepFnwSrMlZ6IA5eh3m/IntuSolve.lean\">IntuSolve.lean</a></p>\n</blockquote>\n<p>Note that the typeclass system is not designed for this. For example, it will only use a hypothesis if it appears in the goal, since it only discovers them by unification.</p>",
        "id": 548188054,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761924696
    },
    {
        "content": "<p>see also the docstring for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fact#doc\">docs#Fact</a></p>",
        "id": 548188159,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761924722
    },
    {
        "content": "<p>I know, I know,<br>\n<span class=\"user-mention silent\" data-user-id=\"133339\">Mirek Olšák</span> <a href=\"#narrow/channel/113488-general/topic/Understanding.20typeclass.20search.20.26.20outParams/near/548111831\">said</a>:</p>\n<blockquote>\n<p>I know it is not the intention but</p>\n</blockquote>",
        "id": 548189899,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1761925160
    },
    {
        "content": "<p>I do not intend it as a lean automation, rather a toy solver in a similar way as one could try to write a sokoban solver, or anything similar.</p>",
        "id": 548194385,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1761926299
    },
    {
        "content": "<p>I also tried <code>@[default_instance]</code> but that doesn't seem to have any effect -- Lean is always happy to build <code>a ∧ a</code> with <code>AddToAnd.combine a a : AddToAnd a a (a ∧ a)</code></p>",
        "id": 548198453,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1761927473
    },
    {
        "content": "<p>what are you trying to do</p>",
        "id": 548210759,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761931235
    },
    {
        "content": "<p>what's the problem here</p>",
        "id": 548210771,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761931239
    },
    {
        "content": "<p>I tried to write a logical program that operates on \"states\" of the form <code>(Ctx Goal : Prop)</code>, where <code>Ctx</code> is a conjunction of assumptions, and <code>Goal</code> is the current <code>Goal</code>. I want to ensure that I never get repeated assumption in <code>Ctx</code>, so I implemented <code>AddToAnd</code> which should skip the double assumption. However, this skipping is not reliable, when I look at the trace of the last problem, I eventually get <code>✅️ apply AddToAnd.combine to AddToAnd a a (a ∧ a)</code> which I was trying to avoid.</p>",
        "id": 548218875,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1761934116
    },
    {
        "content": "<p>Do you really really want to use typeclass for this?</p>",
        "id": 548222613,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761935551
    },
    {
        "content": "<p>Yes, but if you say it is not possible, ok. I was curious how typeclasses &amp; logical programming relate.</p>",
        "id": 548223916,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1761936023
    },
    {
        "content": "<p>Is it really that uncommon in typeclass practice that you want to prevent usage of a certain rule with a certain pattern?</p>",
        "id": 548224274,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1761936169
    },
    {
        "content": "<p>But answer \"You cannot implement prolog-like cuts with typeclasses.\" is a knowledge I am happy with.</p>",
        "id": 548224842,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1761936400
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek Olšák</span> <a href=\"#narrow/channel/113488-general/topic/Understanding.20typeclass.20search.20.26.20outParams/near/548224274\">said</a>:</p>\n<blockquote>\n<p>Is it really that uncommon in typeclass practice that you want to prevent usage of a certain rule with a certain pattern?</p>\n</blockquote>\n<p>I have never come across such a situation before</p>",
        "id": 548226272,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761936945
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek Olšák</span> <a href=\"#narrow/channel/113488-general/topic/Understanding.20typeclass.20search.20.26.20outParams/near/548224842\">said</a>:</p>\n<blockquote>\n<p>But answer \"You cannot implement prolog-like cuts with typeclasses.\" is a knowledge I am happy with.</p>\n</blockquote>\n<p>That is correct: there are no prolog-like cuts with type classes in Lean. However, Lean type classes also don't do <em>linear</em> resolution in the strict sense. So cuts wouldn't necessarily work as expected from the prolog point of view.</p>",
        "id": 548244763,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1761944231
    }
]