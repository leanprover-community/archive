[
    {
        "content": "<p>I know that bracketing can be tricky. For <code>let</code>,  my working hypotehsis was that <code>let h : α := ...</code> and <code>let (h : α) := ...</code> are the same, but apparently this is not the case. Here is a MWE:</p>\n<p>Here, <code>rfl</code> gives an error, saying that <code>q</code> is not definitionally equal to <code>1</code>...</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>...while everything works fine without the brackets...</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Can someone explain to my why that is?</p>",
        "id": 508750181,
        "sender_full_name": "Peter Pfaffelhuber",
        "timestamp": 1743167046
    },
    {
        "content": "<p>no, the syntax of let/have is like <code>have (name)? (binders)? (: type)? := value</code>, and the <code>name</code> cannot be in parentheses, so when you put parentheses it gets interpreted as a binder. <code>have (x : A) := x</code> is a definition of the identity function named <code>this</code></p>",
        "id": 508750638,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743167171
    },
    {
        "content": "<p>for <code>let</code> it's slightly more complicated because <code>let</code> doesn't allow the name to be optional (not exactly sure why, it may be on some stage of being changed to be more like <code>have</code>). So it is probably just a syntax error to do <code>let (q : ℕ) := 1</code>?</p>",
        "id": 508750857,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743167235
    },
    {
        "content": "<p>ah, looks like the syntax unification has already happened, <code>let</code> acts the same as <code>have</code>. So <code>let (q : ℕ) := 1</code> is equivalent to <code>let this (q : ℕ) := 1</code> or <code>let this := fun (q : ℕ) =&gt; 1</code>, it declares a constant function</p>",
        "id": 508751461,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743167407
    },
    {
        "content": "<p>that doesn't seem to be the case, looking at the tactic state after the let?</p>",
        "id": 508751997,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1743167567
    },
    {
        "content": "<p>Ok, I understand this, thanks. However, when I use <code>let (q : ℕ) := 1</code>, the infoveiw in the next line tells me that <code>q : ℕ</code>, so it is not a function. (When I use  <code>let q : ℕ := 1</code>, the proof state tells me <code>q : ℕ := 1</code>.)</p>",
        "id": 508752353,
        "sender_full_name": "Peter Pfaffelhuber",
        "timestamp": 1743167675
    },
    {
        "content": "<p>in particular, the effect seems more like <code>refine (fun q =&gt; ?a) (1:Nat)</code></p>",
        "id": 508752417,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1743167694
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/channel/113488-general/topic/Question.20on.20.60let.60/near/508752417\">schrieb</a>:</p>\n<blockquote>\n<p>in particular, the effect seems more like <code>refine (fun q =&gt; ?a) (1:Nat)</code></p>\n</blockquote>\n<p>That`s right, the proof state looks exactly the same...</p>",
        "id": 508752808,
        "sender_full_name": "Peter Pfaffelhuber",
        "timestamp": 1743167815
    },
    {
        "content": "<p>that seems like a bug then?</p>",
        "id": 508754934,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743168486
    },
    {
        "content": "<p>for <code>have</code> it produces a function, and I think we definitely don't want divergence between them</p>",
        "id": 508755021,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743168521
    },
    {
        "content": "<p>I was wrong, the <code>let this</code> PR has not merged yet. This isn't a parse error, it's interpreted as a pattern matching <code>let</code></p>",
        "id": 508755565,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743168670
    },
    {
        "content": "<p>but the pattern expression is just a type ascription</p>",
        "id": 508755806,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743168726
    },
    {
        "content": "<p>so it ends up equivalent to <code>have ((q : Nat)) := 1</code></p>",
        "id": 508755984,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743168787
    },
    {
        "content": "<p>I lied earlier, the syntax of have is not just <code>have (name)? (binders)* (: type)? := value</code>, there is a second form which is <code>have (pattern) (: type)? := value</code>, with no binders and no name allowed</p>",
        "id": 508756237,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743168859
    },
    {
        "content": "<p>and <code>(pattern)</code> here is just <code>term</code>, it accepts any term and rejects anything that doesn't resolve to some constructor expression (more or less)</p>",
        "id": 508756344,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743168892
    },
    {
        "content": "<p>but type ascriptions are allowed in patterns</p>",
        "id": 508756411,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743168915
    },
    {
        "content": "<p>and <code>let (pattern) := value</code> is identical to <code>have (pattern) := value</code>, i.e. it doesn't actually produce a let binding</p>",
        "id": 508756532,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743168952
    },
    {
        "content": "<p>ah right, like how in do-notation you can write <code>let .some a := [0,2].get? 2</code></p>",
        "id": 508759532,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1743169746
    },
    {
        "content": "<p>that makes more sense</p>",
        "id": 508759552,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1743169752
    },
    {
        "content": "<p>yes, or <code>let (x, y) := (1, 2)</code></p>",
        "id": 508759616,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743169775
    },
    {
        "content": "<p>which does not produce let bindings even though people might hope for it</p>",
        "id": 508759695,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743169798
    }
]