[
    {
        "content": "<p>I feel like the aspect of Lean as a general-purpose programming language is often neglected, hence this topic. Basically <a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/channel/113488-general/topic/dreams.20of.20big.20projects/with/564815192\">#general &gt; dreams of big projects</a>, but focused on the programming side instead of proof-assistant side in Lean, perhaps doing it dependently while we're at it.</p>",
        "id": 565385256,
        "sender_full_name": "Gavin Zhao",
        "timestamp": 1766687031
    },
    {
        "content": "<p>The ability to send HTTP requests is a must. From my observation, people are mostly shelling out to <code>curl</code> or similar command-line tools. <span class=\"user-mention\" data-user-id=\"481858\">@Sofia Rodrigues</span> has a <code>Std.HTTP</code> client implementation at <a href=\"https://github.com/leanprover/lean4/pull/10478\">https://github.com/leanprover/lean4/pull/10478</a></p>",
        "id": 565385507,
        "sender_full_name": "Gavin Zhao",
        "timestamp": 1766687414
    },
    {
        "content": "<p>However I don't think that enables sending HTTPS requests. To do that purely in Lean, someone has to either:</p>\n<ul>\n<li>Write bindings to OpenSSL/MbedTLS/similar libraries to handle the encryption.</li>\n<li>Write a pure Lean implementation of such encryption.</li>\n</ul>",
        "id": 565385544,
        "sender_full_name": "Gavin Zhao",
        "timestamp": 1766687494
    },
    {
        "content": "<p>I recall seeing in multiple topics that there's demand for tools to automatically generate Lean bindings from C headers, so projects similar to <a href=\"https://github.com/mozilla/cbindgen\">cbindgen</a> are likely wanted. One problem is that the Lean FFI seems to be still unstable, but if it's automated then probably changes to the FFI would not be that of a pain?</p>",
        "id": 565385607,
        "sender_full_name": "Gavin Zhao",
        "timestamp": 1766687631
    },
    {
        "content": "<blockquote>\n<p>Write a pure Lean implementation of such encryption.</p>\n</blockquote>\n<p>Please do not do this with the intent of having it being used as a real world library. Lean is not a good language to implement side channel proof crypto libraries in. If you really want to do it from within Lean it should be done from a DSL within Lean that directly generates C code (or similar).</p>\n<p>Even though OpenSSL is well known for it's absolutely awful API it has a lot of things figured out correctly internally and we should not try to replicate them unless we have a good reason and people that actually know what they are doing in the space.</p>",
        "id": 565385692,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1766687769
    },
    {
        "content": "<p>One important thing to keep in mind with the OpenSSL FFI is that you likely do not want the Lean library to ship its own OpenSSL dynamic library but to be able to link against the system library. This is so vendors can easily roll out bug fixes when they happen without having to touch every piece of software on their system. This poses an interesting challenge for FFI applications because suddenly linking against just one specific version of a header is not enough anymore, you actually need to be able to link against several different versions of the same library.</p>\n<p>For this reason the lowest level crate in Rust that provides the direct FFI layer <a href=\"https://github.com/rust-openssl/rust-openssl/tree/master/openssl-sys\">openssl-sys</a> is in fact mostly hand written with a ton of configuration operations and ifdefs sprinkled throughout it. So while a first shot at an OpenSSL FFI could indeed be auto generated using something like bindgen in Lean, if we want it to stick to this principle of linking against the OpenSSL version your user wants instead of against the version you think is correct, a lot of it will have to be hand written.</p>\n<p>That said I think a version of cbindgen could still be useful for linking against other C libraries regardless,</p>",
        "id": 565385978,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1766688342
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/channel/113488-general/topic/Lean.20project.20ideas.20for.20general-purpose.20programming/near/565385692\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>Write a pure Lean implementation of such encryption.</p>\n</blockquote>\n<p>Please do not do this with the intent of having it being used as a real world library. Lean is not a good language to implement side channel proof crypto libraries in. If you really want to do it from within Lean it should be done from a DSL within Lean that directly generates C code (or similar).</p>\n<p>Even though OpenSSL is well known for it's absolutely awful API it has a lot of things figured out correctly internally and we should not try to replicate them unless we have a good reason and people that actually know what they are doing in the space.</p>\n</blockquote>\n<p>FWIW the general state of language support for side-channel proof crypto is pretty bad (for example LLVM still has no support for semantically “secret” values and will sometimes insert branches even in seemingly branchless code. Trying to prevent it from doing this is a constant battle and the terrain can change under you at any time. At this point there’s really no substitute for freezing the compiler, putting all your sensitive code in inline(never) functions and checking the assembly output). And of course this is without even considering hardware. </p>\n<p>(Here’s a really great paper on the subject <a href=\"https://eprint.iacr.org/2025/435.pdf\">https://eprint.iacr.org/2025/435.pdf</a>).</p>\n<p>Im not contradicting you really to be clear, just pointing out that this stuff is really complicated even without anything Lean-specific</p>",
        "id": 565393228,
        "sender_full_name": "cmlsharp",
        "timestamp": 1766700438
    },
    {
        "content": "<p>I'm aware of the research surrounding this topic yes^^ I just think we should not try to play in this field unless we actually have people that have the skills to do it.</p>",
        "id": 565396324,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1766706919
    },
    {
        "content": "<p>Or maybe we just rebuild perlasm in Lean <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 565396358,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1766707018
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"766285\">Gavin Zhao</span> <a href=\"#narrow/channel/113488-general/topic/Lean.20project.20ideas.20for.20general-purpose.20programming/near/565385544\">said</a>:</p>\n<blockquote>\n<p>However I don't think that enables sending HTTPS requests. To do that purely in Lean, someone has to either:</p>\n<ul>\n<li>Write bindings to OpenSSL/MbedTLS/similar libraries to handle the encryption.</li>\n<li>Write a pure Lean implementation of such encryption.</li>\n</ul>\n</blockquote>\n<p>There's <a href=\"https://github.com/bergmannjg/leanCurl\">leanCurl</a> which I've successfully used for HTTPS in a few small programs such as <a href=\"https://git.unnamed.website/everything.nix/tree/CheckCache.lean\">this one</a>.</p>",
        "id": 565407645,
        "sender_full_name": "Anthony Wang",
        "timestamp": 1766723809
    },
    {
        "content": "<p>i'm working on OpenSSL bindings for lean. i've done many in my carrier for other languages. <br>\nI'll give some updates when i can share some results. I'll support system library bindings, but unlike Rust bindings, i'll support bindings starting from version 3 and onwards. So not so much crazy <code>if</code> version checking in the library bindings internals.</p>",
        "id": 565444885,
        "sender_full_name": "Alfredo Moreira-Rosa",
        "timestamp": 1766757234
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"481858\">@Sofia Rodrigues</span> is also planning to work on OpenSSL bindings, and I'm sure will be interested in your work, <span class=\"user-mention\" data-user-id=\"942100\">@Alfredo Moreira-Rosa</span>.</p>",
        "id": 566302664,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1767603644
    },
    {
        "content": "<p>I've been building off of the existing sdl3 bindings for Lean to try to create graphical programs with it (see <a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/channel/113488-general/topic/Fun.20with.20SDL3/with/565753009\">#general &gt; Fun with SDL3</a> )</p>",
        "id": 566511169,
        "sender_full_name": "Greg Shuflin",
        "timestamp": 1767693448
    },
    {
        "content": "<p>Another idea that I've had - some kind of parser generator that can prove that it parses exactly the context-free-grammar it is supposed to</p>",
        "id": 566511534,
        "sender_full_name": "Greg Shuflin",
        "timestamp": 1767693593
    }
]