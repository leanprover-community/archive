[
    {
        "content": "<p>Currently there are two Vector types that I am aware of</p>\n<p>Vector from std lib, which has no definition of induction, which makes proofs hard:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- `Vector α n` is an `Array α` with size `n`. -/</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- The underlying array. -/</span>\n<span class=\"w\">  </span><span class=\"n\">toArray</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- Array size. -/</span>\n<span class=\"w\">  </span><span class=\"n\">size_toArray</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">toArray</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Repr</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span>\n</code></pre></div>\n<p>List.Vector from mathlib4 which includes a custom definition of induction, so proofs work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>\n<p>But why do both differ from the definitions in Rocq/Agda/The Little Typer:</p>\n<div class=\"codehilite\" data-code-language=\"Coq\"><pre><span></span><code><span class=\"kn\">Inductive</span> <span class=\"n\">t</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span>\n  <span class=\"o\">|</span><span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"n\">A</span> <span class=\"mi\">0</span>\n  <span class=\"o\">|</span><span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">nat</span><span class=\"o\">),</span> <span class=\"n\">t</span> <span class=\"n\">A</span> <span class=\"n\">n</span> <span class=\"o\">-&gt;</span> <span class=\"n\">t</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">n</span><span class=\"o\">).</span>\n</code></pre></div>\n<p>Why was there decided to diverge from this Lean definition:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Vec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vec</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vec</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">Vec</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Before I start redefining this, has this been done somewhere else?<br>\nOr was there some reason that I shouldn't go down this path?</p>",
        "id": 562066141,
        "sender_full_name": "awalterschulze",
        "timestamp": 1764930126
    },
    {
        "content": "<p>My thinking is that <code>Vector</code> can sit on top of the efficiency characteristics of <code>Array</code> and <code>List.Vector</code> can profit from all the existing API from <code>List</code>.</p>",
        "id": 562067440,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1764930535
    },
    {
        "content": "<p><code>Vector</code> is defined as it is so it can use the good properties of  <code>Array</code> in the runtime.</p>\n<p><code>List.Vector</code> is defined as is because it can reuse all the <code>List</code> API for free. Furthermore the inductively defined vectors have to carry around the <code>n</code> that tells the length of the tail in every <code>cons</code> node when compiled. So this is not a data structure you would ever want to use for executable code compared to <code>{ l : List α // l.length = n }</code></p>",
        "id": 562069223,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1764931060
    },
    {
        "content": "<p>Ah okay interesting. In Lean, unlike Coq, Agda and The Little Typer, execution is important and for execution speed the definition of Vec is not efficient. I don't quite understand why that is the case, why n would need to be carried around in compiled code after type checking, but that is okay, I can understand that Array is more efficient. I do also get that converting from a Subtype to a List vs running a toList function on Vec is more efficient.</p>\n<p>Currently I do find that List.Vector in mathlib4 is more convenient for proofs, since it at least has a defined induction macro. I do hope Vector in the std lib gets one soon too.</p>\n<p>I do still wonder if Vec would still be more convenient, just for proofs.</p>",
        "id": 562074002,
        "sender_full_name": "awalterschulze",
        "timestamp": 1764932627
    },
    {
        "content": "<p>\"convenient\" is a broad and subjective term. I, particularly, find it hard to beat the convenience of reusing all the definitions and theorems from <code>List</code>. If you define a completely new type, you'll have to bootstrap everything, which is quite the opposite of \"convenient\" IMO.</p>",
        "id": 562081398,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1764935122
    },
    {
        "content": "<p>All very true</p>",
        "id": 562085857,
        "sender_full_name": "awalterschulze",
        "timestamp": 1764936540
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"557483\">awalterschulze</span> <a href=\"#narrow/channel/113488-general/topic/vector.20types/near/562074002\">said</a>:</p>\n<blockquote>\n<p>Ah okay interesting. In Lean, unlike Coq, Agda and The Little Typer, execution is important and for execution speed the definition of Vec is not efficient. I don't quite understand why that is the case, why n would need to be carried around in compiled code after type checking, but that is okay, I can understand that Array is more efficient. </p>\n<p>I do still wonder if Vec would still be more convenient, just for proofs.</p>\n</blockquote>\n<p>Because n is of sort  Nat and Nat is of sort Type. Anything that lives in Type remains the part of computations and anything that lives in Prop never participates in computations.  Since n is of type Nat, you can do pattern match (eliminate) n then vector itself so n survives and becomes a part of computation. (This answer is based on Rocq experience but I think it’s true for Lean as well. I however wonder what would happen if the n of Vec Type n lives in Prop?)</p>",
        "id": 562143983,
        "sender_full_name": "Mukesh Tiwari",
        "timestamp": 1764953090
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"557483\">awalterschulze</span> <a href=\"#narrow/channel/113488-general/topic/vector.20types/near/562066141\">said</a>:</p>\n<blockquote>\n<p>Currently there are two Vector types that I am aware of</p>\n<p>Vector from std lib, which has no definition of induction, which makes proofs hard:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- `Vector α n` is an `Array α` with size `n`. -/</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- The underlying array. -/</span>\n<span class=\"w\">  </span><span class=\"n\">toArray</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- Array size. -/</span>\n<span class=\"w\">  </span><span class=\"n\">size_toArray</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">toArray</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Repr</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span>\n</code></pre></div>\n<p>List.Vector from mathlib4 which includes a custom definition of induction, so proofs work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>\n<p>But why do both differ from the definitions in Rocq/Agda/The Little Typer:</p>\n<div class=\"codehilite\" data-code-language=\"Coq\"><pre><span></span><code><span class=\"kn\">Inductive</span> <span class=\"n\">t</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span>\n  <span class=\"o\">|</span><span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"n\">A</span> <span class=\"mi\">0</span>\n  <span class=\"o\">|</span><span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">nat</span><span class=\"o\">),</span> <span class=\"n\">t</span> <span class=\"n\">A</span> <span class=\"n\">n</span> <span class=\"o\">-&gt;</span> <span class=\"n\">t</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">n</span><span class=\"o\">).</span>\n</code></pre></div>\n<p>Why was there decided to diverge from this Lean definition:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Vec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vec</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vec</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">Vec</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Before I start redefining this, has this been done somewhere else?<br>\nOr was there some reason that I shouldn't go down this path?</p>\n</blockquote>\n<p>you can still get induction on Vector. You can take a vector <code>v</code> and call <code>v.toArray.toList</code></p>",
        "id": 562149894,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764954965
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/113488-general/topic/vector.20types/near/562149894\">said</a>:</p>\n<blockquote>\n<p>you can still get induction on Vector. You can take a vector <code>v</code> and call <code>v.toArray.toList</code></p>\n</blockquote>\n<p>Yes, but that doesn't work in all contexts.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">ys</span>\n</code></pre></div>\n<p>can be transformed into</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">toList</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"bp\">.</span><span class=\"n\">toList</span>\n</code></pre></div>\n<p>But when it is lower down in the equality, things are a bitter tougher</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Maybe this is not the best example or maybe you know a trick I do not know about</p>",
        "id": 562292227,
        "sender_full_name": "awalterschulze",
        "timestamp": 1765093591
    },
    {
        "content": "<p>You prove the lifted version of list lemmas for arrays and vector. Fortunately the vector library already has quite a bit of this api.</p>",
        "id": 562297897,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765100697
    },
    {
        "content": "<p>Note that there is also another typical way of representing vectors, and that is <code>Fin n -&gt; α</code>. This is used for example for matrices, and denoted with <code>![1,2,3]</code>.</p>",
        "id": 562300609,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1765104004
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/113488-general/topic/vector.20types/near/562297897\">said</a>:</p>\n<blockquote>\n<p>You prove the lifted version of list lemmas for arrays and vector. Fortunately the vector library already has quite a bit of this api.</p>\n</blockquote>\n<p>Ok , but once you define your own functions on vectors, you also have to create lifted versions for each lemma you want to define on those functions?</p>",
        "id": 562301243,
        "sender_full_name": "awalterschulze",
        "timestamp": 1765104684
    },
    {
        "content": "<p>By the way, I can see one fundamental advantage of having <code>List.Vector</code> defined as a restricted List: Then the conversions to <code>List</code> and vice versa are definitionally equal.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"mi\">20</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">20</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⟨</span><span class=\"n\">l</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"mi\">20</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>besides this, it would not matter of course how we define <code>List.Vector</code> as long as we have the two conversions. Of course the advantage is that we can easily detach the proving part from manipulation, and therefore the manipulation is more flexible.</p>\n<p>To me, the definition of Rocq / Agda / ... is a bit of show-off what a cool dependent type can be built in the system without caring much about consequences, and Lean's <code>List.Vector</code> is a reasonable decision to minimize dependent type hell, and realize that <code>Vector</code> is for most people just a <code>List</code> of fixed length... I have heard that Rocq defines even <code>Fin</code> with some DTT trick which is cool but not very practical (for Lean, <code>Fin</code> is just a restricted <code>Nat</code>).</p>",
        "id": 562302478,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1765106197
    }
]