[
    {
        "content": "<p><strong>@bors</strong> <a href=\"https://github.com/leanprover-community/mathlib4/pull/3751#issuecomment-1530739806\">said</a>:</p>\n<blockquote>\n<p>Pull request successfully merged into master.</p>\n<p>Build succeeded!</p>\n<p>The publicly hosted instance of bors-ng is deprecated and will go away soon.</p>\n<p>If you want to self-host your own instance, <a href=\"https://github.com/bors-ng/bors-ng#how-to-set-up-your-own-real-instance\">instructions are here</a>.<br>\nFor more help, visit <a href=\"https://forum.bors.tech/\">the forum</a>.</p>\n<p>If you want to switch to GitHub's built-in merge queue, visit <a href=\"https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/configuring-pull-request-merges/managing-a-merge-queue\">their help page</a>.</p>\n<ul>\n<li>Build</li>\n<li>Lint style</li>\n</ul>\n</blockquote>",
        "id": 355009268,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1682992638
    },
    {
        "content": "<p>GitHub's <a href=\"https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/incorporating-changes-from-a-pull-request/merging-a-pull-request-with-a-merge-queue\">merge queue feature</a> looks promising. Has anyone tried it out?</p>",
        "id": 355010573,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1682993518
    },
    {
        "content": "<p>See <a href=\"https://bors.tech/newsletter/2023/05/01/tmib-76/\">https://bors.tech/newsletter/2023/05/01/tmib-76/</a></p>",
        "id": 355057164,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1683013129
    },
    {
        "content": "<p><img alt=\":bors:\" class=\"emoji\" src=\"https://zulip-avatars.s3.amazonaws.com/3121/emoji/images/22134.png\" title=\"bors\"> <span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span></p>",
        "id": 355063963,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1683014675
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123965\">Bryan Gin-ge Chen</span> <a href=\"#narrow/stream/113488-general/topic/bors.20going.20away.3F/near/355010573\">said</a>:</p>\n<blockquote>\n<p>GitHub's <a href=\"https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/incorporating-changes-from-a-pull-request/merging-a-pull-request-with-a-merge-queue\">merge queue feature</a> looks promising. Has anyone tried it out?</p>\n</blockquote>\n<p>I think this is the natural option, but I don't know if it does batching (and binary searching to resolve build conflicts) or if it just serializes the merging/CI steps.</p>",
        "id": 355069254,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1683015795
    },
    {
        "content": "<p>It doesn't seem to support batching or prioritization</p>",
        "id": 355071562,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1683016300
    },
    {
        "content": "<p>That's pretty poor...</p>",
        "id": 355072045,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1683016432
    },
    {
        "content": "<p>I searched some more and I found <a href=\"https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/configuring-pull-request-merges/managing-a-merge-queue\">https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/configuring-pull-request-merges/managing-a-merge-queue</a>, which says stuff like \"Merge limits: Select the minimum and maximum number of pull requests to merge in a single group (between 1 and 100), and a timeout after which the queue should stop waiting for more entries and merge with fewer than the minimum number of pull requests.\"</p>",
        "id": 355072845,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1683016578
    },
    {
        "content": "<p>And <a href=\"https://github.com/orgs/community/discussions/46757#discussioncomment-4908959\">this</a> implies a \"Jump queue\" (i.e., move to front) exists too, which is good.</p>",
        "id": 355076438,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1683017295
    },
    {
        "content": "<p>It seems pretty hard to work out from their documentation how it actually works. (e.g. what it does about batching, what happens when something fails mid-queue).</p>",
        "id": 355093774,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1683021379
    },
    {
        "content": "<p>We could just turn it on for the mathlib4 repository for a bit, see how it goes, and if it doesn't work out fall back to hosting our own bors.</p>",
        "id": 355093892,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1683021410
    },
    {
        "content": "<p>Or make a <code>mathlib-test</code> fork and ask people to create some garbage PRs (that modify comments in early files to make builds slow) just to see what happens</p>",
        "id": 355108881,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1683024613
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/stream/113488-general/topic/bors.20going.20away.3F/near/355057164\">said</a>:</p>\n<blockquote>\n<p>See <a href=\"https://bors.tech/newsletter/2023/05/01/tmib-76/\">https://bors.tech/newsletter/2023/05/01/tmib-76/</a></p>\n</blockquote>\n<p>So <code>bors</code> itself is deprecated?</p>",
        "id": 355146156,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1683033089
    },
    {
        "content": "<p>Yes. :-(</p>",
        "id": 355294615,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1683076749
    },
    {
        "content": "<p>can a majority of mathlib PRs be grouped in some reasonable fashion based on which part of the library they mainly touch? e.g. lots of PRs only touch stuff in <code>Algebra</code> or only touch stuff in <code>CategoryTheory</code>?</p>\n<p>a technique I've seen before to reduce merge queue pressure on <code>master</code> in mono-repos is to have non-master branches that accumulate multiple PRs before being merged into <code>master</code> all together. e.g. you have an <code>algebra</code> branch that all mostly-algebra PRs target, and then once a day (maybe more often) you merge that branch into master.</p>\n<p>it's somewhat better than trying to automatically batch PRs, because you can work out all the merge conflicts in all the algebra PRs before the changes even reach <code>master</code>.</p>",
        "id": 370136246,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1687884498
    },
    {
        "content": "<p>Personally, I'm not sure that that is something that would be helpful at this point</p>",
        "id": 370136684,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1687884585
    },
    {
        "content": "<p><a href=\"https://github.blog/2023-07-12-github-merge-queue-is-generally-available/\">https://github.blog/2023-07-12-github-merge-queue-is-generally-available/</a></p>",
        "id": 374697113,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1689183505
    },
    {
        "content": "<p>Should we try it?</p>",
        "id": 374746667,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1689196459
    },
    {
        "content": "<p>Should we try it on something with lower traffic like Std4 first? I think using it on mathlib3 just before the freeze would be needless pain, and there are probably more people working on Mathlib4 than Std4 [citation needed]</p>",
        "id": 374747668,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689196848
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> <span aria-label=\"up\" class=\"emoji emoji-2b06\" role=\"img\" title=\"up\">:up:</span>?</p>",
        "id": 374748836,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1689197318
    },
    {
        "content": "<p>Trying it on something low traffic seems to defeat the purpose really though, testing it a bit on a fork might be good though so maintainers can learn how it works</p>",
        "id": 374750139,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1689197832
    },
    {
        "content": "<p>Anyway, it's up to the <a href=\"https://leanprover-community.github.io/teams/ci.html\">CI team</a> to decide. <span class=\"user-mention\" data-user-id=\"123965\">@Bryan Gin-ge Chen</span> <span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> <span class=\"user-mention\" data-user-id=\"128280\">@Wojciech Nawrocki</span> <span aria-label=\"up\" class=\"emoji emoji-2b06\" role=\"img\" title=\"up\">:up:</span></p>",
        "id": 374754145,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1689199397
    },
    {
        "content": "<p>Note that Std4 is not in the leanprover-community organization, so I suspect only <span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> from that list has the power to enact such a decision.</p>",
        "id": 374754721,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689199638
    },
    {
        "content": "<p>CI team can decide to try it on some other repo (website, docs).<br>\nP.S.: I stop replying in this thread because I feel like I'm trespassing into the CI team territory.</p>",
        "id": 374757163,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1689200750
    },
    {
        "content": "<p>Yury, I don't think you have to worry about that. Everybody can offer suggestions.</p>",
        "id": 374806084,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1689226012
    },
    {
        "content": "<p>Test in production on Mathlib! :-)</p>",
        "id": 374806502,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1689226197
    },
    {
        "content": "<p>That's an option too (at least if it's easy to reverse the decision).</p>",
        "id": 375808054,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1689528341
    },
    {
        "content": "<p>I think the biggest problem is:</p>\n<blockquote>\n<p>Once a pull request has passed all required branch protection checks, a user with write access to the repository can add the pull request to the queue.</p>\n</blockquote>\n<p>This seems incompatible with our setup in which we give write access to all contributors.</p>",
        "id": 375868640,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1689559404
    },
    {
        "content": "<p>We could try to just establish the social expectation that only maintainers actually merge, but I think we will see too many mistakes to be comfortable with this.</p>",
        "id": 375868925,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1689559505
    },
    {
        "content": "<p>I think we should assume that this situation (anyone with write access can add to the merge queue) is here to stay. That means our options are:</p>\n<ul>\n<li>remove write access from non-maintainers, by working out how to do CI from forks (like everyone else in the universe)</li>\n<li>not use github's merge queue (which will mean running our own bors instance)</li>\n</ul>",
        "id": 375869136,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1689559610
    },
    {
        "content": "<p>The obstacles for CI from forks seem to be:</p>\n<ul>\n<li>inability to push oleans into the shared cache</li>\n<li>inability to use Hoskinson Center CI runners (although I'm not sure these are even running mathlib4 actions at present!)</li>\n</ul>",
        "id": 375870047,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1689560087
    },
    {
        "content": "<p>I think that each user won't run out of their amount of free hours of CI, so the latter is not a problem.</p>",
        "id": 375876446,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1689563424
    },
    {
        "content": "<p>But we need some solution for oleans.</p>",
        "id": 375876473,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1689563450
    },
    {
        "content": "<p>The Hoskinson runners are faster than github, and it would be nice to take advantage of this.</p>",
        "id": 375876561,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1689563511
    },
    {
        "content": "<p>It only matters if someone makes a big refactor or modifies a file deep in the <code>import</code> heirarchy.</p>",
        "id": 375876857,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1689563674
    },
    {
        "content": "<p>But I can't think of a way to deal with <code>olean</code>s.</p>",
        "id": 375877292,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1689563902
    },
    {
        "content": "<p>We can have a central storage for the main branch, then each clone <code>olean</code>s as <code>github</code> artifacts. Can we?</p>",
        "id": 375877393,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1689563979
    },
    {
        "content": "<p>And how can we help users not run out of space?</p>",
        "id": 375877494,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1689564014
    },
    {
        "content": "<p>(<code>lake exe cache get</code> can try the central storage and user-specific storages)</p>",
        "id": 375877537,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1689564046
    },
    {
        "content": "<p>Another option: each contributor gets a login+password for the storage. <code>olean</code>s from each user are stored in <code>login/shasum.extension</code>. <code>lake exe cache get</code> has a configurable list of users that one trusts.</p>",
        "id": 375877725,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1689564134
    },
    {
        "content": "<p>BTW, what are the current monthly stats for the storage?</p>",
        "id": 375877820,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1689564199
    },
    {
        "content": "<p>what is the shared cache used for currently? if it's just for speeding up subsequent CI runs, I think GH has a way for CI to cache files directly, which could be set up in each  contributor's fork</p>",
        "id": 375878714,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1689564695
    },
    {
        "content": "<p>I can <code>git checkout some-branch; lake exe cache get</code> and have <code>olean</code>s for that branch.</p>",
        "id": 375885387,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1689568421
    },
    {
        "content": "<p>ahh. yeah. maybe this is the incentive to build a centralized package repository with olean caching. but that's a lot of work compared to hosting a bors instance <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span></p>",
        "id": 375888861,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1689570172
    },
    {
        "content": "<p>Also relevant: <a href=\"https://matklad.github.io/2023/06/18/GitHub-merge-queue.html\">https://matklad.github.io/2023/06/18/GitHub-merge-queue.html</a></p>",
        "id": 375904341,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1689576382
    },
    {
        "content": "<p>Wow, if those criticisms are right, then I really think we should self-host bors</p>",
        "id": 375905833,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1689576846
    },
    {
        "content": "<p>Delegation is such an important feature for how I use bors that its absence is sufficient reason for me to self-host bors.</p>",
        "id": 375908082,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1689577328
    },
    {
        "content": "<p>Yes, and the latency aspect as well</p>",
        "id": 375908220,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1689577363
    },
    {
        "content": "<p>human time &gt;&gt; machine time</p>",
        "id": 375908329,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1689577388
    },
    {
        "content": "<p>Even Bors the software being frozen is not a great sign but I agree that self-hosting it while watching for improvements to GH's implementation sounds like a reasonable strategy.<br>\nRelevant GH feature requests: <a href=\"https://github.com/orgs/community/discussions/14699\">https://github.com/orgs/community/discussions/14699</a> and (I think?) <a href=\"https://github.com/orgs/community/discussions/6865\">https://github.com/orgs/community/discussions/6865</a></p>",
        "id": 375911448,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1689578168
    },
    {
        "content": "<p>Yeah, without delegation I think we should self-host Bors, not to mention some of the other headaches above.</p>",
        "id": 376036045,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1689602559
    },
    {
        "content": "<p>What happens when something breaks Bors? My understanding is that it is on the user to fix since the repo itself being archived.</p>",
        "id": 376037188,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1689602760
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/113488-general/topic/bors.20going.20away.3F/near/375870047\">said</a>:</p>\n<blockquote>\n<p>The obstacles for CI from forks seem to be:</p>\n<ul>\n<li>inability to push oleans into the shared cache</li>\n<li>inability to use Hoskinson Center CI runners (although I'm not sure these are even running mathlib4 actions at present!)</li>\n</ul>\n</blockquote>\n<p>What makes it able to do these currently?</p>",
        "id": 376057782,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1689606167
    },
    {
        "content": "<p>From forks, it's not able to do those currently</p>",
        "id": 376062006,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689606832
    },
    {
        "content": "<p>Unfortunately there is an element of security by obscurity here, which public discussion erodes</p>",
        "id": 376062429,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689606901
    },
    {
        "content": "<p>Auth issues?</p>",
        "id": 376062431,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1689606901
    },
    {
        "content": "<p>Ah ok.</p>",
        "id": 376062517,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1689606917
    },
    {
        "content": "<p>Github recommends that you do not allow private CI runners to be used on forks, which somewhat answers question 2.</p>",
        "id": 376062659,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689606943
    },
    {
        "content": "<p>Though it is technically possible</p>",
        "id": 376062719,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689606952
    },
    {
        "content": "<p>Can't the current workflow be triggered on a pull request to <code>master</code>, the fork get pulled in, and everything run as it is now?</p>",
        "id": 376062960,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1689606982
    },
    {
        "content": "<p>So that the runner ignores workflow setup in the fork?</p>",
        "id": 376076503,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1689608792
    },
    {
        "content": "<p>Is the question whether to replace bors, and with what?<br>\nI have used mergify in the past, and found it very nice, also compared to bors. They are also quite responsive, so if GitHub's built in features don't cut it, I expect they'll listen to our needs.</p>",
        "id": 376094996,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1689610982
    },
    {
        "content": "<p>I think we used to use mergify; it's in some old mathlib3 PRs</p>",
        "id": 376096638,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689611220
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/2322\">!3#2322</a></p>",
        "id": 376097684,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1689611430
    },
    {
        "content": "<p>Apparently mergify didn't do batching at the time (it got implemented in <a href=\"https://blog.mergify.com/mergify-changelog-2021q3/\">Q3 2021</a>)</p>",
        "id": 376098270,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1689611561
    },
    {
        "content": "<p>Ah, I see :-). Yes, they have that feature now, including a refinement that they call merge trains (although I haven’t used that myself yet)</p>",
        "id": 376108356,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1689613783
    },
    {
        "content": "<p>Does mergify have delegation? I think it didn't back in the day when mathlib used it.</p>",
        "id": 376108775,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1689613876
    },
    {
        "content": "<p>Not in the exact from that bors has it, I believe. Most of the time when something was delegated to me it was “merge once CI turned green”, which I found strange anyways (why tell a human to watch it when borgs/mergify/whatever can do that).<br>\nIn other words, I wonder if “delegation” is really more useful than “merge when ready”  where ready means something like “has approving reviews and the label <code>automerge</code>”. But likely I haven’t seen all the use-cases for delegation, and when it would mean something else than “I approve this PR”</p>",
        "id": 376110555,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1689614269
    },
    {
        "content": "<p>It looks like it can do label-based triggers. So you have some combination of maintainer approval and this to allow simulated delegation</p>",
        "id": 376110688,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1689614291
    },
    {
        "content": "<p>Often delegation is used for \"make some trivial docstring change, wait for CI, then merge\"</p>",
        "id": 376110968,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689614352
    },
    {
        "content": "<p>delegation in the form of \"merge when CI is green\" is indeed pointing at failing tech, but the form of \"please fix these minor issues, and kick it on some queue afterwards\" seems like an excellent form of delegation</p>",
        "id": 376111017,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1689614367
    },
    {
        "content": "<p>In the project I used it with the rules was:</p>\n<blockquote>\n<p>Merge when it has an approving review by a commiter, CI is green, and <code>merge</code> label is there.</p>\n</blockquote>\n<p>So the action to indicate</p>\n<blockquote>\n<p>\"make some trivial docstring change, wait for CI, then merge\"</p>\n</blockquote>\n<p>would be to remove the <code>merge</code> label (if present) and approve.<br>\nThen the author can fix typo, add label, and is done. As soon as CI is green, it is merged.<br>\nIn particular (and very crucial, I believe), noone has to manually wait for CI to finish</p>",
        "id": 376111336,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1689614433
    },
    {
        "content": "<p>It requires maintainers to remove the label if they want the author to give a chance to act again, but otherwise that use-case was covered nicely .</p>",
        "id": 376111550,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1689614485
    },
    {
        "content": "<p>Is it important that the delegation can be scoped to one particular user? Or is it ok if anybody can do the next step?</p>",
        "id": 376111805,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1689614544
    },
    {
        "content": "<p>\"approving review by a commiter\", does that mean \"maintainer\"?</p>",
        "id": 376111836,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1689614555
    },
    {
        "content": "<p>Note that on github, almost anyone can add labels. So the presence of the label should be thought of as a social flag, not a security flag.</p>",
        "id": 376111838,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1689614555
    },
    {
        "content": "<p>Yes, approving review by a maintainer. Or by an explicit github group.</p>",
        "id": 376111913,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1689614581
    },
    {
        "content": "<p>A few times there was some small annoyance because the delegation allowed the original PR author to merge, but someone else had taken over the PR since then. And almost anyone can sneak in a commit to someone else's branch …<br>\nAre we worried about people who have been added to the repo (only those can add labels, I think) playing not nice?<br>\n(If so, then label-based “merge if ready” indications don’t work well.)</p>",
        "id": 376112534,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1689614749
    },
    {
        "content": "<p>I don't think we are too worried about that. If someone abuses trust, then we revert the commit too master and revoke write access for that person.</p>",
        "id": 376113016,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1689614872
    },
    {
        "content": "<p><a href=\"https://docs.mergify.com/conditions/\">Here</a> are all the conditions available to use</p>",
        "id": 376113694,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1689615026
    },
    {
        "content": "<p>So so far it sounds as if mergify would be a viable option, should bors have to be shut down and should nothing better (e.g. github native) work for us.</p>",
        "id": 376113820,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1689615062
    },
    {
        "content": "<p>This is the config that I set up at a previous project. It worked well from a developer happiness point of view, but it was obviously a very differently sized project, and less open: <a href=\"https://github.com/dfinity/motoko/blob/master/.mergify.yml\">https://github.com/dfinity/motoko/blob/master/.mergify.yml</a></p>",
        "id": 376114216,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1689615155
    },
    {
        "content": "<p>Now that a PR of mine just got merged, I am reminded of one thing that mergify might do better: merged PRs would actually appear as merged in GitHub, not closed</p>",
        "id": 382040035,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1691214516
    },
    {
        "content": "<p>Since we seem to be using the merge queue now, we should probably try to make it produce better commit messages</p>",
        "id": 400488060,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1699261463
    },
    {
        "content": "<p>I think the merge queue <a href=\"https://github.com/leanprover-community/mathlib4/pull/8199#issuecomment-1794204475\">won't be used</a>. Probably we will hear about the chosen alternative soon.</p>",
        "id": 400488475,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1699261640
    },
    {
        "content": "<p>Yes, there has been a lot of experimenting and debugging yesterday. We hope to post an update soon!</p>",
        "id": 400489461,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1699262025
    },
    {
        "content": "<p>The merge queue was unsuitable because it runs a build for every single commit, rather than just the latest commit in the batch</p>",
        "id": 400489463,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699262025
    },
    {
        "content": "<p>(It's not totally clear to me that this is actually a showstopper. It will certainly consume more CI than bors. But we do a <em>lot</em> of non-bors CI, and there may still be slack in the system.)</p>",
        "id": 400489658,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1699262096
    },
    {
        "content": "<p>If it’s just the squash merge commit message, Github now supports the sensible setting of using Github title + description. Probably it can’t stop at <code>---</code> though.  Mergify supports something along these lines (a <code>### commit message</code> section).</p>",
        "id": 400501751,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1699266208
    },
    {
        "content": "<p>If you look at <a class=\"stream-topic\" data-stream-id=\"116290\" href=\"/#narrow/stream/116290-rss/topic/Recent.20Commits.20to.20mathlib4.3Amaster\">#rss &gt; Recent Commits to mathlib4:master</a> , you can see we already used the title+description option for the last few messages</p>",
        "id": 400502919,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699266614
    },
    {
        "content": "<p>Ok, sorry for the noise :-)</p>",
        "id": 400503065,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1699266675
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/bors.20going.20away.3F/near/400489463\">said</a>:</p>\n<blockquote>\n<p>The merge queue was unsuitable because it runs a build for every single commit, rather than just the latest commit in the batch</p>\n</blockquote>\n<p>Wait, what? That would make it useless for everyone, not just mathlib. Could this be a problem with mathlib's ci setup?</p>",
        "id": 400506742,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1699267972
    },
    {
        "content": "<p>The purpose of the github merge queue seems to be to ensure master never breaks, not to reduce CI load</p>",
        "id": 400506941,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699268047
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"325367\">Mauricio Collares</span> <a href=\"#narrow/stream/113488-general/topic/bors.20going.20away.3F/near/355072845\">said</a>:</p>\n<blockquote>\n<p>I searched some more and I found <a href=\"https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/configuring-pull-request-merges/managing-a-merge-queue\">https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/configuring-pull-request-merges/managing-a-merge-queue</a>, which says stuff like \"Merge limits: Select the minimum and maximum number of pull requests to merge in a single group (between 1 and 100), and a timeout after which the queue should stop waiting for more entries and merge with fewer than the minimum number of pull requests.\"</p>\n</blockquote>\n<p>Is this relevant?</p>",
        "id": 400507399,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1699268200
    },
    {
        "content": "<p><a href=\"https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/configuring-pull-request-merges/managing-a-merge-queue#successful-ci\">https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/configuring-pull-request-merges/managing-a-merge-queue#successful-ci</a> suggests that it waits for result from both [master, PR1] and [master, PR1, PR2] before merging PR1 and PR2 into master</p>",
        "id": 400508219,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1699268490
    },
    {
        "content": "<p>Indeed, merge queue does not do batches + binary search like Bors</p>",
        "id": 400513937,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1699270872
    },
    {
        "content": "<p>It does not do binary search, but given that merge groups are a thing I'd be very surprised if (in a properly configured environment, which might be hard because documentation is basically non-existent) every commit of a group got tested separately.</p>",
        "id": 400518706,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1699272709
    },
    {
        "content": "<p>It looks pretty clear from the GitHub documentation that CI runs on every commit in the group (after the history is merged / rebased to be linear)</p>",
        "id": 400518967,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699272820
    },
    {
        "content": "<p>It sounds like you can set \"Minimum pull requests to merge\" and \"Wait time\" so that PRs queue up without CI running until either N PRs are ready or T time has passed. It says</p>\n<blockquote>\n<p>You can specify a minimum group size, which is useful if merges to your base branch trigger a lengthy CI build or deploy process, and you don’t want to hold up the following entries in the queue.</p>\n</blockquote>\n<p>which suggests that it is intended for our general use case</p>",
        "id": 400519727,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699273195
    },
    {
        "content": "<p>also \"Build concurrency\" can be used to prevent it from eating all our runners</p>",
        "id": 400519898,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699273256
    },
    {
        "content": "<p>Does it bisect at all?</p>",
        "id": 400519983,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1699273293
    },
    {
        "content": "<p>I see no evidence of bisection</p>",
        "id": 400520007,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699273305
    },
    {
        "content": "<p>I think it just makes the queue go slower if you use the aforementioned throttling options</p>",
        "id": 400520118,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699273345
    },
    {
        "content": "<blockquote>\n<p>is useful if merges to your base branch trigger a lengthy CI build</p>\n</blockquote>\n<p>this is merges to the base branch, not CI on the staging branch</p>",
        "id": 400520753,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699273630
    },
    {
        "content": "<p>This is too late to be useful; if we move our CI to only be on the base branch, then we can't guarantee master stays green any more</p>",
        "id": 400520800,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699273655
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/bors.20going.20away.3F/near/400518967\">said</a>:</p>\n<blockquote>\n<p>It looks pretty clear from the GitHub documentation that CI runs on every commit in the group (after the history is merged / rebased to be linear)</p>\n</blockquote>\n<p>I agree that the docs are very weird, and I am not claiming that the feature is helpful for us any longer. I'm just surprised someone at GitHub would think this version of <code>merge_group</code> is useful to anyone.</p>",
        "id": 400520885,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1699273685
    },
    {
        "content": "<p>it's not <a href=\"https://graydon2.dreamwidth.org/1597.html\">rocket science</a>, why does everyone mess this up?</p>",
        "id": 400520979,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699273746
    },
    {
        "content": "<p>There's <a href=\"https://github.com/orgs/community/discussions/46757#discussioncomment-6035884\">some discussion here</a>, but I doubt it has much visibility</p>",
        "id": 400523340,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699274582
    },
    {
        "content": "<p>To be fair, github have succeeding in meeting the not-rocket-science rule</p>",
        "id": 400523668,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699274664
    },
    {
        "content": "<p>They've just done it in a way that costs more CI machines</p>",
        "id": 400523712,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699274676
    },
    {
        "content": "<p>Arguably, running CI only on the batch is what breaks the not rocket science rule</p>",
        "id": 400525196,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1699275094
    },
    {
        "content": "<p>Yes, depending on whether you split the hair of \"repository of code\" as \"every commit\" or \"the HEAD at any point in time\"</p>",
        "id": 400525527,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699275200
    },
    {
        "content": "<p>I don't see how you could make every commit green unless you prevent people from pushing to the repo at all</p>",
        "id": 400525697,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699275253
    },
    {
        "content": "<p>Ok, I should have split that as \"every commit accessible by following the first parents of <code>HEAD</code>\"</p>",
        "id": 400525829,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699275303
    },
    {
        "content": "<p>which is possible, if like graydon you keep a separate repository which is entirely maintained by robots and pulls stuff from the repo that people actually work on</p>",
        "id": 400525891,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699275329
    },
    {
        "content": "<p>It's also exactly what github merge queues achieve</p>",
        "id": 400526092,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699275405
    },
    {
        "content": "<p>oh I see what you mean now, bors can merge commits which have not been tested but are ancestors of a tested commit</p>",
        "id": 400526111,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699275411
    },
    {
        "content": "<p>Yes exactly, and conceivably that could be a problem for some people; but it's not something we care about or are willing to increase our CI usage for</p>",
        "id": 400526253,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699275459
    },
    {
        "content": "<p>\"Every commit needs to work\" may also be Gerrit-inspired.</p>",
        "id": 400526572,
        "sender_full_name": "Julian Berman",
        "timestamp": 1699275565
    },
    {
        "content": "<p>Our current setup makes it harder to bisect bugs that get introduced in one big bors batch if it so happens that two PRs in that batch \"interfere constructively\"</p>",
        "id": 400528580,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1699276229
    },
    {
        "content": "<p>But I feel like this is far less of an issue for our specific use than anyone elses' because it is very hard to write theorems that are genuinely bad/buggy; as opposed to code.</p>",
        "id": 400528740,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1699276290
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284160\">Eric Rodriguez</span> <a href=\"#narrow/stream/113488-general/topic/bors.20going.20away.3F/near/400528580\">said</a>:</p>\n<blockquote>\n<p>Our current setup makes it harder to bisect bugs that get introduced in one big bors batch if it so happens that two PRs in that batch \"interfere constructively\"</p>\n</blockquote>\n<p>e.g. one changes a meta thing and the other one removes the tests for that meta thing</p>",
        "id": 400528789,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1699276312
    },
    {
        "content": "<p>Akin to Zeus who summoned two mighty warriors from their grave, <span class=\"user-mention\" data-user-id=\"110596\">@Rob Lewis</span>  has asked <img alt=\":bors:\" class=\"emoji\" src=\"https://zulip-avatars.s3.amazonaws.com/3121/emoji/images/22134.png\" title=\"bors\">  to rise from its grave to rescue mathlib. Congratulations and thanks!</p>",
        "id": 400788923,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1699379322
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321696\">Julian Berman</span> <a href=\"#narrow/stream/113488-general/topic/bors.20going.20away.3F/near/400526572\">said</a>:</p>\n<blockquote>\n<p>\"Every commit needs to work\" may also be Gerrit-inspired.</p>\n</blockquote>\n<p>It is also very useful for end-users who may wish to cherry-pick some subset of changes for there use-case (e.g., patching old software with newer security patches but without a full update to the newest release due to other restrictions). Being able to bisect effectively without false positive breakages is very valuable. Thus, I think what GitHub is doing here <em>is</em> a proper implementation of the \"Not Rocket Science\" rule. The fact that bors did not do this is actually surprising, as it violates the principle of monotonically increasing test coverage expressed in the article by Graydon (i.e., by an x-axis of commit # in the default branch, test coverage is not necessarily monotonically increasing).</p>",
        "id": 400977872,
        "sender_full_name": "Mac Malone",
        "timestamp": 1699460205
    },
    {
        "content": "<p>That property is only true with the github merge queue if you <em>squash merge</em> though. If you create real merge commits, then it only enforces \"the chain of first parents is always green\"</p>",
        "id": 400980998,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699461155
    },
    {
        "content": "<p>Note that it's easy enough to bisect mathlib despite not every commit being tested; you just return the special exit code 125 from your bisection script if no  cache is available</p>",
        "id": 400981590,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699461335
    },
    {
        "content": "<p>Sure, but that won't tell you what exact commit has issues, just the bors group - that is likely easy to figure out anyways, though.</p>",
        "id": 400982344,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1699461561
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/bors.20going.20away.3F/near/400980998\">said</a>:</p>\n<blockquote>\n<p>That property is only true with the github merge queue if you <em>squash merge</em> though. If you create real merge commits, then it only enforces \"the chain of first parents is always green\"</p>\n</blockquote>\n<p>Yeah, I guess I was subconsciously assuming a linear history here as merge commits have nearly always been discouraged in the software projects I've dealt with heavily (outside of a few cases of semi-linear histories).</p>",
        "id": 400983348,
        "sender_full_name": "Mac Malone",
        "timestamp": 1699461866
    },
    {
        "content": "<p>I guess you could argue that the bors batching ought to be reflected in the git history itself, which would restore the \"every first parent is tested\" property (maybe that counts as semilinear?).</p>",
        "id": 400984781,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699462353
    },
    {
        "content": "<p><code>git bisect</code> works perfectly with many merge commits since that's how Linux is developed</p>",
        "id": 400986031,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1699462737
    },
    {
        "content": "<p>I think the <em>actual</em> performance gains of batching on busy days likley outweigh the <em>potential</em> drawbacks of failed bisection. I think the probability of the former occurring is rather low, especially if one follows Eric's regime first of only bisecting commits with a cache to winnow down the search. Then you can do normal bisection between the failing cached commit and the most recently cached commit.</p>\n<p>In this way the probability of encountering a false positive bisection is limited to the probability of error in an individual commit in a bors batch of size at most n, where n is the max batch size between the working and failing commits.</p>",
        "id": 400988793,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1699463571
    },
    {
        "content": "<p>The performance gains are overall compute cost, but not actually merge latency, because the batch’s prefixes are tested in parallel, right?<br>\n(I’m wary of a workflow that does not test every first-parent commit on master for the reasons mentioned above already, but I understand that resources may be limited)</p>",
        "id": 400996111,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1699466284
    },
    {
        "content": "<p>Merge latency is only unaffected if we never run out of compute</p>",
        "id": 400998079,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699466926
    },
    {
        "content": "<p>But we're very frequently using all the runners at busy times of day, so that's a bad assumption.</p>",
        "id": 400998188,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699466967
    },
    {
        "content": "<p>Moreover, we've had bors batches whose size exceeds the number of runners.</p>",
        "id": 400998312,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1699467005
    },
    {
        "content": "<p>In addition, bors is relatively feature rich. If there were some commit against which we <em>really</em> wanted to ensure Mathlib builds, we could send it to bors with high priority to make sure it gets its own batch. Maybe this is worth doing for core or std bumps, but for many commits I think it really isn't that important.</p>",
        "id": 400998855,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1699467240
    },
    {
        "content": "<p>My understanding is that bors initially didn't have batching, but resource constraints made people do \"rollup merges\" manually until the feature was added to bors</p>",
        "id": 400999628,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1699467555
    },
    {
        "content": "<p>If you are looking for a feature rich replacement for bors, mergify might be an option. It does merge queues like GitHub, but is much more configurable (e.g. extracting commit messages from PR descriptions, and plenty of other PR-related automation, e.g. reacting to labels etc.)</p>",
        "id": 401019859,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1699476218
    },
    {
        "content": "<p>but mergify has a cap for their free version of 100 / month. At this point, it doesn't seem we need a replacement for bors.</p>",
        "id": 401020271,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1699476398
    },
    {
        "content": "<p>Mergify would cost $12/mo/seat, but I'm not sure what \"seat\" means. If it's active users, or even active mergers, it's prohibitively expensive. If it's repo, then $12/mo for Mergify on mathlib4 might be worth it if/when bors returns to its grave</p>",
        "id": 401035662,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1699483453
    },
    {
        "content": "<p>Has anyone contacted mergify directly?</p>",
        "id": 401037532,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1699484543
    },
    {
        "content": "<p>Just did :-)</p>",
        "id": 401101898,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1699518474
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/stream/113488-general/topic/bors.20going.20away.3F/near/401101898\">said</a>:</p>\n<blockquote>\n<p>Just did :-)</p>\n</blockquote>\n<p><span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span>  Julien from Mergify here! Thanks <span class=\"user-mention\" data-user-id=\"470149\">@Joachim Breitner</span> for the invitation :)<br>\nIf you think we'd be a good solution for you, I'd be happy to have a chat. We (have to) announce limitations on the open source plan to avoid abuse, but we can raise those on a case-by-case basis.</p>",
        "id": 401112723,
        "sender_full_name": "Julien Danjou",
        "timestamp": 1699521578
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"665738\">@Julien Danjou</span> Hi! Thanks for taking the time to hop on this zulip!</p>\n<p>I don't know how much details Joachim already gave you, but here is a short summary: <a href=\"https://leanprover-community.github.io/mathlib_stats.html\">https://leanprover-community.github.io/mathlib_stats.html</a> shows that we have ~500 commits per month on our <code>master</code> branch, on busy days this means merging &gt; 20 PRs per day. Since CI runs can take over 1 hour in worst-case scenarios this would mean that a linear merging strategy leads to a traffic jam.</p>\n<p>We used bors to batch CI runs and merge batches of PRs in one go. But bors is EOL, so now we are looking at alternatives. Over the weekend we managed to set up a self-hosted bors instance. I'm not up to speed on the final details, but my impression is that \"it works mostly fine\" TM, and \"there are still a few glitches\" TM.</p>\n<p>We also used mergify several years ago. Back then it didn't have the feature to merge PRs in batches. But that seems to have changed...</p>",
        "id": 401115757,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1699522327
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> !</p>\n<p>Yes, we're far more feature-complete than Bors at this point, if one can say  — but it's not a competition; it's about finding the right tool for you.</p>\n<p>We do support batches, indeed, and even multiple concurrent batches. Details here: <a href=\"https://docs.mergify.com/merge-queue/batches/\">https://docs.mergify.com/merge-queue/batches/</a></p>\n<p>Merging 20 PRs per day won't be a problem as far as we're concerned. I've tagged your organization as being authorized to go above limits on our open-source plan, so feel free to give it a try.</p>",
        "id": 401117297,
        "sender_full_name": "Julien Danjou",
        "timestamp": 1699522717
    },
    {
        "content": "<p>That’s at least a proactive customer service that (I assume) we won’t get at Github :-)</p>",
        "id": 401140421,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1699530422
    }
]