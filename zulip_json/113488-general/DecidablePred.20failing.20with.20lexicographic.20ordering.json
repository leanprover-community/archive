[
    {
        "content": "<p>I'm running into an issue where instance search is failing to synthesize instances for the decidability of the predicate, even when it can find the decidability of the specialization of the predicate. This seems to only happen when the predicate has something to do with lexicographic ordering:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Order.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Prod.Lex</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- For each particular `n`, deciding if (0, 1) &lt;= (n, 0) is decidable</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">LE.le</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×ₗ</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">))</span> <span class=\"c1\">-- succeeds</span>\n<span class=\"c1\">-- But we can't show that this is actually a decidable predicate!</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span> <span class=\"n\">DecidablePred</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">LE.le</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×ₗ</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">))</span> <span class=\"c1\">-- fails</span>\n</code></pre></div>\n<p>If we replace the lexicographic ordering with the product partial order, then it succeeds. Similarly other minor variations succeed:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">synth</span> <span class=\"n\">Decidable</span> <span class=\"o\">((</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">))</span>  <span class=\"c1\">-- succeeds</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span> <span class=\"n\">DecidablePred</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">))</span>  <span class=\"c1\">-- also succeeds</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span> <span class=\"n\">DecidablePred</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">LE.le</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×ₗ</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">))</span> <span class=\"c1\">-- fails</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span> <span class=\"n\">DecidablePred</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">True</span> <span class=\"bp\">→</span> <span class=\"n\">LE.le</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×ₗ</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">))</span> <span class=\"c1\">-- succeeds?!</span>\n</code></pre></div>\n<p>Can anyone explain this?</p>",
        "id": 370878792,
        "sender_full_name": "Praneeth Kolichala",
        "timestamp": 1688062106
    },
    {
        "content": "<p>Type aliases are evil.  That's why we're moving them to structures where easily possible, or at least add functions like <code>toLex : α → Lex α</code> that do not break the abstraction.  In your example, the defeq <code>α = Lex α</code> leaks and Lean tries to synthesize an instance of <code>LinearOrder (Nat × Nat)</code> which of course breaks.</p>",
        "id": 370884935,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1688063265
    },
    {
        "content": "<p>The reason it leaks is because <code>(0, 1)</code> has the type <code>Nat × Nat</code>, and not <code>Lex (Nat × Nat)</code>.</p>",
        "id": 370885176,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1688063303
    },
    {
        "content": "<p>It works if you use <code>toLex</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">synth</span> <span class=\"n\">DecidablePred</span> <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">toLex</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">toLex</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"c1\">-- succeeds</span>\n</code></pre></div>",
        "id": 370885256,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1688063323
    }
]