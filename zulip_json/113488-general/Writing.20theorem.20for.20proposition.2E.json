[
    {
        "content": "<p>How would I write a theorem and prove this proposition?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">NodeRef</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">    </span><span class=\"n\">nid</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Inhabited</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Repr</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">BEq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">NodeTest</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">ref</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NodeRef</span>\n<span class=\"w\">  </span><span class=\"n\">inputs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">NodeRef</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[]</span>\n<span class=\"w\">  </span><span class=\"n\">outputs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">NodeRef</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[]</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">inputsOutputsConsistent</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">nodes</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">NodeTest</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NodeTest</span><span class=\"o\">),</span>\n<span class=\"w\">    </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">nodes</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">    </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">nodes</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">    </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">ref</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">inputs</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">    </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">ref</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">outputs</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">test1plus2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NodeTest</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">ref</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">nid</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">inputs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[{</span><span class=\"n\">nid</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">nid</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">}],</span><span class=\"w\"> </span><span class=\"n\">outputs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">test1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NodeTest</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">ref</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">nid</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">inputs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[],</span><span class=\"w\"> </span><span class=\"n\">outputs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[{</span><span class=\"n\">nid</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">}]</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">test2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NodeTest</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">ref</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">nid</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">inputs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[],</span><span class=\"w\"> </span><span class=\"n\">outputs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[{</span><span class=\"n\">nid</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">}]</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- Put all nodes in an array</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">testGraph</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">NodeTest</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">test1plus2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">test1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">test2</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 547056449,
        "sender_full_name": "Tamas Hadhazy",
        "timestamp": 1761397588
    },
    {
        "content": "<p>What theorem do you want to write</p>",
        "id": 547056909,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761397990
    },
    {
        "content": "<p>Also, you don't need to mark your code as haskell, the default on this zulip is lean4</p>",
        "id": 547056980,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761398025
    },
    {
        "content": "<p>I want to prove that if a node <code>x</code> has an input called <code>b</code> then in node <code>b</code>'s outputs we have to find node <code>x</code> and vice versa. <br>\nsee</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">    </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">ref</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">inputs</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">    </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">ref</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">outputs</span>\n</code></pre></div>",
        "id": 547057262,
        "sender_full_name": "Tamas Hadhazy",
        "timestamp": 1761398321
    },
    {
        "content": "<p>you want to prove this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">inputsOutputsConsistent</span><span class=\"w\"> </span><span class=\"n\">testGraph</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 547057415,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761398468
    },
    {
        "content": "<p>here's my proof btw</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>proof</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">inputsOutputsConsistent</span><span class=\"w\"> </span><span class=\"n\">testGraph</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">inputsOutputsConsistent</span><span class=\"w\"> </span><span class=\"n\">testGraph</span><span class=\"w\"> </span><span class=\"n\">test1plus2</span><span class=\"w\"> </span><span class=\"n\">test1</span><span class=\"w\"> </span><span class=\"n\">test2</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">mem_toArray</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">mem_cons</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">mem_nil_iff</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">or_imp</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">forall_and</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">forall_eq_apply_imp_iff</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">forall_eq</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n</code></pre></div>\n</div></div>",
        "id": 547057674,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761398743
    },
    {
        "content": "<p>Can you, by any chance, give me a description of what these are doing?</p>",
        "id": 547059326,
        "sender_full_name": "Tamas Hadhazy",
        "timestamp": 1761400405
    },
    {
        "content": "<p>It works fine btw.</p>",
        "id": 547059401,
        "sender_full_name": "Tamas Hadhazy",
        "timestamp": 1761400492
    },
    {
        "content": "<p><code>unfold</code> will unfold the declarations</p>",
        "id": 547059420,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761400516
    },
    {
        "content": "<p><code>simp</code> is the simplifier, it uses the theorems tagged <code>@[simp]</code> to simplify stuff into something provably equal</p>",
        "id": 547059438,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761400538
    },
    {
        "content": "<p><code>simp only</code> means don't use the theorems tagged <code>@[simp]</code>, actually only use the theorems I give it to simplify stuff</p>",
        "id": 547059478,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761400587
    },
    {
        "content": "<p>You can only use unfold on reducible definitions, right?</p>\n<p>Here why do you need <code>testGraph test1plus2 test1 test2</code> for the <code>unfold inputsOutputsConsistent</code></p>",
        "id": 547060535,
        "sender_full_name": "Tamas Hadhazy",
        "timestamp": 1761401632
    },
    {
        "content": "<p>it can unfold most definitions</p>",
        "id": 547060590,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761401684
    },
    {
        "content": "<p><code>unfold foo1 foo2</code> is mostly the same as <code>unfold foo1; unfold foo2</code></p>",
        "id": 547060625,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761401708
    },
    {
        "content": "<p>so here you are unfolding <br>\n<code>inputsOutputsConsistent</code>, <code>testGraph</code>, <code>test1plus2</code>, <code>test1</code>, <code>test2</code>?</p>",
        "id": 547060740,
        "sender_full_name": "Tamas Hadhazy",
        "timestamp": 1761401833
    },
    {
        "content": "<p>So all of these are lemmas right?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">mem_toArray</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">mem_cons</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">mem_nil_iff</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">or_imp</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">forall_and</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">forall_eq_apply_imp_iff</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">forall_eq</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 547061024,
        "sender_full_name": "Tamas Hadhazy",
        "timestamp": 1761402125
    },
    {
        "content": "<p>those lemmas are lemmas I am telling <code>simp</code> to use to rewrite the goal</p>",
        "id": 547061858,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761402939
    },
    {
        "content": "<p>So now I want to prove</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">nodeControl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">nodes</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">NodeTest</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">nodes</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">inputs</span><span class=\"bp\">.</span><span class=\"n\">isEmpty</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">isCfg</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∨</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">inputs</span><span class=\"bp\">.</span><span class=\"n\">isEmpty</span><span class=\"w\"> </span><span class=\"bp\">∧</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">firstRef</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">inputs</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">!</span>\n<span class=\"w\">      </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">ctrl</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">nodes</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ctrl</span><span class=\"bp\">.</span><span class=\"n\">ref</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">firstRef</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">isCfg</span><span class=\"w\"> </span><span class=\"n\">ctrl</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and I did</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">nodeControl</span><span class=\"w\"> </span><span class=\"n\">testGraph</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">nodeControl</span><span class=\"w\"> </span><span class=\"n\">testGraph</span><span class=\"w\"> </span><span class=\"n\">starttest1plus2</span><span class=\"w\"> </span><span class=\"n\">test1plus2</span><span class=\"w\"> </span><span class=\"n\">test1</span><span class=\"w\"> </span><span class=\"n\">test2</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">mem_toArray</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">mem_cons</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">mem_nil_iff</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">or_imp</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">forall_and</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">forall_eq_apply_imp_iff</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">forall_eq</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n</code></pre></div>\n<p>but it still gives me <code>unsolved goals</code></p>",
        "id": 547119378,
        "sender_full_name": "Tamas Hadhazy",
        "timestamp": 1761474155
    },
    {
        "content": "<p>well you can't expect the same proof to work for every theorem</p>",
        "id": 547119453,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761474258
    },
    {
        "content": "<p>I guess the \"logical disjunction\" and \"logical conjunction\" make it different so probably will need other tools</p>",
        "id": 547119594,
        "sender_full_name": "Tamas Hadhazy",
        "timestamp": 1761474424
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"816344\">@Aaron Liu</span> do you have any idea about how I might be able to prove it?</p>",
        "id": 547134521,
        "sender_full_name": "Tamas Hadhazy",
        "timestamp": 1761488811
    },
    {
        "content": "<p>no I don't</p>",
        "id": 547134559,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761488834
    },
    {
        "content": "<p>since I have no idea what <code>isCfg</code> does</p>",
        "id": 547134568,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761488843
    },
    {
        "content": "<p>Just checking if it is a CFG node or not</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">NodeDataTest</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">constantl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">value</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nullData</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">returnData</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">startData</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Inhabited</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Repr</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">BEq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">NodeTest</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">ref</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NodeRef</span>\n<span class=\"w\">  </span><span class=\"n\">data</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NodeDataTest</span>\n<span class=\"w\">  </span><span class=\"n\">inputs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">NodeRef</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[]</span>\n<span class=\"w\">  </span><span class=\"n\">outputs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">NodeRef</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[]</span>\n\n\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">isCfg</span><span class=\"o\">(</span><span class=\"n\">node</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NodeTest</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">node</span><span class=\"bp\">.</span><span class=\"n\">data</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">NodeDataTest</span><span class=\"bp\">.</span><span class=\"n\">startData</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">NodeDataTest</span><span class=\"bp\">.</span><span class=\"n\">returnData</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">false</span>\n</code></pre></div>",
        "id": 547134623,
        "sender_full_name": "Tamas Hadhazy",
        "timestamp": 1761488887
    },
    {
        "content": "<p>this all looks like very decidable stuff</p>",
        "id": 547134707,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761488955
    },
    {
        "content": "<p>why don't you try writing a <code>Decidable</code> instance</p>",
        "id": 547134719,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761488965
    },
    {
        "content": "<p>So just use the decide tactic?</p>",
        "id": 547135636,
        "sender_full_name": "Tamas Hadhazy",
        "timestamp": 1761489518
    }
]