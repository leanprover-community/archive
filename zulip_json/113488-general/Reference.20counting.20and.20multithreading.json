[
    {
        "content": "<p>I am sorry if this question appears to be stupid or already answered, but how exactly Lean does reference counting on multithreaded programs?  Is it like Koka with atomics? Or there is something else?</p>",
        "id": 325620087,
        "sender_full_name": "Oleg M",
        "timestamp": 1675428261
    },
    {
        "content": "<p>As far as I know Koka did not diverge from Lean 4 in that regard, yes. Objects marked as multi-threaded use acquire/release atomic operations. I don't know any realistic alternative.</p>",
        "id": 325622822,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1675429029
    },
    {
        "content": "<p>Okay, I see, thank you!<br>\nI am just thinking that there might be another option, maybe with some lock-free approach. I think atomics might slow down things too much.</p>",
        "id": 325631027,
        "sender_full_name": "Oleg M",
        "timestamp": 1675431191
    },
    {
        "content": "<p>Atomics are lock-free. Atomics are how you <em>do</em> lock-free usually.</p>",
        "id": 325633048,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1675431654
    },
    {
        "content": "<p>Yeah lock free usually means you reduce your state to 64 bit and start having atomic read compare update ops.</p>",
        "id": 325634548,
        "sender_full_name": "Henrik BÃ¶ving",
        "timestamp": 1675432036
    },
    {
        "content": "<p>I see. Thank you for answering.</p>",
        "id": 325635025,
        "sender_full_name": "Oleg M",
        "timestamp": 1675432147
    }
]