[
    {
        "content": "<p>I'm pleased to announce the initial (alpha) release of <a href=\"https://github.com/digama0/lean4lean\"><code>lean4lean</code></a>, a lean 4 kernel implementation written entirely in lean 4. This is the first complete kernel implementation other than the original (AFAIK). In fact, even the elaborator, which is essentially a strictly more complexified version of the kernel (because it also has to deal with things like metavariables), doesn't know all the tricks that the kernel does, especially around validity checking for inductives and anything to do with nested inductives.</p>\n<p>It is essentially a \"Rewrite it in Lean\" direct port of the C++ code. For now it is just the core implementation, there is no frontend to speak of, but it provides <code>Environment.addDecl'</code> which is a drop-in replacement for <code>Environment.addDecl</code>. It also makes use of Lean data structures (<code>Expr</code>, <code>Environment</code>, etc) so it should be compatible with other lean metaprograms, and is a good starting point for hacking the kernel (e.g. adding print messages, tracing reduction, profiling, etc).</p>\n<p>A stretch goal for the project is to also add lean metatheory and maybe prove some properties about the kernel. The main thing that was done to facilitate this is that it only uses pure lean data structures: no <code>IO</code>, no <code>ST</code>, and almost no <code>partial</code> (there are some inherited <code>partial</code> from lean functions and some TODOs in the code). I think it is feasible to get to a point where one could prove soundness at least in principle.</p>\n<p>The natural question for self-verification projects like this is: where is the \"cheat\", what makes this not the kind of verification that is precluded by Goedel's incompleteness theorems? Well, the reduction process is not obviously structurally recursive and you need some stupendously large ordinals to find a decreasing metric for <code>#reduce</code>. Absent that, you essentially have to treat reduction as a potentially non-terminating process. Luckily, this accords well with another fact of life: Lean doesn't run reduction forever anyway, because it has <code>(deterministic) timeout</code> and <code>deep recursion</code> errors if you try. So for this implementation we just run reduction for N steps where N is a large number and timeout if it doesn't complete. With this truncated reduction, it is possible to prove termination in lean, as well as soundness.</p>",
        "id": 396406831,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697165483
    },
    {
        "content": "<p>Sorry, what does “soundness” mean in this setting? Do you have a particular model in mind?</p>",
        "id": 396411928,
        "sender_full_name": "Jason Rute",
        "timestamp": 1697167276
    },
    {
        "content": "<p>yes, <a href=\"https://github.com/digama0/lean-type-theory/releases/tag/v1.0\">#leantt</a></p>",
        "id": 396411950,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697167288
    },
    {
        "content": "<p>So every theorem provable by the kernel plus the standard lean axioms holds in ZFC + infinitely many large cardinals (under the usual interpretation of types as sets, etc.)?</p>",
        "id": 396412257,
        "sender_full_name": "Jason Rute",
        "timestamp": 1697167450
    },
    {
        "content": "<p>Formalizing the results of my thesis has been a long standing goal of mine. A kernel is a slightly different kind of task which doesn't overlap that much with metatheory, but it's a start: at least one can <em>state</em> claims like consistency or soundness using lean data types</p>",
        "id": 396412521,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697167603
    },
    {
        "content": "<p>I agree.  I’m just wrapping my head around what the statement of the theorem for soundness would be.  (Consistency is easier to state of course.)</p>",
        "id": 396412818,
        "sender_full_name": "Jason Rute",
        "timestamp": 1697167757
    },
    {
        "content": "<p>yes that's the right statement (modulo some details)</p>",
        "id": 396412854,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697167789
    },
    {
        "content": "<p>there are basically two theorems of interest: (1) everything the lean kernel accepts is a theorem of LeanTT, and (2) there is a model of LeanTT in ZFC + omega universes, so in particular False is not a theorem of LeanTT</p>",
        "id": 396413039,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697167879
    },
    {
        "content": "<p>Here LeanTT represents the \"abstract representation\" of the type theory, more or less what you get in my thesis</p>",
        "id": 396413140,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697167931
    },
    {
        "content": "<p>I have more real worries about (1) being false than (2). In a big program there is a lot of room for trivial errors</p>",
        "id": 396413404,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697168104
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Lean4Lean.3A.20Lean.204.20kernel.20in.20Lean/near/396411950\">said</a>:</p>\n<blockquote>\n<p>yes, <a href=\"https://github.com/digama0/lean-type-theory/releases/tag/v1.0\">#leantt</a></p>\n</blockquote>\n<p>Also with updates from <a href=\"https://lean-lang.org/papers/thesis-sebastian.pdf#section.3.2\">https://lean-lang.org/papers/thesis-sebastian.pdf#section.3.2</a> , I assume?</p>",
        "id": 396429203,
        "sender_full_name": "Utensil Song",
        "timestamp": 1697176297
    },
    {
        "content": "<p>It's Lean all the way down!</p>",
        "id": 396436541,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1697180093
    },
    {
        "content": "<p>So what is the path to <code>lean4lean4checker</code>, and having it run in Mathlib CI?</p>",
        "id": 396438049,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1697180744
    },
    {
        "content": "<p>Anyone wants to implement the \"reflections on trusting trust\" concept in lean4? <a href=\"https://www.cs.cmu.edu/~rdriley/487/papers/Thompson_1984_ReflectionsonTrustingTrust.pdf\">https://www.cs.cmu.edu/~rdriley/487/papers/Thompson_1984_ReflectionsonTrustingTrust.pdf</a></p>",
        "id": 396440829,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1697181491
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/113488-general/topic/Lean4Lean.3A.20Lean.204.20kernel.20in.20Lean/near/396438049\">said</a>:</p>\n<blockquote>\n<p>So what is the path to <code>lean4lean4checker</code>, and having it run in Mathlib CI?</p>\n</blockquote>\n<p>I have already copied the core of <code>lean4checker</code> into <code>lean4lean</code> because it's the easiest way to test the program, although I haven't thought about how to distribute it yet. (It's still at the riddled-with-bugs stage, I was excited to release it but I hadn't actually tried to run it yet because I was afraid of what I would find. I'm sure it's at least a few more days of debugging before it will check mathlib and we can do actual profiling.)</p>",
        "id": 396500738,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697201794
    },
    {
        "content": "<p>Would it be (hypothetically, for now) possible to replace the C++ kernel in lean with the lean-implemented one at some point? Would we expect any gains (besides that more of the lean code is accessible to people knowing only lean)?</p>",
        "id": 396519816,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1697208353
    },
    {
        "content": "<p>As  I understand the interaction  point of the Compiler with the Kernel is through C FFI, passing in <code>Environment</code> among other things. And since  we can <code>@[export]</code> functions to make them available as callable functions through C FFI it should definitely be possible to link in the lean4lean kernel from a technical POV.</p>",
        "id": 396520221,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1697208486
    },
    {
        "content": "<p>I more wonder: What qualities do we want from a kernel implemenation? Is there something that a reimplementation like lean4lean could provide that would make us want to use that as the “the” kernel?<br>\nI guess as per the other recent discussions, lean is “only” the proof assistant, and the built-in kernel is mostly a sanity check, so speed and maybe good error messages matter most? Whereas correctness is actually less important compared to when used as an external checker afterwards.</p>",
        "id": 396523072,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1697209450
    },
    {
        "content": "<p>Correctness is obviously one of the most important aspects of a kernel implementation. The other main one is performance, and this is why lean4lean uses all the optimizations from the original. (It is difficult to second-guess whether a kernel optimization is really critical or not because it might show up only in certain kinds of programs that stress particular parts of the implementation.) I expect there to be some performance drop relative to the C++ implementation because the compiler might not be able to optimize the lean code as well, we will have to see.</p>",
        "id": 396526350,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697210522
    },
    {
        "content": "<p>There are three main remaining components in the C++ code:</p>\n<ol>\n<li>the kernel</li>\n<li>the (old) compiler frontend (Expr -&gt; IR)</li>\n<li>the interpreter</li>\n</ol>\n<p>It would be possible to upstream lean4lean and this basically crosses (1) off the list. Similarly, (2) is \"just\" a matter of porting the old code, although I think this is hampered somewhat by the desire to \"do it better this time\" and so now the whole compiler is being redesigned and this could take a while. (3) seems the hardest to move to lean, because it has some really extreme performance requirements and I can't see lean ever being good enough for that (even C/C++/Rust can't make optimal interpreter code sometimes and you have to drop to assembly to get the right codegen). But with those components covered lean could move to a fully self-hosted system and drop the requirement of a C++ compiler, and my impression is that this is a long term goal of the project.</p>",
        "id": 396526682,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697210620
    },
    {
        "content": "<p>By the way, lean4lean does not support <code>reduceBool</code>, despite a fair amount of thinking on how to do it. (For those who haven't already guessed, the recent discussion of <code>reduceBool</code> stems from investigations into reimplementing and validating the kernel.) To do it in pure lean, you would need the interpreter to also exist in pure lean, which is a separate project (item (3) on the list). The simple cheat would be to just call it as an opaque function but this tanks some of the metatheory goals. There are more elaborate ways to specify it somewhat abstractly.</p>",
        "id": 396528669,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697211212
    },
    {
        "content": "<p>Could lean4lean support <code>reduceBool</code> by normalising the <code>Expr</code>, i.e. _not_ invoking the compiled code? Presumably that would be rather slow, and people use <code>reduceBool</code> precisely when that would be too slow, but would there be otherwise a difference?</p>",
        "id": 396531508,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1697212359
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Lean4Lean.3A.20Lean.204.20kernel.20in.20Lean/near/396526682\">said</a>:</p>\n<blockquote>\n<p>(3) seems the hardest to move to lean, because it has some really extreme performance requirements and I can't see lean ever being good enough for that (even C/C++/Rust can't make optimal interpreter code sometimes and you have to drop to assembly to get the right codegen).</p>\n</blockquote>\n<p>With the new LLVM backend, replacing the interpreter with  JIT could work. Furthermore, with the new in-Lean compiler, it would be possible to swap out implementations with manually construct LLVM definitions (which can include inline assembly). Thus, fully hosted compiler+interpreter should be possible in the future.</p>",
        "id": 396549491,
        "sender_full_name": "Mac Malone",
        "timestamp": 1697219527
    },
    {
        "content": "<p>I'm not talking about replacing the interpreter with something else, I'm talking about writing the interpreter itself in lean. We will always have a need for an interpreter, and it is very important that the interpreter be fast because it has a multiplicative effect on all code run through the interpreter. A JIT would not replace the interpreter, it would only supplement it (I can't think of any interpreted language which was able to move to 100% JIT, they usually keep the interpreter and go back and forth based on dynamic performance measurements).</p>",
        "id": 396575437,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697233895
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/stream/113488-general/topic/Lean4Lean.3A.20Lean.204.20kernel.20in.20Lean/near/396531508\">said</a>:</p>\n<blockquote>\n<p>Could lean4lean support <code>reduceBool</code> by normalising the <code>Expr</code>, i.e. _not_ invoking the compiled code? Presumably that would be rather slow, and people use <code>reduceBool</code> precisely when that would be too slow, but would there be otherwise a difference?</p>\n</blockquote>\n<p>It could. The simplest way to do that would be to have <code>reduceBool</code> be a <code>def</code> instead of an <code>opaque</code>, since that is effectively what you are saying: it is defeq to its value after unfolding. I think the main issue with doing this in practice is that quite often this reduction won't work because it will get stuck on an <code>opaque</code> for something the compiler implements externally. It could also explode in time/space requirements as you note, it's hard to predict this in advance.</p>",
        "id": 396575725,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697234074
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Lean4Lean.3A.20Lean.204.20kernel.20in.20Lean/near/396575437\">said</a>:</p>\n<blockquote>\n<p>A JIT would not replace the interpreter, it would only supplement it (I can't think of any interpreted language which was able to move to 100% JIT, they usually keep the interpreter and go back and forth based on dynamic performance measurements).</p>\n</blockquote>\n<p>What does Julia do in this regard?</p>",
        "id": 396577890,
        "sender_full_name": "Jason Rute",
        "timestamp": 1697235462
    },
    {
        "content": "<p>From what I can tell, Julia is indeed \"100% JIT\". I also saw the term \"just ahead of time\" used to describe it, and it's not too dissimilar to what lean currently does: it runs the compiler on the spot when you write an expression at the repl, and executes the result (no tracing and optimistic re-compilation like in actual JIT languages like Java or JS). I think lean could do this in theory, and the theory is getting closer to practice as the work on LLVM JIT / GccJit progresses.</p>",
        "id": 396582695,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697239598
    },
    {
        "content": "<p>There does seem to be a julia interpreter package but it's not part of the default distribution</p>",
        "id": 396582716,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697239622
    },
    {
        "content": "<p>and if the interpreter is relegated to this kind of place in the lean ecosystem it wouldn't be a big deal if it was written in 100% lean since the majority case would be all be efficient native code generated by the JIT</p>",
        "id": 396582808,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697239684
    },
    {
        "content": "<p>Ah, so <code>reduceBool</code> not only evaluates “normal” definitions (possibly with <code>implemented_by</code> or <code>csimp</code> attributes), but also opaque definitions where <em>only</em> a compiled definition exists, and normal reduction can't even do anything.</p>",
        "id": 396647537,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1697286911
    },
    {
        "content": "<p>Update: <code>lean4lean</code> is now tested and working on all of the <code>Lean</code> package. I think it's ready for performance testing...</p>",
        "id": 397444874,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697700299
    },
    {
        "content": "<p>Initial numbers show a 36% slowdown relative to the C++ code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">$</span> <span class=\"n\">time</span> <span class=\"n\">build</span><span class=\"bp\">/</span><span class=\"n\">bin</span><span class=\"bp\">/</span><span class=\"n\">lean4lean</span> <span class=\"c1\">--fresh Lean</span>\n<span class=\"n\">Executed</span> <span class=\"k\">in</span>   <span class=\"mi\">20</span><span class=\"bp\">.</span><span class=\"mi\">98</span> <span class=\"n\">secs</span>    <span class=\"n\">fish</span>           <span class=\"n\">external</span>\n   <span class=\"n\">usr</span> <span class=\"n\">time</span>   <span class=\"mi\">20</span><span class=\"bp\">.</span><span class=\"mi\">76</span> <span class=\"n\">secs</span>  <span class=\"mi\">405</span><span class=\"bp\">.</span><span class=\"mi\">00</span> <span class=\"n\">micros</span>   <span class=\"mi\">20</span><span class=\"bp\">.</span><span class=\"mi\">76</span> <span class=\"n\">secs</span>\n   <span class=\"n\">sys</span> <span class=\"n\">time</span>    <span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">15</span> <span class=\"n\">secs</span>  <span class=\"mi\">237</span><span class=\"bp\">.</span><span class=\"mi\">00</span> <span class=\"n\">micros</span>    <span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">15</span> <span class=\"n\">secs</span>\n\n<span class=\"bp\">$</span> <span class=\"n\">time</span> <span class=\"n\">build</span><span class=\"bp\">/</span><span class=\"n\">bin</span><span class=\"bp\">/</span><span class=\"n\">lean4checker</span> <span class=\"c1\">--fresh Lean</span>\n<span class=\"n\">Executed</span> <span class=\"k\">in</span>   <span class=\"mi\">15</span><span class=\"bp\">.</span><span class=\"mi\">19</span> <span class=\"n\">secs</span>    <span class=\"n\">fish</span>           <span class=\"n\">external</span>\n   <span class=\"n\">usr</span> <span class=\"n\">time</span>   <span class=\"mi\">15</span><span class=\"bp\">.</span><span class=\"mi\">02</span> <span class=\"n\">secs</span>  <span class=\"mi\">520</span><span class=\"bp\">.</span><span class=\"mi\">00</span> <span class=\"n\">micros</span>   <span class=\"mi\">15</span><span class=\"bp\">.</span><span class=\"mi\">02</span> <span class=\"n\">secs</span>\n   <span class=\"n\">sys</span> <span class=\"n\">time</span>    <span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">07</span> <span class=\"n\">secs</span>  <span class=\"mi\">161</span><span class=\"bp\">.</span><span class=\"mi\">00</span> <span class=\"n\">micros</span>    <span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">07</span> <span class=\"n\">secs</span>\n</code></pre></div>\n<p>Alas, lean code still can't quite compete. :( But this was more or less as expected, and the important part is that it's not an order of magnitude slower.</p>",
        "id": 397446672,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697701002
    },
    {
        "content": "<p>Still, for a first speed test, that is really competitive!</p>",
        "id": 397449263,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1697701794
    },
    {
        "content": "<p>And certainly fast enough to happily use in CI.</p>",
        "id": 397449364,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1697701817
    },
    {
        "content": "<p>Should I set it up to run on all of Mathlib?</p>",
        "id": 397449403,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1697701833
    },
    {
        "content": "<p>Maybe that doesn't even need a fast machine. <code>lean4checker</code> only takes ~15 minutes in CI.</p>",
        "id": 397449462,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1697701852
    },
    {
        "content": "<p>yes please</p>",
        "id": 397452258,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697702775
    },
    {
        "content": "<p>Same order of magnitude on first try is pretty good, congrats! Still wondering if this could be used to de-C++ lean itself some more :-)</p>",
        "id": 397492630,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1697717663
    },
    {
        "content": "<p>Unfortunately it appears to be quite a bit slower on Mathlib:</p>\n<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code>%<span class=\"w\"> </span><span class=\"nb\">time</span><span class=\"w\"> </span>lake<span class=\"w\"> </span>env<span class=\"w\"> </span>../lean4checker/build/bin/lean4checker<span class=\"w\"> </span>--fresh<span class=\"w\"> </span>Mathlib\nlake<span class=\"w\"> </span>env<span class=\"w\"> </span>../lean4checker/build/bin/lean4checker<span class=\"w\"> </span>--fresh<span class=\"w\"> </span>Mathlib<span class=\"w\">  </span><span class=\"m\">1201</span>.51s<span class=\"w\"> </span>user<span class=\"w\"> </span><span class=\"m\">73</span>.39s<span class=\"w\"> </span>system<span class=\"w\"> </span><span class=\"m\">99</span>%<span class=\"w\"> </span>cpu<span class=\"w\"> </span><span class=\"m\">21</span>:15.51<span class=\"w\"> </span>total\n</code></pre></div>\n<p>while</p>\n<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code>%<span class=\"w\"> </span><span class=\"nb\">time</span><span class=\"w\"> </span>lake<span class=\"w\"> </span>env<span class=\"w\"> </span>../lean4lean/build/bin/lean4lean<span class=\"w\"> </span>--fresh<span class=\"w\"> </span>Mathlib\n</code></pre></div>\n<p>is still running with 4 hours on the clock. :-(</p>",
        "id": 397643682,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1697785170
    },
    {
        "content": "<p>Oh that's not good</p>",
        "id": 397644823,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697785566
    },
    {
        "content": "<p>I expect the issue to be a bug in the checker, not a performance issue</p>",
        "id": 397644889,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697785598
    },
    {
        "content": "<p><code>Lean</code> is a fairly good test suite but it doesn't have everything</p>",
        "id": 397644937,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697785622
    },
    {
        "content": "<p>Could you replace <code>addDecl</code> with this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">addDecl</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">Declaration</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">verbose</span> <span class=\"o\">:=</span> <span class=\"n\">false</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">match</span> <span class=\"n\">d</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">axiomDecl</span> <span class=\"n\">d</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">println</span><span class=\"bp\">!</span> <span class=\"s2\">\"adding axiomDecl {d.name}\"</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">defnDecl</span> <span class=\"n\">d</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">println</span><span class=\"bp\">!</span> <span class=\"s2\">\"adding defnDecl {d.name}\"</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">thmDecl</span> <span class=\"n\">d</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">println</span><span class=\"bp\">!</span> <span class=\"s2\">\"adding thmDecl {d.name}\"</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">opaqueDecl</span> <span class=\"n\">d</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">println</span><span class=\"bp\">!</span> <span class=\"s2\">\"adding opaqueDecl {d.name}\"</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">quotDecl</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">println</span><span class=\"bp\">!</span> <span class=\"s2\">\"adding quotDecl\"</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">mutualDefnDecl</span> <span class=\"n\">d</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">println</span><span class=\"bp\">!</span> <span class=\"s2\">\"adding mutualDefnDecl {d.map (·.name)}\"</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">inductDecl</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">d</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">println</span><span class=\"bp\">!</span> <span class=\"s2\">\"adding inductDecl {d.map (·.name)}\"</span>\n  <span class=\"k\">match</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">get</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">env.addDecl'</span> <span class=\"n\">d</span> <span class=\"n\">true</span> <span class=\"n\">verbose</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">read</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">env0</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">ok</span> <span class=\"n\">env</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">modify</span> <span class=\"k\">fun</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span> <span class=\"n\">s</span> <span class=\"k\">with</span> <span class=\"n\">env</span> <span class=\"o\">:=</span> <span class=\"n\">env</span> <span class=\"o\">}</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">error</span> <span class=\"n\">ex</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">throwKernelException</span> <span class=\"n\">ex</span>\n</code></pre></div>\n<p>and then log the output to see where it got stuck?</p>",
        "id": 397645193,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697785698
    },
    {
        "content": "<p>(I'm actually kind of surprised you haven't reported any <code>deep recursion</code> or <code>deterministic timeout</code> errors. I somewhat arbitrarily set 1000 iterations in every place where it is not structurally recursive, and it's not actually that hard to write code that exceeds this many iterations if you try.)</p>",
        "id": 397645599,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697785888
    },
    {
        "content": "<p>Another thing is that you can use non-<code>--fresh</code> mode and compile all the environments separately. This is actually a better test for lean4lean than <code>--fresh</code> mode because it validates lean4lean's expressions against the C++ kernel generated exprs stored in the oleans</p>",
        "id": 397645953,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697786057
    },
    {
        "content": "<p>(It's also way faster since it is multithreaded)</p>",
        "id": 397646110,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697786149
    },
    {
        "content": "<p>Okay, just got back to this thread, and killed it at the 8 hour mark.</p>",
        "id": 397689549,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1697801368
    },
    {
        "content": "<p>I think you must have also changed <code>Environment.addDecl'</code>, as this doesn't typecheck:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">function</span> <span class=\"n\">expected</span> <span class=\"n\">at</span>\n  <span class=\"n\">Environment.addDecl'</span> <span class=\"n\">__do_lift</span><span class=\"bp\">✝¹.</span><span class=\"n\">env</span> <span class=\"n\">d</span>\n<span class=\"n\">term</span> <span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">Except</span> <span class=\"n\">KernelException</span> <span class=\"n\">Environment</span>\n</code></pre></div>",
        "id": 397689880,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1697801504
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">%</span> <span class=\"n\">time</span> <span class=\"n\">lake</span> <span class=\"n\">env</span> <span class=\"bp\">../</span><span class=\"n\">lean4lean</span><span class=\"bp\">/</span><span class=\"n\">build</span><span class=\"bp\">/</span><span class=\"n\">bin</span><span class=\"bp\">/</span><span class=\"n\">lean4lean</span>\n<span class=\"n\">lean4lean</span> <span class=\"n\">found</span> <span class=\"n\">a</span> <span class=\"n\">problem</span> <span class=\"k\">in</span> <span class=\"n\">Std.Data.String.Lemmas</span>\n</code></pre></div>\n<p>and then runs forever.</p>",
        "id": 397802986,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1697854749
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/113488-general/topic/Lean4Lean.3A.20Lean.204.20kernel.20in.20Lean/near/397689880\">said</a>:</p>\n<blockquote>\n<p>I think you must have also changed <code>Environment.addDecl'</code>, as this doesn't typecheck:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">function</span> <span class=\"n\">expected</span> <span class=\"n\">at</span>\n  <span class=\"n\">Environment.addDecl'</span> <span class=\"n\">__do_lift</span><span class=\"bp\">✝¹.</span><span class=\"n\">env</span> <span class=\"n\">d</span>\n<span class=\"n\">term</span> <span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">Except</span> <span class=\"n\">KernelException</span> <span class=\"n\">Environment</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Oops, you can ignore the last two arguments</p>",
        "id": 397807758,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697858193
    },
    {
        "content": "<p>I did manage to reproduce the <code>Std.Data.String.Lemmas</code> error, will investigate</p>",
        "id": 397807937,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697858331
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> I pushed a fix for the issue above, and now <code>Std</code> also passes. Could you rerun the mathlib test?</p>",
        "id": 397815683,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697864595
    },
    {
        "content": "<p>I found and fixed a (caching) bug in lean4lean, and the two kernels should now be very close in behavior. The test from above is now 18.89s (lean4lean) / 14.87 (lean4checker), i.e. a 27% slowdown (an improvement over the 36% reported above) although this might be noise, I don't think the caching issue shows up in <code>Lean</code> because it doesn't have many proofs in it.</p>\n<p>I'm going to try running the mathlib test again and see if there are any performance cliffs.</p>",
        "id": 398206552,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1698125252
    },
    {
        "content": "<p>Hey <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> , can I get you to do one more mathlib run with lean4lean? I think I've solved the last performance issues, and I have tested that every file in mathlib is within 2x of the C++, but I haven't tried doing it with <code>--fresh</code> and without it one has to be careful to limit the number of threads or it uses up all my memory building 12 copies of mathlib in memory.</p>",
        "id": 398900858,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1698413944
    },
    {
        "content": "<p>Yes, but I'm away from the computer until tomorrow.</p>",
        "id": 398966154,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1698439560
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">%</span> <span class=\"n\">time</span> <span class=\"n\">lake</span> <span class=\"n\">env</span> <span class=\"bp\">../</span><span class=\"n\">lean4lean</span><span class=\"bp\">/</span><span class=\"n\">build</span><span class=\"bp\">/</span><span class=\"n\">bin</span><span class=\"bp\">/</span><span class=\"n\">lean4lean</span> <span class=\"c1\">--fresh Mathlib</span>\n</code></pre></div>\n<p>killed after 9 hours.</p>",
        "id": 399189554,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1698618171
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span></p>",
        "id": 399189567,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1698618184
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> That's weird, are you sure you ran it on the latest version? I definitely managed to get it to complete in an hour or so</p>",
        "id": 399211104,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1698632607
    },
    {
        "content": "<p>Oh I think mathlib moved on since my test: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AlgebraicTopology.DoldKan.compatibility_Γ₂N₁_Γ₂N₂_natTrans#doc\">AlgebraicTopology.DoldKan.compatibility_Γ₂N₁_Γ₂N₂_natTrans</a> seems to be very hard, the lean kernel takes 9.4s and lean4lean takes at least 5 minutes</p>",
        "id": 399215352,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1698634802
    },
    {
        "content": "<p>(In those 9.4s, lean calls inferType on just over 1 million subterms. Maybe this proof should be refactored...)</p>",
        "id": 399219458,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1698637207
    },
    {
        "content": "<p>Here are the results of running <code>lean4lean --fresh Mathlib</code> and collecting data on the longest definitions. All definitions which took more than 1 second to run are listed (in units of milliseconds), and when lean was more than 2x faster it is also listed.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"mi\">35084</span> <span class=\"o\">(</span><span class=\"n\">lean</span> <span class=\"mi\">17464</span><span class=\"o\">)</span> <span class=\"kd\">lemma</span> <span class=\"n\">AlgebraicTopology.DoldKan.compatibility_</span><span class=\"bp\">Γ₂</span><span class=\"n\">N₁_</span><span class=\"bp\">Γ₂</span><span class=\"n\">N₂_inv_app</span>\n<span class=\"mi\">23737</span>              <span class=\"kd\">lemma</span> <span class=\"n\">UpperHalfPlane.isometry_vertical_line</span>\n<span class=\"mi\">23050</span>              <span class=\"kd\">lemma</span> <span class=\"n\">CategoryTheory.Idempotents.DoldKan.hε</span>\n<span class=\"mi\">18733</span> <span class=\"o\">(</span><span class=\"n\">lean</span>  <span class=\"mi\">8649</span><span class=\"o\">)</span> <span class=\"kd\">lemma</span> <span class=\"n\">AlgebraicTopology.DoldKan.compatibility_</span><span class=\"bp\">Γ₂</span><span class=\"n\">N₁_</span><span class=\"bp\">Γ₂</span><span class=\"n\">N₂_hom_app</span>\n<span class=\"mi\">17587</span> <span class=\"o\">(</span><span class=\"n\">lean</span>  <span class=\"mi\">8519</span><span class=\"o\">)</span> <span class=\"kd\">lemma</span> <span class=\"n\">AlgebraicTopology.DoldKan.compatibility_</span><span class=\"bp\">Γ₂</span><span class=\"n\">N₁_</span><span class=\"bp\">Γ₂</span><span class=\"n\">N₂_natTrans</span>\n<span class=\"mi\">15256</span> <span class=\"o\">(</span><span class=\"n\">lean</span>  <span class=\"mi\">4382</span><span class=\"o\">)</span> <span class=\"kd\">lemma</span> <span class=\"n\">CliffordAlgebra.GradedAlgebra.lift_ι_eq</span>\n<span class=\"mi\">10301</span> <span class=\"o\">(</span><span class=\"n\">lean</span>  <span class=\"mi\">4433</span><span class=\"o\">)</span> <span class=\"kd\">lemma</span> <span class=\"n\">HasFPowerSeriesAt.comp</span>\n <span class=\"mi\">9927</span> <span class=\"o\">(</span><span class=\"n\">lean</span>  <span class=\"mi\">4934</span><span class=\"o\">)</span> <span class=\"kd\">lemma</span> <span class=\"n\">Ideal.powQuotSuccInclusion_injective</span>\n <span class=\"mi\">7749</span> <span class=\"o\">(</span><span class=\"n\">lean</span>  <span class=\"mi\">3365</span><span class=\"o\">)</span> <span class=\"kd\">lemma</span> <span class=\"n\">ModuleCat.monModuleEquivalenceAlgebra.proof_25</span>\n <span class=\"mi\">7319</span>              <span class=\"kd\">lemma</span> <span class=\"n\">ModuleCat.MonoidalCategory.pentagon</span>\n <span class=\"mi\">6826</span> <span class=\"o\">(</span><span class=\"n\">lean</span>  <span class=\"mi\">2582</span><span class=\"o\">)</span> <span class=\"kd\">lemma</span> <span class=\"n\">TensorProduct.directSum_symm_lof_tmul</span>\n <span class=\"mi\">6701</span> <span class=\"o\">(</span><span class=\"n\">lean</span>  <span class=\"mi\">2726</span><span class=\"o\">)</span> <span class=\"kd\">lemma</span> <span class=\"n\">finsuppTensorFinsupp_single</span>\n <span class=\"mi\">6453</span> <span class=\"o\">(</span><span class=\"n\">lean</span>  <span class=\"mi\">2879</span><span class=\"o\">)</span> <span class=\"kd\">lemma</span> <span class=\"n\">cauchySeq_finset_of_geometric_bound</span>\n <span class=\"mi\">6369</span>              <span class=\"kd\">lemma</span> <span class=\"n\">Submodule.pow_induction_on_right'</span>\n <span class=\"mi\">6049</span> <span class=\"o\">(</span><span class=\"n\">lean</span>  <span class=\"mi\">2715</span><span class=\"o\">)</span> <span class=\"kd\">lemma</span> <span class=\"n\">ModuleCat.monModuleEquivalenceAlgebra.proof_11</span>\n <span class=\"mi\">5268</span> <span class=\"o\">(</span><span class=\"n\">lean</span>  <span class=\"mi\">2467</span><span class=\"o\">)</span> <span class=\"kd\">lemma</span> <span class=\"n\">ModuleCat.monModuleEquivalenceAlgebra.proof_9</span>\n <span class=\"mi\">5048</span> <span class=\"o\">(</span><span class=\"n\">lean</span>  <span class=\"mi\">2296</span><span class=\"o\">)</span> <span class=\"kd\">lemma</span> <span class=\"n\">ModuleCat.monModuleEquivalenceAlgebra.proof_10</span>\n <span class=\"mi\">4069</span>              <span class=\"kd\">def</span> <span class=\"n\">GradedModule.isModule</span>\n <span class=\"mi\">3288</span>              <span class=\"kd\">lemma</span> <span class=\"n\">Ideal.homogeneousHull_eq_iSup</span>\n <span class=\"mi\">3250</span> <span class=\"o\">(</span><span class=\"n\">lean</span>  <span class=\"mi\">1610</span><span class=\"o\">)</span> <span class=\"kd\">lemma</span> <span class=\"n\">GradedModule.isModule.proof_4</span>\n <span class=\"mi\">3130</span>              <span class=\"kd\">lemma</span> <span class=\"n\">GradedModule.isModule.proof_6</span>\n <span class=\"mi\">3121</span>              <span class=\"kd\">lemma</span> <span class=\"n\">GradedModule.isModule.proof_5</span>\n <span class=\"mi\">3114</span>              <span class=\"kd\">lemma</span> <span class=\"n\">GradedModule.isModule.proof_2</span>\n <span class=\"mi\">3109</span>              <span class=\"kd\">lemma</span> <span class=\"n\">GradedModule.isModule.proof_1</span>\n <span class=\"mi\">3019</span>              <span class=\"kd\">lemma</span> <span class=\"n\">GradedModule.isModule.proof_3</span>\n <span class=\"mi\">2961</span> <span class=\"o\">(</span><span class=\"n\">lean</span>  <span class=\"mi\">1354</span><span class=\"o\">)</span> <span class=\"kd\">lemma</span> <span class=\"n\">CategoryTheory.Pretriangulated.shiftFunctorZero_op_hom_app</span>\n <span class=\"mi\">2902</span> <span class=\"o\">(</span><span class=\"n\">lean</span>  <span class=\"mi\">1315</span><span class=\"o\">)</span> <span class=\"kd\">lemma</span> <span class=\"n\">UpperHalfPlane.modular_T_smul</span>\n <span class=\"mi\">2821</span> <span class=\"o\">(</span><span class=\"n\">lean</span>   <span class=\"mi\">826</span><span class=\"o\">)</span> <span class=\"kd\">lemma</span> <span class=\"n\">TensorProduct.directSum.proof_4</span>\n <span class=\"mi\">2784</span> <span class=\"o\">(</span><span class=\"n\">lean</span>  <span class=\"mi\">1196</span><span class=\"o\">)</span> <span class=\"kd\">lemma</span> <span class=\"n\">Algebra.TensorProduct.opAlgEquiv.proof_14</span>\n <span class=\"mi\">2289</span> <span class=\"o\">(</span><span class=\"n\">lean</span>  <span class=\"mi\">1099</span><span class=\"o\">)</span> <span class=\"kd\">lemma</span> <span class=\"n\">Ideal.powQuotSuccInclusion_apply_coe</span>\n <span class=\"mi\">2044</span> <span class=\"o\">(</span><span class=\"n\">lean</span>   <span class=\"mi\">985</span><span class=\"o\">)</span> <span class=\"kd\">lemma</span> <span class=\"n\">ModuleCat.monModuleEquivalenceAlgebra.proof_8</span>\n <span class=\"mi\">1994</span> <span class=\"o\">(</span><span class=\"n\">lean</span>   <span class=\"mi\">893</span><span class=\"o\">)</span> <span class=\"kd\">lemma</span> <span class=\"n\">Module.torsion_by_prime_power_decomposition</span>\n <span class=\"mi\">1924</span>              <span class=\"kd\">lemma</span> <span class=\"n\">CommRingCat.instCreatesLimitCommRingCatMaxInstCommRingCatLargeCategoryRingCatMaxInstRingCatLargeCategoryForget₂InstConcreteCategoryCommRingCatInstCommRingCatLargeCategoryInstConcreteCategoryRingCatInstRingCatLargeCategoryHasForgetToRingCat.proof_2</span>\n <span class=\"mi\">1811</span>              <span class=\"kd\">lemma</span> <span class=\"n\">ContinuousLinearMap.prodMapL.proof_19</span>\n <span class=\"mi\">1735</span>              <span class=\"kd\">def</span> <span class=\"n\">GradedRing.proj</span>\n <span class=\"mi\">1638</span>              <span class=\"kd\">lemma</span> <span class=\"n\">Ideal.IsHomogeneous.isPrime_of_homogeneous_mem_or_mem</span>\n <span class=\"mi\">1506</span>              <span class=\"kd\">lemma</span> <span class=\"n\">AlgebraicGeometry.PresheafedSpace.colimitCocone.proof_3</span>\n <span class=\"mi\">1432</span>              <span class=\"kd\">lemma</span> <span class=\"n\">norm_iteratedFDerivWithin_comp_le_aux</span>\n <span class=\"mi\">1430</span> <span class=\"o\">(</span><span class=\"n\">lean</span>   <span class=\"mi\">623</span><span class=\"o\">)</span> <span class=\"kd\">lemma</span> <span class=\"n\">DirectSum.decompose_one</span>\n <span class=\"mi\">1308</span> <span class=\"o\">(</span><span class=\"n\">lean</span>   <span class=\"mi\">552</span><span class=\"o\">)</span> <span class=\"kd\">lemma</span> <span class=\"n\">CategoryTheory.Idempotents.DoldKan.hη</span>\n <span class=\"mi\">1289</span>              <span class=\"kd\">lemma</span> <span class=\"n\">Module.equiv_directSum_of_isTorsion</span>\n <span class=\"mi\">1239</span> <span class=\"o\">(</span><span class=\"n\">lean</span>   <span class=\"mi\">597</span><span class=\"o\">)</span> <span class=\"kd\">lemma</span> <span class=\"n\">DirectSum.decompose_symm_one</span>\n <span class=\"mi\">1169</span> <span class=\"o\">(</span><span class=\"n\">lean</span>   <span class=\"mi\">383</span><span class=\"o\">)</span> <span class=\"kd\">lemma</span> <span class=\"n\">CategoryTheory.Bicategory.adjointifyCounit_left_triangle</span>\n <span class=\"mi\">1155</span> <span class=\"o\">(</span><span class=\"n\">lean</span>   <span class=\"mi\">444</span><span class=\"o\">)</span> <span class=\"kd\">lemma</span> <span class=\"n\">TensorProduct.directSumRight_tmul_lof</span>\n <span class=\"mi\">1131</span> <span class=\"o\">(</span><span class=\"n\">lean</span>   <span class=\"mi\">417</span><span class=\"o\">)</span> <span class=\"kd\">lemma</span> <span class=\"n\">TensorProduct.directSumLeft_symm_lof_tmul</span>\n <span class=\"mi\">1111</span> <span class=\"o\">(</span><span class=\"n\">lean</span>   <span class=\"mi\">482</span><span class=\"o\">)</span> <span class=\"kd\">lemma</span> <span class=\"n\">Algebra.TensorProduct.map_ker</span>\n <span class=\"mi\">1098</span>              <span class=\"kd\">lemma</span> <span class=\"n\">RingCat.instCreatesLimitRingCatMaxInstRingCatLargeCategorySemiRingCatMaxInstSemiRingCatLargeCategoryForget₂InstConcreteCategoryRingCatInstRingCatLargeCategoryInstConcreteCategorySemiRingCatInstSemiRingCatLargeCategoryHasForgetToSemiRingCat.proof_2</span>\n <span class=\"mi\">1085</span> <span class=\"o\">(</span><span class=\"n\">lean</span>   <span class=\"mi\">433</span><span class=\"o\">)</span> <span class=\"kd\">lemma</span> <span class=\"n\">CategoryTheory.Localization.instIsEquivalenceFunctorCategoryFunctorsInvertingInstCategoryFunctorsInvertingWhiskeringLeftFunctor.proof_2</span>\n <span class=\"mi\">1064</span> <span class=\"o\">(</span><span class=\"n\">lean</span>   <span class=\"mi\">488</span><span class=\"o\">)</span> <span class=\"kd\">lemma</span> <span class=\"n\">Ordinal.sup_sum</span>\n <span class=\"mi\">1055</span> <span class=\"o\">(</span><span class=\"n\">lean</span>   <span class=\"mi\">386</span><span class=\"o\">)</span> <span class=\"kd\">lemma</span> <span class=\"n\">QuadraticForm.tmul_comp_tensorAssoc</span>\n <span class=\"mi\">1054</span> <span class=\"o\">(</span><span class=\"n\">lean</span>   <span class=\"mi\">270</span><span class=\"o\">)</span> <span class=\"kd\">lemma</span> <span class=\"n\">CategoryTheory.FreeBicategory.liftHom₂_congr</span>\n <span class=\"mi\">1048</span> <span class=\"o\">(</span><span class=\"n\">lean</span>   <span class=\"mi\">484</span><span class=\"o\">)</span> <span class=\"kd\">lemma</span> <span class=\"n\">Algebra.TensorProduct.opAlgEquiv.proof_15</span>\n <span class=\"mi\">1014</span> <span class=\"o\">(</span><span class=\"n\">lean</span>   <span class=\"mi\">504</span><span class=\"o\">)</span> <span class=\"kd\">lemma</span> <span class=\"n\">FormalMultilinearSeries.changeOrigin_eval</span>\n</code></pre></div>",
        "id": 399238517,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1698650102
    },
    {
        "content": "<p>I expect that basically all of these are \"bad\" proofs, which take a long time not because of any deep mathematical reason but rather because something unexpected is being unfolded. Note in particular that essentially none of the large tactic-heavy proofs show up in this list - these are slow for the elaborator but quite light on the kernel. The stuff that shows up here is in deeply dependent situations like in category theory and algebraic topology where defeq problems are necessary in order to even state proof goals.</p>",
        "id": 399238977,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1698650332
    },
    {
        "content": "<p>That list is impressively short!</p>",
        "id": 399240608,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1698651183
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>, there's something worrying here: I'm sure that I just rebuilt Mathlib master locally, and rebuilt the latest <code>lean4lean</code>, but my latest run of <code>lean4lean --fresh Mathlib</code> was still going after 4 hours...</p>",
        "id": 399240849,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1698651347
    },
    {
        "content": "<p>oops, both the performance bugs from friday and the one I fixed an hour ago were not pushed <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 399241040,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1698651443
    },
    {
        "content": "<p>the above test was done on <a href=\"https://github.com/digama0/lean4lean/commit/2d54c3d87b0a1f294523fa25d4a9e5a9b14999e5\">https://github.com/digama0/lean4lean/commit/2d54c3d87b0a1f294523fa25d4a9e5a9b14999e5</a></p>",
        "id": 399241144,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1698651499
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">lake</span> <span class=\"n\">env</span> <span class=\"bp\">../</span><span class=\"n\">lean4lean</span><span class=\"bp\">/</span><span class=\"n\">build</span><span class=\"bp\">/</span><span class=\"n\">bin</span><span class=\"bp\">/</span><span class=\"n\">lean4lean</span> <span class=\"c1\">--fresh Mathlib  1752.20s user 137.67s system 99% cpu 31:33.01 total</span>\n</code></pre></div>",
        "id": 399320471,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1698678180
    },
    {
        "content": "<p>(Compared to 21 minutes from the C++ kernel. Nice!)</p>",
        "id": 399320644,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1698678221
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Can you clarify some implementation details (for my battles for the Trepplein port)? <br>\nThis is regarding the functions <code>whnf</code> and <code>whnfCore</code> and the parameter <code>cheapProj</code>. Am I correct that:</p>\n<ul>\n<li>The difference between these is that <code>whnf</code> (and <code>whnf'</code>) include unfolding definitions but this is not the case in <code>whnfCore</code> (and <code>whnfCore'</code>).</li>\n<li>If <code>cheapProj</code> is <code>true</code>, then the less agressive normalization <code>whnfCore</code> is called to avoid too much looping at the cost of less complete normalization.</li>\n<li>When proving <code>defEq</code>we set <code>cheapProj</code> as <code>true</code> and pass this on recursively, so equality may fail to be proved but crashes are avoided.</li>\n</ul>\n<p>For context, the current state of the port is that it is crashing with a stackoverflow while type-checking the (huge) definition <code>Nat.Linear.ExprCnstr.denote_toNormPoly</code>and I traced this to recursive simplification of the <code>struct</code> in a projection. It looks like the sort of thing the above was meant to block so it would help if this is clear (on the flip side reducing normalization may mean types are not proved equal).</p>",
        "id": 400709962,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1699352784
    },
    {
        "content": "<p>I also had issues with that theorem</p>",
        "id": 400710110,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699352847
    },
    {
        "content": "<p>I don't think <code>cheapProj</code> is used to distinguish between <code>whnf</code> and <code>whnfCore</code></p>",
        "id": 400710162,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699352873
    },
    {
        "content": "<p>In <code>reduceProj</code> I see the line <code>let mut c ← (if cheapProj then whnfCore struct cheapRec cheapProj else whnf struct)</code></p>",
        "id": 400710345,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1699352943
    },
    {
        "content": "<p>oh no you are right, it is only used in L302 where it does that</p>",
        "id": 400710372,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699352952
    },
    {
        "content": "<p>I don't have a whole lot of insight into how and why these flags are passed around, but I guess you should do it if you aren't already and it is leading to a timeout</p>",
        "id": 400710986,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699353157
    },
    {
        "content": "<p>Thanks. I will experiment with an analogous flag. The structure of the code is a bit different in lean4lean versus trepplein 3, but something analogous can be done.</p>",
        "id": 400711559,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1699353357
    },
    {
        "content": "<p>(I swear I'm not trying to make these line up with the eve of lean community meetings but these things happen!) I want to share a major new development in the lean4lean repo: <a href=\"https://github.com/digama0/lean4lean/commit/c40c886bd83e71ac577d116e714bf4fdaadb2006#diff-cf6d325f097aaecd3832d2bd7fd5164922bf6c25ac43e9dcb174fa25fce87b2d\">an initial formalization</a> of lean's type theory, modeled after chapter 2.1-2.2 of <a href=\"https://github.com/digama0/lean-type-theory/releases/tag/v1.0\">#leantt</a>. It is still missing the definition of inductive types, but it does explicitly define the environment and valid environment modifications, unlike <a href=\"https://github.com/digama0/lean-type-theory/releases/tag/v1.0\">#leantt</a> which leaves the environment implicit.</p>",
        "id": 403312610,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1700548460
    },
    {
        "content": "<p>It uses a separate type <code>VExpr</code> which is like <code>Expr</code> but with some constructors removed and others macro expanded. A tool I'm particularly proud of is the <code>vexpr(..)</code> macro, which lets you define a <code>VExpr</code> from an <code>Expr</code>, meaning that we can reuse all of lean's elaboration features. In fact, this was so effective that it allowed me to write this borderline-cheating definition of the quotient extension:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">VEnv.addQuot</span> <span class=\"o\">(</span><span class=\"n\">env</span> <span class=\"o\">:</span> <span class=\"n\">VEnv</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">VEnv</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">env</span> <span class=\"bp\">←</span> <span class=\"n\">env.addConst</span> <span class=\"bp\">``</span><span class=\"n\">Quot</span> <span class=\"n\">vconst</span><span class=\"o\">(</span><span class=\"n\">type_of</span><span class=\"bp\">%</span> <span class=\"bp\">@</span><span class=\"n\">Quot</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">env</span> <span class=\"bp\">←</span> <span class=\"n\">env.addConst</span> <span class=\"bp\">``</span><span class=\"n\">Quot.mk</span> <span class=\"n\">vconst</span><span class=\"o\">(</span><span class=\"n\">type_of</span><span class=\"bp\">%</span> <span class=\"bp\">@</span><span class=\"n\">Quot.mk</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">env</span> <span class=\"bp\">←</span> <span class=\"n\">env.addConst</span> <span class=\"bp\">``</span><span class=\"n\">Quot.ind</span> <span class=\"n\">vconst</span><span class=\"o\">(</span><span class=\"n\">type_of</span><span class=\"bp\">%</span> <span class=\"bp\">@</span><span class=\"n\">Quot.ind</span><span class=\"o\">)</span>\n  <span class=\"n\">env.addConst</span> <span class=\"bp\">``</span><span class=\"n\">Quot.lift</span> <span class=\"n\">vconst</span><span class=\"o\">(</span><span class=\"n\">type_of</span><span class=\"bp\">%</span> <span class=\"bp\">@</span><span class=\"n\">Quot.lift</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>which expands to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Lean4Lean.VEnv.addQuot</span> <span class=\"o\">:</span> <span class=\"n\">VEnv</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">VEnv</span> <span class=\"o\">:=</span>\n<span class=\"k\">fun</span> <span class=\"n\">env</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">env</span> <span class=\"bp\">←</span>\n    <span class=\"n\">VEnv.addConst</span> <span class=\"n\">env</span> <span class=\"bp\">`</span><span class=\"n\">Quot</span>\n        <span class=\"o\">(</span><span class=\"n\">some</span>\n          <span class=\"o\">{</span> <span class=\"n\">uvars</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n            <span class=\"n\">type</span> <span class=\"o\">:=</span>\n              <span class=\"n\">VExpr.forallE</span> <span class=\"o\">(</span><span class=\"n\">VExpr.sort</span> <span class=\"o\">(</span><span class=\"n\">VLevel.param</span> <span class=\"mi\">0</span><span class=\"o\">))</span>\n                <span class=\"o\">(</span><span class=\"n\">VExpr.forallE</span> <span class=\"o\">(</span><span class=\"n\">VExpr.forallE</span> <span class=\"o\">(</span><span class=\"n\">VExpr.bvar</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">VExpr.forallE</span> <span class=\"o\">(</span><span class=\"n\">VExpr.bvar</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">VExpr.sort</span> <span class=\"n\">VLevel.zero</span><span class=\"o\">)))</span>\n                  <span class=\"o\">(</span><span class=\"n\">VExpr.sort</span> <span class=\"o\">(</span><span class=\"n\">VLevel.param</span> <span class=\"mi\">0</span><span class=\"o\">)))</span> <span class=\"o\">})</span>\n  <span class=\"k\">let</span> <span class=\"n\">env</span> <span class=\"bp\">←</span>\n    <span class=\"n\">VEnv.addConst</span> <span class=\"n\">env</span> <span class=\"bp\">`</span><span class=\"n\">Quot.mk</span>\n        <span class=\"o\">(</span><span class=\"n\">some</span>\n          <span class=\"o\">{</span> <span class=\"n\">uvars</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n            <span class=\"n\">type</span> <span class=\"o\">:=</span>\n              <span class=\"n\">VExpr.forallE</span> <span class=\"o\">(</span><span class=\"n\">VExpr.sort</span> <span class=\"o\">(</span><span class=\"n\">VLevel.param</span> <span class=\"mi\">0</span><span class=\"o\">))</span>\n                <span class=\"o\">(</span><span class=\"n\">VExpr.forallE</span> <span class=\"o\">(</span><span class=\"n\">VExpr.forallE</span> <span class=\"o\">(</span><span class=\"n\">VExpr.bvar</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">VExpr.forallE</span> <span class=\"o\">(</span><span class=\"n\">VExpr.bvar</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">VExpr.sort</span> <span class=\"n\">VLevel.zero</span><span class=\"o\">)))</span>\n                  <span class=\"o\">(</span><span class=\"n\">VExpr.forallE</span> <span class=\"o\">(</span><span class=\"n\">VExpr.bvar</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n                    <span class=\"o\">(</span><span class=\"n\">VExpr.app</span> <span class=\"o\">(</span><span class=\"n\">VExpr.app</span> <span class=\"o\">(</span><span class=\"n\">VExpr.const</span> <span class=\"bp\">`</span><span class=\"n\">Quot</span> <span class=\"o\">[</span><span class=\"n\">VLevel.param</span> <span class=\"mi\">0</span><span class=\"o\">])</span> <span class=\"o\">(</span><span class=\"n\">VExpr.bvar</span> <span class=\"mi\">2</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">VExpr.bvar</span> <span class=\"mi\">1</span><span class=\"o\">))))</span> <span class=\"o\">})</span>\n   <span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 403313065,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1700548726
    },
    {
        "content": "<p>My ITP paper on Lean4Lean is <a href=\"https://arxiv.org/abs/2403.14064\">now on ArXiv</a></p>",
        "id": 428259491,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711082133
    }
]