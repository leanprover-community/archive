[
    {
        "content": "<p>Hi everyone,</p>\n<p>I am attempting to formalize my own thesis using Lean. It relates to Boolean sigma algebras, the countable chain condition, and measure theory on those. I realize that many things that I would have to do would fit nicely in mathlib, and therefore I think it makes sense to try to add them to the library.</p>\n<p>I will follow roughly Halmos' \"Introduction to Boolean algebras\" and \"Lectures on Boolean Algebras\", but of course I will adapt things so that they fit nicely into mathlib.</p>\n<p>I am rather new to Lean, so I am pretty sure I will need help often; I hope that is fine.</p>\n<p>To start, I opened an issue: <a href=\"https://github.com/leanprover-community/mathlib4/issues/25849\">https://github.com/leanprover-community/mathlib4/issues/25849</a><br>\nThe idea is that both <code>inf_sSup_le_iSup_inf</code> and <code>iInf_sup_le_sup_sInf</code> are provable, and therefore I have prepared a PR with that change. It consists essentially of moving those two statements out of <code>CompleteBooleanAlgebra</code> and making them into lemmas that we prove. Moreover, it removes the proof of those for every instance of <code>CompleteBooleanAlgebra</code>.</p>\n<p>Any comments, or people interested, are welcome.</p>",
        "id": 524131243,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1749994286
    },
    {
        "content": "<p>Please make a PR removing those fields, add the lemmas with the one-line proofs as mentioned in the issue and then see if you can fix up the library to get it all compiling again! The PR should mostly involve deleting code :-) </p>\n<p>The way to make PRs to mathlib has recently changed, so searching this Zulip and maybe even some of the online docs might still be out of date (I don't know, all I know is that we are currently right in the middle of a big change). What you need to do is to fork mathlib, create a new branch, edit the file to remove the fields from the structure, and then try compiling locally with <code>lake build</code> and wait for 1 to 2 minutes. Probably other files will break; fix them. When the mathlib compilation process runs for a couple of minutes without any errors, try your luck: quit compiling locally (it will take an hour on a medium spec machine and you don't need to do this yourself) and make a PR to mathlib describing your change briefly. Then we'll see what CI says and you can ask again if it says something you don't understand.</p>",
        "id": 524131817,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1749995095
    },
    {
        "content": "<p>Thanks for the explanation, I tried my best following the guidelines (hopefully the new ones), here is the PR:<br>\n<a href=\"https://github.com/leanprover-community/mathlib4/pull/25909\">https://github.com/leanprover-community/mathlib4/pull/25909</a></p>\n<p>I think it does exactly what you described, except that I made them theorem (it was not clear which it should be, but I can definitely change to lemma).</p>",
        "id": 524132359,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1749995799
    },
    {
        "content": "<p>FYI on Zulip you can type <code>#25909</code> and it will render as <a href=\"https://github.com/leanprover-community/mathlib4/pull/25909\">#25909</a></p>",
        "id": 524133537,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1749996906
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"928941\">@Pierre Quinton</span> thanks a lot for your first merged PR!</p>",
        "id": 524152633,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1750017621
    },
    {
        "content": "<p>I have added a new PR (<a href=\"https://github.com/leanprover-community/mathlib4/pull/25938\">#25938</a>) that follows the previous one. The idea is that since we do not have any more fields in <code>CompleteBooleanAlgebra</code>, we can now make <code>CompleteAtomicBooleanAlgebra</code> extend it directly. We also don't need anymore cast to <code>CompleteBooleanAlgebra</code>.</p>",
        "id": 524156235,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1750022544
    },
    {
        "content": "<p>I want to get working on Boolean sigma algebras. I can find no concepts related to Boolean sigma algebras, sigma Ideals, lattice that are closed under countable operations. The only remotely related material I could find are notions of <code>Measurable</code> sets which form sigma algebra without explicitly framing those as <code>BooleanAlgebra</code> (I might have missed something, obviously).</p>\n<p>I am thinking of creating a new file <code>BooleanSigmaAlgebra</code> in <code>Order</code> (alternatively, we could group all <code>BooleanAlgebra</code> related material in a Order/BooleanAlgebra folder in a quick PR).  In it, I am planning to add a class <code>BooleanSigmaAlgebra</code> (or maybe <code>BooleanσAlgebra</code> but this is slightly hard to read) that extends only <code>BooleanAlgebra</code>. I will then add some material to it, for instance I am thinking of duplicating a fair proportion of material from CompleteBooleanAlgebra as they share a lot of properties.</p>\n<p>Alternatively, I am wondering about if there would be a way to change have an intermediate class that extends BooleanAlgebra and is given some constraint of type <code>Set α → Prop</code> which would typically be <code>Set.Finite</code>, <code>Set.Countable</code> or <code>Set α → true</code>. In this class, we could prove many of the properties that are currently in <code>CompleteBooleanAlgebra</code>. Then we would have that if it is constrained to <code>Set.Finite</code>, then it is a <code>BooleanAlgebra</code>, if it is constrained to <code>Set.Countable</code>, then it is a <code>BooleanSigmaAlgebra</code> and if it is <code>Set α → true</code> then it is <code>CompleteBooleanAlgebra</code>. I am not sure if My explanation makes sense, or if it is doable but I think it would be an interesting structure.</p>\n<p>Any feedback would is most welcome, and I will provide update on my progress here.</p>",
        "id": 524267974,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1750083542
    },
    {
        "content": "<p>One possibility is the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Order</span><span class=\"bp\">.</span><span class=\"n\">BooleanAlgebra</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Order</span><span class=\"bp\">.</span><span class=\"n\">Bounds</span><span class=\"bp\">.</span><span class=\"n\">Defs</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Order</span><span class=\"bp\">.</span><span class=\"n\">SetNotation</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Countable</span>\n\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">BooleanSigmaAlgebra</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">BooleanAlgebra</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n\n<span class=\"w\">  </span><span class=\"sd\">/-- The supremum of a countable set. -/</span>\n<span class=\"w\">  </span><span class=\"n\">cSup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">Countable</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"w\">  </span><span class=\"sd\">/-- The infimum of a countable set. -/</span>\n<span class=\"w\">  </span><span class=\"n\">cInf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">Countable</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n\n<span class=\"w\">  </span><span class=\"sd\">/-- `cSup s hs` is a least upper bound of `s`. -/</span>\n<span class=\"w\">  </span><span class=\"n\">isLUB_cSup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">Countable</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cSup</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">hs</span><span class=\"o\">)</span>\n\n<span class=\"w\">  </span><span class=\"sd\">/-- `cInf s hs` is a greatest lower bound of `s`. -/</span>\n<span class=\"w\">  </span><span class=\"n\">isGLB_cInf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">Countable</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cInf</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">hs</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 524284029,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1750088579
    },
    {
        "content": "<p>Another possibility is this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Order</span><span class=\"bp\">.</span><span class=\"n\">BooleanAlgebra</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Order</span><span class=\"bp\">.</span><span class=\"n\">Bounds</span><span class=\"bp\">.</span><span class=\"n\">Defs</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Order</span><span class=\"bp\">.</span><span class=\"n\">SetNotation</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Countable</span>\n\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span>\n\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">BooleanSigmaAlgebra</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">BooleanAlgebra</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">iSup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">iInf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"w\">  </span><span class=\"n\">le_iSup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">iSup</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"w\">  </span><span class=\"n\">iSup_le</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">iSup</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">a</span>\n\n<span class=\"w\">  </span><span class=\"n\">iInf_le</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">iInf</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"n\">le_iInf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">iInf</span><span class=\"w\"> </span><span class=\"n\">f</span>\n</code></pre></div>\n<p>For now I like this one better, it feels simpler. The only weird thing is that the <code>iSup</code> here is not related to <code>SupSet</code> in any kind of way.</p>",
        "id": 524392481,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1750146983
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"928941\">@Pierre Quinton</span>, sorry for the delay, but both your ideas above will be impractical:</p>\n<ul>\n<li>They don't give you access to the existing <code>⨅</code>/<code>⨆</code> notations</li>\n<li>They have restricted inputs</li>\n</ul>",
        "id": 524431415,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1750160100
    },
    {
        "content": "<p>More subtly, your second definition doesn't give you the supremum/infimum of the empty set, <del>so eg <code>ℝ</code> should be a boolean sigma algebra according to that definition</del> actually no it wouldn't be, but something along those lines, eg ordinals should work</p>",
        "id": 524431862,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1750160227
    },
    {
        "content": "<p>I suggest instead you take in <em>total</em> functions <code>sSup</code>/<code>sInf</code>, and assert that they are LUBs/GLBs only if the given sets are countable. This would look like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">BooleanSigmaAlgebra</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">BooleanAlgebra</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">sSup</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">sInf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">isLUB_sSup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">Countable</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sSup</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">s</span>\n<span class=\"w\">  </span><span class=\"n\">isGLB_sInf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">Countable</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sInf</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">s</span>\n</code></pre></div>",
        "id": 524432330,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1750160371
    },
    {
        "content": "<p>Have fun!</p>",
        "id": 524432335,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1750160373
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> Yes, I have realized that when trying to prove anything. But it looks like I can only get <code>⨆</code> if I extend <code>SupSet</code> which would then define <code>sSup</code> for all sets, not just those that are of restricted cardinality.</p>\n<p>For your second point, you are completely right, this definition is terrible.</p>\n<p>I think that your solution works, but I feel weird about having <code>sSup</code> defined on any set. But I guess this is just a symbol, it doesn't mean anything, so this is fine. thanks a lot, I will explore it now!</p>",
        "id": 524432732,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1750160489
    },
    {
        "content": "<p>Indeed I am making your <code>sSup</code>/<code>sInf</code> have junk values. This is the same reasoning behind <code>1 / 0 = 0</code> or <code>√-1 = 0</code>: Better make your functions total than requiring your users to prove that inputs are valid every time they call then function</p>",
        "id": 524433061,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1750160596
    },
    {
        "content": "<p>BTW, should I then extend <code>SupSet</code> and <code>InfSet</code> to get the <code>sSup</code> and <code>sInf</code> instead of declaring them?</p>",
        "id": 524433100,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1750160608
    },
    {
        "content": "<p>Yes! Doesn't change a huge lot over declaring the instance separately, but why not, it saves you a few lines</p>",
        "id": 524433194,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1750160646
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/113488-general/topic/Boolean.20sigma.20algebras.20and.20measure.20theory.20on.20them/near/524432330\">said</a>:</p>\n<blockquote>\n<p>I suggest instead you take in <em>total</em> functions <code>sSup</code>/<code>sInf</code>, and assert that they are LUBs/GLBs only if the given sets are countable. This would look like</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">BooleanSigmaAlgebra</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">BooleanAlgebra</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">sSup</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">sInf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">isLUB_sSup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">Countable</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sSup</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">s</span>\n<span class=\"w\">  </span><span class=\"n\">isGLB_sInf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">Countable</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sInf</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">s</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Should <code>s : Set α</code> be implicit here?</p>",
        "id": 524466636,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1750170425
    },
    {
        "content": "<p>Doesn't matter, since I hope Pierre will write the lemmas <code>_root_.isLUB_σsSup {s : Set α} (hs : s.Countable) : IsLUB (sSup s) s</code> and alike <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 524467141,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1750170572
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> Not sure I understand that. How can we know that <code>s</code> is countable in this statement?</p>",
        "id": 524470506,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1750171535
    },
    {
        "content": "<p>Whoops, typo</p>",
        "id": 524470820,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1750171623
    },
    {
        "content": "<p>I really like the idea of having <code>s</code> implicit everywhere, it makes the writing so much lighter, thanks a lot <span class=\"user-mention\" data-user-id=\"634338\">@Michael Rothgang</span></p>",
        "id": 524471315,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1750171750
    },
    {
        "content": "<p>I'm making nice progress. Here is a sample as a trailer:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- `⊓` distributes over `⨆`. -/</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">inf_σsSup_eq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">Countable</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">⊓</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">⊓</span><span class=\"w\"> </span><span class=\"n\">sSup</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">gc_inf_himp</span><span class=\"bp\">.</span><span class=\"n\">isLUB_l_image</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">isLUB_σsSup</span><span class=\"w\"> </span><span class=\"n\">hs</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- `⊔` distributes over `⨅`. -/</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">sup_σsInf_eq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">Countable</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">⊔</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">⊔</span><span class=\"w\"> </span><span class=\"n\">sInf</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">gc_sdiff_sup</span><span class=\"bp\">.</span><span class=\"n\">isGLB_u_image</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">isGLB_σsInf</span><span class=\"w\"> </span><span class=\"n\">hs</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Still figuring out the structure. For <code>iSup</code>, is it fine if I make the assumption that I have countable index set? Here is what I have in mind:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BooleanSigmaAlgebra</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Countable</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>I feel slightly weird about assuming globally that <code>ι</code> is countable, but not <code>s</code> (I always give <code>hs : s.Countable</code> to my theorems and lemmas). Any input is most welcome.</p>",
        "id": 524482774,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1750175143
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"928941\">Pierre Quinton</span> <a href=\"#narrow/channel/113488-general/topic/Boolean.20sigma.20algebras.20and.20measure.20theory.20on.20them/near/524482774\">said</a>:</p>\n<blockquote>\n<p>For <code>iSup</code>, is it fine if I make the assumption that I have countable index set? Here is what I have in mind:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BooleanSigmaAlgebra</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Countable</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>I feel slightly weird about assuming globally that <code>ι</code> is countable, but not <code>s</code> (I always give <code>hs : s.Countable</code> to my theorems and lemmas)</p>\n</blockquote>\n<p>Looks exactly how I would expect it</p>",
        "id": 524484317,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1750175663
    },
    {
        "content": "<p>The book \"Introduction to Boolean algebra\" by Halmos' has a lot of statement on a Boolean algebra of the form</p>\n<p>If $\\{ p_i \\}$ is a family of elements in a Boolean algebra, then<br>\n\\begin{align*}<br>\n\\left( \\bigwedge_i p_i \\right)' = \\bigvee_i p_i'<br>\n\\end{align*}<br>\nThe equations are to be interpreted in the sense that if either term exists, then so does the other term and the two are equal.</p>\n<p>I really like such formulations, and I think it would translate nicely as the lemma (maybe the name should change)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">compl_GLB_LUB_compl</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">b</span><span class=\"bp\">ᶜ</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">ᶜ</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>It feels like this would help factorize a fair amount of code between <code>CompleteBooleanAlgebra</code> and my new <code>BooleanσAlgebra</code>. Also a lot of such results manipulating LUBs and GLBs would be very useful for proofs.</p>\n<p>What do you think of that?</p>",
        "id": 524664890,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1750238909
    },
    {
        "content": "<p>Sure! Generally using <code>IsLUB</code>/<code>IsGLB</code> is an underused great idea</p>",
        "id": 524666004,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1750239274
    },
    {
        "content": "<p>I'm trying to add the following (and similar results) to <code>BooleanAlgebra.lean</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">inf_LUB_iff</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">⊓</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">⊓</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">gc_inf_himp</span><span class=\"bp\">.</span><span class=\"n\">isLUB_l_image</span>\n</code></pre></div>\n<p>But <code>GaloisConnection.isLUB_l_image</code> is defined in <code>Mathlib.Order.GaloisConnection.Basic</code> and the problem is that if I try to import it, I get a cyclic import. I am not sure why exactly, and I don't really know what is the appropriate way to proceed. Any help would be most welcome.</p>",
        "id": 524687548,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1750247132
    },
    {
        "content": "<p>The answer is that <code>Order.GaloisConnection</code> should be split into one file about preorders/partial orders/linear orders/lattices, one file about boolean algebras, one file about...</p>",
        "id": 524688185,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1750247367
    },
    {
        "content": "<p>Then should I move BooleanAlgebra related things from <code>GaloisConnection</code> to <code>BooleanAlgebra.lean</code>? Or should I make that a separate file?</p>",
        "id": 524688911,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1750247672
    },
    {
        "content": "<p>A new file under <code>Order.BooleanAlgebra</code> is probably best</p>",
        "id": 524688977,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1750247699
    },
    {
        "content": "<p>So <code>mkdir</code> BooleanAlgebra in Order? I guess this is a bit of refactor to make things a bit cleaner. How about the following files in it:</p>\n<ul>\n<li>Defs.lean</li>\n<li>Basic.lean</li>\n<li>InfiniteLaws.lean</li>\n<li>CompleteBooleanAlgebra lean</li>\n</ul>\n<p>The last one would contain infinite laws on Boolean algebra and the only <code>BooleanAlgebra</code> related statement in <code>GaloisConnection</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">compl</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BooleanAlgebra</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BooleanAlgebra</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">gc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">GaloisConnection</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">GaloisConnection</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">compl</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">compl</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">compl</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">compl</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">dsimp</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">le_compl_iff_le_compl</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">gc</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">compl_le_iff_compl_le</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 524689776,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1750247996
    },
    {
        "content": "<p>What's an infinite law?</p>",
        "id": 524690184,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1750248121
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"928941\">Pierre Quinton</span> <a href=\"#narrow/stream/113488-general/topic/Boolean.20sigma.20algebras.20and.20measure.20theory.20on.20them/near/524687548\">said</a>:</p>\n<blockquote>\n<p>I'm trying to add the following (and similar results) to <code>BooleanAlgebra.lean</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">inf_LUB_iff</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">⊓</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">⊓</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">gc_inf_himp</span><span class=\"bp\">.</span><span class=\"n\">isLUB_l_image</span>\n</code></pre></div>\n<p>But <code>GaloisConnection.isLUB_l_image</code> is defined in <code>Mathlib.Order.GaloisConnection.Basic</code> and the problem is that if I try to import it, I get a cyclic import. I am not sure why exactly, and I don't really know what is the appropriate way to proceed. Any help would be most welcome.</p>\n</blockquote>\n<p>All the results of this form with LUBs and GLBs. I could also make that part of the Basic.lean</p>",
        "id": 524690457,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1750248200
    },
    {
        "content": "<p><code>CompleteBooleanAlgebra</code> should probably not be under <code>Order.BooleanAlgebra</code></p>",
        "id": 524690652,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1750248251
    },
    {
        "content": "<p>Pinging <span class=\"user-mention\" data-user-id=\"411579\">@Sam van G</span> who might be interested.</p>",
        "id": 524691232,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1750248421
    },
    {
        "content": "<p>I am a bit worried about backward compatibility on that. I want to avoid it as much as possible</p>",
        "id": 524693579,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1750249233
    },
    {
        "content": "<p>Actually, I just realized that the import problem comes from the import of <code>BooleanAlgebra</code> in <code>Set.Basic</code> with the following instance:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">instBooleanAlgebra</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BooleanAlgebra</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">inferInstance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BooleanAlgebra</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"n\">sup</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">∪</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">),</span>\n<span class=\"w\">    </span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">),</span>\n<span class=\"w\">    </span><span class=\"n\">lt</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">inf</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">∩</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">),</span>\n<span class=\"w\">    </span><span class=\"n\">bot</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">∅</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">compl</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·ᶜ</span><span class=\"o\">),</span>\n<span class=\"w\">    </span><span class=\"n\">top</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">univ</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">sdiff</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>\n<p>Do you think there is a way to move that in <code>BooleanAlgebra.lean</code>?</p>",
        "id": 524730198,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1750259504
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"400289\">@Artie Khovanov</span> was thinking about this</p>",
        "id": 524730697,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1750259634
    },
    {
        "content": "<p>For the original goal, I am planing on adding all of those (as soon as we fix this import issue):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- This is true of a Lattice</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">GLB_assoc</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hss</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- This is true of a Lattice</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">LUB_assoc</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hss</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">GLB_compl</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">b</span><span class=\"bp\">ᶜ</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">ᶜ</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">LUB_compl</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">b</span><span class=\"bp\">ᶜ</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">ᶜ</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">inf_LUB</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">⊓</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">⊓</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">gc_inf_himp</span><span class=\"bp\">.</span><span class=\"n\">isLUB_l_image</span><span class=\"w\"> </span><span class=\"n\">hs</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">LUB_inf</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">⊓</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">⊓</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">sup_GLB</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">⊔</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">⊔</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">gc_sdiff_sup</span><span class=\"bp\">.</span><span class=\"n\">isGLB_u_image</span><span class=\"w\"> </span><span class=\"n\">hs</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">GLB_sup</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">⊔</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">⊔</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">sdiff_LUB</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">LUB_sdiff</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">sdiff_GLB</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">GLB_sdiff</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">himp_LUB</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">⇨</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">⇨</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">LUB_himp</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">⇨</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">⇨</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">himp_GLB</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">⇨</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">⇨</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">GLB_himp</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">⇨</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">⇨</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I think they will be very practical for handling LUBs and GLBs and will make implementation of many things easier for <code>CompleteBooleanAlgebra</code> and <code>BooleanSigmaAlgebra</code>.</p>",
        "id": 524734196,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1750260702
    },
    {
        "content": "<p>You can split <code>Set.Basic</code> but tbh you probably end up duplicating API (i.e., proving facts once for set intersections and again for general joins)</p>",
        "id": 524735644,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1750261147
    },
    {
        "content": "<p>Actually, I think I can solve my cyclic import problem by simply splitting BooleanAlgebra into BooleanAlgebra.Basic and BooleanAlgebra.Defs. This is because I need the Set related import only for the proofs, and BooleanAlgebra is imported in Set.Basic only via the Defs.</p>\n<p>Is there any guide I should follow for this type of structure? Should I duplicate the docstrings? Is there one package that is structured like that and is considered a good target?</p>",
        "id": 524858540,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1750329750
    },
    {
        "content": "<p>This is the way that several other parts of mathlib are modelled so if it's a good fit for you then go for it! The module docstrings should probably be modified a bit, I would just duplicate the copyright headers unless you really want to go into the git history (which might involve going back to mathlib3 in this case, I can't remember) but the new module docstrings should reflect what's happening in the files. Any split PR like this (splitting a file) should be a one-off PR which does nothing else at all other than deleting the old files, creating the new files and modifying the module docstrings so that they're appropriate. This should then be followed up with a second PR tagged <code>easy</code> which deprecates the old file ie adds it back and just makes it import the new files and adds a deprecation line ensuring that anyone who tries to import it gets a warning rather than an error. For a reason I'm unclear about the preference of the community is currently to do this in a second PR.</p>",
        "id": 524862321,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1750331453
    },
    {
        "content": "<p>I would prioritise this split if you're convinced that it's the way forward because this should be done as the first step of this refactor.</p>",
        "id": 524862504,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1750331524
    },
    {
        "content": "<p>The reason for preferring a split is cleaner history and diffs: a PR moving a 1000-line file, but adding the deprecation looks like a 900 line deletion plus a 1000 line addition. (Yes, you can diff things locally, but this is extra effort. And this occurs every time a future contributor wants to check.) If you just move a file, you get a sane diff.</p>",
        "id": 524911688,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1750348017
    },
    {
        "content": "<p>I should also add there there is work on automating the second part, i.e. auto-generating such PRs.</p>",
        "id": 524911753,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1750348039
    },
    {
        "content": "<p>This is what I tried to do in <a href=\"https://github.com/leanprover-community/mathlib4/pull/26173\">#26173</a> . I moved <code>BooleanAlgebra.lean</code> to <code>BooleanAlgebra/Defs.lean</code>, then I created <code>BooleanAlgebra/Basic.lean</code> and moved all theorems there, I also adapted the docstrings. I don't know if I could have done it better to keep the git authorship.<br>\nLet me know if this looks fine.</p>",
        "id": 524922579,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1750352403
    },
    {
        "content": "<p>I am now working on the deprecation/warning when I create the file. One way to do that would be to create a dummy theorem which is deprecated. Is that the standard way of doing that? Is there a known example somewhere I can copy?</p>",
        "id": 524923682,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1750352983
    },
    {
        "content": "<p>You can copy <a href=\"https://tqft.net/mathlib4files/Topology/GDelta/UniformSpace\">file#Topology/GDelta/UniformSpace</a></p>",
        "id": 524924136,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1750353214
    },
    {
        "content": "<p>Done in <a href=\"https://github.com/leanprover-community/mathlib4/pull/26176\">#26176</a> , I cannot add the tag <code>easy</code>.</p>",
        "id": 524928264,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1750355460
    },
    {
        "content": "<p>Even if the tests were passing, I don't think that any of these PRs should be merged yet. I think they do not resolve the cyclic import problem. I am thinking about a solution, which could involve including part of the material that is currently in <code>Basic</code> into <code>Defs</code> to decrease the need to import <code>BooleanAlgebra.Basic</code> into other parts of <code>mathlib</code>.<br>\nIf anyone has an idea on something I could try, I'm all ears.</p>",
        "id": 524934609,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1750358972
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"928941\">Pierre Quinton</span> <a href=\"#narrow/channel/113488-general/topic/Boolean.20sigma.20algebras.20and.20measure.20theory.20on.20them/near/524928264\">said</a>:</p>\n<blockquote>\n<p>Done in <a href=\"https://github.com/leanprover-community/mathlib4/pull/26176\">#26176</a> , I cannot add the tag <code>easy</code>.</p>\n</blockquote>\n<p>Oh apologies, this is the new regime now.</p>",
        "id": 524949183,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1750367871
    },
    {
        "content": "<p>Does anyone know what failed in <a href=\"https://github.com/leanprover-community/mathlib4/pull/26176\">#26176</a> ? the error is a bit cryptic: <a href=\"https://github.com/leanprover-community/mathlib4/actions/runs/15773295542/job/44462125321?pr=26176\">https://github.com/leanprover-community/mathlib4/actions/runs/15773295542/job/44462125321?pr=26176</a></p>\n<p>If we fix it, then both <a href=\"https://github.com/leanprover-community/mathlib4/pull/26173\">#26173</a> and <a href=\"https://github.com/leanprover-community/mathlib4/pull/26176\">#26176</a> are ready.<br>\nI don't know if splitting a file in such Defs and Basic is generally a good idea, but I think it does not solve my problem as I may have to think the structure differently. So either we merge them or I will close them.</p>\n<p>Regarding the structure, I was working on this idea of being able to work with LUBs and GLBs, trying to get nice arithmetic on them (you can find them at the end of the message). There are few things worth noticing:</p>\n<ul>\n<li>Most are not dependent on BooleanAlgebras but can most likely be proven from semi lattices and (co)heyting algebras</li>\n<li>I think that this idea of being able to work with limit operations on spaces that may not be closed under all such operations is more general than that. For instance, I was exploring <code>LiminfLimsup</code> and it looks like the problem is the same there, they are defined on Dedekind complete lattices (ConditionallyCompleteLattice) even though the inf, sup, liminf, limsup and lim (characterized by existence of liminf, limsup and their equality) might exist in any partially ordered set.</li>\n<li>The way I define theorems was an attempt at making their usage nice, e.g., from a proof that something is a LUB, you can prove that something else is a LUB. My hope was that this would lead to a nice way to chain them to obtain composite results, but in the end it was a pain to use them to prove anything, so I think we should do better than that.</li>\n</ul>\n<p>Any idea/suggestion would be most welcome!</p>\n<p>Here are the theorems:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c\">/-</span>\n<span class=\"cm\">Copyright (c) 2025 Pierre Quinton. All rights reserved.</span>\n<span class=\"cm\">Released under Apache 2.0 license as described in the file LICENSE.</span>\n<span class=\"cm\">Authors: Pierre Quinton</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Order</span><span class=\"bp\">.</span><span class=\"n\">BooleanAlgebra</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Order</span><span class=\"bp\">.</span><span class=\"n\">Bounds</span><span class=\"bp\">.</span><span class=\"n\">Defs</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Order</span><span class=\"bp\">.</span><span class=\"n\">GaloisConnection</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BooleanAlgebra</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- SemilatticeSup</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">GLB_assoc</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hss</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- SemilatticeInf</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">LUB_assoc</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hss</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- BooleanAlgebra possibly HeytingAlgebra</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">GLB_compl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">b</span><span class=\"bp\">ᶜ</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">ᶜ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- BooleanAlgebra possibly CoheytingAlgebra</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">LUB_compl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">￢</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">￢</span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- HeytingAlgebra</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">inf_LUB</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">⊓</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">⊓</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">gc_inf_himp</span><span class=\"bp\">.</span><span class=\"n\">isLUB_l_image</span><span class=\"w\"> </span><span class=\"n\">hs</span>\n\n<span class=\"c1\">-- HeytingAlgebra</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">LUB_inf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">⊓</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">⊓</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp_rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">inf_comm</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">inf_LUB</span><span class=\"w\"> </span><span class=\"n\">hs</span>\n\n<span class=\"c1\">-- CoheytingAlgebra</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">sup_GLB</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">⊔</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">⊔</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">gc_sdiff_sup</span><span class=\"bp\">.</span><span class=\"n\">isGLB_u_image</span><span class=\"w\"> </span><span class=\"n\">hs</span>\n\n<span class=\"c1\">-- CoheytingAlgebra</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">GLB_sup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">⊔</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">⊔</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp_rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">sup_comm</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">sup_GLB</span><span class=\"w\"> </span><span class=\"n\">hs</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">sdiff_LUB</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- CoheytingAlgebra</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">LUB_sdiff</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">gc_sdiff_sup</span><span class=\"bp\">.</span><span class=\"n\">isLUB_l_image</span><span class=\"w\"> </span><span class=\"n\">hs</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">sdiff_GLB</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">GLB_sdiff</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">himp_LUB</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">⇨</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">⇨</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">LUB_himp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">⇨</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">⇨</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">himp_GLB</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">⇨</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">⇨</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">gc_inf_himp</span><span class=\"bp\">.</span><span class=\"n\">isGLB_u_image</span><span class=\"w\"> </span><span class=\"n\">hs</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">GLB_himp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">⇨</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">⇨</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">c</span><span class=\"bp\">ᶜ</span><span class=\"w\"> </span><span class=\"bp\">⊓</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">⊔</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">ᶜ</span><span class=\"w\"> </span><span class=\"bp\">⊓</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">⊔</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">LUB_inf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">LUB_compl</span><span class=\"w\"> </span><span class=\"n\">hs</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 525137914,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1750488344
    },
    {
        "content": "<p>The problem is that you added new files. You need to run the command <code>lake exe mk_all</code> to regenerate the import all files.</p>",
        "id": 525155047,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1750507687
    },
    {
        "content": "<p>I have opened a PR (<a href=\"https://github.com/leanprover-community/mathlib4/pull/26318\">#26318</a>) to add <code>BooleanσAlgebra</code>. For now it just provides the definition of <code>BooleanσAlgebra</code> and some instances. I tried to make every commit very atomic so that it is easy to review. I think that we can already probably improve both instances, my implementation might be inefficient.</p>\n<p>My plan is then to mimic a lot of results from <code>ConditionallyCompleteLattice</code> and <code>CompleteBooleanAlgebra</code> and add them in <code>Basic.lean</code>.</p>\n<p>Any comment or idea is most welcome.</p>\n<p>EDIT: Also, should I do everything in one PR as this is starting a new concept (to see if we do want to merge it in the end), or should I cut in smaller PRs (because we know we will eventually do it)?</p>",
        "id": 525379504,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1750699985
    },
    {
        "content": "<p>Between the two proofs of the second theorem:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">σSup_le_iff</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">Countable</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">sSup</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">isLUB_le_iff</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">isLUB_σsSup</span><span class=\"w\"> </span><span class=\"n\">hs</span><span class=\"o\">)</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">le_σsInf_iff</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">Countable</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">sInf</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"c1\">-- le_isGLB_iff (isGLB_σsInf hs)</span>\n<span class=\"w\">  </span><span class=\"n\">σSup_le_iff</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"bp\">ᵒᵈ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">hs</span>\n</code></pre></div>\n<p>There seems to be a tendency in Mathlib to prefer the first one (i.e. not the one by duality). Is there a good reason for that? It is tempting to state all dual proofs as such.</p>",
        "id": 525411483,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1750714981
    },
    {
        "content": "<p>To do the proof by duality you have to import duality</p>",
        "id": 525414125,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1750716714
    },
    {
        "content": "<p>In <code>ConditionallyCompleteLattice</code>, there is this result:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- `b &lt; sSup s` when there is an element `a` in `s` with `b &lt; a`, when `s` is bounded above.</span>\n<span class=\"sd\">This is essentially an iff, except that the assumptions for the two implications are</span>\n<span class=\"sd\">slightly different (one needs boundedness above for one direction, nonemptiness and linear</span>\n<span class=\"sd\">order for the other one), so we formulate separately the two implications, contrary to</span>\n<span class=\"sd\">the `CompleteLattice` case. -/</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">lt_csSup_of_lt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BddAbove</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">sSup</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">lt_of_lt_of_le</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">le_csSup</span><span class=\"w\"> </span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I think that in the case of a Boolean sigma algebra, conditioned on countability of <code>s</code>, this is supposed to be an equivalence, like for complete lattices. I could not find the corresponding result in <code>CompleteLattice</code>, does that ring a bell to anyone?</p>",
        "id": 525462007,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1750752215
    },
    {
        "content": "<p>Well, I think it is essentially this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">lt_isLUB_iff</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span>\n</code></pre></div>\n<p>EDIT:<br>\nActually this holds only in linear orders. In a Boolean algebra, it doesn't hold:<br>\nIf we have <code>x</code>, <code>y</code> and <code>z</code>, and we let <code>s={x, y, z}</code> as well as <code>b = x ⊔ y</code>, then we can have <code>b &lt; a</code> while <code>∃ c ∈ s, b &lt; c</code> would be false.</p>",
        "id": 525465528,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1750753429
    },
    {
        "content": "<p>Little update: I have introduced the intermediary concept of SigmaCompleteLattice to decompose better the responsabilities and match the structure of <code>CompleteBooleanAlgebra</code>.</p>\n<p>I also have the following question: In some cases, for a set <code>s</code>, there is a LUB. I think that in that case, we want <code>sSup s</code> to be that LUB. As an example, if <code>(h : IsGreatest s a)</code>, then <code>a</code> is the LUB of <code>s</code>, and we would like <code>sSup s</code> to equal <code>a</code>. I am therefore wondering about adding two statements to <code>SigmaCompleteLattice</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">isLUB_sSup_of_isLUB</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sSup</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">isGLB_sInf_of_isGLB</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sInf</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Is this the good way to proceed? Are the name correct? I didn't put the <code>σ</code> here as this is not related to countability. So the over <code>SigmaCompleteLattice</code> would be defined as</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">SigmaCompleteLattice</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">Lattice</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">SupSet</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">InfSet</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">isLUB_σsSup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">Countable</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sSup</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">isGLB_σsInf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">Countable</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sInf</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span>\n\n<span class=\"w\">  </span><span class=\"n\">isLUB_sSup_of_isLUB</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sSup</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">isGLB_sInf_of_isGLB</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sInf</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 525714826,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1750858587
    },
    {
        "content": "<p>I have a question that is a bit more general than the scope of this project.</p>\n<p>The type classes <code>SupSet α</code> and <code>InfSet α</code> define respectively the mapping <code>sSup : Set α → α</code> and <code>sInf : Set α → α</code>. The role of those mapping is to represent the suprema and infima of sets.<br>\nI am wondering why this is not enforced by any property. For instance, I think it would make sense to have statement stating that if there exists a LUB <code>a</code> on a set <code>s</code>, then <code>sSup s = a</code>.<br>\nThis would effectively enforce that if <code>s</code> has a supremum, then this supremum is <code>sSup</code>. Now if we think for instance of a <code>CompleteLattice</code>, then we only need to ensure that every set <code>s</code> has a LUB, and then this LUB is <code>sSup</code>.<br>\nIn <code>CompleteLattice</code> or in <code>ConditionallyCompleteLattice</code>, it doesn't make any difference as in the former, every suprema exist and in the later, they exists if and only if the set is bounded above and non-empty.<br>\nIn my case (SigmaCompleteLattice), I want to have a statement saying that the supremum of every countable set exists, but of course there could be many other set with some supremum (for instance, if <code>a</code> is the greatest element of <code>s</code>).<br>\nFor a <code>Lattice</code>, we could then prove that the infima and suprema of every finite collection exists and is <code>sSup</code> and <code>sInf</code>.</p>\n<p>Note that this formalism would also make it possible to have the functions <code>sSup</code> and <code>sInf</code> defined on <code>PartialOrder</code>, and in principle, we could prove some statement with them. For instance, on a <code>BooleanAlgebra</code>, we could prove<br>\nthen</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">inf_sSup_le_iSup_inf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">⊓</span><span class=\"w\"> </span><span class=\"n\">sSup</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">⨆</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">⊓</span><span class=\"w\"> </span><span class=\"n\">b</span>\n</code></pre></div>\n<p>which states that <code>⊓</code> distributes over <code>⨆</code>. Actually, I think we would also want a proof that <code>a ⊓ sSup s</code> is the LUB of <code>{a ⊓ b | b ∈ s}</code>.<br>\nAnyways, I am not sure if this is a good idea or if there was very specific to not have that, let me know if this makes (no) sense. I have attempted a structure for that:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">OrderSupSet</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">PartialOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">SupSet</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">isLUB_sSup</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sSup</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">OrderInfSet</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">PartialOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">InfSet</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">isGLB_sInf</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sInf</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">priority</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">100</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">PartialOrder</span><span class=\"bp\">.</span><span class=\"n\">toOrderSupSet</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PartialOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">OrderSupSet</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">sSup</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">choose</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">arbitrary</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">isLUB_sSup</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">priority</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">100</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">PartialOrder</span><span class=\"bp\">.</span><span class=\"n\">toOrderInfSet</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PartialOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">OrderInfSet</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">sInf</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">IsGLB</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">choose</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">arbitrary</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">isGLB_sInf</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>The last instance doesn't work (I am not used to working with choice), but I think it provides the intuition.</p>",
        "id": 526045818,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1751016655
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"928941\">Pierre Quinton</span> <a href=\"#narrow/channel/113488-general/topic/Boolean.20sigma.20algebras.20and.20measure.20theory.20on.20them/near/526045818\">said</a>:</p>\n<blockquote>\n<p>Anyways, I am not sure if this is a good idea or if there was very specific to not have that, let me know if this makes (no) sense.</p>\n</blockquote>\n<p>I am also not sure this is a good idea, do you have any specific use cases in mind?</p>",
        "id": 526054011,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751019753
    },
    {
        "content": "<p>I think it separates better where the results come from. Some results are essentially always, an example is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">IsGreatest</span><span class=\"bp\">.</span><span class=\"n\">csSup_eq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsGreatest</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">sSup</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>\n<p>In <code>ConditionallyCompleteLattice</code>. In <code>SigmaCompleteLattice</code>, such a result cannot be proven as <code>sSup</code> cannot be proven to be the supremum of <code>s</code> unless <code>s</code> is countable, but clearly here, <code>s</code> has a greatest element and therefore has a LUB, its just that this LUB is not provably <code>sSup s</code>.</p>\n<p>I think that some fair proportion of results of <code>CompleteLattice</code> and <code>ConditionallyCompleteLattice</code> can be factored as results on lattice with this structure.</p>\n<p>Later, I would also like to add the countable chain condition in combination with BooleanSigmaAlgebra. It states that any anti-chain is a most countable. This implies that the Boolean algebra is actually complete.</p>\n<p>In general, a structure that would factor results from <code>CompleteLattice</code>, <code>ConditionallyCompleteLattice</code> and <code>SigmaCompleteLattice</code> would feel less like repeating every statement three times, I think it would then typically reduce the probability of forgetting to change all three when we change one. Finally it satisfies a bit more the single responsibility principle. It would be weird to add such a structure to <code>SigmaCompleteLattice</code> even though it has nothing to do with sigma completeness.</p>",
        "id": 526067198,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1751025038
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"928941\">Pierre Quinton</span> <a href=\"#narrow/channel/113488-general/topic/Boolean.20sigma.20algebras.20and.20measure.20theory.20on.20them/near/526067198\">said</a>:</p>\n<blockquote>\n<p>In general, a structure that would factor results from <code>CompleteLattice</code>, <code>ConditionallyCompleteLattice</code> and <code>SigmaCompleteLattice</code> would feel less like repeating every statement three times, I think it would then typically reduce the probability of forgetting to change all three when we change one.</p>\n</blockquote>\n<p>That's what <code>IsGLB</code> and <code>IsLUB</code> are for, right?</p>",
        "id": 526067492,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751025173
    },
    {
        "content": "<p>Yes but in <code>SupSet</code>, it is said:</p>\n<blockquote>\n<p><code>sSup s</code> is the supremum of the set <code>s</code>;</p>\n</blockquote>\n<p>But this is not true if I only guarantee that <code>sSup s</code> is the supremum of <code>s</code> whenever <code>s</code> is countable. So it feels like we also want to guarantee that <code>sSup s</code> is the supremum of <code>s</code> whenever there is <code>a</code> such that <code>IsLUB s a</code>, right?</p>",
        "id": 526069377,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1751025845
    },
    {
        "content": "<p>Alright, I think I will try to push <code>BooleanSigmaAlgebra</code> and <code>SigmaCompleteLattice</code> as much as possible without this structure. If I get to some unconfortable things later, it will provide material to think about these things. I am therefore removing this from <code>SigmaCompleteLattice</code> in <a href=\"https://github.com/leanprover-community/mathlib4/pull/26318\">#26318</a></p>",
        "id": 526195664,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1751107859
    },
    {
        "content": "<p>Does any know a short proof that if <code>(hs : s.Countable)</code>, then <code>(s ∩ t).Countable</code>?</p>",
        "id": 526197780,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1751110183
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"928941\">Pierre Quinton</span> <a href=\"#narrow/channel/113488-general/topic/Boolean.20sigma.20algebras.20and.20measure.20theory.20on.20them/near/526197780\">said</a>:</p>\n<blockquote>\n<p>Does any know a short proof that if <code>(hs : s.Countable)</code>, then <code>(s ∩ t).Countable</code>?</p>\n</blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.Countable.mono#doc\">docs#Set.Countable.mono</a> along with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.inter_subset_left#doc\">docs#Set.inter_subset_left</a></p>",
        "id": 526202828,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751115870
    },
    {
        "content": "<p>Thank, I ended up using <code>mono</code> and <code>simp</code></p>",
        "id": 526203084,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1751116226
    },
    {
        "content": "<p>In <a href=\"https://github.com/leanprover-community/mathlib4/pull/26318/commits/4e926313a0984ab289e43e4d4a40a850b1699b1d\">https://github.com/leanprover-community/mathlib4/pull/26318/commits/4e926313a0984ab289e43e4d4a40a850b1699b1d</a> I have added a lot of theorems about <code>iSup</code> and <code>iInf</code>. I would appreciate some review, in particular on the countability assumptions that I make and if they make sense:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">SigmaCompleteLattice</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span>\n<span class=\"o\">[</span><span class=\"n\">Countable</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Countable</span><span class=\"w\"> </span><span class=\"n\">ι'</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Countable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">κ</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Countable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">κ'</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 526288736,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1751224148
    },
    {
        "content": "<p>The reason I am asking about my assumptions for the <code>iSup/iInf</code> theorems is that I am struggling with a proof which should probably easier. I have introduce this theorem</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">σsSup_eq_σiSup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">Countable</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">sSup</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">⨆</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">le_antisymm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">σsSup_le</span><span class=\"w\"> </span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"n\">le_σiSup₂</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">σiSup₂_le</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">le_σsSup</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>And the proof doesn't work, I am supposed to prove that <code>α</code> is countable which it might not be for <code>le_σiSup₂</code>. This proof is adapted from the corresponding theorem in <code>CompleteLattice</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">sSup_eq_iSup</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">sSup</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">⨆</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">le_antisymm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sSup_le</span><span class=\"w\"> </span><span class=\"n\">le_iSup₂</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">iSup₂_le</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">le_sSup</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>The prototype is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">le_σiSup₂</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">SigmaCompleteLattice</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Countable</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Countable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">κ</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">)]</span><span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">κ</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">κ</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"bp\">⨆</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">j</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span>\n</code></pre></div>\n<p>And in the application I want to have, I think that <code>ι</code> is supposed to be <code>α</code> and <code>κ i</code> is <code>i ∈ s</code>. Therefore there are uncountably many element in the <code>iSup</code>, but only countably many of those are different. I am not sure what I should do to my assumption to fix that, I guess this is only about all the theorems involving <code>σiSup₂</code> and <code>σiInf₂</code></p>",
        "id": 526351084,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1751273661
    },
    {
        "content": "<p>Hey Pierre, your PR and this thread are still on my radar, but I am still under the weather. You should receive a review from me in the next week or so</p>",
        "id": 526356971,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1751275388
    },
    {
        "content": "<p>Thanks, there is no rush, I will provide updates here on my progress and anyways there are many other things to do (I just have proven theorems about SigmaCompleteLattice but none about BooleanSigmaAlgebra), so take your time!</p>",
        "id": 526357314,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1751275497
    },
    {
        "content": "<p>Pierre did you already get warned about <a href=\"https://leanprover-community.github.io/extras/pitfalls.html#accidental-double-iinf-or-isup\">this gotcha</a> ? I wonder whether it affects you here. Maybe you want to just write <code>⨆ a : s, a</code> to avoid this?</p>",
        "id": 526423638,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1751295743
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  I was totally unaware of this, and somehow, I think this unblocked me quite a lot.</p>\n<p>Still, I think that <code>⨆ a ∈ s, a</code> should exist whenever <code>s.Countable</code> holds (currently it is not, but I think there might be a way):<br>\nNote that <code>⨆ a ∈ s, a</code> is shorthand for <code>⨆ (a : α), ⨆ (_ : a ∈ s), a</code>. For each <code>a</code> not in <code>s</code>,  <code>{a | ∃ _ : a ∈ s}</code> is empty (and therefore countable) and therefore  <code>⨆ (_ : a ∈ s), a</code> equals <code>⊥</code>.  On the other hand, if <code>a</code> is in <code>s</code>, then <code>{a | ∃ _ : a ∈ s}={a}</code> (which is countable) and so <code>⨆ (_ : a ∈ s), a = a</code>. Now if we write <code>f (a : α)</code> to be <code>a</code> if <code>a</code> is in <code>s</code> and <code>⊥</code>, then <code>{f a | a : α}</code> is contained in the union of <code>s</code> and <code>{⊥}</code>, which is therefore countable, so the <code>iSup</code> should exist.</p>\n<p>This hints that we should have a version of the iSup theorems based on the countability of the image of <code>f</code> instead.</p>\n<p>If that sounds reasonable to you, I will go for that!</p>",
        "id": 526440142,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1751300873
    },
    {
        "content": "<p>Aah yes, if there is a sensible answer for sup(empty set) then the gotcha won't apply to you (which is a relief).</p>",
        "id": 526444199,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1751302283
    },
    {
        "content": "<p>Well, for sure in a BooleanSigmaAlgebra there should be, but also, as the empty set is countable, it should have sSup and sInf, so those better be bot and top. It indicates that SigmaCompleteLattice should be a BoundedOrder. BTW, do you know any reason why CompleteLattice reimplements  the structure of BoundedOrder instead of extending it? Is there any reason I should do the same?</p>",
        "id": 526445407,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1751302761
    },
    {
        "content": "<p>Actually, I think that it is wrong (or rather inefficient) to assume in <code>CompleteLattice</code> the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"sd\">/-- Any element is less than the top one. -/</span>\n<span class=\"w\">  </span><span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"n\">le_top</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"bp\">⊤</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- Any element is more than the bottom one. -/</span>\n<span class=\"w\">  </span><span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"n\">bot_le</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">⊥</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>\n<p>Ina <code>CompleteLattice</code>, we can show that there exists a minimal element. For instance, we can use the GLB of the empty set and show that it is smaller than any element because of monotonicity of <code>sSup</code> applied to <code>∅</code> and any singleton <code>{a}</code>. We could then have an instance of <code>BoundedOrder</code> instead of assuming it. The exact same reasoning works for me as all involved sets are countable.</p>\n<p>My solution is the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">priority</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">100</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">SigmaCompleteLattice</span><span class=\"bp\">.</span><span class=\"n\">toBoundedOrder</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">SigmaCompleteLattice</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">BoundedOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">top</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">sInf</span><span class=\"w\"> </span><span class=\"bp\">∅</span>\n<span class=\"w\">  </span><span class=\"n\">bot</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">sSup</span><span class=\"w\"> </span><span class=\"bp\">∅</span>\n<span class=\"w\">  </span><span class=\"n\">le_top</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">isGLB_empty_iff</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">isGLB_σsInf</span><span class=\"w\"> </span><span class=\"bp\">∅</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">countable_empty</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"n\">bot_le</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">isLUB_empty_iff</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">isLUB_σsSup</span><span class=\"w\"> </span><span class=\"bp\">∅</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">countable_empty</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>\n<p>Which seems to work, I have made a PR (<a href=\"https://github.com/leanprover-community/mathlib4/pull/26574\">#26574</a>) with the same change to <code>CompleteLattice</code>. This introduced some errors that I struggle fixing, any help would be welcome.</p>",
        "id": 526523071,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1751344355
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 526524956,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1751346013
    },
    {
        "content": "<p>I don't know much about this corner of the library and am hoping that someone who does will chime in, but my guess is that the way it's set up the way it is is to give people more flexibility in choosing their bottom and top elements up to definitional equality, and that the change you're suggesting will not be desired because it removes this. In other words this is not a mathematical decision but a CS-related one. Your suggestion is making the typeclass system conjure data out of nowhere and definitional equality matters when it comes to data in the typeclass system.</p>",
        "id": 526539125,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1751353954
    },
    {
        "content": "<p>In other words, there are probably plenty of situations where although it might be a <em>theorem</em> that top = sInf empty, it might be very annoying (or even unworkable in practice) to have this as the <em>definition</em> of top, in your favourite complete lattice.</p>",
        "id": 526539437,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1751354069
    },
    {
        "content": "<p>I guess this is a synctatic choice rather than a semantic one? But still, it feels weird to constrain the definition of CompleteLattice because some type classes that extend it want to define their own top and bot. It feels like it should be the responsability of things that are CompleteLattices to define their top and bot element differently if they want. For instance, the powerset of X need not extend CompleteAlgebra if we want top to be X and bot to be the emptyset, it can then provide an instance of CompleteLattice and also some theorems to prove that the top and bot elements are really X and emptyset. I'm guessing the problem with that would be that we would have to use those theorems a lot, or even replicate most theorems about them?</p>",
        "id": 526542164,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1751355084
    },
    {
        "content": "<p>Yes, exactly. The <code>top</code> and <code>bot</code> fields are here to stay</p>",
        "id": 526548460,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1751357059
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"928941\">@Pierre Quinton</span> the real way to solve it is to make a custom constructor rather than changing the definition, because we sometimes definitely want a top/bot that is defeq to something and not defined to be the Inf/Sup of the empty set</p>",
        "id": 526566457,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751362570
    },
    {
        "content": "<p>for example, in ideals, bot is defeq to {x | x = 0}</p>",
        "id": 526566500,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751362591
    },
    {
        "content": "<p>I think I'm starting to get it, however I have one last question. If we take ideals for instance, we don't we have <code>sSup ∅={x | x = 0}</code>? Because if we did, then setting <code>bot</code> to <code>sSup ∅</code> would work right?</p>",
        "id": 526590029,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1751370619
    },
    {
        "content": "<p>We do have <code>sSup ∅ = {x | x = 0}</code>, but it's not a definitional equality</p>",
        "id": 526590230,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751370694
    },
    {
        "content": "<p>It feels like I am mixing several levels of abstraction, sorry about that.</p>",
        "id": 526590560,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1751370815
    },
    {
        "content": "<p>Definitional equality is when things are equal \"by definition\"</p>",
        "id": 526590604,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751370837
    },
    {
        "content": "<p>Do you know what definitional equality is? I can explain it a bit more if you want.</p>",
        "id": 526590654,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751370856
    },
    {
        "content": "<p>I think I am fine (after some reading). It is just not clear that I should do the same for SigmaCompleteLattices. For instance a sigma algebra is a SigmaCompleteLattice and I want to top to be the full set and the bot to be the empty set, so the problem seems to be the same.</p>",
        "id": 526591144,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1751371024
    },
    {
        "content": "<p>Let's say you define an instance of <code>CompleteLattice</code> on <code>WithTop Nat</code>.</p>",
        "id": 526591258,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751371072
    },
    {
        "content": "<p>Then coming from <code>∀ α, Top (WithTop α)</code> you get a top</p>",
        "id": 526591390,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751371125
    },
    {
        "content": "<p>and coming from <code>CompleteLattice (WithTop Nat)</code> you get another top</p>",
        "id": 526591432,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751371140
    },
    {
        "content": "<p>It's bad if they're not definitionally equal because then you can have goal like <code>⊤ = ⊤</code> that's not <code>rfl</code> because the tops are coming from different instances</p>",
        "id": 526591565,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751371196
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"928941\">@Pierre Quinton</span> It's not clear to me that you understand what defeq means</p>",
        "id": 526591882,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751371295
    },
    {
        "content": "<p>So we add a <code>top</code> field to <code>CompleteLattice</code> so that instead of the instance filling in <code>top := sInf ∅</code> for you, you can make it be the same one coming from <code>∀ α, Top (WithTop α)</code> instead (but then you have to prove it's the same top)</p>",
        "id": 526591897,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751371300
    },
    {
        "content": "<p>And if you want to fill in everything automatically you can still use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=completeLatticeOfCompleteSemilatticeSup#doc\">docs#completeLatticeOfCompleteSemilatticeSup</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=completeLatticeOfCompleteSemilatticeInf#doc\">docs#completeLatticeOfCompleteSemilatticeInf</a></p>",
        "id": 526592058,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751371347
    },
    {
        "content": "<p>This is the same reason we have copies like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Units.copy#doc\">docs#Units.copy</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RingHom.copy#doc\">docs#RingHom.copy</a></p>",
        "id": 526592796,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751371590
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/113488-general/topic/Boolean.20sigma.20algebras.20and.20measure.20theory.20on.20them/near/526591565\">said</a>:</p>\n<blockquote>\n<p>It's bad if they're not definitionally equal because then you can have goal like <code>⊤ = ⊤</code> that's not <code>rfl</code> because the tops are coming from different instances</p>\n</blockquote>\n<p>Alright, this made it very clear.</p>",
        "id": 526592814,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1751371596
    },
    {
        "content": "<p>[Quoting…]</p>\n<p>Yes, I was not clear with this, sorry about that.</p>",
        "id": 526593142,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1751371706
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"928941\">@Pierre Quinton</span> you need to pay attention when replacing data. replacing proofs is fine because of proof irrelevance, but for data we care about defeq</p>",
        "id": 526593389,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751371789
    },
    {
        "content": "<p>in fact we recently just had a refactor on complete lattices? does anyone remember which PR that was?</p>",
        "id": 526593637,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751371864
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"816344\">@Aaron Liu</span> do you remember?</p>",
        "id": 526593909,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751371958
    },
    {
        "content": "<p>I could take a look at complete lattice code and see the blame</p>",
        "id": 526594310,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751372100
    },
    {
        "content": "<p>but I don't remember</p>",
        "id": 526594332,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751372105
    },
    {
        "content": "<p>I found <a href=\"https://github.com/leanprover-community/mathlib4/pull/23064\">#23064</a> is this the one you're thinking of</p>",
        "id": 526594574,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751372181
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/113488-general/topic/Boolean.20sigma.20algebras.20and.20measure.20theory.20on.20them/near/526591258\">said</a>:</p>\n<blockquote>\n<p>Let's say you define an instance of <code>CompleteLattice</code> on <code>WithTop Nat</code>.</p>\n</blockquote>\n<p>Going back to this example, why doesn't lean require in this case to prove that the two defeq for tops are the same? Because it feels like when we view <code>α</code> as a <code>WithTop Nat</code>, we want the top to be defeq to the meaningfull top while when viewing <code>α</code> as a <code>CompleteLattice</code>, we could want that <code>top</code> to be defeq to <code>sInf ∅</code>. In a sense it still feels to me that the defeq of a type depends on the level of abstraction that we consider.</p>\n<p>Also, is there any reason that <code>CompleteLattice</code> does not extend <code>BoundedOrder</code> instead of defining <code>le_top</code> and <code>bot_le</code>?</p>",
        "id": 526595752,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1751372522
    },
    {
        "content": "<p>You can't prove things are defeq in Lean</p>",
        "id": 526595908,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751372568
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"928941\">Pierre Quinton</span> <a href=\"#narrow/stream/113488-general/topic/Boolean.20sigma.20algebras.20and.20measure.20theory.20on.20them/near/526595752\">said</a>:</p>\n<blockquote>\n<p>Also, is there any reason that <code>CompleteLattice</code> does not extend <code>BoundedOrder</code> instead of defining <code>le_top</code> and <code>bot_le</code>?</p>\n</blockquote>\n<p>I have no idea</p>",
        "id": 526595963,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751372588
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"928941\">@Pierre Quinton</span> it still really seems like you don't understand defeqs, lemme try to come up with an example for you to play with...</p>",
        "id": 526596812,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751372857
    },
    {
        "content": "<p>but before that, <span class=\"user-mention\" data-user-id=\"816344\">@Aaron Liu</span> <span class=\"user-mention\" data-user-id=\"928941\">@Pierre Quinton</span> I found the PR I was talking about: <a href=\"https://github.com/leanprover-community/mathlib4/pull/25909\">#25909</a> changed:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">CompleteBooleanAlgebra</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">CompleteLattice</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">BooleanAlgebra</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- `⊓` distributes over `⨆`. -/</span>\n<span class=\"w\">  </span><span class=\"n\">inf_sSup_le_iSup_inf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">⊓</span><span class=\"w\"> </span><span class=\"n\">sSup</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"bp\">⨆</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">⊓</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- `⊔` distributes over `⨅`. -/</span>\n<span class=\"w\">  </span><span class=\"n\">iInf_sup_le_sup_sInf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">⨅</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">⊔</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">⊔</span><span class=\"w\"> </span><span class=\"n\">sInf</span><span class=\"w\"> </span><span class=\"n\">s</span>\n</code></pre></div>\n<p>to:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">CompleteBooleanAlgebra</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">CompleteLattice</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">BooleanAlgebra</span><span class=\"w\"> </span><span class=\"n\">α</span>\n</code></pre></div>\n<p>because it turned out that the two axioms required were actually provable! and this does not create any issues, because we're replacing theorems rather than data</p>",
        "id": 526597286,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751373012
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">ext</span><span class=\"kd\">]</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Bot</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">bot</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"kn\">notation</span><span class=\"w\"> </span><span class=\"s2\">\"⊥\"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Bot</span><span class=\"bp\">.</span><span class=\"n\">bot</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">NatCast</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">CanonicalNatCast</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">NatCast</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Bot</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">bot_eq_zero</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⊥</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CanonicalNatCast</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⊥</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"c1\">-- fails!</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CanonicalNatCast</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⊥</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">⊥</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"c1\">-- succeeds!</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CanonicalNatCast</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">natCast</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"c1\">-- n ↦ { x | x &lt; n }</span>\n<span class=\"w\">  </span><span class=\"n\">bot</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"c1\">-- ⊥ := ∅ := { x | False }</span>\n<span class=\"w\">  </span><span class=\"n\">bot_eq_zero</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">funext</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">eq_false</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">not_lt_zero</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⊥</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">⊥</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- works!</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⊥</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"c1\">-- fails!</span>\n\n<span class=\"sd\">/-- This is the function you propose, which is bad. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">NatCast</span><span class=\"bp\">.</span><span class=\"n\">toCanonical</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NatCast</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CanonicalNatCast</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">bot</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">bot_eq_zero</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"c1\">-- attribute [instance] NatCast.toCanonical</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">diamond!</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⊥</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">    </span><span class=\"bp\">@</span><span class=\"n\">Bot</span><span class=\"bp\">.</span><span class=\"n\">bot</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">CanonicalNatCast</span><span class=\"bp\">.</span><span class=\"n\">toBot</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">self</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">NatCast</span><span class=\"bp\">.</span><span class=\"n\">toCanonical</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"c1\">-- ⊢ ⊥ = ⊥</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"c1\">-- doesn't work!</span>\n</code></pre></div>",
        "id": 526599092,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751373617
    },
    {
        "content": "<p>Ah yeah, I did that one!</p>",
        "id": 526599107,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1751373625
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"928941\">@Pierre Quinton</span> here's your example to play with</p>",
        "id": 526599116,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751373628
    },
    {
        "content": "<p>so, lemme explain in words</p>",
        "id": 526599178,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751373658
    },
    {
        "content": "<p>CanonicalNatCast means that there's a way to cast a natural number to the type, and that 0 is mapped to the bottom element</p>",
        "id": 526599230,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751373677
    },
    {
        "content": "<p>and our toy example here is <code>Nat -&gt; Prop</code>, which means <code>(Set ℕ)</code> (I didn't import Mathlib so I don't have those notations)</p>",
        "id": 526599320,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751373708
    },
    {
        "content": "<p>the way to cast the natural number n is to map it to { x | x &lt; n }</p>",
        "id": 526599366,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751373721
    },
    {
        "content": "<p>so 37 is mapped to {0, 1, 2, ..., 36}</p>",
        "id": 526599393,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751373728
    },
    {
        "content": "<p>and naturally there's a bottom element, which is the empty set!</p>",
        "id": 526599409,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751373738
    },
    {
        "content": "<p>if you try removing the Bot from the requirement (as you reasoned, \"obviously I can just set bot to be <code>f 0</code>!\"), then you'll get a diamond</p>",
        "id": 526599516,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751373772
    },
    {
        "content": "<p>(there should <em>technically</em> be a way to tweak my code to make them defeq, and this is left as an exercise to the reader <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span> )</p>",
        "id": 526600389,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751374059
    },
    {
        "content": "<p>Thanks a lot for the example, it helps. Actually my question was more about Lean itself than about Mathlib, so it shouldn't be asked here.</p>",
        "id": 526601715,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1751374477
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> Actually, another instance of exactly that problem is the fact that we could in principle define a CompleteLattice via only the infimums and deduce the supremum, but instead we define both and we can use <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Order/CompleteLattice/Defs.html#completeLatticeOfInf\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Order/CompleteLattice/Defs.html#completeLatticeOfInf</a> to do that if really needed. This completely answers my question because if we need the defeq of sup to be the one defined by an InfSet, then we could use <code>(completeLatticeOfInf [...]).sSup</code>.<br>\nSo I will do exactly the same thing for SigmaCompleteLattice.</p>",
        "id": 526636921,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1751384420
    },
    {
        "content": "<p>Coming back to the problem with iSup2 I had, I am thinking of doing the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">σiSup₂_le</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">κ</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">Countable</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hf₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">iSup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">Countable</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">⨆</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">j</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">σiSup_le</span><span class=\"w\"> </span><span class=\"n\">hf₂</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">σiSup_le</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf₁</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">i</span>\n</code></pre></div>\n<p>This works, but maybe <code>(hf₂ : {iSup (f i) | i}.Countable)</code> is not the cleanest way of assuming that there are at most countably <code>iSup</code>s.</p>",
        "id": 526681542,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1751403363
    },
    {
        "content": "<p>I made <code>CompleteLattice</code> extend <code>BoundedOrder</code> in <a href=\"https://github.com/leanprover-community/mathlib4/pull/26626\">#26626</a> in case that is a good idea.</p>",
        "id": 526778929,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1751455420
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"928941\">@Pierre Quinton</span> hmm, I don't immediately know why they didn't do that, let's see what others say</p>",
        "id": 526782418,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751456766
    },
    {
        "content": "<p>Now that I have these:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Countable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Countable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- ...</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">σiSup_le</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">⨆</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>\n<p>I want to prove the following lemma:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">σiSup₂_le</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">κ</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">Countable</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hf₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">iSup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">Countable</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">⨆</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">j</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">haveI</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Countable</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"bp\">⨆</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hf₂</span>\n<span class=\"w\">  </span><span class=\"n\">σiSup_le</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">haveI</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Countable</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hf₁</span><span class=\"w\"> </span><span class=\"n\">i</span>\n<span class=\"w\">    </span><span class=\"n\">σiSup_le</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">i</span>\n</code></pre></div>\n<p>The proof I provide is valid, but I feel like it is very inefficient, does any one have an idea on how to improve on it?</p>\n<p>Same question for this one:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">le_σiSup₂</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">κ</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">Countable</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hf₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">iSup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">Countable</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">κ</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"bp\">⨆</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">j</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">haveI</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Countable</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"bp\">⨆</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hf₂</span>\n<span class=\"w\">  </span><span class=\"n\">haveI</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Countable</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hf₁</span><span class=\"w\"> </span><span class=\"n\">i</span>\n<span class=\"w\">  </span><span class=\"n\">le_σiSup_of_le</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">le_σiSup</span><span class=\"w\"> </span><span class=\"n\">j</span>\n</code></pre></div>",
        "id": 527274541,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1751716446
    },
    {
        "content": "<p>I have managed to fix the  few problems that I had. I think this is already a pretty big PR and I did not start with <code>BooleanSigmaAlgebra</code> specific results yet, I have only ported results from <code>CompleteLattice</code> and <code>ConditionallycompleteLattice</code> to <code>SigmaCompleteLattice</code>. I am wondering if we should aim for a merge with the current results and add results specific to <code>BooleanSigmaAlgebra</code>s in another PR.</p>\n<p>In the meantime, I would appreciate some review on the assumptions and proofs of all theorems that involves <code>σiSup₂</code>. It feels like my assumptions are pretty heavy and I don't know how we could make all this lighter, for instance:<br>\n<a href=\"https://github.com/leanprover-community/mathlib4/pull/26318/files#diff-f7ca657929701ee4af7c14463fef9035e3528d414ccafda2402b82f24dd633adR85\">https://github.com/leanprover-community/mathlib4/pull/26318/files#diff-f7ca657929701ee4af7c14463fef9035e3528d414ccafda2402b82f24dd633adR85</a></p>",
        "id": 528989195,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1752647531
    },
    {
        "content": "<p>To make working with statement involving <code>⨆ (i : ι) (j : κ i), f i j</code>, I thought of assuming <code>[Countable (Σ i, κ i)]</code>. Note that as there are at most Countably many nonempty <code>κ i</code> and each of those have at most countably many elements, then we should be fine for the proofs in principle.</p>\n<p>The usage of <code>Sigma</code> involves typing <code>{ι : Type*} {κ : ι → Type*}</code> and <code>Type*</code> excludes <code>Prop</code> which would be very useful to have. We could work with <code>PSigma</code> but I think it would make everything complicated.</p>\n<p>I think this matter is a bit out of my skill set in Lean. Consider the illustration of the problem:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">Countable</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Countable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Sigma</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">Countable</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Countable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">PSigma</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Countable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Sigma</span><span class=\"w\"> </span><span class=\"n\">κ</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Countable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">κ</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">sigma_mk_injective</span><span class=\"bp\">.</span><span class=\"n\">countable</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Countable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">PSigma</span><span class=\"w\"> </span><span class=\"n\">κ</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Countable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">κ</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Countable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Sigma</span><span class=\"w\"> </span><span class=\"n\">κ</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Countable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Sigma</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">κ</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Countable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">PSigma</span><span class=\"w\"> </span><span class=\"n\">κ</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Countable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">PSigma</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">κ</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Countable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Sigma</span><span class=\"w\"> </span><span class=\"n\">κ</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">κ</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">⨆</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Countable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">PSigma</span><span class=\"w\"> </span><span class=\"n\">κ</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">κ</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">⨆</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>The first and fifth statements fail with a type error as <code>Prop</code> is not a <code>Type</code> but a <code>Sort</code> would work. The <code>PSigma</code> variant are valid, and they would work with <code>{ι : Sort*} {κ : ι → Sort*}</code> (instead of <code>Type*</code>), however in the documentation, it is said:</p>\n<blockquote>\n<p>In practice, this generality leads to universe level constraints that are difficult to solve, so <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Core.html#PSigma\">PSigma</a> is rarely used in manually-written code. It is usually only used in automation that constructs pairs of arbitrary types.</p>\n</blockquote>\n<p>I am therefore worried that it will be very hard to prove statements involving <code>PSigma</code>s (and when I tried, it was indeed rather difficult).</p>",
        "id": 529442119,
        "sender_full_name": "Pierre Quinton",
        "timestamp": 1752837420
    }
]