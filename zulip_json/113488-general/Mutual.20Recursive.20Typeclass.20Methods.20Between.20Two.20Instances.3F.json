[
    {
        "content": "<p>Is there any way to create two typeclass instances, each of which containing a function, with those functions being mutually recursive, without defining the functions in a mutual block outside the instances first?</p>",
        "id": 541088444,
        "sender_full_name": "Segev Elazar Mittelman",
        "timestamp": 1758657065
    },
    {
        "content": "<p>probably not</p>",
        "id": 541088766,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758657173
    },
    {
        "content": "<p>if the typeclass is an abbrev for a function then maybe</p>",
        "id": 541097232,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758660545
    },
    {
        "content": "<p>if the typeclass is a structure then no</p>",
        "id": 541097260,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758660552
    },
    {
        "content": "<p>What would a typeclass that is an abbrev for a function look like? Just a typeclass with a single function method and nothing else or do I have to use the abbrev keyword somewhere?</p>",
        "id": 541097590,
        "sender_full_name": "Segev Elazar Mittelman",
        "timestamp": 1758660680
    },
    {
        "content": "<p>I don't think that's legal, I think the following is what Aaron intended, but Lean complains:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">class</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n</code></pre></div>",
        "id": 541097974,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758660810
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=DecidableEq#doc\">docs#DecidableEq</a></p>",
        "id": 541097987,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758660817
    },
    {
        "content": "<p>is a typeclass</p>",
        "id": 541098006,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758660828
    },
    {
        "content": "<p>but also an abbrev for a function</p>",
        "id": 541098026,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758660837
    },
    {
        "content": "<p>Ah, and it supports mutual types right?</p>",
        "id": 541098085,
        "sender_full_name": "Segev Elazar Mittelman",
        "timestamp": 1758660862
    },
    {
        "content": "<p>no idea what that means</p>",
        "id": 541098122,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758660873
    },
    {
        "content": "<p>like mutual inductive types or</p>",
        "id": 541098161,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758660891
    },
    {
        "content": "<p>mutual recursion probably</p>",
        "id": 541098202,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758660908
    },
    {
        "content": "<p>oh</p>",
        "id": 541098213,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758660915
    },
    {
        "content": "<p>Sorry brain misfire, I'm thinking in the context of deriving DecidableEq, how do they derive it for mutually inductive types</p>",
        "id": 541098247,
        "sender_full_name": "Segev Elazar Mittelman",
        "timestamp": 1758660930
    },
    {
        "content": "<p>oh they don't</p>",
        "id": 541098261,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758660936
    },
    {
        "content": "<p>I don't think they do</p>",
        "id": 541098273,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758660944
    },
    {
        "content": "<p>not yet at least</p>",
        "id": 541098308,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758660957
    },
    {
        "content": "<p>But it should be possible since its an abbrev?</p>",
        "id": 541098355,
        "sender_full_name": "Segev Elazar Mittelman",
        "timestamp": 1758660971
    },
    {
        "content": "<p>there's basically not much support <span aria-label=\"tm\" class=\"emoji emoji-2122\" role=\"img\" title=\"tm\">:tm:</span> for anything \"mutual\" that you want to make</p>",
        "id": 541098366,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758660973
    },
    {
        "content": "<p>Ah that's trouble. I'm trying to derive some mutually dependent typeclasses via metaprogramming, one example being a typechecker mutually defined with a type inferrer.</p>",
        "id": 541098964,
        "sender_full_name": "Segev Elazar Mittelman",
        "timestamp": 1758661219
    },
    {
        "content": "<p>by metaprogramming do you mean \"I won't prove anything with my definitions\"?</p>",
        "id": 541099221,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758661311
    },
    {
        "content": "<p>That's not what I mean by it but I probably won't prove anything with these definitions. They're for use in a QuickChick style PBT library.</p>",
        "id": 541099474,
        "sender_full_name": "Segev Elazar Mittelman",
        "timestamp": 1758661417
    },
    {
        "content": "<p>The metaprogramming is for syntactically analyzing an inductive relation then extracting various functions from it.</p>",
        "id": 541099783,
        "sender_full_name": "Segev Elazar Mittelman",
        "timestamp": 1758661530
    },
    {
        "content": "<p>Btw, deriving DecidableEq does support mutual inductives, it just defines a mutual block of the decEq functions then later creates instances.</p>",
        "id": 541100698,
        "sender_full_name": "Segev Elazar Mittelman",
        "timestamp": 1758661911
    }
]