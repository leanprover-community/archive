[
    {
        "content": "<p>Is it possible to prove that <code>ℕ ≠ ℤ</code>?</p>",
        "id": 318612995,
        "sender_full_name": "Sabrina Jewson",
        "timestamp": 1672415889
    },
    {
        "content": "<p>What do you mean by that?</p>",
        "id": 318613092,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1672415933
    },
    {
        "content": "<p>Is it possible to fill in the <code>sorry</code> in this code?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">≠</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 318613195,
        "sender_full_name": "Sabrina Jewson",
        "timestamp": 1672415981
    },
    {
        "content": "<p>This question isn’t for any particular purpose, I just wondered if that’s a thing that can be done in Lean</p>",
        "id": 318613404,
        "sender_full_name": "Sabrina Jewson",
        "timestamp": 1672416027
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"574896\">Sabrina Jewson</span> <a href=\"#narrow/stream/113488-general/topic/Beginner.20Questions/near/318613195\">said</a>:</p>\n<blockquote>\n<p>Is it possible to fill in the <code>sorry</code> in this code?</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">≠</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>This is a good question that I, unfortunately, cannot answer.</p>",
        "id": 318613522,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1672416077
    },
    {
        "content": "<p>No, it's not possible.</p>",
        "id": 318613695,
        "sender_full_name": "Reid Barton",
        "timestamp": 1672416151
    },
    {
        "content": "<p>I was thinking about something different. You somehow identify <code>(1 : ℕ)</code> with <code>(1 : ℤ)</code> and <code>(2 : ℕ)</code> with <code>(2 : ℤ)</code> and so on and you want to show that there are elements of <code>ℤ</code> with no corresponding thing on the <code>ℕ</code> side.</p>",
        "id": 318613767,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1672416184
    },
    {
        "content": "<p>Which is not a claim about the sizes of the sets, but it speaks about a concrete embedding of natural numbers into integers.</p>",
        "id": 318613872,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1672416234
    },
    {
        "content": "<p>I was thinking about taking <code>N : set ℕ := λ n, true</code> and <code>Z : set ℤ := λ z, true</code> and then wanting to reason about <code>N</code> coerced to act like <code>set ℤ</code> instance.</p>",
        "id": 318614423,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1672416441
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113488-general/topic/Beginner.20Questions/near/318613695\">said</a>:</p>\n<blockquote>\n<p>No, it's not possible.</p>\n</blockquote>\n<p>Interesting — more generally, for which types <code>T</code> and <code>U</code> is it impossible to prove that <code>T ≠ U</code>? I discovered that I can easily do it for <code>empty ≠ ℕ</code> using <code>not_nonempty_iff</code>, so is it just possible for the empty/nonempty distinction or are they more ways?</p>",
        "id": 318614673,
        "sender_full_name": "Sabrina Jewson",
        "timestamp": 1672416525
    },
    {
        "content": "<p>I'd be first interested for which types <code>T</code> and <code>U</code> we can prove <code>T = U</code>. The identity relation is defined for all <code>Sort</code> levels, so it should a syntactically valid proposition.</p>",
        "id": 318614939,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1672416615
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"574896\">Sabrina Jewson</span> <a href=\"#narrow/stream/113488-general/topic/Beginner.20Questions/near/318614673\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113488-general/topic/Beginner.20Questions/near/318613695\">said</a>:</p>\n<blockquote>\n<p>No, it's not possible.</p>\n</blockquote>\n<p>Interesting — more generally, for which types <code>T</code> and <code>U</code> is it impossible to prove that <code>T ≠ U</code>?</p>\n</blockquote>\n<p>The only way is to prove that T and U have different cardinalities</p>",
        "id": 318615180,
        "sender_full_name": "Reid Barton",
        "timestamp": 1672416718
    },
    {
        "content": "<p>oh okay, that makes sense, let me try it</p>",
        "id": 318615306,
        "sender_full_name": "Sabrina Jewson",
        "timestamp": 1672416757
    },
    {
        "content": "<p>Okay got it working :D</p>",
        "id": 318616455,
        "sender_full_name": "Sabrina Jewson",
        "timestamp": 1672417181
    },
    {
        "content": "<p>Thanks for the advice, that’s very interesting</p>",
        "id": 318616473,
        "sender_full_name": "Sabrina Jewson",
        "timestamp": 1672417192
    },
    {
        "content": "<p>Can you please show us what you proved?</p>",
        "id": 318616602,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1672417224
    },
    {
        "content": "<p>I want to learn what can be done with types.</p>",
        "id": 318616625,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1672417234
    },
    {
        "content": "<p>I didn’t put effort into making my proof nice though, be warned :V</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"n\">c1</span>\n<span class=\"bp\">|</span> <span class=\"n\">c2</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">b</span>\n<span class=\"bp\">|</span> <span class=\"n\">c1</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n  <span class=\"k\">from</span> <span class=\"o\">⟨</span><span class=\"n\">a.c1</span><span class=\"o\">,</span> <span class=\"n\">a.c2</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"kd\">begin</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">contradiction</span> <span class=\"kd\">end</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">h</span> <span class=\"n\">at</span> <span class=\"n\">ha</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">ha</span> <span class=\"k\">with</span> <span class=\"n\">x</span> <span class=\"n\">ha</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">ha</span> <span class=\"k\">with</span> <span class=\"n\">y</span> <span class=\"n\">ha</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">eq</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n  <span class=\"n\">contradiction</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 318616857,
        "sender_full_name": "Sabrina Jewson",
        "timestamp": 1672417274
    },
    {
        "content": "<p>I prove first that <code>∃ x y : a, x ≠ y</code>, then substitute in <code>a</code> for <code>b</code>, then show that this is a contradiction (as all <code>b</code> values are equal)</p>",
        "id": 318617029,
        "sender_full_name": "Sabrina Jewson",
        "timestamp": 1672417334
    },
    {
        "content": "<p>You could also prove this by showing that the cardinality of a is 2 and the cardinality of b is 1. In general this is the only technique to prove that types are unequal in lean because the cardinality model of Lean's type theory would have all types of a given cardinality being type synonyms for a fixed type; in that model Nat does equal Int, which is why it's not possible to prove that they're unequal in lean</p>",
        "id": 318617496,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1672417473
    },
    {
        "content": "<p>So <code>ℕ = ℤ</code> can be proved?</p>",
        "id": 318617601,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1672417521
    },
    {
        "content": "<p>No. It just can't be disproved.</p>",
        "id": 318617629,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1672417536
    },
    {
        "content": "<p>Good.</p>",
        "id": 318617640,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1672417544
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/113488-general/topic/Beginner.20Questions/near/318614939\">said</a>:</p>\n<blockquote>\n<p>I'd be first interested for which types <code>T</code> and <code>U</code> we can prove <code>T = U</code>. The identity relation is defined for all <code>Sort</code> levels, so it should a syntactically valid proposition.</p>\n</blockquote>\n<p>..</p>",
        "id": 318617673,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1672417561
    },
    {
        "content": "<p>Trying to prove equality of types is \"evil\" in a precise sense. It's not the right question in Lean's type theory.</p>",
        "id": 318617819,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1672417616
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"574896\">Sabrina Jewson</span> <a href=\"#narrow/stream/113488-general/topic/Beginner.20Questions/near/318616857\">said</a>:</p>\n<blockquote>\n<p>I didn’t put effort into making my proof nice though, be warned :V</p>\n</blockquote>\n<p>I know that nobody asked and nobody cares, but this is my refactor of your proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">use</span> <span class=\"n\">a.c1</span><span class=\"o\">,</span> <span class=\"n\">use</span> <span class=\"n\">a.c2</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"n\">rw</span> <span class=\"n\">h</span> <span class=\"n\">at</span> <span class=\"n\">ha</span><span class=\"o\">,</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">ha</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">neq</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">neq</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 318618612,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1672417901
    },
    {
        "content": "<p>You taught me a new thing — equality between types can be used in <code>rw</code>.</p>",
        "id": 318618811,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1672417968
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/Beginner.20Questions/near/318617819\">said</a>:</p>\n<blockquote>\n<p>Trying to prove equality of types is \"evil\" in a precise sense. It's not the right question in Lean's type theory.</p>\n</blockquote>\n<p>Can someone tell us more than \"don't do it\" please?</p>",
        "id": 318618931,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1672418017
    },
    {
        "content": "<p>You can prove equalities of types in roughly three scenarios:</p>\n<ul>\n<li>The types are definitionally equal, i.e. if <code>def foo := nat</code> then <code>foo</code> and <code>nat</code> are provably equal.</li>\n<li>The types are built from the same inductive families applied to equal arguments, for example <code>fin (a + b)</code>  and <code>fin (b + a)</code> are equal because <code>a + b = b + a</code> and <code>fin</code> is a function (a type function, but a function nonetheless)</li>\n<li>There is a coincidence of different indices of an inductive family being equal because of cardinality considerations (roughly: cantor's theorem). That is, if you have an inductive family <code>inductive foo : set Type -&gt; Type</code> then it can't be injective because no such function can be.</li>\n</ul>",
        "id": 318619410,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1672418175
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">@[derive fintype]</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"n\">c1</span>\n<span class=\"bp\">|</span> <span class=\"n\">c2</span>\n\n<span class=\"kd\">@[derive fintype]</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">b</span>\n<span class=\"bp\">|</span> <span class=\"n\">c1</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"kd\">by</span> <span class=\"n\">obtain</span> <span class=\"o\">⟨⟩</span> <span class=\"o\">:</span> <span class=\"n\">fintype.card</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">fintype.card</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 318637989,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1672425740
    },
    {
        "content": "<p>I think this can be golfed, but I can't get rid of the <code>simp only</code> because the rewrite isn't type-correct.</p>",
        "id": 318638107,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1672425796
    },
    {
        "content": "<p>Golfing your proof using mathlib <code>rcases</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"n\">c1</span>\n<span class=\"bp\">|</span> <span class=\"n\">c2</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">b</span>\n<span class=\"bp\">|</span> <span class=\"n\">c1</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">hab</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">a.c1</span><span class=\"o\">,</span> <span class=\"n\">a.c2</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">a.no_confusion</span> <span class=\"n\">m</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">hab</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"o\">⟨⟨⟩,</span> <span class=\"o\">⟨⟩,</span> <span class=\"n\">h</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 318643000,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1672428053
    },
    {
        "content": "<p>Lean 4 has <code>rcases</code> in <code>Std</code> so you don't need to use mathlib to have access to it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std.Tactic.RCases</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"n\">c1</span>\n<span class=\"bp\">|</span> <span class=\"n\">c2</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">b</span>\n<span class=\"bp\">|</span> <span class=\"n\">c1</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">hab</span>\n  <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">a.c1</span><span class=\"o\">,</span> <span class=\"n\">a.c2</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a.noConfusion</span> <span class=\"n\">m</span><span class=\"o\">⟩</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hab</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"o\">⟨⟨⟩,</span> <span class=\"o\">⟨⟩,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 318643565,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1672428293
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/Beginner.20Questions/near/318617819\">said</a>:</p>\n<blockquote>\n<p>Trying to prove equality of types is \"evil\" in a precise sense. It's not the right question in Lean's type theory.</p>\n</blockquote>\n<p>Note that it can be interesting to prove equality of types (or lemmas that let you rewrite one type into the other) When writing functions though. For example when we are operating on length indexed lists and there is two different arithmetic expression in the length index of two lists and we would like to say zip it with a function of type <code>List a n -&gt; List b n -&gt; List (Prod a b) n</code> it can be interesting to prove that the types of the two lists are in fact equal by showing that the two arithmetic expressions in their indices match up.</p>",
        "id": 318668585,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1672443638
    },
    {
        "content": "<p>Precisely this sort of problem, when the two naturals aren't definitionally equal, was a genuine issue with category theory in LTE. We have had to develop tools such as <code>eq_to_hom</code> and <code>eq_to_iso</code> to manage the stuck <code>eq.rec</code> terms.</p>",
        "id": 318676372,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1672449968
    },
    {
        "content": "<p>I proved they weren't equal in term mode in Lean 4:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"n\">c1</span>\n<span class=\"bp\">|</span> <span class=\"n\">c2</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">b</span>\n<span class=\"bp\">|</span> <span class=\"n\">c1</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">hab</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">xₐ</span> <span class=\"n\">yₐ</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">xₐ</span> <span class=\"bp\">≠</span> <span class=\"n\">yₐ</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">a.c1</span><span class=\"o\">,</span> <span class=\"n\">a.c2</span><span class=\"o\">,</span> <span class=\"n\">a.noConfusion</span><span class=\"o\">⟩</span>\n  <span class=\"k\">have</span> <span class=\"n\">hb</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x'</span> <span class=\"n\">y'</span> <span class=\"o\">:</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">x'</span> <span class=\"bp\">≠</span> <span class=\"n\">y'</span> <span class=\"o\">:=</span> <span class=\"n\">hab</span> <span class=\"bp\">▸</span> <span class=\"n\">h</span>\n  <span class=\"n\">hb.casesOn</span> <span class=\"bp\">λ</span> <span class=\"o\">⟨⟩</span> <span class=\"o\">⟨⟨⟩,</span> <span class=\"n\">hxy</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">hxy</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 318676389,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1672450010
    },
    {
        "content": "<p>The equality in Lean is \"underspecified\", i.e. we don't determine everything with the current rules and axioms. A few ways to specify that are</p>\n<ul>\n<li>Add the ability to pattern match on types, which gives us a no-confusion thing. This sort of makes the universe an inductive type.</li>\n<li>Univalence.</li>\n<li>Something in the style of observational type theory. This sort of makes the universe a coinductive type.</li>\n</ul>",
        "id": 318681080,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1672454786
    },
    {
        "content": "<p>A quick way to see if something cannot be proved in Lean, is to look at these three possibilities. If they disagree then the proposition can't be proved or disproved. (For the N=Z thing, the result is \"false, true, depends\", so you know you can't prove or disprove it)</p>",
        "id": 318681324,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1672455043
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/Beginner.20Questions/near/318676372\">said</a>:</p>\n<blockquote>\n<p>Precisely this sort of problem, when the two <code>n</code>s aren't definitionally equal, was a genuine issue with category theory in LTE. We have had to develop tools such as <code>eq_to_hom</code> and <code>eq_to_iso</code> to manage the stuck <code>eq.rec</code> terms.</p>\n</blockquote>\n<p>In graph theory, we don't have the luxury of identity morphisms, so we instead had to develop tools like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/simple_graph.walk.copy\">docs#simple_graph.walk.copy</a></p>\n<p>This was recently added to category theory as <a href=\"https://leanprover-community.github.io/mathlib_docs/find/quiver.hom.cast\">docs#quiver.hom.cast</a> for work on quivers, which can't in general just use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.eq_to_hom\">docs#category_theory.eq_to_hom</a></p>",
        "id": 318756874,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1672502384
    },
    {
        "content": "<p>It seems to be a good dependent types design pattern to write a custom <code>eq.rec</code> that's specifically for rewriting indices in type constructors, to \"cast\" terms of the type to terms of an equal type in a more controlled way. For example, having a <code>cast</code> function to rewrite the length of a length-indexed list types.</p>",
        "id": 318757220,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1672502559
    },
    {
        "content": "<p>Informally, I might try to prove that <code>ℕ ≠ ℤ</code> by observing that <code>-1 ∈ ℤ</code> and that <code>-1 ∉ ℕ</code>. Is this not a correct proof / is this not possible in Lean?</p>",
        "id": 318783649,
        "sender_full_name": "Tyler Josephson ⚛️",
        "timestamp": 1672522005
    },
    {
        "content": "<p>That's just a syntax error in lean: for <code>a \\mem b</code> to typecjeck b must be a term of type <code>set something</code></p>",
        "id": 318786525,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1672524580
    },
    {
        "content": "<p>You could interpret this as showing <code>set.Ici (0 : ℤ) ≠ set.univ</code>, but that certainly isn't showing <code>ℕ ≠ ℤ</code>.</p>",
        "id": 318787529,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1672525433
    },
    {
        "content": "<p>I spent an embarrassingly long time trying to prove that <code>ℕ ≠ ℤ</code> and I now think that it is unlikely that such a proof is possible in Lean. Here's why I think that:<br>\nNatural numbers and integers have the same cardinality, so there is some bijection <code>nat_to_int</code> between them. We choose such a bijection (preferably one where <code>nat_to_int (0 : ℕ) = (0 : ℤ)</code>). We can now define the <code>ℤ</code> equivalent of <code>nat.succ</code> by converting from int to nat, adding 1, then converting back. I call this new function <code>new_succ</code>. It has type <code>ℤ -&gt; ℤ</code>.<br>\nAn important fact about natural numbers is that every natural number is expressible as <code>nat.succ</code> applied some amount of times to <code>nat.zero</code>. Now with our new function, every integer is expressible as <code>new_succ</code> applied some amount of times to <code>(0 : ℤ)</code>. I can prove this by showing that the recursor for natural numbers also holds true for integers:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Lots of code</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">set_theory.cardinal.basic</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">cardinality_equal</span> <span class=\"o\">:</span> <span class=\"n\">cardinal.mk</span> <span class=\"n\">ℕ</span> <span class=\"bp\">=</span> <span class=\"n\">cardinal.mk</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span>\n<span class=\"n\">eq.trans</span> <span class=\"n\">cardinal.mk_nat</span> <span class=\"n\">cardinal.mk_int.symm</span>\n<span class=\"kd\">def</span> <span class=\"n\">nat_to_int_conversion_exists</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">ℕ</span> <span class=\"bp\">≃</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">quotient.exact</span> <span class=\"n\">cardinality_equal</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">nat_to_int_conversion</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">≃</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span> <span class=\"n\">classical.choice</span> <span class=\"n\">nat_to_int_conversion_exists</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">nat_to_int</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span> <span class=\"n\">nat_to_int_conversion.to_fun</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">int_to_nat</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">nat_to_int_conversion.inv_fun</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">nat_to_int_left_inv</span> <span class=\"o\">:</span> <span class=\"n\">function.left_inverse</span> <span class=\"n\">int_to_nat</span> <span class=\"n\">nat_to_int</span> <span class=\"o\">:=</span>\n<span class=\"n\">nat_to_int_conversion.left_inv</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">nat_to_int_right_inv</span> <span class=\"o\">:</span> <span class=\"n\">function.right_inverse</span> <span class=\"n\">int_to_nat</span> <span class=\"n\">nat_to_int</span> <span class=\"o\">:=</span>\n<span class=\"n\">nat_to_int_conversion.right_inv</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">new_succ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">nat_to_int</span> <span class=\"o\">((</span><span class=\"n\">int_to_nat</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">int.new_rec</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">},</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">nat_to_int</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">),</span> <span class=\"n\">motive</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">new_succ</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">),</span> <span class=\"n\">motive</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">motive</span> <span class=\"n\">base_case</span> <span class=\"n\">ind_case</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">set</span> <span class=\"n\">motive'</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">nat_to_int</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"n\">hmot</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">base_case'</span> <span class=\"o\">:</span> <span class=\"n\">motive'</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">hmot</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">base_case</span> <span class=\"o\">},</span>\n  <span class=\"k\">have</span> <span class=\"n\">ind_case'</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">motive'</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">motive'</span> <span class=\"n\">n.succ</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">intros</span> <span class=\"n\">k</span> <span class=\"n\">prev_step</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">hmot</span> <span class=\"n\">at</span> <span class=\"bp\">⊢</span> <span class=\"n\">prev_step</span><span class=\"o\">,</span>\n    <span class=\"n\">specialize</span> <span class=\"n\">ind_case</span> <span class=\"o\">(</span><span class=\"n\">nat_to_int</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"n\">prev_step</span><span class=\"o\">,</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">new_succ</span> <span class=\"n\">at</span> <span class=\"n\">ind_case</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">nat_to_int_left_inv</span> <span class=\"n\">k</span> <span class=\"n\">at</span> <span class=\"n\">ind_case</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">ind_case</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">nat.rec</span> <span class=\"n\">motive'</span> <span class=\"n\">base_case'</span> <span class=\"n\">ind_case'</span> <span class=\"o\">(</span><span class=\"n\">int_to_nat</span> <span class=\"n\">n</span><span class=\"o\">),</span>\n  <span class=\"n\">rw</span> <span class=\"n\">hmot</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">nat_to_int_right_inv</span> <span class=\"n\">n</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n</div></div>\n<p>Note how <code>int.new_rec</code> basically has the same type as <code>nat.rec</code>, except we have <code>int</code> instead of <code>nat</code> and <code>new_succ</code> instead of <code>nat.succ</code>. We also have <code>nat_to_int 0</code> instead of <code>0</code> but it would be <code>(0 : ℤ)</code> if I chose a more convenient bijection. Since every proof about natural numbers essentially boils down to a bunch of <code>nat.zero</code>, <code>nat.succ</code>, and <code>nat.rec</code> calls, any proof about the natural numbers can be translated to a proof about the integers simply by replacing all instances of <code>nat.succ</code> with <code>new_succ</code>, etc. (well, at least I think it can, I don't know if it has the same definitional equalities).</p>\n<p>Since every proof about natural numbers can be translated to an equivalent proof about integers, there's no way to prove <code>ℕ ≠ ℤ</code> because then that proof could be translated to <code>ℤ ≠ ℤ</code> by doing the substitution described above.</p>\n<p>I'm not entirely sure if my argument is sound, but it made sense in my head at least.</p>",
        "id": 318912066,
        "sender_full_name": "Niels Voss",
        "timestamp": 1672612207
    },
    {
        "content": "<p>You could have believed Reid :)</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113488-general/topic/Beginner.20Questions/near/318613695\">said</a>:</p>\n<blockquote>\n<p>No, it's not possible.</p>\n</blockquote>",
        "id": 318913817,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1672613788
    },
    {
        "content": "<p>I figured as much, I just wanted to see if I could justify why to myself</p>",
        "id": 318913888,
        "sender_full_name": "Niels Voss",
        "timestamp": 1672613872
    },
    {
        "content": "<p>I'm not sure your argument is sound. If your argument is correct, wouldn't it <em>prove</em> that $\\mathbb{Z} = \\mathbb{N}$, by translating one side of the true statement $\\mathbb{N} = \\mathbb{N}$?</p>",
        "id": 318915981,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1672616155
    },
    {
        "content": "<p>No, because there's no way in Lean to make a function that takes some arbitrary proof and substitutes all instances of <code>nat.succ</code> with <code>new_succ</code>, etc. The rules of Lean don't really allow it, and the closest would could get is a tactic. My argument is necessarily meta-theoretic. Assuming I didn't make a mistake in my reasoning, it would only prove that equality of types is independent of the axioms, and neither prove nor disprove it.<br>\nOn the other hand, I'm not entirely sure my argument is watertight either because I don't really have a great understanding of type theory and there might be some detail I missed that would make it impossible to translate all proofs (something like the computation rule not getting translated).</p>",
        "id": 318917095,
        "sender_full_name": "Niels Voss",
        "timestamp": 1672617461
    },
    {
        "content": "<p>8 messages were moved here from <a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/stream/113488-general/topic/Beginner.20Questions\">#general &gt; Beginner Questions</a> by <span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span>.</p>",
        "id": 318927320,
        "sender_full_name": "Notification Bot",
        "timestamp": 1672627841
    },
    {
        "content": "<p>41 messages were moved here from <a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/stream/113488-general/topic/Beginner.20Questions\">#general &gt; Beginner Questions</a> by <span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span>.</p>",
        "id": 318927448,
        "sender_full_name": "Notification Bot",
        "timestamp": 1672628030
    }
]