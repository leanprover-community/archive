[
    {
        "content": "<p>why this raise an error?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">empty</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">children</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Tree</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">))</span>\n<span class=\"c\">/-</span><span class=\"cm\"> None of the deriving handlers for class `DecidableEq` applied to Tree -/</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">BEq</span>\n</code></pre></div>",
        "id": 543065788,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1759561418
    },
    {
        "content": "<p>Because <code>Tree</code> is a nested inductive type so it's quite a bit more complicated to automatically derive a <code>DecidableEq</code> (or anything that recurses over it for that matter)</p>",
        "id": 543075838,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1759572241
    },
    {
        "content": "<p>but we can derive BEq. why?</p>",
        "id": 543075873,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1759572275
    },
    {
        "content": "<p>Most likely because <code>BEq</code> is not proof carrying so getting it done is quite a lot easier. It's most likely not the case that deriving <code>DecidableEq</code> is actually impossible, it's just hard.</p>",
        "id": 543075924,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1759572327
    },
    {
        "content": "<p>The derived <code>BEq</code> uses <code>partial</code> here. That would be silly for <code>DecidableEq</code>.</p>",
        "id": 543154250,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1759661916
    },
    {
        "content": "<p>Would it? <code>DecidableEq</code> is for more than just <code>decide</code></p>",
        "id": 543155680,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1759663666
    },
    {
        "content": "<p>I feel like it should still be possible to systematically derive a <code>DecidableEq</code> here</p>",
        "id": 543156274,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1759664353
    },
    {
        "content": "<p>how does it work normally?</p>",
        "id": 543156276,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1759664361
    },
    {
        "content": "<p>Hmm, ok, maybe silly is a strong word. So you say a <code>partial</code> definition that doesn't work with <code>by decide</code> or with kernel reduction of <code>if</code> would still be more useful than unhelpful?</p>",
        "id": 543156572,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1759664786
    },
    {
        "content": "<p>(it is maybe unfortunate that the same type class is used both for kernel reduction and compiled code)</p>",
        "id": 543156631,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1759664843
    },
    {
        "content": "<p>I would argue that decidable instances are still sometimes a good idea even if they are neither reducible nor executable!</p>",
        "id": 543172676,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1759681286
    },
    {
        "content": "<p>If you want something that's neither reducible nor executable, wouldn't then <code>Classical.propDecidable</code> serve your purpose?</p>",
        "id": 543184377,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1759689469
    },
    {
        "content": "<p>having an instance makes lean not complain about failure to synthesize. However, if you use <code>open Classical</code>, the instance synthesis might not give you the decidability instance you want in unrelated cases (possibly in the same declaration, making <code>open in</code> not a feasible alternative). Therefore there <em>is</em> benefit, however small</p>",
        "id": 543190565,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1759695550
    },
    {
        "content": "<p>that aside, maybe this just means that someone needs to look into/spend time writing a non-<code>partial</code> deriver for <code>DecidableEq</code> for mutual/nested inductives...</p>",
        "id": 543190693,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1759695653
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/channel/113488-general/topic/DecidableEq.20for.20Tree/near/543190565\">said</a>:</p>\n<blockquote>\n<p>having an instance makes lean not complain about failure to synthesize. However, if you use <code>open Classical</code>, the instance synthesis might not give you the decidability instance you want in unrelated cases (possibly in the same declaration, making <code>open in</code> not a feasible alternative). Therefore there <em>is</em> benefit, however small</p>\n</blockquote>\n<p>but if that's the case then you can just register the instance but make the implementation be <code>Classical.propDecidable</code>, right? (mathlib does this for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Real.decidableEq#doc\">docs#Real.decidableEq</a>)</p>",
        "id": 543190998,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1759696034
    },
    {
        "content": "<p>I guess I should clarify that while registering the instance is a good idea in that case, indeed there would be little value in deriving it</p>",
        "id": 543193730,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1759699352
    }
]