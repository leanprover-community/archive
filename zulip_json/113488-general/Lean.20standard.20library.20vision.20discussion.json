[
    {
        "content": "<p>This is a discussion thread for <a class=\"stream-topic\" data-stream-id=\"113486\" href=\"/#narrow/channel/113486-announce/topic/The.20Lean.20standard.20library.3A.20vision.20and.20call.20for.20contributions\">#announce &gt; The Lean standard library: vision and call for contributions</a></p>",
        "id": 496074155,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1737970754
    },
    {
        "content": "<p>Nitpick, but shouldn't</p>\n<blockquote>\n<p>we are mostly interested in contributions that expand upon existing material rather than introducing novel concepts</p>\n</blockquote>\n<p>rather read</p>\n<blockquote>\n<p>we are mostly interested in contributions that expand upon existing material rather than introduce novel concepts</p>\n</blockquote>",
        "id": 496083929,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1737972467
    },
    {
        "content": "<p>In terms of the practicality of actually contributing to <code>Std</code>:</p>\n<p>With Batteries, I can check out the repo, run <code>lake build</code>, and things are ready to go in a minute or so. With Mathlib, the same is true thanks to <code>cache get</code>. When I've made contributions to Lean 4 itself, I've found it often takes more than 15 minutes to get to a point where I have a lean server running, as everything has to be built from scratch. </p>\n<p>Are there tricks to shortcut such a cold build? Is this a place where nix can help?</p>",
        "id": 496084745,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1737972739
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/113488-general/topic/Lean.20standard.20library.20vision.20discussion/near/496083929\">said</a>:</p>\n<blockquote>\n<p>Nitpick, but shouldn't</p>\n<blockquote>\n<p>we are mostly interested in contributions that expand upon existing material rather than introducing novel concepts</p>\n</blockquote>\n<p>rather read</p>\n<blockquote>\n<p>we are mostly interested in contributions that expand upon existing material rather than introduce novel concepts</p>\n</blockquote>\n</blockquote>\n<p>I'm not a native speaker, but <a href=\"https://kagi.com/search?q=rather+than+gerund&amp;r=no_region&amp;sh=eF8_I7VwKMg4EdiRcuDcNQ\">a quick internet search</a> seems to suggest that both are correct.</p>",
        "id": 496085070,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1737972856
    },
    {
        "content": "<p>I think it's a very minor stylistic point; as a native speaker \"contributing/ introducing\" or \"contribute /  introduce\"  would both be fine, but the mixture is very slightly imbalanced. I think there are more interesting things to discuss about Std though!</p>",
        "id": 496085694,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1737973083
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/113488-general/topic/Lean.20standard.20library.20vision.20discussion/near/496084745\">said</a>:</p>\n<blockquote>\n<p>Are there tricks to shortcut such a cold build? Is this a place where nix can help?</p>\n</blockquote>\n<p>I'm not aware of anyone working on something like stage1 olean caching. stage0 benefits from C being generally fast to compile and high <code>ccache</code> hit rates, but as far as I am aware at present the main way to get fast stage1 builds is a beefy machine.</p>",
        "id": 496086699,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1737973419
    },
    {
        "content": "<p>Perhaps I didn't configure ccache correctly in the gitpod config; or maybe the cache only ends up hot if you're working on Lean full time!</p>",
        "id": 496087208,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1737973558
    },
    {
        "content": "<p>I'm curious, what's the difference between \"software verification and verified software development\" (referenced in the visiou? what's an example of one vs. the other?</p>",
        "id": 496093724,
        "sender_full_name": "Somo S.",
        "timestamp": 1737975523
    },
    {
        "content": "<p>By \"verified software development\" I mean writing a piece of software in Lean and then proving (in Lean) that it is correct. An example of this is the <a href=\"https://github.com/cedar-policy/cedar-spec\">Cedar project</a>. By software verification I mean using a tool like <a href=\"https://github.com/AeneasVerif/aeneas\">Aeneas</a> to prove in Lean that a piece of software written in a different programming language is correct.</p>",
        "id": 496095170,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1737976003
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/113488-general/topic/Lean.20standard.20library.20vision.20discussion/near/496084745\">said</a>:</p>\n<blockquote>\n<p>In terms of the practicality of actually contributing to <code>Std</code>:</p>\n<p>With Batteries, I can check out the repo, run <code>lake build</code>, and things are ready to go in a minute or so. With Mathlib, the same is true thanks to <code>cache get</code>. When I've made contributions to Lean 4 itself, I've found it often takes more than 15 minutes to get to a point where I have a lean server running, as everything has to be built from scratch. </p>\n</blockquote>\n<p>For small contributions, I think it's a good idea to stage into Batteries first. In addition to fast builds:</p>\n<ul>\n<li>The review process is quicker and not as fussy (no RFC approvals).</li>\n<li>The contribution will be available right away rather than waiting for the appropriate Lean release.</li>\n<li>Mathlib adaptations can be made right away, which simplifies work for Lean maintainers.</li>\n<li>The upstreaming to Lean is often a trivial copy paste and can even be handled by Lean maintainers or more experienced users with beefy machines.</li>\n<li>It provides a platform for live testing before submitting to Lean.</li>\n</ul>",
        "id": 496141723,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1737989762
    },
    {
        "content": "<p>Yes, making it easy to extend existing standard library concepts with new operations and theorems in downstream projects (independently of whether there are plans to have the material upstreamed eventually) is one of the goals of the standard library.</p>\n<p>Of course, different repositories will have different contribution processes, review styles, coding practices, etc., so I expect that there will be varying preferences about whether to contribute to Lean directly or go through a project like Batteries first, just like some material for mathlib is developed downstream of mathlib first while other material is contributed to mathlib directly.</p>",
        "id": 496145632,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1737990693
    },
    {
        "content": "<p>in that case, it sounds like it might be useful to make it clear which kind of suggestion should use which process. Particularly, i imagine it is not beneficial to have a RFC/PR to Std <em>and</em> a PR to Batteries open for the same thing... or at least not when they don't mention eachother?</p>",
        "id": 496159017,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1737994090
    },
    {
        "content": "<p>I think it's more about what your goals are. If your goal is to see your code merged into the standard library, then you should follow the processes laid out in the call for contributions, i.e., discuss your possible contribution with someone from the standard library team and if we agree that your contribution would make a good addition to the standard library then we will invite you to open a PR. For this, it does not matter where the code was before that, if you write it directly inside of your fork of the lean4 repository, if you had it in your own downstream project or if you contributed it to Batteries before to get some initial feedback.</p>",
        "id": 496163401,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1737995080
    },
    {
        "content": "<p>I'm confused by this sentence:<br>\n<span class=\"user-mention silent\" data-user-id=\"260921\">Markus Himmel</span> <a href=\"#narrow/channel/113486-announce/topic/The.20Lean.20standard.20library.3A.20vision.20and.20call.20for.20contributions/near/496074012\">said</a>:</p>\n<blockquote>\n<p>we will be adding a style guide and naming scheme (for the standard library only)</p>\n</blockquote>\n<p>Specifically about the naming scheme: the standard library is going to have a different naming scheme from everything else? Maybe I misunderstand what is meant by this sentence.</p>",
        "id": 496168024,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1737996411
    },
    {
        "content": "<p>At the moment the Lean codebase does not have a codified naming convention at all! Soon, at least the public parts of standard library will (and of course it will aim to be compatible with mathlib's naming convention).</p>",
        "id": 496168551,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1737996587
    },
    {
        "content": "<p>Perhaps we mean something different by <em>naming convention</em>. Maybe what I'm referring to would be better called a <em>naming scheme</em>. The scheme I am referring to is documented <a href=\"https://leanprover-community.github.io/contribute/naming.html#general-conventions\">here</a>. I realize this is a leanprover <em>community</em> webpage, but I was under the impression that the naming scheme documented there was a consequence of decisions made in core Lean.</p>\n<p>My main question is: will that scheme be changing for the standard library?</p>",
        "id": 496169445,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1737996840
    },
    {
        "content": "<p>Nothing will change. The only thing that will happen is that the lean4 repository will contain a file with basically the same content as the file you linked to.</p>",
        "id": 496169815,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1737996945
    },
    {
        "content": "<p>(Or, if anything will change, it's that both documents will improve as we discover missing coverage, and discuss with the Mathlib naming experts how to add consistent conventions for these.)</p>",
        "id": 496218099,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1738014887
    },
    {
        "content": "<p>Didn't we already have a standard library which got turned into Batteries? What's the difference here?</p>",
        "id": 496276681,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1738051542
    },
    {
        "content": "<p>\"Standard library\" is the term we use for a certain part of the Lean distribution, as defined in the document. Batteries is a community project which builds on and extends the standard library and other parts of the Lean distribution to provide additional material which is not present in Lean core.</p>",
        "id": 496277668,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1738051970
    },
    {
        "content": "<p>Just to be super clear, this is referring to <code>Std</code>, right?</p>",
        "id": 496303646,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1738060560
    },
    {
        "content": "<p>As described in the vision document, the standard library does not correspond to a certain directory in the lean4 repository or a certain namespace. Rather, the standard library is defined by what is listed in the standard library outline (which is also part of the vision document).</p>",
        "id": 496305421,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1738061139
    },
    {
        "content": "<p>I think explicitly mentioning that the scope is larger than / orthogonal to<code>Std</code> in the document would aid clarity</p>",
        "id": 496306149,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1738061388
    },
    {
        "content": "<p>Is \"Not all public APIs in the Lean distribution are part of the standard library, and the standard library does not correspond to a certain directory within the Lean source repository.\" not that?</p>",
        "id": 496306319,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1738061432
    },
    {
        "content": "<p>\"a certain directory (e.g. <code>Std</code>)\" would be compatible with Ctrl+F :)</p>",
        "id": 496306387,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1738061460
    },
    {
        "content": "<p>That is, batteries could no longer be called \"standard\" to avoid confusion with this library</p>",
        "id": 496306428,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1738061470
    },
    {
        "content": "<p>Is Std a subset of the standard library?</p>",
        "id": 496306432,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1738061471
    },
    {
        "content": "<p>It's confusing that \"the standard library\" doesn't mean Std given that Std is an abbreviation of \"standard\". Maybe you should rename Std?</p>",
        "id": 496306627,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1738061528
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/channel/113488-general/topic/Lean.20standard.20library.20vision.20discussion/near/496306428\">said</a>:</p>\n<blockquote>\n<p>That is, batteries could no longer be called \"standard\" to avoid confusion with this library</p>\n</blockquote>\n<p>If I'm not mistaken the batteries project has been using the term \"extended library\" for a while now.</p>",
        "id": 496307056,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1738061650
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/113488-general/topic/Lean.20standard.20library.20vision.20discussion/near/496306627\">said</a>:</p>\n<blockquote>\n<p>It's confusing that \"the standard library\" doesn't mean Std given that Std is an abbreviation of \"standard\". Maybe you should rename Std?</p>\n</blockquote>\n<p>I will make an amendment to the document that tries to address this confusion. I think it is reasonable for parts of the prelude like <code>Nat</code> to be considered part of the standard library while still providing additional material (like containers or the date and time library) that we would expect people to explicitly import as part of a <code>Std</code> namespace.</p>",
        "id": 496307680,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1738061858
    },
    {
        "content": "<p>Maybe you could provide some examples as to what constitutes part of the standard library and what doesn't?<br>\nThe way I had previously thought about it was that everything that didn't require an input was part of the \"Init library\" and everything that shipped with the lean distribution but required an input was part of the standard library. But it seems this isn't quite true?</p>\n<p>Basically, what I'm asking is if the standard library doesn't correspond to the files in Std, then what does it correspond to?</p>",
        "id": 496391559,
        "sender_full_name": "Niels Voss",
        "timestamp": 1738086488
    },
    {
        "content": "<p>Oh I see the outline now, which clears some things up. I still think that \"Basic Types\" is a bit ambiguous.</p>\n<p>My concern is that a Lean user might want to make an API that depends only on the standard library, (maybe because it's less likely to make backward incompatible changes?) but doesn't know what's part of the standard library or not. For instance, is <code>unsafe</code> stuff like <code>lcProof</code> part of the standard library? What about <code>ST</code> or <code>SizeOf</code>? Or does the standard library not necessarily correspond to the parts of Lean which can be considered stable, and users wouldn't need to know what's part of the standard library?</p>",
        "id": 496393189,
        "sender_full_name": "Niels Voss",
        "timestamp": 1738087033
    },
    {
        "content": "<p>There are stable public APIs beyond the standard library. We are aware that Lean currently does a poor job of telling users which  declarations (in all namespaces) are considered public or even stable and which are not. We will improve this.</p>",
        "id": 496399402,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1738088966
    },
    {
        "content": "<p>Currently, the document says \"std library is a subset of lean distribution; there is no simple way to tell what files/definitions/theorems belong to it\". WDYT about adding some way to figure this out without asking the developers? E.g., add a sentence \"This file is a part of the standard library\" to each relevant module doc string?</p>",
        "id": 496437110,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1738104453
    },
    {
        "content": "<p>Yes, this is a good idea, thanks! The detailed outline and the reference manual will also eventually contain this information down to the level of individual types. So there will be plenty of ways.</p>",
        "id": 496477797,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1738131290
    }
]