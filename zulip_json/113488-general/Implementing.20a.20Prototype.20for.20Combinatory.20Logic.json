[
    {
        "content": "<p>Hi everyone,</p>\n<p>I am a beginner in Lean and Combinatory Logic, trying to formalize basic combinators from Raymond Smullyan's \"To Mock a Mockingbird\". The \"birds\" here are just combinators (functions). My goal is to work through the book's puzzles.</p>\n<p>Here’s my setup:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">Bird</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">response</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bird</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bird</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bird</span>\n<span class=\"kn\">infixl</span><span class=\"o\">:</span><span class=\"mi\">90</span><span class=\"w\"> </span><span class=\"s2\">\" ⬝ \"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">response</span>\n\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">response_ext</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">⬝</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">⬝</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">is_kestrel</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bird</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"bp\">⬝</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">⬝</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">kestrel_simp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">is_kestrel</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"bp\">⬝</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">⬝</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">is_kestrel</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"bp\">⬝</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">⬝</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">⬝</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">⬝</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>My questions:</p>\n<ol>\n<li>The <code>kestrel_simp</code> lemma feels redundant — can <code>simp</code> use <code>is_kestrel K</code> directly?</li>\n<li>I currently have to manually pass <code>h</code> to <code>simp</code>. Can this be automatic?</li>\n<li>I would like extensionality so that <code>K ⬝ x ⬝ y ⬝ z = x ⬝ z</code> reduces to <code>K ⬝ x ⬝ y = x</code> automatically, maybe even via <code>simp</code>?</li>\n</ol>\n<p>I suspect Lean has mechanisms for all of this, but I am not familiar with them. What is the idiomatic way to handle this in Lean?</p>",
        "id": 569971901,
        "sender_full_name": "Creative Salmon",
        "timestamp": 1769365046
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"1019633\">Creative Salmon</span> <a href=\"#narrow/channel/113488-general/topic/Implementing.20a.20Prototype.20for.20Combinatory.20Logic/near/569971901\">said</a>:</p>\n<blockquote>\n<ol>\n<li>The <code>kestrel_simp</code> lemma feels redundant — can <code>simp</code> use <code>is_kestrel K</code> directly?</li>\n</ol>\n</blockquote>\n<p>No. Since <code>is_kestrel</code> is not reducible, <code>simp</code> can't see through its definition. <code>simp [h _ _]</code> works because the type of <code>h _ _</code> is an equality, but <code>simp [h]</code> alone does not work because the type of <code>h</code> is <code>is_kestrel K</code> which is not an equality at reducible transparency.</p>",
        "id": 569972173,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1769365296
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"1019633\">Creative Salmon</span> <a href=\"#narrow/channel/113488-general/topic/Implementing.20a.20Prototype.20for.20Combinatory.20Logic/near/569971901\">said</a>:</p>\n<blockquote>\n<ol start=\"2\">\n<li>I currently have to manually pass <code>h</code> to <code>simp</code>. Can this be automatic?</li>\n</ol>\n</blockquote>\n<p>You could configure the discharger to search through the local hypotheses, so <code>simp (disch := assumption)</code> for example, or you could use <code>simp_all</code> or <code>simp [*]</code> which both give <code>simp</code> access to all the local hypotheses.</p>",
        "id": 569972283,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1769365417
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"1019633\">Creative Salmon</span> <a href=\"#narrow/channel/113488-general/topic/Implementing.20a.20Prototype.20for.20Combinatory.20Logic/near/569971901\">said</a>:</p>\n<blockquote>\n<ol start=\"3\">\n<li>I would like extensionality so that <code>K ⬝ x ⬝ y ⬝ z = x ⬝ z</code> reduces to <code>K ⬝ x ⬝ y = x</code> automatically, maybe even via <code>simp</code>?</li>\n</ol>\n</blockquote>\n<p>This isn't sound, since if you could do this then you could prove <code>K ⬝ x ⬝ y ⬝ z = x ⬝ z → K ⬝ x ⬝ y = x</code> by simplifying it to <code>K ⬝ x ⬝ y = x → K ⬝ x ⬝ y = x</code>.</p>",
        "id": 569972428,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1769365543
    },
    {
        "content": "<p>Is there a better way to implement all of this (maybe the whole <code>axiom</code> approach is not a good fit)?</p>\n<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/113488-general/topic/Implementing.20a.20Prototype.20for.20Combinatory.20Logic/near/569972173\">said</a>:</p>\n<blockquote>\n<p>No. Since <code>is_kestrel</code> is not reducible, <code>simp</code> can't see through its definition. <code>simp [h _ _]</code> works because the type of <code>h _ _</code> is an equality, but <code>simp [h]</code> alone does not work because the type of <code>h</code> is <code>is_kestrel K</code> which is not an equality at reducible transparency.</p>\n</blockquote>\n<p>Ok.  Out of curiosity, why <code>simp</code> does not try to \"instantiate\" that (as in you example, <code>simp [h _ _]</code>)?  Are there not  too many  theorems for <code>simp</code> to use which are behind this kind of quantifiers?  Maybe there is a pattern to write <code>simp</code> theorems I miss.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/113488-general/topic/Implementing.20a.20Prototype.20for.20Combinatory.20Logic/near/569972283\">said</a>:</p>\n<blockquote>\n<p>You could configure the discharger to search through the local hypotheses, so <code>simp (disch := assumption)</code> for example, or you could use <code>simp_all</code> or <code>simp [*]</code> which both give <code>simp</code> access to all the local hypotheses.</p>\n</blockquote>\n<p>Yes, these help with the current approach.  Thank you.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/113488-general/topic/Implementing.20a.20Prototype.20for.20Combinatory.20Logic/near/569972428\">said</a>:</p>\n<blockquote>\n<p>This isn't sound, since if you could do this then you could prove <code>K ⬝ x ⬝ y ⬝ z = x ⬝ z → K ⬝ x ⬝ y = x</code> by simplifying it to <code>K ⬝ x ⬝ y = x → K ⬝ x ⬝ y = x</code>.</p>\n</blockquote>\n<p>Why isn't that sound?  Isn't that the definition of <code>is_kestrel K</code>?</p>",
        "id": 569974077,
        "sender_full_name": "Creative Salmon",
        "timestamp": 1769367053
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"1019633\">Creative Salmon</span> <a href=\"#narrow/channel/113488-general/topic/Implementing.20a.20Prototype.20for.20Combinatory.20Logic/near/569974077\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/113488-general/topic/Implementing.20a.20Prototype.20for.20Combinatory.20Logic/near/569972428\">said</a>:</p>\n<blockquote>\n<p>This isn't sound, since if you could do this then you could prove <code>K ⬝ x ⬝ y ⬝ z = x ⬝ z → K ⬝ x ⬝ y = x</code> by simplifying it to <code>K ⬝ x ⬝ y = x → K ⬝ x ⬝ y = x</code>.</p>\n</blockquote>\n<p>Why isn't that sound?  Isn't that the definition of <code>is_kestrel K</code>?</p>\n</blockquote>\n<p>Well I guess if you have an <code>is_kestrel K</code> hypothesis then it's sound, but you would also never need such an extensionality lemma in this case because <code>K ⬝ x ⬝ y ⬝ z = x ⬝ z</code> simplifies to <code>True</code>.</p>",
        "id": 569974276,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1769367253
    }
]