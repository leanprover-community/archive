[
    {
        "content": "<p>I have a graduate independent study project involving proving code to be run as an OS kernel on a simulated risc-v processor, and I'm currently considering lean as a proof assistant (I'd also appreciate input on this usecase).</p>\n<p>Therefore I need to be able to compile lean code to rv64.<br>\nRight now I'm just trying to figure out how to manually compile the emitted code to my native x86 binary using the following command.<br>\n<code>gcc -I~/elan/toolchains/leanprover--lean4---stable/include/ Main.c</code><br>\nI also tried with clang, and I'm getting a lot of errors complaining that various macros are not defined.</p>",
        "id": 469197664,
        "sender_full_name": "Felix Wilking",
        "timestamp": 1725998100
    },
    {
        "content": "<p>You can get there with what is described here <a href=\"https://kuruczgy.com/blog/2024/07/31/lean-esp32/\">https://kuruczgy.com/blog/2024/07/31/lean-esp32/</a> but this still relies on a lot of C code in libc and libc++  just to get the runtime working. Lean is also not generally something that people would write a real operating system in given that it is not at all a systems programming language.</p>\n<p>I would suggest to use proof techniques like differential fuzzing instead of trying to run Lean code directly.</p>",
        "id": 469199014,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1725998481
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/113488-general/topic/How.20can.20I.20manually.20compile.20the.20emitted.20c-code.20to.20riscv.3F/near/469199014\">said</a>:</p>\n<p>What proof assistant would you recommend?  I've been considering idris, but I know CoQ and isabelle are more commonly used.  But the PA needs to emit RISC-V binary and my understanding is isabelle cannot do that.</p>",
        "id": 469222697,
        "sender_full_name": "Felix Wilking",
        "timestamp": 1726005934
    },
    {
        "content": "<p>Why would the proof assistant need to emit a RISC-V binary? There are plenty of ways to verify code without the proof assistant emitting the binary really.</p>",
        "id": 469225514,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1726007265
    },
    {
        "content": "<p>my goal is to first write an intermediary stack based language and then write the OS in that language.</p>",
        "id": 469225928,
        "sender_full_name": "Felix Wilking",
        "timestamp": 1726007457
    },
    {
        "content": "<p>If you are implementing your own programming language you'd want to implement a compiler as well instead of using the code generation facilities of whatever language wouldn't you? Also note that none of Idris, Coq or Isabelle are capable of producing binaries that run on bare metal.</p>",
        "id": 469226465,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1726007736
    },
    {
        "content": "<p>My recommended approach for this project would be to implement your OS in a proper systems language like Rust and then implement a model in Lean or some other proof assistant and differentially fuzz a compiled version of that model against your OS implementation. This is e.g. the technique used by <a href=\"https://www.kernkonzept.com/\">https://www.kernkonzept.com/</a> to verify L4re.</p>\n<p>You can also use the techniques used by Isabelle to verify seL4 which would include first implementing your OS in C and then doing proofs about the C directly. That's going to give you some more certainty in the correctness of your proof but increase the effort quite drastically.</p>\n<p>In general implementing something that resembles an OS on RISC-V is probably already challenging enough for most student projects. Unless you really know what you are doing on the RISC-V end already and have a significant amount of time over a significant time period for this project</p>",
        "id": 469226855,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1726007965
    },
    {
        "content": "<p>what do you mean by run on bare metal?  Do you mean without environmental overhead like a garbage collector? In my research it seems like idris is capable of compiling its racket backend to risc-v, but that might contain some runtime environment or something, I'm not sure.<br>\nAs for implementing an OS, I've already taken a rigorous undergraduate OS class and did very well, and I'm currently taking a graduate level one as well, so I think it's doable, but maybe I'm mistaken.<br>\nThe reason I had the idea to create the intermediate language was because it seemed like it would be a very useful crossroads between ease of development and ease of verification.</p>",
        "id": 469229367,
        "sender_full_name": "Felix Wilking",
        "timestamp": 1726009172
    },
    {
        "content": "<p>All of those languages usually require a runtime to manage their memory indeed. Maybe there is some trick involved though I don't know about that.</p>\n<p>Implementing an operating system while knowing how it works in theory from a class is still an additional bump in complexity. You'll be spending most of your time reading the RISCV manual that describes privileged execution etc.</p>\n<p>If you have never implemented OS level functionality like setting up a page table or an allocator just writing the OS is going to be hard in its own right. I still don't know how much time you have but if you are seriously considering it I would recommend the differential fuzzing approach at most. If not just implementing an OS without versification.</p>",
        "id": 469299569,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1726038145
    }
]