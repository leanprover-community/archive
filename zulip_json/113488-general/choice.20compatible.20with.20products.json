[
    {
        "content": "<p>Is there a way to do something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">my_better_choice</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">my_better_choice</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">my_better_choice</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">choice</span><span class=\"w\"> </span><span class=\"n\">α</span>\n</code></pre></div>\n<p>I.e., have a choice function on nonempty types, which is compatible with the projections in product types?</p>",
        "id": 464309050,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1724317316
    },
    {
        "content": "<p>I guess no, by the cardinality model (which shows that asking if a type is a product type hasn't a well defined answer).</p>",
        "id": 464317172,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1724319225
    },
    {
        "content": "<p>Interesting! Can you speculate a bit or point to a reference?</p>",
        "id": 464318863,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1724319614
    },
    {
        "content": "<p>There's a model of Lean where <code>Fin 2 \\times Fin 2</code> and <code>Fin 4</code> are <em>equal as types</em>.</p>",
        "id": 464322638,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1724320523
    },
    {
        "content": "<p>Not a great solution, but:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">HasNiceChoice</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">niceChoice</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"kn\">export</span><span class=\"w\"> </span><span class=\"n\">HasNiceChoice</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">niceChoice</span><span class=\"o\">)</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">priority</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">low</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">defaultNiceChoice</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HasNiceChoice</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">niceChoice</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">choice</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">Prod</span><span class=\"bp\">.</span><span class=\"n\">instNiceChoice</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">HasNiceChoice</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">HasNiceChoice</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HasNiceChoice</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">niceChoice</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">niceChoice</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">niceChoice</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 464331919,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1724322562
    },
    {
        "content": "<p>I expect that it is consistent to assume this, i.e. to assume</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">prodChoice</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">prodChoice_spec</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">prodChoice</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">prodChoice</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">prodChoice</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I don't see why this should be inconsistent even in the cardinality model. In the model when defining the interpretation of <code>Prod</code> and <code>Prod.mk</code> I think you can ensure that <code>prodChoice_spec</code> holds.<br>\nHowever, I also expect that such a function is not definable in Lean from ordinary choice.</p>",
        "id": 464333631,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1724323148
    },
    {
        "content": "<p>Isn't <code>HasNiceChoice</code> basically <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Inhabited#doc\">docs#Inhabited</a> ?</p>",
        "id": 464337994,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1724324416
    },
    {
        "content": "<p>Not quite, because <code>HasNiceChoice Empty</code> exists</p>",
        "id": 464338299,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1724324502
    },
    {
        "content": "<p>I agree that it's certainly consistent to assume this. However, it is also not provable, because the cardinality model gives you a model where this doesn't hold, as follows. </p>\n<p>In the cardinality model, all types with the same cardinality are equal. This can be built by starting from a model where the types are distinct, choosing compatible bijections between the types with the same cardinality, and identifying the types under these bijections. Let me start from such a bijection <code>f</code> between <code>ℕ</code> and <code>ℕ x ℕ</code>. Assume I have distinguished points in each type (say <code>x : ℕ</code> and <code>y : ℕ x ℕ</code>), compatible with the product structure (i.e. <code>y = (x, x)</code>) and with the identifications (i.e. <code>y = f x</code>). Then <code>f x = (x, x)</code>. But it is easy to construct <code>f</code> such that this equality is never true (choose for instance <code>f x</code> to not be in the vertical line above <code>x</code>). This shows that, in the cardinality model constructed using this specific <code>f</code>, then <code>prodChoice</code> is false.</p>",
        "id": 464359854,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1724329986
    },
    {
        "content": "<p>I think this is one of those places where you need your own type universe to keep track of how the type is a product.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">Common</span>\n\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">pp_with_univ</span><span class=\"kd\">]</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">PType</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">incl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">prod</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PType</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">PType</span><span class=\"bp\">.</span><span class=\"n\">toType</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PType</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">incl</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">prod</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"bp\">.</span><span class=\"n\">toType</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"bp\">.</span><span class=\"n\">toType</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CoeSort</span><span class=\"w\"> </span><span class=\"n\">PType</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">PType</span><span class=\"bp\">.</span><span class=\"n\">toType</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">PType</span><span class=\"bp\">.</span><span class=\"n\">choice</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PType</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">incl</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">choice</span><span class=\"w\"> </span><span class=\"n\">inst</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">prod</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">nonempty_prod</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"m\">1</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">nonempty_prod</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"m\">2</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">PType</span><span class=\"bp\">.</span><span class=\"n\">choice</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">PType</span><span class=\"bp\">.</span><span class=\"n\">choice</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 464477179,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1724359097
    }
]