[
    {
        "content": "<p>Is there any work on proving facts about the distributions of random programs? Speaking loosely because I am out of my depth here (as a mathematican who just read FPIL) I envision some sort of monadic approach is possible where I can write a program where I can swap the monad between something that \"assumes\" true random distributions (Giry monad?) that I can prove things about and a monad that lets me actually run the program (IO based), without changing the logic of the program (basically showing that if the input randomness was true random then what I proved about the program is true).</p>",
        "id": 533245857,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1754556351
    },
    {
        "content": "<p>You can run prove things inside the Id monad</p>",
        "id": 533254666,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1754559221
    },
    {
        "content": "<p>Can you elaborate? I can see how this allows you to prove things about the deterministic aspects of the program but not how to prove things about the program as a distribution.</p>",
        "id": 533260053,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1754561139
    },
    {
        "content": "<p>I realized it wasn't totally clear in my initial post but I want to specifically prove things about the distribution of outputs of the program if you assumed the random number generation was true random. An example application would be a program that runs a Monte Carlo or Markov Chain Monte Carlo simulation where you can prove convergence results (in particular that it actually estimates what you want to estimate), confidence intervals etc...</p>",
        "id": 533263440,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1754562443
    },
    {
        "content": "<ol>\n<li>With a monad it is possible to abstract away the retrieval of random values. Then, we can write a handler to supply the random values to the program to get the output.</li>\n<li>Now let's assume that our program terminates. Things get more interesting when there is a possibility of non-termination. We now face the first hurdle: we don't know how many random values the program requests. To overcome this hurdle, the handler needs to return an error when not enough random values or too many random values are being supplied, and return the actual program output otherwise.</li>\n<li>With this, we now have the set of valid lists of random values. Then, by running the program on every list in the set, we also have a multiset of possible outputs. With this multiset, we can start talking about the behavior of programs with random number generation.</li>\n</ol>",
        "id": 533270039,
        "sender_full_name": "(deleted)",
        "timestamp": 1754564764
    },
    {
        "content": "<p>I'm watching a movie right now. But I can provide code to illustrate what I'm saying.</p>",
        "id": 533270551,
        "sender_full_name": "(deleted)",
        "timestamp": 1754564976
    },
    {
        "content": "<p>To add to the above, you can employ two tricks. Abstract the random variable away and prove things about the resulting function by assuming a distribution on this parameter.  The second trick is to use Yao’s minimax principle to prove something about the distribution of inputs instead of distribution of algorithms that arises from randomly chosen parameters.</p>",
        "id": 533276185,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1754567141
    },
    {
        "content": "<p>Here is an example of proof that applies to randomized computations: in the query oracle model, sorting takes at least <code>log2 n!</code> queries in the average case, including for randomized algorithms.</p>\n<p><a href=\"https://github.com/girving/debate/blob/0dab8ad4b58b7a0e82f1738e86135d444462b953/Comp/Sort.lean#L176\">https://github.com/girving/debate/blob/0dab8ad4b58b7a0e82f1738e86135d444462b953/Comp/Sort.lean#L176</a></p>",
        "id": 533277482,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1754567687
    },
    {
        "content": "<p>Inspired by <a href=\"https://inria.hal.science/inria-00431771v1/document#%5B%7B%22num%22%3A51%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C67.213%2C702.144%2Cnull%5D\">this paper</a> and <a href=\"https://github.com/leanprover/lean4/blob/master/tests/lean/run/partial_fixpoint_probability.lean\">this code</a> I was able to create a rough draft of the approach I was envisioning </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">ENNReal</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">RandomBool</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">randomBool</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">Bool</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RandomBool</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">randomBool</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">rand</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Distr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span>\n\n<span class=\"c1\">-- assume all types are finite so I can sum over `α`</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">finite_types</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">finite_types</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n\n<span class=\"c1\">-- Giry Monad on finite types</span>\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">Distr</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"n\">bind</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"bp\">∑</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RandomBool</span><span class=\"w\"> </span><span class=\"n\">Distr</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">randomBool</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">random_Bool</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">RandomBool</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">RandomBool</span><span class=\"bp\">.</span><span class=\"n\">randomBool</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">random_Bool</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- returns a random Bool</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">random_notBool</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">RandomBool</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">RandomBool</span><span class=\"bp\">.</span><span class=\"n\">randomBool</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">random_notBool</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- returns a random not Bool</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> prove that under the assumption of uniformly distributed Booleans,</span>\n<span class=\"cm\">random_Bool has the same distribution as random_notBool -/</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">random_Bool</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Distr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">random_notBool</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Distr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Distr</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">random_Bool</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">random_notBool</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">RandomBool</span><span class=\"bp\">.</span><span class=\"n\">randomBool</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">Bind</span><span class=\"bp\">.</span><span class=\"n\">bind</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Pure</span><span class=\"bp\">.</span><span class=\"n\">pure</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n</code></pre></div>\n<p>Obviously it contains some nonsense (I assume all types are fintype so I can take the sum). The idea though is that by replacing the monad <code>m</code> in the same program I can go from a computable program that can actually generate \"random\" outputs to a noncomputable program that I can reason about (for example proving that <code>random_Bool</code> and <code>random_notBool</code> have the same distribution). One would want to extend this so that you can take a sequence of \"independent\" random inputs and ideally be able to use Measures in mathlib in place of <code>Distr</code> so that you can use the full strength of mathlib to prove stuff (unfortunately I am not sure if this is easy or doable). Does this approach seem reasonable though?</p>",
        "id": 533390953,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1754623008
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">GetRandom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Done</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Read</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">continuation</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">GetRandom</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">bind</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">GetRandom</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">GetRandom</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">GetRandom</span><span class=\"bp\">.</span><span class=\"n\">Done</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">GetRandom</span><span class=\"bp\">.</span><span class=\"n\">Read</span><span class=\"w\"> </span><span class=\"n\">continuation</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">GetRandom</span><span class=\"bp\">.</span><span class=\"n\">Read</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">bind</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">continuation</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- up to this point it's standard monadic stuff</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Outcome</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">TooLittle</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">TooMuch</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">JustRight</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">supply</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">GetRandom</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[],</span><span class=\"w\"> </span><span class=\"n\">GetRandom</span><span class=\"bp\">.</span><span class=\"n\">Done</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Outcome</span><span class=\"bp\">.</span><span class=\"n\">JustRight</span><span class=\"w\"> </span><span class=\"n\">k</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[],</span><span class=\"w\"> </span><span class=\"n\">GetRandom</span><span class=\"bp\">.</span><span class=\"n\">Read</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Outcome</span><span class=\"bp\">.</span><span class=\"n\">TooLittle</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">GetRandom</span><span class=\"bp\">.</span><span class=\"n\">Done</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Outcome</span><span class=\"bp\">.</span><span class=\"n\">TooMuch</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">tail</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">GetRandom</span><span class=\"bp\">.</span><span class=\"n\">Read</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">supply</span><span class=\"w\"> </span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">possibleOutputs</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">GetRandom</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Multiset</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">GetRandom</span><span class=\"bp\">.</span><span class=\"n\">Done</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">GetRandom</span><span class=\"bp\">.</span><span class=\"n\">Read</span><span class=\"w\"> </span><span class=\"n\">continuation</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">possibleOutputs</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">continuation</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">possibleOutputs</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">continuation</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 533407149,
        "sender_full_name": "(deleted)",
        "timestamp": 1754636005
    },
    {
        "content": "<p>Important caveat: if you have to generate an integer in a range, you have to come up with a different monad. You can't just generate bits and then use rejection sampling. This is because when you use rejection sampling, the program isn't guaranteed to terminate.</p>",
        "id": 533424941,
        "sender_full_name": "(deleted)",
        "timestamp": 1754643481
    },
    {
        "content": "<p>I feel my approach is fundamentally different from yours. Because my mind is shaped by the industry, and I prefer approaches that just work rather than elegant approaches.</p>",
        "id": 533426692,
        "sender_full_name": "(deleted)",
        "timestamp": 1754644056
    },
    {
        "content": "<p>The finite time rejection sampling thing is why for my purposes above the computations are allowed to sample from arbitrary finitely supported distributions. This doesn’t precisely model what real computers do, but is a more convenient setting for a lot of theoretical computer science results.</p>",
        "id": 533435946,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1754647956
    },
    {
        "content": "<p>You could also use the new free monad stuff in mathlib to write the programs, and embed separately in PMF monad to discuss distributions and IO monad to actually run it. You don't have a direct correspondence between the semantics and the actual run then though. <code>PMF</code> or <code>SPMF</code> is essentially just David's <code>Distr</code> definition</p>",
        "id": 533532700,
        "sender_full_name": "Devon Tuma",
        "timestamp": 1754689604
    },
    {
        "content": "<p>Oh thanks! I wasn't aware of the PMF monad. This should let me remove the fintype hack I used!</p>",
        "id": 533536461,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1754692868
    },
    {
        "content": "<p>It uses <code>tsum</code> for infinite cases which can be a bitter tougher to work with. It reduces to finite sums though if you do have the instance around</p>",
        "id": 533536799,
        "sender_full_name": "Devon Tuma",
        "timestamp": 1754693207
    },
    {
        "content": "<p>Which is potentially a good thing though because it lets you work with infinite (discrete) distributions. I was trying to get this working with Measure but it doesnt work because you need a measurable space instance on your types so you can't make it a monad but I suppose this works because you can give every type the discrete topology and sigma algebra.</p>",
        "id": 533536989,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1754693409
    },
    {
        "content": "<p>It does also have functions to turn it into measures. But yeah they aren't that useful except for occasionally pulling back lemmas from measure theory, since you need those instances</p>",
        "id": 533537081,
        "sender_full_name": "Devon Tuma",
        "timestamp": 1754693499
    },
    {
        "content": "<p>Though I feel using complicated machinery isn't worth it for terminating programs.</p>",
        "id": 533537536,
        "sender_full_name": "(deleted)",
        "timestamp": 1754693881
    },
    {
        "content": "<p>We have the coin flips measure on (Nat -&gt; Bool) at <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.Measure.infinitePiNat#doc\">docs#MeasureTheory.Measure.infinitePiNat</a> and a random program can also be seen as a deterministic program that takes a seed (Nat -&gt; Bool) as additional input. The pushforward of the coin flips measure by this program will be the theoretical behavior of the program and perhaps you may also be able to compose with some IO (Nat -&gt; Bool) to be able to run it?</p>",
        "id": 533543612,
        "sender_full_name": "Thomas Zhu",
        "timestamp": 1754700038
    }
]