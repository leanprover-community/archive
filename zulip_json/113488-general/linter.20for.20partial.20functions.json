[
    {
        "content": "<p>Hello, I'm new to lean but one of the features I absolutely love about it is that each function is total by default unless marked partial. However, this doesn't quite work as I expected because you can create non terminating functions that are not marked partial just by calling partial functions, as opposed to, for instance, Rust in which a function must be unsafe to call another unsafe function (leaving apart unsafe blocks)<br>\nAs I would like to be able to see if a function terminates just by looking at its signature, is there a linter rule I can activate or something of that nature?</p>",
        "id": 388180356,
        "sender_full_name": "Quentin Januel",
        "timestamp": 1693423217
    },
    {
        "content": "<p>I'm surprised by your claim. Can you give an example?</p>",
        "id": 388184188,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1693424750
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> You can't tell that <code>g</code> doesn't terminate:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"n\">n</span>\n\n<span class=\"k\">#print</span> <span class=\"n\">g</span>\n</code></pre></div>",
        "id": 388184540,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1693424878
    },
    {
        "content": "<p><code>#print axioms g</code> doesn't show any axioms either</p>",
        "id": 388184659,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1693424917
    },
    {
        "content": "<p>This is \"fine\" because <code>Nat</code> is inhabited, and <code>f</code> is opaque, so you shouldn't be able to prove anything false.</p>",
        "id": 388184709,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1693424940
    },
    {
        "content": "<p>Is there an argument here that proof of termination is uninteresting, since what actually matters is termination in a tractable amount of time?</p>",
        "id": 388184800,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1693424979
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span>  I was about to provide the exact same example of <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> but he was faster. As another example though, since the while syntax internally uses partial functions, the following code works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">while</span> <span class=\"n\">true</span> <span class=\"k\">do</span>\n    <span class=\"n\">IO.println</span> <span class=\"s2\">\"hello\"</span>\n</code></pre></div>",
        "id": 388184984,
        "sender_full_name": "Quentin Januel",
        "timestamp": 1693425047
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> I understand I wouldn't be able to prove anything false, but I would not just want to use lean as a proof assistant. I also see it as a \"stronger haskell\" and having each function being total unless marked otherwise felt powerful to me. Even if this is not a requirement in lean, I believe it shouldn't be too hard to statically check this and have a linter require me to mark partial every function that ever \"might\" not terminate (maybe I'm wrong though)</p>",
        "id": 388185393,
        "sender_full_name": "Quentin Januel",
        "timestamp": 1693425227
    },
    {
        "content": "<p>Yeah, it seems like it should be possible to write a <code>@[terminates]</code> attribute that asserts that a given function doesn't transitively call any <code>opaque</code> definitions.</p>",
        "id": 388185917,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1693425430
    },
    {
        "content": "<p>Why is <code>partial</code> non-poisoning, actually?</p>",
        "id": 388186126,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1693425495
    },
    {
        "content": "<p>So by your reply, I assume such a thing doesn't exist yet? Also, if possible, I would very much prefer the opposite: that is, mark it as non terminating when it's not</p>",
        "id": 388186193,
        "sender_full_name": "Quentin Januel",
        "timestamp": 1693425520
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> I don't know either, I discovered that in the \"functional programming in lean\" book just here:<br>\n<a href=\"https://leanprover.github.io/functional_programming_in_lean/monad-transformers/conveniences.html?highlight=%22infec#infinite-loops\">https://leanprover.github.io/functional_programming_in_lean/monad-transformers/conveniences.html?highlight=%22infec#infinite-loops</a></p>",
        "id": 388186620,
        "sender_full_name": "Quentin Januel",
        "timestamp": 1693425668
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113488-general/topic/linter.20for.20partial.20functions/near/388186126\">said</a>:</p>\n<blockquote>\n<p>Why is <code>partial</code> non-poisoning, actually?</p>\n</blockquote>\n<p>It's just a mechanism to make an <code>opaque</code> constant with a particular run-time interpretation. <code>opaque</code> is like <code>axiom</code> but it requires that the type be <code>Inhabited</code>, so it's not admitting the fact that the type is nonempty.</p>\n<p>If it were to be poisoning, then an obvious implementation would lead to any function that calls out to code written in C++ being marked too. Even <code>IO.println</code> for example, which uses the <code>opaque</code> constant <code>getStdout</code> (which calls <code>lean_get_stdout</code> in C++).</p>",
        "id": 388187319,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1693425962
    },
    {
        "content": "<p>Is it shocking to have <code>IO.println</code> be <code>partial</code>?</p>",
        "id": 388187473,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1693426017
    },
    {
        "content": "<p>No, not really, I just mentioned it because it was mentioned.</p>",
        "id": 388187719,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1693426118
    },
    {
        "content": "<p>I think it would be fine to just not poison when doing FFI with C++ since this is obviously code that could go wrong and that should be checked and marked manually</p>",
        "id": 388191208,
        "sender_full_name": "Quentin Januel",
        "timestamp": 1693427664
    },
    {
        "content": "<p>I suppose this is very unlikely to change, so the discussion about alternative schemes is a bit moot. But we can discuss how to deal with this design choice.</p>\n<ul>\n<li>For noncomputable mathematics, there's no effect since consistency is all that matters.</li>\n<li>For verified software:<ul>\n<li>If you do a full correctness proof, you can't use <code>partial</code> (or, more generally, <code>opaque</code>) functions anyway since you can't prove anything about them. However, <code>@[implementedBy]</code> can still overwrite your reference implementations with arbitrary garbage, so you have to prevent or audit that.</li>\n<li>If you do anything short of a full correctness proof, it's hard to be sure that your top-level function actually terminates.</li>\n</ul>\n</li>\n</ul>",
        "id": 388192718,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1693428325
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256311\">@Jannis Limperg</span> There is also the additional detail that there is  no guarantee the compiler actually produces code that semantically corresponds to code you are proving things about. This leads into a key detail about current design of Lean. Proofs about code are about the Lean-level abstraction, they are not about the compiled code (hence why <code>opaque</code> does not poison and <code>implemented_by</code> does not need to come with a proof of equivalence). This is a problem for many formal verification contexts. Hopefully, however, this will slowly change once the code generator is written in Lean and we can start proving things about it.</p>",
        "id": 388205439,
        "sender_full_name": "Mac Malone",
        "timestamp": 1693434169
    },
    {
        "content": "<p>If you want formally verified implemented_by that can just be csimp no?</p>\n<p>Regarding the code generator, it is right now definitely not at all written in a way that allows for verification and in fact filled with partial itself (for some passes I know for sure that this is correct because they rely on additional unformalized invariants to even terminate in the first place)</p>\n<p>On top of that there is always a C compiler or LLVM after the code generator, both with a gigantic code base that you would have to trust in addition. So if you are a person that doesn't believe in the correctness of the comparatively small code generator that we have right now, why would you believe in the LLVM/C compiler. On top of that the generated code is largely just making calls to the C++ runtime and not really doing much stuff on its own apart from branching and calling functions (both Lean and runtime ones).</p>\n<p>That doesn't mean I think a formalized code generator would be useless, I do find the idea quite interesting. It's just that I don't feel like a formalized code generator is the actual blocker if you wish to fully trust a compiled lean program.</p>",
        "id": 388206258,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1693434616
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113488-general/topic/linter.20for.20partial.20functions/near/388186126\">said</a>:</p>\n<blockquote>\n<p>Why is <code>partial</code> non-poisoning, actually?</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113488-general/topic/linter.20for.20partial.20functions/near/388187473\">said</a>:</p>\n<blockquote>\n<p>Is it shocking to have <code>IO.println</code> be <code>partial</code>?</p>\n</blockquote>\n<p>I have a counter question to this. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.add#doc\">docs#Nat.add</a> is tagged with <code>extern</code> just like many other primitive <code>Nat</code> operations to, also some <code>Array</code> operations etc. all to connect them to external C functions and make them performant. Now of course they do have a Lean body as well that is supposed to faithfully model what happens in the C++ based on the lean interpretation of the datatype (for Nat that is peano nat instead of funky multi precision nat, for Array that is a List instead of...well an array)</p>\n<p>As I understand there are two parts to the idea here:</p>\n<ol>\n<li>Every function that isn't what it pretends to be to the logic should be marked as partial, this means in particular <code>extern</code> and <code>implemented_by</code> ones. If you go through with this idea <code>Nat.add</code> and friends would be partial and you can't prove things about them anymore so you would have to add their definitional equations as axioms. This doesn't sound like something desirable to me? Of course we could go through the effort of making these functions magical and what not to avoid this but that feels like a weird 2 class system.</li>\n<li>Making partial viral. While this is a nice idea in principle it gives the classic \"function color issue\" (you basically split the eco system into <code>partial def</code> and <code>def</code> and this would be a real split as the mathematicians would only care about <code>def</code>) which has been discussed at length by e.g. the rust folk for their async and is a thing that people disagree on to this date. On top of that as I see the only thing you get is this: You now know your function will terminate. And for this you basically give up the ability to argue over functions completley that may just use a single piece of partial somewhere. Say for example you have</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span>\n    <span class=\"n\">partialFoo</span> <span class=\"n\">x</span>\n  <span class=\"k\">else</span>\n    <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>if partial is viral i cannot prove that if <code>x \\neq 0</code> <code>foo x = 2 * x</code> since you block me entirely from arguing over the body of the function. This does also not seem desirable to me. (note that this is not unfixable, we could rewrite foo in CPS but restructuring your code just for a termination dogma seems a bit meh)</p>\n<p>That said I do agree it would be nice to maybe have an annotation as proposed above that checks this. Making the virality check \"opt in\" in parts of code that you know will not be damaged from it so to speak.</p>",
        "id": 388207504,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1693435329
    },
    {
        "content": "<p>Thank you all for the explanations. Again I am very new to lean and probably don't realise the implications of what I'm trying to get, but I would like to clarify a something:<br>\nI do agree sometimes it is needed to have a partial function that will not poison, and it is the developer's responsability to make sure there won't be any issue with it. This would be needed for ffi for instance.<br>\nI don't mind that, these are implementation details burried in libraries I choose to trust.<br>\nHowever, when writing my own code, I feel like it should immediately know when I'm calling partial functions I wrote, unless I took the decision to mark them non partial after carefully checking them. To me, this is the same kind of difference between having an unsafe function in Rust, and a safe function that internally contain an unsafe block: the latter means the function have been verified manually.<br>\nAlso I believe this is not just about a termination dogma, but rather having more precise function signatures, letting you know what they can possibly do just by reading their type. Monads provide a similar feature by making the type explicit if a function may use IO or internal state e.g. Why should partial be treated any differently?</p>",
        "id": 388210221,
        "sender_full_name": "Quentin Januel",
        "timestamp": 1693436983
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"645377\">@Quentin Januel</span> If you are curious about the rational, I think I am be able to explain. The goal of the termination checker in Lean is not primarily to verify that a function terminates. Instead, it verifies termination insofar as it is a necessary requirement to keep the logical system of the theorem prover sound. Thus, definitions like <code>partial</code>, <code>opaque</code>, or <code>implemented_by</code> which may be non-terminating are ignored because they are still guaranteed to be sound for other reasons. On the hand, your desire is that if a definition passes the termination check it guaranteed to terminate as long as the trusted codebase (i.e., core and manually marked functions) terminate.</p>\n<p>I think your original idea of a linter (or something in the vein of <code>#print axioms</code> like <code>#print partial</code>) would be the best way of handling this (likely in some userland package).</p>",
        "id": 388215730,
        "sender_full_name": "Mac Malone",
        "timestamp": 1693440509
    },
    {
        "content": "<p>Is it possible to <em>prove</em> termination for a concrete function (say without things like <code>IO</code> for now)? What would that look like?</p>\n<p>Also, someone said it's not possible to do <code>partial def</code> for an uninhabited type. Does \"uninhabited\" here mean you cannot create an instance or is it about the typeclass <code>Inhabited</code>? For example, you can make an axiom that allows a contradiction and then <code>partial def</code> an instance of <code>False</code>(I tried). It the claim still true? (I guess it doesn't matter in this case since you already have a contradiction, so that's not a good example)</p>",
        "id": 388226283,
        "sender_full_name": "Adomas Baliuka",
        "timestamp": 1693445614
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"638715\">ab</span> <a href=\"#narrow/stream/113488-general/topic/linter.20for.20partial.20functions/near/388226283\">said</a>:</p>\n<blockquote>\n<p>Is it possible to <em>prove</em> termination for a concrete function (say without things like <code>IO</code> for now)? What would that look like?</p>\n</blockquote>\n<p>If the function does not make use of <code>partial</code> or <code>opaque</code> definitions then it passing the termination checker is proof it terminates. If it uses partial or opaque definitions, then it is impossible to prove termination because the details of the function are opaque to the prover. One way of verifying termination would be to unfold every definition until the definition is purely composed of constructors (also erasing and prop or type terms since they are irrelevant). If that works, the function terminates. If not, it does not.</p>",
        "id": 388244348,
        "sender_full_name": "Mac Malone",
        "timestamp": 1693455218
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"638715\">ab</span> <a href=\"#narrow/stream/113488-general/topic/linter.20for.20partial.20functions/near/388226283\">said</a>:</p>\n<blockquote>\n<p>Does \"uninhabited\" here mean you cannot create an instance or is it about the typeclass <code>Inhabited</code>?</p>\n</blockquote>\n<p>These notions are meant to be isomorphic (i.e., if can construct an instance of type, you can also construct an instance of <code>Inhabited</code> for the type). You can also manually provide an instance of the type in the <code>opaque</code> syntax (e.g., <code>opaque foo : A := &lt;some instance of A&gt;</code>). This is useful if it being inhabited is dependent on the parameters of the <code>opaque</code> definition. Furthermore, technically, the requirement is actually just that it has a <code>Nonempty</code> instance (which is propositional rather than constructive) -- an <code>Inhabited</code> instance implies a <code>Nonempty</code> one, but not vice versa (because <code>Nonempty</code>, since it is propositional, can use axioms / classical logic to generate instances as opposed to constructive logic) and an implementation (e.g. <code>extern</code> / <code>implemented_by</code>) or is marked <code>noncomputable</code>.</p>",
        "id": 388245046,
        "sender_full_name": "Mac Malone",
        "timestamp": 1693455542
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315577\">@Mac Malone</span> thanks for the answer. What I meant by \"proof\" was actually being able to write (and prove) something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"bp\">&lt;...</span> <span class=\"kd\">definition</span> <span class=\"n\">depending</span> <span class=\"n\">on</span> <span class=\"n\">definitions</span> <span class=\"n\">of</span> <span class=\"n\">definitions</span> <span class=\"n\">etc.</span><span class=\"bp\">&gt;</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">terminates_f</span> <span class=\"o\">:</span> <span class=\"n\">Terminates</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>I.e., encoding the statement within Lean. Can one prove that \"after expanding definitions, <code>f</code> is a composition of constructors\"?</p>",
        "id": 388255423,
        "sender_full_name": "Adomas Baliuka",
        "timestamp": 1693461575
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"638715\">@ab</span> That seems difficult. For one, even formalizing <code>Terminates f</code> is hard. (And, of course, in the general case, is the halting problem.) I am not sure how would go or about this or if this is even possible within Lean's theory.</p>",
        "id": 388256097,
        "sender_full_name": "Mac Malone",
        "timestamp": 1693461922
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315577\">@Mac Malone</span> maybe an easier question first: Is it possible to formalize and prove \"<code>f</code> is a constructor for some inductive type\"?</p>",
        "id": 388256613,
        "sender_full_name": "Adomas Baliuka",
        "timestamp": 1693462215
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"638715\">@ab</span> I would imagine probably not. By the substitution rule for equality anything you can prove about a construct you can prove about something equal to a construct (which, e.g., could be an <code>opaque</code> definition). The only way I can think of doing this at the moment would be proving it about Lean's metalanguage itself (i.e., about <code>Expr</code> and Environments and the such) and that is not very amendable to proofs (i.e., it uses at lot of partials and opaques).</p>",
        "id": 388257032,
        "sender_full_name": "Mac Malone",
        "timestamp": 1693462453
    },
    {
        "content": "<p>This is why I think a linter would be easier. That way you can just reason about definitions programmatically and check whether they can reduce to such a result. Its not quite the level the guarantee of a <code>theorem</code>, but it seems good enough for most use cases (as even the <code>theorem</code> as caveats like the compiler actually producing semantically correct code).</p>",
        "id": 388257307,
        "sender_full_name": "Mac Malone",
        "timestamp": 1693462601
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315577\">@Mac Malone</span> Thank you, I understood the primary goal of the termination checker was about soundness of the logical system, but just as lean can be used both as a proof assistant <em>and</em> a programming language, the termination checker might just as well have several benefits. Also yes I completely agree: I didn't expect lean to directly provide such a solution, a linter would be the best in this context I guess. Sadly since such a thing does not exist yet I suppose I will just have to check every once in a while if someone ever makes that (as I don't see myself able to do that unfortunately)</p>",
        "id": 388257653,
        "sender_full_name": "Quentin Januel",
        "timestamp": 1693462794
    },
    {
        "content": "<p>Yeah about the halting problem, I felt like it was because everyone just didn't want to throw away turing completeness. I first thought that lean wasn't turing complete and was interested to see how powerful it could still be with this restriction, but I was just wrong</p>",
        "id": 388258027,
        "sender_full_name": "Quentin Januel",
        "timestamp": 1693462997
    },
    {
        "content": "<p>I think that the undecidability of the halting problem (or undecidability more generally) simply means that you cannot hope to prove every true statement.  This is very far from being actually able to prove <em>many</em> true statements!</p>",
        "id": 388258170,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1693463079
    },
    {
        "content": "<p>Here's a basic implementation based on <code>#print axioms</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Elab</span> <span class=\"n\">Command</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">CollectPartial</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">State</span> <span class=\"n\">where</span>\n  <span class=\"n\">visited</span> <span class=\"o\">:</span> <span class=\"n\">NameSet</span> <span class=\"o\">:=</span> <span class=\"o\">{}</span>\n  <span class=\"n\">opaques</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Name</span> <span class=\"o\">:=</span> <span class=\"bp\">#</span><span class=\"o\">[]</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">ReaderT</span> <span class=\"n\">Environment</span> <span class=\"bp\">$</span> <span class=\"n\">StateT</span> <span class=\"n\">State</span> <span class=\"n\">MetaM</span>\n\n<span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">collect</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">collectExpr</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"n\">e.getUsedConstants.forM</span> <span class=\"n\">collect</span>\n  <span class=\"k\">let</span> <span class=\"n\">s</span> <span class=\"bp\">←</span> <span class=\"n\">get</span>\n  <span class=\"n\">unless</span> <span class=\"n\">s.visited.contains</span> <span class=\"n\">c</span> <span class=\"k\">do</span>\n    <span class=\"n\">modify</span> <span class=\"k\">fun</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span> <span class=\"n\">s</span> <span class=\"k\">with</span> <span class=\"n\">visited</span> <span class=\"o\">:=</span> <span class=\"n\">s.visited.insert</span> <span class=\"n\">c</span> <span class=\"o\">}</span>\n    <span class=\"k\">let</span> <span class=\"n\">env</span> <span class=\"bp\">←</span> <span class=\"n\">read</span>\n    <span class=\"k\">match</span> <span class=\"n\">env.find</span><span class=\"bp\">?</span> <span class=\"n\">c</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">ConstantInfo.ctorInfo</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">ConstantInfo.recInfo</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">ConstantInfo.inductInfo</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">ConstantInfo.quotInfo</span> <span class=\"n\">_</span><span class=\"o\">)</span>   <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">pure</span> <span class=\"o\">()</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">ConstantInfo.defnInfo</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">ConstantInfo.thmInfo</span> <span class=\"n\">v</span><span class=\"o\">)</span>    <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">unless</span> <span class=\"bp\">←</span> <span class=\"n\">Meta.isProp</span> <span class=\"n\">v.type</span> <span class=\"k\">do</span> <span class=\"n\">collectExpr</span> <span class=\"n\">v.value</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">ConstantInfo.axiomInfo</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">ConstantInfo.opaqueInfo</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">unless</span> <span class=\"bp\">←</span> <span class=\"n\">Meta.isProp</span> <span class=\"n\">v.type</span> <span class=\"k\">do</span>\n        <span class=\"n\">modify</span> <span class=\"k\">fun</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span> <span class=\"n\">s</span> <span class=\"k\">with</span> <span class=\"n\">opaques</span> <span class=\"o\">:=</span> <span class=\"n\">s.opaques.push</span> <span class=\"n\">c</span> <span class=\"o\">}</span>\n    <span class=\"bp\">|</span> <span class=\"n\">none</span>                             <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">modify</span> <span class=\"k\">fun</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span> <span class=\"n\">s</span> <span class=\"k\">with</span> <span class=\"n\">opaques</span> <span class=\"o\">:=</span> <span class=\"n\">s.opaques.push</span> <span class=\"n\">c</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">CollectPartial</span>\n\n<span class=\"n\">elab</span> <span class=\"s2\">\"#print\"</span> <span class=\"s2\">\"partial\"</span> <span class=\"n\">name</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">constName</span> <span class=\"bp\">←</span> <span class=\"n\">resolveGlobalConstNoOverloadWithInfo</span> <span class=\"n\">name</span>\n  <span class=\"k\">let</span> <span class=\"n\">env</span> <span class=\"bp\">←</span> <span class=\"n\">getEnv</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">liftTermElabM</span> <span class=\"bp\">&lt;|</span> <span class=\"o\">((</span><span class=\"n\">CollectPartial.collect</span> <span class=\"n\">constName</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">run</span> <span class=\"n\">env</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">run</span> <span class=\"o\">{}</span>\n  <span class=\"k\">if</span> <span class=\"n\">s.opaques.isEmpty</span> <span class=\"k\">then</span>\n    <span class=\"n\">logInfo</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"'{constName}' does not use any partial definitions\"</span>\n  <span class=\"k\">else</span>\n    <span class=\"n\">logInfo</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"'{constName}' depends on opaques: {s.opaques.toList}\"</span>\n\n<span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">Unit</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">foo</span>\n<span class=\"kd\">def</span> <span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"n\">Unit</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">foo</span>\n\n<span class=\"k\">#print</span> <span class=\"n\">partial</span> <span class=\"n\">bar</span>\n</code></pre></div>",
        "id": 388259582,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693463886
    },
    {
        "content": "<p>By the way, this catches <code>sorry</code> also:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">no</span> <span class=\"o\">:</span> <span class=\"n\">Unit</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"k\">#print</span> <span class=\"n\">partial</span> <span class=\"n\">no</span>  <span class=\"c1\">--  'no' depends on opaques: [sorryAx]</span>\n</code></pre></div>",
        "id": 388261242,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1693464800
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  Wow, this is wonderful thank you so much!<br>\nIs it easy to make it print the warning when the function is declared, except if the said function is also declared partial (similarly to the message \"declaration uses sorry\" which doesn't need to be checked manually afterwards)? I already changed it so that it prints a warning if there are opaques, or nothing otherwise, but I am having troubles with that since afaik \"elab\" is not documented yet</p>",
        "id": 388291551,
        "sender_full_name": "Quentin Januel",
        "timestamp": 1693476872
    },
    {
        "content": "<p><code>elab</code> is how you declare new syntax and give it an implementation, it's basically (one of) the entry points to lean metaprogramming</p>",
        "id": 388291731,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693476955
    },
    {
        "content": "<p>You can move the check to the function using an attribute, e.g. you write <code>@[terminating] def no : Unit -&gt; Nat := sorry</code> and it gives a warning</p>",
        "id": 388291961,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693477049
    },
    {
        "content": "<p>You could also use a linter if you want to have no syntax at the point of use, although this is a bit hackish</p>",
        "id": 388292084,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693477095
    },
    {
        "content": "<p>So you're saying elab wouldn't work to override existing syntax (for instance to, say, replace any \"&lt;declaration\"&gt; by \"#print partial ident; &lt;declaration&gt;\"?</p>\n<p>Well I don't want to use attributes because it kills the point of forcing me to declare my function as partials. Are there already existing linters?</p>",
        "id": 388295321,
        "sender_full_name": "Quentin Januel",
        "timestamp": 1693478470
    },
    {
        "content": "<p><code>elab</code> declares new syntax and attaches rules to that syntax. You could declare syntax exactly matching <code>def</code> and with a higher priority, and then any future defs would use your syntax and apply its rules</p>",
        "id": 388295564,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693478549
    },
    {
        "content": "<p><code>elab_rules</code> attaches rules to existing syntax. You could use this to override the behavior of <code>def</code> without changing the syntax</p>",
        "id": 388295663,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693478588
    },
    {
        "content": "<p>I don't mind about it being hackish. Also, talking about hackish, if anyone's interested I modified your solution so that it doesn't raise a warning for \"IO\"s since those are already visible in the function signature:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Elab</span> <span class=\"n\">Command</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">CollectPartial</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">State</span> <span class=\"n\">where</span>\n  <span class=\"n\">visited</span> <span class=\"o\">:</span> <span class=\"n\">NameSet</span> <span class=\"o\">:=</span> <span class=\"o\">{}</span>\n  <span class=\"n\">opaques</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Name</span> <span class=\"o\">:=</span> <span class=\"bp\">#</span><span class=\"o\">[]</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">ReaderT</span> <span class=\"n\">Environment</span> <span class=\"bp\">$</span> <span class=\"n\">StateT</span> <span class=\"n\">State</span> <span class=\"n\">MetaM</span>\n\n<span class=\"c1\">-- feels very hackish but nvm</span>\n<span class=\"kd\">def</span> <span class=\"n\">isIO</span> <span class=\"o\">:</span> <span class=\"n\">String</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"bp\">.</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">takeWhile</span> <span class=\"o\">(</span><span class=\"bp\">.</span> <span class=\"bp\">!=</span> <span class=\"sc\">' '</span><span class=\"o\">)</span> <span class=\"bp\">|&gt;</span> <span class=\"o\">(</span><span class=\"bp\">.</span> <span class=\"bp\">==</span> <span class=\"s2\">\"BaseIO\"</span><span class=\"o\">))</span>\n\n<span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">collect</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">collectExpr</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"n\">e.getUsedConstants.forM</span> <span class=\"n\">collect</span>\n  <span class=\"k\">let</span> <span class=\"n\">s</span> <span class=\"bp\">←</span> <span class=\"n\">get</span>\n  <span class=\"n\">unless</span> <span class=\"n\">s.visited.contains</span> <span class=\"n\">c</span> <span class=\"k\">do</span>\n    <span class=\"n\">modify</span> <span class=\"k\">fun</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span> <span class=\"n\">s</span> <span class=\"k\">with</span> <span class=\"n\">visited</span> <span class=\"o\">:=</span> <span class=\"n\">s.visited.insert</span> <span class=\"n\">c</span> <span class=\"o\">}</span>\n    <span class=\"k\">let</span> <span class=\"n\">env</span> <span class=\"bp\">←</span> <span class=\"n\">read</span>\n    <span class=\"k\">match</span> <span class=\"n\">env.find</span><span class=\"bp\">?</span> <span class=\"n\">c</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">ConstantInfo.ctorInfo</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">ConstantInfo.recInfo</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">ConstantInfo.inductInfo</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">ConstantInfo.quotInfo</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">pure</span> <span class=\"o\">()</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">ConstantInfo.defnInfo</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">ConstantInfo.thmInfo</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">unless</span> <span class=\"bp\">←</span> <span class=\"n\">Meta.isProp</span> <span class=\"n\">v.type</span> <span class=\"k\">do</span>\n        <span class=\"n\">collectExpr</span> <span class=\"n\">v.value</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">ConstantInfo.axiomInfo</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">ConstantInfo.opaqueInfo</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">unless</span> <span class=\"bp\">←</span> <span class=\"n\">Meta.isProp</span> <span class=\"n\">v.type</span> <span class=\"k\">do</span>\n        <span class=\"n\">unless</span> <span class=\"n\">isIO</span> <span class=\"o\">(</span><span class=\"n\">ToString.toString</span> <span class=\"n\">v.type</span><span class=\"o\">)</span> <span class=\"k\">do</span>\n          <span class=\"n\">modify</span> <span class=\"k\">fun</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span> <span class=\"n\">s</span> <span class=\"k\">with</span> <span class=\"n\">opaques</span> <span class=\"o\">:=</span> <span class=\"n\">s.opaques.push</span> <span class=\"n\">c</span> <span class=\"o\">}</span>\n    <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">modify</span> <span class=\"k\">fun</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span> <span class=\"n\">s</span> <span class=\"k\">with</span> <span class=\"n\">opaques</span> <span class=\"o\">:=</span> <span class=\"n\">s.opaques.push</span> <span class=\"n\">c</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">CollectPartial</span>\n\n<span class=\"n\">elab</span> <span class=\"s2\">\"#print\"</span> <span class=\"s2\">\"partial\"</span> <span class=\"n\">name</span><span class=\"o\">:</span><span class=\"n\">ident</span>  <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">constName</span> <span class=\"bp\">←</span> <span class=\"n\">resolveGlobalConstNoOverloadWithInfo</span> <span class=\"n\">name</span>\n  <span class=\"k\">let</span> <span class=\"n\">env</span> <span class=\"bp\">←</span> <span class=\"n\">getEnv</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">liftTermElabM</span> <span class=\"bp\">&lt;|</span> <span class=\"o\">((</span><span class=\"n\">CollectPartial.collect</span> <span class=\"n\">constName</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">run</span> <span class=\"n\">env</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">run</span> <span class=\"o\">{}</span>\n  <span class=\"n\">unless</span> <span class=\"n\">s.opaques.isEmpty</span> <span class=\"k\">do</span>\n    <span class=\"n\">logWarning</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"'{constName}' may not terminate due to:</span><span class=\"se\">\\n</span><span class=\"s2\">{s.opaques.toList}.\"</span>\n</code></pre></div>",
        "id": 388295690,
        "sender_full_name": "Quentin Januel",
        "timestamp": 1693478600
    },
    {
        "content": "<p>The part that is hackish about using linters is that you have to re-parse the syntax to find out the declaration that was made, and it's easy to miss one if you don't understand the syntax</p>",
        "id": 388295794,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693478642
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/linter.20for.20partial.20functions/near/388295663\">said</a>:</p>\n<blockquote>\n<p><code>elab_rules</code> attaches rules to existing syntax. You could use this to override the behavior of <code>def</code> without changing the syntax</p>\n</blockquote>\n<p>This one seems interesting</p>",
        "id": 388295928,
        "sender_full_name": "Quentin Januel",
        "timestamp": 1693478686
    },
    {
        "content": "<p>You still have to handle all the behavior of <code>def</code> though with that option, it's somewhat heavyweight</p>",
        "id": 388295995,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693478712
    },
    {
        "content": "<p>you would basically be adapting whatever code <code>def</code> uses to do its thing</p>",
        "id": 388296040,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693478738
    },
    {
        "content": "<blockquote>\n<p>Also, talking about hackish, if anyone's interested I modified your solution so that it doesn't raise a warning for \"IO\"s since those are already visible in the function signature</p>\n</blockquote>\n<p>I think you have made an unjustified assumption here that \"IO\" <em>is</em> visible in the function signature. The function originally selected might not say anything about IO</p>",
        "id": 388296279,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693478845
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">loop</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"n\">IO.iterate</span> <span class=\"o\">()</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">inl</span> <span class=\"o\">())</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">evil</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Unit</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span>\n  <span class=\"n\">loop</span> <span class=\"o\">()</span> <span class=\"n\">matches</span> <span class=\"bp\">.</span><span class=\"n\">ok</span> <span class=\"bp\">..</span>\n</code></pre></div>",
        "id": 388296714,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693479035
    },
    {
        "content": "<p>Hmm, but in this case that's not a problem since IO.iterate should be reported as it allows to make infinite loops<br>\nI just wanted to turn off the warnings for functions like stdOut and stdIn</p>",
        "id": 388297063,
        "sender_full_name": "Quentin Januel",
        "timestamp": 1693479203
    },
    {
        "content": "<p>Or did I miss your point?</p>",
        "id": 388297104,
        "sender_full_name": "Quentin Januel",
        "timestamp": 1693479225
    },
    {
        "content": "<p>I think you should specifically exempt opaques that are known to be terminating</p>",
        "id": 388297118,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693479234
    },
    {
        "content": "<p>e.g. using an attribute to tag them</p>",
        "id": 388297214,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693479265
    },
    {
        "content": "<p>Well that would surely be the best option but wouldn't this be way more complicated?</p>",
        "id": 388297226,
        "sender_full_name": "Quentin Januel",
        "timestamp": 1693479270
    },
    {
        "content": "<p>I mean, each tag comes with some soundness argument so it seems good to have it explicit by default</p>",
        "id": 388297294,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693479304
    },
    {
        "content": "<p>it's not particularly complicated to have a whitelist in that code</p>",
        "id": 388297344,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693479330
    },
    {
        "content": "<p>Oh I think I see</p>",
        "id": 388297356,
        "sender_full_name": "Quentin Januel",
        "timestamp": 1693479335
    },
    {
        "content": "<p>Well thank you for all the help, it's very good to know that lean is powerful enough to express all of this by itself. I'm really not sure I'll be able to come with a solution though, but if I do I will post it here</p>",
        "id": 388297573,
        "sender_full_name": "Quentin Januel",
        "timestamp": 1693479423
    },
    {
        "content": "<p>Here's how you make an attribute whitelist:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Elab</span> <span class=\"n\">Command</span>\n\n<span class=\"n\">initialize</span> <span class=\"n\">terminatesExt</span> <span class=\"o\">:</span> <span class=\"n\">SimplePersistentEnvExtension</span> <span class=\"n\">Name</span> <span class=\"n\">NameSet</span> <span class=\"bp\">←</span>\n  <span class=\"n\">registerSimplePersistentEnvExtension</span> <span class=\"o\">{</span>\n    <span class=\"n\">addEntryFn</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"n\">insert</span><span class=\"o\">)</span>\n    <span class=\"n\">addImportedFn</span> <span class=\"o\">:=</span> <span class=\"n\">mkStateFromImportedEntries</span> <span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"n\">insert</span><span class=\"o\">)</span> <span class=\"o\">{}</span>\n  <span class=\"o\">}</span>\n\n<span class=\"n\">initialize</span> <span class=\"n\">registerBuiltinAttribute</span> <span class=\"o\">{</span>\n  <span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"n\">terminates</span>\n  <span class=\"n\">descr</span> <span class=\"o\">:=</span> <span class=\"s2\">\"Asserts that an opaque is terminating\"</span>\n  <span class=\"n\">add</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">decl</span> <span class=\"n\">_</span> <span class=\"n\">kind</span> <span class=\"bp\">↦</span> <span class=\"k\">do</span>\n    <span class=\"n\">unless</span> <span class=\"n\">kind</span> <span class=\"bp\">==</span> <span class=\"n\">AttributeKind.global</span> <span class=\"k\">do</span>\n      <span class=\"n\">throwError</span> <span class=\"s2\">\"invalid attribute 'terminates', must be global\"</span>\n    <span class=\"n\">modifyEnv</span> <span class=\"o\">(</span><span class=\"n\">terminatesExt.addEntry</span> <span class=\"bp\">·</span> <span class=\"n\">decl</span><span class=\"o\">)</span>\n<span class=\"o\">}</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">CollectPartial</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">State</span> <span class=\"n\">where</span>\n  <span class=\"n\">visited</span> <span class=\"o\">:</span> <span class=\"n\">NameSet</span> <span class=\"o\">:=</span> <span class=\"o\">{}</span>\n  <span class=\"n\">opaques</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Name</span> <span class=\"o\">:=</span> <span class=\"bp\">#</span><span class=\"o\">[]</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">StateT</span> <span class=\"n\">State</span> <span class=\"n\">MetaM</span>\n\n<span class=\"n\">syntax</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span> <span class=\"n\">ws</span>\n<span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">collect</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">collectExpr</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"n\">e.getUsedConstants.forM</span> <span class=\"n\">collect</span>\n  <span class=\"k\">let</span> <span class=\"n\">s</span> <span class=\"bp\">←</span> <span class=\"n\">get</span>\n  <span class=\"n\">unless</span> <span class=\"n\">s.visited.contains</span> <span class=\"n\">c</span> <span class=\"k\">do</span>\n    <span class=\"n\">modify</span> <span class=\"k\">fun</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span> <span class=\"n\">s</span> <span class=\"k\">with</span> <span class=\"n\">visited</span> <span class=\"o\">:=</span> <span class=\"n\">s.visited.insert</span> <span class=\"n\">c</span> <span class=\"o\">}</span>\n    <span class=\"k\">let</span> <span class=\"n\">env</span> <span class=\"bp\">←</span> <span class=\"n\">getEnv</span>\n    <span class=\"k\">match</span> <span class=\"n\">env.find</span><span class=\"bp\">?</span> <span class=\"n\">c</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">ConstantInfo.ctorInfo</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">ConstantInfo.recInfo</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">ConstantInfo.inductInfo</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">ConstantInfo.quotInfo</span> <span class=\"n\">_</span><span class=\"o\">)</span>   <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">pure</span> <span class=\"o\">()</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">ConstantInfo.defnInfo</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">ConstantInfo.thmInfo</span> <span class=\"n\">v</span><span class=\"o\">)</span>    <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">unless</span> <span class=\"bp\">←</span> <span class=\"n\">Meta.isProp</span> <span class=\"n\">v.type</span> <span class=\"k\">do</span> <span class=\"n\">collectExpr</span> <span class=\"n\">v.value</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">ConstantInfo.axiomInfo</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">ConstantInfo.opaqueInfo</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">unless</span> <span class=\"bp\">←</span> <span class=\"n\">Meta.isProp</span> <span class=\"n\">v.type</span> <span class=\"k\">do</span>\n        <span class=\"n\">unless</span> <span class=\"o\">(</span><span class=\"n\">terminatesExt.getState</span> <span class=\"n\">env</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">contains</span> <span class=\"n\">c</span> <span class=\"k\">do</span>\n          <span class=\"n\">modify</span> <span class=\"k\">fun</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span> <span class=\"n\">s</span> <span class=\"k\">with</span> <span class=\"n\">opaques</span> <span class=\"o\">:=</span> <span class=\"n\">s.opaques.push</span> <span class=\"n\">c</span> <span class=\"o\">}</span>\n    <span class=\"bp\">|</span> <span class=\"n\">none</span>                             <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">modify</span> <span class=\"k\">fun</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span> <span class=\"n\">s</span> <span class=\"k\">with</span> <span class=\"n\">opaques</span> <span class=\"o\">:=</span> <span class=\"n\">s.opaques.push</span> <span class=\"n\">c</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">CollectPartial</span>\n\n<span class=\"n\">initialize</span> <span class=\"n\">registerBuiltinAttribute</span> <span class=\"o\">{</span>\n  <span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"n\">terminating</span>\n  <span class=\"n\">descr</span> <span class=\"o\">:=</span> <span class=\"s2\">\"Checks that a definition does not depend on any nonterminating functions\"</span>\n  <span class=\"n\">applicationTime</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">afterCompilation</span>\n  <span class=\"n\">add</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">decl</span> <span class=\"n\">_</span> <span class=\"n\">kind</span> <span class=\"bp\">↦</span> <span class=\"k\">do</span>\n    <span class=\"n\">unless</span> <span class=\"n\">kind</span> <span class=\"bp\">==</span> <span class=\"n\">AttributeKind.global</span> <span class=\"k\">do</span>\n      <span class=\"n\">throwError</span> <span class=\"s2\">\"invalid attribute 'terminates', must be global\"</span>\n    <span class=\"k\">let</span> <span class=\"o\">((</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">Meta.MetaM.run</span> <span class=\"bp\">&lt;|</span> <span class=\"o\">(</span><span class=\"n\">CollectPartial.collect</span> <span class=\"n\">decl</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">run</span> <span class=\"o\">{}</span>\n    <span class=\"n\">unless</span> <span class=\"n\">s.opaques.isEmpty</span> <span class=\"k\">do</span>\n      <span class=\"n\">logError</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"'{decl}' depends on opaques: {s.opaques.toList}\"</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>and then the test code has to be in a separate file:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">MyLib.TerminatesAttr</span>\n\n<span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">Unit</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">foo</span>\n<span class=\"kd\">@[terminating]</span> <span class=\"kd\">def</span> <span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"n\">Unit</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">foo</span> <span class=\"c1\">-- error</span>\n\n<span class=\"kd\">@[terminates]</span> <span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">safe</span> <span class=\"o\">:</span> <span class=\"n\">Unit</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">safe</span>\n<span class=\"kd\">@[terminating]</span> <span class=\"kd\">def</span> <span class=\"n\">baz</span> <span class=\"o\">:</span> <span class=\"n\">Unit</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">safe</span> <span class=\"c1\">-- ok</span>\n</code></pre></div>",
        "id": 388298665,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693479855
    },
    {
        "content": "<p>and then you could have things like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">terminates</span><span class=\"o\">]</span> <span class=\"n\">IO.getStdout</span> <span class=\"n\">IO.getStderr</span>\n</code></pre></div>\n<p>to whitelist IO functions you trust</p>",
        "id": 388299746,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693480307
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Sorry for the late reply but this is amazing, thank you so much for all the help!!</p>",
        "id": 388539692,
        "sender_full_name": "Quentin Januel",
        "timestamp": 1693579928
    }
]