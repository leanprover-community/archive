[
    {
        "content": "<p>I am trying to improve Lean’s support for guessing lexicographic orderings, and following an approach that's used by Isabelle. This guessing uses Lean’s default <code>decreasing_tactic</code>, or the user-specified one (but if they user specifies a tactic, then they probably have specified the termination order first anyways, and guessing isn’t really required).</p>\n<p>Here is a mutual function definition that goes through in Isabelle automatically:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">mutual</span>\n<span class=\"kd\">def</span> <span class=\"n\">prod</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">y</span> <span class=\"bp\">%</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"n\">eprod</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"k\">else</span> <span class=\"n\">oprod</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span>\n<span class=\"kd\">def</span> <span class=\"n\">oprod</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">eprod</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"kd\">def</span> <span class=\"n\">eprod</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"n\">z</span> <span class=\"k\">else</span> <span class=\"n\">prod</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"n\">z</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>The order that it infers is this one, which we can of course give explicitly:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">termination_by</span>\n  <span class=\"n\">prod</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">)</span>\n  <span class=\"n\">oprod</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"n\">eprod</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>However, it seems our default <code>deceasing_tactic</code> is far from handling that automatically. This is what I had to write to make it go through:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">macro_rules</span> <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">decreasing_trivial</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n              <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">apply</span> <span class=\"n\">Nat.le_refl</span><span class=\"o\">)</span>\n<span class=\"n\">macro_rules</span> <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">decreasing_trivial</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n              <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">apply</span> <span class=\"n\">Nat.succ_lt_succ</span><span class=\"bp\">;</span> <span class=\"n\">decreasing_trivial</span><span class=\"o\">)</span>\n<span class=\"n\">macro_rules</span> <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">decreasing_trivial</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n              <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">apply</span> <span class=\"n\">Nat.sub_le</span><span class=\"o\">)</span>\n<span class=\"n\">macro_rules</span> <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">decreasing_trivial</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n              <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">apply</span> <span class=\"n\">Nat.div_le_self</span><span class=\"o\">)</span>\n\n<span class=\"kd\">mutual</span>\n<span class=\"kd\">def</span> <span class=\"n\">prod</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">y</span> <span class=\"bp\">%</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"n\">eprod</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"k\">else</span> <span class=\"n\">oprod</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span>\n<span class=\"kd\">def</span> <span class=\"n\">oprod</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">eprod</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"kd\">def</span> <span class=\"n\">eprod</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"n\">z</span> <span class=\"k\">else</span> <span class=\"n\">prod</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"n\">z</span>\n<span class=\"kd\">end</span>\n<span class=\"n\">termination_by</span>\n  <span class=\"n\">prod</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">)</span>\n  <span class=\"n\">oprod</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"n\">eprod</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"n\">decreasing_by</span>\n  <span class=\"n\">simp_wf</span>\n  <span class=\"n\">solve</span>\n    <span class=\"bp\">|</span> <span class=\"n\">apply</span> <span class=\"n\">Prod.Lex.right'</span>\n      <span class=\"bp\">·</span> <span class=\"n\">solve</span> <span class=\"bp\">|</span> <span class=\"n\">decreasing_trivial</span>\n      <span class=\"bp\">·</span> <span class=\"n\">solve</span> <span class=\"bp\">|</span> <span class=\"n\">decreasing_trivial</span>\n    <span class=\"bp\">|</span> <span class=\"n\">apply</span> <span class=\"n\">Prod.Lex.left</span>\n      <span class=\"bp\">·</span> <span class=\"n\">solve</span> <span class=\"bp\">|</span> <span class=\"n\">decreasing_trivial</span>\n              <span class=\"bp\">|</span> <span class=\"n\">apply</span> <span class=\"n\">Nat.bitwise_rec_lemma</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span>\n</code></pre></div>\n<p>For comparison, <a href=\"https://github.com/leanprover/lean4/blob/baa4b68a71926a722b77d4ec2cba34bfc76cc5aa/src/Init/WFTactics.lean#L31-L45\">this is the default setup</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Constructs a proof of decreasing along a well founded relation, by applying</span>\n<span class=\"sd\">lexicographic order lemmas and using `ts` to solve the base case. If it fails,</span>\n<span class=\"sd\">it prints a message to help the user diagnose an ill-founded recursive definition. -/</span>\n<span class=\"n\">macro</span> <span class=\"s2\">\"decreasing_with \"</span> <span class=\"n\">ts</span><span class=\"o\">:</span><span class=\"n\">tacticSeq</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">=&gt;</span>\n <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span>\n   <span class=\"o\">(</span><span class=\"n\">simp_wf</span>\n    <span class=\"n\">repeat</span> <span class=\"o\">(</span><span class=\"n\">first</span> <span class=\"bp\">|</span> <span class=\"n\">apply</span> <span class=\"n\">Prod.Lex.right</span> <span class=\"bp\">|</span> <span class=\"n\">apply</span> <span class=\"n\">Prod.Lex.left</span><span class=\"o\">)</span>\n    <span class=\"n\">repeat</span> <span class=\"o\">(</span><span class=\"n\">first</span> <span class=\"bp\">|</span> <span class=\"n\">apply</span> <span class=\"n\">PSigma.Lex.right</span> <span class=\"bp\">|</span> <span class=\"n\">apply</span> <span class=\"n\">PSigma.Lex.left</span><span class=\"o\">)</span>\n    <span class=\"n\">first</span>\n    <span class=\"bp\">|</span> <span class=\"n\">done</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">ts</span>\n    <span class=\"bp\">|</span> <span class=\"n\">fail</span> <span class=\"s2\">\"failed to prove termination, possible solutions:</span>\n<span class=\"s2\">  - Use `have`-expressions to prove the remaining goals</span>\n<span class=\"s2\">  - Use `termination_by` to specify a different well-founded relation</span>\n<span class=\"s2\">  - Use `decreasing_by` to specify your own tactic for discharging this kind of goal\"</span><span class=\"o\">))</span>\n\n<span class=\"n\">macro</span> <span class=\"s2\">\"decreasing_tactic\"</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">decreasing_with</span> <span class=\"n\">first</span> <span class=\"bp\">|</span> <span class=\"n\">decreasing_trivial</span> <span class=\"bp\">|</span> <span class=\"n\">subst_vars</span><span class=\"bp\">;</span> <span class=\"n\">decreasing_trivial</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Notable points:</p>\n<ul>\n<li>The default setup uses <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Prod.Lex.right#doc\">docs#Prod.Lex.right</a>, which requires the left component on the pair to be defEq. This doesn’t work in the second recursive call, where the we need <code>y - 1 ≤ y</code>. There is a suitable lemma (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Prod.Lex.right%27#doc\">docs#Prod.Lex.right'</a>), but now we need backtracking, which the default <code>repeat</code> doesn't do, it seems.</li>\n<li>Not surprisingly, <code>decreasing_trivial</code> misses a lot of lemmas about <code>≤</code></li>\n<li>Instead of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.bitwise_rec_lemma#doc\">docs#Nat.bitwise_rec_lemma</a>, it would be more natural to use <code>Nat.div_lt_self</code>, but which tactic will reliably get <code>0 &lt; y</code> from <code>y ≠ 0</code>.</li>\n</ul>\n<p>It seems for the last two issues, it makes sense to wait for <code>omega</code> and start using that in <code>decreasing_trivial</code>, when maybe all these problems will dispappear, right. <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> ? :-)</p>\n<p>For the first issue – the more general lexicographic ordering lemma which will need backtracking, I am not sure what the best way forward will be. Or will <code>omega</code> be able to deal with goals of the form <code>x1 &lt; x2  \\/ (x1 ≤ x2 /\\ y1 &lt; y2)</code> natively?</p>\n<p>(Or maybe such function definitions are simply out of scope for us.)</p>",
        "id": 401607174,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1699789777
    },
    {
        "content": "<p>Furthermore, I found it hard to develop these termination tactics, partly because the tactic passed to <code>decreasing_by</code> is applied at every call.</p>\n<p>Wouldn’t it be much nicer if the goal after <code>termination_by</code> was a conjunction of all the proof obligations, and you could focus each goal with  <code>.</code> individually there? (Maybe starting with <code>all_goals simp_wf…</code> to get a more sensible goal). It might be doable; a downside might be that if you first collect all the proof obligations in one place, it’s harder to put the squiggly line under the right function call.</p>",
        "id": 401611227,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1699793421
    },
    {
        "content": "<p>I've also found filling in <code>decreasing_by</code> arguments hard for the same reason, so I'm in favour of your change.</p>",
        "id": 401811241,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1699895353
    },
    {
        "content": "<p>Great! I’ll ask you to <span aria-label=\"thumbs up\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"thumbs up\">:thumbs_up:</span>  the corresponding issue once I get around to it :-)</p>",
        "id": 401814269,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1699896496
    },
    {
        "content": "<p>+1</p>",
        "id": 401819375,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1699898553
    },
    {
        "content": "<p>I had a brief look, currently stuck passing more than MVar to <code>TacticM.run</code>: <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Lean.2EElab.2ETactic.2Erun.20but.20with.20multiple.20goals\">https://leanprover.zulipchat.com/#narrow/stream/217875-Is-there-code-for-X.3F/topic/Lean.2EElab.2ETactic.2Erun.20but.20with.20multiple.20goals</a></p>",
        "id": 402562067,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1700171061
    },
    {
        "content": "<p>I cast this idea into an RFC so that it has an issue number and a place to record more thoughts: <a href=\"https://github.com/leanprover/lean4/issues/2921\">https://github.com/leanprover/lean4/issues/2921</a></p>",
        "id": 403145198,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1700478073
    }
]