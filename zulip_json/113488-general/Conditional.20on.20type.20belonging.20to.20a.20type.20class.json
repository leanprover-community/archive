[
    {
        "content": "<p>Hello, folks. I'm trying to learn Lean for functional programming, and I was wondering if the following was possible. Consider the code below:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">MInterface</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">fm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\">  </span><span class=\"n\">MInterface</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">fm</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\">  </span><span class=\"n\">MInterface</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">fm</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MInterface</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">repr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Repr</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Repr</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">reprPrec</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">Repr</span><span class=\"bp\">.</span><span class=\"n\">reprPrec</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">repr</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"mi\">1</span><span class=\"bp\">⟩</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">lx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">⟨</span><span class=\"mi\">1</span><span class=\"bp\">⟩</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"s2\">\"ok\"</span><span class=\"bp\">⟩</span><span class=\"o\">]</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"c1\">-- 1</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">lx</span><span class=\"w\"> </span><span class=\"c1\">-- [1, \"ok\"]</span>\n</code></pre></div>\n<p>This <code>M</code> structure allows me to create lists having distinct types, as long as these types are all instances of some given class(es). All very good. Here is my \"problem\". In the code above, I've constrained <code>M</code> on <code>[repr : Repr T]</code>, which allowed me to make <code>M</code> an instance of <code>Repr</code>.</p>\n<p>Yet, I'd want to get rid of the <code>[repr: Repr T]</code> constraint, and instead make <code>M</code> an instance of <code>Repr</code> by providing a function that uses the <code>repr</code> for a given type if it belongs to such class, and otherwise it does something generic (like write the string \"no-repr\"). For example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">MyType</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">_</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"w\">  </span><span class=\"bp\">_</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\">  </span><span class=\"n\">MInterface</span><span class=\"w\"> </span><span class=\"n\">MyType</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">fm</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">._</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">._</span><span class=\"mi\">2</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">m1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyType</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">MyType</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">l2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">⟨</span><span class=\"mi\">1</span><span class=\"bp\">⟩</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"s2\">\"ok\"</span><span class=\"bp\">⟩</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">m1</span><span class=\"bp\">⟩</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- [1, \"ok\", \"no-repr\"]</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">l2</span>\n</code></pre></div>\n<p>This code fails, since <code>MyType</code> is not <code>Repr</code>, but I've commented what the desired output should be.<br>\nAn even better output would be using the <code>deriving Repr</code>.</p>\n<p>I mean, when I define <code>MyType</code> without the <code>deriving Repr</code>, Lean seems to infer it, since I can still use <code>#eval</code>. I was wondering if I could mimic this behavior.</p>",
        "id": 484564720,
        "sender_full_name": "DSB",
        "timestamp": 1732642578
    },
    {
        "content": "<p>i don't think there's a <em>safe</em> way to do that, without doing some elaboration shenanigans.</p>",
        "id": 484566083,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1732643077
    },
    {
        "content": "<p>What about adding a default low priority <code>Repr</code> instance for all types? Something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">priority</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Repr</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"n\">reprPrec</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"no-repr\"</span>\n</code></pre></div>",
        "id": 484566450,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1732643217
    },
    {
        "content": "<p>i'd recommend you inline the instance in a custom constructor</p>",
        "id": 484566503,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1732643241
    },
    {
        "content": "<p>otherwise, maybe something like <code>[repr:Repr T := default_repr T]</code> works? i don't know if instance synthesis or default argument takes precedence in this case though...</p>",
        "id": 484566736,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1732643325
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MInterface</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span>\n<span class=\"w\">  </span><span class=\"n\">repr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Repr</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">first</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">infer_instance</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">defaultRepr</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Repr</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">reprPrec</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">Repr</span><span class=\"bp\">.</span><span class=\"n\">reprPrec</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">repr</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">defaultRepr</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Repr</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">reprPrec</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"no-repr\"</span><span class=\"bp\">.</span><span class=\"n\">quote</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">MyType</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">_</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"w\">  </span><span class=\"bp\">_</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\">  </span><span class=\"n\">MInterface</span><span class=\"w\"> </span><span class=\"n\">MyType</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">fm</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">._</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">._</span><span class=\"mi\">2</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">m1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyType</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">MyType</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">l2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"s2\">\"ok\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">m1</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- [1, \"ok\", \"no-repr\"]</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">l2</span>\n</code></pre></div>\n<p>essentially does what you want.</p>",
        "id": 484568364,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1732643890
    },
    {
        "content": "<p>You won't be able to use the <code>⟨1⟩</code> notation though, not unless you make your own similar notation.</p>",
        "id": 484568463,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1732643923
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/channel/113488-general/topic/Conditional.20on.20type.20belonging.20to.20a.20type.20class/near/484566736\">said</a>:</p>\n<blockquote>\n<p>maybe something like <code>[repr:Repr T := default_repr T]</code> works?</p>\n</blockquote>\n<p>This isn't valid syntax, optional parameters only work for default binders <code>(x : T := v)</code></p>",
        "id": 484568797,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1732644037
    },
    {
        "content": "<p>right, that makes sense</p>",
        "id": 484568939,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1732644084
    },
    {
        "content": "<p>it was just a guess</p>",
        "id": 484568964,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1732644093
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"709428\">DSB</span> <a href=\"#narrow/channel/113488-general/topic/Conditional.20on.20type.20belonging.20to.20a.20type.20class/near/484564720\">said</a>:</p>\n<blockquote>\n<p>if it belongs to such class</p>\n</blockquote>\n<p>If you're coming from other functional languages, just watch out that typeclasses in Lean aren't constraints — instead they're just a mechanism for automatically synthesizing an implicit argument. There's a not very strong sense of \"belonging to a class\" (one definition might be \"<code>Repr T</code> is nonempty\", but then every <code>T</code> belongs to \"Repr\" since it's trivial to write a \"no repr\" instance, and another might be \"synthesis can find a <code>Repr T</code> instance\", but that can change depending on what instances are available). This means that unless you do what <code>Alex</code> suggests, with trying to pin down a Repr instance manually, then from within the <code>Repr M</code> instance there's nothing you can do to ask for the <code>Repr M.T</code> instance.</p>",
        "id": 484570556,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1732644706
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"709428\">DSB</span> <a href=\"#narrow/channel/113488-general/topic/Conditional.20on.20type.20belonging.20to.20a.20type.20class/near/484564720\">said</a>:</p>\n<blockquote>\n<p>This <code>M</code> structure allows me to create lists having distinct types</p>\n</blockquote>\n<p>Could you expand on what you're doing? I'm not sure I'm following what's supposed to be distinct from what.</p>",
        "id": 484571307,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1732644991
    },
    {
        "content": "<p>Thanks, <span class=\"user-mention\" data-user-id=\"448405\">@Alex Meiburg</span> ! Why the <code>⟨ ... ⟩</code> notation becomes unavailable? Also, is there a way to use the <code>deriving Repr</code> instead of the \"no-repr\"?</p>",
        "id": 484572997,
        "sender_full_name": "DSB",
        "timestamp": 1732645684
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> , the idea is that <code>M</code> represents something like <code>types that I can render in the screen</code>. Thus, I wish to have a collection (list) of such types, and apply a single <code>render</code> function over the list.</p>\n<p>I think, in summary, the idea is of ad-hoc polymorphisms. I want to create a collection of elements, all that have types with a <code>render</code> function, which can then be used individually.</p>",
        "id": 484573344,
        "sender_full_name": "DSB",
        "timestamp": 1732645807
    },
    {
        "content": "<p>That notation sees that M <em>can</em> take two arguments, so it insists on providing both arguments. It doesn't accept the fact that it's got a default value.</p>",
        "id": 484573380,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1732645819
    },
    {
        "content": "<p>(I've been wondering whether it's an oversight that anonymous constructor notation doesn't know about optParams (default values).)</p>",
        "id": 484573484,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1732645863
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"448405\">Alex Meiburg</span> <a href=\"#narrow/channel/113488-general/topic/Conditional.20on.20type.20belonging.20to.20a.20type.20class/near/484573380\">said</a>:</p>\n<blockquote>\n<p>That notation sees that M <em>can</em> take two arguments, so it insists on providing both arguments. It doesn't accept the fact that it's got a default value.</p>\n</blockquote>\n<p>How can one define his own notation? I see that the <code>M.mk</code> is passed to each element in the list. Can I define a quick notation that maps the <code>M.mk</code> to the elements somehow?</p>",
        "id": 484573610,
        "sender_full_name": "DSB",
        "timestamp": 1732645914
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"709428\">DSB</span> <a href=\"#narrow/channel/113488-general/topic/Conditional.20on.20type.20belonging.20to.20a.20type.20class/near/484573344\">said</a>:</p>\n<blockquote>\n<p>the idea is that <code>M</code> represents something like <code>types that I can render in the screen</code>. Thus, I wish to have a collection (list) of such types, and apply a single <code>render</code> function over the list.</p>\n</blockquote>\n<p>I see, then in that case I think your original solution is best. It's capturing a \"closure\" of what Lean sees as all the instances, and it's sort of the best you can hope for, beyond perhaps making it easy to have a \"no repr\" repr in scope when it is needed — that is, Yael's solution is pretty much what you'd be using. Alex's solution is Yael's solution without making the \"no repr\" repr be a global instance.</p>",
        "id": 484575060,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1732646564
    },
    {
        "content": "<p>I think it's worth thinking about why you have types that don't have the typeclass available design-wise. Can you instead ensure they all implement an instance for the class?</p>",
        "id": 484575152,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1732646612
    },
    {
        "content": "<p>In the case of Repr, it is just a convenience. Let me explain the whole idea.<br>\nThe structure <code>M</code> represents graphical primitive shapes. This means that if I create a type, say, <code>Circle</code>, I then create an instance of <code>M</code> for such <code>Circle</code> by providing a <code>render : Circle -&gt; Drawing</code>. Another primitive type could be <code>Rectangle</code> or <code>Square</code>, etc. The idea is that I have these primitive types, each of which I know how to represent as a drawing in the screen. Think of how SVG renders figures.</p>\n<p>Now, imagine I have a complex figure, where I have a list of many of such primitives. Hence, to render the whole list I map the <code>render</code> function to each element in the list (which are all instance of <code>M</code>, and therefore have a valid <code>render</code>).</p>\n<p>I then have a function that flattens <code>[Drawing] -&gt; Drawing</code> into a single drawing.<br>\nAll good. Now, for convenience, it would be nice to have a <code>repr</code> for my list of primitives (i.e. values of <code>List M</code>). Just so one can check what is inside, before rendering. I could force the <code>repr</code> in the primitive types. But this would not be \"nice\" from a design point of view, because having a <code>Repr</code> is not actually part of the specification.</p>",
        "id": 484575953,
        "sender_full_name": "DSB",
        "timestamp": 1732646941
    },
    {
        "content": "<p>I think unfortunately that's what you have to live with though, since you're using <code>repr</code> so it's become part of the specification. (One thing to think about: there's no runtime representation for Type, so there's no way to look up a <code>Repr</code> instance at runtime, even using \"unsafe\" code.)</p>",
        "id": 484576297,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1732647084
    },
    {
        "content": "<p>In that case you could 'tighten' Yael's approach, to something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">priority</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Drawable</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Repr</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"n\">reprPrec</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"no-repr\"</span>\n</code></pre></div>\n<p>(I'm assuming that <code>Drawable</code> is some class that specifies this <code>render: T -&gt; Drawing</code> method.) Now all Drawable's have a default Repr they can use. But this won't leak over to other types.</p>",
        "id": 484576316,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1732647101
    },
    {
        "content": "<p>If you know C++, you can think about <code>M</code> as being a way to associate a vtable to a value, and adding this <code>repr</code> field is how you can do the run-time polymorphism.</p>",
        "id": 484576464,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1732647150
    },
    {
        "content": "<p>To me, that feels much better than just doing it universal over all types. It's still localized to \"your\" types you're working with locally, and won't suddenly provide a Repr for e.g. some crazy category theory types.</p>",
        "id": 484576468,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1732647151
    },
    {
        "content": "<p>The code by Yael gives me an error... <br>\n<code>unexpected token ')'; expected term</code></p>\n<p>The same error appears in yours implementation, <span class=\"user-mention\" data-user-id=\"448405\">@Alex Meiburg</span> .</p>",
        "id": 484576592,
        "sender_full_name": "DSB",
        "timestamp": 1732647208
    },
    {
        "content": "<p>Just to check, that solution still involves putting a Repr instance in the <code>M</code> type, right <span class=\"user-mention\" data-user-id=\"448405\">@Alex Meiburg</span>? The point of it is to avoid polluting the global Repr instances?</p>",
        "id": 484576596,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1732647210
    },
    {
        "content": "<p>Yes, exactly</p>",
        "id": 484576620,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1732647223
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"709428\">@DSB</span> Yael was using a mathlib extension. Here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">priority</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Repr</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"n\">reprPrec</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"no-repr\"</span>\n</code></pre></div>",
        "id": 484576730,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1732647259
    },
    {
        "content": "<p>(apologies!)</p>",
        "id": 484577035,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1732647380
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"448405\">Alex Meiburg</span> <a href=\"#narrow/channel/113488-general/topic/Conditional.20on.20type.20belonging.20to.20a.20type.20class/near/484576316\">said</a>:</p>\n<blockquote>\n<p>In that case you could 'tighten' Yael's approach, to something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">priority</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Drawable</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Repr</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"n\">reprPrec</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"no-repr\"</span>\n</code></pre></div>\n<p>(I'm assuming that <code>Drawable</code> is some class that specifies this <code>render: T -&gt; Drawing</code> method.) Now all Drawable's have a default Repr they can use. But this won't leak over to other types.</p>\n</blockquote>\n<p>This <code>Drawable</code> would be the <code>M</code>?</p>",
        "id": 484578056,
        "sender_full_name": "DSB",
        "timestamp": 1732647817
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"709428\">@DSB</span> With that instance, the idea would be</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Drawable</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">repr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Repr</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span>\n</code></pre></div>\n<p>Since there's a <code>Drawable T</code> instance around, that enables this particular instance.</p>",
        "id": 484590396,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1732652733
    },
    {
        "content": "<p>Thank you all for the answers!</p>",
        "id": 484590691,
        "sender_full_name": "DSB",
        "timestamp": 1732652851
    },
    {
        "content": "<p>I guess my last question would be if this \"no-repr\" could instead be something like the <code>deriving Repr</code>. I mean, instead of a generic string, it somehow inspects the structure and gives something a bit more meaningful.</p>",
        "id": 484590888,
        "sender_full_name": "DSB",
        "timestamp": 1732652928
    },
    {
        "content": "<p>Are you types not the sorts of things you can do <code>deriving Repr</code> with? Or post-hoc do the <code>deriving instance Repr for YourTypeName</code> with?</p>",
        "id": 484591234,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1732653080
    },
    {
        "content": "<p>Whatever it is, it has to be done at compile time and not at runtime. There's no runtime representation for types, so there is not much to introspect at runtime. (There's just enough structure that the runtime is able to free objects and decrement reference counts when reference counts go to zero, but I don't believe any of that is accessible to Lean programs, and I'm sure this is anything you'd want to see in a <code>repr</code> instance anyway.)</p>",
        "id": 484591732,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1732653248
    }
]