[
    {
        "content": "<p>This question was probably asked here before, but I didn't find it on Zulip: Could doc gen open the namespace of a declaration before rendering it? In particular, I am looking at lemmas like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Limits.pullbackDiagonalMapIdIso_hom_fst#doc\">docs#CategoryTheory.Limits.pullbackDiagonalMapIdIso_hom_fst</a>. This is unreadable and I believe this is because <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.%C2%ABterm_%E2%89%AB_%C2%BB\">CategoryTheory.«term_≫_»</a> is scoped and hence not shown by the pretty printer if the namespace is not open.</p>",
        "id": 481956588,
        "sender_full_name": "Christian Merten",
        "timestamp": 1731420221
    },
    {
        "content": "<p>As far as I understand (cc <span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span>), the main obstacle for this is that there isn't a good place at the moment for the configuration which namespaces to open to live.</p>",
        "id": 481957504,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1731420474
    },
    {
        "content": "<p>Indeed, I guess if we would record what namespaces were open when a theorem was declared in some env extension we could do it?</p>",
        "id": 481957749,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1731420532
    },
    {
        "content": "<p>Is \"open the namespace of the declaration\" not a good approximation of which namespace to open?</p>",
        "id": 481957904,
        "sender_full_name": "Christian Merten",
        "timestamp": 1731420581
    },
    {
        "content": "<p>But there should be no reason for a heuristic solution here, this is a solvable problem if the elaborator cooperates</p>",
        "id": 481958093,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1731420628
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"648495\">Christian Merten</span> <a href=\"#narrow/channel/113488-general/topic/docgen.20scoped.20notations/near/481957904\">said</a>:</p>\n<blockquote>\n<p>Is \"open the namespace of the declaration\" not a good approximation of which namespace to open?</p>\n</blockquote>\n<p>If I understand your proposal correctly, this would lead to bad output in the <code>Algebra/Category</code> directory of mathlib.</p>",
        "id": 481958225,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1731420661
    },
    {
        "content": "<p>Ah yes, so it is a very rough approximation.</p>",
        "id": 481959065,
        "sender_full_name": "Christian Merten",
        "timestamp": 1731420887
    },
    {
        "content": "<p>What about, open all namespaces of terms appearing in the definition?</p>",
        "id": 481959427,
        "sender_full_name": "Christian Merten",
        "timestamp": 1731420980
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"648495\">Christian Merten</span> <a href=\"#narrow/channel/113488-general/topic/docgen.20scoped.20notations/near/481959427\">said</a>:</p>\n<blockquote>\n<p>What about, open all namespaces of terms appearing in the definition?</p>\n</blockquote>\n<p>Would this mean to print just the last segment of every constant?</p>",
        "id": 481959582,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1731421025
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/channel/113488-general/topic/docgen.20scoped.20notations/near/481959582\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"648495\">Christian Merten</span> <a href=\"#narrow/channel/113488-general/topic/docgen.20scoped.20notations/near/481959427\">said</a>:</p>\n<blockquote>\n<p>What about, open all namespaces of terms appearing in the definition?</p>\n</blockquote>\n<p>Would this mean to print just the last segment of every constant?</p>\n</blockquote>\n<p>You can do <code>open scoped &lt;namespace&gt;</code> to avoid this, no?</p>",
        "id": 481959897,
        "sender_full_name": "Christian Merten",
        "timestamp": 1731421103
    },
    {
        "content": "<p>Oh, I thought that you were referring to the documentation pages.</p>",
        "id": 481960059,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1731421145
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/issues/6050\">https://github.com/leanprover/lean4/issues/6050</a> recorded as an RFC</p>",
        "id": 481960294,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1731421204
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/channel/113488-general/topic/docgen.20scoped.20notations/near/481960059\">said</a>:</p>\n<blockquote>\n<p>Oh, I thought that you were referring to the documentation pages.</p>\n</blockquote>\n<p>I was, then I am probably misunderstanding something. Can you not do an equivalent of <code>open scoped</code> before rendering there?</p>",
        "id": 481960537,
        "sender_full_name": "Christian Merten",
        "timestamp": 1731421281
    },
    {
        "content": "<p>I guess that I was running under the assumption that the documentation was not checking what was <code>open</code>/<code>open scoped</code> and the RFC is precisely to add such awareness.  So, I guess that we were both discussing the same topic, but I was not assuming the RFC and you were!  <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 481961254,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1731421481
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> Christian is suggesting that, without the RFC, the heuristic that docgen could do is \"when processing a declaration, first set up the state that is the equivalent to doing <code>open scoped namespaceOfTheDecl</code>\". There's no need for awareness of the namespaces opened at the time of a declaration's definition with Christian's proposal, but it's an approximation.</p>",
        "id": 482206118,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1731513519
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/113488-general/topic/docgen.20scoped.20notations/near/482206118\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> Christian is suggesting that, without the RFC, the heuristic that docgen could do is \"when processing a declaration, first set up the state that is the equivalent to doing <code>open scoped namespaceOfTheDecl</code>\". There's no need for awareness of the namespaces opened at the time of a declaration's definition with Christian's proposal, but it's an approximation.</p>\n</blockquote>\n<p>(and since it was pointed out above that <code>namespaceOfTheDecl</code> is not sufficient, it could be <code>open scoped namespaceOfTerm</code> for every <code>Term</code> appearing in the statement of <code>Decl</code>)</p>",
        "id": 482207939,
        "sender_full_name": "Christian Merten",
        "timestamp": 1731513980
    },
    {
        "content": "<p>Ah, ok, I understand now: sorry for creating confusion with my confusion!  <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 482208797,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1731514191
    },
    {
        "content": "<p>Even that is not sufficient, as <code>open scoped Manifold</code> is widely used but the <code>Manifold</code> namespace has only two very specialised declarations.</p>",
        "id": 483449742,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1732098050
    },
    {
        "content": "<p>... Huh, this was only a recent thing? Because e.g. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.whiskeringLeftObjCompIso#doc\">docs#CategoryTheory.whiskeringLeftObjCompIso</a> has been <code>Functor C D</code> and <code>F.comp G</code> for ages; in fact I don't think any of the category theory notations have been showing up in docs for a while. I'd just assumed that notation didn't work in docs in general, but apparently that's just a category theory thing?</p>",
        "id": 510057574,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1743725058
    },
    {
        "content": "<p>The docs don't make use of scoped notation <span class=\"user-mention\" data-user-id=\"359992\">@Robert Maxton</span>. The problem today was that even notations like for <code>Iff</code>, <code>Eq</code>, or <code>HAdd.hAdd</code> weren't being used.</p>",
        "id": 510057924,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743725240
    },
    {
        "content": "<p>Can we do something about this though? it's quite cumbersome to look at <code>CategoryStruct.comp</code></p>",
        "id": 510057977,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1743725269
    },
    {
        "content": "<p>Ahh, I see. That makes... well okay, it's a good explanation, but -- yeah it'd be quite nice if that were otherwise, I can't say that it 'makes sense' as a design choice :p</p>",
        "id": 510058060,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1743725294
    },
    {
        "content": "<p>4 messages were moved here from <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/channel/287929-mathlib4/topic/No.20notation.20in.20.23docs/with/509882147\">#mathlib4 &gt; No notation in #docs</a> by <span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span>.</p>",
        "id": 510058880,
        "sender_full_name": "Notification Bot",
        "timestamp": 1743725830
    },
    {
        "content": "<p>I moved the discussion here <span class=\"user-mention\" data-user-id=\"359992\">@Robert Maxton</span>.</p>",
        "id": 510059052,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743725905
    },
    {
        "content": "<p>so I see!</p>",
        "id": 510059064,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1743725915
    },
    {
        "content": "<p>Oh, hey, there is an RFC, that's helpful. </p>\n<p>I'm surprised that this isn't as simple as \"record the def statement exactly as produced by the user during normal compilation and then transform it\", though, since doc comments are part of the underlying language/not just normal whitespace comments anyway...?</p>",
        "id": 510059651,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1743726250
    },
    {
        "content": "<p>Are you saying that you're surprised that docgen tries to pretty print declaration signatures using the actual computed types rather than trying to transform the source code directly?</p>",
        "id": 510063488,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743728590
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/113488-general/topic/docgen.20scoped.20notations/near/510063488\">said</a>:</p>\n<blockquote>\n<p>Are you saying that you're surprised that docgen tries to pretty print declaration signatures using the actual computed types rather than trying to transform the source code directly?</p>\n</blockquote>\n<p>Sort of? More that it tries to do something other than \"work through the existing display channels, in particular the standard delaborator\"</p>",
        "id": 510063622,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1743728671
    },
    {
        "content": "<p>Generate the docgen data in the same pass as normal compilation</p>",
        "id": 510063872,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1743728805
    },
    {
        "content": "<p>Ok, so you're surprised that docgen decides to create the documentation by loading all the compiled oleans and pretty printing the results?</p>",
        "id": 510063940,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743728842
    },
    {
        "content": "<p>One good reason not to do this is that it's a lot faster to create the documentation than to compile mathlib. For example, downstream projects can compile their own project and generate full documentation with mathlib documentation without compiling mathlib themselves.</p>",
        "id": 510064063,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743728912
    },
    {
        "content": "<p>(Are you surprised because you think nobody thought about doing documentation generating in the same pass as compilation? Or that the idea was discarded early on?)</p>",
        "id": 510064159,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743728980
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/113488-general/topic/docgen.20scoped.20notations/near/510063940\">said</a>:</p>\n<blockquote>\n<p>Ok, so you're surprised that docgen decides to create the documentation by loading all the compiled oleans and pretty printing the results?</p>\n</blockquote>\n<p>That sounds about right, yeah. Since Lean notation can get <em>so</em> elaborate and also <em>so</em> integral to its purpose, it seems like it should be a bit more of a 'first class citizen'</p>",
        "id": 510064179,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1743728999
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/113488-general/topic/docgen.20scoped.20notations/near/510064159\">said</a>:</p>\n<blockquote>\n<p>(Are you surprised because you think nobody thought about doing documentation generating in the same pass as compilation? Or that the idea was discarded early on?)</p>\n</blockquote>\n<p>Either would be surprising, but I suppose mostly the second!</p>",
        "id": 510064243,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1743729016
    },
    {
        "content": "<p>Given that you seem to know about how scoped notations work, I'm surprised that your opinion is \"I can't say that it 'makes sense' as a design choice\". The current way it works is the obviously-not-incorrect approach. It's what you see if you <code>import Mathlib</code> and <code>#check</code> the declaration. It would be surprising if that used notations you couldn't use yourself, right?</p>",
        "id": 510064630,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743729250
    },
    {
        "content": "<p>It's not uncommon also for new notations to be defined later. Consider all the definitions in the prelude (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.le_trans#doc\">docs#Nat.le_trans</a> is one). Should the documentation print that using only the available notations? That's what your suggestion would result in. <code>LE.le n m → LE.le m k → LE.le n k</code></p>",
        "id": 510064721,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743729319
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/113488-general/topic/docgen.20scoped.20notations/near/510064630\">said</a>:</p>\n<blockquote>\n<p>Given that you seem to know about how scoped notations work, I'm surprised that your opinion is \"I can't say that it 'makes sense' as a design choice\". The current way it works is the obviously-not-incorrect approach. It's what you see if you <code>import Mathlib</code> and <code>#check</code> the declaration. It would be surprising if that used notations you couldn't use yourself, right?</p>\n</blockquote>\n<p>Sorry if that came off harsh. I don't think this is \"obviously not incorrect\", though, as it results in surprisingly illegible docs precisely when you need them most. </p>\n<p>In general, my position is that digital environments should present as 'real', concrete environments by default and deviate from that only with a positive reason to be otherwise. In this case, when I work in Lean, I set up my elaborators and delaborators and spend time on my notation, and when I'm done I sit back and see that indeed I can type math fluently into my code and, just as importantly, that Lean uses it when reporting back to me; I feel that Lean \"understands my notation\". It is therefore surprising when I go use the docgen feature, which again is hooking into something I've been building \"along the way\" as I work, only to discover that it apparently sees an entirely** different environment than I do. To borrow a term, it breaks immersion.</p>\n<p>** Yes, I know it's not actually an entirely different mechanism, the point is about user experience rather than the actual underlying code</p>",
        "id": 510065937,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1743730027
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/113488-general/topic/docgen.20scoped.20notations/near/510064721\">said</a>:</p>\n<blockquote>\n<p>It's not uncommon also for new notations to be defined later. Consider all the definitions in the prelude (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.le_trans#doc\">docs#Nat.le_trans</a> is one). Should the documentation print that using only the available notations? That's what your suggestion would result in. <code>LE.le n m → LE.le m k → LE.le n k</code></p>\n</blockquote>\n<p>While of course the maximally correct option is \"having a place to specify the context in which documentation is generated\", yes, I would actually prefer that. It would be annoying, but the prelude is only one, relatively short file, the set of places where Mathlib uses a concept far ahead of its notation are only a few short files out of thousands. Furthermore, it would adhere to the above principle of consistency: it would match what I see when I open the prelude in Lean, as presumably for that exact reason I wouldn't be able to use or read those notations while editing.</p>",
        "id": 510066154,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1743730154
    },
    {
        "content": "<p>In general, I would be in favor of coming up with a way to display some scoped notations in doc-gen. However, I don't think it can just be: display all scoped notations, because they might conflict.</p>",
        "id": 510073234,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1743734323
    },
    {
        "content": "<p>I can confirm that it is a great impediment to my productivity that the docs don't show category theory notation!</p>",
        "id": 510089067,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1743744360
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/113488-general/topic/docgen.20scoped.20notations/near/510073234\">said</a>:</p>\n<blockquote>\n<p>In general, I would be in favor of coming up with a way to display some scoped notations in doc-gen. However, I don't think it can just be: display all scoped notations, because they might conflict.</p>\n</blockquote>\n<p>In Lean 3, doc-gen opened all locales and it was working great from my point of view. Personally I think that was a more correct design than what we have now. Even more correct would be to pretty-print file X with the scopes opened in X.lean. If that results in ambiguous notation:</p>\n<ol>\n<li>It's usually pretty clear from context which notation is meant. Biggest counterexample to that is probably <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Functor.LaxMonoidal#doc\">docs#CategoryTheory.Functor.LaxMonoidal</a>.ε with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Mon_Class.mul#doc\">docs#Mon_Class.mul</a>, which I will remark is an annoying pair even outside the context of pretty-printing!</li>\n<li>In the docs, you can click on notation to see what it stands for.</li>\n</ol>",
        "id": 510089889,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1743744830
    },
    {
        "content": "<p>Here's a tentative algorithm: When creating documentation for file X, scan for <code>open ...</code> and for <code>open scoped ...</code>, open the relevant scopes, pretty-print each declaration in X</p>",
        "id": 510090310,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1743745048
    },
    {
        "content": "<p>An alternative (I am not clear whether it's better or worse than the previous, but it should result in equal docs in most cases): When creating documentation for file X, scan the .lean file for <code>namespace</code>, <code>section</code>, <code>open ...</code>, and figure out from this information which declaration had which scope open, pretty-print each declaration according to which scopes were opened then</p>",
        "id": 510090639,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1743745258
    },
    {
        "content": "<p>I am not clear about whether sections and namespaces are recorded in oleans. My understanding is that oleans contain quite a huge lot of stuff which we almost never use (eg proof terms are only used in leanchecker), so including the data of <code>section</code>, <code>namespace</code> and <code>open</code> doesn't sound like a big ask.</p>",
        "id": 510090882,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1743745416
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113488-general/topic/docgen.20scoped.20notations/near/510064721\">said</a>:</p>\n<blockquote>\n<p>It's not uncommon also for new notations to be defined later. Consider all the definitions in the prelude (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.le_trans#doc\">docs#Nat.le_trans</a> is one). Should the documentation print that using only the available notations? That's what your suggestion would result in. <code>LE.le n m → LE.le m k → LE.le n k</code></p>\n</blockquote>\n<p>To clarify, with the algorithm I've just offered, documentation would display global notation that's defined later, scoped notation iff the scope already existed and was open then, and not display local notation. That seems morally correct to me</p>",
        "id": 510091131,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1743745563
    },
    {
        "content": "<p>My personal understanding was that we had to give up on displaying scoped notation in Lean 4 for transient technical reasons. Therefore I am surprised to hear that there was no plan to bring it back!</p>",
        "id": 510091195,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1743745628
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/113488-general/topic/docgen.20scoped.20notations/near/510091195\">said</a>:</p>\n<blockquote>\n<p>Therefore I am surprised to hear that there was no plan to bring it back!</p>\n</blockquote>\n<p>Where did you hear this? In this thread, there's an RFC about collecting the <code>open</code> information so that it's possible to open scoped notations for docgen.</p>",
        "id": 510092496,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743746405
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/pull/6050\">lean4#6050</a></p>",
        "id": 510092555,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743746443
    },
    {
        "content": "<p>Ah sorry, I missed that link. Then I am happy <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 510093689,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1743746997
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/channel/113488-general/topic/docgen.20scoped.20notations/near/510073234\">said</a>:</p>\n<blockquote>\n<p>In general, I would be in favor of coming up with a way to display some scoped notations in doc-gen. However, I don't think it can just be: display all scoped notations, because they might conflict.</p>\n</blockquote>\n<p>If they would conflict in the docs, surely they must already conflict in the code, no?</p>",
        "id": 510097659,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1743747650
    },
    {
        "content": "<p>No, because the point of scoped notation is that you can decide notations you want to enable. I've been confused about you saying notation should feel like a first-class citizen, when being able to enable and disable it like this is what that would mean — unless you mean something else by that?</p>",
        "id": 510101204,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743748157
    },
    {
        "content": "<p><em>Is</em> there a way to disable them? AFAIK, you can decide what notations you want to enable, but only by opening various scopes, and the only way to 'close' them would be to close the entire section it's in. Maybe I've missed something?</p>\n<p>Though, that said, I don't think it really matters to my argument -- either way, if you're tracking the context in which the (doc comment using the) notation is used, then either it will be ambiguous in both, or whatever means you can use to disambiguate in the codebase proper -- in this case, sectioning data (which already needs to be tracked for things like universes and variable declarations, I would have thought?) and <code>open</code>s -- and can be used disambiguate the docs.</p>",
        "id": 510101760,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1743748435
    },
    {
        "content": "<p>The central issue is that doc-gen generates the documentation from the olean files by calling into various lean facilities. This is the correct way to go for various reasons pointed out above. The olean files in turn do not currently contain the information about which namespaces had been open during the declaration of a definition and thus it is impossible to recover this information in doc-gen right now. There is an RFC linked above which explains how we can get around these limitations by doing some work in core (namely tracking the open namespaces in the olean files through an environment extension). Which is to say that on a technical level this problem is solved, it is just not implemented.</p>",
        "id": 510102561,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1743748750
    },
    {
        "content": "<p>There's a pareto frontier here <span class=\"user-mention\" data-user-id=\"359992\">@Robert Maxton</span>. Docgen tends toward showing you the documentation for a library-as-it-is-imported. You have mentioned that you would rather have a pretty version of the declaration-headers-as-they-appear. These are both defensible.</p>",
        "id": 510102572,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743748756
    },
    {
        "content": "<p>... I suppose that RFC is precisely \"no we are not currently tracking the namespaces opened\", but then I get back to \"huh, it's not just part of compilation?\" Feels like doing it this way requires solving a nontrivial problem (the entire system of d/elaboration) twice</p>",
        "id": 510102641,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1743748790
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/113488-general/topic/docgen.20scoped.20notations/near/510102572\">said</a>:</p>\n<blockquote>\n<p>There's a pareto frontier here <span class=\"user-mention silent\" data-user-id=\"359992\">Robert Maxton</span>. Docgen tends toward showing you the documentation for a library-as-it-is-imported. You have mentioned that you would rather have a pretty version of the declaration-headers-as-they-appear. These are both defensible.</p>\n</blockquote>\n<p>Fair enough!</p>",
        "id": 510102658,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1743748796
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"359992\">Robert Maxton</span> <a href=\"#narrow/stream/113488-general/topic/docgen.20scoped.20notations/near/510102641\">said</a>:</p>\n<blockquote>\n<p>... I suppose that RFC is precisely \"no we are not currently tracking the namespaces opened\", but then I get back to \"huh, it's not just part of compilation?\" Feels like doing it this way requires solving a nontrivial problem (the entire system of d/elaboration) twice</p>\n</blockquote>\n<p>The compiler tracks the namespaces, the information is just not persisted in the olean files, this is the case for a lot of information.</p>",
        "id": 510102778,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1743748839
    }
]