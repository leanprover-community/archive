[
    {
        "content": "<p>Here is a fun example demonstrating that misunderstanding of the way Nat behaves may lead to  \"proofs\". Is there a way to make sure that something like this does not happen deep deep deep in libraries?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Fermat</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">omega</span>\n</code></pre></div>",
        "id": 471640946,
        "sender_full_name": "Anton Mellit",
        "timestamp": 1726816079
    },
    {
        "content": "<p>h1 is just assuming a proof of False. Unless you are in an inconsistent situation you'll never be able to provide that argument.</p>",
        "id": 471641286,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1726816179
    },
    {
        "content": "<p>The problem here is mostly with the definition, and something general which works for these is checking specific examples, and proving stuff using it</p>",
        "id": 471641969,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1726816392
    },
    {
        "content": "<p>in other words, while this is a concern for the main statement of the theorem, it's not an issue deep deep deep in the middle of a proof, because anything which is assumed has to be proved later so if it was trivially true or trivially false then the proof would not hold together</p>",
        "id": 471646019,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726817431
    },
    {
        "content": "<p>it is a concern for large libraries in the sense that they are large collections of theorems, not necessarily all related to each other, so there is a possibility that one of those theorems is accidentally trivialized and no one has noticed because it is not being used</p>",
        "id": 471646345,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726817487
    },
    {
        "content": "<p>So would it be worth it to lint against such things? To check if a theorem assumes an hypothesis which reduces to False?</p>",
        "id": 471646606,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1726817528
    },
    {
        "content": "<p>We have a linter <code>synTaut</code> for catching refl lemmas that are literally proving <code>a = a</code> (and are not <code>Eq.rfl</code> itself)</p>",
        "id": 471646758,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726817564
    },
    {
        "content": "<p>Yeah, trying with n=3 will uncover the problem.  I am thinking of a situation when the assumptions would be convoluted, and some straightforward cases would be ok, for instance I would have an actual correct proof for n&lt;100000, and for n&gt;100000 the assumptions would be accidentally inconsistent</p>",
        "id": 471647131,
        "sender_full_name": "Anton Mellit",
        "timestamp": 1726817659
    },
    {
        "content": "<p>I think a more general version of that is <code>nitpick</code>, which is an isabelle linter which tells you when the theorem you have stated is false. Theorems that are true but trivial are a bit harder because there are genuine reasons you might want to state a trivial theorem (as evidenced by the fact that the most popular proof in mathlib by a large margin is <code>rfl</code>)</p>",
        "id": 471647348,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726817701
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"675145\">@Anton Mellit</span> in that case the assumptions are not inconsistent, they just imply n &lt;= 100000</p>",
        "id": 471647909,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726817795
    },
    {
        "content": "<p>which might be an actual part of the proof</p>",
        "id": 471647983,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726817807
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Fermat.20Last.20theorem.20by.20omega/near/471647348\">said</a>:</p>\n<blockquote>\n<p>I think a more general version of that is <code>nitpick</code>, which is an isabelle linter which tells you when the theorem you have stated is false. [...]</p>\n</blockquote>\n<p>Is that like <code>slim_check</code>?</p>",
        "id": 471648292,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1726817858
    },
    {
        "content": "<p>yes, except it runs as a linter instead of being called explicitly</p>",
        "id": 471648387,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726817875
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"690858\">Daniel Weber</span> <a href=\"#narrow/stream/113488-general/topic/Fermat.20Last.20theorem.20by.20omega/near/471648292\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Fermat.20Last.20theorem.20by.20omega/near/471647348\">said</a>:</p>\n<blockquote>\n<p>I think a more general version of that is <code>nitpick</code>, which is an isabelle linter which tells you when the theorem you have stated is false. [...]</p>\n</blockquote>\n<p>Is that like <code>slim_check</code>?</p>\n</blockquote>\n<p>Nitpick is much further developed than <code>slim_check</code> it uses a SAT solver to perform model finding and not just random exploration of the search space. That said I've been thinking for a while about pulling <code>slim_check</code> from mathlib and just making it its own library so everyone <span aria-label=\"tm\" class=\"emoji emoji-2122\" role=\"img\" title=\"tm\">:tm:</span> can benefit from it. It would be even cooler if we could integrate it with the <code>by</code> keyword in core but I'm not sure if that would scope creep a little.</p>",
        "id": 471650802,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1726818311
    },
    {
        "content": "<p>I think it needs a rewrite, it should not be implemented through the typeclass system</p>",
        "id": 471652630,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726818760
    },
    {
        "content": "<p>I think if we had a deriving handler for it it would be quite fine</p>",
        "id": 471652899,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1726818829
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/113488-general/topic/Fermat.20Last.20theorem.20by.20omega/near/471650802\">said</a>:</p>\n<blockquote>\n<p>It would be even cooler if we could integrate it with the <code>by</code> keyword in core but I'm not sure if that would scope creep a little.</p>\n</blockquote>\n<p>I thought that \"scope creep\" was the subtitle of lean core</p>",
        "id": 471652940,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726818838
    },
    {
        "content": "<p>There are things that can't be implemented in slim_check because the enumeration happens at the object level instead of the meta level. E.g. you can't use it to check theorems about real numbers because things aren't <code>Decidable</code> even if <code>linarith</code> can find a trivial contradiction</p>",
        "id": 471653384,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726818921
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Fermat.20Last.20theorem.20by.20omega/near/471652940\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/113488-general/topic/Fermat.20Last.20theorem.20by.20omega/near/471650802\">said</a>:</p>\n<blockquote>\n<p>It would be even cooler if we could integrate it with the <code>by</code> keyword in core but I'm not sure if that would scope creep a little.</p>\n</blockquote>\n<p>I thought that \"scope creep\" was the subtitle of lean core</p>\n</blockquote>\n<p>Not really no.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Fermat.20Last.20theorem.20by.20omega/near/471653384\">said</a>:</p>\n<blockquote>\n<p>There are things that can't be implemented in slim_check because the enumeration happens at the object level instead of the meta level. E.g. you can't use it to check theorems about real numbers because things aren't <code>Decidable</code> even if <code>linarith</code> can find a trivial contradiction</p>\n</blockquote>\n<p>Right</p>",
        "id": 471657635,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1726819883
    },
    {
        "content": "<p>Is it possible to port nitpick to Lean? It sounds like a very great thing.</p>",
        "id": 471726598,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1726838239
    },
    {
        "content": "<p>Given the incompatability between the logics of Isabelle and Lean a direct port would not be possible no. Iirc getting SAT based model finders compatible with HOL was already research work at the time, whether it is trivial to extend this work to DTT or not I don't know. Either way it would not be a trivial endeavour to write up in Lean. Though a sufficiently skilled Lean developer that is willing to dig into the matter could probably get there.</p>",
        "id": 471726875,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1726838314
    },
    {
        "content": "<p>When I was just getting into theorem proving, I tried translating a science derivation into logic (was using automated theorem prover KeYmaera X) and would often make mistakes when writing down the theorem. The logic expert on our team explained the principle of explosion to me; our context had several hypotheses and ensuring they were all consistent wasn’t always simple. Eventually (because the theorem prover was automated) I adjusted my workflow so before trying to prove “the thing I wanted,” I’d change the conjecture to “1=0,” then run the prover, and if it immediately returned True, I’d use that signal to go back and check my assumptions.</p>\n<p>So, I think building automated consistency checking would be helpful. It would be great if VS code could check, after a theorem is stated, whether the hypotheses are consistent. Maybe in some cases, the compute required would be unreasonable and so the checking should be turned off, but I think scientists and engineers would find this useful. I have some proposals out for automatically constructing theories using LLMs and checking them with a theorem prover, and propose some controls like this for ensuring consistency.</p>",
        "id": 472211755,
        "sender_full_name": "Tyler Josephson ⚛️",
        "timestamp": 1727093438
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/13999\">#13999</a> is an in-progress PR adding a linter against e.g. natural number subtraction. As I understand the linter, it would have caught this example.</p>",
        "id": 472213417,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1727093830
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"424214\">@Tyler Josephson ⚛️</span> it would certainly be nice to have tooling like in <a href=\"https://github.com/leanprover-community/mathlib4/pull/13999\">#13999</a> to find user error automatically. However, do you realize that what you're asking for is not possible in general? That is, by Gödel's incompleteness theorems, it is not possible for Lean (or anything of equivalent proving power) to tell you: \"your context is consistent\" (even an empty context, because Lean has its own axioms). It can only tell you: \"your context is inconsistent because I can prove false\", and even then, it has to find a proof of <code>False</code>, which may be arbitrarily hard.</p>\n<p>Again, this doesn't preclude things like <code>slim_check</code> or similar to help avoid simple mistakes.</p>",
        "id": 472250433,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1727102189
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> Yes, indeed. I bet some amount of decision-making would be needed to decide which cases are worth catching automatically. If there was movement on this, I could check with my group and see what kinds of cases we'd all find useful. For example, catching simple equality / inequality relationships among naturals, rationals, and reals would go pretty far. Here's one example (from <a href=\"https://www.nature.com/articles/s41467-023-37236-y?fromPaywallRec=false\">here</a>) - making a mistake when writing these down can lead to an inconsistency.<br>\n<a href=\"/user_uploads/3121/JSu0t8VbJhpiCmMY9PNAQfkk/Screenshot-2024-09-23-at-11.11.09AM.png\">Screenshot-2024-09-23-at-11.11.09AM.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/JSu0t8VbJhpiCmMY9PNAQfkk/Screenshot-2024-09-23-at-11.11.09AM.png\" title=\"Screenshot-2024-09-23-at-11.11.09AM.png\"><img data-original-dimensions=\"920x322\" src=\"/user_uploads/thumbnail/3121/JSu0t8VbJhpiCmMY9PNAQfkk/Screenshot-2024-09-23-at-11.11.09AM.png/840x560.webp\"></a></div>",
        "id": 472260044,
        "sender_full_name": "Tyler Josephson ⚛️",
        "timestamp": 1727104401
    },
    {
        "content": "<p>I wonder how much one could already cover your use-case by a simple macro which runs essentially <code>exfalso; aesop</code> or another strong finisher tactic which can find contradictions:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">fail_if_success</span><span class=\"w\"> </span><span class=\"n\">exfalso</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">aesop</span><span class=\"w\"> </span><span class=\"c1\">-- failure: tactic succeeded</span>\n</code></pre></div>",
        "id": 472303454,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1727116975
    },
    {
        "content": "<p>Some weeks ago I brought up the topic of automatic counterexample finding in a different thread.</p>\n<p><a href=\"#narrow/stream/270676-lean4/topic/Model.20finding.2FAutomatic.20counter.20example.20generation.20in.20Lean/near/451552547\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Model.20finding.2FAutomatic.20counter.20example.20generation.20in.20Lean/near/451552547</a></p>\n<p>I'd generally be interested in working on this topic and have started reading about Nitpick. It translates the Isabelle problem to Kodkod but I'm not sure if that is still state of the art or if there are now better tools for model finding. </p>\n<p>There is also the design question of whether to have a lightweight tool that runs in the background or a more powerful counterexample generator that needs to be run explicitly. Ideally, one could have a single tool that can be run with different settings to achieve both goals, but this might be even harder to come up with...</p>",
        "id": 472500489,
        "sender_full_name": "Jonas Bayer",
        "timestamp": 1727186043
    },
    {
        "content": "<p>I'd encourage anyone exploring this to aim for lightweight, extensible, and automatic.</p>",
        "id": 472581557,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1727216096
    },
    {
        "content": "<p>Although it is worth considering that for counterexample finding no proofs are necessary, so an extensible mechanism to hand problems to an unverified SMT solver is perhaps viable. However that worked then require users to have an external tool, which would limit adoption.</p>",
        "id": 472581731,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1727216212
    },
    {
        "content": "<p>If your counterexample doesn't come with a proof it might not be a counterexample after all. Any statement in Lean with junk values is particularly vulnerable to this, as the SMT solver might not model them correctly</p>",
        "id": 472593950,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727225299
    },
    {
        "content": "<p>In Isabelle, nitpick can return \"found a potentially spurious counterexample\" when the example cannot be verified.</p>",
        "id": 472734261,
        "sender_full_name": "Jonas Bayer",
        "timestamp": 1727281418
    }
]