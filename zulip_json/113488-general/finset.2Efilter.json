[
    {
        "content": "<p>I am often writing</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">let</span> <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"bp\">→</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">univ</span><span class=\"bp\">.</span><span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">),</span>\n</code></pre></div>\n\n\n<p>I don't really like this, for two reasons:</p>\n<ol>\n<li>It would be infinitely better if we could write <code>{ x | x i = 0 }</code>.</li>\n<li>If you have <code>hx : x ∈ S</code> and <code>rewrite mem_filter at hx</code>, then you end up with <code>hx : x ∈ univ ∧ x i = 0</code>.</li>\n</ol>\n<p>Of course (2) can be solved by a simp-lemma <code>mem_filter_univ</code>, but is there something that could be done about the aesthetics?</p>",
        "id": 195533535,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1588063078
    },
    {
        "content": "<p>I really want to have a <code>has_sep</code> instance for <code>finset</code>, but the type doesn't work - the predicate has to be decidable</p>",
        "id": 195533693,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588063178
    },
    {
        "content": "<p>maybe we should just have a noncomputable instance</p>",
        "id": 195533716,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588063190
    },
    {
        "content": "<p>What are the consequences of doing that?</p>",
        "id": 195534512,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1588063739
    },
    {
        "content": "<p>I guess we don't want to break computability for every fintype. Fintypes are a place where computation can be pretty useful.</p>",
        "id": 195534580,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1588063777
    },
    {
        "content": "<p>I mean you can define a non-computable version of filter and call it <code>ncfilter</code> or something</p>",
        "id": 195534664,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1588063809
    },
    {
        "content": "<p>and then the <code>has_sep</code> would call <code>ncfilter</code></p>",
        "id": 195534697,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1588063832
    },
    {
        "content": "<p>With a low priority?</p>",
        "id": 195534729,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1588063859
    },
    {
        "content": "<p>I know nothing about priority</p>",
        "id": 195534760,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1588063882
    },
    {
        "content": "<p>But we could still end up with the wrong <code>{ x | is_cool x }</code> on fintypes with decidable eq etc, right?</p>",
        "id": 195534773,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1588063892
    },
    {
        "content": "<p>I don't understand. We're using <code>{ x | some_nc_pred x }</code></p>",
        "id": 195534886,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1588063953
    },
    {
        "content": "<p>Hmm, I guess I'm the one that is confused.</p>",
        "id": 195534997,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1588064015
    },
    {
        "content": "<p>I just know that stuff is more complicated and ugly than it should be. And I would like some fairy or elf to fix it.</p>",
        "id": 195535077,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1588064051
    },
    {
        "content": "<ol>\n<li>looks like <a href=\"https://github.com/leanprover-community/lean/search?q=set_of&amp;unscoped_q=set_of\" title=\"https://github.com/leanprover-community/lean/search?q=set_of&amp;unscoped_q=set_of\"><code>{ x : ℕ | x = x }</code> is hard-wired into Lean with C++ so we can't change it, and it isn't <code>has_sep</code></a></li>\n<li>and <a href=\"https://github.com/leanprover-community/mathlib/search?q=has_sep&amp;unscoped_q=has_sep\" title=\"https://github.com/leanprover-community/mathlib/search?q=has_sep&amp;unscoped_q=has_sep\">we already have a <code>has_sep</code> for <code>finset</code></a></li>\n<li>so the best we can do is <code>{ x ∈ univ | x i = 0 }</code></li>\n</ol>",
        "id": 195535788,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1588064505
    },
    {
        "content": "<ol>\n<li>\"we can't change it\" is no longer true</li>\n<li>ok, that's cool, thanks!</li>\n<li>which looks a lot better, thanks so much! But the <code>∈ univ</code> is of course really silly</li>\n</ol>",
        "id": 195535961,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1588064634
    }
]