[
    {
        "content": "<p>If you match on a string, you can obviously match using a string literal pattern, but you can also match using its constructor:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ctor_match</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"s2\">\"Good\"</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"bp\">.</span><span class=\"n\">ofByteArray</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n</code></pre></div>\n<p>However, if you try to mix both kinds of pattern, this seems to break:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">badMatch</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"s2\">\"Bad\"</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"bp\">.</span><span class=\"n\">ofByteArray</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"s2\">\"Eek\"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"c1\">-- unknown free variable `_fvar.149`</span>\n</code></pre></div>\n<p>Notably, this also occurs in previous versions of Lean (from v4.24.0, pre-Unicode scalar changes):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">badMatchOld</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"s2\">\"Bad\"</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">B'</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"s2\">\"Eek\"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"c1\">-- unknown free variable `_fvar.778`</span>\n</code></pre></div>\n<p>Am I just misusing these match statements? If so, if I do want to match for just a part of a string, how should I do so?</p>",
        "id": 555480144,
        "sender_full_name": "Alessandra Simmons",
        "timestamp": 1763078344
    },
    {
        "content": "<p>String having literal matching is hard-coded into the matcher code, along with the other kinds of literal matching:</p>\n<ul>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat#doc\">docs#Nat</a> literal matching</li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Int#doc\">docs#Int</a> literal matching</li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fin#doc\">docs#Fin</a> literal matching</li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=BitVec#doc\">docs#BitVec</a> literal matching</li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=String#doc\">docs#String</a> literal matching</li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Char#doc\">docs#Char</a> literal matching</li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=UInt8#doc\">docs#UInt8</a> literal matching</li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=UInt16#doc\">docs#UInt16</a> literal matching</li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=UInt32#doc\">docs#UInt32</a> literal matching</li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=UInt64#doc\">docs#UInt64</a> literal matching</li>\n</ul>\n<p>You can see the list at <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.isMatchValue#doc\">docs#Lean.Meta.isMatchValue</a> and it's used to determine which values get a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.Match.Pattern.val#doc\">docs#Lean.Meta.Match.Pattern.val</a></p>",
        "id": 555483700,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763080228
    },
    {
        "content": "<p>Does the same problem occur with the other kinds of literals or is it just strings?</p>",
        "id": 555483747,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763080251
    },
    {
        "content": "<p>It does seem to also happen with other literals, for example Char and UInt8:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">charMatch</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">X'</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Char</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">A'</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"c1\">-- unknown free variable `_fvar.836`</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">uInt8Match</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">5</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">UInt8</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">UInt8</span><span class=\"bp\">.</span><span class=\"n\">ofBitVec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">ofFin</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"c1\">-- unknown free variable `_fvar.1026`</span>\n</code></pre></div>",
        "id": 555485728,
        "sender_full_name": "Alessandra Simmons",
        "timestamp": 1763081267
    },
    {
        "content": "<p>I think there's some point to made about this not being an intended use for match statements but at least it should give a cryptic error message</p>",
        "id": 555677591,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1763154211
    },
    {
        "content": "<p>Do you mind filing an issue?</p>",
        "id": 555677613,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1763154225
    },
    {
        "content": "<p>Sure, I filed an issue here: <a href=\"https://github.com/leanprover/lean4/issues/11186\">https://github.com/leanprover/lean4/issues/11186</a></p>",
        "id": 555692045,
        "sender_full_name": "Alessandra Simmons",
        "timestamp": 1763161727
    },
    {
        "content": "<p>I'm curious though, why isn't this intended? I match on constructors for every other type, so I'm not really sure why this wouldn't also be in-scope</p>",
        "id": 555692165,
        "sender_full_name": "Alessandra Simmons",
        "timestamp": 1763161801
    },
    {
        "content": "<p>they're special-cased to use the decidable equality instance instead of pattern matching normally</p>",
        "id": 555692407,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763161936
    },
    {
        "content": "<p>it only does it for literals of the types listed</p>",
        "id": 555692470,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763161979
    },
    {
        "content": "<p>the matcher maker machinery is set up to be able to do it for any type with decidable equality though</p>",
        "id": 555692557,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763162020
    }
]