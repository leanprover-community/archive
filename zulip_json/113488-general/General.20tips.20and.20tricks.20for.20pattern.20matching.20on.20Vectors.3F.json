[
    {
        "content": "<p>I keep running into issues when pattern matching using Mathlib's <code>::v</code> constructor, and stright up do not know how to match the empty vector. What are the recommended ways to pattern match Vectors?</p>",
        "id": 493488402,
        "sender_full_name": "AZMCode",
        "timestamp": 1736818014
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> ?</p>",
        "id": 493495124,
        "sender_full_name": "Jason Rute",
        "timestamp": 1736821252
    },
    {
        "content": "<p>Also, note that, unlike some ITPs, both <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Vector#doc\">docs#Vector</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.Vector#doc\">docs#List.Vector</a> are not inductively defined.  The first is an <code>Array</code> with a fixed length and the second is a <code>List</code> of fixed length.  So it may not make sense to write recursive definitions on either, which is what I assume you mean by pattern matching.</p>",
        "id": 493495129,
        "sender_full_name": "Jason Rute",
        "timestamp": 1736821255
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"819695\">AZMCode</span> has marked this topic as resolved.</p>",
        "id": 493639441,
        "sender_full_name": "Notification Bot",
        "timestamp": 1736877492
    },
    {
        "content": "<p>Why would it not make sense to write recursive definitions with List.Vector though? Aren't lists meant to be easily pattern-matchable? There <em>is</em> the proof in the way, but it looks like the ::v constructor takes care of that. What would be the preferred approach?</p>",
        "id": 493639542,
        "sender_full_name": "AZMCode",
        "timestamp": 1736877538
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"819695\">@AZMCode</span> I think it would be best for you to write a small example of the sort of function you would like to write with vectors.  (Make it clear which of the two vector types you are referring to.)  If you like, you can write it with the notation you think would be most natural, even if Lean doesn’t accept that, as long as it is clear what your meaning is.  Then one of us could show you an idiomatic way which works in Lean.</p>",
        "id": 493712189,
        "sender_full_name": "Jason Rute",
        "timestamp": 1736912196
    },
    {
        "content": "<p>Will do in a moment. My initial issue was with confusing the default Array backed vector for the List backed vector. List backed is probably what im looking for for the indices and dimensions, since they're probably small and meant to go along a recursive structure.</p>\n<p>The thing I'm trying to build, as an exercise (I don't know if something similar already exists, probably tho), is an N-Dimensional vector implemented via nested Vectors. Accesed via a Vector index and dimensioned according to another Vector.</p>\n<p>I feel a particularly clean way to implement this would be via recursive functions, since the structure itself is recursive. Ive found the issues trying to pattern match on these indices and dimensions.Will post the specific code soon.</p>",
        "id": 493971968,
        "sender_full_name": "AZMCode",
        "timestamp": 1736959685
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">nestedVectorTy</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">d</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">dim</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">dim</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">        </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">dp</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">hdim</span><span class=\"w\"> </span><span class=\"bp\">::ᵥ</span><span class=\"w\"> </span><span class=\"n\">tdim</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">nestedVectorTy</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"n\">hdim</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">tdim</span>\n<span class=\"w\">        </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\">     </span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\">             </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">t</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">NVector</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">d</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">dim</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">    </span><span class=\"n\">toNestedVector</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">nestedVectorTy</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"n\">dim</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Currently the compilation error is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">invalid</span><span class=\"w\"> </span><span class=\"n\">patterns</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"ss\">`tdim</span><span class=\"bp\">`</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"n\">explicit</span><span class=\"w\"> </span><span class=\"n\">pattern</span><span class=\"w\"> </span><span class=\"kn\">variable</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">but</span><span class=\"w\"> </span><span class=\"n\">it</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"n\">occurs</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">positions</span><span class=\"w\"> </span><span class=\"n\">that</span><span class=\"w\"> </span><span class=\"n\">are</span><span class=\"w\"> </span><span class=\"n\">inaccessible</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">pattern</span><span class=\"w\"> </span><span class=\"n\">matching</span>\n<span class=\"w\">  </span><span class=\"n\">dp</span><span class=\"bp\">.</span><span class=\"n\">succ</span>\n\n<span class=\"w\">  </span><span class=\"bp\">⟨</span><span class=\"n\">hdim</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"o\">(</span><span class=\"n\">tdim</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">⋯⟩</span>\n</code></pre></div>",
        "id": 493976684,
        "sender_full_name": "AZMCode",
        "timestamp": 1736960984
    },
    {
        "content": "<p>You might check <code>Mathlib.Data.Holor</code> for related work. (It has not been used since it was written in 2018, to my knowledge.)</p>",
        "id": 494030171,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1736980923
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"819695\">@AZMCode</span>, please check <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>. e.g. your code block above is missing imports.</p>",
        "id": 494030282,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1736980993
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"115715\">Jason Rute</span> has marked this topic as unresolved.</p>",
        "id": 494031220,
        "sender_full_name": "Notification Bot",
        "timestamp": 1736981516
    },
    {
        "content": "<p>Adding one possible import, you can simply do this by writing your function for <code>List</code> and then using <code>dim.toList</code> (which is <code>O(1)</code>) to extract the list:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">nestedVectorTy_aux</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">dim</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">hdim</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">tdim</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">nestedVectorTy_aux</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"n\">hdim</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">tdim</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\">           </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">t</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">nestedVectorTy</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">d</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">dim</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">nestedVectorTy_aux</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"n\">dim</span><span class=\"bp\">.</span><span class=\"n\">toList</span>\n</code></pre></div>",
        "id": 494031658,
        "sender_full_name": "Jason Rute",
        "timestamp": 1736981753
    },
    {
        "content": "<p>(Also, why is the return value using <code>Vector</code>, but the input is using <code>List.Vector</code>?  Or is this in the imports that you didn't include?)</p>",
        "id": 494031662,
        "sender_full_name": "Jason Rute",
        "timestamp": 1736981757
    },
    {
        "content": "<p>A more interesting example would be where you write a function from <code>List.Vector</code> to <code>List.Vector</code>.  Here are two examples in the Mathlib code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">reverse</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">⟨</span><span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">toList</span><span class=\"bp\">.</span><span class=\"n\">reverse</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"bp\">⟩</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">insertIdx</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">⟨</span><span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"bp\">.</span><span class=\"n\">insertIdx</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">length_insertIdx</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">split</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">omega</span><span class=\"bp\">⟩</span>\n</code></pre></div>\n<p>Notice, these just work by computing the output on the underlying list and then also including a proof that the output length is as intended.  In the first case <code>simp</code> was enough to give the proof.  In the second case, one has to give a more manual proof.</p>",
        "id": 494033394,
        "sender_full_name": "Jason Rute",
        "timestamp": 1736982539
    },
    {
        "content": "<blockquote>\n<p>(Also, why is the return value using <code>Vector</code>, but the input is using <code>List.Vector</code>? Or is this in the imports that you didn't include?)</p>\n</blockquote>\n<p>I assumed it would better optimize if the multidimensional array was in a compact representation rather than a linked list. Not as good as compacting the multiple dimensions in a single array, but close enough for a first prototype.</p>\n<p>Yes, i did omit the Mathlib import, my bad. Will make sure not to do that in future questions.</p>\n<blockquote>\n<p>Notice, these just work by computing the output on the underlying list and then also including a proof that the output length is as intended. In the first case <code>simp</code> was enough to give the proof. In the second case, one has to give a more manual proof.</p>\n</blockquote>\n<p>Would these not introduce an additional runtime check on the length of the lists?</p>\n<blockquote>\n<p>You might check <code>Mathlib.Data.Holor</code> for related work. (It has not been used since it was written in 2018, to my knowledge.)</p>\n</blockquote>\n<p>Assuming by the lack of usage, I assume nested Vectors are recommended for small and fixed dimensions? Kind of an unruly notation to carry around for even relatively small numbers of dimensions. Is there another more compact notation?</p>\n<p>Also, I appreciate the Math pointers. I come from a Software Engineering perspective, so I have little maths knowledge as of now. Sure seems interesting!</p>",
        "id": 494040283,
        "sender_full_name": "AZMCode",
        "timestamp": 1736986456
    },
    {
        "content": "<p>BTW, I deeply appreciate the pointers. Just getting started here so the feedback is amazing. Thanks.</p>",
        "id": 494040328,
        "sender_full_name": "AZMCode",
        "timestamp": 1736986487
    },
    {
        "content": "<p>From this I gather pattern matching on vectors directly is discouraged, so I'll make sure to steer clear, however, in my google searches I haven't found this particular error before, about <code>Inaccessible location in pattern matching</code>. What does that mean precisely? Is it just about visibility protections, or something more interesting?</p>",
        "id": 494040706,
        "sender_full_name": "AZMCode",
        "timestamp": 1736986698
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"819695\">AZMCode</span> <a href=\"#narrow/stream/113488-general/topic/General.20tips.20and.20tricks.20for.20pattern.20matching.20on.20Vectors.3F/near/494040283\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>Notice, these just work by computing the output on the underlying list and then also including a proof that the output length is as intended. In the first case <code>simp</code> was enough to give the proof. In the second case, one has to give a more manual proof.</p>\n</blockquote>\n<p>Would these not introduce an additional runtime check on the length of the lists?</p>\n</blockquote>\n<p>No, because at compile time you have already proved what the length of the list is, so you don’t need to compute it at runtime.  Yay for proofs!</p>",
        "id": 494053256,
        "sender_full_name": "Jason Rute",
        "timestamp": 1736993629
    },
    {
        "content": "<p>While it looks like a List.Vector has two parts, the List and the proof, the proof isn’t actually included in the machine code.  So it is just a List in machine code.</p>",
        "id": 494053955,
        "sender_full_name": "Jason Rute",
        "timestamp": 1736994082
    }
]