[
    {
        "content": "<p>I would like to consider the type of all functions f from the subsets of {1, ... ,n} (for some n) to a set A; in other words, the type <code>Σ n, set (fin n) → α</code> There is a natural partial order on this type, where <code>f ≤ g</code> if and only if <code>f.1 ≤ g.1</code>, and <code>f.2</code> is a 'restriction' of <code>g.2</code> to <code>set (fin f.1)</code> in the natural way. </p>\n<p>I can't seem to do this, however, without running into heterogeneous equality. Here is a MWE. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">col</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">Σ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">partial_order</span> <span class=\"o\">(</span><span class=\"n\">col</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">le</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">c</span> <span class=\"n\">c'</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">c.1</span> <span class=\"bp\">≤</span> <span class=\"n\">c'.1</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">c.2</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">c'.2</span> <span class=\"o\">(</span><span class=\"n\">fin.cast_le</span> <span class=\"n\">h</span> <span class=\"bp\">''</span> <span class=\"n\">s</span><span class=\"o\">),</span>\n  <span class=\"n\">le_refl</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">rfl.le</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">congr</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">fin.cast_le_of_eq</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">}⟩,</span>\n  <span class=\"n\">le_trans</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">rintros</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">⟨</span><span class=\"n\">h1</span><span class=\"o\">,</span><span class=\"n\">h1'</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">h2</span><span class=\"o\">,</span><span class=\"n\">h2'</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">h1.trans</span> <span class=\"n\">h2</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h1'</span><span class=\"o\">,</span><span class=\"n\">h2'</span><span class=\"o\">],</span>\n    <span class=\"n\">convert</span> <span class=\"n\">rfl</span> <span class=\"n\">using</span> <span class=\"mi\">2</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">fin.cast_le_comp_cast_le</span><span class=\"o\">],</span>\n    <span class=\"n\">apply</span> <span class=\"n\">set.image_comp</span> <span class=\"o\">,</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">le_antisymm</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n\n    <span class=\"n\">rintros</span> <span class=\"n\">c</span> <span class=\"n\">c'</span> <span class=\"o\">⟨</span><span class=\"n\">hle</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">hle'</span><span class=\"o\">,</span> <span class=\"n\">h'</span><span class=\"o\">⟩,</span>\n    <span class=\"k\">have</span> <span class=\"n\">h_eq</span> <span class=\"o\">:=</span> <span class=\"n\">hle.antisymm</span> <span class=\"n\">hle'</span><span class=\"o\">,</span>\n    <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">h_eq</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">h_eq</span><span class=\"o\">,</span>\n    <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n\n    <span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">    ⊢ ∀ (a : set (fin c.fst)) (a' : set (fin c'.fst)), a == a' → c.snd a == c'.snd a'</span>\n<span class=\"cm\">    -/</span>\n  <span class=\"kd\">end</span>  <span class=\"o\">}</span>\n</code></pre></div>\n<p>I did figure out how to resolve this goal, but from what I gather, it is preferable to avoid <code>==</code> altogether. Is there a design route that does this? I'm not fussy as long as it captures the (simple) mathematical object I'm considering.</p>",
        "id": 324051549,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1674826430
    },
    {
        "content": "<p>I think it's fine having <code>heq</code> in proofs, though sometimes eliminating it actually makes things simpler -- this is because sometimes the steps following a <code>heq</code> showing up are just to turn that <code>heq</code> back into an <code>eq</code>.</p>\n<p>The strategy I usually try to go for is to do <code>cases</code>/<code>subst</code> on relevant equalities from left-to-right so that <code>heq</code>s naturally become <code>eq</code>s.</p>\n<p>Here's a <code>heq</code>-free proof of <code>le_antisymm</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">partial_order</span> <span class=\"o\">(</span><span class=\"n\">col</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">le</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">c</span> <span class=\"n\">c'</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">c.1</span> <span class=\"bp\">≤</span> <span class=\"n\">c'.1</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">c.2</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">c'.2</span> <span class=\"o\">(</span><span class=\"n\">fin.cast_le</span> <span class=\"n\">h</span> <span class=\"bp\">''</span> <span class=\"n\">s</span><span class=\"o\">),</span>\n  <span class=\"n\">le_refl</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">rfl.le</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">congr</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">fin.cast_le_of_eq</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">}⟩,</span>\n  <span class=\"n\">le_trans</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">rintros</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">⟨</span><span class=\"n\">h1</span><span class=\"o\">,</span><span class=\"n\">h1'</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">h2</span><span class=\"o\">,</span><span class=\"n\">h2'</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">h1.trans</span> <span class=\"n\">h2</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h1'</span><span class=\"o\">,</span><span class=\"n\">h2'</span><span class=\"o\">],</span>\n    <span class=\"n\">convert</span> <span class=\"n\">rfl</span> <span class=\"n\">using</span> <span class=\"mi\">2</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">fin.cast_le_comp_cast_le</span><span class=\"o\">],</span>\n    <span class=\"n\">apply</span> <span class=\"n\">set.image_comp</span> <span class=\"o\">,</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">le_antisymm</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">rintros</span> <span class=\"o\">⟨</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">sc</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">c'</span><span class=\"o\">,</span> <span class=\"n\">sc'</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">hle</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">hle'</span><span class=\"o\">,</span> <span class=\"n\">h'</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">hle.antisymm</span> <span class=\"n\">hle'</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">true_and</span><span class=\"o\">,</span> <span class=\"n\">eq_self_iff_true</span><span class=\"o\">,</span> <span class=\"n\">heq_iff_eq</span><span class=\"o\">,</span> <span class=\"n\">sigma.mk.inj_iff</span><span class=\"o\">],</span>\n    <span class=\"n\">ext</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">fin.cast_le_of_eq</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">fin.cast_refl</span><span class=\"o\">,</span> <span class=\"n\">order_iso.refl_apply</span><span class=\"o\">,</span> <span class=\"n\">set.image_id'</span><span class=\"o\">],</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 324054823,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1674827270
    },
    {
        "content": "<p>I forgot to mention that part of the strategy is also to split open structures so that you get enough equalities between plain variables, which you need for <code>cases</code>/<code>subst</code> to work.</p>",
        "id": 324055274,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1674827396
    }
]