[
    {
        "content": "<p>This looks exciting. </p>\n<p>Your main example of a bridge, is an example of reflection in type theory, as it is used in the Rocq SSReflect language and the (huge) mathematical components library. Did you intend to capture the same concept ?</p>",
        "id": 568665163,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1768744519
    },
    {
        "content": "<p>This topic was moved here from <a class=\"stream-topic\" data-stream-id=\"113486\" href=\"/#narrow/channel/113486-announce/topic/doc-verification-bridge\">#announce &gt; doc-verification-bridge</a> by <span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span>.</p>",
        "id": 568681739,
        "sender_full_name": "Notification Bot",
        "timestamp": 1768758190
    },
    {
        "content": "<p>Thanks for the connection to SSReflect! I'm unfamiliar with the Rocq SSReflect language—could you point me to key references on how reflection is organized there? I'd be curious whether there's an existing taxonomy of theorem types that relates to what I'm trying to capture.</p>\n<p>To clarify the distinction I'm drawing: the \"bridging\" concept is specifically about connecting two fundamentally different kinds of formalization:</p>\n<ul>\n<li><strong>Mathematical</strong> (Prop-based): focused on <em>proving properties</em>—specifications that may not be computable</li>\n<li><strong>Computational</strong> (Bool-based): focused on <em>implementing functions</em> that have proven properties</li>\n</ul>\n<p>This is distinct from refinement <em>within</em> the mathematical world (e.g., abstract algebra → concrete representation, or high-level spec → low-level spec). Both sides remain in <code>Prop</code> for that kind of refinement.</p>\n<p>The Prop/Bool bridge is special because it crosses the specification/implementation divide—it is about connecting \"what should hold\" (a proposition) with \"how to check it\" (executable code). The tool's <strong>validates</strong> relationship specifically tracks which Bool functions have been proven correct against which Prop specifications. </p>\n<p>My motivation came from my own experience: after developing mathematical formalizations to support refinement-style proofs of a computational implementation, I found it difficult to track which properties of the implementation were actually verified and how the mathematical formalization supported that verification. I needed a way to assess progress and strategize what to focus on next—informed by which properties of the implementation are important to verify and which remain unverified.</p>\n<p>In the paper, I follow <span class=\"user-mention\" data-user-id=\"260921\">@Markus Himmel</span>'s framing from <a href=\"https://bobkonf.de/2026/himmel.html\">\"Proofs for Programs, Programs for Proofs\"</a>:</p>\n<ul>\n<li><strong>Validation bridges</strong>: <code>f x = true → P x</code> (computed results can be trusted)</li>\n<li><strong>Specification bridges</strong>: <code>P x → f x = true</code> (proofs can leverage <code>native_decide</code>)</li>\n</ul>\n<p>I'd love to learn more about how SSReflect/Mathematical Components organizes these patterns—are there papers or documentation that discuss their reflection methodology systematically?</p>",
        "id": 568699061,
        "sender_full_name": "Nicolas Rouquette",
        "timestamp": 1768776093
    },
    {
        "content": "<p>There's a book :-) <a href=\"https://math-comp.github.io/mcb/\">https://math-comp.github.io/mcb/</a></p>\n<p>There is a long history, but at least:<br>\nGonthier, G. (2005). A computer-checked proof of the Four Colour Theorem.<br>\nGonthier, G., Mahboubi, A., &amp; Tassi, E. (2008). A Small Scale Reflection extension for the Coq system.</p>",
        "id": 568703902,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1768781739
    }
]