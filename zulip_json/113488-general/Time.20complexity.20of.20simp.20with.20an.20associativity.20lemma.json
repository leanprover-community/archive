[
    {
        "content": "<p>What is the time complexity of simp when I run it with a single associativity lemma, say <code>add_assoc</code>? Clearly some simp lemmas will, abstractly speaking, loop infinitely if you run them (like running <code>add_comm</code> on <code>a + b</code>). But if I run <code>simp [add_assoc]</code> on some expression of length n, is it guaranteed to run in O(n) time?</p>",
        "id": 406609160,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1701977991
    },
    {
        "content": "<p>I had a <code>simp</code> call time out with an associativity lemma that i didn't expect to time out if it really was a linear time operation. This has left me wondering if there is room for some kind of <code>simp_assoc</code> lemma that simplifies in an asymptotically optimal way.</p>",
        "id": 406611296,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1701978904
    },
    {
        "content": "<p><code>assoc_rw</code>?</p>",
        "id": 406611707,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1701979059
    },
    {
        "content": "<p>Note that <code>simp [add_comm]</code> doesn't loop! <code>simp</code> has a detection against loops:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Nat.add_comm</span><span class=\"o\">]</span> <span class=\"c1\">-- no progress</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Nat.add_comm</span><span class=\"o\">]</span> <span class=\"c1\">-- rewrites once, then stops</span>\n</code></pre></div>",
        "id": 406612013,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1701979179
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113488-general/topic/Maximum.20complexity.20of.20simp.20with.20an.20associativity.20lemma/near/406611707\">said</a>:</p>\n<blockquote>\n<p><code>assoc_rw</code>?</p>\n</blockquote>\n<p>Potentially very cool! However I don't really understand what is meant by the docstring \"behaves like rewrite [h₀,← h₁] at ⊢ h₂ with the exception that associativity is used implicitly to make rewriting possible.\"</p>",
        "id": 406612373,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1701979293
    },
    {
        "content": "<p><code>simp only [add_assoc]</code> will rewrite using <code>add_assoc</code> eagerly starting at the leaves of the expression, and then moving outwards. So that is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n\\log(n))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">))</span></span></span></span>, I think?</p>",
        "id": 406612894,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1701979459
    },
    {
        "content": "<p>It seems like the <code>assoc_rw</code> tactic is less about simplification and more about being able to do other rewrites on a horribly parenthesized goal.</p>",
        "id": 406613010,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1701979521
    },
    {
        "content": "<p>Oh, no probably  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> if it's maximally associated in the other direction.</p>",
        "id": 406613163,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1701979581
    },
    {
        "content": "<p>Ok that's good to know, that could totally be causing the problem.</p>",
        "id": 406613393,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1701979692
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/stream/113488-general/topic/Maximum.20complexity.20of.20simp.20with.20an.20associativity.20lemma/near/406613163\">said</a>:</p>\n<blockquote>\n<p>Oh, no probably  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> if it's maximally associated in the other direction.</p>\n</blockquote>\n<p>Yeah that makes sense, because it first simplifies the left subtree, and then it needs an additional n steps to move the last addition to the other side.</p>",
        "id": 406613675,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1701979852
    },
    {
        "content": "<p>I wonder if there's a way of automatically identifying lemmas/lemma sets that have this property and making a simplification procedure for them that's linear time.</p>",
        "id": 406613804,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1701979915
    },
    {
        "content": "<p>what is the optimal strategy for doing the rewrites? <code>simp</code> also has capability to start rewriting the full term and only then going into subexpressions</p>",
        "id": 406613832,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1701979924
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">section</span>\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kn\">local</span> <span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"n\">Nat.add_assoc</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.Meta.Tactic.simp.rewrite</span> <span class=\"n\">true</span> <span class=\"k\">in</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">d</span> <span class=\"bp\">+</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"bp\">;</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- 6 rewrites</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kn\">local</span> <span class=\"n\">simp</span><span class=\"bp\">↓</span><span class=\"o\">]</span> <span class=\"n\">Nat.add_assoc</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.Meta.Tactic.simp.rewrite</span> <span class=\"n\">true</span> <span class=\"k\">in</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">d</span> <span class=\"bp\">+</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"bp\">;</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- 4 rewrites</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 406614001,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1701980032
    },
    {
        "content": "<p>Or shorter example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">set_option</span> <span class=\"n\">trace.Meta.Tactic.simp.rewrite</span> <span class=\"n\">true</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">d</span> <span class=\"bp\">+</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Nat.add_assoc</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- 6 rewrites</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">d</span> <span class=\"bp\">+</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">↓</span><span class=\"n\">Nat.add_assoc</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- 4 rewrites</span>\n</code></pre></div>",
        "id": 406614399,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1701980231
    },
    {
        "content": "<p>If my only simp lemma is <code>add_assoc</code>, I could </p>\n<ol>\n<li>Construct a binary tree of subexpressions where <code>+</code> is not the top level operation of any leaf</li>\n<li>Flatten the tree into a singly-linked list.</li>\n<li>Recursively search leaf subexpressions for more <code>+</code>.</li>\n</ol>\n<p>Which I think is linear time, at least if every thing is reference-oriented enough that I don't have to copy anything.</p>",
        "id": 406614611,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1701980344
    },
    {
        "content": "<p>This might be equivalent to always rewriting at the top of the syntax tree first and then working downwards.</p>",
        "id": 406615122,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1701980570
    },
    {
        "content": "<p><del>(Is that what <code>simp↓</code> does? I haven't seen that before)</del> <a href=\"https://github.com/leanprover/lean4/blob/c474dff38c401723226277240cd3baec0437de15/src/Init/Tactics.lean#L785\">Yes</a></p>",
        "id": 406615195,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1701980604
    },
    {
        "content": "<p>Hmm, <code>simp↓</code> is used exactly once in mathlib, it makes me wonder if there are efficiency gains we are missing out on.</p>",
        "id": 406616008,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1701981009
    },
    {
        "content": "<p>Worth investigating, for sure!</p>",
        "id": 406616057,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1701981037
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/stream/113488-general/topic/Maximum.20complexity.20of.20simp.20with.20an.20associativity.20lemma/near/406614399\">said</a>:</p>\n<blockquote>\n<p>Or shorter example:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">set_option</span> <span class=\"n\">trace.Meta.Tactic.simp.rewrite</span> <span class=\"n\">true</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">d</span> <span class=\"bp\">+</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Nat.add_assoc</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- 6 rewrites</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">d</span> <span class=\"bp\">+</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">↓</span><span class=\"n\">Nat.add_assoc</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- 4 rewrites</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>If you add <code>f</code> to the first expression, the number of rewrites goes up to 10. If you add <code>g</code> it goes up to 15.</p>",
        "id": 406616416,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1701981219
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113488-general/topic/Maximum.20complexity.20of.20simp.20with.20an.20associativity.20lemma/near/406616057\">said</a>:</p>\n<blockquote>\n<p>Worth investigating, for sure!</p>\n</blockquote>\n<p>For example, reading the documentation of <code>simp↓</code>, it seems like a no-brainer to me that a lemma like <code>mul_zero</code> should be <code>simp↓</code> rather than <code>simp</code>. Why should I simplify subexpressions when I am going to eliminate them anyway?</p>",
        "id": 406618584,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1701982265
    },
    {
        "content": "<p>And yet <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Int.mul_zero#doc\">docs#Int.mul_zero</a> seems to be <code>simp</code>, not <code>simp↓</code>. Why is this?</p>",
        "id": 406618618,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1701982282
    },
    {
        "content": "<p>In that case it might be worth trying out tagging some such lemmas across mathlib then spending some time thinking how to make <code>@[simp]</code> automatically decide how a lemma should be tagged.</p>",
        "id": 406619129,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1701982503
    },
    {
        "content": "<p>I mean I feel like any affine simplification that eliminates at least one subexpression should be <code>simp↓</code>, right? But aren't <code>simp</code> lemmas almost always affine anyway? I feel like you were the first one to point this out to me - that a rewrite lemma being affine is a good rule-of-thumb for if it should be <code>simp</code>.</p>",
        "id": 406619403,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1701982630
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"282271\">Bolton Bailey</span> <a href=\"#narrow/stream/113488-general/topic/Maximum.20complexity.20of.20simp.20with.20an.20associativity.20lemma/near/406618584\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113488-general/topic/Maximum.20complexity.20of.20simp.20with.20an.20associativity.20lemma/near/406616057\">said</a>:</p>\n<blockquote>\n<p>Worth investigating, for sure!</p>\n</blockquote>\n<p>For example, reading the documentation of <code>simp↓</code>, it seems like a no-brainer to me that a lemma like <code>mul_zero</code> should be <code>simp↓</code> rather than <code>simp</code>. Why should I simplify subexpressions when I am going to eliminate them anyway?</p>\n</blockquote>\n<p>Does that matter much? If my expression is <code>x * 0</code>, then presumably there is little (nothing) to simplify in <code>0</code>, and I don't see why it matters whether I simplify with <code>mul_zero</code> first or simplify <code>x</code> first.<br>\nYou might be right that it's quicker (we don't visit <code>0</code> if we simplify with <code>↓mul_zero</code>), but I expect the gains to be tiny.</p>",
        "id": 406619539,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1701982686
    },
    {
        "content": "<p>Well the point is that <code>x</code> could be some huge expression that I could take forever to simplify, only to find out that it was eliminated anyway.</p>",
        "id": 406619771,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1701982790
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"282271\">Bolton Bailey</span> <a href=\"#narrow/stream/113488-general/topic/Maximum.20complexity.20of.20simp.20with.20an.20associativity.20lemma/near/406619403\">said</a>:</p>\n<blockquote>\n<p>I mean I feel like any affine simplification that eliminates at least one subexpression should be <code>simp↓</code>, right? But aren't <code>simp</code> lemmas almost always affine anyway?</p>\n</blockquote>\n<p>Yes, although I think a good deal of simp lemmas (maybe half? maybe a third?) don't eliminate any subexpression but instead shuffle things around.</p>",
        "id": 406619881,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1701982818
    },
    {
        "content": "<p>Oh wait, you're saying <code>mul_zero</code>, not <code>add_zero</code>. You're right.</p>",
        "id": 406619892,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1701982822
    },
    {
        "content": "<p>Maybe what I'm not understanding is the reason leaf-first is the default to begin with.</p>",
        "id": 406619919,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1701982834
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113488-general/topic/Maximum.20complexity.20of.20simp.20with.20an.20associativity.20lemma/near/406619881\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"282271\">Bolton Bailey</span> <a href=\"#narrow/stream/113488-general/topic/Maximum.20complexity.20of.20simp.20with.20an.20associativity.20lemma/near/406619403\">said</a>:</p>\n<blockquote>\n<p>I mean I feel like any affine simplification that eliminates at least one subexpression should be <code>simp↓</code>, right? But aren't <code>simp</code> lemmas almost always affine anyway?</p>\n</blockquote>\n<p>Yes, although I think a good deal of simp lemmas (maybe half? maybe a third?) don't eliminate any subexpression but instead shuffle things around.</p>\n</blockquote>\n<p>Yeah, clicking around in the grep, this seems to be the case.</p>",
        "id": 406620168,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1701982920
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"282271\">Bolton Bailey</span> <a href=\"#narrow/stream/113488-general/topic/Maximum.20complexity.20of.20simp.20with.20an.20associativity.20lemma/near/406619919\">said</a>:</p>\n<blockquote>\n<p>Maybe what I'm not understanding is the reason leaf-first is the default to begin with.</p>\n</blockquote>\n<p>You might want to investigate how complicated simp calls work in eg category theory. Usually, you can only simplify a function call only once you know its input is of a certain shape.</p>",
        "id": 406620894,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1701983217
    },
    {
        "content": "<p>Ok thinking about it more, I think I see the reason it's sometimes better to go leaf-first: Some simp lemmas like <code>sub_self</code> reference an input twice, and so we would like to normalize the subexpressions to make it more likely that the lemma fires the first time we investigate it.</p>",
        "id": 406621065,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1701983311
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"282271\">Bolton Bailey</span> <a href=\"#narrow/stream/113488-general/topic/Maximum.20complexity.20of.20simp.20with.20an.20associativity.20lemma/near/406618584\">said</a>:</p>\n<blockquote>\n<p>For example, reading the documentation of <code>simp↓</code>, it seems like a no-brainer to me that a lemma like <code>mul_zero</code> should be <code>simp↓</code> rather than <code>simp</code>. Why should I simplify subexpressions when I am going to eliminate them anyway?</p>\n</blockquote>\n<p>Btw, what documentation did you read?</p>",
        "id": 406621366,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1701983454
    },
    {
        "content": "<p>I guess I don't understand how <code>simp↓</code> works? If I make <code>mul_zero</code> a <code>simp↓</code> lemma and then I simplify an expression <code>a * b</code> with <code>mul_zero</code> and a bunch of other leaf-first lemmas, is <code>mul_zero</code> investigated again each time <code>b</code> changes?</p>",
        "id": 406621398,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1701983471
    },
    {
        "content": "<p>Even with something like <code>mul_zero</code> you get more hits if you simplify the leaves first. You might have <code>a * b</code> when going down, and <code>b</code> might simplify to <code>0</code>.</p>",
        "id": 406621417,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1701983484
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/stream/113488-general/topic/Maximum.20complexity.20of.20simp.20with.20an.20associativity.20lemma/near/406621366\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"282271\">Bolton Bailey</span> <a href=\"#narrow/stream/113488-general/topic/Maximum.20complexity.20of.20simp.20with.20an.20associativity.20lemma/near/406618584\">said</a>:</p>\n<blockquote>\n<p>For example, reading the documentation of <code>simp↓</code>, it seems like a no-brainer to me that a lemma like <code>mul_zero</code> should be <code>simp↓</code> rather than <code>simp</code>. Why should I simplify subexpressions when I am going to eliminate them anyway?</p>\n</blockquote>\n<p>Btw, what documentation did you read?</p>\n</blockquote>\n<p>The docstring itself here <a href=\"https://github.com/leanprover/lean4/blob/c474dff38c401723226277240cd3baec0437de15/src/Init/Tactics.lean#L785\">https://github.com/leanprover/lean4/blob/c474dff38c401723226277240cd3baec0437de15/src/Init/Tactics.lean#L785</a></p>\n<p>Sometimes searching github works better than searching <a href=\"https://leanprover-community.github.io/mathlib4_docs/\">https://leanprover-community.github.io/mathlib4_docs/</a></p>",
        "id": 406621502,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1701983523
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"282271\">Bolton Bailey</span> <a href=\"#narrow/stream/113488-general/topic/Maximum.20complexity.20of.20simp.20with.20an.20associativity.20lemma/near/406621398\">said</a>:</p>\n<blockquote>\n<p>I guess I don't understand how <code>simp↓</code> works? If I make <code>mul_zero</code> a <code>simp↓</code> lemma and then I simplify an expression <code>a * b</code> with <code>mul_zero</code> and a bunch of other leaf-first lemmas, is <code>mul_zero</code> investigated again each time <code>b</code> changes?</p>\n</blockquote>\n<p>I expect (but wanted to read in some documentation), that it will visit the expression both before and after simplifying leaves (and not any time in between), but I'm not sure.</p>",
        "id": 406621654,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1701983599
    },
    {
        "content": "<p>Ah, the documentation of the simp attribute (not the simp tactic) mentions <code>↓</code>.</p>",
        "id": 406621702,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1701983629
    },
    {
        "content": "<p>There's definitely a fundamental problem where if I have both <code>↓mul_zero</code> and <code>↓zero_mul</code> and I am simplifying <code>a * b</code>, I have no a-priori reason to think <code>a</code> is more likely to simplify to zero than <code>b</code>, so whichever I simplify first, there is only a 50%-50% shot that I simplify the one which speeds things up for me.</p>",
        "id": 406622415,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1701983966
    },
    {
        "content": "<p>I expect that if you have <code>a * b</code> and neither <code>a</code> nor <code>b</code> is definitionally equal to <code>0</code>, then it doesn't matter whether you use <code>↓</code>. Neither of them will be tried after you simplify only one of the arguments (at least, that is what I strongly suspect).</p>",
        "id": 406622834,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1701984131
    },
    {
        "content": "<p>Well, wouldn't I be imposing an additional initial check on every application of <code>simp</code> to a goal with a top level <code>*</code> though? I would be sacrificing a lot of time over the whole library to make a few applications faster.</p>",
        "id": 406623568,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1701984455
    },
    {
        "content": "<p>No, I expect not, through the magic of discrimination trees. If your expression is <code>a * b</code> where neither <code>a</code> nor <code>b</code> is reducibly-defeq to <code>0</code>, then <code>mul_zero</code> and <code>zero_mul</code> will not even be considered.</p>",
        "id": 406623736,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1701984533
    },
    {
        "content": "<p>I was very confused that the following example simplifies using <code>Nat.mul_zero</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hb</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">↓</span><span class=\"n\">Nat.mul_zero</span><span class=\"o\">,</span> <span class=\"n\">hb</span><span class=\"o\">]</span><span class=\"bp\">;</span>\n  <span class=\"c1\">-- goal: ⊢ 0 = c</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>But I figured it out: <code>simp</code> by default does multiple passes on your expression, as long as it changes. If you disable that, then <code>Nat.mul_zero</code> is not used to simplify (as I expected):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hb</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">(</span><span class=\"n\">config</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">singlePass</span> <span class=\"o\">:=</span> <span class=\"n\">true</span><span class=\"o\">})</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">↓</span><span class=\"n\">Nat.mul_zero</span><span class=\"o\">,</span> <span class=\"n\">hb</span><span class=\"o\">]</span><span class=\"bp\">;</span>\n  <span class=\"c1\">-- goal: ⊢ a * 0 = c</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>My take-aways</p>\n<ul>\n<li>If you make a lemma a pre-simp lemma (i.e. with <code>↓</code>), then it will be (using the default settings) also used as a post-simp lemma (i.e. a normal simp-lemma), since it will simplify in the second pass.</li>\n<li>However, all other post-simp lemmas will be applied before the pre-simp lemma will be tried on the second pass, so there might still be a small performance boost to make it <em>also</em> a post-simp lemma.</li>\n<li>I think it is worth investigating to make all simp-lemmas that eliminate a variable also a pre-simp lemma. Maybe that improves performance a bit.</li>\n</ul>",
        "id": 406627344,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1701986199
    },
    {
        "content": "<p>and indeed, using <code>set_option trace.Debug.Meta.Tactic.simp true</code> Lean will tell you</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">Debug.Meta.Tactic.simp</span><span class=\"o\">]</span> <span class=\"n\">no</span> <span class=\"n\">theorems</span> <span class=\"n\">found</span> <span class=\"n\">for</span> <span class=\"n\">pre</span><span class=\"bp\">-</span><span class=\"n\">rewriting</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">c</span>\n</code></pre></div>\n<p>so there should be no performance loss by making <code>mul_zero</code> a pre-simp lemma.</p>",
        "id": 406627443,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1701986256
    },
    {
        "content": "<p>wtf is a \"pre-simp\" lemma? and where do I read about it?</p>",
        "id": 406630652,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1701987705
    },
    {
        "content": "<p>In the docstrings of the code in the lean4 github repository, <a href=\"#narrow/stream/113488-general/topic/Maximum.20complexity.20of.20simp.20with.20an.20associativity.20lemma/near/406621502\">apparently</a> <span aria-label=\"smiling devil\" class=\"emoji emoji-1f608\" role=\"img\" title=\"smiling devil\">:smiling_devil:</span>.</p>",
        "id": 406630828,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1701987790
    },
    {
        "content": "<p>Thanks. <span aria-label=\"mind blown\" class=\"emoji emoji-1f92f\" role=\"img\" title=\"mind blown\">:mind_blown:</span></p>",
        "id": 406631077,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1701987921
    },
    {
        "content": "<p>I would also like to express that I would like to read something that would give me an in-depth description of how the simplifier works, including this \"discrimination tree magic\", and how it relates to the precise order in which nodes of the syntax tree are examined and which order lemmas are applied in.</p>",
        "id": 406631814,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1701988345
    },
    {
        "content": "<p>\"Discrimination tree\" is a little hard to google explanations for, <a href=\"https://citeseerx.ist.psu.edu/document?repid=rep1&amp;type=pdf&amp;doi=da8bc301ca4407624315312ac5b15f2f3d40b5a3\">here</a> is what I eventually found.</p>",
        "id": 406631930,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1701988420
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> Could I interest you to come up with some heuristics to use for marking things as <code>simp↓</code> based on your investigations, and maybe we could get a linter out of it?</p>",
        "id": 406720433,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1702027839
    },
    {
        "content": "<p>alternatively, we could implement the heuristic in core, changing what <code>@[simp]</code> does. Might be worth a benchmark</p>",
        "id": 406720767,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1702027973
    },
    {
        "content": "<p>I am curious too, so I went and made <a href=\"https://github.com/leanprover-community/mathlib4/pull/8895\">#8895</a> to test out adding some pre-simps to one file. Do I need special permission to use the !bench command, or can I just use it?</p>",
        "id": 406722500,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1702028715
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Time.20complexity.20of.20simp.20with.20an.20associativity.20lemma/near/406720433\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> Could I interest you to come up with some heuristics to use for marking things as <code>simp↓</code> based on your investigations, and maybe we could get a linter out of it?</p>\n</blockquote>\n<p>I think further investigation is needed, e.g. marking 1-10 lemmas as <code>simp↓</code> and benchmarking that.<br>\nOh, Bolton did just that. I'll remark further on that PR.</p>",
        "id": 406741965,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1702035731
    },
    {
        "content": "<p>Actually, let me continue here.</p>\n<p>Looking at the changes, this looks like a <code>-2.114%</code> decrease in simp-time across the whole library.</p>\n<p>That is <em>huge</em> for marking 12 lemmas as <code>simp↓</code>, since most <code>simp</code>-calls will not involve these lemmas (even though the bot thinks it's not significant).<br>\nI don't know what the uncertainty is for these percentages (maybe we should add another test making ~100 more simp-lemmas presimp), but it seems that this heuristic has merit.</p>",
        "id": 406742279,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1702035883
    },
    {
        "content": "<p>I don't know if I have time for this soon, so if <span class=\"user-mention\" data-user-id=\"282271\">@Bolton Bailey</span> is willing to continue this investigation, you have my blessing!</p>",
        "id": 406742331,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1702035908
    },
    {
        "content": "<p>I think 2% is typical noise for the simp metric, based on <a href=\"http://speed.lean-fro.org/mathlib4/repo-detail/e7b27246-a3e6-496a-b552-ff4b45c7236e?zoomXStart=1701761005913.0867&amp;zoomXEnd=1702098000000&amp;dimensions=build%3Asimp&amp;dayEquidistant=true\">the recent history</a></p>",
        "id": 406744014,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1702036730
    },
    {
        "content": "<p>well, the average deviation seems to be more like 1%</p>",
        "id": 406744367,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1702036866
    },
    {
        "content": "<p>If you can figure out a stand-alone benchmark for something like this, please suggest one! The biggest issue with the various submetrics in the <code>build</code> benchmark is that we don't have instruction counts for them, which usually has ~100x less noise than time metrics.</p>",
        "id": 406747024,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1702037916
    },
    {
        "content": "<p>Does collecting heartbeats decrease noise?</p>",
        "id": 406747273,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1702038042
    },
    {
        "content": "<p>Or is that just a \"time metric\"</p>",
        "id": 406747306,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1702038055
    },
    {
        "content": "<p>Heartbeats I would hope is completely deterministic but I have no idea whether it is a good metric. Perhaps like instructions it can at least be used to judge whether a time regression is \"reasonable\". And we could feasibly measure it for subtasks like simp, yes.</p>",
        "id": 406747652,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1702038213
    },
    {
        "content": "<p>Perhaps it's even feasible to measure instructions per subtask, I haven't looked into that before</p>",
        "id": 406747689,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1702038232
    },
    {
        "content": "<p>why wouldn't it be a good metric? For <code>simp</code> it seems like it would be a very direct correlation</p>",
        "id": 406748096,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1702038377
    },
    {
        "content": "<p>are you concerned about loops that don't allocate?</p>",
        "id": 406748169,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1702038409
    },
    {
        "content": "<p>We did have such a bug at least once before, yes. But more generally, code changes that affect real time but not (as much) heartbeats.</p>",
        "id": 406748239,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1702038442
    },
    {
        "content": "<p>we can just collect both metrics</p>",
        "id": 406748269,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1702038458
    },
    {
        "content": "<p>probably a better use of metrics than the thousands of single-file benchmarks</p>",
        "id": 406748373,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1702038488
    },
    {
        "content": "<p>Another question: does <code>simp</code> cache failures to simplify? I'm wondering whether tagging lemmas with <code>@[simp↓, simp high]</code> might be worth it to try them both going down and first when going up. But if failures are not cached, this might be expensive (especially with multiple passes).</p>",
        "id": 406748439,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1702038510
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/stream/113488-general/topic/Time.20complexity.20of.20simp.20with.20an.20associativity.20lemma/near/406742331\">said</a>:</p>\n<blockquote>\n<p>I don't know if I have time for this soon, so if <span class=\"user-mention silent\" data-user-id=\"282271\">Bolton Bailey</span> is willing to continue this investigation, you have my blessing!</p>\n</blockquote>\n<p>I'm happy to keep looking into it, though I feel I may be shooting into the dark since I am not familiar with this benchmarking framework. I agree with <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> that it would be nice to have a less-noisy/deterministic benchmark to look at so I can know what is noise and what is meaningful.</p>\n<p>My strategy for the PR was very simple so far, since at this point my understanding of the  internal workings of simp is pretty minimal. I looked for any simp lemmas that didn't have any Prop argument and only referenced variables once, and made them pre-simp if they eliminated a variable and didn't duplicate any other variables.</p>",
        "id": 406756970,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1702041488
    },
    {
        "content": "<p>Yes, that sounds like a good strategy. <br>\nI see you made a new commit, that is good. Hopefully we can make the signal big enough that it's clearly bigger than any noise.</p>",
        "id": 406778718,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1702048332
    },
    {
        "content": "<p>Seems the new commit isn't any faster than what we started with <span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span>. I wouldn't want to go much further marking all these lemmas by hand, so I recommend postponing this investigation until we either have a less noisy speed metric or until I/someone writes a script to identify good pre-simp candidates.</p>",
        "id": 407063177,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1702210801
    }
]