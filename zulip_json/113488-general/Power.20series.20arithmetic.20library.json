[
    {
        "content": "<p>Discussion thread for <a href=\"#narrow/channel/113486-announce/topic/Power.20series.20arithmetic.20library/with/555238332\">Power series arithmetic library</a> about the <a href=\"https://github.com/girving/series\">series</a> library.</p>",
        "id": 555238651,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1762988486
    },
    {
        "content": "<p>Since the library has generic Newton solvers in place, it is straightforward to add new verified operations that build on top of Newton solves and therefore have optimal time complexity (Newton steps double precision, and thus solves are linear time). For example, one typically implements <code>exp</code> on series via a Newton solve on terms of <code>log</code>, and <code>log</code> is easy too (via integral of inverse).</p>",
        "id": 555238984,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1762988662
    },
    {
        "content": "<p>Can you say to what extent <code>native_decide</code> is used here?</p>",
        "id": 555241160,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1762989977
    },
    {
        "content": "<p>For example, in <a href=\"https://github.com/girving/bottcher/blob/66851ffbca467cfbaf857531efdc737e968547d3/Bottcher/Actual.lean#L21\">this Mandelbrot area bound</a>: The rest of the lines reduce the proof to evaluating <code>spray 256</code>, which is three nested layers of power series Newton solvers on top of Dyadic arithmetic using Karatsuba multiplication and such. I haven't made any effort to make it work with <code>decide +kernel</code>, but there's nothing fundamental blocking it other than \"<code>native_decide</code> is faster\".</p>",
        "id": 555241326,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1762990081
    },
    {
        "content": "<p>Ah, actually it's very array heavy, and possibly arrays interact very badly with the kernel? If the kernel treats them as lists then the complexity would jump by a quadratic factor.</p>",
        "id": 555241505,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1762990228
    },
    {
        "content": "<p>Yeah, to my understanding the kernel treats arrays as lists, but I'd be a bit surprised if they can't be folded away? </p>\n<p>Is Karatsuba multiplication implemented in Lean here? I'm slightly surprised that that's faster than the default, which would use GMP for multiplying large integers, and is probably very heavily optimised in C already</p>",
        "id": 555241700,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1762990347
    },
    {
        "content": "<p>Karatsuba for power series, not for Nat: <a href=\"https://github.com/girving/series/blob/6627b8572f4f5628acdc2d6c265e5569bcf1f28c/Series/Series/Mul.lean#L36\">https://github.com/girving/series/blob/6627b8572f4f5628acdc2d6c265e5569bcf1f28c/Series/Series/Mul.lean#L36</a></p>",
        "id": 555241765,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1762990393
    },
    {
        "content": "<p>It's quite possible that multiplication could be rewritten into a kernel-friendly form. A general principle is that the library is very layered: Newton, inverse, sqrt do not know in any way that multiplication uses Karatsuba.</p>",
        "id": 555242047,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1762990544
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> <a href=\"#narrow/channel/113488-general/topic/Power.20series.20arithmetic.20library/near/555241700\">said</a>:</p>\n<blockquote>\n<p>Yeah, to my understanding the kernel treats arrays as lists</p>\n</blockquote>\n<p>yes</p>",
        "id": 555242286,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1762990677
    },
    {
        "content": "<p>That makes sense, thanks! The extensibility here is very neat :)</p>",
        "id": 555242956,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1762991070
    },
    {
        "content": "<p>So Karatsuba on a list would be very slow, but Karatsuba on a specific binary tree data structure (splitting top-down) would be very clean and should be kernel friendly. If there is demand signal I could implement this.</p>",
        "id": 555243567,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1762991529
    },
    {
        "content": "<p>The downside is that the Series data structure is then hand-chosen to fit the multiplication operation, but every operation simpler than multiply is trivial and every operation more complex treats multiply as a black box, so it would be okay. Of course, if one later wanted FFT multiply it would need to be rewritten.</p>",
        "id": 555243703,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1762991628
    },
    {
        "content": "<p>There already exists a kernel efficient array structure with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.RArray#doc\">docs#Lean.RArray</a> though it is mostly built for reflection proofs at the moment.</p>",
        "id": 555243780,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1762991679
    },
    {
        "content": "<p>My guess is that unless RArray is power-of-two specific, it would be easier given the Karatsuba context to do it custom.</p>",
        "id": 555244051,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1762991878
    },
    {
        "content": "<p>Hmm, actually RArray is really close to perfect, so maybe I do just want RArrays with some invariant about them stored separately.</p>",
        "id": 555244993,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1762992394
    },
    {
        "content": "<p>You would also need to prove some theory about it given that this is currently non existent</p>",
        "id": 555246945,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1762993556
    },
    {
        "content": "<p>I guess it might be interesting to have an abstract notion of an <code>Array</code> with similar axioms as the <a href=\"https://smt-lib.org/theories-ArraysEx.shtml\">SMT-LIB</a> array theory so people can write programs that abstract about runtime and kernel efficient arrays? Not sure</p>",
        "id": 555247093,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1762993648
    },
    {
        "content": "<p>That might be useful separate from this, but here Karatsuba has a recursive structure related to power-of-two-sized chunks, so the adjusted multiply routine would be recursing directly on the tree structure rather than using an abstract Array-like API.</p>",
        "id": 555289096,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1763021540
    },
    {
        "content": "<p>That looks very nice. How does it relate to the porting effort of exact real numbers from Rocq to Lean?<br>\nI believe they are working both on the old corn real numbers and the faster type class based ones.<br>\n<a href=\"http://arxiv.org/abs/1105.2751\">http://arxiv.org/abs/1105.2751</a></p>\n<p>In speed it will likely be incomparable, since Lean is using (unverified) GMP.</p>",
        "id": 555350812,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1763039349
    },
    {
        "content": "<p>This library is power series on top of whatever kind of scalar arithmetic one wants, assuming it has an <code>Approx</code> instance saying it approximates your designed mathematical scalar type. So I don’t think it is closely related to exact real numbers.</p>",
        "id": 555351335,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1763039472
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"514145\">Geoffrey Irving</span> <a href=\"#narrow/channel/113486-announce/topic/Power.20series.20arithmetic.20library/near/555238332\">said</a>:</p>\n<blockquote>\n<p>I proved it correct, then tested it, and the tests did not work</p>\n</blockquote>\n<p>Just want to say I love the Knuth reference</p>",
        "id": 555437424,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1763060954
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span>  Here's all the ring operations in a hopefully kernel-friendly form, using a data structure similar to <code>RArray</code> but specialised to power-of-two sizes. </p>\n<p><a href=\"https://gist.github.com/girving/db7a31fe4df064f4a9aba76927cab14a\">https://gist.github.com/girving/db7a31fe4df064f4a9aba76927cab14a</a></p>\n<p>The proofs of correctness are way simpler than for the array version, since everything is more natural functional programming. I think I'll probably switch the whole library to this, but I'll need to do various translation first.</p>",
        "id": 555689174,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1763160025
    },
    {
        "content": "<p>Nearly all of the case analysis logic was written by Sonnet 4.5 against Sonnet 4.5-written unit tests, and then I put the correctness proofs in place after the fact.</p>",
        "id": 555689408,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1763160188
    }
]