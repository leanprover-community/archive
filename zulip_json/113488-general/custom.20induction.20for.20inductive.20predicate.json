[
    {
        "content": "<h2>Motivation</h2>\n<p>I read the example about palindromes on the official Lean website.<br>\nThere, in order to prove propositions about an inductive predicate called <code>Palindrome</code>, they constructed an induction principle specifically for <code>Palindrome</code>.</p>\n<p>In code, it looks like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">grind</span><span class=\"kd\">]</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Palindrome</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Palindrome</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">single</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Palindrome</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">sandwich</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Palindrome</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Palindrome</span><span class=\"w\"> </span><span class=\"o\">([</span><span class=\"n\">a</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">])</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">palindrome_ind</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">[])</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">single</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">])</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">sandwich</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">([</span><span class=\"n\">a</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">b</span><span class=\"o\">]))</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">nil</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">single</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">a₁</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">a₂</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">as'</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">palindrome_ind</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"n\">single</span><span class=\"w\"> </span><span class=\"n\">sandwich</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a₂</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">as'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">dropLast</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a₂</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">as'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">dropLast</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a₂</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">as'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">getLast</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">a₁</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a₁</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">a₂</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">as'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">dropLast_concat_getLast</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"bp\">▸</span><span class=\"w\"> </span><span class=\"n\">sandwich</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">ih</span>\n<span class=\"n\">termination_by</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"bp\">.</span><span class=\"n\">length</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"bp\">.</span><span class=\"n\">reverse</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Palindrome</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">palindrome_ind</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">grind</span>\n</code></pre></div>\n<p>This is quite cumbersome.<br>\nI thought it would be convenient if we could automatically generate induction principles for inductive predicates as well.</p>\n<h2>Question</h2>\n<p>Lean has <em>functional induction</em>, and for recursive functions it can automatically generate induction principles.<br>\nSo I thought that, when an inductive predicate can be written as a recursive function, we could rewrite it as such and obtain an induction principle that way. I tried this approach, and it worked.</p>\n<p>For <code>Palindrome</code>, it looks like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"kn\">scoped</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"w\"> </span><span class=\"k\">in</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">PalindromeRec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">a₁</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">a₂</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a₂</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">dropLast</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a₂</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">getLast</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">)</span>\n\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">a₁</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a₁</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">a₂</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">dropLast_concat_getLast</span><span class=\"o\">]</span>\n\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">a₁</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"n\">PalindromeRec</span><span class=\"w\"> </span><span class=\"n\">xs</span>\n<span class=\"w\">    </span><span class=\"k\">else</span>\n<span class=\"w\">      </span><span class=\"n\">false</span>\n<span class=\"n\">termination_by</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"bp\">.</span><span class=\"n\">length</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"bp\">.</span><span class=\"n\">reverse</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Palindrome</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">PalindromeRec</span><span class=\"bp\">.</span><span class=\"n\">induct</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">grind</span>\n</code></pre></div>\n<p>I think this is a good approach, but it only applies to inductive predicates that can be rewritten as recursive functions.<br>\nIf an inductive predicate cannot be rewritten as a recursive function, is the only option to write the induction principle by hand?</p>",
        "id": 563621588,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1765633105
    },
    {
        "content": "<h2>Addendum</h2>\n<p>I recently realized that <em>functional induction</em> is actually useful not only for recursive functions, but also for <strong>inductive predicates that can be rewritten as recursive functions</strong>.<br>\nThank you for introducing functional induction. It turned out to be far more useful than I initially thought.</p>",
        "id": 563621803,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1765633316
    },
    {
        "content": "<p>What about the <code>Palindrome.rec</code>?</p>",
        "id": 563621917,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765633449
    },
    {
        "content": "<p>oh I guess you can only use it when you know it's a palindrome?</p>",
        "id": 563621964,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765633483
    },
    {
        "content": "<p>Then I don't see how this works in general</p>",
        "id": 563622044,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765633556
    },
    {
        "content": "<p>Isn't it the case that every inductive predicate can be rewritten as recursive function? Although, proving termination in case of a function might be cumbersome (and might require passing some additional objects around).</p>",
        "id": 563630767,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765642137
    },
    {
        "content": "<p>I see — you did say this right at the beginning, but I skipped to the code and missed it — this is an induction principle especially for <em>proving</em> that something is a <code>Palindrome</code>. Usually induction principles go the other way.</p>\n<p>I would say that you're right, <code>List.palindrome_ind</code> could naturally be defined via a function that checks whether something is a palindrome. Joachim (who implemented functional induction) has said before that a convenient way to build an induction principle is to define a recursive function that has the shape you want.</p>",
        "id": 563632692,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1765644037
    },
    {
        "content": "<p>If it were possible to use the pattern</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">isPalindrome</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">True</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">True</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">b</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">isPalindrome</span><span class=\"w\"> </span><span class=\"n\">as</span>\n</code></pre></div>\n<p>then you'd get the exact induction principle you want through functional induction. However, the third one isn't a valid pattern in Lean.</p>",
        "id": 563632947,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1765644227
    },
    {
        "content": "<p>Hm, but unlike <code>PalindromeRec</code>, <code>List.palindrome_ind</code> doesn't check <code>a₁ = x</code>. So there is some difference here.</p>",
        "id": 563632987,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765644257
    },
    {
        "content": "<p>Right, it's setting up the induction for <em>proving</em> palindromes, that's the difference I was re-emphasizing</p>",
        "id": 563633432,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1765644679
    },
    {
        "content": "<p>That doesn't mean that it proves lists are palindromes itself.</p>",
        "id": 563633449,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1765644704
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"626349\">@Asei Inoue</span> Another equivalent approach to <code>List.palindrome_ind</code> is to define the inductive predicate with <code>List.palindrome_ind</code> as its recursor, then prove it's always true, like so:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">grind</span><span class=\"kd\">]</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Palindrome</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Palindrome</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">single</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Palindrome</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">sandwich</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Palindrome</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Palindrome</span><span class=\"w\"> </span><span class=\"o\">([</span><span class=\"n\">a</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">])</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">grind</span><span class=\"kd\">]</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">IsPalindromeAux</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsPalindromeAux</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">single</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsPalindromeAux</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">sandwich</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsPalindromeAux</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsPalindromeAux</span><span class=\"w\"> </span><span class=\"o\">([</span><span class=\"n\">a</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">b</span><span class=\"o\">])</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">IsPalindromeAux</span><span class=\"bp\">.</span><span class=\"n\">trivial</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsPalindromeAux</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">nil</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">single</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">a'</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">as'</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">trivial</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a'</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">as'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">dropLast</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a'</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">as'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">getLast</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a'</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">as'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">dropLast</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">b</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">a'</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">as'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">dropLast_concat_getLast</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"bp\">▸</span><span class=\"w\"> </span><span class=\"n\">sandwich</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">ih</span>\n<span class=\"n\">termination_by</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"bp\">.</span><span class=\"n\">length</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"bp\">.</span><span class=\"n\">reverse</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Palindrome</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">IsPalindromeAux</span><span class=\"bp\">.</span><span class=\"n\">trivial</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">grind</span>\n</code></pre></div>",
        "id": 563633618,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1765644892
    },
    {
        "content": "<p>Just to check that indeed it has the expected recursor:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">pp</span><span class=\"bp\">.</span><span class=\"n\">proofs</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">IsPalindromeAux</span><span class=\"bp\">.</span><span class=\"n\">rec</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">IsPalindromeAux.rec {α : Type} {motive : (a : List α) → IsPalindromeAux a → Prop}</span>\n<span class=\"cm\">  (nil : motive [] IsPalindromeAux.nil)</span>\n<span class=\"cm\">  (single : ∀ (a : α), motive [a] (IsPalindromeAux.single a))</span>\n<span class=\"cm\">  (sandwich :</span>\n<span class=\"cm\">    ∀ (a b : α) (as : List α) (ih : IsPalindromeAux as),</span>\n<span class=\"cm\">      motive as ih → motive ([a] ++ as ++ [b]) (IsPalindromeAux.sandwich a b as ih))</span>\n<span class=\"cm\">  {a✝ : List α} (t : IsPalindromeAux a✝) : motive a✝ t</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>(There's a small complexity where the <code>IsPalindromeAux</code> proof itself is passed along as an additional argument, but that doesn't change anything.)</p>",
        "id": 563633959,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1765645211
    },
    {
        "content": "<p>Hmm, so I guess we can view functional induction as something that takes a recursive induction, creates an equivalent inductive predicate for it, and does structural induction on it.</p>",
        "id": 563637040,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765648380
    }
]