[
    {
        "content": "<p>The standard library now provides typeclasses representing order structures<br>\nsuch as preorders, partial orders and linear orders. This post serves as a short introduction, but hopefully long enough that you feel qualified to give your opinion. I hope you like it, but now would be the best time to make adjustments if something was wrong with the design.</p>\n<p>Given an <code>LE α</code> instance, there are a few new propositional typeclasses:</p>\n<ul>\n<li><code>IsLinearOrder α</code> is the proposition that <code>≤</code> satisfies the axioms of a linear order.</li>\n<li>Similarly <code>IsPreorder</code>, <code>IsLinearPreorder</code> and <code>IsPartialOrder</code>.</li>\n<li><code>LawfulOrderLT</code> is the proposition that <code>LT α</code> is \"compatible\" with <code>LE α</code>.</li>\n<li><code>LawfulOrderOrd</code> is the proposition that <code>Ord α</code> is \"compatible\" with <code>LE α</code>.</li>\n<li>Similarly for <code>BEq</code>, <code>Min</code> and <code>Max</code>.</li>\n</ul>\n<p>As you can see, everything is centered around <code>LE</code> -- I'll explain the reasons below.</p>\n<p>More fine-grained instances such as <code>Std.Antisymm</code> remain. <code>IsLinearOrder</code><br>\nentails many of them and lemmas are free to only require a few axioms for the sake of<br>\ngenerality if they do not need a full linear order.</p>\n<p>The factories <code>LinearOrderPackage.ofLE α</code> or <code>LinearOrderPackage.ofOrd α</code> make it<br>\nconvenient to provide <code>LE α</code>, <code>LT α</code>, <code>Ord α</code>, <code>Min α</code>, <code>Max α</code>, <code>BEq α</code>,<br>\n<code>IsLinearOrder α</code> and other useful instances.</p>\n<p>For the motivation behind this design, see below -- but let us look at an example first.</p>\n<p><strong>Creating a linear order with as many operations as possible</strong></p>\n<p>You can try the following <a href=\"https://live.lean-lang.org/#project=lean-nightly&amp;codez=JYOwJgrgxgLsBuBTABAEQIYE9kHcAWiATogFDLIA+yAtgPYiXIwQpU6JiMx4SMBmhYIwDO6GCIggSJAPQBaAIRpEfUCgBU6EJnXIABgHlCYPQBp9AFUJbhRk8i2c9AGXQ4+EADYBRAI529ZFBhGC0oRGFken0MTD0AOmQ5GWlg0JBw5AAuZDs0LGyAXmRhWkJCTBI0sJQcgGUYMHirGzzYopKyiqqQEJrs5Aam13cvPzaCrOLS8srZRRIACXR4UABzZDAVNScA809EcQhI9AgYWmoxYCh0T09sLcEkfWdvMxeLd70AWVAv7/QAA9Ao59AAhPx6EjoSLsO4OSIwTAAB0QUE8MOEEWQxAxcBAG24iGo8RIyWkPT6GVqg0a8WcanQhDsRAACugoABrdBrFDtKbIeK0PgTObyBQkABytBwuBQeBWKFuniiqOscHoJ3EtAghE2wGEyNoohVoIVz0QIB1azwyAO1EuiNoyGRhFoz246xOACMdeIidQsmSUiREID0NRkQdkAAKMCAQIJNoAggk2gGCCAaxACUsbw8ZTOQTyEAJkTJ7MxvBJ9MFlMlsCp7MFxO1quFMi0poHAD6MGsvWQuZTFdT0jDEajKDjibAKbrGawZYHA0LAB5SznK0ua2mG5tE6vZ1M20N4p4YJ3hZ3T+e+Jf5Xn+5WR+HI9HJ8m55gd1ALsimShC9OyDFCe4iACmEu7IPu+atuQx7fpGf6dogviXjAQA\">in Lean 4 Web on the latest nightly</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Day</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mon</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">tue</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">wed</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">thu</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">fri</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">sat</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">sun</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">! Define *any* `Ord`, `TransOrd` and `LawfulEqOrd` instances on `Day`. -/</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ord</span><span class=\"w\"> </span><span class=\"n\">Day</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">TransOrd</span><span class=\"w\"> </span><span class=\"n\">Day</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">LawfulEqOrd</span><span class=\"w\"> </span><span class=\"n\">Day</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">!</span>\n<span class=\"cm\">Having defined `Ord`, let us automatically derive `LE`, `LT`, `Min`, `Max` and `BEq`</span>\n<span class=\"cm\">as well as typeclasses relating them.</span>\n<span class=\"cm\">-/</span>\n\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">LinearOrderPackage</span><span class=\"w\"> </span><span class=\"n\">Day</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">ofOrd</span><span class=\"w\"> </span><span class=\"n\">Day</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">!</span>\n<span class=\"cm\">Now we have all operations at our disposal and have enough lemmas to prove things about them:</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">d₁</span><span class=\"w\"> </span><span class=\"n\">d₂</span><span class=\"w\"> </span><span class=\"n\">d₃</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Day</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h₁₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">d₁</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">d₂</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h₂₃</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">d₂</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">d₃</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">d₁</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">d₃</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">le_trans</span><span class=\"w\"> </span><span class=\"n\">h₁₂</span><span class=\"w\"> </span><span class=\"n\">h₂₃</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">d₁</span><span class=\"w\"> </span><span class=\"n\">d₂</span><span class=\"w\"> </span><span class=\"n\">d₃</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Day</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h₁₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">d₁</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">d₂</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h₂₃</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">d₂</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">d₃</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">d₁</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">d₃</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">lt_of_lt_of_le</span><span class=\"w\"> </span><span class=\"n\">h₁₂</span><span class=\"w\"> </span><span class=\"n\">h₂₃</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">d₁</span><span class=\"w\"> </span><span class=\"n\">d₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Day</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">compare</span><span class=\"w\"> </span><span class=\"n\">d₁</span><span class=\"w\"> </span><span class=\"n\">d₂</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">lt</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">d₁</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">d₂</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">compare_eq_lt</span>\n</code></pre></div>\n<p>The factory <code>LinearOrderFactory.ofOrd</code> uses auto-param magic to provide sensible defaults for all instances where possible. If it is not able to automatically derive some instance, it explains to the user in an error message what is missing and how to provide it manually. If any of the data-carrying instances (<code>LT</code>, <code>LE</code>, <code>Min</code>, ...) already exists, the factory will prefer the pre-existing one over generating a new one that might not be definitionally equal.</p>\n<p>A good example for how to use the new classes in lemma signatures is <code>List.min?_eq_some_iff</code>. Its signature was:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">max</span><span class=\"bp\">?</span><span class=\"n\">_eq_some_iff</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Max</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LE</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">anti</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std.Antisymm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">le_refl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">max_eq_or</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">max_le_iff</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">xs.max</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>\n<p>Its new signature is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">max</span><span class=\"bp\">?</span><span class=\"n\">_eq_some_iff</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Max</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LE</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsLinearOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">LawfulOrderMax</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">xs.max</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>\n<p><strong>Motivation</strong></p>\n<p>Previously, talking about linear orders using the standard library was tedious and<br>\nthere was no unified way to do it. Different lemmas in the standard<br>\nlibrary used seemingly different sets of hypotheses that were equivalent to<br>\nhaving a linear order.</p>\n<p>There are multiple data-carrying typeclasses for different basic operations:<br>\n<code>LE</code>, <code>LT</code>, <code>BEq</code>, <code>Ord</code>, <code>Min</code> and <code>Max</code>.</p>\n<p>One solution would be to use exactly the same approach like Mathlib, providing<br>\ntypeclasses like <code>LinearOrder</code> which bundle all applicable operations and certain laws<br>\nabout them.</p>\n<p>But the standard library has different requirements than Mathlib.<br>\nMany programming tasks only require a few of these operations and it is desirable<br>\nfor code to assume as few data-carrying instances as necessary.<br>\nIt is also not always desirable to implement or generate all of them at once<br>\nbecause it is tedious and generating them automatically might produce inefficient<br>\nimplementations that cannot easily be replaced downstream.<br>\nEven if some operations are (still) missing, it should be possible to talk about<br>\nlinear orders.</p>\n<p>The given design is a compromise: It requires an <code>LE</code> instance in order to say<br>\nwhat a linear order is, but other operations may or may not be present.</p>\n<p>Another pain point is that it's tedious to construct linear orders and all instances<br>\none may want for them. The <code>LinearOrderPackage.of*</code> factories make this more convenient.</p>\n<p><strong>Mathlib integration</strong></p>\n<p>Right now, <code>IsLinearOrder</code> (etc.) coexists independently from Mathlib's <code>LinearOrder</code>.</p>\n<p>While the details need to be discussed, it should be relatively easy to make them compatible:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- cannot cause diamonds because `IsLinearOrder α` is a proposition</span>\n<span class=\"kd\">instance</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLinearOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"c1\">-- translate Mathlib's formulation of the axioms</span>\n</code></pre></div>\n<p>It might make sense to move lemmas such as <code>Std.le_trans</code> into the global<br>\nnamespace, replacing the corresponding lemmas in Mathlib.</p>\n<p>(EDIT: removed workaround in the example after nightly landed)</p>",
        "id": 537826289,
        "sender_full_name": "Paul Reichert",
        "timestamp": 1757063498
    },
    {
        "content": "<ul>\n<li>I would have expected <code>LawfulOrderLT</code> to be called <code>LawfulLT</code>.</li>\n<li>Here's a controversial question: do you want to allow using <code>max</code> and <code>min</code> for partial orders? I see that there is <code>Std.LawfulOrderInf</code> (with <code>min</code> as the operator), so I guess the answer is yes.</li>\n</ul>",
        "id": 537833820,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1757065923
    },
    {
        "content": "<p>I tend to think of <code>LawfulClass</code> as an intrinsic description when <code>Class</code> is to be considered lawful. However, <code>LawfulOrderLT</code> relates <code>LT</code> to the order data encoded in <code>LE</code>. Another option would be to call it <code>LawfulLELT</code>, but it doesn't convey the intent of the typeclass as well (and it looks weird). Also, <code>LawfulBEq</code> (another can of worms) already has a different meaning.</p>\n<p>Regarding <code>Min</code> and <code>Max</code>, yes, that's a difficult question. Mathlib also chose to use <code>min</code>/<code>max</code> for partial orders (<a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Order/Lattice.html#Prod.instMin_mathlib\"><code>Prod.instMin_mathlib</code></a>) and I believe it's the better choice: Practically, having a separate <code>Inf</code> class would require duplicating a lot of the API. But agreed that it can be misleading that it's called <code>min</code> and not <code>inf</code>!</p>",
        "id": 537836352,
        "sender_full_name": "Paul Reichert",
        "timestamp": 1757066828
    },
    {
        "content": "<p>I'd had the same thought about <code>LawfulLT</code>, and I think I'd still be in favour of this rename. I appreciate the point about it being a less principled name, but nevertheless less surprising.</p>",
        "id": 537839679,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1757068194
    },
    {
        "content": "<p>I think I was having a conversation just the other day about how nice it would be to make a similar change in Mathlib... it would be great if that happened, I feel.</p>",
        "id": 537892930,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1757085255
    },
    {
        "content": "<p>So this looks super to me :)</p>",
        "id": 537893096,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1757085312
    }
]