[
    {
        "content": "<p>Hi everyone, <br>\nI am trying to work with the Schwartz space from analysis.schwartz_space.<br>\nI want to produce small proofs such as 'f :  ùì¢(E, F) --&gt; x*f :  ùì¢(E, F)' and 'f: ùì¢(E, F) --&gt; f.fderiv: ùì¢(E, F)'.<br>\nUnfortunately, I already have issues with this proof, which makes me think I am setting up the proof incorrectly. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">fderiv_schwartz</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">schwartz_map</span> <span class=\"n\">‚Ñù</span> <span class=\"n\">‚ÑÇ</span>  <span class=\"o\">):</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">schwartz_map</span> <span class=\"n\">‚Ñù</span>  <span class=\"n\">‚ÑÇ</span> <span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>I would like to do something like this eventually </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">fourier_transform</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">schwartz_map</span>  <span class=\"n\">‚Ñù</span> <span class=\"n\">‚ÑÇ</span>  <span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">real.fourier_integral</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">schwartz_map</span>  <span class=\"n\">‚Ñù</span> <span class=\"n\">‚ÑÇ</span>  <span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Furthermore, I wanted to show that the Gaussian function is in the Schwartz space. <br>\nI have the proofs lemma gaussian_smooth:  cont_diff ‚Ñù ‚ä§ (Œª (x : ‚Ñù), exp (-x^2)) := <br>\nand lemma gaussian_decay (a:‚Ñù)  (ha: 0&lt;a):  ‚àÄ (k n : ‚Ñï), ‚àÉ (C : ‚Ñù), ‚àÄ x, ‚Äñx‚Äñ^k * ‚Äñiterated_fderiv ‚Ñù n (Œª (x : ‚Ñù), exp (-a*x^2)) x‚Äñ ‚â§ C :=<br>\nand def gaussian:=exp (x^2) (Not sure how to give it  right way to write the function )</p>\n<p>It does not complain with this set up, but I have a feeling that it perceives gaussian_smooth and gaussian_decay as functions, and not the proofs supporting gaussian. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">in_schwartz_map</span> <span class=\"o\">(</span> <span class=\"n\">gaussian</span> <span class=\"n\">gaussian_smooth</span> <span class=\"n\">gaussian_decay</span><span class=\"o\">:</span> <span class=\"n\">schwartz_map</span>  <span class=\"n\">‚Ñù</span> <span class=\"n\">‚ÑÇ</span>   <span class=\"o\">):</span> <span class=\"mi\">1</span><span class=\"bp\">=</span><span class=\"mi\">1</span><span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>I am just a little confused when it comes to structures. From my understanding, I need to give the arguments to_fun,smooth',decay', but when and where do I give these arguments. </p>\n<p>Kind regards,<br>\nSonia</p>",
        "id": 339554805,
        "sender_full_name": "rtertr (Sonia)",
        "timestamp": 1677936119
    },
    {
        "content": "<p>Hey! <code>schwartz_map ‚Ñù ‚ÑÇ</code> is a structure, so \"elements\" (understand, terms) of it are Schwartz functions. In particular, they are <em>not</em> functions <code>‚Ñù ‚Üí ‚ÑÇ</code>. There is a way to consider <code>f : schwartz_map ‚Ñù ‚ÑÇ</code> as a function <code>‚Ñù ‚Üí ‚ÑÇ</code>, namely by inserting a <em>coercion</em> to functions, <code>coe_fn</code>. If <code>f : schwartz_map ‚Ñù ‚ÑÇ</code>, then <code>‚áëf : ‚Ñù ‚Üí ‚ÑÇ</code> (but confusingly you have to let Lean insert the <code>‚áë</code> for you). The other way, proving that a function <code>f : ‚Ñù ‚Üí ‚ÑÇ</code>is a Schwartz function, amounts to constructing a <code>schwartz_map ‚Ñù ‚ÑÇ</code> whose <code>to_fun</code> field is defined as <code>f</code>.</p>",
        "id": 339555624,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1677936392
    },
    {
        "content": "<p>Here is a toy example to show that the zero map is a Schwartz map</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">schwartz_map</span> <span class=\"n\">‚Ñù</span> <span class=\"n\">‚ÑÇ</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n  <span class=\"n\">smooth'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"c1\">-- your proof of smoothness here</span>\n  <span class=\"n\">decay'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"o\">}</span> <span class=\"c1\">-- your proof of decay here</span>\n</code></pre></div>",
        "id": 339556013,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1677936532
    },
    {
        "content": "<p>Also, make sure to check out <a href=\"https://github.com/leanprover-community/mathlib/wiki/Code-in-backticks\">#backticks</a> for posting code on Zulip</p>",
        "id": 339556282,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1677936640
    },
    {
        "content": "<p>Okay, so I try to write : </p>\n<div class=\"codehilite\" data-code-language=\"example\"><pre><span></span><code> { to_fun := (Œª (x : ‚Ñù), exp (-x ^ 2)),\n  smooth' := gaussian_smooth,\n  decay' := gaussian_decay}\n</code></pre></div>\n<p>Then it says: </p>\n<p>type mismatch at field 'smooth''<br>\n  gaussian_smooth<br>\nhas type<br>\n  cont_diff ‚Ñù ‚ä§ (Œª (x : ‚Ñù), exp (-x ^ 2))<br>\nbut is expected to have type<br>\n  cont_diff ‚Ñù ‚ä§ (Œª (x : ‚Ñù), ‚Üë(exp (-x ^ 2)))</p>\n<p>and similarly for decay'. Is there a quick fix here? Is it the same as coe_fn?</p>",
        "id": 339557685,
        "sender_full_name": "rtertr (Sonia)",
        "timestamp": 1677937205
    },
    {
        "content": "<p>Hard to say! Can you follow the instructions at <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>?</p>",
        "id": 339558145,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1677937391
    },
    {
        "content": "<p>My guess is that you proved that <code>x ‚Ü¶ exp (- x ^ 2)</code> was smooth as a function <code>‚Ñù ‚Üí ‚Ñù</code> while Lean expects you to prove it's smooth as a function <code>‚Ñù ‚Üí ‚ÑÇ</code>.</p>",
        "id": 339558383,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1677937476
    },
    {
        "content": "<p>So I am trying to make a mwe, but it is taking some time <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> . But I saw you needed  to provide<br>\n<code>cont_diff ‚Ñù ‚ä§ self.to_fun</code> by definition, and so my proof is <code>cont_diff ‚Ñù ‚ä§ (Œª (x : ‚Ñù), exp (-x^2))</code> but yeah, I am not sure why it has ‚Ñù by definition :D</p>",
        "id": 339559991,
        "sender_full_name": "rtertr (Sonia)",
        "timestamp": 1677938158
    },
    {
        "content": "<p>So I tried to make it as small as possible. <br>\nThe decay proof has a sorry, because it was building upon other lemmas. </p>\n<div class=\"codehilite\" data-code-language=\"import\"><pre><span></span><code>import analysis.schwartz_space\nimport analysis.special_functions.exp_deriv\n\nnamespace real\n\nnoncomputable theory\n\nopen complex\n\nlemma gaussian_decay:  ‚àÄ (k n : ‚Ñï), ‚àÉ (C : ‚Ñù), ‚àÄ x, ‚Äñx‚Äñ^k * ‚Äñiterated_fderiv ‚Ñù n (Œª (x : ‚Ñù), exp (-x^2)) x‚Äñ ‚â§ C :=\nbegin\n  sorry,\nend\n\nlemma gaussian_smooth:  cont_diff ‚Ñù ‚ä§ (Œª (x : ‚Ñù), exp (-x^2)) :=\nbegin\n  have hid: cont_diff ‚Ñù ‚ä§ (Œª (x : ‚Ñù), x),\n    apply cont_diff_id,\n  have hsq: cont_diff ‚Ñù ‚ä§ (Œª (x : ‚Ñù), x^2),\n    apply cont_diff.pow hid (2:‚Ñï),\n  have hsqneg: cont_diff ‚Ñù ‚ä§ (Œª (x : ‚Ñù), -x^2),\n    apply cont_diff.neg hsq,\n  have hexp: cont_diff ‚Ñù ‚ä§ (Œª (x : ‚Ñù), exp x),\n    apply cont_diff.exp,\n    exact hid,\n  apply cont_diff.comp hexp hsqneg,\nend\n\nexample : schwartz_map ‚Ñù ‚ÑÇ :=\n{ to_fun := (Œª (x : ‚Ñù), exp (-x ^ 2)),\n  smooth' := gaussian_smooth,\n  decay' := gaussian_decay}\n\nlemma gaussian_smooth_2:  cont_diff ‚Ñù ‚ä§ (Œª (x : ‚Ñù), ‚Üë(exp (-x ^ 2))) :=  -- tried to make a new proof the way it was desired, but it would not recognize it, unfortunately.\nbegin\n  sorry,\nend\n\nend real\n</code></pre></div>",
        "id": 339563301,
        "sender_full_name": "rtertr (Sonia)",
        "timestamp": 1677939328
    },
    {
        "content": "<p>Yeah so the problem is exactly what I said. <code>gaussian_smooth</code> proves smoothness a function <code>‚Ñù ‚Üí ‚Ñù</code> and <code>smooth'</code> expects smoothness of the \"same\" function but as <code>‚Ñù ‚Üí ‚ÑÇ</code>.</p>",
        "id": 339563771,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1677939493
    },
    {
        "content": "<p>They are related by composing with the coercion <code>coe : ‚Ñù ‚Üí ‚ÑÇ</code>. So you can bridge the gap by using the fact that the compositiion of smooth functions is smooth. But I don't know where is the fact that the coercion is smooth.</p>",
        "id": 339563964,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1677939589
    },
    {
        "content": "<p>Okay, thank you so much! Would the statement then be <code>cont_diff ‚ÑÇ ‚ä§ (Œª (x : ‚Ñù), exp (-x^2))</code> instead? :D</p>",
        "id": 339566389,
        "sender_full_name": "rtertr (Sonia)",
        "timestamp": 1677940490
    },
    {
        "content": "<p>Yep, sounds like it.</p>",
        "id": 339566554,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1677940538
    },
    {
        "content": "<p>Thank you! :D</p>",
        "id": 339567015,
        "sender_full_name": "rtertr (Sonia)",
        "timestamp": 1677940674
    },
    {
        "content": "<p>But just one question, in the definition of the Schwartz space, it says you need to give a proof of <code>smooth' : cont_diff ‚Ñù ‚ä§ self.to_fun</code> so I think even if I show <code>cont_diff ‚ÑÇ ‚ä§ (Œª (x : ‚Ñù),  ‚Üëexp (-x^2))</code> I might still be in trouble</p>",
        "id": 339567475,
        "sender_full_name": "rtertr (Sonia)",
        "timestamp": 1677940828
    },
    {
        "content": "<p>Oh I might be wrong then. The best way for you to prove the right statement is to prove whatever the goal inside the <code>smooth'</code> field.</p>",
        "id": 339567605,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1677940885
    },
    {
        "content": "<p>ah, okay great! I will try that then :D Thank you again</p>",
        "id": 339567789,
        "sender_full_name": "rtertr (Sonia)",
        "timestamp": 1677940947
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"412682\">@Moritz Doll</span> will know how to address your issues I'm sure.</p>",
        "id": 339570377,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1677941998
    },
    {
        "content": "<p>Good morning. It is great to hear that you want to prove that the Fourier transform is a map from the Schwartz space to itself. This is a very nontrivial problem and I would suggest to start with the Gaussian, that should be way easier. <br>\nThe definition should be</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">gaussian</span> <span class=\"o\">:</span> <span class=\"bp\">ùì¢</span><span class=\"o\">(</span><span class=\"n\">‚Ñù</span><span class=\"o\">,</span> <span class=\"n\">‚Ñù</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">exp</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"o\">),</span>\n    <span class=\"n\">smooth'</span> <span class=\"o\">:=</span>\n    <span class=\"kd\">begin</span>\n      <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n    <span class=\"kd\">end</span><span class=\"o\">,</span>\n    <span class=\"n\">decay'</span> <span class=\"o\">:=</span>\n    <span class=\"kd\">begin</span>\n      <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n    <span class=\"kd\">end</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>As for the coercion, the <code>differentiable</code> version is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">complex.differentiable_at_coe</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">‚Ñù</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">differentiable_at</span> <span class=\"n\">‚Ñù</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">differentiable_at</span> <span class=\"n\">‚Ñù</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">‚ÑÇ</span><span class=\"o\">))</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"n\">complex.of_real_clm.differentiable_at.comp</span> <span class=\"n\">_</span> <span class=\"n\">hf</span>\n</code></pre></div>\n<p>and I think the <code>cont_diff</code> version is very similar (I haven't checked)</p>",
        "id": 339620122,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1677970532
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"590693\">@rtertr</span> Great to see someone else interested in this stuff! I've been working for a while myself on Fourier transforms, Poisson summation (which finally made it into mathlib a week or two back), etc. One of the goals of that project was to apply Poisson summation to the Gaussian, in order to get the transformation law for the Jacobi theta function (+ hence the functional equation of Riemann zeta). If you can prove that the Gaussian is in the Schwartz space (ideally the slightly more general statement that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy=\"false\">(</mo><mo>‚àí</mo><mi>a</mi><mo>‚àó</mo><msup><mi>x</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">exp( -a * x ^ 2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">x</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">(</span><span class=\"mord\">‚àí</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">‚àó</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> is Schwartz for any <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>&lt;</mo><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">0 &lt; a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6835em;vertical-align:-0.0391em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span>) then that would certainly be very useful for my project, so we should definitely coordinate.</p>",
        "id": 339684175,
        "sender_full_name": "David Loeffler",
        "timestamp": 1678017832
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"481963\">@David Loeffler</span>  Hi David,<br>\nThat sounds great! I am a third year undergraduate student trying to do my thesis on Fourier transforms in Lean. <br>\nRight now I have <br>\nlemma gaussian_decay (a:‚Ñù)  (ha: 0&lt;a):  ‚àÄ (k n : ‚Ñï), ‚àÉ (C : ‚Ñù), ‚àÄ x, ‚Äñx‚Äñ^k * ‚Äñiterated_fderiv ‚Ñù n (Œª (x : ‚Ñù), exp (-a*x^2)) x‚Äñ ‚â§ C<br>\nwith a few minor sorrys along the way. I would love to do some collaboration. I would just have to discuss it with my thesis advisor first probably :D</p>",
        "id": 339689128,
        "sender_full_name": "rtertr (Sonia)",
        "timestamp": 1678019972
    },
    {
        "content": "<p>Hi, I was thinking a bit about the Schwartz map. In LEAN, the maps goes between two real normed vector spaces, <br>\n[normed_add_comm_group E] [normed_space ‚Ñù E]. <br>\nI was wondering why does the field need to be ‚Ñù? I see that iterated fderiv and cont diff require a nontrivially normed field k.<br>\nCould the Schwartz space exist between [normed_add_comm_group E] [normed_space k E]? <br>\nKind regards</p>",
        "id": 358814617,
        "sender_full_name": "rtertr (Sonia)",
        "timestamp": 1684260880
    },
    {
        "content": "<p>Is this generalisation useful? E.g. if you take the field to be $\\mathbb{C}$, then the definitions make perfect sense, but I'm pretty sure that the resulting space is zero.</p>",
        "id": 358827236,
        "sender_full_name": "David Loeffler",
        "timestamp": 1684264494
    },
    {
        "content": "<p>Okay, interesting! Why would the space become zero?</p>",
        "id": 358958276,
        "sender_full_name": "rtertr (Sonia)",
        "timestamp": 1684322888
    },
    {
        "content": "<p>Liouville's theorem + Schwartz functions vanish at infinity</p>",
        "id": 358964418,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1684324825
    },
    {
        "content": "<blockquote>\n<p>Is this generalisation useful?</p>\n</blockquote>\n<p>It sounds like the generalization is useful to have in mathlib because it allows you to formally prove that mathematically it is not useful!</p>",
        "id": 358973793,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684327488
    },
    {
        "content": "<p>I disagree, we would have to keep repeating everywhere that we consider the real derivative, which is the only sensible choice. There are more general ways to phrase this and this should not clutter up the Schwartz space.</p>",
        "id": 358974549,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1684327687
    },
    {
        "content": "<p>(I was mostly joking <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span>)</p>",
        "id": 358974716,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684327739
    },
    {
        "content": "<p>oh sorry, I did not get that.</p>",
        "id": 358974840,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1684327773
    },
    {
        "content": "<p>yeah someone once joked about how it would be great to have modules over semirings and look what happened then :-/</p>",
        "id": 358977526,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1684328475
    },
    {
        "content": "<p>Hey, it let us unify the <code>nsmul</code> lemmas with <code>smul</code> lemmas everywhere, so I think that was maybe worth it!</p>",
        "id": 358985313,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684330463
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/Schwartz.20Space/near/358977526\">said</a>:</p>\n<blockquote>\n<p>yeah someone once joked about how it would be great to have modules over semirings and look what happened then :-/</p>\n</blockquote>\n<p>A professor of mine used to joke over giving a course on algebraically closed finite fields and prove all sort of wonderful properties, only to show in the last lecture that there aren't.</p>",
        "id": 358986004,
        "sender_full_name": "Giovanni Mascellani",
        "timestamp": 1684330660
    },
    {
        "content": "<p>Modules over semirings suffer from the fact that normal equivalences that are used in theory building don't hold - I'm thinking linear independence is broken right now, iirc</p>",
        "id": 358998872,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1684333664
    },
    {
        "content": "<p>But I don't see what's the issue with making schwartz spaces over all fields and then we just decide to only build the theory over R-VSs</p>",
        "id": 358999052,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1684333704
    },
    {
        "content": "<p>I don't see the issue of making groups over all notational symbols and then just asking the user to supply <code>*</code> every time they want to use <code>*</code> as a group law. But the people typing in the group theory theorems do.</p>",
        "id": 359002208,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1684334452
    },
    {
        "content": "<p>It's not about what is possible, it's about what people want to do in practice. This is why the mathematicians have to have the final word on questions such as this.</p>",
        "id": 359002573,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1684334547
    },
    {
        "content": "<p>I don‚Äôt think modules of semirings is the right analogy here, because even if the theory is not very developed there are still concrete examples where it allows for some code factorization. Here there is <em>absolutely nothing to say</em> about Schwartz maps over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span> because they are all zero. I don‚Äôt know anything about the p-adic case, but I would definitely argue in favor of sticking to real differentiable maps.</p>",
        "id": 359002591,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1684334551
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"268315\">@Anatole Dedecker</span> what's the definition? I can try and figure out the p-adic story. Maybe it will turn out to be terrifically interesting and then Eric is vindicated :-)</p>",
        "id": 359002844,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1684334613
    },
    {
        "content": "<p><a href=\"https://en.wikipedia.org/wiki/Schwartz_space\">https://en.wikipedia.org/wiki/Schwartz_space</a> or <a href=\"https://leanprover-community.github.io/mathlib_docs/find/schwartz_map\">docs#schwartz_map</a></p>",
        "id": 359005188,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1684335148
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"606744\">@Olivier Ta√Øbi</span> aren't these used by Jacquet-Langlands in the p-adic case? My memory is that this is the language they use, but when I tried to understand what they were doing I wondered whether they were just using it as an abbreviation for \"locally constant function\" or some such thing. Jacquet-Langlands never define the word IIRC.</p>",
        "id": 359009548,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1684336174
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/Schwartz.20Space/near/359002208\">said</a>:</p>\n<blockquote>\n<p>I don't see the issue of making groups over all notational symbols and then just asking the user to supply <code>*</code> every time they want to use <code>*</code> as a group law. But the people typing in the group theory theorems do.</p>\n</blockquote>\n<p>This would've been great - means we can state eckmann hilton easily! Reminds me of the theorems stated comparing two topologies, too :)</p>",
        "id": 359012773,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1684337017
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/Schwartz.20Space/near/359009548\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"606744\">Olivier Ta√Øbi</span> aren't these used by Jacquet-Langlands in the p-adic case? My memory is that this is the language they use, but when I tried to understand what they were doing I wondered whether they were just using it as an abbreviation for \"locally constant function\" or some such thing. Jacquet-Langlands never define the word IIRC.</p>\n</blockquote>\n<p>Usually what we call \"Schwartz space\" in the p-adic case is the space of locally constant functions with compact support. Then we have a nice Fourier transform on it. I don't think that there is a good notion of differentiable maps on totally disconnected groups with values in something like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span>. Now if we're talking p-adic maps on p-adic groups, that's another story...</p>",
        "id": 359014656,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1684337484
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"318709\">Sophie Morel</span> <a href=\"#narrow/stream/113488-general/topic/Schwartz.20Space/near/359014656\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/Schwartz.20Space/near/359009548\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"606744\">Olivier Ta√Øbi</span> aren't these used by Jacquet-Langlands in the p-adic case? My memory is that this is the language they use, but when I tried to understand what they were doing I wondered whether they were just using it as an abbreviation for \"locally constant function\" or some such thing. Jacquet-Langlands never define the word IIRC.</p>\n</blockquote>\n<p>Usually what we call \"Schwartz space\" in the p-adic case is the space of locally constant functions with compact support. Then we have a nice Fourier transform on it. I don't think that there is a good notion of differentiable maps on totally disconnected groups with values in something like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span>. Now if we're talking p-adic maps on p-adic groups, that's another story...</p>\n</blockquote>\n<p>Yes, and these are certainly enough for Jacquet-Langlands. There are also weaker notions (i.e. bigger spaces, more similar to the real case) that are useful, see <a href=\"https://arxiv.org/pdf/1410.2279v4.pdf\">what google found</a>.</p>",
        "id": 359015559,
        "sender_full_name": "Olivier Ta√Øbi",
        "timestamp": 1684337716
    },
    {
        "content": "<p>In case someone who is not familiar with p-adic functions follows Olivier's link: \"smooth\" in that context means \"locally constant\" !</p>",
        "id": 359016051,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1684337841
    },
    {
        "content": "<p>Exactly: the useful generalisation of Schwartz functions in the p-adic case is functions whose <em>source</em> is p-adic but whose <em>target</em> is real / complex. As Kevin, Sophie, and Olivier (knowing my mathematical tastes) will probably have guessed, this is a mathematical structure that I am personally extremely interested in and definitely would want mathlib to have in future. But this notion of p-adic Schwartz functions can't sensibly be gotten simply by making a general definition for an arbitrary normed field <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">k</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{k}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">k</span></span></span></span> which recovers the usual one for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span>, and then plugging in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">Q</mi><mi>p</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Q}_p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.975em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Q</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span> to this; it will need to be set up separately.</p>",
        "id": 359027055,
        "sender_full_name": "David Loeffler",
        "timestamp": 1684340832
    },
    {
        "content": "<p>There are also spaces of differentiable functions with p-adic source <em>and</em> target, which are important in p-adic Langlands theory and in Iwasawa theory ‚Äì this is the theory described in Colmez's lovely little monograph \"Fonctions d'une variable p-adique\". But these behave very differently from complex Schwartz functions, and the term \"Schwartz space\" is not usually used for them (\"locally analytic functions\" is the usual jargon).</p>",
        "id": 359028299,
        "sender_full_name": "David Loeffler",
        "timestamp": 1684341186
    },
    {
        "content": "<p>Just spelling it out for those who don't know the area: the point is that number theorists definitely want to consider functions <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><msub><mi mathvariant=\"double-struck\">Q</mi><mi>p</mi></msub><mo>‚Üí</mo><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">f:\\mathbb{Q}_p\\to\\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.975em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Q</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚Üí</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span> which are locally constant (this does not imply constant because <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">Q</mi><mi>p</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Q}_p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.975em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Q</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span> is a long way from being connected), but one cannot differentiate these functions in the usual manner because <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo>+</mo><mi>h</mi><mo stretchy=\"false\">)</mo><mo>‚àí</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">/</mi><mi>h</mi></mrow><annotation encoding=\"application/x-tex\">(f(x+h)-f(x))/h</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">h</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">‚àí</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">))</span><span class=\"mord\">/</span><span class=\"mord mathnormal\">h</span></span></span></span> doesn't typecheck (numerator is complex, denominator is p-adic). So we call them \"Schwarz functions\" (at least if they're compactly supported) but we're not using a generalisation of the mathlib definition, it's more like an analogy.</p>",
        "id": 359031685,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1684342089
    },
    {
        "content": "<p>Because JL never wrote down the definition I was never sure whether they were allowing locally constant functions which didn't have compact support but which were decaying sufficiently fast that the integral converged anyway; I have some pencil note about this on p1 of my copy of the book! This is one reason why I was interested in finding out what was actually going on.</p>",
        "id": 359032713,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1684342365
    },
    {
        "content": "<p>Definitely in Jacquet-Langlands theory (&amp; also in Tate's thesis, etc), one wants to allow non-compactly-supported, but L^1, functions from p-adic spaces to R. Integrating these functions is what gives you L-factors, and the failure of these functions to be compactly supported is exactly what makes the L-factors be non-trivial and interesting objects.</p>",
        "id": 359035415,
        "sender_full_name": "David Loeffler",
        "timestamp": 1684343075
    },
    {
        "content": "<p>Yes, they definitely show up in Tate. I was just wondering whether they were Schwarz functions :-) If we allow x/y to make sense if x is the complex number 0 and y is p-adic (and we let the quotient be 0), then probably they satisfy the definition :-)</p>",
        "id": 359036415,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1684343353
    },
    {
        "content": "<p>I believe you can prove JL (at least for GL_2) without L-functions, if you prove a trace formula which is not restricted to regular semi-simple support and prove transfer from D^x to GL_2(F) (the regular semi-simple version is easy, in general you need to consider Shalika germs, and so integrable functions on p-adic spaces).<br>\nIn Deligne's paper he uses Godement-Jacquet L-functions to show that there are only finitely many automorphic representations which are prescribed outside some finite set S of places, with no a priori bound on ramification at S. I forget if JL use a similar trick or prove transfer.</p>",
        "id": 359320380,
        "sender_full_name": "Olivier Ta√Øbi",
        "timestamp": 1684394110
    },
    {
        "content": "<p>(of course L-functions are interesting and essential for other reasons)</p>",
        "id": 359323552,
        "sender_full_name": "Olivier Ta√Øbi",
        "timestamp": 1684395582
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 359386625,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1684414089
    },
    {
        "content": "<blockquote>\n<p>I believe you can prove JL (at least for GL_2) without L-functions [...] (of course L-functions are interesting and essential for other reasons)</p>\n</blockquote>\n<p>Maybe we're talking slightly at cross-purposes here; I understood Kevin's reference to \"Jacquet-Langlands\" to mean the entire theory developed in Jacquet and Langlands' SLN 114 volume, whose primary goal (as they explicitly state in the introduction) is to establish analytic continuation + functional equation for GL2 automorphic L-functions. The theorem about functoriality between GL2 and quaternion algebras in section 16 of that book, which posterity happens to have assigned the name \"the Jacquet-Langlands theorem\", is explicitly described as an \"afterthought\" in their introduction.</p>\n<p>The suggestion that one might <em>only</em> be interested in L-functions as a tool for proving Langlands functoriality results seems quite bizarre to me ‚Äì personally, for me, the reverse is true: I'm only interested in Langlands functoriality if I can use it to help me prove theorems about L-functions!</p>\n<p>Anyway, I think we are all in agreement that (a) mathlib will definitely need to have some kind of p-adic Schwartz spaces in due course, but (b) their definition is sufficiently different from the real-analytic versions that they will need to be developed separately, so mechanically generalising the real-analytic theory with <code>[nontrivially_normed_field k]</code> everywhere is probably not useful.</p>",
        "id": 359478282,
        "sender_full_name": "David Loeffler",
        "timestamp": 1684437391
    }
]